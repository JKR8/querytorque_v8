# Schemas: Every Knowledge Engine Artifact

> **Status**: Target state specification
> **Every artifact has**: a schema, a template, and a validation step
> **Templates at**: `docs/knowledge_engine/templates/`

---

## Artifact Overview

| # | Artifact | Format | Template | Auto/Manual | Validation |
|---|----------|--------|----------|-------------|------------|
| 1 | BlackboardEntry | JSONL | Auto-generated by pipeline | Auto | Schema |
| 2 | AnalysisSession | Markdown | `templates/analysis_session.md` | Manual | Required sections |
| 3 | Finding | Markdown | `templates/finding.md` | Manual | Required fields |
| 4 | EngineProfile | Markdown | `templates/engine_profile_template.md` | Manual | `qt validate-profile` |
| 5 | GoldExample | JSON | `templates/gold_example_template.json` | Manual | `qt validate-example` |
| 6 | DetectionRule | JSON | See `05_DETECTION_AND_MATCHING.md` | Manual | `qt validate-rules` |
| 7 | FeatureVector | Dict | Computed at runtime | Auto | Vocabulary |

---

## 1. BlackboardEntry (JSONL — Auto-Generated)

One line of JSONL per optimization attempt. See `02_BLACKBOARD.md` for full context.

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "BlackboardEntry",
  "description": "One optimization outcome — JSONL format, append-only",

  "type": "object",
  "required": ["id", "source", "base", "outcome", "transforms", "provenance", "version"],

  "properties": {
    "id": {
      "type": "string",
      "description": "Unique: {query_id}_{worker_id}_{date}",
      "examples": ["q88_w2_20260211"]
    },

    "source": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": {
          "type": "string",
          "enum": ["4w_worker", "plan_scanner", "expert_session"]
        }
      }
    },

    "base": {
      "type": "object",
      "required": ["query_id", "engine", "benchmark", "timestamp", "run_id"],
      "properties": {
        "query_id": { "type": "string" },
        "engine": { "type": "string", "enum": ["duckdb", "postgresql"] },
        "benchmark": { "type": "string" },
        "original_sql": { "type": "string" },
        "fingerprint": { "type": "string" },
        "timestamp": { "type": "string", "format": "date-time" },
        "run_id": { "type": "string" }
      }
    },

    "opt": {
      "type": "object",
      "properties": {
        "approach": { "type": "string", "enum": ["4w_worker", "plan_scanner", "config_tuning"] },
        "worker_id": { "type": ["integer", "null"] },
        "strategy": { "type": "string" },
        "iteration": { "type": "integer", "default": 0 },
        "optimized_sql": { "type": ["string", "null"] },
        "examples_used": { "type": "array", "items": { "type": "string" } },
        "engine_profile_version": { "type": "string" }
      }
    },

    "outcome": {
      "type": "object",
      "required": ["status", "speedup", "speedup_type"],
      "properties": {
        "status": { "type": "string", "enum": ["WIN", "IMPROVED", "NEUTRAL", "REGRESSION", "ERROR", "FAIL"] },
        "tier": { "type": "string", "enum": ["CRITICAL_HIT", "WIN", "IMPROVED", "NEUTRAL", "REGRESSION", "ERROR"] },
        "speedup": { "type": "number" },
        "speedup_type": { "type": "string", "enum": ["measured", "vs_timeout_ceiling", "both_timeout"] },
        "timing": {
          "type": "object",
          "properties": {
            "original_ms": { "type": "number" },
            "optimized_ms": { "type": "number" }
          }
        },
        "validation": {
          "type": "object",
          "properties": {
            "confidence": { "type": "string", "enum": ["high", "row_count_only", "zero_row_unverified"] },
            "rows_match": { "type": "boolean" },
            "checksum_match": { "type": ["boolean", "null"] }
          }
        },
        "error": { "type": ["object", "null"] }
      }
    },

    "transforms": {
      "type": "object",
      "properties": {
        "primary": { "type": "string" },
        "all": { "type": "array", "items": { "type": "string" } }
      }
    },

    "config": {
      "type": ["object", "null"],
      "properties": {
        "settings": { "type": "object" },
        "impact_additive": { "type": ["number", "null"] }
      }
    },

    "error": {
      "type": ["object", "null"],
      "properties": {
        "category": { "type": "string", "enum": ["syntax", "semantic", "timeout", "execution", "unknown"] },
        "messages": { "type": "array", "items": { "type": "string" } }
      }
    },

    "reasons": {
      "type": ["object", "null"],
      "properties": {
        "reasoning_chain": { "type": "string" },
        "evidence": { "type": "string" }
      }
    },

    "tags": {
      "type": "array",
      "items": { "type": "string" }
    },

    "provenance": {
      "type": "object",
      "required": ["model", "provider"],
      "properties": {
        "model": { "type": "string" },
        "provider": { "type": "string" },
        "git_sha": { "type": "string" },
        "knowledge_version_used": { "type": "string" }
      }
    },

    "version": {
      "type": "object",
      "required": ["schema_version"],
      "properties": {
        "schema_version": { "type": "string", "const": "2.0" },
        "entry_version": { "type": "integer", "default": 1 },
        "status": { "type": "string", "enum": ["active", "superseded", "archived"], "default": "active" }
      }
    }
  }
}
```

---

## 2. AnalysisSession (Markdown — Manual)

**Template**: `templates/analysis_session.md`
**Storage**: `data/analysis_sessions/{engine}/AS-{ENGINE_SHORT}-{NNN}.md`

### Required Sections

| Section | Required | Content |
|---------|----------|---------|
| Header | Yes | Date, analyst, engine, benchmark, source path, session ID |
| Batch Summary | Yes | Entry counts by status, top speedup, worst regression |
| Findings | Yes (1+) | At least one finding per session |
| Actions | Yes | One action block per finding |
| Session Summary | Yes | Counts of findings/updates/promotions, profile version change |

### Finding Structure (within session)

Each finding must have:

| Field | Required | Format |
|-------|----------|--------|
| ID | Yes | `F-{ENGINE_SHORT}-{NNN}` |
| Claim | Yes | One falsifiable sentence |
| Category | Yes | One of: scan_method, join_optimization, aggregation, subquery, config_tuning, index_usage, parallelism, materialization |
| Evidence table | Yes | Query, Worker, Speedup, Transform, Supports/Contradicts |
| Mechanism | Yes | WHY the optimizer behaves this way |
| Boundary conditions | Yes | Applies when (1+), Does NOT apply when (1+), Diagnostic signal (1+) |
| Confidence | Yes | high, medium, or low with rationale |

### Action Structure (within session)

Each action must specify:
- Which finding it addresses
- Action type: update_gap, new_gap, new_strength, promote_example, no_action
- If profile update: exact text to add/modify
- If gold example: reference to 4-part explanation draft

---

## 3. Finding (Markdown — Standalone)

**Template**: `templates/finding.md`
**Storage**: Normally embedded in analysis session. Standalone findings at `data/findings/{engine}/F-{ENGINE_SHORT}-{NNN}.md`

Same required fields as findings within an analysis session (see table above), plus:

| Field | Required | Format |
|-------|----------|--------|
| Session reference | Yes | `AS-{ENGINE_SHORT}-{NNN}` |
| Linked profile entry | Yes | Gap ID or "none — propose new gap" |
| Proposed action | Yes | update_gap, new_gap, new_strength, no_action |

---

## 4. EngineProfile (Markdown — Manual)

**Template**: `templates/engine_profile_template.md`
**Storage**: `constraints/engine_profile_{dialect}.md`

### Structural Schema

```python
@dataclass
class EngineProfileStructure:
    engine: str                                     # "duckdb" | "postgresql"
    version_tested: str                             # "1.1+"
    briefing_note: str                              # 1-2 sentences
    strengths: list[StrengthEntry]                  # 5-10 entries
    gaps: list[GapEntry]                            # 3-8 entries, ordered by priority
    set_local_intel: list[ConfigRule] | None        # PG only
    scale_warning: str | None                       # Optional
    profile_version: str                            # "YYYY.MM.DD-vN"
    last_validated: str                             # "YYYY-MM-DD"
    analysis_sessions: list[str]                    # Session IDs that informed this version

@dataclass
class StrengthEntry:
    id: str                                         # SCREAMING_SNAKE
    summary: str                                    # 1 sentence
    note: str                                       # Tactical field note with evidence

@dataclass
class GapEntry:
    id: str                                         # SCREAMING_SNAKE, unique
    priority: Literal["HIGH", "MEDIUM", "LOW"]
    what: str                                       # 1 sentence — what optimizer fails to do
    why: str                                        # 1 sentence — internal mechanism
    hunt: str                                       # 1 sentence — what worker should try
    won: list[WonLost]                              # All winning evidence (no truncation)
    lost: list[WonLost]                             # All losing evidence (no truncation)
    rules: list[str]                                # Condition-scoped field notes

@dataclass
class WonLost:
    query: str                                      # "Q88"
    speedup: float                                  # 6.28 or 0.23
    technique: str                                  # Brief description

@dataclass
class ConfigRule:
    id: str                                         # SCREAMING_SNAKE
    trigger: str                                    # EXPLAIN signal to look for
    config: str                                     # SET LOCAL statement or "Do NOT"
    evidence: str                                   # Query + speedup
    risk: Literal["LOW", "MEDIUM", "HIGH", "CRITICAL"]
```

### Validation Rules

- Every gap must have `What`, `Why`, `Hunt`, `Won`, `Lost`, `Rules` sections
- `Rules` must contain at least 1 diagnostic (EXPLAIN signal) and 1 safety rule
- Gap IDs must be unique SCREAMING_SNAKE
- Strengths must be in table format (ID | Summary | Note)
- Profile version and last validated date must be present
- PG profiles must have SET LOCAL Config Intel section

### Markdown Format

See `03_ENGINE_PROFILE.md` for the complete format specification with examples.

---

## 5. GoldExample (JSON — Manual)

**Template**: `templates/gold_example_template.json`
**Storage**: `qt_sql/examples/{dialect}/{id}.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "GoldExample",
  "description": "A proven optimization example used as few-shot context",

  "type": "object",
  "required": ["id", "query_id", "dialect", "original_sql", "optimized_sql", "explanation", "outcome", "status"],

  "properties": {
    "schema_version": { "type": "string", "const": "2.0" },
    "id": { "type": "string", "examples": ["q6_date_cte", "q88_channel_bitmap"] },
    "query_id": { "type": "string" },
    "dialect": { "type": "string", "enum": ["duckdb", "postgresql"] },

    "classification": {
      "type": "object",
      "properties": {
        "tags": { "type": "array", "items": { "type": "string" } },
        "archetype": { "type": "string" },
        "transforms": { "type": "array", "items": { "type": "string" } },
        "complexity": { "type": "string", "enum": ["simple", "moderate", "complex"] }
      }
    },

    "demonstrates_gaps": {
      "type": "array",
      "items": { "type": "string" },
      "description": "Engine profile gap IDs this example exploits"
    },

    "original_sql": { "type": "string" },
    "optimized_sql": { "type": "string" },

    "explanation": {
      "type": "object",
      "required": ["what", "why", "when", "when_not"],
      "properties": {
        "what": { "type": "string" },
        "why": { "type": "string" },
        "when": { "type": "string" },
        "when_not": { "type": "string" }
      }
    },

    "example": {
      "type": "object",
      "description": "Legacy format (input_slice, output, key_insight) — backward compat",
      "properties": {
        "opportunity": { "type": "string" },
        "input_slice": { "type": "string" },
        "output": { "type": "object" },
        "key_insight": { "type": "string" },
        "when_not_to_use": { "type": "string" }
      }
    },

    "outcome": {
      "type": "object",
      "required": ["speedup", "validation_confidence"],
      "properties": {
        "speedup": { "type": "number" },
        "original_ms": { "type": "number" },
        "optimized_ms": { "type": "number" },
        "validated_at_sf": { "type": "integer" },
        "validation_confidence": { "type": "string", "enum": ["high", "row_count_only", "zero_row_unverified"] },
        "rows_match": { "type": "boolean" },
        "checksum_match": { "type": ["boolean", "null"] }
      }
    },

    "provenance": {
      "type": "object",
      "properties": {
        "source_run": { "type": "string" },
        "worker_id": { "type": "integer" },
        "model": { "type": "string" },
        "promoted_at": { "type": "string", "format": "date-time" },
        "promoted_by": { "type": "string", "enum": ["human"] },
        "analysis_session": { "type": "string", "description": "AS-XXX-NNN that promoted this" }
      }
    },

    "status": { "type": "string", "enum": ["active", "deprecated", "superseded"] },
    "superseded_by": { "type": ["string", "null"] }
  }
}
```

### Validation Rules

- `explanation` must have all 4 fields (what, why, when, when_not) non-empty
- `when_not` must reference at least one specific query + regression
- `demonstrates_gaps` must reference valid gap IDs from the engine profile
- `outcome.speedup` must be > 1.0
- `provenance.promoted_by` must be "human"
- `provenance.analysis_session` must reference a valid session ID

---

## 6. DetectionRule (JSON — Manual)

**Storage**: `constraints/detection_rules/{dialect}/{GAP_ID}.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "DetectionRule",
  "description": "Machine-readable predicate for gap detection",

  "type": "object",
  "required": ["id", "gap_id", "detect"],

  "properties": {
    "id": { "type": "string", "description": "Same as gap_id" },
    "gap_id": { "type": "string", "description": "Engine profile gap ID" },
    "priority": { "type": "string", "enum": ["HIGH", "MEDIUM", "LOW"] },

    "detect": {
      "type": "object",
      "required": ["match"],
      "properties": {
        "match": { "$ref": "#/$defs/predicate_tree" },
        "skip": { "$ref": "#/$defs/predicate_tree" },
        "confidence": {
          "type": "object",
          "properties": {
            "high_when": { "$ref": "#/$defs/predicate_tree" },
            "low_when": { "$ref": "#/$defs/predicate_tree" }
          }
        }
      }
    }
  },

  "$defs": {
    "predicate_tree": {
      "oneOf": [
        {
          "type": "object",
          "properties": { "ALL": { "type": "array", "items": { "$ref": "#/$defs/predicate_tree" } } },
          "required": ["ALL"]
        },
        {
          "type": "object",
          "properties": { "ANY": { "type": "array", "items": { "$ref": "#/$defs/predicate_tree" } } },
          "required": ["ANY"]
        },
        {
          "type": "object",
          "properties": {
            "feature": { "type": "string" },
            "op": { "type": "string", "enum": ["==", "!=", ">=", "<=", ">", "<", "in"] },
            "value": {}
          },
          "required": ["feature", "op", "value"]
        }
      ]
    }
  }
}
```

### Validation Rules

- All features must exist in the feature vocabulary (see `05_DETECTION_AND_MATCHING.md`)
- All operators must be valid for the feature's type
- `gap_id` must reference a valid gap in the engine profile
- `match` predicate is required; `skip` and `confidence` are optional

---

## 7. FeatureVector (Runtime — Computed)

Not stored. Computed at query time by the feature extractor.

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "FeatureVector",
  "description": "Structural features extracted from SQL via sqlglot",

  "type": "object",
  "properties": {
    "join_style": { "type": "string", "enum": ["explicit", "implicit_comma", "mixed", "none"] },
    "table_count": { "type": "integer" },
    "dimension_table_count": { "type": "integer" },
    "is_star_schema": { "type": "boolean" },
    "fact_table_max_scans": { "type": "integer" },
    "tables_with_multiple_scans": { "type": "integer" },
    "correlated_subquery_count": { "type": "integer" },
    "correlated_with_aggregate": { "type": "integer" },
    "correlated_exists_count": { "type": "integer" },
    "scalar_subquery_in_select": { "type": "integer" },
    "where_filters_on_dimension_tables": { "type": "integer" },
    "or_chain_count": { "type": "integer" },
    "or_branches_max": { "type": "integer" },
    "or_branches_touch_different_indexes": { "type": "boolean" },
    "cte_count": { "type": "integer" },
    "multi_ref_cte_count": { "type": "integer" },
    "cte_max_depth": { "type": "integer" },
    "conditional_aggregate_count": { "type": "integer" },
    "aggregation_type": { "type": "string", "enum": ["none", "simple", "conditional", "nested", "multi_stage"] },
    "has_having": { "type": "boolean" },
    "has_window_functions": { "type": "boolean" },
    "self_join_count": { "type": "integer" },
    "union_branch_count": { "type": "integer" },
    "has_lateral": { "type": "boolean" },
    "estimated_complexity": { "type": "string", "enum": ["simple", "moderate", "complex"] },

    "has_disk_sort": { "type": ["boolean", "null"] },
    "disk_sort_size_mb": { "type": ["number", "null"] },
    "has_large_seqscan": { "type": ["boolean", "null"] },
    "large_seqscan_tables": { "type": ["integer", "null"] },
    "has_jit": { "type": ["boolean", "null"] },
    "baseline_ms": { "type": ["number", "null"] },
    "nested_loop_on_dimension_pk": { "type": ["boolean", "null"] },
    "parallel_workers_used": { "type": ["integer", "null"] }
  }
}
```

---

## Populated Examples

### BlackboardEntry: Q9 4.47x single_pass_aggregation
See `02_BLACKBOARD.md` for the full populated JSON.

### EngineProfile: DuckDB gap block
See `03_ENGINE_PROFILE.md` for the CROSS_CTE_PREDICATE_BLINDNESS gap in markdown format.

### GoldExample: or_to_union with 4-part explanation
See `04_GOLD_EXAMPLES.md` for the populated explanation block.

### DetectionRule: CROSS_CTE_PREDICATE_BLINDNESS
See `05_DETECTION_AND_MATCHING.md` for the full predicate JSON.
