{
  "summary": {
    "total_queries": 99,
    "queries_with_findings": 98,
    "total_findings": 642,
    "avg_per_query": 6.48
  },
  "severity_counts": {
    "info": 131,
    "high": 131,
    "optimization": 87,
    "medium": 155,
    "low": 137,
    "critical": 1
  },
  "category_counts": {
    "optimization": 182,
    "optimization_opportunity": 195,
    "subqueries": 48,
    "aggregation": 50,
    "duckdb": 100,
    "where_clause": 25,
    "joins": 27,
    "cte": 3,
    "order_by": 6,
    "union": 3,
    "select_clause": 3
  },
  "rule_frequency": {
    "QT-AGG-002": 131,
    "QT-OPT-003": 77,
    "SQL-DUCK-002": 44,
    "SQL-AGG-006": 42,
    "QT-OPT-009": 41,
    "QT-OPT-007": 28,
    "SQL-SUB-002": 25,
    "SQL-DUCK-018": 25,
    "SQL-DUCK-006": 17,
    "SQL-JOIN-007": 17,
    "QT-CTE-002": 17,
    "QT-BOOL-001": 16,
    "QT-OPT-001": 16,
    "SQL-WHERE-004": 15,
    "SQL-JOIN-010": 10,
    "QT-DIST-001": 10,
    "SQL-SUB-004": 8,
    "SQL-WHERE-001": 8,
    "SQL-DUCK-001": 8,
    "QT-OPT-002": 7,
    "SQL-DUCK-007": 6,
    "QT-OPT-006": 6,
    "QT-PLAN-001": 6,
    "SQL-ORD-001": 6,
    "QT-OPT-011": 6,
    "SQL-SUB-001": 5,
    "SQL-SUB-006": 5,
    "QT-OPT-010": 5,
    "QT-OPT-005": 4,
    "QT-OPT-004": 4,
    "SQL-AGG-002": 3,
    "SQL-AGG-008": 3,
    "SQL-SUB-003": 3,
    "SQL-AGG-007": 2,
    "SQL-CTE-005": 2,
    "SQL-UNION-001": 2,
    "SQL-WHERE-008": 2,
    "SQL-SEL-002": 2,
    "QT-OPT-008": 1,
    "SQL-SUB-007": 1,
    "SQL-UNION-002": 1,
    "QT-AGG-003": 1,
    "SQL-CTE-003": 1,
    "QT-FILT-001": 1,
    "SQL-SEL-003": 1,
    "SQL-SUB-005": 1
  },
  "queries": {
    "query_1": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-002",
        "name": "Correlated Subquery to Pre-computed CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Correlated Avg subquery on ctr_store_sk - pre-computed CTE can give 2-3x speedup",
        "suggestion": "Extract correlated aggregate into separate CTE with GROUP BY, then JOIN",
        "location": "__main__:16"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: ctr2, ctr1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-001",
        "name": "Correlated Subquery in WHERE",
        "severity": "high",
        "category": "subqueries",
        "description": "Correlated subquery in WHERE - runs per row",
        "suggestion": "Rewrite as JOIN with CTE or derived table",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "customer_total_return:3"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "customer_total_return:3"
      }
    ],
    "query_10": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(*)' computed 6 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 14 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: c, ca",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-006",
        "name": "EXISTS with SELECT *",
        "severity": "high",
        "category": "subqueries",
        "description": "EXISTS with SELECT * - use SELECT 1",
        "suggestion": "Use SELECT 1 in EXISTS for explicit intent",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 8 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_11": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: t_w_secyear, t_s_secyear",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 10 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "year_total"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "year_total"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 8 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "year_total"
      }
    ],
    "query_12": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ws_ext_sales_price)' computed 3 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 5 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_13": [
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__"
      }
    ],
    "query_14": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "16 JOINs - critical complexity",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-004",
        "name": "Repeated Subquery",
        "severity": "medium",
        "category": "subqueries",
        "description": "Repeated subquery - extract to CTE",
        "suggestion": "Extract to CTE and reference once",
        "location": "__main__:74"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ws_quantity * ws_list_pric' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-007",
        "name": "Aggregate of Aggregate",
        "severity": "low",
        "category": "aggregation",
        "description": "Aggregate of aggregate - consider pre-aggregation table",
        "suggestion": "For repeated queries, pre-compute base aggregations",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [avg_sales] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__:74"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "__main__:68"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "__main__:68"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "__main__:80"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "__main__:80"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "__main__:92"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "__main__:92"
      },
      {
        "rule_id": "QT-OPT-005",
        "name": "Scan Consolidation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Table scanned multiple times [web_sales(2x), store_sales(2x)] - consolidate with CASE WHEN for 1.5-2x speedup",
        "suggestion": "Combine multiple scans into single scan with CASE WHEN conditional aggregates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-JOIN-010",
        "name": "Complex Subquery in JOIN",
        "severity": "low",
        "category": "joins",
        "description": "Complex subquery in JOIN - extract to CTE",
        "suggestion": "Move complex subqueries to WITH clause for readability",
        "location": "cross_items"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "avg_sales"
      }
    ],
    "query_15": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year, d_qoy) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [ca_zip | ca_state | cs_sales_price] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-001",
        "name": "Function on Column in WHERE",
        "severity": "high",
        "category": "where_clause",
        "description": "SUBSTRING() on column prevents index usage",
        "suggestion": "Rewrite to apply function to the literal value instead",
        "location": "__main__"
      }
    ],
    "query_16": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(DISTINCT cs_order_number' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: cs1, cr1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "QT-DIST-001",
        "name": "Potentially Unnecessary DISTINCT",
        "severity": "low",
        "category": "optimization",
        "description": "DISTINCT adds overhead - verify it's needed",
        "suggestion": "Remove DISTINCT if query already returns unique rows",
        "location": "__main__:3"
      },
      {
        "rule_id": "SQL-SUB-006",
        "name": "EXISTS with SELECT *",
        "severity": "high",
        "category": "subqueries",
        "description": "EXISTS with SELECT * - use SELECT 1",
        "suggestion": "Use SELECT 1 in EXISTS for explicit intent",
        "location": "__main__"
      }
    ],
    "query_17": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'AVG(ss_quantity)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 15 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: d3, d2",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_18": [
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 11 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: cd1, cd2",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      }
    ],
    "query_19": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-001",
        "name": "Function on Column in WHERE",
        "severity": "high",
        "category": "where_clause",
        "description": "SUBSTRING() on column prevents index usage",
        "suggestion": "Rewrite to apply function to the literal value instead",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 4 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_2": [
      {
        "rule_id": "SQL-DUCK-007",
        "name": "Manual Pivot Pattern",
        "severity": "medium",
        "category": "duckdb",
        "description": "7 CASE expressions - consider PIVOT",
        "suggestion": "DuckDB supports PIVOT t ON column USING aggregate(value)",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-006",
        "name": "Multi-layer Predicate Pushdown",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Multi-layer CTE with filter - predicate can be pushed through layers",
        "suggestion": "Push filter predicate through each CTE layer to base tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim, wswscs] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-JOIN-010",
        "name": "Complex Subquery in JOIN",
        "severity": "low",
        "category": "joins",
        "description": "Complex subquery in JOIN - extract to CTE",
        "suggestion": "Move complex subqueries to WITH clause for readability",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-CTE-005",
        "name": "Simple CTE Used Once",
        "severity": "low",
        "category": "cte",
        "description": "Simple CTE 'wscs' used once - consider inlining",
        "suggestion": "Consider inlining simple single-use CTEs",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'wscs' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-010",
        "name": "Inline Single-Use CTE",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "CTE 'wscs' used once - consider inlining",
        "suggestion": "Inline CTE as subquery since it's only used once",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-007",
        "name": "Manual Pivot Pattern",
        "severity": "medium",
        "category": "duckdb",
        "description": "7 CASE expressions - consider PIVOT",
        "suggestion": "DuckDB supports PIVOT t ON column USING aggregate(value)",
        "location": "wswscs"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "wswscs"
      }
    ],
    "query_20": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(cs_ext_sales_price)' computed 3 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 5 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_21": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      }
    ],
    "query_22": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      }
    ],
    "query_23": [
      {
        "rule_id": "SQL-SUB-004",
        "name": "Repeated Subquery",
        "severity": "medium",
        "category": "subqueries",
        "description": "Repeated subquery - extract to CTE",
        "suggestion": "Extract to CTE and reference once",
        "location": "__main__:40"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(*)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-006",
        "name": "Multi-layer Predicate Pushdown",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Multi-layer CTE with filter - predicate can be pushed through layers",
        "suggestion": "Push filter predicate through each CTE layer to base tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [best_ss_customer] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__:40"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "__main__:39"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "__main__:39"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "__main__:40"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "__main__:40"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "__main__:48"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "__main__:48"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "__main__:49"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "__main__:49"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'max_store_sales' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-005",
        "name": "Scan Consolidation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Table scanned multiple times [store_sales(3x)] - consolidate with CASE WHEN for 1.5-2x speedup",
        "suggestion": "Combine multiple scans into single scan with CASE WHEN conditional aggregates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(*)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "frequent_ss_items"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "frequent_ss_items"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "frequent_ss_items"
      },
      {
        "rule_id": "SQL-AGG-002",
        "name": "GROUP BY on Expression",
        "severity": "medium",
        "category": "aggregation",
        "description": "GROUP BY SUBSTRING() - consider computed column",
        "suggestion": "Use computed column or pre-calculate",
        "location": "frequent_ss_items"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "frequent_ss_items"
      },
      {
        "rule_id": "SQL-AGG-008",
        "name": "HAVING COUNT Filter",
        "severity": "low",
        "category": "aggregation",
        "description": "HAVING COUNT filter - consider CTE/semi-join for large data",
        "suggestion": "For selective filters, pre-filter IDs with subquery/CTE",
        "location": "frequent_ss_items"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "max_store_sales"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "max_store_sales"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_quantity * ss_sales_pri' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "best_ss_customer"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "best_ss_customer"
      }
    ],
    "query_24": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(netpaid)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 11 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "ssales"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ssales"
      },
      {
        "rule_id": "SQL-WHERE-001",
        "name": "Function on Column in WHERE",
        "severity": "high",
        "category": "where_clause",
        "description": "UPPER() on column prevents index usage",
        "suggestion": "Rewrite to apply function to the literal value instead",
        "location": "ssales:26"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 10 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "ssales"
      }
    ],
    "query_25": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: d3, d2",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 4 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_26": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:15"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [p_channel_email | p_channel_event] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:15"
      }
    ],
    "query_27": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      }
    ],
    "query_28": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'AVG(ss_list_price)' computed 6 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [store_sales] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-DIST-001",
        "name": "Potentially Unnecessary DISTINCT",
        "severity": "low",
        "category": "optimization",
        "description": "DISTINCT adds overhead - verify it's needed",
        "suggestion": "Remove DISTINCT if query already returns unique rows",
        "location": "__main__:5"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__:8"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:8"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [ss_list_price | ss_coupon_amt | ss_wholesale_cost] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:8"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__:16"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:16"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [ss_list_price | ss_coupon_amt | ss_wholesale_cost] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:16"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__:24"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:24"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [ss_list_price | ss_coupon_amt | ss_wholesale_cost] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:24"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__:32"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:32"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [ss_list_price | ss_coupon_amt | ss_wholesale_cost] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:32"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [ss_list_price | ss_coupon_amt | ss_wholesale_cost] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__:48"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:48"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [ss_list_price | ss_coupon_amt | ss_wholesale_cost] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:48"
      }
    ],
    "query_29": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: d3, d2",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 4 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_3": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: item, dt",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_30": [
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 13 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-002",
        "name": "Correlated Subquery to Pre-computed CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Correlated Avg subquery on ctr_state - pre-computed CTE can give 2-3x speedup",
        "suggestion": "Extract correlated aggregate into separate CTE with GROUP BY, then JOIN",
        "location": "__main__:20"
      },
      {
        "rule_id": "QT-OPT-004",
        "name": "Predicate Pushdown into CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Dimension filter [customer_address(ctr_state,ctr_state), customer(ctr_state,ctr_state)] in main query - push into CTE for 2-3x speedup",
        "suggestion": "Move dimension join and filter INTO the CTE before GROUP BY",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: ctr2, ctr1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-001",
        "name": "Correlated Subquery in WHERE",
        "severity": "high",
        "category": "subqueries",
        "description": "Correlated subquery in WHERE - runs per row",
        "suggestion": "Rewrite as JOIN with CTE or derived table",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "customer_total_return:3"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "customer_total_return:3"
      }
    ],
    "query_31": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "9 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: ws2, ss2",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ss"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "ss"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ws"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "ws"
      }
    ],
    "query_32": [
      {
        "rule_id": "QT-OPT-002",
        "name": "Correlated Subquery to Pre-computed CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Correlated Avg subquery on d_date_sk - pre-computed CTE can give 2-3x speedup",
        "suggestion": "Extract correlated aggregate into separate CTE with GROUP BY, then JOIN",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      }
    ],
    "query_33": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "9 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-004",
        "name": "Repeated Subquery",
        "severity": "medium",
        "category": "subqueries",
        "description": "Repeated subquery - extract to CTE",
        "suggestion": "Extract to CTE and reference once",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [item] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'ss' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ss"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ss"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "ss"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "ss"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "cs"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "cs"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "cs"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "cs"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ws"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ws"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "ws"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "ws"
      }
    ],
    "query_34": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      }
    ],
    "query_35": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'MAX(cd_dep_count)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 18 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year, d_qoy) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: c, ca",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-006",
        "name": "EXISTS with SELECT *",
        "severity": "high",
        "category": "subqueries",
        "description": "EXISTS with SELECT * - use SELECT 1",
        "suggestion": "Use SELECT 1 in EXISTS for explicit intent",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 6 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_36": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_net_profit)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: d1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      }
    ],
    "query_37": [
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_38": [
      {
        "rule_id": "QT-DIST-001",
        "name": "Potentially Unnecessary DISTINCT",
        "severity": "low",
        "category": "optimization",
        "description": "DISTINCT adds overhead - verify it's needed",
        "suggestion": "Remove DISTINCT if query already returns unique rows",
        "location": "__main__:3"
      }
    ],
    "query_39": [
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 10 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-004",
        "name": "Predicate Pushdown into CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Dimension filter [item(d_moy,d_moy)] in main query - push into CTE for 2-3x speedup",
        "suggestion": "Move dimension join and filter INTO the CTE before GROUP BY",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: inv2, inv1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "inv"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 4 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "inv"
      }
    ],
    "query_4": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "11 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: t_w_secyear, t_s_firstyear",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 10 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "year_total"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "year_total"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 8 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "year_total"
      }
    ],
    "query_40": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      }
    ],
    "query_41": [
      {
        "rule_id": "QT-OPT-002",
        "name": "Correlated Subquery to Pre-computed CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Correlated Count subquery on i_manufact - pre-computed CTE can give 2-3x speedup",
        "suggestion": "Extract correlated aggregate into separate CTE with GROUP BY, then JOIN",
        "location": "__main__"
      },
      {
        "rule_id": "QT-DIST-001",
        "name": "Potentially Unnecessary DISTINCT",
        "severity": "low",
        "category": "optimization",
        "description": "DISTINCT adds overhead - verify it's needed",
        "suggestion": "Remove DISTINCT if query already returns unique rows",
        "location": "__main__:2"
      },
      {
        "rule_id": "QT-OPT-008",
        "name": "Flatten Subquery to JOIN/EXISTS",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "COUNT(*) > 0 pattern - EXISTS stops at first match",
        "suggestion": "Replace (SELECT COUNT(*) ...) > 0 with EXISTS (SELECT 1 ...)",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-001",
        "name": "Correlated Subquery in WHERE",
        "severity": "high",
        "category": "subqueries",
        "description": "Correlated subquery in WHERE - runs per row",
        "suggestion": "Rewrite as JOIN with CTE or derived table",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "4 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__"
      }
    ],
    "query_42": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_ext_sales_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: item, dt",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_43": [
      {
        "rule_id": "SQL-DUCK-007",
        "name": "Manual Pivot Pattern",
        "severity": "medium",
        "category": "duckdb",
        "description": "7 CASE expressions - consider PIVOT",
        "suggestion": "DuckDB supports PIVOT t ON column USING aggregate(value)",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      }
    ],
    "query_44": [
      {
        "rule_id": "SQL-SUB-004",
        "name": "Repeated Subquery",
        "severity": "medium",
        "category": "subqueries",
        "description": "Repeated subquery - extract to CTE",
        "suggestion": "Extract to CTE and reference once",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'AVG(ss_net_profit)' computed 6 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-PLAN-001",
        "name": "Window Blocks Pushdown",
        "severity": "medium",
        "category": "optimization",
        "description": "Filter after window - some predicates could be pushed inside",
        "suggestion": "Move non-window filters inside the subquery",
        "location": "__main__:29"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [store_sales] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: descending, asceding",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-ORD-001",
        "name": "ORDER BY in Subquery",
        "severity": "medium",
        "category": "order_by",
        "description": "ORDER BY in subquery without LIMIT/TOP - will be ignored",
        "suggestion": "Remove ORDER BY or add TOP clause",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-001",
        "name": "Subquery Instead of QUALIFY",
        "severity": "medium",
        "category": "duckdb",
        "description": "Subquery with window function - use QUALIFY instead",
        "suggestion": "DuckDB supports QUALIFY - filter window functions directly",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-011",
        "name": "Remove Redundant Operations",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "ORDER BY in subquery is often redundant",
        "suggestion": "Remove unnecessary DISTINCT, ORDER BY, or unused columns",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-003",
        "name": "Deeply Nested Subqueries",
        "severity": "medium",
        "category": "subqueries",
        "description": "Subquery depth 3 - consider refactoring",
        "suggestion": "Refactor using CTEs or temp tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-JOIN-010",
        "name": "Complex Subquery in JOIN",
        "severity": "low",
        "category": "joins",
        "description": "Complex subquery in JOIN - extract to CTE",
        "suggestion": "Move complex subqueries to WITH clause for readability",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-ORD-001",
        "name": "ORDER BY in Subquery",
        "severity": "medium",
        "category": "order_by",
        "description": "ORDER BY in subquery without LIMIT/TOP - will be ignored",
        "suggestion": "Remove ORDER BY or add TOP clause",
        "location": "__main__:16"
      },
      {
        "rule_id": "QT-OPT-011",
        "name": "Remove Redundant Operations",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "ORDER BY in subquery is often redundant",
        "suggestion": "Remove unnecessary DISTINCT, ORDER BY, or unused columns",
        "location": "__main__:16"
      }
    ],
    "query_45": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year, d_qoy) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [ca_zip | i_item_id,i_item_sk] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-001",
        "name": "Function on Column in WHERE",
        "severity": "high",
        "category": "where_clause",
        "description": "SUBSTRING() on column prevents index usage",
        "suggestion": "Rewrite to apply function to the literal value instead",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "__main__:9"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "__main__:9"
      }
    ],
    "query_46": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: customer, current_addr",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:19"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [hd_dep_count | hd_vehicle_count] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:19"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 4 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_47": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_sales_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-006",
        "name": "Multi-layer Predicate Pushdown",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Multi-layer CTE with filter - predicate can be pushed through layers",
        "suggestion": "Push filter predicate through each CTE layer to base tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'v2' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-010",
        "name": "Inline Single-Use CTE",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "CTE 'v2' used once - consider inlining",
        "suggestion": "Inline CTE as subquery since it's only used once",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_sales_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "v1"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "v1"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "v1"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "v1"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 6 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "v1"
      }
    ],
    "query_48": [
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__"
      }
    ],
    "query_49": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim, store_returns] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-007",
        "name": "Correlated Subquery Could Be Window",
        "severity": "high",
        "category": "subqueries",
        "description": "Correlated aggregate with inequality - use window function",
        "suggestion": "Use window function with OVER (PARTITION BY ... ORDER BY ...)",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-ORD-001",
        "name": "ORDER BY in Subquery",
        "severity": "medium",
        "category": "order_by",
        "description": "ORDER BY in subquery without LIMIT/TOP - will be ignored",
        "suggestion": "Remove ORDER BY or add TOP clause",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-001",
        "name": "Subquery Instead of QUALIFY",
        "severity": "medium",
        "category": "duckdb",
        "description": "Subquery with window function - use QUALIFY instead",
        "suggestion": "DuckDB supports QUALIFY - filter window functions directly",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-UNION-001",
        "name": "UNION Without ALL",
        "severity": "medium",
        "category": "union",
        "description": "UNION removes duplicates - consider UNION ALL if not needed",
        "suggestion": "Use UNION ALL if duplicate removal is not required",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-011",
        "name": "Remove Redundant Operations",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "ORDER BY in subquery is often redundant",
        "suggestion": "Remove unnecessary DISTINCT, ORDER BY, or unused columns",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-003",
        "name": "Deeply Nested Subqueries",
        "severity": "medium",
        "category": "subqueries",
        "description": "Subquery depth 3 - consider refactoring",
        "suggestion": "Refactor using CTEs or temp tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [return_rank | currency_rank] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__"
      }
    ],
    "query_5": [
      {
        "rule_id": "SQL-UNION-002",
        "name": "Large UNION Chain",
        "severity": "medium",
        "category": "union",
        "description": "5 UNION branches - consider refactoring",
        "suggestion": "Consider partitioned table or dynamic SQL",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(profit)' computed 4 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'ssr' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-005",
        "name": "Scan Consolidation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Table scanned multiple times [web_sales(2x)] - consolidate with CASE WHEN for 1.5-2x speedup",
        "suggestion": "Combine multiple scans into single scan with CASE WHEN conditional aggregates",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ssr"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ssr"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "csr"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "csr"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "wsr"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "wsr"
      }
    ],
    "query_50": [
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 15 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: d2, d1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 10 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_51": [
      {
        "rule_id": "QT-PLAN-001",
        "name": "Window Blocks Pushdown",
        "severity": "medium",
        "category": "optimization",
        "description": "Filter after window - some predicates could be pushed inside",
        "suggestion": "Move non-window filters inside the subquery",
        "location": "__main__:40"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [store_v1, web_v1] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-ORD-001",
        "name": "ORDER BY in Subquery",
        "severity": "medium",
        "category": "order_by",
        "description": "ORDER BY in subquery without LIMIT/TOP - will be ignored",
        "suggestion": "Remove ORDER BY or add TOP clause",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-001",
        "name": "Subquery Instead of QUALIFY",
        "severity": "medium",
        "category": "duckdb",
        "description": "Subquery with window function - use QUALIFY instead",
        "suggestion": "DuckDB supports QUALIFY - filter window functions directly",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-011",
        "name": "Remove Redundant Operations",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "ORDER BY in subquery is often redundant",
        "suggestion": "Remove unnecessary DISTINCT, ORDER BY, or unused columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'web_v1' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "web_v1"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "store_v1"
      }
    ],
    "query_52": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: item, dt",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_53": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_sales_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-PLAN-001",
        "name": "Window Blocks Pushdown",
        "severity": "medium",
        "category": "optimization",
        "description": "Filter after window - some predicates could be pushed inside",
        "suggestion": "Move non-window filters inside the subquery",
        "location": "__main__:20"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-001",
        "name": "Subquery Instead of QUALIFY",
        "severity": "medium",
        "category": "duckdb",
        "description": "Subquery with window function - use QUALIFY instead",
        "suggestion": "DuckDB supports QUALIFY - filter window functions directly",
        "location": "__main__"
      }
    ],
    "query_54": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-006",
        "name": "Multi-layer Predicate Pushdown",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Multi-layer CTE with filter - predicate can be pushed through layers",
        "suggestion": "Push filter predicate through each CTE layer to base tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: cs_or_ws_sales",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-CTE-005",
        "name": "Simple CTE Used Once",
        "severity": "low",
        "category": "cte",
        "description": "Simple CTE 'segments' used once - consider inlining",
        "suggestion": "Consider inlining simple single-use CTEs",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'my_customers' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-010",
        "name": "Inline Single-Use CTE",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "CTE 'my_customers' used once - consider inlining",
        "suggestion": "Inline CTE as subquery since it's only used once",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "my_customers"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: cs_or_ws_sales",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "my_customers"
      },
      {
        "rule_id": "QT-DIST-001",
        "name": "Potentially Unnecessary DISTINCT",
        "severity": "low",
        "category": "optimization",
        "description": "DISTINCT adds overhead - verify it's needed",
        "suggestion": "Remove DISTINCT if query already returns unique rows",
        "location": "my_customers:3"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "my_revenue"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "my_revenue"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "my_revenue"
      },
      {
        "rule_id": "QT-DIST-001",
        "name": "Potentially Unnecessary DISTINCT",
        "severity": "low",
        "category": "optimization",
        "description": "DISTINCT adds overhead - verify it's needed",
        "suggestion": "Remove DISTINCT if query already returns unique rows",
        "location": "my_revenue:3"
      }
    ],
    "query_55": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      }
    ],
    "query_56": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "9 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-004",
        "name": "Repeated Subquery",
        "severity": "medium",
        "category": "subqueries",
        "description": "Repeated subquery - extract to CTE",
        "suggestion": "Extract to CTE and reference once",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [item] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'ss' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ss"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ss"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "ss"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "ss"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "cs"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "cs"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "cs"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "cs"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ws"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ws"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "ws"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "ws"
      }
    ],
    "query_57": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(cs_sales_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-006",
        "name": "Multi-layer Predicate Pushdown",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Multi-layer CTE with filter - predicate can be pushed through layers",
        "suggestion": "Push filter predicate through each CTE layer to base tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'v2' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-010",
        "name": "Inline Single-Use CTE",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "CTE 'v2' used once - consider inlining",
        "suggestion": "Inline CTE as subquery since it's only used once",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(cs_sales_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "v1"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "v1"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "v1"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "v1"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 5 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "v1"
      }
    ],
    "query_58": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "8 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-004",
        "name": "Repeated Subquery",
        "severity": "medium",
        "category": "subqueries",
        "description": "Repeated subquery - extract to CTE",
        "suggestion": "Extract to CTE and reference once",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'ss_items' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ss_items"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ss_items"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "ss_items"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "ss_items"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "ss_items"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "cs_items"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "cs_items"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "cs_items"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "cs_items"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "cs_items"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ws_items"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ws_items"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "ws_items"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "ws_items"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "ws_items"
      }
    ],
    "query_59": [
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 10 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-007",
        "name": "Manual Pivot Pattern",
        "severity": "medium",
        "category": "duckdb",
        "description": "7 CASE expressions - consider PIVOT",
        "suggestion": "DuckDB supports PIVOT t ON column USING aggregate(value)",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim, store] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-JOIN-010",
        "name": "Complex Subquery in JOIN",
        "severity": "low",
        "category": "joins",
        "description": "Complex subquery in JOIN - extract to CTE",
        "suggestion": "Move complex subqueries to WITH clause for readability",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-007",
        "name": "Manual Pivot Pattern",
        "severity": "medium",
        "category": "duckdb",
        "description": "7 CASE expressions - consider PIVOT",
        "suggestion": "DuckDB supports PIVOT t ON column USING aggregate(value)",
        "location": "wss"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "wss"
      }
    ],
    "query_6": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(*)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-002",
        "name": "Correlated Subquery to Pre-computed CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Correlated Avg subquery on i_category - pre-computed CTE can give 2-3x speedup",
        "suggestion": "Extract correlated aggregate into separate CTE with GROUP BY, then JOIN",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: i, a",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "QT-DIST-001",
        "name": "Potentially Unnecessary DISTINCT",
        "severity": "low",
        "category": "optimization",
        "description": "DISTINCT adds overhead - verify it's needed",
        "suggestion": "Remove DISTINCT if query already returns unique rows",
        "location": "__main__:13"
      },
      {
        "rule_id": "SQL-SUB-001",
        "name": "Correlated Subquery in WHERE",
        "severity": "high",
        "category": "subqueries",
        "description": "Correlated subquery in WHERE - runs per row",
        "suggestion": "Rewrite as JOIN with CTE or derived table",
        "location": "__main__:18"
      },
      {
        "rule_id": "SQL-AGG-008",
        "name": "HAVING COUNT Filter",
        "severity": "low",
        "category": "aggregation",
        "description": "HAVING COUNT filter - consider CTE/semi-join for large data",
        "suggestion": "For selective filters, pre-filter IDs with subquery/CTE",
        "location": "__main__:22"
      }
    ],
    "query_60": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "9 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-004",
        "name": "Repeated Subquery",
        "severity": "medium",
        "category": "subqueries",
        "description": "Repeated subquery - extract to CTE",
        "suggestion": "Extract to CTE and reference once",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [item] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'ss' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ss"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ss"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "ss"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "ss"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "cs"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "cs"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "cs"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "cs"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ws"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ws"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "ws"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "ws"
      }
    ],
    "query_61": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "12 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_ext_sales_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__:20"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:20"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [p_channel_dmail | p_channel_email | p_channel_tv] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:20"
      },
      {
        "rule_id": "SQL-JOIN-010",
        "name": "Complex Subquery in JOIN",
        "severity": "low",
        "category": "joins",
        "description": "Complex subquery in JOIN - extract to CTE",
        "suggestion": "Move complex subqueries to WITH clause for readability",
        "location": "__main__"
      }
    ],
    "query_62": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-002",
        "name": "GROUP BY on Expression",
        "severity": "medium",
        "category": "aggregation",
        "description": "GROUP BY SUBSTRING() - consider computed column",
        "suggestion": "Use computed column or pre-calculate",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_63": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_sales_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-PLAN-001",
        "name": "Window Blocks Pushdown",
        "severity": "medium",
        "category": "optimization",
        "description": "Filter after window - some predicates could be pushed inside",
        "suggestion": "Move non-window filters inside the subquery",
        "location": "__main__:23"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-001",
        "name": "Subquery Instead of QUALIFY",
        "severity": "medium",
        "category": "duckdb",
        "description": "Subquery with window function - use QUALIFY instead",
        "suggestion": "DuckDB supports QUALIFY - filter window functions directly",
        "location": "__main__"
      }
    ],
    "query_64": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "19 JOINs - critical complexity",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(cs_ext_list_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 21 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-004",
        "name": "Predicate Pushdown into CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Dimension filter [customer(store_zip,store_zip), customer_demographics(store_zip,store_zip)] in main query - push into CTE for 2-3x speedup",
        "suggestion": "Move dimension join and filter INTO the CTE before GROUP BY",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-006",
        "name": "Multi-layer Predicate Pushdown",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Multi-layer CTE with filter - predicate can be pushed through layers",
        "suggestion": "Push filter predicate through each CTE layer to base tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: cs1, cs2",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'cs_ui' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(cs_ext_list_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "cs_ui"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "cs_ui"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 19 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "cross_sales"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "cross_sales"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: hd2, hd1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "cross_sales"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 15 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "cross_sales"
      },
      {
        "rule_id": "QT-AGG-003",
        "name": "Redundant GROUP BY",
        "severity": "low",
        "category": "optimization",
        "description": "GROUP BY has 4 columns from 'ad1' - check for FD",
        "suggestion": "If grouping by PK, other columns from same table are redundant",
        "location": "cross_sales"
      }
    ],
    "query_65": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_sales_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim, store_sales] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: sb, sc",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-JOIN-010",
        "name": "Complex Subquery in JOIN",
        "severity": "low",
        "category": "joins",
        "description": "Complex subquery in JOIN - extract to CTE",
        "suggestion": "Move complex subqueries to WITH clause for readability",
        "location": "__main__"
      }
    ],
    "query_66": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "8 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-007",
        "name": "Aggregate of Aggregate",
        "severity": "low",
        "category": "aggregation",
        "description": "Aggregate of aggregate - consider pre-aggregation table",
        "suggestion": "For repeated queries, pre-compute base aggregations",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 44 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-007",
        "name": "Manual Pivot Pattern",
        "severity": "medium",
        "category": "duckdb",
        "description": "48 CASE expressions - consider PIVOT",
        "suggestion": "DuckDB supports PIVOT t ON column USING aggregate(value)",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 7 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_67": [
      {
        "rule_id": "QT-PLAN-001",
        "name": "Window Blocks Pushdown",
        "severity": "medium",
        "category": "optimization",
        "description": "Filter after window - some predicates could be pushed inside",
        "suggestion": "Move non-window filters inside the subquery",
        "location": "__main__:31"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim, item] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-ORD-001",
        "name": "ORDER BY in Subquery",
        "severity": "medium",
        "category": "order_by",
        "description": "ORDER BY in subquery without LIMIT/TOP - will be ignored",
        "suggestion": "Remove ORDER BY or add TOP clause",
        "location": "__main__:12"
      },
      {
        "rule_id": "SQL-DUCK-001",
        "name": "Subquery Instead of QUALIFY",
        "severity": "medium",
        "category": "duckdb",
        "description": "Subquery with window function - use QUALIFY instead",
        "suggestion": "DuckDB supports QUALIFY - filter window functions directly",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 10 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-011",
        "name": "Remove Redundant Operations",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "ORDER BY in subquery is often redundant",
        "suggestion": "Remove unnecessary DISTINCT, ORDER BY, or unused columns",
        "location": "__main__:12"
      }
    ],
    "query_68": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: customer, current_addr",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:26"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [hd_dep_count | hd_vehicle_count] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:26"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 4 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_69": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(*)' computed 3 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: c, ca",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-006",
        "name": "EXISTS with SELECT *",
        "severity": "high",
        "category": "subqueries",
        "description": "EXISTS with SELECT * - use SELECT 1",
        "suggestion": "Use SELECT 1 in EXISTS for explicit intent",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 5 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_7": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:15"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [p_channel_email | p_channel_event] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:15"
      }
    ],
    "query_70": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_net_profit)' computed 3 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim, store] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: d1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-ORD-001",
        "name": "ORDER BY in Subquery",
        "severity": "medium",
        "category": "order_by",
        "description": "ORDER BY in subquery without LIMIT/TOP - will be ignored",
        "suggestion": "Remove ORDER BY or add TOP clause",
        "location": "__main__:10"
      },
      {
        "rule_id": "QT-OPT-011",
        "name": "Remove Redundant Operations",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "ORDER BY in subquery is often redundant",
        "suggestion": "Remove unnecessary DISTINCT, ORDER BY, or unused columns",
        "location": "__main__:10"
      },
      {
        "rule_id": "SQL-DUCK-001",
        "name": "Subquery Instead of QUALIFY",
        "severity": "medium",
        "category": "duckdb",
        "description": "Subquery with window function - use QUALIFY instead",
        "suggestion": "DuckDB supports QUALIFY - filter window functions directly",
        "location": "__main__"
      }
    ],
    "query_71": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-JOIN-010",
        "name": "Complex Subquery in JOIN",
        "severity": "low",
        "category": "joins",
        "description": "Complex subquery in JOIN - extract to CTE",
        "suggestion": "Move complex subqueries to WITH clause for readability",
        "location": "__main__:4"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 4 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_72": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "10 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year, d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: d1, d2",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_73": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      }
    ],
    "query_74": [
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: t_w_secyear, t_s_secyear",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "year_total"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 4 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "year_total"
      }
    ],
    "query_75": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "10 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 10 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: prev_yr, curr_yr",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-001",
        "name": "Function on Column in WHERE",
        "severity": "high",
        "category": "where_clause",
        "description": "CAST() on column prevents index usage",
        "suggestion": "Rewrite to apply function to the literal value instead",
        "location": "__main__:66"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "all_sales"
      },
      {
        "rule_id": "SQL-UNION-001",
        "name": "UNION Without ALL",
        "severity": "medium",
        "category": "union",
        "description": "UNION removes duplicates - consider UNION ALL if not needed",
        "suggestion": "Use UNION ALL if duplicate removal is not required",
        "location": "all_sales"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 5 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "all_sales:48"
      }
    ],
    "query_76": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 5 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__:20"
      }
    ],
    "query_77": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "13 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-CTE-003",
        "name": "Deeply Nested CTEs",
        "severity": "medium",
        "category": "cte",
        "description": "6 CTEs - consider materializing",
        "suggestion": "Materialize intermediate CTEs to temp tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'ss' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ss"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ss"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "sr"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "sr"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "cs"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "cs"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "cr"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "cr"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ws"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ws"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "wr"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "wr"
      }
    ],
    "query_78": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "8 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [ws_qty | cs_qty] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-001",
        "name": "Function on Column in WHERE",
        "severity": "high",
        "category": "where_clause",
        "description": "COALESCE() on column prevents index usage",
        "suggestion": "Rewrite to apply function to the literal value instead",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-008",
        "name": "COALESCE/ISNULL in Filter",
        "severity": "medium",
        "category": "where_clause",
        "description": "COALESCE on column in filter - prevents index",
        "suggestion": "Handle NULL explicitly with OR ... IS NULL",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-001",
        "name": "Function on Column in WHERE",
        "severity": "high",
        "category": "where_clause",
        "description": "COALESCE() on column prevents index usage",
        "suggestion": "Rewrite to apply function to the literal value instead",
        "location": "__main__:48"
      },
      {
        "rule_id": "SQL-WHERE-008",
        "name": "COALESCE/ISNULL in Filter",
        "severity": "medium",
        "category": "where_clause",
        "description": "COALESCE on column in filter - prevents index",
        "suggestion": "Handle NULL explicitly with OR ... IS NULL",
        "location": "__main__:48"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'ws' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ws:3"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "ws:12"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "cs:15"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "cs:24"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ss:27"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "ss:36"
      }
    ],
    "query_79": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-BOOL-001",
        "name": "OR Across Columns",
        "severity": "low",
        "category": "optimization",
        "description": "OR across different columns - consider UNION",
        "suggestion": "Consider UNION for better index utilization",
        "location": "__main__:14"
      },
      {
        "rule_id": "QT-OPT-001",
        "name": "OR to UNION ALL Decomposition",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "OR across [hd_dep_count | hd_vehicle_count] - UNION ALL can give 2-3x speedup",
        "suggestion": "Split OR conditions into separate SELECT statements joined with UNION ALL",
        "location": "__main__:14"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 4 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_8": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(*)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year, d_qoy) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [customer, customer_address] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: v1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-JOIN-010",
        "name": "Complex Subquery in JOIN",
        "severity": "low",
        "category": "joins",
        "description": "Complex subquery in JOIN - extract to CTE",
        "suggestion": "Move complex subqueries to WITH clause for readability",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-001",
        "name": "Function on Column in WHERE",
        "severity": "high",
        "category": "where_clause",
        "description": "SUBSTRING() on column prevents index usage",
        "suggestion": "Rewrite to apply function to the literal value instead",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-003",
        "name": "Deeply Nested Subqueries",
        "severity": "medium",
        "category": "subqueries",
        "description": "Subquery depth 3 - consider refactoring",
        "suggestion": "Refactor using CTEs or temp tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-008",
        "name": "HAVING COUNT Filter",
        "severity": "low",
        "category": "aggregation",
        "description": "HAVING COUNT filter - consider CTE/semi-join for large data",
        "suggestion": "For selective filters, pre-filter IDs with subquery/CTE",
        "location": "__main__:99"
      },
      {
        "rule_id": "QT-FILT-001",
        "name": "Non-Sargable Predicate",
        "severity": "high",
        "category": "optimization",
        "description": "Substring(column) prevents index usage",
        "suggestion": "Rewrite as range predicate to enable index seek",
        "location": "__main__"
      }
    ],
    "query_80": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "15 JOINs - critical complexity",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'ssr' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "ssr"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "ssr"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "csr"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "csr"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "wsr"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "wsr"
      }
    ],
    "query_81": [
      {
        "rule_id": "SQL-DUCK-006",
        "name": "Consider EXCLUDE Clause",
        "severity": "low",
        "category": "duckdb",
        "description": "SELECT with 16 columns - consider * EXCLUDE",
        "suggestion": "Use SELECT * EXCLUDE (col1, col2) to select most columns",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-002",
        "name": "Correlated Subquery to Pre-computed CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Correlated Avg subquery on ctr_state - pre-computed CTE can give 2-3x speedup",
        "suggestion": "Extract correlated aggregate into separate CTE with GROUP BY, then JOIN",
        "location": "__main__:20"
      },
      {
        "rule_id": "QT-OPT-004",
        "name": "Predicate Pushdown into CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Dimension filter [customer_address(ctr_state,ctr_state), customer(ctr_state,ctr_state)] in main query - push into CTE for 2-3x speedup",
        "suggestion": "Move dimension join and filter INTO the CTE before GROUP BY",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: ctr2, ctr1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-001",
        "name": "Correlated Subquery in WHERE",
        "severity": "high",
        "category": "subqueries",
        "description": "Correlated subquery in WHERE - runs per row",
        "suggestion": "Rewrite as JOIN with CTE or derived table",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "customer_total_return:3"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "customer_total_return:3"
      }
    ],
    "query_82": [
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_83": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "8 JOINs - consider simplifying",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-004",
        "name": "Repeated Subquery",
        "severity": "medium",
        "category": "subqueries",
        "description": "Repeated subquery - extract to CTE",
        "suggestion": "Extract to CTE and reference once",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'sr_items' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "sr_items"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "sr_items"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "sr_items"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "sr_items"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "sr_items"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "cr_items"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "cr_items"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "cr_items"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "cr_items"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "cr_items"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "wr_items"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "wr_items"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [date_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "wr_items"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "wr_items"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "wr_items"
      }
    ],
    "query_85": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'AVG(ws_quantity)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: cd1, cd2",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__"
      }
    ],
    "query_86": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ws_net_paid)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: d1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      }
    ],
    "query_87": [
      {
        "rule_id": "QT-DIST-001",
        "name": "Potentially Unnecessary DISTINCT",
        "severity": "low",
        "category": "optimization",
        "description": "DISTINCT adds overhead - verify it's needed",
        "suggestion": "Remove DISTINCT if query already returns unique rows",
        "location": "__main__:3"
      }
    ],
    "query_88": [
      {
        "rule_id": "SQL-JOIN-007",
        "name": "Too Many JOINs",
        "severity": "medium",
        "category": "joins",
        "description": "31 JOINs - critical complexity",
        "suggestion": "Consider splitting query or materializing intermediates",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(*)' computed 8 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [household_demographics, store] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: store, time_dim",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-WHERE-004",
        "name": "OR Instead of IN",
        "severity": "low",
        "category": "where_clause",
        "description": "3 OR conditions - consider using IN",
        "suggestion": "Use IN clause for readability",
        "location": "__main__:11"
      },
      {
        "rule_id": "SQL-JOIN-010",
        "name": "Complex Subquery in JOIN",
        "severity": "low",
        "category": "joins",
        "description": "Complex subquery in JOIN - extract to CTE",
        "suggestion": "Move complex subqueries to WITH clause for readability",
        "location": "__main__"
      }
    ],
    "query_89": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_sales_price)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-PLAN-001",
        "name": "Window Blocks Pushdown",
        "severity": "medium",
        "category": "optimization",
        "description": "Filter after window - some predicates could be pushed inside",
        "suggestion": "Move non-window filters inside the subquery",
        "location": "__main__:24"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-001",
        "name": "Subquery Instead of QUALIFY",
        "severity": "medium",
        "category": "duckdb",
        "description": "Subquery with window function - use QUALIFY instead",
        "suggestion": "DuckDB supports QUALIFY - filter window functions directly",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 6 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__:22"
      }
    ],
    "query_9": [
      {
        "rule_id": "SQL-SEL-003",
        "name": "Multiple Scalar Subqueries",
        "severity": "critical",
        "category": "select_clause",
        "description": "15 scalar subqueries in SELECT - consolidate",
        "suggestion": "Combine into single JOIN or CTE",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SUB-005",
        "name": "Multiple Scalar Subqueries",
        "severity": "high",
        "category": "subqueries",
        "description": "15 scalar subqueries hit 'store_sales' - use LATERAL/CTE",
        "suggestion": "Use LATERAL JOIN or CTE to query table once",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'AVG(ss_net_profit)' computed 5 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [store_sales] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SEL-002",
        "name": "Scalar Subquery in SELECT",
        "severity": "high",
        "category": "select_clause",
        "description": "Scalar subquery in SELECT - executes per row",
        "suggestion": "Rewrite as JOIN or CTE",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-SEL-002",
        "name": "Scalar Subquery in SELECT",
        "severity": "high",
        "category": "select_clause",
        "description": "Scalar subquery in SELECT - executes per row",
        "suggestion": "Rewrite as JOIN or CTE",
        "location": "__main__:5"
      }
    ],
    "query_90": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(*)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-007",
        "name": "Materialize Repeated Subquery",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Repeated subquery on [household_demographics, time_dim] - materialized CTE can give 1.2-2x speedup",
        "suggestion": "Extract repeated subquery into a materialized CTE",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: web_page, household_demographics",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-JOIN-010",
        "name": "Complex Subquery in JOIN",
        "severity": "low",
        "category": "joins",
        "description": "Complex subquery in JOIN - extract to CTE",
        "suggestion": "Move complex subqueries to WITH clause for readability",
        "location": "__main__"
      }
    ],
    "query_91": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(cr_net_loss)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_moy, d_year) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 5 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_92": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ws_ext_discount_amt)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-002",
        "name": "Correlated Subquery to Pre-computed CTE",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Correlated Avg subquery on d_date_sk - pre-computed CTE can give 2-3x speedup",
        "suggestion": "Extract correlated aggregate into separate CTE with GROUP BY, then JOIN",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      }
    ],
    "query_93": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      }
    ],
    "query_94": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(DISTINCT ws_order_number' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: ws2, ws1",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "QT-DIST-001",
        "name": "Potentially Unnecessary DISTINCT",
        "severity": "low",
        "category": "optimization",
        "description": "DISTINCT adds overhead - verify it's needed",
        "suggestion": "Remove DISTINCT if query already returns unique rows",
        "location": "__main__:3"
      },
      {
        "rule_id": "SQL-SUB-006",
        "name": "EXISTS with SELECT *",
        "severity": "high",
        "category": "subqueries",
        "description": "EXISTS with SELECT * - use SELECT 1",
        "suggestion": "Use SELECT 1 in EXISTS for explicit intent",
        "location": "__main__"
      }
    ],
    "query_95": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(DISTINCT ws_order_number' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: ws1, ws_wh",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      },
      {
        "rule_id": "QT-DIST-001",
        "name": "Potentially Unnecessary DISTINCT",
        "severity": "low",
        "category": "optimization",
        "description": "DISTINCT adds overhead - verify it's needed",
        "suggestion": "Remove DISTINCT if query already returns unique rows",
        "location": "__main__:8"
      },
      {
        "rule_id": "SQL-SUB-002",
        "name": "Subquery Instead of JOIN",
        "severity": "medium",
        "category": "subqueries",
        "description": "IN with subquery - consider JOIN for clarity",
        "suggestion": "Consider rewriting as JOIN",
        "location": "__main__:24"
      },
      {
        "rule_id": "SQL-DUCK-018",
        "name": "Nested Loop Join Risk",
        "severity": "medium",
        "category": "duckdb",
        "description": "IN (subquery) in WHERE - consider JOIN for better optimization",
        "suggestion": "Rewrite as explicit JOIN for better optimizer choices",
        "location": "__main__:24"
      },
      {
        "rule_id": "QT-OPT-005",
        "name": "Scan Consolidation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Table scanned multiple times [web_sales(2x)] - consolidate with CASE WHEN for 1.5-2x speedup",
        "suggestion": "Combine multiple scans into single scan with CASE WHEN conditional aggregates",
        "location": "__main__"
      }
    ],
    "query_96": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'COUNT(*)' computed 2 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-009",
        "name": "Join Reordering",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "Join order may benefit from reordering - filtered tables: store, time_dim",
        "suggestion": "Put tables with selective filters earlier in join order",
        "location": "__main__"
      }
    ],
    "query_97": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-CTE-002",
        "name": "Single-Use CTE",
        "severity": "low",
        "category": "optimization",
        "description": "CTE 'ssci' used once - inline to enable pushdown",
        "suggestion": "Inline single-use CTE to enable predicate pushdown",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-010",
        "name": "Inline Single-Use CTE",
        "severity": "optimization",
        "category": "optimization_opportunity",
        "description": "CTE 'ssci' used once - consider inlining",
        "suggestion": "Inline CTE as subquery since it's only used once",
        "location": "__main__"
      }
    ],
    "query_98": [
      {
        "rule_id": "SQL-AGG-006",
        "name": "Repeated Aggregation",
        "severity": "medium",
        "category": "aggregation",
        "description": "Aggregation 'SUM(ss_ext_sales_price)' computed 3 times - use CTE",
        "suggestion": "Compute aggregation once in CTE, reference multiple times",
        "location": "__main__"
      },
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "QT-OPT-003",
        "name": "Date CTE Isolation",
        "severity": "high",
        "category": "optimization_opportunity",
        "description": "Date filter (d_date) with fact table - early CTE can give 1.5-2.5x speedup",
        "suggestion": "Extract date filtering into a CTE and join early to fact tables",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 5 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ],
    "query_99": [
      {
        "rule_id": "QT-AGG-002",
        "name": "Aggregate After Join",
        "severity": "info",
        "category": "optimization",
        "description": "Aggregate after join - consider pre-aggregating",
        "suggestion": "Pre-aggregate in subquery before joining",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-AGG-002",
        "name": "GROUP BY on Expression",
        "severity": "medium",
        "category": "aggregation",
        "description": "GROUP BY SUBSTRING() - consider computed column",
        "suggestion": "Use computed column or pre-calculate",
        "location": "__main__"
      },
      {
        "rule_id": "SQL-DUCK-002",
        "name": "Explicit GROUP BY",
        "severity": "low",
        "category": "duckdb",
        "description": "GROUP BY with 3 columns - consider GROUP BY ALL",
        "suggestion": "DuckDB supports GROUP BY ALL to auto-group non-aggregated columns",
        "location": "__main__"
      }
    ]
  }
}