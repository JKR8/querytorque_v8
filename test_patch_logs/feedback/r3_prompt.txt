You are a SQL rewrite engine for PostgreSQL v14.3.
Preserve exact semantic equivalence (same rows, same columns, same ordering).

## Original SQL

```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sr_reason_sk as ctr_reason_sk
,sum(SR_RETURN_AMT_INC_TAX) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2002
and sr_return_amt / sr_return_quantity between 108 and 167
group by sr_customer_sk
,sr_store_sk, sr_reason_sk)
 select  c_customer_id
from customer_total_return ctr1
,store
,customer
,customer_demographics
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk
)
and ctr1.ctr_reason_sk BETWEEN 43 AND 46
and s_store_sk = ctr1.ctr_store_sk
and s_state IN ('IL', 'KY', 'TX')
and ctr1.ctr_customer_sk = c_customer_sk
and c_current_cdemo_sk = cd_demo_sk
and cd_marital_status IN ('M', 'M')
and cd_education_status IN ('Advanced Degree', 'College')
and cd_gender = 'F'
and c_birth_month = 2
and c_birth_year BETWEEN 1965 AND 1971
order by c_customer_id
limit 100;
```

## IR Node Map

```
S0 [SELECT]
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: store_returns, date_dim
    WHERE [ddc05012d854ff26]: sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN ...
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store, customer, customer_demographics
    WHERE [a05952426f9ba20b]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WH...
    ORDER BY: c_customer_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Previous Round Feedback

## Round 3 Results (baseline: 7752ms, None rows)

### P1_decorrelate_v2: WIN 1.18x (6596ms)
Steps: s1: insert_cte — ; s2: replace_from — ; s3: replace_where_predicate — 
EXPLAIN top:
```
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=63552.92..63552.93 rows=1 width=17) (actual time=6595.747..6595.795 rows=0 loops=1)
   Buffers: shared hit=821152 read=82770, temp read=627211 written=583
   CTE customer_total_return
     ->  Finalize GroupAggregate  (cost=62623.82..62649.31 rows=197 width=44) (actual time=431.884..476.757 rows=95599 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=818258 read=82699, temp read=243 written=244
```

### P2_pushdown_v2: NO IMPROVEMENT (7005ms)
Steps: s1: insert_cte — ; s2: replace_from — ; s3: replace_where_predicate — 
EXPLAIN top:
```
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=63552.92..63552.93 rows=1 width=17) (actual time=7004.091..7004.187 rows=0 loops=1)
   Buffers: shared hit=804245 read=99677, temp read=627211 written=583
   CTE customer_total_return
     ->  Finalize GroupAggregate  (cost=62623.82..62649.31 rows=197 width=44) (actual time=439.457..485.113 rows=95599 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=801351 read=99606, temp read=243 written=244
```

### P3_restructure_v2: FAILED TO APPLY
Error: Step s1 failed: No target found for replace_from step s1
Steps: s1: replace_from — ; s2: replace_where_predicate — 

### P4_combined_v2: WIN 1.16x (6686ms)
Steps: s1: insert_cte — ; s2: insert_cte — ; s3: replace_from — ; s4: replace_where_predicate — 
EXPLAIN top:
```
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=63552.92..63552.93 rows=1 width=17) (actual time=6685.790..6685.852 rows=0 loops=1)
   Buffers: shared hit=806647 read=97275, temp read=627211 written=583
   CTE customer_total_return
     ->  Finalize GroupAggregate  (cost=62623.82..62649.31 rows=197 width=44) (actual time=417.378..463.913 rows=95599 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=803753 read=97204, temp read=243 written=244
```


## Task

Based on the feedback above, produce **4 improved patch plans** — one per strategy slot.
- If a plan WON, try to improve it further or combine its strategy with others.
- If a plan had WRONG RESULTS, fix the semantic error (usually: predicates dropped by replace_where_predicate — use replace_expr_subtree instead to target only the specific predicate).
- If a plan FAILED TO APPLY, simplify it or use different operations.
- If a plan had NO IMPROVEMENT, try a fundamentally different approach.

### Strategy Slots (you MUST use a different strategy for each)

**P1 DECORRELATE**: Pre-compute correlated subqueries into CTEs, use `replace_from` to JOIN them.
**P2 PREDICATE PUSHDOWN**: Push selective filters into CTE definitions or earlier FROM.
**P3 RESTRUCTURE**: Convert comma-joins to explicit JOINs via `replace_from`.
**P4 COMBINED**: Best elements of P1+P2+P3 together.

## Available Operations

| op | required fields | description |
|---|---|---|
| `insert_cte` | `by_node_id`, `cte_name`, `cte_query_sql` | Add a new CTE |
| `replace_expr_subtree` | `by_node_id`, `by_anchor_hash`, `expr_sql` | Replace one expression |
| `replace_where_predicate` | `by_node_id`, `by_anchor_hash`, `expr_sql` | Replace ENTIRE WHERE clause |
| `replace_from` | `by_node_id`, `from_sql` | Replace entire FROM+JOINs of a SELECT |
| `delete_expr_subtree` | `by_node_id`, `by_anchor_hash` | Delete an expression |

`replace_from`: `from_sql` is everything after FROM, before WHERE.

## CRITICAL rules

- `by_anchor_hash`: copy the 16-char hex from `[...]` in the IR Node Map. Do NOT invent hashes.
- `replace_where_predicate` replaces the ENTIRE WHERE clause. To replace just ONE predicate in a multi-AND WHERE, use `replace_expr_subtree` with that predicate's anchor hash.
- Every `cte_query_sql`, `expr_sql`, and `from_sql` must be complete, syntactically valid SQL.
- Each plan must preserve ALL existing predicates unless intentionally restructured.
- Fields can be flat at step level (no need for target/payload nesting).

## Output: JSON array of 4 plans

```json
[
  {"plan_id": "P1_...", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P2_...", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P3_...", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P4_...", "dialect": "postgres", "steps": [...]}
]
```

After the JSON, write one line per plan: `P1: <strategy> — expected speedup: <estimate>`