You are a SQL rewrite engine for PostgreSQL v14.3.
Preserve exact semantic equivalence (same rows, same columns, same ordering).

## Original SQL

```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sr_reason_sk as ctr_reason_sk
,sum(SR_RETURN_AMT_INC_TAX) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2002
and sr_return_amt / sr_return_quantity between 108 and 167
group by sr_customer_sk
,sr_store_sk, sr_reason_sk)
 select  c_customer_id
from customer_total_return ctr1
,store
,customer
,customer_demographics
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk
)
and ctr1.ctr_reason_sk BETWEEN 43 AND 46
and s_store_sk = ctr1.ctr_store_sk
and s_state IN ('IL', 'KY', 'TX')
and ctr1.ctr_customer_sk = c_customer_sk
and c_current_cdemo_sk = cd_demo_sk
and cd_marital_status IN ('M', 'M')
and cd_education_status IN ('Advanced Degree', 'College')
and cd_gender = 'F'
and c_birth_month = 2
and c_birth_year BETWEEN 1965 AND 1971
order by c_customer_id
limit 100;
```

## IR Node Map

```
S0 [SELECT]
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: store_returns, date_dim
    WHERE [ddc05012d854ff26]: sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store, customer, customer_demographics
    WHERE [a05952426f9ba20b]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk) AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_store_sk = ctr1.ctr_store_sk AND s_state IN ('IL', 'KY', 'TX') AND ctr1.ctr_customer_sk = c_customer_sk AND c_current_cdemo_sk = cd_demo_sk AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971
    ORDER BY: c_customer_id

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Previous Round Feedback

## Round 2 Results (baseline: 8673ms, None rows)

### P1_decorrelate: WIN 13.89x (625ms)
Steps: s1: insert_cte — ; s2: replace_from — ; s3: replace_where_predicate — 
EXPLAIN top:
```
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=62680.20..62680.20 rows=1 width=17) (actual time=623.918..623.964 rows=0 loops=1)
   Buffers: shared hit=803284 read=98960, temp read=582 written=583
   CTE customer_total_return
     ->  Finalize GroupAggregate  (cost=62623.82..62649.31 rows=197 width=44) (actual time=521.369..585.699 rows=95599 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=802069 read=98888, temp read=243 written=244
```

### P2_pushdown: WIN 16.93x (512ms)
Steps: s1: replace_expr_subtree — 
EXPLAIN top:
```
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=65293.47..65293.48 rows=1 width=17) (actual time=512.218..512.282 rows=0 loops=1)
   Buffers: shared hit=808351 read=95760
   CTE customer_total_return
     ->  GroupAggregate  (cost=65271.29..65271.39 rows=4 width=44) (actual time=373.257..374.316 rows=1845 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=805253 read=95693
```

### P3_restructure: NO IMPROVEMENT (8828ms)
Steps: s1: replace_from — ; s2: replace_where_predicate — 
EXPLAIN top:
```
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=63552.92..63552.93 rows=1 width=17) (actual time=8827.084..8827.149 rows=0 loops=1)
   Buffers: shared hit=799780 read=104142, temp read=627211 written=583
   CTE customer_total_return
     ->  Finalize GroupAggregate  (cost=62623.82..62649.31 rows=197 width=44) (actual time=504.545..564.022 rows=95599 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=796886 read=104071, temp read=243 written=244
```

### P4_combined: WIN 20.91x (415ms)
Steps: s1: replace_expr_subtree — ; s2: insert_cte — ; s3: replace_from — ; s4: replace_where_predicate — 
EXPLAIN top:
```
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=65291.95..65291.96 rows=1 width=17) (actual time=414.620..414.668 rows=0 loops=1)
   Buffers: shared hit=803656 read=98649
   CTE customer_total_return
     ->  GroupAggregate  (cost=65271.29..65271.39 rows=4 width=44) (actual time=385.787..386.863 rows=1845 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=802365 read=98581
```


## Task

Based on the feedback above, produce **4 improved patch plans** — one per strategy slot.
- If a plan WON, try to improve it further or combine its strategy with others.
- If a plan had WRONG RESULTS, fix the semantic error (usually: predicates dropped by replace_where_predicate — use replace_expr_subtree instead to target only the specific predicate).
- If a plan FAILED TO APPLY, simplify it or use different operations.
- If a plan had NO IMPROVEMENT, try a fundamentally different approach.

### Strategy Slots (you MUST use a different strategy for each)

**P1 DECORRELATE**: Pre-compute correlated subqueries into CTEs, use `replace_from` to JOIN them.
**P2 PREDICATE PUSHDOWN**: Push selective filters into CTE definitions or earlier FROM.
**P3 RESTRUCTURE**: Convert comma-joins to explicit JOINs via `replace_from`.
**P4 COMBINED**: Best elements of P1+P2+P3 together.

## Available Operations

| op | required fields | description |
|---|---|---|
| `insert_cte` | `by_node_id`, `cte_name`, `cte_query_sql` | Add a new CTE |
| `replace_expr_subtree` | `by_node_id`, `by_anchor_hash`, `expr_sql` | Replace one expression |
| `replace_where_predicate` | `by_node_id`, `by_anchor_hash`, `expr_sql` | Replace ENTIRE WHERE clause |
| `replace_from` | `by_node_id`, `from_sql` | Replace entire FROM+JOINs of a SELECT |
| `delete_expr_subtree` | `by_node_id`, `by_anchor_hash` | Delete an expression |

`replace_from`: `from_sql` is everything after FROM, before WHERE.

## CRITICAL rules

- `by_anchor_hash`: copy the 16-char hex from `[...]` in the IR Node Map. Do NOT invent hashes.
- `replace_where_predicate` replaces the ENTIRE WHERE clause. To replace just ONE predicate in a multi-AND WHERE, use `replace_expr_subtree` with that predicate's anchor hash.
- Every `cte_query_sql`, `expr_sql`, and `from_sql` must be complete, syntactically valid SQL.
- Each plan must preserve ALL existing predicates unless intentionally restructured.
- Fields can be flat at step level (no need for target/payload nesting).

## Output: JSON array of 4 plans

```json
[
  {"plan_id": "P1_...", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P2_...", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P3_...", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P4_...", "dialect": "postgres", "steps": [...]}
]
```

After the JSON, write one line per plan: `P1: <strategy> — expected speedup: <estimate>`