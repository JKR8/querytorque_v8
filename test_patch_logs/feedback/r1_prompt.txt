You are a SQL rewrite engine for PostgreSQL v14.3.
Preserve exact semantic equivalence (same rows, same columns, same ordering).

## Original SQL

```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sr_reason_sk as ctr_reason_sk
,sum(SR_RETURN_AMT_INC_TAX) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2002
and sr_return_amt / sr_return_quantity between 108 and 167
group by sr_customer_sk
,sr_store_sk, sr_reason_sk)
 select  c_customer_id
from customer_total_return ctr1
,store
,customer
,customer_demographics
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk
)
and ctr1.ctr_reason_sk BETWEEN 43 AND 46
and s_store_sk = ctr1.ctr_store_sk
and s_state IN ('IL', 'KY', 'TX')
and ctr1.ctr_customer_sk = c_customer_sk
and c_current_cdemo_sk = cd_demo_sk
and cd_marital_status IN ('M', 'M')
and cd_education_status IN ('Advanced Degree', 'College')
and cd_gender = 'F'
and c_birth_month = 2
and c_birth_year BETWEEN 1965 AND 1971
order by c_customer_id
limit 100;
```

## IR Node Map

```
S0 [SELECT]
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: store_returns, date_dim
    WHERE [ddc05012d854ff26]: sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN ...
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store, customer, customer_demographics
    WHERE [a05952426f9ba20b]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WH...
    ORDER BY: c_customer_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Task

Produce **4 patch plans** — one per strategy slot below. Each plan is a self-contained
JSON object applied to the ORIGINAL IR (not chained).

### Strategy Slots (you MUST use a different strategy for each)

**P1 DECORRELATE**: Pre-compute the correlated subquery (e.g. AVG/MAX subquery in WHERE)
into a CTE, then use `replace_from` to JOIN that CTE instead, and `replace_expr_subtree`
or `delete_expr_subtree` to swap the old subquery predicate for a simple column reference.
Typical steps: `insert_cte` + `replace_from` + `replace_expr_subtree`.

**P2 PREDICATE PUSHDOWN**: Push selective WHERE filters into CTE definitions or earlier
in the FROM chain to reduce intermediate result sizes before expensive joins/subqueries.
Typical steps: `insert_cte` + `replace_expr_subtree`.

**P3 RESTRUCTURE**: Convert comma-joins to explicit JOINs via `replace_from`, or
restructure the FROM clause for better optimizer join ordering.
Typical steps: `replace_from` (possibly combined with `replace_expr_subtree` to move
predicates from WHERE into JOIN ON).

**P4 COMBINED**: Best elements of P1+P2+P3 together — decorrelate AND push predicates
AND restructure joins in a single plan.

## Available Operations

| op | required fields | description |
|---|---|---|
| `insert_cte` | `by_node_id`, `cte_name`, `cte_query_sql` | Add a new CTE |
| `replace_expr_subtree` | `by_node_id`, `by_anchor_hash`, `expr_sql` | Replace one expression |
| `replace_where_predicate` | `by_node_id`, `by_anchor_hash`, `expr_sql` | Replace ENTIRE WHERE clause |
| `replace_from` | `by_node_id`, `from_sql` | Replace entire FROM+JOINs of a SELECT |
| `delete_expr_subtree` | `by_node_id`, `by_anchor_hash` | Delete an expression |

`replace_from`: `from_sql` is everything after FROM, before WHERE. Example:
```
"from_sql": "customer_total_return AS ctr1 JOIN store_avg sa ON sa.ctr_store_sk = ctr1.ctr_store_sk JOIN store ON s_store_sk = ctr1.ctr_store_sk"
```

## CRITICAL rules

- `by_anchor_hash`: copy the 16-char hex from `[...]` in the IR Node Map. Do NOT compute your own.
- `replace_where_predicate` replaces the ENTIRE WHERE clause. If you only want to replace one predicate within a multi-AND WHERE, use `replace_expr_subtree` targeting that predicate's anchor hash.
- Every `cte_query_sql`, `expr_sql`, and `from_sql` must be complete, syntactically valid SQL.
- Each plan must preserve ALL existing predicates unless intentionally restructured.
- Fields can be flat at step level (no need to nest in target/payload).

## Output: JSON array of 4 plans

```json
[
  {"plan_id": "P1_decorrelate", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P2_pushdown", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P3_restructure", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P4_combined", "dialect": "postgres", "steps": [...]}
]
```

After the JSON, write one line per plan: `P1: <strategy> — expected speedup: <estimate>`