You are a SQL rewrite engine for PostgreSQL v14.3. Follow the Target Query Map structure below. Write correct, executable SQL for each node. Preserve exact semantic equivalence (same rows, same columns, same ordering).

**Assignment:** Strategy: decorrelate_subquery | Approach: Pre-compute per-store average return amounts in a CTE to avoid correlated subquery re-execution.

## Semantic Contract (MUST preserve)

Preserve exact row count, column names, ordering, and all aggregate values.

## Approach

Pre-compute per-store average return amounts in a CTE to avoid correlated subquery re-execution.

## Hazard Flags (avoid these specific risks)

Do not change column aliases in the final SELECT.

## Original SQL

```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sr_reason_sk as ctr_reason_sk
,sum(SR_RETURN_AMT_INC_TAX) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2002
and sr_return_amt / sr_return_quantity between 108 and 167
group by sr_customer_sk
,sr_store_sk, sr_reason_sk)
 select  c_customer_id
from customer_total_return ctr1
,store
,customer
,customer_demographics
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk
)
and ctr1.ctr_reason_sk BETWEEN 43 AND 46
and s_store_sk = ctr1.ctr_store_sk
and s_state IN ('IL', 'KY', 'TX')
and ctr1.ctr_customer_sk = c_customer_sk
and c_current_cdemo_sk = cd_demo_sk
and cd_marital_status IN ('M', 'M')
and cd_education_status IN ('Advanced Degree', 'College')
and cd_gender = 'F'
and c_birth_month = 2
and c_birth_year BETWEEN 1965 AND 1971
order by c_customer_id
limit 100;
```

## Rewrite Checklist (must pass before final SQL)

- Follow every node in `TARGET_QUERY_MAP` and produce each `NODE_CONTRACT` output column exactly.
- Keep all semantic invariants from `Semantic Contract` and `Constraints`.
- Preserve all literals and the exact final output schema/order.
- Apply `Hazard Flags` and `Regression Warnings` as hard guards.
- Verify your rewrite addresses the CURRENT_PLAN_GAP divergences.

### Column Completeness Contract

The final query MUST produce exactly these columns (same names, same order): `c_customer_id`

## IR Node Map

The original query has been parsed into a stable IR with the following structure:

```
S0 [SELECT]
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: store_returns, date_dim
    WHERE [ddc05012d854ff26]: sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store, customer, customer_demographics
    WHERE [a05952426f9ba20b]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk) AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_store_sk = ctr1.ctr_store_sk AND s_state IN ('IL', 'KY', 'TX') AND ctr1.ctr_customer_sk = c_customer_sk AND c_current_cdemo_sk = cd_demo_sk AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971
    ORDER BY: c_customer_id

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Output Format — Patch Plan

Emit a single JSON object describing ONLY the changes (not the full SQL).
The patch engine will apply your steps atomically to the IR above.

```json
{"plan_id": "W<N>_<query_id>", "dialect": "<dialect>",
 "steps": [
   {"step_id": "s1", "op": "<operation>",
    "target": {"by_node_id": "<statement_id>"},
    "payload": { ... },
    "description": "<what this step does>"}
 ]}
```

### Available Operations

| op | target fields | payload fields | description |
|---|---|---|---|
| `insert_cte` | `by_node_id` | `cte_name`, `cte_query_sql` | Add a new CTE to a statement |
| `replace_expr_subtree` | `by_node_id` + `by_anchor_hash` | `expr_sql` | Replace an expression matched by hash |
| `replace_where_predicate` | `by_node_id` + `by_anchor_hash` | `expr_sql` | Replace a WHERE predicate matched by hash |
| `delete_expr_subtree` | `by_node_id` + `by_anchor_hash` | _(none)_ | Remove an expression matched by hash |

### Targeting

- `by_node_id`: Selects the statement (e.g. `"S0"`). Required for all ops.
- `by_anchor_hash`: For expression-level ops (`replace_expr_subtree`, `replace_where_predicate`, `delete_expr_subtree`), also provide `by_anchor_hash` — copy the 16-char hex hash shown in square brackets in the IR Node Map above (e.g. the `[abc123...]` next to WHERE). Do NOT compute your own hash.

### Rules
- Every `cte_query_sql` and `expr_sql` must be complete, executable SQL (no ellipsis).
- Steps are applied in order. Later steps see the IR state after earlier steps.
- The final query columns must match the Column Completeness Contract.

After JSON:
```
Changes: <1-2 sentences>
Expected speedup: <estimate>
```

Now output your Patch Plan JSON: