You are a SQL rewrite engine for PostgreSQL v14.3.
Preserve exact semantic equivalence (same rows, same columns, same ordering).

## Reference Example (patch format)

**early_filter_decorrelate** (27.80x): Decorrelate correlated AVG subquery into pre-computed CTE, then replace WHERE with CTE lookup

Steps that produced the speedup:
1. `insert_cte` name=`store_thresholds`: `SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_limit FROM customer_total_return GROUP BY ctr_store_sk`
2. `replace_where_predicate`: Replace correlated subquery with threshold CTE lookup
   BEFORE: `ctr1.ctr_total_return > (SELECT AVG(...) FROM ctr2 WHERE correlated)`
   AFTER: `ctr1.ctr_total_return > (SELECT avg_limit FROM store_thresholds WHERE ...)`

## Original SQL

```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sr_reason_sk as ctr_reason_sk
,sum(SR_RETURN_AMT_INC_TAX) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2002
and sr_return_amt / sr_return_quantity between 108 and 167
group by sr_customer_sk
,sr_store_sk, sr_reason_sk)
 select  c_customer_id
from customer_total_return ctr1
,store
,customer
,customer_demographics
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk
)
and ctr1.ctr_reason_sk BETWEEN 43 AND 46
and s_store_sk = ctr1.ctr_store_sk
and s_state IN ('IL', 'KY', 'TX')
and ctr1.ctr_customer_sk = c_customer_sk
and c_current_cdemo_sk = cd_demo_sk
and cd_marital_status IN ('M', 'M')
and cd_education_status IN ('Advanced Degree', 'College')
and cd_gender = 'F'
and c_birth_month = 2
and c_birth_year BETWEEN 1965 AND 1971
order by c_customer_id
limit 100;
```

## IR Node Map

```
S0 [SELECT]
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: store_returns, date_dim
    WHERE [ddc05012d854ff26]: sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store, customer, customer_demographics
    WHERE [a05952426f9ba20b]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk) AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_store_sk = ctr1.ctr_store_sk AND s_state IN ('IL', 'KY', 'TX') AND ctr1.ctr_customer_sk = c_customer_sk AND c_current_cdemo_sk = cd_demo_sk AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971
    ORDER BY: c_customer_id

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Task

Apply the decorrelation pattern from the example above to this query.
Emit a single patch plan JSON with steps applied in order.

Available ops: `insert_cte`, `replace_where_predicate`, `replace_expr_subtree`, `delete_expr_subtree`
- `by_node_id`: Statement ID (e.g. `"S0"`). Required for all.
- `by_anchor_hash`: Copy the 16-char hex hash from `[...]` in the IR Node Map. Required for expression ops.
- Payload: `cte_name`+`cte_query_sql` for insert_cte, `expr_sql` for replace ops.

```json
{"plan_id": "...", "dialect": "postgres", "steps": [...]}
```

After JSON, write: `Changes: <summary>` and `Expected speedup: <estimate>`

Now output your Patch Plan JSON: