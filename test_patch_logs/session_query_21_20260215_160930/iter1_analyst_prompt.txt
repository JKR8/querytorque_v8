## Role

You are a SQL optimization analyst reviewing benchmark results. Analyze what worked, what failed, and design refined targets for the next round of workers.

Identify the primary bottleneck. Only provide secondary targets if they are distinct and high-confidence. Quality > Quantity.

You will see the original query, execution plan, IR structure, and detailed results from the previous round.

## Query: query_21

**Dialect**: DUCKDB

```sql
-- start query 21 in stream 0 using template query21.tpl
select *
 from(select w_warehouse_name
            ,i_item_id
            ,sum(case when (cast(d_date as date) < cast ('2002-02-27' as date))
	                then inv_quantity_on_hand 
                      else 0 end) as inv_before
            ,sum(case when (cast(d_date as date) >= cast ('2002-02-27' as date))
                      then inv_quantity_on_hand 
                      else 0 end) as inv_after
   from inventory
       ,warehouse
       ,item
       ,date_dim
   where i_current_price between 0.99 and 1.49
     and i_item_sk          = inv_item_sk
     and inv_warehouse_sk   = w_warehouse_sk
     and inv_date_sk    = d_date_sk
     and d_date between (cast ('2002-02-27' as date) - INTERVAL 30 DAY)
                    and (cast ('2002-02-27' as date) + INTERVAL 30 DAY)
   group by w_warehouse_name, i_item_id) x
 where (case when inv_before > 0 
             then inv_after / inv_before 
             else null
             end) between 2.0/3.0 and 3.0/2.0
 order by w_warehouse_name
         ,i_item_id
 LIMIT 100;

-- end query 21 in stream 0 using template query21.tpl
```


## Current Execution Plan

```
┌───────────────────────────┐
│           TOP_N           │
│    ────────────────────   │
│          Top: 100         │
│                           │
│         Order By:         │
│   x.w_warehouse_name ASC  │
│      x.i_item_id ASC      │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│           FILTER          │
│    ────────────────────   │
│ (CASE  WHEN ((inv_before >│
│  0)) THEN ((CAST(inv_after│
│      AS DOUBLE) / CAST    │
│  (inv_before AS DOUBLE))) │
│   ELSE NULL END BETWEEN 0 │
│ .6666666666666666 AND 1.5)│
│                           │
│        ~2,184 rows        │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│       HASH_GROUP_BY       │
│    ────────────────────   │
│          Groups:          │
│             #0            │
│             #1            │
│                           │
│        Aggregates:        │
│          sum(#2)          │
│          sum(#3)          │
│                           │
│        ~2,184 rows        │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│         PROJECTION        │
│    ────────────────────   │
│      w_warehouse_name     │
│         i_item_id         │
│   CASE  WHEN ((d_date <   │
│ '2002-02-27'::DATE)) THEN │
│   (inv_quantity_on_hand)  │
│         ELSE 0 END        │
│  CASE  WHEN ((d_date >=   │
│ '2002-02-27'::DATE)) THEN │
│   (inv_quantity_on_hand)  │
│         ELSE 0 END        │
│                           │
│      ~5,141,212 rows      │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│         HASH_JOIN         │
│    ────────────────────   │
│      Join Type: INNER     │
│                           │
│        Conditions:        ├────────────────────────────────────────────────────────────────────────┐
│     inv_warehouse_sk =    │                                                                        │
│       w_warehouse_sk      │                                                                        │
│                           │                                                                        │
│      ~5,141,212 rows      │                                                                        │
└─────────────┬─────────────┘                                                                        │
┌─────────────┴─────────────┐                                                          ┌─────────────┴─────────────┐
│         HASH_JOIN         │                                                          │         SEQ_SCAN          │
│    ────────────────────   │                                                          │    ────────────────────   │
│      Join Type: INNER     │                                                          │      Table: warehouse     │
│                           │                                                          │   Type: Sequential Scan   │
│        Conditions:        │                                                          │                           │
│  inv_item_sk = i_item_sk  ├───────────────────────────────────────────┐              │        Projections:       │
│                           │                                           │              │       w_warehouse_sk      │
│                           │                                           │              │      w_warehouse_name     │
│                           │                                           │              │                           │
│      ~5,655,333 rows      │                                           │              │          ~10 rows         │
└─────────────┬─────────────┘                                           │              └───────────────────────────┘
┌─────────────┴─────────────┐                             ┌─────────────┴─────────────┐
│         HASH_JOIN         │                             │         SEQ_SCAN          │
│    ────────────────────   │                             │    ────────────────────   │
│      Join Type: INNER     │                             │        Table: item        │
│                           │                             │   Type: Sequential Scan   │
│        Conditions:        │                             │                           │
│  inv_date_sk = d_date_sk  │                             │        Projections:       │
│                           │                             │         i_item_sk         │
│                           ├──────────────┐              │         i_item_id         │
│                           │              │              │                           │
│                           │              │              │          Filters:         │
│                           │              │              │ i_current_price>=0.99 AND │
│                           │              │              │    i_current_price<=1.49  │
│                           │              │              │                           │
│      ~26,620,542 rows     │              │              │        ~20,400 rows       │
└─────────────┬─────────────┘              │              └───────────────────────────┘
┌─────────────┴─────────────┐┌─────────────┴─────────────┐
│         SEQ_SCAN          ││           FILTER          │
│    ────────────────────   ││    ────────────────────   │
│      Table: inventory     ││ (d_date_sk BETWEEN 2450815│
│   Type: Sequential Scan   ││        AND 2452635)       │
│                           ││                           │
│        Projections:       ││                           │
│        inv_item_sk        ││                           │
│      inv_warehouse_sk     ││                           │
│        inv_date_sk        ││                           │
│    inv_quantity_on_hand   ││                           │
│                           ││                           │
│     ~133,110,000 rows     ││        ~14,609 rows       │
└───────────────────────────┘└─────────────┬─────────────┘
                             ┌─────────────┴─────────────┐
                             │         SEQ_SCAN          │
                             │    ────────────────────   │
                             │      Table: date_dim      │
                             │   Type: Sequential Scan   │
                             │                           │
                             │        Projections:       │
                             │         d_date_sk         │
                             │           d_date          │
                             │                           │
                             │          Filters:         │
                             │ (CAST(d_date AS TIMESTAMP)│
                             │  BETWEEN '2002-01-28 00:00│
                             │ :00'::TIMESTAMP AND '2002 │
                             │     -03-29 00:00:00':     │
                             │        :TIMESTAMP)        │
                             │                           │
                             │        ~14,609 rows       │
                             └───────────────────────────┘

```


## IR Structure (for patch targeting)

```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: (subquery) x
    WHERE [43499fffd10e5dc4]: (CASE WHEN inv_before > 0 THEN inv_after / inv_before ELSE NULL END) BETWEEN 2.0 / 3.0 AND 3.0 / 2.0
    ORDER BY: w_warehouse_name, i_item_id
S1 [OTHER_DDL]

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**Note**: Use `by_node_id` (e.g., "S0") and `by_anchor_hash` (16-char hex) from map above to target patch operations.


## Optimization Families

Review the 6 families below. Each shows a pattern with a gold example.

Choose up to **4 most relevant families** for this query based on:
- Query structure (CTEs, subqueries, joins, aggregations, set operations)
- Execution plan signals (WHERE placement, repeated scans, correlated subqueries, materializations)
- Problem signature (cardinality estimation errors, loops vs sets, filter ordering)



### Family A: Early Filtering (Predicate Pushback)
**Description**: Push small filters into CTEs early, reduce row count before expensive operations
**Speedup Range**: 1.3–4.0x (~35% of all wins)
**Use When**:
  1. Late WHERE filters on dimension tables
  2. Cascading CTEs with filters applied downstream
  3. Expensive joins after filters could be pushed earlier

**Gold Example**: `date_cte_isolate` (4.00x)

**BEFORE (slow):**
```sql
select a.ca_state state, count(*) cnt
 from customer_address a
     ,customer c
     ,store_sales s
     ,date_dim d
     ,item i
 where       a.ca_address_sk = c.c_current_addr_sk
 	and c.c_customer_sk = s.ss_customer_sk
 	and s.ss_sold_date_sk = d.d_date_sk
 	and s.ss_item_sk = i.i_item_sk
...
```

**AFTER (fast):**
```sql
WITH target_month AS (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3), category_avg AS (SELECT i_category, AVG(i_current_price) * 1.2 AS price_threshold FROM item GROUP BY i_category)
SELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address AS a JOIN customer AS c ON a.ca_address_sk = c.c_current_addr_sk JOIN store_sales AS s ON c.c_customer_sk = s.ss_customer_sk JOIN date_dim AS d ON s.ss_sold_date_sk = d.d_date_sk JOIN target_month AS tm ON d.d_month_seq = tm.d_month_seq JOIN item AS i ON s.ss_item_sk = i.i_item_sk JOIN category_avg AS ca ON i.i_category = ca.i_category WHERE i.i_current_price > ca.price_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100;
```

**IR BEFORE:**
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: customer_address a, customer c, store_sales s, date_dim d, item i
    WHERE [2837aea03aa52676]: a.ca_address_sk = c.c_current_addr_sk AND c.c_customer_sk = s.ss_customer_sk AND s.ss_sold_date_s...
    GROUP BY: a.ca_state
    ORDER BY: cnt, a.ca_state

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: target_month  (via CTE_Q_S0_target_month)
    FROM: date_dim
    WHERE [198e5f8f07395c48]: d_year = 2002 AND d_moy = 3
  CTE: category_avg  (via CTE_Q_S0_category_avg)
    FROM: item
    GROUP BY: i_category
  MAIN QUERY (via Q_S0)
    FROM: customer_address a, customer c, store_sales s, date_dim d, target_month tm, item i, category_avg ca
    WHERE [031e98036ebea62d]: i.i_current_price > ca.price_threshold
    GROUP BY: a.ca_state
    ORDER BY: cnt, a.ca_state

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```



### Family B: Decorrelation (Sets Over Loops)
**Description**: Convert correlated subqueries to standalone CTEs with GROUP BY, eliminate per-row re-execution
**Speedup Range**: 2.4–2.9x (~15% of all wins)
**Use When**:
  1. Correlated subqueries in WHERE clause
  2. Scalar aggregates computed per outer row
  3. DELIM_SCAN in execution plan (indicates correlation)

**Gold Example**: `decorrelate` (2.92x)

**BEFORE (slow):**
```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sum(SR_FEE) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2000
group by sr_customer_sk
,sr_store_sk)
...
```

**AFTER (fast):**
```sql
WITH filtered_returns AS (SELECT sr.sr_customer_sk, sr.sr_store_sk, sr.SR_FEE FROM store_returns AS sr JOIN date_dim AS d ON sr.sr_returned_date_sk = d.d_date_sk JOIN store AS s ON sr.sr_store_sk = s.s_store_sk WHERE d.d_year = 2000 AND s.s_state = 'SD'), customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(SR_FEE) AS ctr_total_return FROM filtered_returns GROUP BY sr_customer_sk, sr_store_sk), store_avg_return AS (SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_return_threshold FROM customer_total_return GROUP BY ctr_store_sk)
SELECT c.c_customer_id FROM customer_total_return AS ctr1 JOIN store_avg_return AS sar ON ctr1.ctr_store_sk = sar.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c.c_customer_sk WHERE ctr1.ctr_total_return > sar.avg_return_threshold ORDER BY c.c_customer_id LIMIT 100;
```

**IR BEFORE:**
```
S0 [SELECT]
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: store_returns, date_dim
    WHERE [eb0f6bc97f7168d4]: sr_returned_date_sk = d_date_sk AND d_year = 2000
    GROUP BY: sr_customer_sk, sr_store_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store, customer
    WHERE [e5b7485395ff5a80]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WH...
    ORDER BY: c_customer_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: filtered_returns  (via CTE_Q_S0_filtered_returns)
    FROM: store_returns sr, date_dim d, store s
    WHERE [e49579c0ddbdbdda]: d.d_year = 2000 AND s.s_state = 'SD'
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: filtered_returns
    GROUP BY: sr_customer_sk, sr_store_sk
  CTE: store_avg_return  (via CTE_Q_S0_store_avg_return)
    FROM: customer_total_return
    GROUP BY: ctr_store_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store_avg_return sar, customer c
    WHERE [0f5f48abeb70c147]: ctr1.ctr_total_return > sar.avg_return_threshold
    ORDER BY: c.c_customer_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```



### Family C: Aggregation Pushdown (Minimize Rows Touched)
**Description**: Aggregate before expensive joins when GROUP BY keys ⊇ join keys, reduce intermediate sizes
**Speedup Range**: 1.3–15.3x (~5% of all wins (high variance))
**Use When**:
  1. GROUP BY happens after large joins
  2. GROUP BY keys are subset of join keys
  3. Intermediate result size >> final result size

**Gold Example**: `aggregate_pushdown` (42.90x)

**BEFORE (slow):**
```sql
select i_product_name
             ,i_brand
             ,i_class
             ,i_category
             ,avg(inv_quantity_on_hand) qoh
       from inventory
           ,date_dim
           ,item
       where inv_date_sk=d_date_sk
              and inv_item_sk=i_item_sk
...
```

**AFTER (fast):**
```sql
WITH date_filtered AS (SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1188 AND 1188 + 11), inventory_date AS (SELECT inv_item_sk, inv_quantity_on_hand FROM inventory JOIN date_filtered ON inv_date_sk = d_date_sk), inventory_agg AS (SELECT inv_item_sk, SUM(inv_quantity_on_hand) AS sum_qty, COUNT(inv_quantity_on_hand) AS cnt FROM inventory_date GROUP BY inv_item_sk), join_item AS (SELECT i_product_name, i_brand, i_class, i_category, sum_qty, cnt FROM inventory_agg JOIN item ON inv_item_sk = i_item_sk), rollup_aggregate AS (SELECT i_product_name, i_brand, i_class, i_category, CASE WHEN SUM(cnt) > 0 THEN SUM(sum_qty) / SUM(cnt) END AS qoh FROM join_item GROUP BY ROLLUP(i_product_name, i_brand, i_class, i_category)) SELECT i_product_name, i_brand, i_class, i_category, qoh FROM rollup_aggregate ORDER BY qoh ASC, i_product_name ASC, i_brand ASC, i_class ASC, i_category ASC LIMIT 100
```

**IR BEFORE:**
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: inventory, date_dim, item
    WHERE [cb0b927b3e0ad199]: inv_date_sk = d_date_sk AND inv_item_sk = i_item_sk AND d_month_seq BETWEEN 1188 AND 1188 + 11
    ORDER BY: qoh, i_product_name, i_brand, i_class, i_category

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: date_filtered  (via CTE_Q_S0_date_filtered)
    FROM: date_dim
    WHERE [64df5f706f9f2db0]: d_month_seq BETWEEN 1188 AND 1188 + 11
  CTE: inventory_date  (via CTE_Q_S0_inventory_date)
    FROM: inventory, date_filtered
  CTE: inventory_agg  (via CTE_Q_S0_inventory_agg)
    FROM: inventory_date
    GROUP BY: inv_item_sk
  CTE: join_item  (via CTE_Q_S0_join_item)
    FROM: inventory_agg, item
  CTE: rollup_aggregate  (via CTE_Q_S0_rollup_aggregate)
    FROM: join_item
  MAIN QUERY (via Q_S0)
    FROM: rollup_aggregate
    ORDER BY: qoh, i_product_name, i_brand, i_class, i_category

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```



### Family D: Set Operation Optimization (Sets Over Loops)
**Description**: Replace INTERSECT/UNION-based patterns with EXISTS/NOT EXISTS, avoid full materialization
**Speedup Range**: 1.7–2.7x (~8% of all wins)
**Use When**:
  1. INTERSECT patterns between large sets
  2. UNION ALL with duplicate elimination
  3. Set operations materializing full intermediate results

**Gold Example**: `intersect_to_exists` (1.83x)

**BEFORE (slow):**
```sql
with  cross_items as
 (select i_item_sk ss_item_sk
 from item,
 (select iss.i_brand_id brand_id
     ,iss.i_class_id class_id
     ,iss.i_category_id category_id
 from store_sales
     ,item iss
     ,date_dim d1
 where ss_item_sk = iss.i_item_sk
...
```

**AFTER (fast):**
```sql
WITH cross_items AS (SELECT i.i_item_sk AS ss_item_sk FROM item AS i WHERE EXISTS(SELECT 1 FROM store_sales, item AS iss, date_dim AS d1 WHERE ss_item_sk = iss.i_item_sk AND ss_sold_date_sk = d1.d_date_sk AND d1.d_year BETWEEN 2000 AND 2000 + 2 AND iss.i_brand_id = i.i_brand_id AND iss.i_class_id = i.i_class_id AND iss.i_category_id = i.i_category_id) AND EXISTS(SELECT 1 FROM catalog_sales, item AS ics, date_dim AS d2 WHERE cs_item_sk = ics.i_item_sk AND cs_sold_date_sk = d2.d_date_sk AND d2.d_year BETWEEN 2000 AND 2000 + 2 AND ics.i_brand_id = i.i_brand_id AND ics.i_class_id = i.i_class_id AND ics.i_category_id = i.i_category_id) AND EXISTS(SELECT 1 FROM web_sales, item AS iws, date_dim AS d3 WHERE ws_item_sk = iws.i_item_sk AND ws_sold_date_sk = d3.d_date_sk AND d3.d_year BETWEEN 2000 AND 2000 + 2 AND iws.i_brand_id = i.i_brand_id AND iws.i_class_id = i.i_class_id AND iws.i_category_id = i.i_category_id)), avg_sales AS (SELECT AVG(quantity * list_price) AS average_sales FROM (SELECT ss_quantity AS quantity, ss_list_price AS list_price FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2000 + 2 UNION ALL SELECT cs_quantity AS quantity, cs_list_price AS list_price FROM catalog_sales, date_dim WHERE cs_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2000 + 2 UNION ALL SELECT ws_quantity AS quantity, ws_list_price AS list_price FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2000 + 2) AS x)
SELECT channel, i_brand_id, i_class_id, i_category_id, SUM(sales), SUM(number_sales) FROM (SELECT 'store' AS channel, i_brand_id, i_class_id, i_category_id, SUM(ss_quantity * ss_list_price) AS sales, COUNT(*) AS number_sales FROM store_sales, item, date_dim WHERE ss_item_sk IN (SELECT ss_item_sk FROM cross_items) AND ss_item_sk = i_item_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2000 + 2 AND d_moy = 11 GROUP BY i_brand_id, i_class_id, i_category_id HAVING SUM(ss_quantity * ss_list_price) > (SELECT average_sales FROM avg_sales) UNION ALL SELECT 'catalog' AS channel, i_brand_id, i_class_id, i_category_id, SUM(cs_quantity * cs_list_price) AS sales, COUNT(*) AS number_sales FROM catalog_sales, item, date_dim WHERE cs_item_sk IN (SELECT ss_item_sk FROM cross_items) AND cs_item_sk = i_item_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2000 + 2 AND d_moy = 11 GROUP BY i_brand_id, i_class_id, i_category_id HAVING SUM(cs_quantity * cs_list_price) > (SELECT average_sales FROM avg_sales) UNION ALL SELECT 'web' AS channel, i_brand_id, i_class_id, i_category_id, SUM(ws_quantity * ws_list_price) AS sales, COUNT(*) AS number_sales FROM web_sales, item, date_dim WHERE ws_item_sk IN (SELECT ss_item_sk FROM cross_items) AND ws_item_sk = i_item_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2000 + 2 AND d_moy = 11 GROUP BY i_brand_id, i_class_id, i_category_id HAVING SUM(ws_quantity * ws_list_price) > (SELECT average_sales FROM avg_sales)) AS y GROUP BY ROLLUP (channel, i_brand_id, i_class_id, i_category_id) ORDER BY channel, i_brand_id, i_class_id, i_category_id LIMIT 100;
```

**IR BEFORE:**
```
S0 [SELECT]
  CTE: cross_items  (via CTE_Q_S0_cross_items)
    FROM: item, (subquery) 
    WHERE [3f561bc366ff68bb]: i_brand_id = brand_id AND i_class_id = class_id AND i_category_id = category_id
  CTE: avg_sales  (via CTE_Q_S0_avg_sales)
    FROM: (subquery) x
  MAIN QUERY (via Q_S0)
    FROM: (subquery) y
    ORDER BY: channel, i_brand_id, i_class_id, i_category_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: cross_items  (via CTE_Q_S0_cross_items)
    FROM: item i
    WHERE [8094f2c0095034d2]: EXISTS(SELECT 1 FROM store_sales, item AS iss, date_dim AS d1 WHERE ss_item_sk = iss.i_item_sk AN...
  CTE: avg_sales  (via CTE_Q_S0_avg_sales)
    FROM: (subquery) x
  MAIN QUERY (via Q_S0)
    FROM: (subquery) y
    ORDER BY: channel, i_brand_id, i_class_id, i_category_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```



### Family E: Materialization / Prefetch (Don't Repeat Work)
**Description**: Extract repeated scans or pre-compute intermediate results for reuse across multiple consumers
**Speedup Range**: 1.3–6.2x (~18% of all wins)
**Use When**:
  1. Repeated scans of same table with different filters
  2. Dimension filters applied independently multiple times
  3. CTE referenced multiple times with implicit re-evaluation

**Gold Example**: `multi_dimension_prefetch` (2.71x)

**BEFORE (slow):**
```sql
select s_store_name, s_store_id,
        sum(case when (d_day_name='Sunday') then ss_sales_price else null end) sun_sales,
        sum(case when (d_day_name='Monday') then ss_sales_price else null end) mon_sales,
        sum(case when (d_day_name='Tuesday') then ss_sales_price else  null end) tue_sales,
        sum(case when (d_day_name='Wednesday') then ss_sales_price else null end) wed_sales,
        sum(case when (d_day_name='Thursday') then ss_sales_price else null end) thu_sales,
        sum(case when (d_day_name='Friday') then ss_sales_price else null end) fri_sales,
        sum(case when (d_day_name='Saturday') then ss_sales_price else null end) sat_sales
 from date_dim, store_sales, store
 where d_date_sk = ss_sold_date_sk and
...
```

**AFTER (fast):**
```sql
WITH filtered_dates AS (SELECT d_date_sk, d_day_name FROM date_dim WHERE d_year = 2000), filtered_stores AS (SELECT s_store_sk, s_store_id, s_store_name FROM store WHERE s_gmt_offset = -5), filtered_sales AS (SELECT ss_sales_price, d_day_name, s_store_id, s_store_name FROM store_sales JOIN filtered_dates ON d_date_sk = ss_sold_date_sk JOIN filtered_stores ON s_store_sk = ss_store_sk)
SELECT s_store_name, s_store_id, SUM(CASE WHEN (d_day_name = 'Sunday') THEN ss_sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN (d_day_name = 'Monday') THEN ss_sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN (d_day_name = 'Tuesday') THEN ss_sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN (d_day_name = 'Wednesday') THEN ss_sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN (d_day_name = 'Thursday') THEN ss_sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN (d_day_name = 'Friday') THEN ss_sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN (d_day_name = 'Saturday') THEN ss_sales_price ELSE NULL END) AS sat_sales FROM filtered_sales GROUP BY s_store_name, s_store_id ORDER BY s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales LIMIT 100;
```

**IR BEFORE:**
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: date_dim, store_sales, store
    WHERE [834e9c75d01a8fa3]: d_date_sk = ss_sold_date_sk AND s_store_sk = ss_store_sk AND s_gmt_offset = -5 AND d_year = 2000
    GROUP BY: s_store_name, s_store_id
    ORDER BY: s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: filtered_dates  (via CTE_Q_S0_filtered_dates)
    FROM: date_dim
    WHERE [48b31a2bf2993b3d]: d_year = 2000
  CTE: filtered_stores  (via CTE_Q_S0_filtered_stores)
    FROM: store
    WHERE [812f7299c6fba51b]: s_gmt_offset = -5
  CTE: filtered_sales  (via CTE_Q_S0_filtered_sales)
    FROM: store_sales, filtered_dates, filtered_stores
  MAIN QUERY (via Q_S0)
    FROM: filtered_sales
    GROUP BY: s_store_name, s_store_id
    ORDER BY: s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```



### Family F: Join Transform (Right Shape First)
**Description**: Restructure join topology: convert comma joins to explicit INNER JOIN, optimize join order, eliminate self-joins via single-pass aggregation
**Speedup Range**: 1.8–8.6x (~19% of all wins)
**Use When**:
  1. Comma-separated joins (implicit cross joins) in FROM clause
  2. Self-joins scanning same table multiple times
  3. Dimension-fact join order suboptimal for predicate pushdown

**Gold Example**: `inner_join_conversion` (3.44x)

**BEFORE (slow):**
```sql
select ss_customer_sk
            ,sum(act_sales) sumsales
      from (select ss_item_sk
                  ,ss_ticket_number
                  ,ss_customer_sk
                  ,case when sr_return_quantity is not null then (ss_quantity-sr_return_quantity)*ss_sales_price
                                                            else (ss_quantity*ss_sales_price) end act_sales
            from store_sales left outer join store_returns on (sr_item_sk = ss_item_sk
                                                               and sr_ticket_number = ss_ticket_number)
                ,reason
...
```

**AFTER (fast):**
```sql
WITH filtered_reason AS (SELECT r_reason_sk, r_reason_desc FROM reason WHERE r_reason_desc = 'duplicate purchase'), joined_returns_sales AS (SELECT ss.ss_customer_sk, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales ss INNER JOIN store_returns sr ON (ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number) INNER JOIN filtered_reason fr ON sr.sr_reason_sk = fr.r_reason_sk), aggregated AS (SELECT ss_customer_sk, SUM((ss_quantity - sr_return_quantity) * ss_sales_price) AS sumsales FROM joined_returns_sales GROUP BY ss_customer_sk), top_n AS (SELECT ss_customer_sk, sumsales FROM aggregated ORDER BY sumsales ASC, ss_customer_sk ASC LIMIT 100) SELECT ss_customer_sk, sumsales FROM top_n
```

**IR BEFORE:**
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: (subquery) t
    GROUP BY: ss_customer_sk
    ORDER BY: sumsales, ss_customer_sk

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: filtered_reason  (via CTE_Q_S0_filtered_reason)
    FROM: reason
    WHERE [a7afe1b89848b69b]: r_reason_desc = 'duplicate purchase'
  CTE: joined_returns_sales  (via CTE_Q_S0_joined_returns_sales)
    FROM: store_sales ss, store_returns sr, filtered_reason fr
  CTE: aggregated  (via CTE_Q_S0_aggregated)
    FROM: joined_returns_sales
    GROUP BY: ss_customer_sk
  CTE: top_n  (via CTE_Q_S0_top_n)
    FROM: aggregated
    ORDER BY: sumsales, ss_customer_sk
  MAIN QUERY (via Q_S0)
    FROM: top_n

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```



## Previous Round Results


| Patch | Family | Transform | Semantic | Speedup | Status | Orig ms | Patch ms | Error |

|-------|--------|-----------|----------|---------|--------|---------|----------|-------|

| t1 | C | aggregation_pushdown | FAIL | — | FAIL | — | — | Semantic (after retries): Column mismatch: 1 missing, 4 extr |

| t2 | A | dimension_prefilter | PASS | 0.99x | NEUTRAL | 15 | 15 |  |



## Execution Plans


**Original EXPLAIN:**

```
┌───────────────────────────┐
│           TOP_N           │
│    ────────────────────   │
│          Top: 100         │
│                           │
│         Order By:         │
│   x.w_warehouse_name ASC  │
│      x.i_item_id ASC      │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│           FILTER          │
│    ────────────────────   │
│ (CASE  WHEN ((inv_before >│
│  0)) THEN ((CAST(inv_after│
│      AS DOUBLE) / CAST    │
│  (inv_before AS DOUBLE))) │
│   ELSE NULL END BETWEEN 0 │
│ .6666666666666666 AND 1.5)│
│                           │
│        ~2,184 rows        │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│       HASH_GROUP_BY       │
│    ────────────────────   │
│          Groups:          │
│             #0            │
│             #1            │
│                           │
│        Aggregates:        │
│          sum(#2)          │
│          sum(#3)          │
│                           │
│        ~2,184 rows        │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│         PROJECTION        │
│    ────────────────────   │
│      w_warehouse_name     │
│         i_item_id         │
│   CASE  WHEN ((d_date <   │
│ '2002-02-27'::DATE)) THEN │
│   (inv_quantity_on_hand)  │
│         ELSE 0 END        │
│  CASE  WHEN ((d_date >=   │
│ '2002-02-27'::DATE)) THEN │
│   (inv_quantity_on_hand)  │
│         ELSE 0 END        │
│                           │
│      ~5,141,212 rows      │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│         HASH_JOIN         │
│    ────────────────────   │
│      Join Type: INNER     │
│                           │
│        Conditions:        ├────────────────────────────────────────────────────────────────────────┐
│     inv_warehouse_sk =    │                                                                        │
│       w_warehouse_sk      │                                                                        │
│                           │                                                                        │
│      ~5,141,212 rows      │                                                                        │
```


**t2 (Family A, 0.99x NEUTRAL) EXPLAIN:**

```
┌───────────────────────────┐
│           TOP_N           │
│    ────────────────────   │
│          Top: 100         │
│                           │
│         Order By:         │
│   x.w_warehouse_name ASC  │
│      x.i_item_id ASC      │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│           FILTER          │
│    ────────────────────   │
│ (CASE  WHEN ((inv_before >│
│  0)) THEN ((CAST(inv_after│
│      AS DOUBLE) / CAST    │
│  (inv_before AS DOUBLE))) │
│   ELSE NULL END BETWEEN 0 │
│ .6666666666666666 AND 1.5)│
│                           │
│         ~114 rows         │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│       HASH_GROUP_BY       │
│    ────────────────────   │
│          Groups:          │
│             #0            │
│             #1            │
│                           │
│        Aggregates:        │
│          sum(#2)          │
│          sum(#3)          │
│                           │
│         ~114 rows         │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│         PROJECTION        │
│    ────────────────────   │
│      w_warehouse_name     │
│         i_item_id         │
│   CASE  WHEN ((d_date <   │
│ '2002-02-27'::DATE)) THEN │
│   (inv_quantity_on_hand)  │
│         ELSE 0 END        │
│  CASE  WHEN ((d_date >=   │
│ '2002-02-27'::DATE)) THEN │
│   (inv_quantity_on_hand)  │
│         ELSE 0 END        │
│                           │
│      ~5,141,212 rows      │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│         HASH_JOIN         │
│    ────────────────────   │
│      Join Type: INNER     │
│                           │
│        Conditions:        ├────────────────────────────────────────────────────────────────────────┐
│     inv_warehouse_sk =    │                                                                        │
│       w_warehouse_sk      │                                                                        │
│                           │                                                                        │
│      ~5,141,212 rows      │                                                                        │
```


## Patched SQL


**t1 (Family C, aggregation_pushdown):**

```sql
WITH date_filtered AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN (CAST('2002-02-27' AS DATE) - INTERVAL '30' DAY) AND (CAST('2002-02-27' AS DATE) + INTERVAL '30' DAY)), item_filtered AS (SELECT i_item_sk, i_item_id FROM item WHERE i_current_price BETWEEN 0.99 AND 1.49), inventory_agg AS (SELECT inv_warehouse_sk, inv_item_sk, SUM(CASE WHEN (d_date < CAST('2002-02-27' AS DATE)) THEN inv_quantity_on_hand ELSE 0 END) AS inv_before, SUM(CASE WHEN (d_date >= CAST('2002-02-27' AS DATE)) THEN inv_quantity_on_hand ELSE 0 END) AS inv_after FROM inventory JOIN date_filtered ON inv_date_sk = d_date_sk GROUP BY inv_warehouse_sk, inv_item_sk) SELECT w_warehouse_name, i_item_id, inv_before, inv_after FROM inventory_agg JOIN item_filtered ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk WHERE (CASE WHEN inv_before > 0 THEN inv_after / inv_before ELSE NULL END) BETWEEN 2.0 / 3.0 AND 3.0 / 2.0 ORDER BY w_warehouse_name, i_item_id LIMIT 100;

/* end query 21 in stream 0 using template query21.tpl */;
```


**t2 (Family A, dimension_prefilter) — 0.99x NEUTRAL:**

```sql
WITH date_filtered AS (SELECT * FROM date_dim WHERE d_date BETWEEN (CAST('2002-02-27' AS DATE) - INTERVAL '30' DAY) AND (CAST('2002-02-27' AS DATE) + INTERVAL '30' DAY)), item_filtered AS (SELECT * FROM item WHERE i_current_price BETWEEN 0.99 AND 1.49) /* start query 21 in stream 0 using template query21.tpl */ SELECT * FROM (SELECT w_warehouse_name, i_item_id, SUM(CASE WHEN (CAST(d_date AS DATE) < CAST('2002-02-27' AS DATE)) THEN inv_quantity_on_hand ELSE 0 END) AS inv_before, SUM(CASE WHEN (CAST(d_date AS DATE) >= CAST('2002-02-27' AS DATE)) THEN inv_quantity_on_hand ELSE 0 END) AS inv_after FROM inventory, warehouse, item_filtered, date_filtered WHERE i_item_sk = inv_item_sk AND inv_warehouse_sk = w_warehouse_sk AND inv_date_sk = d_date_sk GROUP BY w_warehouse_name, i_item_id) AS x WHERE (CASE WHEN inv_before > 0 THEN inv_after / inv_before ELSE NULL END) BETWEEN 2.0 / 3.0 AND 3.0 / 2.0 ORDER BY w_warehouse_name, i_item_id LIMIT 100;

/* end query 21 in stream 0 using template query21.tpl */;
```


## Your Task — Refined Targets

Analyze the results above:
- **WINs**: Can you push further? Combine with another family? Layer a second transform on top?
- **NEUTRALs**: What went wrong? Look at EXPLAIN. Fix the approach or try a compound strategy.
- **FAILs/ERRORs**: What caused the failure? Propose a different strategy.
- **REGRESSIONs**: Why slower? Avoid that pattern.

Design 1 to 4 refined optimization targets. Same JSON output format:

```json
[
  {
    "family": "A+B",
    "transform": "early_filter_then_decorrelate",
    "target_id": "t1",
    "relevance_score": 0.95,
    "hypothesis": "Decorrelation worked (7.8x) but scan is still wide. Push date filter into CTE first, then decorrelate on the filtered set.",
    "target_ir": "...",
    "recommended_examples": ["date_cte_isolate", "shared_scan_decorrelate"]
  }
]
```

**Combined families**: You MAY combine families in a single target (e.g. "A+B", "B+E", "A+F").
Use this when one transform sets up conditions for another — e.g. early filtering (A) reduces
the scan before decorrelation (B), or decorrelation (B) creates a CTE that enables
materialization reuse (E). The worker will receive gold examples from ALL referenced families.

Output up to 4 targets. Fewer strong targets beat padding with weak ones.
