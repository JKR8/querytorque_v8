Looking at the query pattern, I notice that the main query is computing ratios between sales from year 1998 and 1999 for each week. The current approach filters the same CTE twice with different year filters. The key insight is that we can **compute both years' data in a single CTE scan** instead of scanning the fact table twice through two separate CTE evaluations.

Here's the optimized approach:

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "semantic_rewrite",
      "nodes": {
        "wswscs_both_years": "SELECT d.d_week_seq, d.d_year, SUM(CASE WHEN (d.d_day_name = 'Sunday') THEN w.sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN (d.d_day_name = 'Monday') THEN w.sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN (d.d_day_name = 'Tuesday') THEN w.sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN (d.d_day_name = 'Wednesday') THEN w.sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN (d.d_day_name = 'Thursday') THEN w.sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN (d.d_day_name = 'Friday') THEN w.sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN (d.d_day_name = 'Saturday') THEN w.sales_price ELSE NULL END) AS sat_sales FROM wscs w JOIN date_dim d ON d.d_date_sk = w.sold_date_sk WHERE d.d_year IN (1998, 1999) GROUP BY d.d_week_seq, d.d_year",
        "main_query": "SELECT y.d_week_seq AS d_week_seq1, ROUND(y.sun_sales / NULLIF(z.sun_sales, 0), 2), ROUND(y.mon_sales / NULLIF(z.mon_sales, 0), 2), ROUND(y.tue_sales / NULLIF(z.tue_sales, 0), 2), ROUND(y.wed_sales / NULLIF(z.wed_sales, 0), 2), ROUND(y.thu_sales / NULLIF(z.thu_sales, 0), 2), ROUND(y.fri_sales / NULLIF(z.fri_sales, 0), 2), ROUND(y.sat_sales / NULLIF(z.sat_sales, 0), 2) FROM (SELECT * FROM wswscs_both_years WHERE d_year = 1998) y JOIN (SELECT * FROM wswscs_both_years WHERE d_year = 1999) z ON y.d_week_seq = z.d_week_seq - 53 ORDER BY y.d_week_seq",
        "wscs": "SELECT sold_date_sk, sales_price FROM (SELECT ws_sold_date_sk AS sold_date_sk, ws_ext_sales_price AS sales_price FROM web_sales UNION ALL SELECT cs_sold_date_sk AS sold_date_sk, cs_ext_sales_price AS sales_price FROM catalog_sales)"
      },
      "invariants_kept": [
        "same result rows",
        "same aggregation results",
        "same output columns",
        "same join conditions"
      ],
      "expected_speedup": "1.8x",
      "risk": "low"
    }
  ],
  "explanation": "Combined the two year-specific aggregations into a single CTE that computes both years at once, reducing the need to scan the fact table twice through separate CTE evaluations. The new CTE groups by both d_week_seq and d_year, filtering for only the needed years (1998 and 1999). This eliminates redundant scanning and aggregation of the same base data."
}
```

**Key insight**: The original query effectively scans the same fact table (through wscs) twice - once for year 1998 and once for 1999. By combining both year filters into a single CTE that groups by both `d_week_seq` and `d_year`, we process the data once and then split it for the ratio calculation. This reduces I/O and aggregation overhead significantly.

This approach is different from the previous failed attempts because:
1. It keeps the original `d_week_seq` semantics (no week offset adjustments)
2. It filters for exactly the two years needed (1998 and 1999)
3. It maintains the correct grouping granularity (week + year)