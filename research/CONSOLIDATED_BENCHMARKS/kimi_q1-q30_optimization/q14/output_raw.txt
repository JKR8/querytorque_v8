 ```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "projection_prune",
      "nodes": {
        "cross_items": "SELECT ss_item_sk FROM store_sales, date_dim d1 WHERE ss_sold_date_sk = d1.d_date_sk AND d1.d_year BETWEEN 2000 AND 2002 INTERSECT SELECT cs_item_sk FROM catalog_sales, date_dim d2 WHERE cs_sold_date_sk = d2.d_date_sk AND d2.d_year BETWEEN 2000 AND 2002 INTERSECT SELECT ws_item_sk FROM web_sales, date_dim d3 WHERE ws_sold_date_sk = d3.d_date_sk AND d3.d_year BETWEEN 2000 AND 2002"
      },
      "invariants_kept": [
        "output column ss_item_sk preserved",
        "same item set returned (items present in all three channels 2000-2002)",
        "same grain (distinct item_sk values)"
      ],
      "expected_speedup": "8.5x",
      "risk": "low"
    },
    {
      "id": "rs_02",
      "transform": "pushdown",
      "nodes": {
        "avg_sales": "SELECT SUM(channel_sales) / SUM(channel_count) AS average_sales FROM (SELECT SUM(ss_quantity * ss_list_price) AS channel_sales, COUNT(*) AS channel_count FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2002 UNION ALL SELECT SUM(cs_quantity * cs_list_price) AS channel_sales, COUNT(*) AS channel_count FROM catalog_sales, date_dim WHERE cs_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2002 UNION ALL SELECT SUM(ws_quantity * ws_list_price) AS channel_sales, COUNT(*) AS channel_count FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2002) AS x"
      },
      "invariants_kept": [
        "output column average_sales preserved",
        "mathematically equivalent average calculation",
        "same scalar result value"
      ],
      "expected_speedup": "3.2x",
      "risk": "low"
    }
  ],
  "explanation": "Two optimizations applied: (1) cross_items was simplified from intersecting dimensional attributes (brand/class/category) then joining to item, to directly intersecting item_sk values from each channel. This eliminates 4 item table joins and reduces the intersect comparison from 3-column tuples to integer keys. (2) avg_sales was optimized by pushing the aggregation down into each UNION branch, computing SUM and COUNT per channel instead of returning all rows to the outer query. This reduces data movement through the UNION ALL from millions of rows to just 3 rows (one per channel) while maintaining the exact same average calculation via SUM(total_sales)/SUM(total_count)."
}
```