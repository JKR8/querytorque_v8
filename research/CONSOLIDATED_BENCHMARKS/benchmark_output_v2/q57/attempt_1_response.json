```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 OR (d_year = 1998 AND d_moy = 12) OR (d_year = 2000 AND d_moy = 1)",
        "filtered_catalog_sales": "SELECT cs_item_sk, cs_call_center_sk, cs_sales_price, d_year, d_moy FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk",
        "v1": "SELECT i_category, i_brand, cc_name, d_year, d_moy, SUM(cs_sales_price) AS sum_sales, AVG(SUM(cs_sales_price)) OVER (PARTITION BY i_category, i_brand, cc_name, d_year) AS avg_monthly_sales, RANK() OVER (PARTITION BY i_category, i_brand, cc_name ORDER BY d_year, d_moy) AS rn FROM item, filtered_catalog_sales, call_center WHERE cs_item_sk = i_item_sk AND cc_call_center_sk = cs_call_center_sk GROUP BY i_category, i_brand, cc_name, d_year, d_moy",
        "v2": "SELECT v1.i_brand, v1.d_year, v1.avg_monthly_sales, v1.sum_sales, v1_lag.sum_sales AS psum, v1_lead.sum_sales AS nsum FROM v1, v1 AS v1_lag, v1 AS v1_lead WHERE v1.i_category = v1_lag.i_category AND v1.i_category = v1_lead.i_category AND v1.i_brand = v1_lag.i_brand AND v1.i_brand = v1_lead.i_brand AND v1.cc_name = v1_lag.cc_name AND v1.cc_name = v1_lead.cc_name AND v1.rn = v1_lag.rn + 1 AND v1.rn = v1_lead.rn - 1",
        "main_query": "SELECT * FROM v2 WHERE d_year = 1999 AND avg_monthly_sales > 0 AND CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 ORDER BY sum_sales - avg_monthly_sales, nsum LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same grouping and aggregation"
      ],
      "expected_speedup": "2.5x",
      "risk": "low"
    },
    {
      "id": "rs_02",
      "transform": "or_to_union",
      "nodes": {
        "filtered_dates_1999": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999",
        "filtered_dates_1998_12": "SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 12",
        "filtered_dates_2000_1": "SELECT d_date_sk FROM date_dim WHERE d_year = 2000 AND d_moy = 1",
        "catalog_sales_1999": "SELECT cs_item_sk, cs_call_center_sk, cs_sales_price, d_year, d_moy FROM catalog_sales JOIN filtered_dates_1999 ON cs_sold_date_sk = d_date_sk",
        "catalog_sales_1998_12": "SELECT cs_item_sk, cs_call_center_sk, cs_sales_price, 1999 AS d_year, 12 AS d_moy FROM catalog_sales JOIN filtered_dates_1998_12 ON cs_sold_date_sk = d_date_sk",
        "catalog_sales_2000_1": "SELECT cs_item_sk, cs_call_center_sk, cs_sales_price, 1999 AS d_year, 1 AS d_moy FROM catalog_sales JOIN filtered_dates_2000_1 ON cs_sold_date_sk = d_date_sk",
        "all_catalog_sales": "SELECT * FROM catalog_sales_1999 UNION ALL SELECT * FROM catalog_sales_1998_12 UNION ALL SELECT * FROM catalog_sales_2000_1",
        "v1": "SELECT i_category, i_brand, cc_name, d_year, d_moy, SUM(cs_sales_price) AS sum_sales, AVG(SUM(cs_sales_price)) OVER (PARTITION BY i_category, i_brand, cc_name, d_year) AS avg_monthly_sales, RANK() OVER (PARTITION BY i_category, i_brand, cc_name ORDER BY d_year, d_moy) AS rn FROM item, all_catalog_sales, call_center WHERE cs_item_sk = i_item_sk AND cc_call_center_sk = cs_call_center_sk GROUP BY i_category, i_brand, cc_name, d_year, d_moy",
        "v2": "SELECT v1.i_brand, v1.d_year, v1.avg_monthly_sales, v1.sum_sales, v1_lag.sum_sales AS psum, v1_lead.sum_sales AS nsum FROM v1, v1 AS v1_lag, v1 AS v1_lead WHERE v1.i_category = v1_lag.i_category AND v1.i_category = v1_lead.i_category AND v1.i_brand = v1_lag.i_brand AND v1.i_brand = v1_lead.i_brand AND v1.cc_name = v1_lag.cc_name AND v1.cc_name = v1_lead.cc_name AND v1.rn = v1_lag.rn + 1 AND v1.rn = v1_lead.rn - 1",
        "main_query": "SELECT * FROM v2 WHERE d_year = 1999 AND avg_monthly_sales > 0 AND CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 ORDER BY sum_sales - avg_monthly_sales, nsum LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same grouping and aggregation"
      ],
      "expected_speedup": "2.8x",
      "risk": "medium"
    }
  ],
  "explanation": "Two complementary rewrites: (1) DATE_CTE_ISOLATE extracts date_dim filter into a CTE to reduce catalog_sales scan early. The OR condition remains but date_dim is filtered first. (2) OR_TO_UNION splits the three date conditions into separate branches, each with precise filters, allowing better index usage and eliminating OR evaluation. Both rewrites reduce the 17M-row catalog_sales scan by pushing date filters earlier."
}
```