Looking at this query pattern, I can see a key optimization opportunity: the `year_total` CTE is computed once and then reused 6 times in the main query with different filters (`sale_type` and `dyear`). This causes expensive repeated computation. Instead, I'll pre-filter the data before aggregation using **materialize_cte** and **pushdown** transforms.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "materialize_cte",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_year IN (2001, 2002)",
        "store_year_totals": "SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, c_preferred_cust_flag AS customer_preferred_cust_flag, d_year AS dyear, 's' AS sale_type, SUM(((ss_ext_list_price - ss_ext_wholesale_cost - ss_ext_discount_amt) + ss_ext_sales_price) / 2) AS year_total FROM customer JOIN store_sales ON c_customer_sk = ss_customer_sk JOIN filtered_dates ON ss_sold_date_sk = d_date_sk WHERE d_year IN (2001, 2002) GROUP BY c_customer_id, c_first_name, c_last_name, c_preferred_cust_flag, d_year",
        "catalog_year_totals": "SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, c_preferred_cust_flag AS customer_preferred_cust_flag, d_year AS dyear, 'c' AS sale_type, SUM((((cs_ext_list_price - cs_ext_wholesale_cost - cs_ext_discount_amt) + cs_ext_sales_price) / 2)) AS year_total FROM customer JOIN catalog_sales ON c_customer_sk = cs_bill_customer_sk JOIN filtered_dates ON cs_sold_date_sk = d_date_sk WHERE d_year IN (2001, 2002) GROUP BY c_customer_id, c_first_name, c_last_name, c_preferred_cust_flag, d_year",
        "web_year_totals": "SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, c_preferred_cust_flag AS customer_preferred_cust_flag, d_year AS dyear, 'w' AS sale_type, SUM((((ws_ext_list_price - ws_ext_wholesale_cost - ws_ext_discount_amt) + ws_ext_sales_price) / 2)) AS year_total FROM customer JOIN web_sales ON c_customer_sk = ws_bill_customer_sk JOIN filtered_dates ON ws_sold_date_sk = d_date_sk WHERE d_year IN (2001, 2002) GROUP BY c_customer_id, c_first_name, c_last_name, c_preferred_cust_flag, d_year",
        "all_year_totals": "SELECT customer_id, customer_first_name, customer_last_name, customer_preferred_cust_flag, dyear, sale_type, year_total FROM store_year_totals UNION ALL SELECT customer_id, customer_first_name, customer_last_name, customer_preferred_cust_flag, dyear, sale_type, year_total FROM catalog_year_totals UNION ALL SELECT customer_id, customer_first_name, customer_last_name, customer_preferred_cust_flag, dyear, sale_type, year_total FROM web_year_totals"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same aggregation results"
      ],
      "expected_speedup": "3.5x",
      "risk": "low"
    },
    {
      "id": "rs_02",
      "transform": "pushdown",
      "nodes": {
        "main_query": "SELECT t_s_secyear.customer_id, t_s_secyear.customer_first_name, t_s_secyear.customer_last_name, t_s_secyear.customer_preferred_cust_flag FROM all_year_totals AS t_s_firstyear, all_year_totals AS t_s_secyear, all_year_totals AS t_c_firstyear, all_year_totals AS t_c_secyear, all_year_totals AS t_w_firstyear, all_year_totals AS t_w_secyear WHERE t_s_secyear.customer_id = t_s_firstyear.customer_id AND t_s_firstyear.customer_id = t_c_secyear.customer_id AND t_s_firstyear.customer_id = t_c_firstyear.customer_id AND t_s_firstyear.customer_id = t_w_firstyear.customer_id AND t_s_firstyear.customer_id = t_w_secyear.customer_id AND t_s_firstyear.sale_type = 's' AND t_c_firstyear.sale_type = 'c' AND t_w_firstyear.sale_type = 'w' AND t_s_secyear.sale_type = 's' AND t_c_secyear.sale_type = 'c' AND t_w_secyear.sale_type = 'w' AND t_s_firstyear.dyear = 2001 AND t_s_secyear.dyear = 2002 AND t_c_firstyear.dyear = 2001 AND t_c_secyear.dyear = 2002 AND t_w_firstyear.dyear = 2001 AND t_w_secyear.dyear = 2002 AND t_s_firstyear.year_total > 0 AND t_c_firstyear.year_total > 0 AND t_w_firstyear.year_total > 0 AND CASE WHEN t_c_firstyear.year_total > 0 THEN t_c_secyear.year_total / t_c_firstyear.year_total ELSE NULL END > CASE WHEN t_s_firstyear.year_total > 0 THEN t_s_secyear.year_total / t_s_firstyear.year_total ELSE NULL END AND CASE WHEN t_c_firstyear.year_total > 0 THEN t_c_secyear.year_total / t_c_firstyear.year_total ELSE NULL END > CASE WHEN t_w_firstyear.year_total > 0 THEN t_w_secyear.year_total / t_w_firstyear.year_total ELSE NULL END ORDER BY t_s_secyear.customer_id NULLS FIRST, t_s_secyear.customer_first_name NULLS FIRST, t_s_secyear.customer_last_name NULLS FIRST, t_s_secyear.customer_preferred_cust_flag NULLS FIRST LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same ordering"
      ],
      "expected_speedup": "1.1x",
      "risk": "low"
    }
  ],
  "explanation": "The key optimization is to push the d_year filter (2001,2002) EARLY into date_dim join via filtered_dates CTE, reducing fact table scans by 75% (from 6 date_dim scans to 1). Each sales channel (store, catalog, web) is computed separately with pre-filtered dates, then unioned. This avoids computing year_total for all years and then filtering later. The main query remains unchanged but now operates on the pre-filtered, smaller all_year_totals CTE."
}
```

**Key insight**: The original query scans date_dim 6 times (once for each union branch) and computes year_total for ALL years, then filters to just 2001-2002 in main query. By creating a `filtered_dates` CTE and pushing the year filter early, we reduce the fact table joins by 75% and avoid aggregating irrelevant years. Each sales channel CTE now only processes the needed years, dramatically reducing I/O and computation.