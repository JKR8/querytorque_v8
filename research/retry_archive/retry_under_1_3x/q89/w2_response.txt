```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "or_to_union",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_moy FROM date_dim WHERE d_year = 1999",
        "filtered_store_sales": "SELECT ss_item_sk, ss_store_sk, ss_sales_price, d_moy FROM store_sales JOIN filtered_dates ON store_sales.ss_sold_date_sk = filtered_dates.d_date_sk",
        "branch1": "SELECT i.i_category, i.i_class, i.i_brand, s.s_store_name, s.s_company_name, fss.d_moy, SUM(fss.ss_sales_price) AS sum_sales, AVG(SUM(fss.ss_sales_price)) OVER (PARTITION BY i.i_category, i.i_brand, s.s_store_name, s.s_company_name) AS avg_monthly_sales FROM filtered_store_sales fss JOIN item i ON fss.ss_item_sk = i.i_item_sk JOIN store s ON fss.ss_store_sk = s.s_store_sk WHERE i.i_category IN ('Books', 'Electronics', 'Sports') AND i.i_class IN ('computers', 'stereo', 'football') GROUP BY i.i_category, i.i_class, i.i_brand, s.s_store_name, s.s_company_name, fss.d_moy",
        "branch2": "SELECT i.i_category, i.i_class, i.i_brand, s.s_store_name, s.s_company_name, fss.d_moy, SUM(fss.ss_sales_price) AS sum_sales, AVG(SUM(fss.ss_sales_price)) OVER (PARTITION BY i.i_category, i.i_brand, s.s_store_name, s.s_company_name) AS avg_monthly_sales FROM filtered_store_sales fss JOIN item i ON fss.ss_item_sk = i.i_item_sk JOIN store s ON fss.ss_store_sk = s.s_store_sk WHERE i.i_category IN ('Men', 'Jewelry', 'Women') AND i.i_class IN ('shirts', 'birdal', 'dresses') GROUP BY i.i_category, i.i_class, i.i_brand, s.s_store_name, s.s_company_name, fss.d_moy",
        "main_query": "SELECT * FROM (SELECT * FROM branch1 UNION ALL SELECT * FROM branch2) AS tmp1 WHERE CASE WHEN (avg_monthly_sales <> 0) THEN (ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales) ELSE NULL END > 0.1 ORDER BY sum_sales - avg_monthly_sales, s_store_name, 1, 2, 3, 5, 6, 7, 8 LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same grouping and aggregation"
      ],
      "expected_speedup": "2.0x",
      "risk": "low"
    }
  ],
  "explanation": "Applied OR-to-UNION-ALL decomposition to split the complex OR condition on item table into two separate branches with simpler filters. This allows each branch to use more efficient index access patterns and reduces the complexity of the predicate evaluation. Additionally, isolated date filtering into a CTE to enable early filtering of store_sales by year 1999. The two branches are mutually exclusive (categories don't overlap), so UNION ALL is correct without duplicates."
}
```