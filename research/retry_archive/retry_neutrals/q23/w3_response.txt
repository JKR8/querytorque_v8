Looking at this query structure, I can see multiple optimization opportunities. The most impactful will be pushing filters into CTEs before aggregation and creating date dimension CTEs for repeated use.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "date_years": "SELECT d_date_sk, d_date, d_year FROM date_dim WHERE d_year IN (2000, 2001, 2002, 2003)",
        "date_feb2000": "SELECT d_date_sk FROM date_dim WHERE d_year = 2000 AND d_moy = 2",
        "frequent_ss_items": "SELECT itemdesc, i_item_sk AS item_sk, d_date AS solddate, COUNT(*) AS cnt FROM store_sales JOIN date_years ON ss_sold_date_sk = d_date_sk JOIN (SELECT SUBSTRING(i_item_desc, 1, 30) AS itemdesc, * FROM item) AS sq1 ON ss_item_sk = i_item_sk GROUP BY itemdesc, i_item_sk, d_date HAVING COUNT(*) > 4",
        "max_store_sales": "SELECT MAX(csales) AS tpcds_cmax FROM (SELECT c_customer_sk, SUM(ss_quantity * ss_sales_price) AS csales FROM store_sales JOIN date_years ON ss_sold_date_sk = d_date_sk JOIN customer ON ss_customer_sk = c_customer_sk GROUP BY c_customer_sk) AS sq2"
      },
      "invariants_kept": [
        "same result rows",
        "same column output",
        "same grain for all CTEs"
      ],
      "expected_speedup": "3.5x",
      "risk": "low"
    },
    {
      "id": "rs_02",
      "transform": "materialize_cte",
      "nodes": {
        "best_ss_customer": "SELECT c_customer_sk, SUM(ss_quantity * ss_sales_price) AS ssales FROM store_sales JOIN customer ON ss_customer_sk = c_customer_sk CROSS JOIN max_store_sales GROUP BY c_customer_sk HAVING SUM(ss_quantity * ss_sales_price) > (50 / 100.0) * MAX(tpcds_cmax)",
        "main_query": "SELECT c_last_name, c_first_name, sales FROM (SELECT c_last_name, c_first_name, SUM(cs_quantity * cs_list_price) AS sales FROM catalog_sales JOIN date_feb2000 ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = customer.c_customer_sk JOIN frequent_ss_items ON cs_item_sk = item_sk JOIN best_ss_customer ON cs_bill_customer_sk = best_ss_customer.c_customer_sk GROUP BY c_last_name, c_first_name UNION ALL SELECT c_last_name, c_first_name, SUM(ws_quantity * ws_list_price) AS sales FROM web_sales JOIN date_feb2000 ON ws_sold_date_sk = d_date_sk JOIN customer ON ws_bill_customer_sk = customer.c_customer_sk JOIN frequent_ss_items ON ws_item_sk = item_sk JOIN best_ss_customer ON ws_bill_customer_sk = best_ss_customer.c_customer_sk GROUP BY c_last_name, c_first_name) AS sq3 ORDER BY c_last_name NULLS FIRST, c_first_name NULLS FIRST, sales NULLS FIRST LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same aggregation"
      ],
      "expected_speedup": "1.5x",
      "risk": "low"
    },
    {
      "id": "rs_03",
      "transform": "pushdown",
      "nodes": {
        "filtered_frequent_items": "SELECT itemdesc, item_sk, solddate, cnt FROM frequent_ss_items WHERE cnt > 4",
        "main_query_optimized": "SELECT c_last_name, c_first_name, sales FROM (SELECT c_last_name, c_first_name, SUM(cs_quantity * cs_list_price) AS sales FROM catalog_sales JOIN date_feb2000 ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = customer.c_customer_sk JOIN filtered_frequent_items ON cs_item_sk = item_sk JOIN best_ss_customer ON cs_bill_customer_sk = best_ss_customer.c_customer_sk GROUP BY c_last_name, c_first_name UNION ALL SELECT c_last_name, c_first_name, SUM(ws_quantity * ws_list_price) AS sales FROM web_sales JOIN date_feb2000 ON ws_sold_date_sk = d_date_sk JOIN customer ON ws_bill_customer_sk = customer.c_customer_sk JOIN filtered_frequent_items ON ws_item_sk = item_sk JOIN best_ss_customer ON ws_bill_customer_sk = best_ss_customer.c_customer_sk GROUP BY c_last_name, c_first_name) AS sq3 ORDER BY c_last_name NULLS FIRST, c_first_name NULLS FIRST, sales NULLS FIRST LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering"
      ],
      "expected_speedup": "1.8x",
      "risk": "low"
    }
  ],
  "explanation": "Applied three key optimizations: 1) Created date dimension CTEs (date_years, date_feb2000) to filter date_dim once and reuse - this isolates the most selective predicates early. 2) Materialized best_ss_customer CTE to avoid recomputing the HAVING clause filter multiple times. 3) Pushed the HAVING filter (cnt > 4) from frequent_ss_items into a separate filtered CTE before joining in main query. These changes reduce redundant scans of large fact tables (store_sales scanned 3 times originally) and apply filters before expensive joins."
}
```