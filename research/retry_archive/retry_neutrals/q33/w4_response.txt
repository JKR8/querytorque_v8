Looking at the query pattern, I can see multiple CTEs with identical structure but different fact tables, all being unioned together. The biggest opportunity is to reduce redundant work by sharing common dimension filtering and materializing repeated subqueries.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 5",
        "filtered_addresses": "SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -5",
        "electronics_items": "SELECT i_manufact_id, i_item_sk FROM item WHERE i_category IN ('Electronics')",
        "ss_rewritten": "SELECT i_manufact_id, SUM(ss_ext_sales_price) AS total_sales FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_addresses ON ss_addr_sk = ca_address_sk JOIN electronics_items ON ss_item_sk = i_item_sk GROUP BY i_manufact_id",
        "ws_rewritten": "SELECT i_manufact_id, SUM(ws_ext_sales_price) AS total_sales FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_addresses ON ws_bill_addr_sk = ca_address_sk JOIN electronics_items ON ws_item_sk = i_item_sk GROUP BY i_manufact_id",
        "cs_rewritten": "SELECT i_manufact_id, SUM(cs_ext_sales_price) AS total_sales FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN filtered_addresses ON cs_bill_addr_sk = ca_address_sk JOIN electronics_items ON cs_item_sk = i_item_sk GROUP BY i_manufact_id"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same aggregation semantics"
      ],
      "expected_speedup": "2.5x",
      "risk": "low"
    },
    {
      "id": "rs_02",
      "transform": "materialize_cte",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 5",
        "filtered_addresses": "SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -5",
        "electronics_items": "SELECT i_manufact_id, i_item_sk FROM item WHERE i_category IN ('Electronics')",
        "combined_sales": "SELECT i_manufact_id, total_sales FROM ss_rewritten UNION ALL SELECT i_manufact_id, total_sales FROM ws_rewritten UNION ALL SELECT i_manufact_id, total_sales FROM cs_rewritten",
        "main_query": "SELECT i_manufact_id, SUM(total_sales) AS total_sales FROM combined_sales GROUP BY i_manufact_id ORDER BY total_sales LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output"
      ],
      "expected_speedup": "1.3x",
      "risk": "low"
    }
  ],
  "explanation": "Applied two optimizations: 1) Created reusable CTEs for filtered date_dim, customer_address, and electronics items to avoid repeated filtering and subquery execution across all three sales CTEs. This reduces 3 scans of date_dim and customer_address to 1 scan each, and 3 IN subqueries on item to a single materialized CTE. 2) Materialized the combined UNION ALL result to prevent re-execution of the dimension joins during the final aggregation. The expected speedup comes from reducing redundant work on dimension tables and eliminating repeated subquery evaluations."
}
```