{
  "source": "kimi_extended",
  "original_path": "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/packages/qt-sql/qt_sql/benchmarks/duckdb_tpcds/queries/query_6.sql",
  "optimized_path": "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/research/archive/benchmark_results/CONSOLIDATED_BENCHMARKS/kimi_q1-q30_optimization/q6/output_optimized.sql",
  "validation": {
    "query_num": 6,
    "status": "success",
    "original_sql": "-- start query 6 in stream 0 using template query6.tpl\nselect a.ca_state state, count(*) cnt\n from customer_address a\n     ,customer c\n     ,store_sales s\n     ,date_dim d\n     ,item i\n where       a.ca_address_sk = c.c_current_addr_sk\n \tand c.c_customer_sk = s.ss_customer_sk\n \tand s.ss_sold_date_sk = d.d_date_sk\n \tand s.ss_item_sk = i.i_item_sk\n \tand d.d_month_seq = \n \t     (select distinct (d_month_seq)\n \t      from date_dim\n               where d_year = 2002\n \t        and d_moy = 3 )\n \tand i.i_current_price > 1.2 * \n             (select avg(j.i_current_price) \n \t     from item j \n \t     where j.i_category = i.i_category)\n group by a.ca_state\n having count(*) >= 10\n order by cnt, a.ca_state\n LIMIT 100;\n\n-- end query 6 in stream 0 using template query6.tpl\n",
    "optimized_sql": "WITH target_month AS (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3), category_avg AS (SELECT i_category, AVG(i_current_price) * 1.2 AS price_threshold FROM item GROUP BY i_category)\nSELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address AS a JOIN customer AS c ON a.ca_address_sk = c.c_current_addr_sk JOIN store_sales AS s ON c.c_customer_sk = s.ss_customer_sk JOIN date_dim AS d ON s.ss_sold_date_sk = d.d_date_sk JOIN target_month AS tm ON d.d_month_seq = tm.d_month_seq JOIN item AS i ON s.ss_item_sk = i.i_item_sk JOIN category_avg AS ca ON i.i_category = ca.i_category WHERE i.i_current_price > ca.price_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100",
    "raw_response": " ```json\n{\n  \"rewrite_sets\": [\n    {\n      \"id\": \"rs_01\",\n      \"transform\": \"decorrelate\",\n      \"nodes\": {\n        \"target_month\": \"SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3\",\n        \"category_avg\": \"SELECT i_category, AVG(i_current_price) * 1.2 AS price_threshold FROM item GROUP BY i_category\",\n        \"main_query\": \"SELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address a JOIN customer c ON a.ca_address_sk = c.c_current_addr_sk JOIN store_sales s ON c.c_customer_sk = s.ss_customer_sk JOIN date_dim d ON s.ss_sold_date_sk = d.d_date_sk JOIN target_month tm ON d.d_month_seq = tm.d_month_seq JOIN item i ON s.ss_item_sk = i.i_item_sk JOIN category_avg ca ON i.i_category = ca.i_category WHERE i.i_current_price > ca.price_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100\"\n      },\n      \"invariants_kept\": [\n        \"same result rows\",\n        \"same ordering\",\n        \"same column output\",\n        \"preserved aggregation grain\"\n      ],\n      \"expected_speedup\": \"2.5x\",\n      \"risk\": \"low\"\n    }\n  ],\n  \"explanation\": \"Decorrelated the scalar subquery on date_dim by converting it to a CTE (target_month) and joining, eliminating the per-row subquery execution. Decorrelated the correlated subquery on item category by pre-computing average prices per category with threshold multiplier in CTE (category_avg), then joining on i_category and moving the inequality predicate to the WHERE clause. This transforms two subqueries into joins, enabling hash joins instead of nested loop correlated execution.\"\n}\n```",
    "error": null,
    "latency_ms": 66114.9495130012,
    "tokens_in": 1623,
    "tokens_out": 5262
  }
}