{
  "source": "kimi_extended",
  "original_path": "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/packages/qt-sql/qt_sql/benchmarks/duckdb_tpcds/queries/query_93.sql",
  "optimized_path": "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/research/archive/benchmark_results/CONSOLIDATED_BENCHMARKS/kimi_q31-q99_optimization/q93/output_optimized.sql",
  "validation": {
    "query_num": 93,
    "status": "success",
    "original_sql": "-- start query 93 in stream 0 using template query93.tpl\nselect ss_customer_sk\n            ,sum(act_sales) sumsales\n      from (select ss_item_sk\n                  ,ss_ticket_number\n                  ,ss_customer_sk\n                  ,case when sr_return_quantity is not null then (ss_quantity-sr_return_quantity)*ss_sales_price\n                                                            else (ss_quantity*ss_sales_price) end act_sales\n            from store_sales left outer join store_returns on (sr_item_sk = ss_item_sk\n                                                               and sr_ticket_number = ss_ticket_number)\n                ,reason\n            where sr_reason_sk = r_reason_sk\n              and r_reason_desc = 'duplicate purchase') t\n      group by ss_customer_sk\n      order by sumsales, ss_customer_sk\n LIMIT 100;\n\n-- end query 93 in stream 0 using template query93.tpl\n",
    "optimized_sql": "WITH filtered_reason AS (SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'), filtered_returns AS (SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk)\nSELECT ss_customer_sk, SUM(act_sales) AS sumsales FROM (SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales AS ss JOIN filtered_returns AS fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100",
    "raw_response": " ```json\n{\n  \"rewrite_sets\": [\n    {\n      \"id\": \"rs_01\",\n      \"transform\": \"early_filter\",\n      \"nodes\": {\n        \"filtered_reason\": \"SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'\",\n        \"filtered_returns\": \"SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk\",\n        \"main_query\": \"SELECT ss_customer_sk, SUM(act_sales) AS sumsales FROM (SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales ss JOIN filtered_returns fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100\"\n      },\n      \"invariants_kept\": [\n        \"output columns unchanged\",\n        \"grain preserved at ss_customer_sk\",\n        \"required predicates preserved via pushdown to filtered_reason and filtered_returns\",\n        \"LEFT JOIN semantics preserved via equivalent INNER JOIN with pre-filtered returns\"\n      ],\n      \"expected_speedup\": \"2.8x\",\n      \"risk\": \"low\"\n    }\n  ],\n  \"explanation\": \"Pushed down the filter r_reason_desc = 'duplicate purchase' to the reason dimension table and pre-joined with store_returns to eliminate non-matching returns before joining with store_sales. This reduces the intermediate result set significantly. Also converted the LEFT JOIN to INNER JOIN since the WHERE clause in the original query effectively filtered out all non-matching rows (sales without 'duplicate purchase' returns). Removed unused columns ss_item_sk and ss_ticket_number from the subquery projection as they are not referenced by the outer query.\"\n}\n```",
    "error": null,
    "latency_ms": 182396.2041939958,
    "tokens_in": 1505,
    "tokens_out": 7851
  }
}