{
  "source": "kimi_extended",
  "original_path": "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/packages/qt-sql/qt_sql/benchmarks/duckdb_tpcds/queries/query_73.sql",
  "optimized_path": "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/research/archive/benchmark_results/CONSOLIDATED_BENCHMARKS/kimi_q31-q99_optimization/q73/output_optimized.sql",
  "validation": {
    "query_num": 73,
    "status": "success",
    "original_sql": "-- start query 73 in stream 0 using template query73.tpl\nselect c_last_name\n       ,c_first_name\n       ,c_salutation\n       ,c_preferred_cust_flag \n       ,ss_ticket_number\n       ,cnt from\n   (select ss_ticket_number\n          ,ss_customer_sk\n          ,count(*) cnt\n    from store_sales,date_dim,store,household_demographics\n    where store_sales.ss_sold_date_sk = date_dim.d_date_sk\n    and store_sales.ss_store_sk = store.s_store_sk  \n    and store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk\n    and date_dim.d_dom between 1 and 2 \n    and (household_demographics.hd_buy_potential = '501-1000' or\n         household_demographics.hd_buy_potential = 'Unknown')\n    and household_demographics.hd_vehicle_count > 0\n    and case when household_demographics.hd_vehicle_count > 0 then \n             household_demographics.hd_dep_count/ household_demographics.hd_vehicle_count else null end > 1\n    and date_dim.d_year in (2000,2000+1,2000+2)\n    and store.s_county in ('Fairfield County','Walker County','Daviess County','Barrow County')\n    group by ss_ticket_number,ss_customer_sk) dj,customer\n    where ss_customer_sk = c_customer_sk\n      and cnt between 1 and 5\n    order by cnt desc, c_last_name asc;\n\n-- end query 73 in stream 0 using template query73.tpl\n",
    "optimized_sql": "-- start query 73 in stream 0 using template query73.tpl\nselect c_last_name\n       ,c_first_name\n       ,c_salutation\n       ,c_preferred_cust_flag \n       ,ss_ticket_number\n       ,cnt from\n   (select ss_ticket_number\n          ,ss_customer_sk\n          ,count(*) cnt\n    from store_sales,date_dim,store,household_demographics\n    where store_sales.ss_sold_date_sk = date_dim.d_date_sk\n    and store_sales.ss_store_sk = store.s_store_sk  \n    and store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk\n    and date_dim.d_dom between 1 and 2 \n    and (household_demographics.hd_buy_potential = '501-1000' or\n         household_demographics.hd_buy_potential = 'Unknown')\n    and household_demographics.hd_vehicle_count > 0\n    and case when household_demographics.hd_vehicle_count > 0 then \n             household_demographics.hd_dep_count/ household_demographics.hd_vehicle_count else null end > 1\n    and date_dim.d_year in (2000,2000+1,2000+2)\n    and store.s_county in ('Fairfield County','Walker County','Daviess County','Barrow County')\n    group by ss_ticket_number,ss_customer_sk) dj,customer\n    where ss_customer_sk = c_customer_sk\n      and cnt between 1 and 5\n    order by cnt desc, c_last_name asc;\n\n-- end query 73 in stream 0 using template query73.tpl\n",
    "raw_response": " The user wants me to optimize a SQL query using the allowed transforms. Let me analyze the input query.\n\nThe query is:\n```sql\nSELECT c_last_name, c_first_name, c_salutation, c_preferred_cust_flag, ss_ticket_number, cnt \nFROM (\n    SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt \n    FROM store_sales, date_dim, store, household_demographics \n    WHERE store_sales.ss_sold_date_sk = date_dim.d_date_sk \n      AND store_sales.ss_store_sk = store.s_store_sk \n      AND store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk \n      AND date_dim.d_dom BETWEEN 1 AND 2 \n      AND (household_demographics.hd_buy_potential = '501-1000' OR household_demographics.hd_buy_potential = 'Unknown') \n      AND household_demographics.hd_vehicle_count > 0 \n      AND CASE WHEN household_demographics.hd_vehicle_count > 0 THEN household_demographics.hd_dep_count / household_demographics.hd_vehicle_count ELSE NULL END > 1 \n      AND date_dim.d_year IN (2000, 2000 + 1, 2000 + 2) \n      AND store.s_county IN ('Fairfield County', 'Walker County', 'Daviess County', 'Barrow County') \n    GROUP BY ss_ticket_number, ss_customer_sk\n) AS dj, \ncustomer \nWHERE ss_customer_sk = c_customer_sk \n  AND cnt BETWEEN 1 AND 5 \nORDER BY cnt DESC, c_last_name ASC\n```\n\nThe detected opportunity mentions OR_TO_UNION on the OR condition: `(household_demographics.hd_buy_potential = '501-1000' OR household_demographics.hd_buy_potential = 'Unknown')`\n\nHowever, looking at the query structure, I should also consider:\n1. The OR condition in the WHERE clause of the subquery\n2. Early filtering opportunities (pushing down filters)\n3. The IN clause on date_dim.d_year could be expanded or optimized\n4. The IN clause on store.s_county\n\nBut the specific detected opportunity is OR_TO_UNION for the hd_buy_potential OR condition.\n\nLet me think about how to apply OR_TO_UNION here. The OR condition is:\n`(household_demographics.hd_buy_potential = '501-1000' OR household_demographics.hd_buy_potential = 'Unknown')`\n\nTo apply OR_TO_UNION, I would split the subquery into two branches:\n1. One with `hd_buy_potential = '501-1000'`\n2. One with `hd_buy_potential = 'Unknown'`\n\nThen UNION ALL them together.\n\nBut I also notice there are other filters that could be pushed down early:\n- date_dim.d_dom BETWEEN 1 AND 2\n- date_dim.d_year IN (2000, 2001, 2002)\n- store.s_county IN (...)\n- household_demographics.hd_vehicle_count > 0\n- The CASE statement condition\n\nHowever, the prompt specifically mentions the OR_TO_UNION opportunity on the OR condition.\n\nLet me structure the rewrite:\n\n1. Create filtered_date_dim with the date filters pushed down\n2. Create filtered_store with the county filter pushed down  \n3. Split the main subquery into two branches for the OR condition\n4. Union them together\n5. Join with customer and apply the cnt filter\n\nWait, looking at the example, the OR_TO_UNUN splits the entire query into UNION ALL branches, each with one part of the OR condition.\n\nSo for this query, I should:\n\nCreate a CTE or subquery that handles the date and store filtering first (early_filter/pushdown), then split the OR condition into two UNION ALL branches.\n\nActually, looking at the example more carefully:\n- The example shows creating a filtered_dates CTE first\n- Then creating filtered_sales as a UNION ALL of three branches, each with one condition from the OR\n- Then the main query does the aggregation\n\nIn my case:\n- The OR is inside the subquery (dj)\n- The subquery does GROUP BY\n- So I need to split the subquery into two parts, union them, then group? Or union two grouped results?\n\nSince the grouping is on ss_ticket_number and ss_customer_sk, and the OR condition is on household_demographics which is joined before the group by, I can:\n1. Filter dates and stores early\n2. Create two branches for the OR condition, each joining with the appropriate hd_buy_potential filter\n3. Union them\n4. Then group by\n\nOr I could group in each branch and then union. But since COUNT(*) is additive across disjoint sets, both approaches work. However, grouping after union is usually better if the union reduces rows significantly, but here the OR is on a dimension table (household_demographics) joined to the fact table (store_sales).\n\nActually, looking at the query plan:\n- store_sales is the fact table\n- It joins to date_dim, store, and household_demographics\n- The OR is on household_demographics.hd_buy_potential\n\nSo the OR_TO_UNION transform would split the query into:\nBranch 1: ... AND hd_buy_potential = '501-1000' ...\nBranch 2: ... AND hd_buy_potential = 'Unknown' ...\n\nAnd UNION ALL them.\n\nBut I should also push down other filters like:\n- date_dim filters (d_dom, d_year)\n- store.s_county filter\n- hd_vehicle_count > 0\n- The CASE condition (which is actually redundant with hd_vehicle_count > 0 check, but let's keep it)\n\nAlso, I can push the customer join and the cnt filter earlier? The cnt filter is on the result of the aggregation, so it has to happen after the GROUP BY. But the join to customer happens after the subquery, and the filter on cnt also happens after.\n\nWait, looking at the query structure:\n- The subquery (dj) groups and counts\n- Then it joins to customer\n- Then filters cnt BETWEEN 1 AND 5\n\nThe cnt filter could be pushed into the subquery (HAVING clause), but that's not one of the allowed transforms explicitly, though it's part of early_filter or pushdown.\n\nBut the allowed transforms are: pushdown, decorrelate, or_to_union, in_to_exists, projection_prune, early_filter.\n\nSo I can use early_filter to push the cnt filter into the subquery as a HAVING clause, and also push the customer join? No, the customer join uses columns not in the subquery, but the cnt filter only uses the subquery columns.\n\nActually, looking at the output columns and grain:\n- The subquery grain is ss_ticket_number, ss_customer_sk\n- The main query joins to customer on ss_customer_sk = c_customer_sk\n- Then filters cnt BETWEEN 1 AND 5\n\nI could push the cnt filter into the subquery as a HAVING clause. This is an early_filter transform.\n\nBut the detected opportunity specifically mentions OR_TO_UNION.\n\nLet me focus on the OR_TO_UNION as the primary transform, but I can combine it with early_filter for the date and store predicates, and maybe pushdown.\n\nActually, looking at the example output format, it seems I should create multiple nodes in the rewrite set.\n\nLet me draft the rewrite:\n\n```json\n{\n  \"rewrite_sets\": [\n    {\n      \"id\": \"rs_01\",\n      \"transform\": \"or_to_union\",\n      \"nodes\": {\n        \"filtered_dates\": \"SELECT d_date_sk FROM date_dim WHERE d_dom BETWEEN 1 AND 2 AND d_year IN (2000, 2001, 2002)\",\n        \"filtered_store\": \"SELECT s_store_sk FROM store WHERE s_county IN ('Fairfield County', 'Walker County', 'Daviess County', 'Barrow County')\",\n        \"dj_branch1\": \"SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_store ON ss_store_sk = s_store_sk JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk WHERE hd_buy_potential = '501-1000' AND hd_vehicle_count > 0 AND CASE WHEN hd_vehicle_count > 0 THEN hd_dep_count / hd_vehicle_count ELSE NULL END > 1 GROUP BY ss_ticket_number, ss_customer_sk\",\n        \"dj_branch2\": \"SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_store ON ss_store_sk = s_store_sk JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk WHERE hd_buy_potential = 'Unknown' AND hd_vehicle_count > 0 AND CASE WHEN hd_vehicle_count > 0 THEN hd_dep_count / hd_vehicle_count ELSE NULL END > 1 GROUP BY ss_ticket_number, ss_customer_sk\",\n        \"dj\": \"SELECT ss_ticket_number, ss_customer_sk, cnt FROM (SELECT * FROM dj_branch1 UNION ALL SELECT * FROM dj_branch2) AS unioned WHERE cnt BETWEEN 1 AND 5\",\n        \"main_query\": \"SELECT c_last_name, c_first_name, c_salutation, c_preferred_cust_flag, ss_ticket_number, cnt FROM dj JOIN customer ON ss_customer_sk = c_customer_sk ORDER BY cnt DESC, c_last_name ASC\"\n      },\n      ...\n    }\n  ]\n}\n```\n\nWait, I need to check if I can push the cnt filter into the subquery. The original query has:\n```sql\n... AS dj, customer \nWHERE ss_customer_sk = c_customer_sk \n  AND cnt BETWEEN 1 AND 5 \n```\n\nSo yes, I can push cnt BETWEEN 1 AND 5 into the dj subquery as a HAVING clause or WHERE clause on the grouped result. Since dj is defined as a subquery with GROUP BY, I should add HAVING cnt BETWEEN 1 AND 5 to both branches or filter after the union.\n\nActually, looking at the original query structure again:\n```sql\nSELECT ... FROM (SELECT ... GROUP BY ...) AS dj, customer \nWHERE ... AND cnt BETWEEN 1 AND 5\n```\n\nThe cnt is available in the dj subquery output, so I can add it as a HAVING clause in the branches or as a filter on the union result.\n\nBut also, I notice that the CASE condition:\n`CASE WHEN household_demographics.hd_vehicle_count > 0 THEN household_demographics.hd_dep_count / household_demographics.hd_vehicle_count ELSE NULL END > 1`\n\nGiven that we already have `hd_vehicle_count > 0`, the CASE simplifies to `hd_dep_count / hd_vehicle_count > 1`.\n\nBut I should keep the SQL as close to original semantics as possible unless optimizing.\n\nNow, regarding the node contracts:\n- main_query output columns: ['c_last_name', 'c_first_name', 'c_salutation', 'c_preferred_cust_flag', 'ss_ticket_number', 'cnt']\n- grain: ['ss_ticket_number', 'ss_customer_sk']\n- required_predicates: ['ss_customer_sk = c_customer_sk']\n\nIn my rewrite, I need to make sure the main_query node preserves these.\n\nAlso, I should consider if I can use early_filter to push the date and store filters into CTEs, as shown in the examples.\n\nLet me refine:\n\n1. Create `filtered_dates` with date filters\n2. Create `filtered_store` with store filters  \n3. Create `branch_501_1000` for the first OR condition with all other filters\n4. Create `branch_unknown` for the second OR condition with all other filters\n5. Create `dj` as UNION ALL of the two branches, with the cnt filter applied (HAVING or WHERE)\n6. Create `main_query` joining dj with customer and ordering\n\nActually, looking at the example OR_TO_UNION, they created filtered_sales as the UNION ALL of three branches, each with one OR condition.\n\nSo for this query, I should create the dj subquery as a UNION ALL.\n\nBut wait, the dj subquery in the original does GROUP BY. If I split into two branches, I can either:\n- Group in each branch then union (requires adding the counts if there could be overlap, but since hd_buy_potential is mutually exclusive values '501-1000' vs 'Unknown', there's no overlap, so UNION ALL is fine)\n- Union then group\n\nSince the OR is on a dimension attribute that filters the fact table, and we're counting rows, splitting the fact table scan into two parts (one for each dimension filter) and grouping each separately then unioning is valid.\n\nHowever, looking at the query, store_sales joins to household_demographics. If I filter household_demographics first by hd_buy_potential, then join to store_sales, that's efficient.\n\nSo:\n- Branch 1: store_sales -> filtered_dates -> filtered_store -> household_demographics (hd_buy_potential = '501-1000') -> group by\n- Branch 2: store_sales -> filtered_dates -> filtered_store -> household_demographics (hd_buy_potential = 'Unknown') -> group by\n- Union them\n- Filter cnt between 1 and 5\n- Join to customer\n\nBut I can also push the cnt filter (HAVING) into each branch.\n\nLet me check the expected_speedup. The prompt says \"Expected: 2x speedup\" for the OR_TO_UNION.\n\nRisk is low.\n\nInvariants kept should include:\n- output columns unchanged\n- same rows after aggregation (or same final result)\n- same ordering\n\nNow, let me write the SQL carefully.\n\nOriginal filters in the subquery:\n- date_dim.d_dom BETWEEN 1 AND 2\n- date_dim.d_year IN (2000, 2000 + 1, 2000 + 2) = IN (2000, 2001, 2002)\n- store.s_county IN ('Fairfield County', 'Walker County', 'Daviess County', 'Barrow County')\n- hd_buy_potential OR condition\n- hd_vehicle_count > 0\n- CASE condition\n\nThe CASE condition: `CASE WHEN household_demographics.hd_vehicle_count > 0 THEN household_demographics.hd_dep_count / household_demographics.hd_vehicle_count ELSE NULL END > 1`\n\nSince we have `hd_vehicle_count > 0` in the WHERE clause, the CASE WHEN is redundant for the NULL check, but I should preserve the logic.\n\nActually, looking at the SQL: `AND CASE WHEN household_demographics.hd_vehicle_count > 0 THEN household_demographics.hd_dep_count / household_demographics.hd_vehicle_count ELSE NULL END > 1`\n\nSince `hd_vehicle_count > 0` is already required, this simplifies to `hd_dep_count / hd_vehicle_count > 1`, but I'll keep the CASE to be safe and preserve semantics exactly.\n\nNow for the rewrite:\n\n```json\n{\n  \"rewrite_sets\": [\n    {\n      \"id\": \"rs_01\",\n      \"transform\": \"or_to_union\",\n      \"nodes\": {\n        \"filtered_dates\": \"SELECT d_date_sk FROM date_dim WHERE d_dom BETWEEN 1 AND 2 AND d_year IN (2000, 2001, 2002)\",\n        \"filtered_stores\": \"SELECT s_store_sk FROM store WHERE s_county IN ('Fairfield County', 'Walker County', 'Daviess County', 'Barrow County')\",\n        \"dj_buy_potential_501_1000\": \"SELECT ss.ss_ticket_number, ss.ss_customer_sk, COUNT(*) AS cnt FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN filtered_stores fs ON ss.ss_store_sk = fs.s_store_sk JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk WHERE hd.hd_buy_potential = '501-1000' AND hd.hd_vehicle_count > 0 AND CASE WHEN hd.hd_vehicle_count > 0 THEN hd.hd_dep_count / hd.hd_vehicle_count ELSE NULL END > 1 GROUP BY ss.ss_ticket_number, ss.ss_customer_sk HAVING COUNT(*) BETWEEN 1 AND 5\",\n        \"dj_buy_potential_unknown\": \"SELECT ss.ss_ticket_number, ss.ss_customer_sk, COUNT(*) AS cnt FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN filtered_stores fs ON ss.ss_store_sk = fs.s_store_sk JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk WHERE hd.hd_buy_potential = 'Unknown' AND hd.hd_vehicle_count > 0 AND CASE WHEN hd.hd_vehicle_count > 0 THEN hd.hd_dep_count / hd.hd_vehicle_count ELSE NULL END > 1 GROUP BY ss.ss_ticket_number, ss.ss_customer_sk HAVING COUNT(*) BETWEEN 1 AND 5\",\n        \"dj\": \"SELECT ss_ticket_number, ss_customer_sk, cnt FROM dj_buy_potential_501_1000 UNION ALL SELECT ss_ticket_number, ss_customer_sk, cnt FROM dj_buy_potential_unknown\",\n        \"main_query\": \"SELECT c.c_last_name, c.c_first_name, c.c_salutation, c.c_preferred_cust_flag, dj.ss_ticket_number, dj.cnt FROM dj JOIN customer c ON dj.ss_customer_sk = c.c_customer_sk ORDER BY dj.cnt DESC, c.c_last_name ASC\"\n      },\n      \"invariants_kept\": [\n        \"output columns unchanged\",\n        \"same result rows\",\n        \"same ordering\"\n      ],\n      \"expected_speedup\": \"2.00x\",\n      \"risk\": \"low\"\n    }\n  ]\n}\n```\n\nWait, I need to check if I should include the cnt filter in the main_query or in dj. In the original, it's in the main_query WHERE clause. But since dj is now a CTE/subquery, I can put it in dj or keep it in main_query. \n\nActually, looking at the original:\n```sql\nFROM (...) AS dj, customer \nWHERE ss_customer_sk = c_customer_sk AND cnt BETWEEN 1 AND 5\n```\n\nSo the cnt filter is applied after the join with customer. But since cnt comes from dj and doesn't depend on customer, I can push it into dj (the subquery). This would be an early_filter.\n\nBut the transform requested is OR_TO_UNION. I can combine transforms? The example shows \"OR_TO_UNION + EARLY_FILTER\" in the first example title, but in the output it's listed as \"or_to_union\" transform. So I can include multiple optimizations in one rewrite set.\n\nHowever, looking at the example 2, it only lists \"or_to_union\" as the transform, but it also does early filtering by creating filtered_dates and pushing conditions there.\n\nSo I think it's fine to include the early filtering of dates and stores, and also push the cnt filter into the subqueries (HAVING).\n\nBut wait, if I push cnt into the HAVING clause of each branch, and then UNION ALL, that's fine.\n\nAlso, I should check if I need to handle the join to customer. The main_query should preserve the join.\n\nOne thing: in the original query, the subquery is named `dj` and is used in the FROM clause with `customer`. The join condition is `ss_customer_sk = c_customer_sk`.\n\nIn my rewrite, I have `dj` as the union result, then join to customer in main_query.\n\nLet me double-check the column aliases. In the original subquery:\n`SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt`\n\nSo dj has columns: ss_ticket_number, ss_customer_sk, cnt.\n\nThen main_query selects from dj and customer where ss_customer_sk = c_customer_sk.\n\nSo my main_query should be correct.\n\nOne optimization: I could also push the customer join into the branches? No, because that would duplicate the customer lookup. Better to filter with cnt first (which reduces rows) then join to customer.\n\nBut the cnt filter is on the grouped result. The grouping is on ss_ticket_number and ss_customer_sk. If I filter by cnt BETWEEN 1 AND 5 in each branch (HAVING), I reduce the rows before the union. Then after union, I join to customer.\n\nThis is efficient.\n\nNow, regarding the CASE statement: `CASE WHEN household_demographics.hd_vehicle_count > 0 THEN household_demographics.hd_dep_count / household_demographics.hd_vehicle_count ELSE NULL END > 1`\n\nSince we already filter `hd_vehicle_count > 0`, the division is safe. The CASE is technically redundant but I'll keep it to preserve exact semantics.\n\nAlso, note that `2000 + 1` and `2000 + 2` should be evaluated to `2001` and `2002` in the rewritten SQL for clarity, or I can keep them as expressions. The example used literal values. I'll use 2001 and 2002.\n\nLet me verify the invariants:\n- output_columns: main_query selects c_last_name, c_first_name, c_salutation, c_preferred_cust_flag, ss_ticket_number, cnt - matches original.\n- grain: The final output has one row per ss_ticket_number, ss_customer_sk (implied by the grouping in dj and the join to customer which is 1:1 on customer_sk). Actually, the grain of the final output is the same as dj, which is ss_ticket_number, ss_customer_sk. The customer join doesn't change the grain assuming c_customer_sk is unique (primary key).\n- required_predicates: ss_customer_sk = c_customer_sk is preserved in main_query.\n\nExpected speedup: 2x as suggested.\nRisk: low.\n\nI think this is good.\n\nOne final check: should I use `UNION ALL` or `UNION`? Since the two branches are mutually exclusive (hd_buy_potential cannot be both '501-1000' and 'Unknown'), UNION ALL is correct and more efficient.\n\nAlso, should I include `filtered_household_501_1000` and `filtered_household_unknown` as separate CTEs? The example showed pushing filters into the branches directly. I think joining to household_demographics with the filter in the WHERE clause of each branch is clear and follows the pattern.\n\nActually, looking at the example again:\n```sql\n\"filtered_sales\": \"SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE substr(ca_zip,1,5) IN (...) UNION ALL ...\"\n```\n\nSo they put the OR condition split into the WHERE clauses of the UNION ALL branches. This is exactly what I did.\n\nSo my rewrite looks correct.\n\nOne small thing: in the original query, the subquery is aliased as `dj` and the main query does `FROM (...) AS dj, customer`. This is an implicit join (comma join) with WHERE clause conditions. In my rewrite, I used explicit JOIN syntax `FROM dj JOIN customer ON ...` which is equivalent and cleaner.\n\nAlso, I should make sure to qualify all columns properly to avoid ambiguity.\n\nIn dj_buy_potential_501_1000:\n- ss.ss_ticket_number, ss.ss_customer_sk - good\n- COUNT(*) AS cnt - good\n\nIn dj_buy_potential_unknown:\n- same\n\nIn dj:\n- SELECT ss_ticket_number, ss_customer_sk, cnt - good (no table alias needed since it's selecting from the CTEs)\n\nIn main_query:\n- c.c_last_name, etc.\n- dj.ss_ticket_number, dj.cnt\n- ORDER BY dj.cnt DESC, c.c_last_name ASC\n\nWait, in the original ORDER BY: `ORDER BY cnt DESC, c_last_name ASC`\n\nSince cnt and c_last_name are in the output, and in my main_query I have dj.cnt and c.c_last_name, I should use the table aliases or just the column names if unambiguous. But to be safe and clear, I'll use the aliases.\n\nActually, looking at the original: `ORDER BY cnt DESC, c_last_name ASC`\n\nIt uses unqualified names. In my main_query, I can use `dj.cnt` and `c.c_last_name` or just `cnt` and `c_last_name` if I alias the output columns. But since I select `dj.cnt` and `c.c_last_name`, I should reference them appropriately.\n\nIn the SELECT list of main_query, I have:\n`SELECT c.c_last_name, c.c_first_name, c.c_salutation, c.c_preferred_cust_flag, dj.ss_ticket_number, dj.cnt`\n\nSo in ORDER BY, I can use `dj.cnt DESC, c.c_last_name ASC` or just `cnt DESC, c_last_name ASC` since those are the output column names effectively. But to be consistent with the examples, I'll use the aliases.\n\nActually, looking at example 1:\n```sql\n\"main_query\": \"SELECT c.c_customer_id FROM customer_total_return ctr1 JOIN store_avg_return sar ON ctr1.ctr_store_sk = sar.ctr_store_sk JOIN customer c ON ctr1.ctr_customer_sk = c.c_customer_sk WHERE ctr1.ctr_total_return > sar.avg_return_threshold ORDER BY c.c_customer_id LIMIT 100\"\n```\n\nThey use table aliases in ORDER BY.\n\nSo I'll use `ORDER BY dj.cnt DESC, c.c_last_name ASC`.\n\nOne final check: the original query has `date_dim.d_year IN (2000, 2000 + 1, 2000 + 2)`. I replaced this with `IN (2000, 2001, 2002)`. This is a constant folding which preserves semantics.\n\nAlso, `d_dom BETWEEN 1 AND 2` is preserved.\n\nThe `s_county IN (...)` is preserved.\n\nThe `hd_vehicle_count > 0` and CASE condition are preserved.\n\nThe `cnt BETWEEN 1 AND 5` is preserved (moved to HAVING in branches).\n\nThe join to customer is preserved.\n\nThe final ordering is preserved.\n\nI think this is complete. </think> ```json\n{\n  \"rewrite_sets\": [\n    {\n      \"id\": \"rs_01\",\n      \"transform\": \"or_to_union\",\n      \"nodes\": {\n        \"filtered_dates\": \"SELECT d_date_sk FROM date_dim WHERE d_dom BETWEEN 1 AND 2 AND d_year IN (2000, 2001, 2002)\",\n        \"filtered_stores\": \"SELECT s_store_sk FROM store WHERE s_county IN ('Fairfield County', 'Walker County', 'Daviess County', 'Barrow County')\",\n        \"dj_buy_potential_501_1000\": \"SELECT ss.ss_ticket_number, ss.ss_customer_sk, COUNT(*) AS cnt FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN filtered_stores fs ON ss.ss_store_sk = fs.s_store_sk JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk WHERE hd.hd_buy_potential = '501-1000' AND hd.hd_vehicle_count > 0 AND CASE WHEN hd.hd_vehicle_count > 0 THEN hd.hd_dep_count / hd.hd_vehicle_count ELSE NULL END > 1 GROUP BY ss.ss_ticket_number, ss.ss_customer_sk HAVING COUNT(*) BETWEEN 1 AND 5\",\n        \"dj_buy_potential_unknown\": \"SELECT ss.ss_ticket_number, ss.ss_customer_sk, COUNT(*) AS cnt FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN filtered_stores fs ON ss.ss_store_sk = fs.s_store_sk JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk WHERE hd.hd_buy_potential = 'Unknown' AND hd.hd_vehicle_count > 0 AND CASE WHEN hd.hd_vehicle_count > 0 THEN hd.hd_dep_count / hd.hd_vehicle_count ELSE NULL END > 1 GROUP BY ss.ss_ticket_number, ss.ss_customer_sk HAVING COUNT(*) BETWEEN 1 AND 5\",\n        \"dj\": \"SELECT ss_ticket_number, ss_customer_sk, cnt FROM dj_buy_potential_501_1000 UNION ALL SELECT ss_ticket_number, ss_customer_sk, cnt FROM dj_buy_potential_unknown\",\n        \"main_query\": \"SELECT c.c_last_name, c.c_first_name, c.c_salutation, c.c_preferred_cust_flag, dj.ss_ticket_number, dj.cnt FROM dj JOIN customer c ON dj.ss_customer_sk = c.c_customer_sk ORDER BY dj.cnt DESC, c.c_last_name ASC\"\n      },\n      \"invariants_kept\": [\n        \"output columns unchanged\",\n        \"same result rows\",\n        \"same ordering\"\n      ],\n      \"expected_speedup\": \"2.00x\",\n      \"risk\": \"low\"\n    }\n  ],\n  \"explanation\": \"Split the OR condition on hd_buy_potential into two UNION ALL branches to enable separate filtered scans on household_demographics. Pushed down date_dim filters (d_dom, d_year) and store filters (s_county) into early CTEs. Pushed the cnt BETWEEN 1 AND 5 filter into each branch as HAVING to reduce rows before the union and customer join.\"\n}\n```",
    "error": null,
    "latency_ms": 115063.3968559996,
    "tokens_in": 1706,
    "tokens_out": 6051
  }
}