```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "or_to_union",
      "nodes": {
        "main_query": "SELECT i_item_id, AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4 FROM store_sales, customer_demographics, date_dim, item, promotion WHERE ss_sold_date_sk = d_date_sk AND ss_item_sk = i_item_sk AND ss_cdemo_sk = cd_demo_sk AND ss_promo_sk = p_promo_sk AND cd_gender = 'F' AND cd_marital_status = 'W' AND cd_education_status = 'College' AND p_channel_email = 'N' AND d_year = 2001 GROUP BY i_item_id UNION ALL SELECT i_item_id, AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4 FROM store_sales, customer_demographics, date_dim, item, promotion WHERE ss_sold_date_sk = d_date_sk AND ss_item_sk = i_item_sk AND ss_cdemo_sk = cd_demo_sk AND ss_promo_sk = p_promo_sk AND cd_gender = 'F' AND cd_marital_status = 'W' AND cd_education_status = 'College' AND p_channel_event = 'N' AND d_year = 2001 AND (p_channel_email IS NULL OR p_channel_email != 'N') GROUP BY i_item_id ORDER BY i_item_id LIMIT 100"
      },
      "invariants_kept": ["output_columns", "grain", "required_predicates", "semantic equivalence of OR condition"],
      "expected_speedup": "2x",
      "risk": "low"
    }
  ],
  "explanation": "Applied OR_TO_UNION transform to decompose the OR condition (p_channel_email = 'N' OR p_channel_event = 'N') into two UNION ALL branches. The first branch handles p_channel_email = 'N', the second handles p_channel_event = 'N' while excluding rows already counted in the first branch (p_channel_email != 'N' or NULL). This allows each branch to use more efficient index access patterns and reduces predicate evaluation complexity."
}
```