============================================================
PARSED OUTPUT
============================================================

OPTIMIZED QUERY:
----------------------------------------
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sum(SR_FEE) as ctr_total_return
from store_returns
,date_dim
,store
where sr_returned_date_sk = d_date_sk
and d_year = 2000
and s_store_sk = sr_store_sk
and s_state = 'SD'
group by sr_customer_sk
,sr_store_sk)
 select c_customer_id
from customer_total_return ctr1
,customer
where ctr1.ctr_total_return > (select avg(ctr2.ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk)
and ctr1.ctr_customer_sk = c_customer_sk
order by c_customer_id
 LIMIT 100;

RATIONALE:
----------------------------------------
This optimization improves performance by: 1) Applying the s_state='SD' filter early in the CTE, reducing the store_returns rows aggregated from ~56k to only those for SD stores before grouping, 2) Removing the separate store table join in the main query since store filtering is now in the CTE, 3) Ensuring the correlated subquery also uses the pre-filtered CTE data, avoiding unnecessary calculations for non-SD stores. This reduces I/O and computation in the hash group by and subsequent joins, particularly lowering the cost of scanning and joining the large customer table since fewer intermediate rows are produced.