{
  "optimized_sql": "SELECT\n  c_customer_id\nFROM customer_total_return AS ctr1\nJOIN store\n  ON s_store_sk = ctr1.ctr_store_sk\nJOIN customer\n  ON ctr1.ctr_customer_sk = c_customer_sk\nWHERE\n  ctr1.ctr_total_return > ctr1.ctr_avg_return_threshold AND s_state = 'SD'\nORDER BY\n  c_customer_id\nLIMIT 100",
  "explanation": "Converted the correlated subquery to a window function in the CTE. The original query calculated `AVG(ctr_total_return) * 1.2` repeatedly for each store via a correlated subquery. By using `AVG(SUM(SR_FEE)) OVER (PARTITION BY sr_store_sk) * 1.2` in the CTE, the average is computed once per store during the single pass of the data. The main query now simply compares `ctr_total_return > ctr_avg_return_threshold` without a subquery scan. This eliminates the O(n\u00b2) nested loop behavior and allows DuckDB to use efficient parallel hash joins for the main query joins. Explicit JOIN syntax was added to help the optimizer recognize join conditions.",
  "rewrites": {
    "customer_total_return": "SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(SR_FEE) AS ctr_total_return, AVG(SUM(SR_FEE)) OVER (PARTITION BY sr_store_sk) * 1.2 AS ctr_avg_return_threshold FROM store_returns JOIN date_dim ON sr_returned_date_sk = d_date_sk WHERE d_year = 2000 GROUP BY sr_customer_sk, sr_store_sk",
    "main_query": "SELECT c_customer_id FROM customer_total_return ctr1 JOIN store ON s_store_sk = ctr1.ctr_store_sk JOIN customer ON ctr1.ctr_customer_sk = c_customer_sk WHERE ctr1.ctr_total_return > ctr1.ctr_avg_return_threshold AND s_state = 'SD' ORDER BY c_customer_id LIMIT 100"
  },
  "correct": true,
  "attempts": 1,
  "latency_ms": 78871.65110299975
}