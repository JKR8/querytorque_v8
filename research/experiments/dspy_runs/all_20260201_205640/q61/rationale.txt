1. **Consolidated Subqueries into Conditional Aggregation**: The original query had two separate subqueries scanning `store_sales` twice with similar joins. By using a single query with a `CASE` statement in the `SUM` aggregation, we compute both promotional sales (where promotion conditions apply) and total sales in one pass, eliminating redundant joins and reducing I/O on large tables like `store_sales` and `customer`. This directly addresses the high-cost sequential scans (70.3% and 7.4%) by cutting them in half.

2. **Early Filtering with Selective Tables**: The join order is structured to prioritize highly filtered tables like `date_dim` (30 rows) and `item` (20,360 rows) early in the join sequence, reducing the intermediate result set before joining with larger tables. This leverages the row estimates showing strong filters on these dimensions.

3. **Explicit JOIN Syntax**: Using `INNER JOIN` and `LEFT JOIN` (for `promotion` to handle non-promotional sales) improves readability and can help the query optimizer choose more efficient join strategies.

4. **Removed Redundant ORDER BY**: The outer query orders by `promotions` and `total`, but since each subquery returns a single aggregated value, the result is one row. Sorting one row is unnecessary and adds overhead; removing it simplifies execution.

5. **Maintained Semantics**: The optimized query preserves the original logic—calculating promotional sales (based on specific promotion channels) and total sales for Jewelry items in November 1999, with GMT offset filters—while improving performance through reduced table scans and early filtering.