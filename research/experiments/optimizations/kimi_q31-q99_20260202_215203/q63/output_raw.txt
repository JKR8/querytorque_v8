 The user wants me to optimize a SQL query using the allowed transforms. The query is query63.tpl from TPC-DS.

Let me analyze the query:

```sql
SELECT * FROM (
  SELECT 
    i_manager_id, 
    SUM(ss_sales_price) AS sum_sales, 
    AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_manager_id) AS avg_monthly_sales 
  FROM item, store_sales, date_dim, store 
  WHERE ss_item_sk = i_item_sk 
    AND ss_sold_date_sk = d_date_sk 
    AND ss_store_sk = s_store_sk 
    AND d_month_seq IN (1181, 1181 + 1, 1181 + 2, 1181 + 3, 1181 + 4, 1181 + 5, 1181 + 6, 1181 + 7, 1181 + 8, 1181 + 9, 1181 + 10, 1181 + 11) 
    AND (
      (i_category IN ('Books', 'Children', 'Electronics') 
       AND i_class IN ('personal', 'portable', 'reference', 'self-help') 
       AND i_brand IN ('scholaramalgamalg #14', 'scholaramalgamalg #7', 'exportiunivamalg #9', 'scholaramalgamalg #9')) 
      OR 
      (i_category IN ('Women', 'Music', 'Men') 
       AND i_class IN ('accessories', 'classical', 'fragrances', 'pants') 
       AND i_brand IN ('amalgimporto #1', 'edu packscholar #1', 'exportiimporto #1', 'importoamalg #1'))
    ) 
  GROUP BY i_manager_id, d_moy
) AS tmp1 
WHERE CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 
ORDER BY i_manager_id, avg_monthly_sales, sum_sales 
LIMIT 100
```

The detected opportunity is OR_TO_UNION. The query has an OR condition with two branches:
1. (i_category IN ('Books', 'Children', 'Electronics') AND i_class IN (...) AND i_brand IN (...))
2. (i_category IN ('Women', 'Music', 'Men') AND i_class IN (...) AND i_brand IN (...))

This is a classic case for OR_TO_UNION transform. I need to split this into two UNION ALL branches.

However, there's a window function involved: `AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_manager_id)`. When doing OR_TO_UNION, I need to be careful about where the window function is computed.

Looking at the structure:
- The inner query groups by i_manager_id and d_moy
- It calculates sum_sales per group
- It calculates avg_monthly_sales as the average of sum_sales across all d_moy values for each i_manager_id (window function)
- The outer query filters based on the ratio of sum_sales to avg_monthly_sales

For OR_TO_UNION, I should:
1. Split the item filter into two branches
2. Each branch joins with store_sales, date_dim, store
3. Apply the specific item filters to each branch
4. Union them together
5. Then do the GROUP BY and window function

Wait, actually, looking at the query more carefully:
- The OR condition is on item attributes (i_category, i_class, i_brand)
- So I can filter item table first, or push the filter down to the joins

The best approach for OR_TO_UNION here would be:
- Create two CTEs or subqueries, one for each OR branch, filtering items accordingly
- Union them
- Then join with the fact table

But actually, looking at the query, the joins are:
- store_sales joins item on ss_item_sk = i_item_sk
- store_sales joins date_dim on ss_sold_date_sk = d_date_sk  
- store_sales joins store on ss_store_sk = s_store_sk

So the OR condition is on the item table. I can:
1. Filter item table into two branches based on the OR condition
2. Union them
3. Join with store_sales

Or I can:
1. Join store_sales with date_dim and store first (applying the date filter)
2. Then split into two branches based on item filters
3. Union them
4. Then aggregate

Given that the date filter is very selective (d_month_seq in a specific range), it makes sense to apply that first.

Let me structure the rewrite:

```sql
-- Branch 1: First OR condition
SELECT i_manager_id, SUM(ss_sales_price) AS sum_sales
FROM (
  SELECT ss_item_sk, ss_store_sk, ss_sold_date_sk, ss_sales_price
  FROM store_sales
  WHERE ss_sold_date_sk IN (SELECT d_date_sk FROM date_dim WHERE d_month_seq IN (...))
) ss
JOIN (
  SELECT i_item_sk, i_manager_id
  FROM item
  WHERE i_category IN ('Books', 'Children', 'Electronics')
    AND i_class IN ('personal', 'portable', 'reference', 'self-help')
    AND i_brand IN ('scholaramalgamalg #14', 'scholaramalgamalg #7', 'exportiunivamalg #9', 'scholaramalgamalg #9')
) i ON ss.ss_item_sk = i.i_item_sk
JOIN store s ON ss.ss_store_sk = s.s_store_sk
GROUP BY i_manager_id, d_moy

UNION ALL

-- Branch 2: Second OR condition  
SELECT i_manager_id, SUM(ss_sales_price) AS sum_sales
FROM (
  SELECT ss_item_sk, ss_store_sk, ss_sold_date_sk, ss_sales_price
  FROM store_sales
  WHERE ss_sold_date_sk IN (SELECT d_date_sk FROM date_dim WHERE d_month_seq IN (...))
) ss
JOIN (
  SELECT i_item_sk, i_manager_id
  FROM item
  WHERE i_category IN ('Women', 'Music', 'Men')
    AND i_class IN ('accessories', 'classical', 'fragrances', 'pants')
    AND i_brand IN ('amalgimporto #1', 'edu packscholar #1', 'exportiimporto #1', 'importoamalg #1')
) i ON ss.ss_item_sk = i.i_item_sk
JOIN store s ON ss.ss_store_sk = s.s_store_sk
GROUP BY i_manager_id, d_moy
```

Wait, I need to be careful. The original query groups by i_manager_id and d_moy, but d_moy comes from date_dim. So I need to include date_dim in the joins or carry d_moy through.

Actually, looking at the original query:
- It selects from item, store_sales, date_dim, store
- It groups by i_manager_id, d_moy
- d_moy is from date_dim

So in my rewrite, I need to make sure d_moy is available for the GROUP BY.

Also, the window function `AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_manager_id)` is computed after the GROUP BY. This means it's computing the average monthly sales across all months (d_moy values) for each manager.

If I do OR_TO_UNION, I should:
1. Split the base data into two union branches with the item filters
2. Then do the GROUP BY and window function on the combined result

Or I could do the GROUP BY in each branch, then union, then compute the window function? But that would be wrong because the window function needs to see all d_moy values for each i_manager_id across both branches.

Actually, if I union after aggregation, the window function would be computed on the unioned aggregated data. That should work.

Let me think about the grain:
- Inner query grain: i_manager_id, d_moy
- Window function: AVG(sum_sales) per i_manager_id (across all d_moy)

So if I do:
1. Branch 1: Filter items, join with sales/date/store, group by i_manager_id, d_moy -> sum_sales_1
2. Branch 2: Filter items, join with sales/date/store, group by i_manager_id, d_moy -> sum_sales_2
3. Union all: sum_sales_1 + sum_sales_2
4. Compute window function on the union
5. Filter outer

This should be correct. The sum_sales from both branches for the same (i_manager_id, d_moy) would be in separate rows in the union, which is correct because they come from different items.

Wait, actually, if the same (i_manager_id, d_moy) pair appears in both branches, they should be summed together? No, because the OR condition is mutually exclusive on items (different categories), so an item can't be in both branches. Therefore, sales from different items are being summed. If I aggregate in each branch separately, I get partial sums per (manager, month) for each item category group. Then when I union them, I have two rows for the same (manager, month) if both branches have data for that month. But that's wrong! The original query would sum all sales for that manager and month across all items (matching either condition) into one row.

Oh wait, no. The GROUP BY is on i_manager_id and d_moy. If I do:
- Branch 1: GROUP BY i_manager_id, d_moy -> gives sum for category group 1
- Branch 2: GROUP BY i_manager_id, d_moy -> gives sum for category group 2
- Union: Now I have two rows for the same (i_manager_id, d_moy) if both groups have sales in that month
- Then window function: AVG(...) OVER (PARTITION BY i_manager_id) would treat these as separate rows

But in the original query, the GROUP BY aggregates across both category groups together, giving one row per (i_manager_id, d_moy) with the total sum.

So if I union after aggregation, I break the semantics.

Therefore, I need to union BEFORE the GROUP BY. I should:
1. Create a filtered_item CTE that is the UNION of the two item filters
2. Or inline the union in the FROM clause

Actually, looking at the OR_TO_UNION pattern from the example:
```sql
SELECT ... FROM table WHERE condition1
UNION ALL
SELECT ... FROM table WHERE condition2
```

So I should:
1. Create a subquery/CTE that unions the two filtered sets of store_sales joined with items
2. Then group by and window function on that

Structure:
```sql
WITH filtered_sales AS (
  SELECT ss_item_sk, ss_store_sk, ss_sold_date_sk, ss_sales_price, i_manager_id
  FROM store_sales
  JOIN item ON ... 
  JOIN date_dim ON ...
  JOIN store ON ...
  WHERE d_month_seq IN (...) AND <condition1>
  
  UNION ALL
  
  SELECT ss_item_sk, ss_store_sk, ss_sold_date_sk, ss_sales_price, i_manager_id
  FROM store_sales
  JOIN item ON ...
  JOIN date_dim ON ...
  JOIN store ON ...
  WHERE d_month_seq IN (...) AND <condition2>
)
SELECT i_manager_id, SUM(ss_sales_price) as sum_sales, 
       AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_manager_id) as avg_monthly_sales
FROM filtered_sales
GROUP BY i_manager_id, d_moy
```

Wait, I need d_moy in the filtered_sales to group by it. So I need to select d_moy from date_dim.

Also, I should check if I can push down the date filter. Yes, d_month_seq is on date_dim, so I can filter date_dim first or use it in the join condition.

Actually, looking at the example provided in the prompt, the OR_TO_UNION creates separate branches with the OR conditions pushed down, and common filters (like the date filter) are applied to both branches.

So:
- Branch 1: store_sales JOIN date_dim (filtered) JOIN store JOIN item (filtered with condition1)
- Branch 2: store_sales JOIN date_dim (filtered) JOIN store JOIN item (filtered with condition2)
- Union them
- Then GROUP BY and window function

But wait, the window function references d_moy implicitly through the grouping. The outer query references avg_monthly_sales which is calculated from the grouped data.

Let me write out the full rewrite:

```sql
SELECT * FROM (
  SELECT 
    i_manager_id, 
    SUM(ss_sales_price) AS sum_sales, 
    AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_manager_id) AS avg_monthly_sales 
  FROM (
    SELECT ss_item_sk, ss_store_sk, ss_sold_date_sk, ss_sales_price, i_manager_id, d_moy
    FROM store_sales
    JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_month_seq IN (1181, ...)
    JOIN store ON ss_store_sk = s_store_sk
    JOIN item ON ss_item_sk = i_item_sk
    WHERE i_category IN ('Books', 'Children', 'Electronics')
      AND i_class IN ('personal', 'portable', 'reference', 'self-help')
      AND i_brand IN ('scholaramalgamalg #14', 'scholaramalgamalg #7', 'exportiunivamalg #9', 'scholaramalgamalg #9')
    
    UNION ALL
    
    SELECT ss_item_sk, ss_store_sk, ss_sold_date_sk, ss_sales_price, i_manager_id, d_moy
    FROM store_sales
    JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_month_seq IN (1181, ...)
    JOIN store ON ss_store_sk = s_store_sk
    JOIN item ON ss_item_sk = i_item_sk
    WHERE i_category IN ('Women', 'Music', 'Men')
      AND i_class IN ('accessories', 'classical', 'fragrances', 'pants')
      AND i_brand IN ('amalgimporto #1', 'edu packscholar #1', 'exportiimporto #1', 'importoamalg #1')
  ) AS unioned_data
  GROUP BY i_manager_id, d_moy
) AS tmp1 
WHERE CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 
ORDER BY i_manager_id, avg_monthly_sales, sum_sales 
LIMIT 100
```

This looks correct. The UNION ALL happens before the GROUP BY, so the GROUP BY aggregates across both branches together, which matches the original semantics.

Now, looking at the node contracts:
- output_columns: ['*'] - I need to preserve all columns selected in the outer query
- grain: ['i_manager_id', 'd_moy'] - The inner query groups by these
- required_predicates: ['CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales', 'avg_monthly_sales > 0'] - These are in the outer WHERE clause

The transform is OR_TO_UNION.

I should also consider if EARLY_FILTER or PUSHDOWN applies. The date filter d_month_seq IN (...) can be pushed down into both branches, which I did above. This could be considered part of the OR_TO_UNION or as a separate PUSHDOWN, but since the prompt asks for atomic rewrite sets and the opportunity detected is OR_TO_UNION, I'll include the pushdown in the OR_TO_UNUN rewrite.

Actually, looking at the example, they created a "filtered_dates" CTE for common filters. I could do that too, but it's optional. The example shows:
```json
"filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_qoy = 1 AND d_year = 2001",
```

So I should probably create a filtered_dates CTE for the date filter, then use it in both branches.

Also, looking at the example, they kept the main_query as the final aggregation/query. So I should structure it as:
- filtered_dates: the date filter
- filtered_sales: the union of the two branches joining with filtered_dates
- main_query: the group by, window function, and outer filter

Wait, but the window function is in the inner query in the original. Let me check the original again.

Original:
```sql
SELECT * FROM (
  SELECT i_manager_id, SUM(ss_sales_price) AS sum_sales, AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_manager_id) AS avg_monthly_sales 
  FROM ... 
  WHERE ... 
  GROUP BY i_manager_id, d_moy
) AS tmp1 
WHERE ...
```

So the window function is inside the subquery tmp1. In my rewrite, I can keep that structure:
- filtered_dates
- unioned_sales (the union of two branches joining filtered_dates with sales/store/item with respective filters)
- tmp1 (or main_query_inner): group by and window function on unioned_sales
- main_query: the outer filter and order by

But the target node is [main_query] GROUP_BY, which suggests I should focus on the grouping part.

Let me map to the output format:

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "or_to_union",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_moy FROM date_dim WHERE d_month_seq IN (1181, 1181 + 1, 1181 + 2, 1181 + 3, 1181 + 4, 1181 + 5, 1181 + 6, 1181 + 7, 1181 + 8, 1181 + 9, 1181 + 10, 1181 + 11)",
        "filtered_sales": "SELECT ss_item_sk, ss_store_sk, ss_sold_date_sk, ss_sales_price, i_manager_id, d_moy FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN store ON ss_store_sk = s_store_sk JOIN item ON ss_item_sk = i_item_sk WHERE i_category IN ('Books', 'Children', 'Electronics') AND i_class IN ('personal', 'portable', 'reference', 'self-help') AND i_brand IN ('scholaramalgamalg #14', 'scholaramalgamalg #7', 'exportiunivamalg #9', 'scholaramalgamalg #9') UNION ALL SELECT ss_item_sk, ss_store_sk, ss_sold_date_sk, ss_sales_price, i_manager_id, d_moy FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN store ON ss_store_sk = s_store_sk JOIN item ON ss_item_sk = i_item_sk WHERE i_category IN ('Women', 'Music', 'Men') AND i_class IN ('accessories', 'classical', 'fragrances', 'pants') AND i_brand IN ('amalgimporto #1', 'edu packscholar #1', 'exportiimporto #1', 'importoamalg #1')",
        "main_query": "SELECT * FROM (SELECT i_manager_id, SUM(ss_sales_price) AS sum_sales, AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_manager_id) AS avg_monthly_sales FROM filtered_sales GROUP BY i_manager_id, d_moy) AS tmp1 WHERE CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 ORDER BY i_manager_id, avg_monthly_sales, sum_sales LIMIT 100"
      },
      "invariants_kept": [
        "output columns unchanged",
        "same aggregation grain",
        "same filter predicates applied"
      ],
      "expected_speedup": "2x",
      "risk": "low"
    }
  ]
}
```

I need to make sure I include d_moy in filtered_dates or filtered_sales so it's available for the GROUP BY. I included it in filtered_dates.

Also, I need to make sure the column names match. The main_query selects * from the subquery, and the subquery outputs i_manager_id, sum_sales, avg_monthly_sales. My main_query node preserves that.

One detail: in the original, the joins are: item, store_sales, date_dim, store. The order doesn't matter but I should make sure the join conditions are correct.

Original conditions:
- ss_item_sk = i_item_sk
- ss_sold_date_sk = d_date_sk  
- ss_store_sk = s_store_sk
- d_month_seq IN (...)
- OR condition on item

My rewrite:
- filtered_dates has d_date_sk and d_moy
- First branch: store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN store ON ss_store_sk = s_store_sk JOIN item ON ss_item_sk = i_item_sk + item filters
- Second branch: same with different item filters
- Then group by i_manager_id, d_moy

This looks correct.

I should verify that the window function still works correctly. The window function is AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_manager_id). This computes the average of the monthly sales (sum_sales) for each manager across all months. Since I'm grouping by d_moy in the main_query node, and the input to that is the union of both branches, the sum_sales for each (manager, month) will include contributions from both item category groups (if both have sales in that month), which is correct.

Actually, wait. If I union the two branches before grouping, and each branch has one row per (ss_item_sk, ss_store_sk, ss_sold_date_sk, ...), then when I group by i_manager_id, d_moy, I will sum all ss_sales_price from both branches. This is correct because the original query would also sum across all items matching either OR condition.

Yes, this is correct.

Risk is low because UNION ALL is safe when the branches are disjoint (which they are, based on mutually exclusive item categories), and even if not disjoint, UNION ALL preserves all rows which is correct for this aggregation.

Expected speedup: 2x as suggested in the prompt, or maybe higher because the item filters are highly selective and can use indexes.

I should format the SQL nicely in the JSON strings.

One final check: the original query has `d_moy` in the GROUP BY but doesn't select it in the output. That's fine, it's used for grouping but not projected. The output columns are i_manager_id, sum_sales, avg_monthly_sales.

In my filtered_sales, I need to make sure d_moy is available for the GROUP BY in main_query. I included it in the SELECT of filtered_sales.

Also, I should check if I need to include ss_store_sk or other columns in filtered_sales. The main_query only uses ss_sales_price, i_manager_id, and d_moy (for grouping). The other columns are not needed after the joins, but they don't hurt. However, to be clean, I should only select the necessary columns.

Actually, looking at the main_query, it does SELECT * FROM (subquery). The subquery outputs i_manager_id, sum_sales, avg_monthly_sales. So filtered_sales just needs to provide i_manager_id, ss_sales_price, and d_moy.

Wait, I also need to make sure the join with store is necessary. The original query joins with store but doesn't use any columns from store in the SELECT or WHERE (except implicitly through the join). Actually, looking at the original:
```sql
FROM item, store_sales, date_dim, store 
WHERE ... AND ss_store_sk = s_store_sk
```
It joins store but doesn't filter on store columns or select store columns. This is a useless join unless it's for data quality (ensuring the store exists), but in TPC-DS, referential integrity is usually enforced, so this join might be redundant. However, I should keep it to be safe and preserve semantics.

So I'll keep the store join in both branches.

Final check on the SQL syntax in the JSON:
- Need to escape quotes properly
- The IN list for d_month_seq is long: (1181, 1181 + 1, ...). I should keep it as is or simplify to the actual values? The example kept the expressions. I'll keep them as in the original.

Actually, looking at the original: `d_month_seq IN (1181, 1181 + 1, ...)`. This is valid SQL.

Let me write the final JSON. </think> ```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "or_to_union",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_moy FROM date_dim WHERE d_month_seq IN (1181, 1181 + 1, 1181 + 2, 1181 + 3, 1181 + 4, 1181 + 5, 1181 + 6, 1181 + 7, 1181 + 8, 1181 + 9, 1181 + 10, 1181 + 11)",
        "filtered_sales": "SELECT ss.ss_sales_price, i.i_manager_id, d.d_moy FROM store_sales ss JOIN filtered_dates d ON ss.ss_sold_date_sk = d.d_date_sk JOIN store s ON ss.ss_store_sk = s.s_store_sk JOIN item i ON ss.ss_item_sk = i.i_item_sk WHERE i.i_category IN ('Books', 'Children', 'Electronics') AND i.i_class IN ('personal', 'portable', 'reference', 'self-help') AND i.i_brand IN ('scholaramalgamalg #14', 'scholaramalgamalg #7', 'exportiunivamalg #9', 'scholaramalgamalg #9') UNION ALL SELECT ss.ss_sales_price, i.i_manager_id, d.d_moy FROM store_sales ss JOIN filtered_dates d ON ss.ss_sold_date_sk = d.d_date_sk JOIN store s ON ss.ss_store_sk = s.s_store_sk JOIN item i ON ss.ss_item_sk = i.i_item_sk WHERE i.i_category IN ('Women', 'Music', 'Men') AND i.i_class IN ('accessories', 'classical', 'fragrances', 'pants') AND i.i_brand IN ('amalgimporto #1', 'edu packscholar #1', 'exportiimporto #1', 'importoamalg #1')",
        "main_query": "SELECT * FROM (SELECT i_manager_id, SUM(ss_sales_price) AS sum_sales, AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_manager_id) AS avg_monthly_sales FROM filtered_sales GROUP BY i_manager_id, d_moy) AS tmp1 WHERE CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 ORDER BY i_manager_id, avg_monthly_sales, sum_sales LIMIT 100"
      },
      "invariants_kept": [
        "output columns unchanged",
        "same aggregation grain i_manager_id, d_moy",
        "same outer filter predicate on avg_monthly_sales",
        "mutually exclusive OR branches preserve row counts via UNION ALL"
      ],
      "expected_speedup": "2.5x",
      "risk": "low"
    }
  ],
  "explanation": "Split the OR condition on item attributes into two UNION ALL branches to enable index usage on item table (category, class, brand). Pushed down the date filter into a common CTE (filtered_dates) applied to both branches. The aggregation and window function remain unchanged, operating on the unioned result set. This allows the optimizer to use selective indexes on item dimensions for each branch rather than scanning the full item table."
}
```