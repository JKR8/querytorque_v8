 ```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "early_filter",
      "nodes": {
        "filtered_reason": "SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'",
        "filtered_returns": "SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk",
        "main_query": "SELECT ss_customer_sk, SUM(act_sales) AS sumsales FROM (SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales ss JOIN filtered_returns fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100"
      },
      "invariants_kept": [
        "output columns unchanged",
        "grain preserved at ss_customer_sk",
        "required predicates preserved via pushdown to filtered_reason and filtered_returns",
        "LEFT JOIN semantics preserved via equivalent INNER JOIN with pre-filtered returns"
      ],
      "expected_speedup": "2.8x",
      "risk": "low"
    }
  ],
  "explanation": "Pushed down the filter r_reason_desc = 'duplicate purchase' to the reason dimension table and pre-joined with store_returns to eliminate non-matching returns before joining with store_sales. This reduces the intermediate result set significantly. Also converted the LEFT JOIN to INNER JOIN since the WHERE clause in the original query effectively filtered out all non-matching rows (sales without 'duplicate purchase' returns). Removed unused columns ss_item_sk and ss_ticket_number from the subquery projection as they are not referenced by the outer query."
}
```