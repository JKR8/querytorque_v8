```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "early_filter",
      "nodes": {
        "filtered_income_band": "SELECT ib_income_band_sk FROM income_band WHERE ib_lower_bound >= 5806 AND ib_upper_bound <= 5806 + 50000",
        "filtered_address": "SELECT ca_address_sk FROM customer_address WHERE ca_city = 'Oakwood'",
        "main_query": "SELECT c.c_customer_id AS customer_id, COALESCE(c.c_last_name, '') || ', ' || COALESCE(c.c_first_name, '') AS customername FROM customer c JOIN filtered_address a ON c.c_current_addr_sk = a.ca_address_sk JOIN household_demographics hd ON c.c_current_hdemo_sk = hd.hd_demo_sk JOIN filtered_income_band ib ON hd.hd_income_band_sk = ib.ib_income_band_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk JOIN store_returns sr ON sr.sr_cdemo_sk = cd.cd_demo_sk ORDER BY c_customer_id LIMIT 100"
      },
      "invariants_kept": [
        "output columns unchanged",
        "row multiplicity preserved (no aggregation in original)",
        "ordering and limit preserved",
        "all join predicates maintained"
      ],
      "expected_speedup": "3.2x",
      "risk": "low"
    }
  ],
  "explanation": "Pushed selective filters (ca_city='Oakwood' and income_band range) into early CTEs to reduce join cardinality before hitting large tables like store_returns and customer. The income band filter is highly selective (specific numeric range) and the city filter reduces the address dimension significantly, minimizing the customer subset that needs to be joined with the fact table."
}
```