 ```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "early_filter",
      "nodes": {
        "filtered_web_data": "SELECT CASE WHEN t.t_hour BETWEEN 10 AND 11 THEN 1 END AS am_flag, CASE WHEN t.t_hour BETWEEN 16 AND 17 THEN 1 END AS pm_flag FROM web_sales ws JOIN household_demographics hd ON ws.ws_ship_hdemo_sk = hd.hd_demo_sk JOIN time_dim t ON ws.ws_sold_time_sk = t.t_time_sk JOIN web_page wp ON ws.ws_web_page_sk = wp.wp_web_page_sk WHERE hd.hd_dep_count = 2 AND wp.wp_char_count BETWEEN 5000 AND 5200 AND (t.t_hour BETWEEN 10 AND 11 OR t.t_hour BETWEEN 16 AND 17)",
        "counts": "SELECT COUNT(am_flag) AS amc, COUNT(pm_flag) AS pmc FROM filtered_web_data",
        "main_query": "SELECT CAST(amc AS DECIMAL(15, 4)) / CAST(pmc AS DECIMAL(15, 4)) AS am_pm_ratio FROM counts ORDER BY am_pm_ratio LIMIT 100"
      },
      "invariants_kept": [
        "output columns unchanged",
        "same ratio calculation",
        "same limit and ordering",
        "preserved all join predicates"
      ],
      "expected_speedup": "1.85x",
      "risk": "low"
    }
  ],
  "explanation": "Eliminated redundant table scans by merging the two subqueries (AM and PM counts) into a single scan with conditional aggregation. The original query scanned web_sales and dimension tables twice (once for each time range). By filtering early with the OR condition covering both time windows and using CASE statements to flag AM vs PM rows, we compute both counts in one pass through the data. This reduces I/O and join processing approximately by half."
}
```