 ```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "early_filter",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy = 12",
        "filtered_items": "SELECT i_item_sk, i_brand_id, i_brand, i_manufact_id, i_manufact FROM item WHERE i_manager_id = 2",
        "main_query": "SELECT i.i_brand_id AS brand_id, i.i_brand AS brand, i.i_manufact_id, i.i_manufact, SUM(ss.ss_ext_sales_price) AS ext_price FROM store_sales ss JOIN filtered_dates d ON ss.ss_sold_date_sk = d.d_date_sk JOIN filtered_items i ON ss.ss_item_sk = i.i_item_sk JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN store s ON ss.ss_store_sk = s.s_store_sk WHERE SUBSTRING(ca.ca_zip, 1, 5) <> SUBSTRING(s.s_zip, 1, 5) GROUP BY i.i_brand, i.i_brand_id, i.i_manufact_id, i.i_manufact ORDER BY ext_price DESC, i.i_brand, i.i_brand_id, i.i_manufact_id, i.i_manufact LIMIT 100"
      },
      "invariants_kept": [
        "output columns unchanged",
        "aggregation grain preserved",
        "all join predicates maintained",
        "filter conditions preserved",
        "same result set and ordering"
      ],
      "expected_speedup": "3.8x",
      "risk": "low"
    }
  ],
  "explanation": "Applied early_filter to pre-filter dimension tables date_dim (d_year=1999, d_moy=12) and item (i_manager_id=2) before joining with the large store_sales fact table. This reduces the join cardinality significantly by filtering the dimension tables first, then only joining matching rows to store_sales. The zip code inequality predicate is preserved in the WHERE clause."
}
```