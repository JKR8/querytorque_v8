Looking at this query, I can see a key optimization opportunity based on the provided patterns. The query uses CTEs that compute aggregates for both 1999 and 2000, but the main query only uses specific year pairs (1999 vs 2000). This is similar to the UNION_CTE_SPLIT pattern where we can specialize CTEs for specific years.

**Key Insight:** The `year_total_store` and `year_total` CTEs compute aggregates for both 1999 and 2000, but the main query always joins 1999 with 2000 data. We can create specialized CTEs for each year, pushing year filters into the aggregation. This reduces the amount of data aggregated and eliminates the need to filter after aggregation.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "pushdown",
      "nodes": {
        "year_1999_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999",
        "year_2000_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 2000",
        "store_sales_1999": "SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, 1999 AS year, STDDEV_SAMP(ss_net_paid) AS year_total FROM customer, store_sales, year_1999_dates WHERE c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk GROUP BY c_customer_id, c_first_name, c_last_name",
        "store_sales_2000": "SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, 2000 AS year, STDDEV_SAMP(ss_net_paid) AS year_total FROM customer, store_sales, year_2000_dates WHERE c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk GROUP BY c_customer_id, c_first_name, c_last_name",
        "web_sales_1999": "SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, 1999 AS year, STDDEV_SAMP(ws_net_paid) AS year_total FROM customer, web_sales, year_1999_dates WHERE c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk GROUP BY c_customer_id, c_first_name, c_last_name",
        "web_sales_2000": "SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, 2000 AS year, STDDEV_SAMP(ws_net_paid) AS year_total FROM customer, web_sales, year_2000_dates WHERE c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk GROUP BY c_customer_id, c_first_name, c_last_name",
        "main_query": "SELECT t_s_secyear.customer_id, t_s_secyear.customer_first_name, t_s_secyear.customer_last_name FROM store_sales_1999 AS t_s_firstyear, store_sales_2000 AS t_s_secyear, web_sales_1999 AS t_w_firstyear, web_sales_2000 AS t_w_secyear WHERE t_s_secyear.customer_id = t_s_firstyear.customer_id AND t_s_firstyear.customer_id = t_w_secyear.customer_id AND t_s_firstyear.customer_id = t_w_firstyear.customer_id AND t_s_firstyear.year_total > 0 AND t_w_firstyear.year_total > 0 AND CASE WHEN t_w_firstyear.year_total > 0 THEN t_w_secyear.year_total / t_w_firstyear.year_total ELSE NULL END > CASE WHEN t_s_firstyear.year_total > 0 THEN t_s_secyear.year_total / t_s_firstyear.year_total ELSE NULL END ORDER BY 2, 1, 3 LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same aggregation semantics"
      ],
      "expected_speedup": "1.5x",
      "risk": "low"
    }
  ],
  "explanation": "Pushed year filters into specialized CTEs before aggregation. Created separate CTEs for store and web sales in 1999 and 2000. This eliminates the IN clause in the original CTEs and reduces the data aggregated by 50% (only aggregating one year at a time). The main query then joins these pre-filtered, pre-aggregated results, which should be faster because each CTE processes less data."
}
```