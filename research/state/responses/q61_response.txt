Looking at this query, I see two main issues: 1) two nearly identical subqueries scanning the same tables, and 2) an OR condition on promotion channels. Based on the patterns provided and constraints, I'll use a dimension CTE isolation approach combined with conditional aggregation to avoid redundant table scans.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "dimension_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy = 11",
        "filtered_stores": "SELECT s_store_sk FROM store WHERE s_gmt_offset = -7",
        "filtered_addresses": "SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -7",
        "filtered_items": "SELECT i_item_sk FROM item WHERE i_category = 'Jewelry'",
        "filtered_customers": "SELECT c_customer_sk, c_current_addr_sk FROM customer",
        "promotional_condition": "SELECT p_promo_sk FROM promotion WHERE p_channel_dmail = 'Y' OR p_channel_email = 'Y' OR p_channel_tv = 'Y'",
        "main_query": "SELECT promotions, total, CAST(promotions AS DECIMAL(15, 4)) / CAST(total AS DECIMAL(15, 4)) * 100 FROM (SELECT SUM(CASE WHEN pc.p_promo_sk IS NOT NULL THEN ss.ss_ext_sales_price ELSE 0 END) AS promotions, SUM(ss.ss_ext_sales_price) AS total FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN filtered_stores fs ON ss.ss_store_sk = fs.s_store_sk JOIN filtered_customers c ON ss.ss_customer_sk = c.c_customer_sk JOIN filtered_addresses ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN filtered_items i ON ss.ss_item_sk = i.i_item_sk LEFT JOIN promotional_condition pc ON ss.ss_promo_sk = pc.p_promo_sk) AS combined_sales ORDER BY promotions, total LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same calculation logic"
      ],
      "expected_speedup": "2.5x",
      "risk": "low"
    }
  ],
  "explanation": "Replaced two nearly identical subqueries with a single scan using conditional aggregation. Created CTEs for all dimension tables with their respective filters to reduce join cardinality early. Used LEFT JOIN with promotion CTE and CASE statement to compute both promotional and total sales in one pass over store_sales."
}
```