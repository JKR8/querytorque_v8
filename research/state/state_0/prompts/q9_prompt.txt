## Example: Single Pass Aggregation (SINGLE_PASS_AGGREGATION)
Verified speedup: 4.47x

### Input:
[main_query]:
SELECT
  CASE WHEN (SELECT count(*) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20) > 74129
       THEN (SELECT avg(ss_ext_discount_amt) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20)
       ELSE (SELECT avg(ss_net_paid) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20) END AS bucket1,
  CASE WHEN (SELECT count(*) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40) > 122840
       THEN (SELECT avg(ss_ext_discount_amt) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40)
       ELSE (SELECT avg(ss_net_paid) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40) END AS bucket2,
  -- ... 3 more buckets, 15 total scans of store_sales

### Output:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "single_pass_aggregation",
      "nodes": {
        "store_sales_aggregates": "SELECT SUM(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 ELSE 0 END) AS cnt1, AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_ext_discount_amt END) AS avg_disc1, AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_net_paid END) AS avg_paid1, SUM(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN 1 ELSE 0 END) AS cnt2, AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_ext_discount_amt END) AS avg_disc2, AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_net_paid END) AS avg_paid2, SUM(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN 1 ELSE 0 END) AS cnt3, AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_ext_discount_amt END) AS avg_disc3, AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_net_paid END) AS avg_paid3, SUM(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN 1 ELSE 0 END) AS cnt4, AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_ext_discount_amt END) AS avg_disc4, AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_net_paid END) AS avg_paid4, SUM(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN 1 ELSE 0 END) AS cnt5, AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_ext_discount_amt END) AS avg_disc5, AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_net_paid END) AS avg_paid5 FROM store_sales",
        "main_query": "SELECT CASE WHEN cnt1 > 74129 THEN avg_disc1 ELSE avg_paid1 END AS bucket1, CASE WHEN cnt2 > 122840 THEN avg_disc2 ELSE avg_paid2 END AS bucket2, CASE WHEN cnt3 > 56580 THEN avg_disc3 ELSE avg_paid3 END AS bucket3, CASE WHEN cnt4 > 10097 THEN avg_disc4 ELSE avg_paid4 END AS bucket4, CASE WHEN cnt5 > 165306 THEN avg_disc5 ELSE avg_paid5 END AS bucket5 FROM store_sales_aggregates"
      },
      "invariants_kept": [
        "same result values",
        "same column output"
      ],
      "expected_speedup": "4.50x",
      "risk": "low"
    }
  ]
}
```

**Key insight:** Multiple scalar subqueries with different filter conditions on the same table can be consolidated into a single CTE using conditional CASE expressions inside aggregates. Reduces N scans to 1 scan.

---

## Example: Filter Pushdown (PUSHDOWN)
Verified speedup: 2.11x

### Input:
[main_query]:
SELECT CASE WHEN (SELECT COUNT(*) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20) > 2972190 
  THEN (SELECT AVG(ss_ext_sales_price) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20)
  ELSE (SELECT AVG(ss_net_profit) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20) END AS bucket1,
  CASE WHEN (SELECT COUNT(*) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40) > 4505785
  THEN (SELECT AVG(ss_ext_sales_price) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40)
  ELSE (SELECT AVG(ss_net_profit) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40) END AS bucket2
FROM reason WHERE r_reason_sk = 1

### Output:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "pushdown",
      "nodes": {
        "quantity_1_20_stats": "SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20",
        "quantity_21_40_stats": "SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40",
        "quantity_41_60_stats": "SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 41 AND 60",
        "quantity_61_80_stats": "SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 61 AND 80",
        "quantity_81_100_stats": "SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 81 AND 100",
        "main_query": "SELECT CASE WHEN q1.cnt > 2972190 THEN q1.avg_ext_price ELSE q1.avg_net_profit END AS bucket1, CASE WHEN q2.cnt > 4505785 THEN q2.avg_ext_price ELSE q2.avg_net_profit END AS bucket2, CASE WHEN q3.cnt > 1575726 THEN q3.avg_ext_price ELSE q3.avg_net_profit END AS bucket3, CASE WHEN q4.cnt > 3188917 THEN q4.avg_ext_price ELSE q4.avg_net_profit END AS bucket4, CASE WHEN q5.cnt > 3525216 THEN q5.avg_ext_price ELSE q5.avg_net_profit END AS bucket5 FROM reason CROSS JOIN quantity_1_20_stats AS q1 CROSS JOIN quantity_21_40_stats AS q2 CROSS JOIN quantity_41_60_stats AS q3 CROSS JOIN quantity_61_80_stats AS q4 CROSS JOIN quantity_81_100_stats AS q5 WHERE r_reason_sk = 1"
      },
      "invariants_kept": [
        "same result rows",
        "same aggregation results",
        "same output columns"
      ],
      "expected_speedup": "2.11x",
      "risk": "low"
    }
  ]
}
```

**Key insight:** Extract repeated quantity-range subqueries into CTEs. Each CTE computes count, avg_ext_price, avg_net_profit in ONE pass instead of scanning store_sales 15+ times.

---

## CONSTRAINTS (Learned from Benchmark Failures)

The following constraints are MANDATORY based on observed failures:

### LITERAL_PRESERVATION [CRITICAL]
CRITICAL: When rewriting SQL, you MUST copy ALL literal values (strings, numbers, dates) EXACTLY from the original query. Do NOT invent, substitute, or 'improve' any filter values. If the original says d_year = 2000, your rewrite MUST say d_year = 2000. If the original says ca_state = 'GA', your rewrite MUST say ca_state = 'GA'. Changing these values will produce WRONG RESULTS and the rewrite will be REJECTED.

### OR_TO_UNION_LIMIT [HIGH]
CAUTION with OR→UNION: Only split OR conditions into UNION ALL when there are ≤3 simple branches AND they have different access patterns. If you have nested ORs (e.g., 3 conditions × 3 values = 9 combinations), DO NOT expand them - keep the original OR structure. DuckDB handles OR predicates efficiently. Over-splitting causes multiple scans of fact tables and severe regressions (0.23x-0.41x observed). When in doubt, preserve the original OR structure.


---

You are an autonomous Query Rewrite Engine. Your goal is to maximize execution speed while strictly preserving semantic invariants.

Output atomic rewrite sets in JSON.

RULES:
- Primary Goal: Maximize execution speed while strictly preserving semantic invariants.
- Allowed Transforms: Use the provided list. If a standard SQL optimization applies that is not listed, label it "semantic_rewrite".
- Atomic Sets: Group dependent changes (e.g., creating a CTE and joining it) into a single rewrite_set.
- Contracts: Output columns, grain, and total result rows must remain invariant.
- Naming: Use descriptive CTE names (e.g., `filtered_returns` vs `cte1`).
- Column Aliasing: Permitted only for aggregations or disambiguation.

ALLOWED TRANSFORMS: pushdown, decorrelate, or_to_union, early_filter, date_cte_isolate, materialize_cte, flatten_subquery, reorder_join, multi_push_predicate, inline_cte, remove_redundant, semantic_rewrite

OUTPUT FORMAT:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "transform_name",
      "nodes": {
        "node_id": "new SQL..."
      },
      "invariants_kept": ["list of preserved semantics"],
      "expected_speedup": "2x",
      "risk": "low"
    }
  ],
  "explanation": "what was changed and why"
}
```

## Target Nodes
  [main_query] GROUP_BY
  [quantity_aggregations] GROUP_BY

## Subgraph Slice
[main_query] type=main
```sql
SELECT CASE WHEN (SELECT cnt FROM quantity_aggregations WHERE bucket = 1) > 74129 THEN (SELECT avg_disc FROM quantity_aggregations WHERE bucket = 1) ELSE (SELECT avg_net FROM quantity_aggregations WHERE bucket = 1) END AS bucket1, CASE WHEN (SELECT cnt FROM quantity_aggregations WHERE bucket = 2) > 122840 THEN (SELECT avg_disc FROM quantity_aggregations WHERE bucket = 2) ELSE (SELECT avg_net FROM quantity_aggregations WHERE bucket = 2) END AS bucket2, CASE WHEN (SELECT cnt FROM quantity_aggregations WHERE bucket = 3) > 56580 THEN (SELECT avg_disc FROM quantity_aggregations WHERE bucket = 3) ELSE (SELECT avg_net FROM quantity_aggregations WHERE bucket = 3) END AS bucket3, CASE WHEN (SELECT cnt FROM quantity_aggregations WHERE bucket = 4) > 10097 THEN (SELECT avg_disc FROM quantity_aggregations WHERE bucket = 4) ELSE (SELECT avg_net FROM quantity_aggregations WHERE bucket = 4) END AS bucket4, CASE WHEN (SELECT cnt FROM quantity_aggregations WHERE bucket = 5) > 165306 THEN (SELECT avg_disc FROM quantity_aggregations WHERE bucket = 5) ELSE (SELECT avg_net FROM quantity_aggregations WHERE bucket = 5) END AS bucket5 FROM reason WHERE r_reason_sk = 1
```

[quantity_aggregations] type=cte
```sql
SELECT CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 WHEN ss_quantity BETWEEN 21 AND 40 THEN 2 WHEN ss_quantity BETWEEN 41 AND 60 THEN 3 WHEN ss_quantity BETWEEN 61 AND 80 THEN 4 WHEN ss_quantity BETWEEN 81 AND 100 THEN 5 END AS bucket, COUNT(*) AS cnt, AVG(ss_ext_discount_amt) AS avg_disc, AVG(ss_net_paid) AS avg_net FROM store_sales WHERE ss_quantity BETWEEN 1 AND 100 GROUP BY CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 WHEN ss_quantity BETWEEN 21 AND 40 THEN 2 WHEN ss_quantity BETWEEN 41 AND 60 THEN 3 WHEN ss_quantity BETWEEN 61 AND 80 THEN 4 WHEN ss_quantity BETWEEN 81 AND 100 THEN 5 END
```


## Node Contracts
[main_query]:
  output_columns: ['bucket1', 'bucket2', 'bucket3', 'bucket4', 'bucket5']
  required_predicates: ['r_reason_sk = 1']
[quantity_aggregations]:
  output_columns: ['bucket', 'cnt', 'avg_disc', 'avg_net']
  grain: ['CASE WHEN ss_quantity BETWEEN ']

## Downstream Usage
[quantity_aggregations]: downstream_refs=['cnt', 'avg_disc', 'bucket', 'avg_net']

## Cost Attribution
[main_query]: 71.1% cost, ~5 rows, ops=[SEQ_SCAN[CTE_SCAN], SEQ_SCAN[CTE_SCAN], SEQ_SCAN[CTE_SCAN]]
[quantity_aggregations]: 28.9% cost, ~27504809 rows, ops=[SEQ_SCAN[store_sales], HASH_GROUP_BY]

## Detected Opportunities
## Node-Specific Opportunities
PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

PUSHDOWN: [main_query] filters on [quantity_aggregations] after GROUP BY
  Fix: Push filter into CTE before aggregation
  Expected: 2x speedup (verified Q93: 2.71x)

Now output your rewrite_sets:

## Execution Plan
```
Operators by cost:
- FILTER: 64.0% cost, 27,504,809 rows
- SEQ_SCAN(store_sales): 22.6% cost, 27,504,809 rows
- PROJECTION: 7.1% cost, 27,504,809 rows
- HASH_GROUP_BY: 6.3% cost, 5 rows
- CTE: 0.0% cost, 0 rows

Scans:
- store_sales x1: 345,611,892 → 27,504,809 rows (filtered)
- reason x1: 45 → 1 rows (filtered)
- CTE_SCAN x15: 5 rows (no filter)

Misestimates:
- HASH_GROUP_BY: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 1,152,039 vs actual 27,504,809 (23.9x)
- FILTER: est 1,152,039 vs actual 27,504,809 (23.9x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- PROJECTION: est 576,019 vs actual 1 (576019.0x)
- FILTER: est 576,019 vs actual 1 (576019.0x)
- CTE_SCAN: est 576,019 vs actual 5 (115203.8x)
```


## Previous Attempts

- baseline: 1.00x [none] NEUTRAL
- kimi: 0.42x [none] REGRESSION
- retry3w_2: 4.47x [none] WIN

**IMPORTANT:** The following patterns were provided: single_pass_aggregation, pushdown. Consider a DIFFERENT approach!
