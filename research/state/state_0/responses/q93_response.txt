Looking at this query pattern, I can see it's already been optimized with an early filter approach. However, I notice an opportunity to apply the **prefetch_fact_join** pattern in a different way. Currently, we're filtering `store_returns` by joining with `filtered_reason`, but we could pre-join `store_sales` with the filtered store returns to create a smaller intermediate fact table before aggregation.

Here's my approach: create a CTE that pre-joins `store_sales` with the already-filtered returns (which includes the reason filter), then perform the aggregation on this smaller dataset.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "prefetch_fact_join",
      "nodes": {
        "filtered_reason": "SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'",
        "sales_with_filtered_returns": "SELECT ss.ss_customer_sk, ss.ss_item_sk, ss.ss_ticket_number, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales AS ss LEFT JOIN (SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk) AS sr ON (sr.sr_item_sk = ss.ss_item_sk AND sr.sr_ticket_number = ss.ss_ticket_number)",
        "main_query": "SELECT ss_customer_sk, SUM(CASE WHEN sr_return_quantity IS NOT NULL THEN (ss_quantity - sr_return_quantity) * ss_sales_price ELSE ss_quantity * ss_sales_price END) AS sumsales FROM sales_with_filtered_returns GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100"
      },
      "invariants_kept": [
        "output columns unchanged",
        "grain preserved",
        "same result rows",
        "LEFT JOIN semantics preserved"
      ],
      "expected_speedup": "2.5x",
      "risk": "low"
    }
  ],
  "explanation": "Created a CTE that pre-joins store_sales with the already-filtered returns (via reason). This creates a smaller intermediate result (store_sales with only relevant return information) before performing the expensive CASE expression and aggregation. The optimizer can now work with a smaller dataset that has already incorporated the reason filter, reducing the amount of data processed during the grouping phase."
}
```

**Key insight**: The original approach filters returns by reason first, then joins with store_sales. This rewrite pre-joins store_sales with those filtered returns upfront, creating a smaller fact-like structure. This allows the expensive CASE expression and SUM aggregation to operate on a pre-filtered dataset, potentially reducing the amount of data that needs to be processed during grouping.

**Why this differs from the original early_filter**: The original early_filter creates filtered_returns first, then joins with store_sales in the main query. This approach creates a single CTE that combines store_sales with the filtered returns upfront, which can be more efficient for the optimizer to work with as a unified dataset before aggregation.