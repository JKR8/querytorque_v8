{
  "query": 1,
  "api": "kimi",
  "model": "kimi-k2.5",
  "sample_speedup": 1.20,
  "full_db_speedup": 2.44,
  "correct": true,
  "operations": [
    {
      "op": "replace_cte",
      "name": "customer_total_return",
      "sql": "select sr_customer_sk as ctr_customer_sk, sr_store_sk as ctr_store_sk, sum(SR_FEE) as ctr_total_return, avg(sum(SR_FEE)) over (partition by sr_store_sk) as ctr_avg_return from store_returns, date_dim, store where sr_returned_date_sk = d_date_sk and sr_store_sk = s_store_sk and d_year = 2000 and s_state = 'SD' group by sr_customer_sk, sr_store_sk"
    },
    {
      "op": "replace_clause",
      "target": "main_query.from",
      "sql": "customer_total_return ctr1, customer"
    },
    {
      "op": "replace_clause",
      "target": "main_query.where",
      "sql": "ctr1.ctr_total_return > ctr1.ctr_avg_return * 1.2 and ctr1.ctr_customer_sk = c_customer_sk"
    }
  ],
  "semantic_warnings": [],
  "explanation": "Applied two high-impact optimizations: 1) Predicate pushdown: Moved the store join and s_state='SD' filter into the CTE, reducing aggregation input from scanning all 56K store_returns to only those in SD. 2) Correlated subquery to window function: Replaced the expensive correlated subquery (which executed per-row) with a window function AVG() OVER (PARTITION BY store) in the CTE. This eliminates the self-join of customer_total_return and transforms an O(nÂ²) operation into O(n), computing all store averages in a single pass."
}
