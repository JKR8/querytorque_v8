# OPTIMIZATION PROMPT: DISCOVER NEW PATTERNS (Forbidden Known Patterns)

## Your Task
Optimize the following TPC-DS query for maximum execution speed on DuckDB.
**CRITICAL**: You MUST NOT use any of the patterns listed below. Your goal is to discover and apply completely NEW optimization techniques that we haven't seen yet.

## FORBIDDEN PATTERNS (Do Not Use)
You are explicitly forbidden from applying these patterns. We have already discovered and codified them:

1. **date_cte_isolate** - Pre-filtering date_dim into a CTE before joining
   - Example: WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE ...) SELECT ... FROM fact JOIN filtered_dates ...
   
2. **dimension_cte_isolate** - Pre-filtering dimension tables into CTEs
   - Example: WITH filtered_items AS (SELECT i_item_sk FROM item WHERE ...) SELECT ... FROM fact JOIN filtered_items ...

3. **multi_dimension_prefetch** - Pre-filtering multiple dimensions before join
   - Example: WITH d1 AS (...), d2 AS (...) SELECT ... JOIN d1 ... JOIN d2 ...

4. **early_filter** - Pushing filter predicates into CTEs early
   - Example: WITH filtered AS (SELECT ... WHERE condition) SELECT ... FROM filtered WHERE more_conditions ...

5. **decorrelate** - Converting correlated subqueries to JOINs
   - Example: SELECT (SELECT COUNT(*) FROM t2 WHERE t2.id = t1.id) FROM t1 → JOIN instead

6. **pushdown** - Pushing filters down to base tables
   - Example: WHERE applied at table level instead of after joins

7. **or_to_union** - Converting OR conditions to UNION ALL
   - Example: WHERE a=1 OR a=2 → UNION ALL of a=1 UNION ALL a=2

8. **materialize_cte** - Forcing CTE materialization
   - Example: WITH MATERIALIZED cte AS (SELECT ...) SELECT ...

9. **intersect_to_exists** - Converting INTERSECT to EXISTS
   - Example: WHERE x IN (SELECT ...) → WHERE EXISTS (SELECT 1 FROM ...)

10. **union_cte_split** - Splitting UNION queries into separate CTEs
    - Example: (SELECT ... FROM t1) UNION (SELECT ... FROM t2) → CTE t1_result, CTE t2_result, then UNION

11. **single_pass_aggregation** - Consolidating repeated scans into CASE aggregates
    - Example: Multiple COUNT(CASE WHEN ...) instead of separate subqueries

12. **time_bucket_aggregation** - Using time-based bucketing for aggregation
    - Example: CASE WHEN hour = 8 THEN ... WHEN hour = 9 THEN ... in single scan

13. **multi_cte_chain** - Progressive filtering through 3+ CTEs
    - Example: filtered_dates → filtered_dates_items → filtered_with_warehouse (each narrows data)

14. **triple_dimension_isolate** - Pre-filtering 3 different dimensions separately
    - Example: 3 separate CTEs for date_dim, item, and store

15. **dual_dimension_isolate** - Pre-filtering exactly 2 dimensions
    - Example: WITH d_dates AS (...), d_items AS (...) SELECT ...

16. **channel_split_union** - Separating by sales channel with separate CTEs
    - Example: ss_cte (store_sales), cs_cte (catalog_sales), ws_cte (web_sales) then UNION

17. **prefetch_fact_join** - Pre-joining filtered dates with fact table
    - Example: Pre-compute fact_sales_with_dates before dimension joins

## What We're Looking For Instead

Think creatively about:
- **Aggregation strategies**: Different grouping levels, partial aggregations, materialization points
- **Join ordering**: Non-obvious join sequences that reduce intermediate result sizes
- **Subquery placement**: Moving subqueries to different locations in the query tree
- **Window function optimization**: Using windows differently (ROWS vs RANGE, partition changes)
- **Set operations**: Novel uses of INTERSECT, EXCEPT, CROSS JOIN, or combinations
- **Conditional logic**: Complex CASE statements, boolean folding, predicate optimization
- **Data flow**: Reverse scans, bottom-up aggregation, materialization at different stages
- **Temp table strategies**: Which intermediate results should be materialized vs computed inline
- **Hybrid approaches**: Combinations of techniques that complement each other (not just one pattern)

## Output Format

When you provide the optimized SQL, ALSO provide:

```
[OPTIMIZATION ANALYSIS]
NEW PATTERN: [Give a name to what you did, e.g., "reverse_aggregation_prefilter"]
DESCRIPTION: [Explain the optimization technique in 2-3 sentences]
WHY IT WORKS: [Explain the mechanism - why is this faster?]
PATTERN FAMILY: [What category does this belong to?]
EXAMPLE STRUCTURE: [Show the general structure of this approach]
```

Example of what a NEW pattern analysis might look like:
```
[OPTIMIZATION ANALYSIS]
NEW PATTERN: aggregate_before_join
DESCRIPTION: Aggregate at the source table level before any joins, reducing intermediate result size dramatically.
WHY IT WORKS: Smaller intermediate tables mean faster joins and lower memory usage in the join hash table.
PATTERN FAMILY: Early Aggregation
EXAMPLE STRUCTURE: 
  WITH sales_by_date AS (
    SELECT ss_sold_date_sk, SUM(ss_sales_price) as daily_sales
    FROM store_sales
    GROUP BY ss_sold_date_sk
  )
  SELECT ... FROM sales_by_date JOIN date_dim ...
```

## The Query to Optimize

[QUERY_WILL_BE_INSERTED_HERE]

## Important Notes
- Do NOT fall back on known patterns. Be creative.
- If you find yourself using one of the 17 forbidden patterns, STOP and try a different approach.
- We want to discover techniques no one has codified yet.
- Explain your reasoning thoroughly so we can understand and extract the new pattern.
- The optimized query MUST be semantically identical to the original.
