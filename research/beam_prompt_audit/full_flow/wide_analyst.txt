### Step 1: BOTTLENECK HYPOTHESIS
The primary bottleneck is the nested execution of 3 correlated NOT EXISTS anti-joins (store_sales, web_sales, catalog_sales) against large fact tables, causing repeated full scans of date_dim and expensive per-row re-execution. Each anti-join materializes massive intermediate results (84K/311K rows) that spill to disk (Hash Batches:8, Memory:3264kB). The comma-join syntax prevents optimal join reordering, while late-applied dimension filters on customer_demographics (Rows Removed by Filter:1) waste cycles.

### Step 2: PROBES DESIGN
```json
{
  "hypothesis": "The bottleneck is nested execution of 3 correlated NOT EXISTS anti-joins against large fact tables, causing repeated date_dim scans and materialization of massive intermediate results that spill to disk, compounded by comma-join syntax preventing optimal join ordering.",
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "date_cte_consolidation",
      "family": "E",
      "target": "S0: Extract shared date_dim filter (d_year=2002 AND d_moy BETWEEN 10-12) into MATERIALIZED CTE date_range AS (SELECT d_date_sk FROM date_dim WHERE ...). Replace all 3 date_dim instances in subqueries with JOIN date_range ON [fact_table].sold_date_sk = date_range.d_date_sk",
      "confidence": 0.95,
      "recommended_examples": ["pg_date_consolidation"]
    },
    {
      "probe_id": "p02",
      "transform_id": "decorrelate_store_sales",
      "family": "B",
      "target": "S0: Convert EXISTS(store_sales/date_dim) to MATERIALIZED CTE store_custs AS (SELECT DISTINCT ss_customer_sk FROM store_sales JOIN date_range ON ... WHERE ss_list_price BETWEEN 80-169). Replace EXISTS with JOIN store_custs ON c.c_customer_sk = store_custs.ss_customer_sk",
      "confidence": 0.90,
      "recommended_examples": ["early_filter_decorrelate"]
    },
    {
      "probe_id": "p03",
      "transform_id": "decorrelate_web_sales",
      "family": "B",
      "target": "S0: Convert NOT EXISTS(web_sales) to MATERIALIZED CTE web_custs AS (SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN date_range ON ... WHERE ws_list_price BETWEEN 80-169). Replace NOT EXISTS with LEFT JOIN web_custs ... WHERE web_custs.ws_bill_customer_sk IS NULL",
      "confidence": 0.90,
      "recommended_examples": ["set_operation_materialization"]
    },
    {
      "probe_id": "p04",
      "transform_id": "decorrelate_catalog_sales",
      "family": "B",
      "target": "S0: Convert NOT EXISTS(catalog_sales) to MATERIALIZED CTE catalog_custs AS (SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales JOIN date_range ON ... WHERE cs_list_price BETWEEN 80-169). Replace NOT EXISTS with LEFT JOIN catalog_custs ... WHERE catalog_custs.cs_ship_customer_sk IS NULL",
      "confidence": 0.90,
      "recommended_examples": ["set_operation_materialization"]
    },
    {
      "probe_id": "p05",
      "transform_id": "explicit_join_syntax",
      "family": "F",
      "target": "S0: Replace comma-joins with explicit INNER JOINs: FROM customer c INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk INNER JOIN customer_demographics cd ON cd_demo_sk = c.c_current_cdemo_sk",
      "confidence": 0.85,
      "recommended_examples": ["pg_date_cte_explicit_join"]
    },
    {
      "probe_id": "p06",
      "transform_id": "prefilter_ca_state",
      "family": "A",
      "target": "S0: Materialize filtered customer_address into CTE ca_filtered AS (SELECT * FROM customer_address WHERE ca_state IN ('CO','NC','TX')). Replace original scan with JOIN ca_filtered",
      "confidence": 0.80,
      "recommended_examples": []
    },
    {
      "probe_id": "p07",
      "transform_id": "prefilter_cd_demographics",
      "family": "A",
      "target": "S0: Materialize filtered customer_demographics into CTE cd_filtered AS (SELECT * FROM customer_demographics WHERE cd_marital_status IN ('S','M','U') AND cd_education_status IN ('Primary','College')). Replace original scan with JOIN cd_filtered",
      "confidence": 0.80,
      "recommended_examples": []
    },
    {
      "probe_id": "p08",
      "transform_id": "work_mem_tune",
      "family": "Config",
      "target": "Apply config patch: SET LOCAL work_mem = '256MB' to prevent hash spill (observed Hash Batches:8 in EXPLAIN)",
      "confidence": 0.75,
      "recommended_examples": []
    },
    {
      "probe_id": "p09",
      "transform_id": "disable_mergejoin",
      "family": "Config",
      "target": "Apply config patch: /*+ Set(enable_mergejoin off) */ to force hash joins for large intermediate sets",
      "confidence": 0.70,
      "recommended_examples": []
    },
    {
      "probe_id": "p10",
      "transform_id": "agg_pushdown_cd",
      "family": "C",
      "target": "S0: Push GROUP BY into customer_demographics CTE: cd_filtered AS (SELECT cd_gender,cd_marital_status,..., COUNT(*) as agg FROM ... GROUP BY cd_gender,...) then join pre-aggregated results",
      "confidence": 0.65,
      "recommended_examples": []
    },
    {
      "probe_id": "p11",
      "transform_id": "parallel_workers",
      "family": "Config",
      "target": "Apply config patch: SET LOCAL max_parallel_workers_per_gather = 4 for large fact table scans",
      "confidence": 0.60,
      "recommended_examples": []
    }
  ],
  "dropped": [
    {
      "transform_id": "inline_decorrelate_materialized",
      "reason": "Not applicable - no scalar aggregates in subqueries"
    },
    {
      "transform_id": "pg_self_join_decomposition",
      "reason": "No self-join pattern detected in query"
    },
    {
      "transform_id": "materialized_dimension_fact_prefilter",
      "reason": "Non-equi joins not present in query"
    }
  ]
}
```