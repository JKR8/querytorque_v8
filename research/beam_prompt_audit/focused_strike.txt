## Role

You are a SQL rewrite engine for PostgreSQL v14.3. Preserve exact semantic equivalence (same rows, same columns, same ordering).

**Assignment:** Strategy: shared_scan_decorrelate | Family: B | Confidence: 95%

## Semantic Contract (MUST preserve)

- All WHERE/HAVING/ON conditions preserved exactly
- Same column names, types, ordering in output
- Same row count as original query
- All literal values unchanged (35*0.01 stays as 35*0.01, NOT 0.35)
- ORDER BY and LIMIT preserved exactly
- No new filter conditions added

## Bottleneck Diagnosis

The Nested Loop Anti joins (lines 3-4) scan 343M + 94M rows for NOT EXISTS checks. The web_sales and catalog_sales Materialize nodes re-read 83K and 332K rows per outer loop. Converting correlated subqueries into pre-materialized CTEs with semi-join eliminates the per-row re-scan overhead.

## Target Query Map

Build your rewrite following this structural blueprint. Each CTE and the main query should match this shape:

```
S0 [SELECT cd_gender, cd_marital_status, cd_education_status, ...]
  CTE: store_buyers = SELECT DISTINCT ss_customer_sk FROM store_sales JOIN date_dim ...
  CTE: web_buyers = SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN date_dim ...
  CTE: catalog_buyers = SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales JOIN date_dim ...
  MAIN: customer JOIN customer_address JOIN customer_demographics
    WHERE c_customer_sk IN store_buyers
      AND c_customer_sk NOT IN web_buyers
      AND c_customer_sk NOT IN catalog_buyers
    GROUP BY ... ORDER BY ... LIMIT 100
```

## Hazard Flags

- Do NOT simplify arithmetic (35*0.01 stays as 35*0.01)
- Do NOT convert INNER JOIN to LEFT JOIN or vice versa unless the target IR specifies it
- Keep ORDER BY + LIMIT exactly as original

## Reference Examples

Adapt these patterns to the query below. Do not copy table/column names or literal values.

### 1. pg_shared_scan_decorrelate (8043.91x (timeout rescue))
**Principle:** Shared Scan Decorrelation: when inner and outer queries scan the same fact table with the same date/cost filters, extract the common scan into a single CTE. Then compute per-item thresholds via GROUP BY in a second CTE, and JOIN back to filter. Converts O(N*M) correlated execution to O(N+M) hash joi

**BEFORE:**
```sql
select 
   sum(ws_ext_discount_amt)  as "Excess Discount Amount"
from
    web_sales
   ,item
   ,date_dim
where
(i_manufact_id BETWEEN 341 and 540
or i_category IN ('Home', 'Men', 'Music'))
and i_item_sk = ws_item_sk
and d_date between '1998-03-13' and
        cast('1998-03-13' as date) + interval '90 day'
and d_date_sk = ws_sold_date_sk
and ws_wholesale_cost BETWEEN 26 AND 46
and ws_ext_discount_amt
     > (
         SELECT
            1.3 * avg(ws_ext_discount_amt)
         FROM
            web_sales
```

**AFTER:**
```sql
WITH common_scan AS (
  SELECT ws_item_sk, ws_ext_discount_amt, ws_sales_price, ws_list_price
  FROM web_sales
  INNER JOIN date_dim ON d_date_sk = ws_sold_date_sk
  WHERE d_date BETWEEN '1998-03-13' AND CAST('1998-03-13' AS DATE) + INTERVAL '90 DAY'
    AND ws_wholesale_cost BETWEEN 26 AND 46
),
threshold_computation AS (
  SELECT ws_item_sk, 1.3 * AVG(ws_ext_discount_amt) AS threshold
  FROM common_scan
  WHERE ws_sales_price / ws_list_price BETWEEN 34 * 0.01 AND 49 * 0.01
  GROUP BY ws_item_sk
),
outer_rows AS (
  SELECT cs.ws_item_sk, cs.ws_ext_discount_amt
  FROM common_scan cs
  INNER JOIN item ON i_item_sk = cs.ws_item_sk
  WHERE i_manufact_id BETWEEN 341 AND 540
     OR i_category IN ('Home', 'Men', 'Music')
),
```


## Original SQL

```sql
select 
  cd_gender,
  cd_marital_status,
  cd_education_status,
  count(*) cnt1,
  cd_purchase_estimate,
  count(*) cnt2,
  cd_credit_rating,
  count(*) cnt3
 from
  customer c,customer_address ca,customer_demographics
 where
  c.c_current_addr_sk = ca.ca_address_sk and
  ca_state in ('CO','NC','TX') and
  cd_demo_sk = c.c_current_cdemo_sk
  and cd_marital_status in ('S', 'M', 'U')
  and cd_education_status in ('Primary', 'College') and
  exists (select *
          from store_sales,date_dim
          where c.c_customer_sk = ss_customer_sk and
                ss_sold_date_sk = d_date_sk and
                d_year = 2002 and
                d_moy between 10 and 10+2
                and ss_list_price between 80 and 169
          ) and
   (not exists (select *
            from web_sales,date_dim
            where c.c_customer_sk = ws_bill_customer_sk and
                  ws_sold_date_sk = d_date_sk and
                  d_year = 2002 and
                  d_moy between 10 and 10+2
                  and ws_list_price between 80 and 169
            ) and
    not exists (select *
            from catalog_sales,date_dim
            where c.c_customer_sk = cs_ship_customer_sk and
                  cs_sold_date_sk = d_date_sk and
                  d_year = 2002 and
                  d_moy between 10 and 10+2
                  and cs_list_price between 80 and 169)
            )
 group by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating
 order by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating
 limit 100;
```

## EXPLAIN Plan

```
Total execution time: 33245.8ms
Planning time: 1.6ms

-> Limit  (rows=80 loops=1 time=33245.8ms)
  -> Aggregate  (rows=80 loops=1 time=33245.8ms)
    -> Nested Loop Anti  (rows=964 loops=1 time=33241.7ms)
       Join Filter: (c.c_customer_sk = catalog_sales.cs_ship_customer_sk)
      -> Nested Loop Anti  (rows=1,105 loops=1 time=7671.7ms)
         Join Filter: (c.c_customer_sk = web_sales.ws_bill_customer_sk)
        -> Gather Merge  (rows=1,128 loops=1 time=604.1ms)
           Workers: 2/2 launched
          -> Sort  (rows=376 loops=3 time=592.0ms)
             Sort Method: quicksort  Space: 56kB (Memory)
            -> Nested Loop Inner  (rows=376 loops=3 time=591.3ms)
              -> Hash Join Semi  (rows=1,691 loops=3 time=573.6ms)
                 Hash Cond: (c.c_customer_sk = store_sales.ss_customer_sk)
                -> Hash Join Inner  (rows=22K loops=3 time=48.2ms)
                   Hash Cond: (c.c_current_addr_sk = ca.ca_address_sk)
                  -> Seq Scan on customer c  (rows=167K loops=3 time=15.9ms)
                  -> Hash  (rows=11K loops=3 time=14.1ms)
                    -> Seq Scan on customer_address ca  (rows=11K loops=3 time=12.7ms)
                       Filter: (ca_state = ANY ('{CO,NC,TX}'::bpchar[]))
                       Rows Removed by Filter: 72K
                -> Hash  (rows=151K loops=3 time=507.3ms)
                   Batches: 8  Memory: 3264kB
                  -> Nested Loop Inner  (rows=151K loops=3 time=217.2ms)
                    -> Index Only Scan on date_dim  (rows=31 loops=3 time=0.6ms)
                       Index Cond: ((d_year = 2002) AND (d_moy >= 10) AND (d_moy <= 12))
                    -> Index Only Scan on store_sales  (rows=4,912 loops=92 time=6.8ms)
                       Filter: ((ss_list_price >= '80'::numeric) AND (ss_list_price <= '169'::numeric))
                       Index Cond: (ss_sold_date_sk = date_dim.d_date_sk)
                       Rows Removed by Filter: 7,334
              -> Index Scan on customer_demographics  (rows=0 loops=5074 time=0.0ms)
                 Filter: ((cd_education_status = ANY ('{Primary,College}'::bpchar[])) AND (cd_marital_status = ANY ('{S,M,...
                 Index Cond: (cd_demo_sk = c.c_current_cdemo_sk)
                 Rows Removed by Filter: 1
        -> Materialize  (rows=84K loops=1128 time=3.4ms)
          -> Gather  (rows=84K loops=1 time=77.3ms)
             Workers: 2/2 launched
            -> Nested Loop Inner  (rows=28K loops=3 time=35.5ms)
              -> Index Only Scan on date_dim date_dim_1  (rows=31 loops=3 time=0.5ms)
                 Index Cond: ((d_year = 2002) AND (d_moy >= 10) AND (d_moy <= 12))
              -> Index Scan on web_sales  (rows=917 loops=92 time=1.1ms)
                 Filter: ((ws_list_price >= '80'::numeric) AND (ws_list_price <= '169'::numeric))
                 Index Cond: (ws_sold_date_sk = date_dim_1.d_date_sk)
                 Rows Removed by Filter: 1,827
      -> Materialize  (rows=311K loops=1105 time=12.5ms)
        -> Nested Loop Inner  (rows=332K loops=1 time=246.2ms)
          -> Index Scan on date_dim date_dim_2  (rows=92 loops=1 time=0.1ms)
             Index Cond: ((d_year = 2002) AND (d_moy >= 10) AND (d_moy <= 12))
          -> Index Scan on catalog_sales  (rows=3,614 loops=92 time=2.5ms)
             Filter: ((cs_list_price >= '80'::numeric) AND (cs_list_price <= '169'::numeric))
             Index Cond: (cs_sold_date_sk = date_dim_2.d_date_sk)
             Rows Removed by Filter: 7,612
```

## Output Format

Output a single rewritten SQL query. No explanation, no markdown fences around it.
The query must be complete and executable.

You have latitude to make complementary changes that support the primary transform (e.g., explicit JOIN syntax, additional CTE materialization) as long as they don't violate the semantic contract.