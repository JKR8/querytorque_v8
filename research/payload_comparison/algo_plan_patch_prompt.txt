Optimize this SQL query.

## Optimization Process

1. ANALYZE: Look at the plan summary. Find where rows are largest.
2. OPTIMIZE: For each large row source, ask "what could reduce it earlier?"
   - Can a filter be moved inside a CTE/subquery instead of applied after?
   - Can a join with a small table happen INSIDE an aggregation to filter before GROUP BY?
   - Is there a correlated subquery that runs repeatedly? Convert to a single CTE + JOIN.
3. VERIFY: The result must be semantically equivalent.

Key principle: Reduce rows as early as possible.

## Plan Summary

Top operators by cost:
- SEQ_SCAN on store_returns: 67% cost, 345M rows scanned â†’ 5.5M rows out
- HASH_GROUP_BY: 22% cost, 5.4M rows
- SEQ_SCAN on customer: 3% cost, 24M rows scanned

Table scans:
- store_returns: 345,507,384 rows (no filter pushed)
- date_dim: 73,049 rows (has filter)
- customer: 24,000,000 rows (no filter pushed)
- store: 402 rows (not in plan - joined late)

Cardinality misestimates:
- FILTER: estimated 4 vs actual 305,574 (76,393x off)
- HASH_JOIN: estimated 4 vs actual 777,703 (194,426x off)

## SQL

```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sum(SR_FEE) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year = 2000
group by sr_customer_sk
,sr_store_sk)
select c_customer_id
from customer_total_return ctr1
,store
,customer
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk)
and s_store_sk = ctr1.ctr_store_sk
and s_state = 'SD'
and ctr1.ctr_customer_sk = c_customer_sk
order by c_customer_id
LIMIT 100;
```

## Response Format

Return JSON with patches:

```json
{
  "patches": [
    {
      "search": "exact text from original SQL",
      "replace": "replacement text",
      "description": "What was fixed"
    }
  ],
  "explanation": "Brief explanation"
}
```

Rules:
- search must be EXACT text from original (including whitespace)
- each patch fixes one issue
- patches applied in order
- return valid JSON only, no markdown
