Optimize this SQL query.

## Optimization Process

1. ANALYZE: Look at the plan summary. Find where rows are largest.
2. OPTIMIZE: For each large row source, ask "what could reduce it earlier?"
3. VERIFY: The result must be semantically equivalent.

Key principle: Reduce rows as early as possible.

## Example: Predicate Pushdown

WRONG - filter after aggregation:
```sql
WITH sales_agg AS (
    SELECT store_id, SUM(amount) as total
    FROM sales
    GROUP BY store_id  -- aggregates ALL stores
),
good_stores AS (
    SELECT store_id FROM stores WHERE region = 'West'
)
SELECT * FROM sales_agg JOIN good_stores USING (store_id)  -- filters AFTER
```

RIGHT - filter inside aggregation:
```sql
WITH sales_agg AS (
    SELECT s.store_id, SUM(amount) as total
    FROM sales
    JOIN stores s ON sales.store_id = s.store_id  -- join INSIDE
    WHERE s.region = 'West'  -- filter INSIDE, before GROUP BY
    GROUP BY s.store_id  -- aggregates only West stores
)
SELECT * FROM sales_agg
```

The RIGHT version aggregates 100x fewer rows.

## Plan Summary

Top operators by cost:
- SEQ_SCAN on store_returns: 67% cost, 345M rows scanned â†’ 5.5M rows out
- HASH_GROUP_BY: 22% cost, 5.4M rows
- SEQ_SCAN on customer: 3% cost, 24M rows scanned

Table scans:
- store_returns: 345,507,384 rows (no filter pushed)
- date_dim: 73,049 rows (has filter)
- customer: 24,000,000 rows (no filter pushed)
- store: 402 rows (not in plan - joined late)

Cardinality misestimates:
- FILTER: estimated 4 vs actual 305,574 (76,393x off)
- HASH_JOIN: estimated 4 vs actual 777,703 (194,426x off)

## SQL

```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sum(SR_FEE) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year = 2000
group by sr_customer_sk
,sr_store_sk)
select c_customer_id
from customer_total_return ctr1
,store
,customer
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk)
and s_store_sk = ctr1.ctr_store_sk
and s_state = 'SD'
and ctr1.ctr_customer_sk = c_customer_sk
order by c_customer_id
LIMIT 100;
```

Return only the optimized SQL.
