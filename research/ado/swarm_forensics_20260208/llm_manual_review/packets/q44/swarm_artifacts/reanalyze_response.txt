FAILURE_ANALYSIS:
All attempts fell short because they focused on CTE restructuring without addressing the fundamental bottleneck: the store_sales table scan with ss_store_sk=146 filter. Worker 3's 1.20x gain came from eliminating duplicate scans via single-pass aggregation, but all workers missed three critical opportunities: 1) No one exploited the fact that ss_addr_sk IS NULL is a sparse filter that could use early filtering or index; 2) No one attempted to pre-filter item table to reduce join cardinality; 3) The ranking operations (two window functions over the same data) weren't optimizedâ€”computing both ranks in one pass helps but doesn't address the window function's O(n log n) sort cost for potentially thousands of items.

UNEXPLORED_OPPORTUNITIES:
1. **Multi-dimensional prefetch**: Pre-filter item table based on items that exist in store_sales with ss_store_sk=146 before joining, reducing join overhead.
2. **OR-to-UNION transformation**: The condition "avg > 0.9*subquery" could be transformed using UNION ALL with early exit logic, though DuckDB may optimize this internally.
3. **Deferred window aggregation**: Compute ranks only after filtering to top/bottom items, not on all qualifying items.
4. **Date/range optimization**: Though not present in this query, similar patterns could benefit from range-based filtering missing here.
5. **Physical optimization hints**: None attempted to influence join order or use of indexes via DuckDB-specific pragmas.

REFINED_STRATEGY:
Combine single-pass aggregation with early dimension filtering and window optimization. First, create a filtered fact CTE for store 146 only once. Second, pre-filter item table to items present in this filtered fact CTE. Third, compute store average via conditional aggregation within the same scan. Fourth, compute item averages and filter using HAVING, but immediately compute ranks and filter to top 10 ascending and descending in separate branches using LIMIT, avoiding full window computation over all qualifying items. Finally, join with pre-filtered item CTEs.

EXAMPLES: single_pass_aggregation, dimension_cte_isolate, deferred_window_aggregation
HINT: Use a single CTE to filter store_sales for store 146. Compute store average with conditional aggregation for ss_addr_sk IS NULL. Compute item averages, filter with HAVING, then in separate CTEs use ORDER BY with LIMIT 10 to get top/bottom items without full window ranking. Join results on row numbers generated via ROW_NUMBER() over ordered sets, which avoids full RANK computation on all items. Pre-filter item table based on items in the filtered store_sales.