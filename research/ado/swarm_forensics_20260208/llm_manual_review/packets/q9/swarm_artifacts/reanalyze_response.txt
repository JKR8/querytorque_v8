FAILURE_ANALYSIS:
All attempts fell short because they failed to address the fundamental bottleneck: DuckDB's columnar execution engine struggles with computing 15 different conditional aggregates (5 counts + 10 averages) in a single scan when they involve overlapping CASE conditions. The original query's independent subqueries allow DuckDB to apply specialized optimizations for each quantity range (potentially using zonemaps/min-max filtering), while the consolidated approaches force evaluation of all conditions for every row. Materialized CTEs added overhead without benefit since store_sales scans dominate. The attempts also missed that r_reason_sk=1 returns exactly one row, making cross-joins wasteful.

UNEXPLORED_OPPORTUNITIES:
1. **Partitioned aggregation**: Compute aggregates per quantity range separately but push all filters to storage layer, leveraging DuckDB's ability to parallelize independent aggregations.
2. **Partial materialization**: Use UNION ALL to compute counts and averages separately, then combine results mathematically (sum/count) instead of full averages.
3. **Vectorized filtering**: Pre-filter store_sales into disjoint ranges using WHERE clauses, not CASE, enabling better predicate pushdown.
4. **Window function avoidance**: All attempts used aggregation; none tried transforming to window functions with QUALIFY.
5. **Approximate counting**: None explored using approx_count() for threshold checks when exact counts aren't needed for averages.

REFINED_STRATEGY:
Compute counts and sums (not averages) in five independent but parallelized subqueries using UNION ALL, then calculate final averages only for selected columns after threshold checks. This minimizes per-row computation while allowing DuckDB to optimize each range independently. Pre-filter reason to a single row using WITH, then join with aggregated results via lateral joins for optimal pipelining.

EXAMPLES: single_pass_aggregation, early_filter, union_cte_split
HINT: Create five separate CTEs for each quantity range computing COUNT, SUM(ss_ext_sales_price), SUM(ss_net_profit), and respective non-null counts. Use UNION ALL to combine, then in main query compute conditional averages using SUM/CASE based on count thresholds. Add PRAGMA enable_verification=false to allow parallel execution.