```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "decorrelate",
      "nodes": {
        "main_query": "WITH date_filter AS (\n    SELECT d_date_sk\n    FROM date_dim\n    WHERE d_date BETWEEN '1999-03-07' AND CAST('1999-03-07' AS DATE) + INTERVAL '90' DAY\n),\nfiltered_items AS (\n    SELECT i_item_sk\n    FROM item\n    WHERE (i_manufact_id IN (1, 78, 97, 516, 521) OR i_manager_id BETWEEN 25 AND 54)\n),\nitem_avg_discount AS (\n    SELECT \n        cs_item_sk,\n        1.3 * AVG(cs_ext_discount_amt) AS avg_disc\n    FROM catalog_sales\n    JOIN date_filter ON cs_sold_date_sk = d_date_sk\n    WHERE cs_list_price BETWEEN 16 AND 45\n      AND cs_sales_price / cs_list_price BETWEEN 63 * 0.01 AND 83 * 0.01\n    GROUP BY cs_item_sk\n)\nSELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\"\nFROM catalog_sales cs\nJOIN filtered_items i ON cs.cs_item_sk = i.i_item_sk\nJOIN date_filter d ON cs.cs_sold_date_sk = d.d_date_sk\nLEFT JOIN item_avg_discount avg ON cs.cs_item_sk = avg.cs_item_sk\nWHERE cs_ext_discount_amt > COALESCE(avg.avg_disc, 0)\nORDER BY SUM(cs_ext_discount_amt)\nLIMIT 100"
      },
      "invariants_kept": [
        "Output columns: 'excess discount amount'",
        "Result grain: single aggregated value with LIMIT 100",
        "Same item filters: i_manufact_id IN (1, 78, 97, 516, 521) OR i_manager_id BETWEEN 25 AND 54",
        "Same date range: '1999-03-07' to '1999-03-07' + 90 days",
        "Same correlation condition: cs_ext_discount_amt > 1.3*average for same item with price constraints"
      ],
      "expected_speedup": "3x",
      "risk": "medium"
    }
  ],
  "explanation": "1) DECORRELATE: The correlated subquery computing average discount per item with specific price constraints was transformed into a CTE (item_avg_discount) that computes these averages once for all items, then joined back. This eliminates repeated subquery execution per outer row. 2) EARLY_FILTER: Created date_filter CTE to isolate date dimension filtering and reuse across main query and average computation. 3) PUSHDOWN: Item filtering moved to filtered_items CTE to apply early. 4) Note: The OR condition on item table is preserved as-is (not split to UNION) due to OR_TO_UNION_LIMIT constraint - nested OR with 5 IN values + BETWEEN creates complex combinations. 5) Used COALESCE to handle items without matching average (treat as 0) maintaining same semantics as original correlated subquery."
}
```