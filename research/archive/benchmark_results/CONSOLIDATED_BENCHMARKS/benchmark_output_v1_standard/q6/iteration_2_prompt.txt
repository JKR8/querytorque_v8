## Example: Date CTE Isolation (DATE_CTE_ISOLATE)
Verified speedup: 1.5-2.5x

### Input:
[main_query]:
SELECT a.ca_state state, count(*) cnt
FROM customer_address a, customer c, store_sales s, date_dim d, item i
WHERE a.ca_address_sk = c.c_current_addr_sk
  AND c.c_customer_sk = s.ss_customer_sk
  AND s.ss_sold_date_sk = d.d_date_sk
  AND s.ss_item_sk = i.i_item_sk
  AND d.d_month_seq = (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2000 AND d_moy = 1)
  AND i.i_current_price > 1.2 * (SELECT avg(j.i_current_price) FROM item j WHERE j.i_category = i.i_category)
GROUP BY a.ca_state HAVING count(*) >= 10
ORDER BY cnt, a.ca_state LIMIT 100

### Output:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "target_month": "SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2000 AND d_moy = 1",
        "category_avg_price": "SELECT i_category, AVG(i_current_price) * 1.2 AS avg_threshold FROM item GROUP BY i_category",
        "filtered_dates": "SELECT d_date_sk FROM date_dim JOIN target_month ON d_month_seq = target_month.d_month_seq",
        "filtered_sales": "SELECT ss_customer_sk, ss_item_sk FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk",
        "main_query": "SELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address a JOIN customer c ON a.ca_address_sk = c.c_current_addr_sk JOIN filtered_sales s ON c.c_customer_sk = s.ss_customer_sk JOIN item i ON s.ss_item_sk = i.i_item_sk JOIN category_avg_price cap ON i.i_category = cap.i_category WHERE i.i_current_price > cap.avg_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same grouping and aggregation"
      ],
      "expected_speedup": "2.0x",
      "risk": "low"
    }
  ]
}
```

**Key insight:** Extract date month_seq subquery into CTE. Extract category average into separate CTE with GROUP BY. Join instead of correlated subquery. This allows each CTE to be scanned once.


---

## Example: Flatten Subquery to JOIN (FLATTEN_SUBQUERY)
Verified speedup: 1.3-2.0x

### Input:
[main_query]:
SELECT c_customer_id, c_first_name, c_last_name
FROM customer
WHERE c_customer_sk IN (
  SELECT ss_customer_sk FROM store_sales
  WHERE ss_sold_date_sk IN (SELECT d_date_sk FROM date_dim WHERE d_year = 2000)
)

### Output:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "flatten_subquery",
      "nodes": {
        "target_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 2000",
        "active_customers": "SELECT DISTINCT ss_customer_sk FROM store_sales JOIN target_dates ON ss_sold_date_sk = d_date_sk",
        "main_query": "SELECT c.c_customer_id, c.c_first_name, c.c_last_name FROM customer c JOIN active_customers ac ON c.c_customer_sk = ac.ss_customer_sk"
      },
      "invariants_kept": [
        "same result rows",
        "same columns"
      ],
      "expected_speedup": "1.5x",
      "risk": "low"
    }
  ]
}
```

**Key insight:** IN subquery becomes a JOIN. Nested IN becomes chained CTEs. DISTINCT ensures no duplicates from the semi-join semantics.


---

## Example: Inline Single-Use CTE (INLINE_CTE)
Verified speedup: 1.1-1.3x

### Input:
[cte_a]:
SELECT d_date_sk, d_year FROM date_dim WHERE d_year = 2000

[cte_b]:
SELECT i_item_sk, i_brand FROM item WHERE i_category = 'Music'

[main_query]:
SELECT SUM(ss_sales_price)
FROM store_sales
JOIN cte_a ON ss_sold_date_sk = d_date_sk
JOIN cte_b ON ss_item_sk = i_item_sk

### Output:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "inline_cte",
      "nodes": {
        "main_query": "SELECT SUM(ss_sales_price) FROM store_sales JOIN date_dim ON ss_sold_date_sk = d_date_sk JOIN item ON ss_item_sk = i_item_sk WHERE d_year = 2000 AND i_category = 'Music'"
      },
      "invariants_kept": [
        "same result",
        "same aggregation"
      ],
      "expected_speedup": "1.2x",
      "risk": "low"
    }
  ]
}
```

**Key insight:** Single-use CTEs can prevent optimizer from pushing predicates. Inlining allows better join ordering and predicate pushdown.


---

You are an autonomous Query Rewrite Engine. Your goal is to maximize execution speed while strictly preserving semantic invariants.

Output atomic rewrite sets in JSON.

RULES:
- Primary Goal: Maximize execution speed while strictly preserving semantic invariants.
- Allowed Transforms: Use the provided list. If a standard SQL optimization applies that is not listed, label it "semantic_rewrite".
- Atomic Sets: Group dependent changes (e.g., creating a CTE and joining it) into a single rewrite_set.
- Contracts: Output columns, grain, and total result rows must remain invariant.
- Naming: Use descriptive CTE names (e.g., `filtered_returns` vs `cte1`).
- Column Aliasing: Permitted only for aggregations or disambiguation.

ALLOWED TRANSFORMS: pushdown, decorrelate, or_to_union, early_filter, date_cte_isolate, materialize_cte, flatten_subquery, reorder_join, multi_push_predicate, inline_cte, remove_redundant, semantic_rewrite

OUTPUT FORMAT:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "transform_name",
      "nodes": {
        "node_id": "new SQL..."
      },
      "invariants_kept": ["list of preserved semantics"],
      "expected_speedup": "2x",
      "risk": "low"
    }
  ],
  "explanation": "what was changed and why"
}
```

## Target Nodes
  [main_query] GROUP_BY CORRELATED
  [filtered_dates] 

## Subgraph Slice
[main_query] type=main
```sql
SELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address AS a JOIN customer AS c ON a.ca_address_sk = c.c_current_addr_sk JOIN store_sales AS s ON c.c_customer_sk = s.ss_customer_sk JOIN filtered_dates AS fd ON s.ss_sold_date_sk = fd.d_date_sk JOIN item AS i ON s.ss_item_sk = i.i_item_sk WHERE i.i_current_price > 1.2 * (SELECT AVG(j.i_current_price) FROM item AS j WHERE j.i_category = i.i_category) GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100
```

[filtered_dates] type=cte
```sql
SELECT d_date_sk FROM date_dim WHERE d_month_seq = (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3)
```


## Node Contracts
[main_query]:
  output_columns: ['state', 'cnt']
  grain: ['ca_state']
  required_predicates: ['i.i_current_price > 1.2 * (SELECT AVG(j.i_current_price) FROM item AS j WHERE j.i_category = i.i_category)', 'j.i_category = i.i_category']
[filtered_dates]:
  output_columns: ['d_date_sk']
  required_predicates: ['d_month_seq = (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3)', 'd_year = 2002', 'd_moy = 3']

## Downstream Usage
No usage data.

## Cost Attribution
[main_query]: 99.1% cost, ~2607300 rows, ops=[SEQ_SCAN[customer_address], SEQ_SCAN[customer], SEQ_SCAN[store_sales]]
[filtered_dates]: 0.0% cost, ~31 rows, ops=[SEQ_SCAN[date_dim], SEQ_SCAN[date_dim]]

## Detected Opportunities
## Node-Specific Opportunities
DECORRELATE: [main_query] has correlated subquery
  Fix: Move aggregate to CTE, join instead of correlated lookup
  Expected: 2-3x speedup (verified Q1: 2.81x)

Now output your rewrite_sets:

## Execution Plan
```
Operators by cost:
- SEQ_SCAN(store_sales): 62.2% cost, 2,607,300 rows
- HASH_JOIN: 10.2% cost, 2,546,099 rows
- HASH_JOIN: 8.4% cost, 2,607,300 rows
- HASH_JOIN: 7.7% cost, 2,546,099 rows
- LEFT_DELIM_JOIN: 5.1% cost, 0 rows

Scans:
- store_sales x1: 3,455,964,288 rows (no filter)
- customer x1: 24,000,000 rows (no filter)
- customer_address x1: 9,000,000 rows (no filter)
- COLUMN_DATA_SCAN x1: 2,546,099 rows (no filter)
- item x2: 408,000 rows (no filter)
- date_dim x2: 73,049 → 31 rows (filtered)
- DELIM_SCAN x1: 0 rows (no filter)

Misestimates:
- HASH_JOIN: est 287,989 vs actual 2,546,099 (8.8x)
- HASH_JOIN: est 263,163 vs actual 2,546,099 (9.7x)
- HASH_JOIN: est 342,999 vs actual 2,546,099 (7.4x)
- HASH_JOIN: est 342,999 vs actual 2,607,300 (7.6x)
- SEQ_SCAN: est 287,997,024 vs actual 2,607,300 (110.5x)
- SEQ_SCAN: est 73,049 vs actual 31 (2356.4x)
- HASH_JOIN: est 0 vs actual 2,546,099 (2546099.0x)
- COLUMN_DATA_SCAN: est 0 vs actual 2,546,099 (2546099.0x)
- PROJECTION: est 28,804 vs actual 10 (2880.4x)
- PROJECTION: est 28,804 vs actual 10 (2880.4x)
- HASH_GROUP_BY: est 28,804 vs actual 10 (2880.4x)
- DELIM_SCAN: est 258,391 vs actual 0 (258391.0x)
- HASH_GROUP_BY: est 258,391 vs actual 11 (23490.1x)

Joins:
- LEFT_DELIM_JOIN: ? x ? -> 0 rows
- HASH_JOIN: ? x item -> 2,546,099 rows
- HASH_JOIN: customer_address x ? -> 2,546,099 rows
- HASH_JOIN: customer x ? -> 2,546,099 rows
- HASH_JOIN: store_sales x ? -> 2,607,300 rows (late)
```


## Previous Successful Iterations

### Iteration 1: 1.07x speedup ✓

## Current Challenge
**Current best:** 1.07x speedup
**Target:** 2.0x
**Gap:** 0.93x needed

Try a DIFFERENT approach to improve upon the current best.



**IMPORTANT:** The following patterns were provided: date_cte_isolate, flatten_subquery, inline_cte. Consider a DIFFERENT approach!
