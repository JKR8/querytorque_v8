 The user wants me to optimize a SQL query using the allowed transforms. Let me analyze the input query.

The query is:
```sql
SELECT c_last_name, c_first_name, c_salutation, c_preferred_cust_flag, ss_ticket_number, cnt 
FROM (
    SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt 
    FROM store_sales, date_dim, store, household_demographics 
    WHERE store_sales.ss_sold_date_sk = date_dim.d_date_sk 
      AND store_sales.ss_store_sk = store.s_store_sk 
      AND store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk 
      AND date_dim.d_dom BETWEEN 1 AND 2 
      AND (household_demographics.hd_buy_potential = '501-1000' OR household_demographics.hd_buy_potential = 'Unknown') 
      AND household_demographics.hd_vehicle_count > 0 
      AND CASE WHEN household_demographics.hd_vehicle_count > 0 THEN household_demographics.hd_dep_count / household_demographics.hd_vehicle_count ELSE NULL END > 1 
      AND date_dim.d_year IN (2000, 2000 + 1, 2000 + 2) 
      AND store.s_county IN ('Fairfield County', 'Walker County', 'Daviess County', 'Barrow County') 
    GROUP BY ss_ticket_number, ss_customer_sk
) AS dj, 
customer 
WHERE ss_customer_sk = c_customer_sk 
  AND cnt BETWEEN 1 AND 5 
ORDER BY cnt DESC, c_last_name ASC
```

The detected opportunity mentions OR_TO_UNION on the OR condition: `(household_demographics.hd_buy_potential = '501-1000' OR household_demographics.hd_buy_potential = 'Unknown')`

However, looking at the query structure, I should also consider:
1. The OR condition in the WHERE clause of the subquery
2. Early filtering opportunities (pushing down filters)
3. The IN clause on date_dim.d_year could be expanded or optimized
4. The IN clause on store.s_county

But the specific detected opportunity is OR_TO_UNION for the hd_buy_potential OR condition.

Let me think about how to apply OR_TO_UNION here. The OR condition is:
`(household_demographics.hd_buy_potential = '501-1000' OR household_demographics.hd_buy_potential = 'Unknown')`

To apply OR_TO_UNION, I would split the subquery into two branches:
1. One with `hd_buy_potential = '501-1000'`
2. One with `hd_buy_potential = 'Unknown'`

Then UNION ALL them together.

But I also notice there are other filters that could be pushed down early:
- date_dim.d_dom BETWEEN 1 AND 2
- date_dim.d_year IN (2000, 2001, 2002)
- store.s_county IN (...)
- household_demographics.hd_vehicle_count > 0
- The CASE statement condition

However, the prompt specifically mentions the OR_TO_UNION opportunity on the OR condition.

Let me structure the rewrite:

1. Create filtered_date_dim with the date filters pushed down
2. Create filtered_store with the county filter pushed down  
3. Split the main subquery into two branches for the OR condition
4. Union them together
5. Join with customer and apply the cnt filter

Wait, looking at the example, the OR_TO_UNUN splits the entire query into UNION ALL branches, each with one part of the OR condition.

So for this query, I should:

Create a CTE or subquery that handles the date and store filtering first (early_filter/pushdown), then split the OR condition into two UNION ALL branches.

Actually, looking at the example more carefully:
- The example shows creating a filtered_dates CTE first
- Then creating filtered_sales as a UNION ALL of three branches, each with one condition from the OR
- Then the main query does the aggregation

In my case:
- The OR is inside the subquery (dj)
- The subquery does GROUP BY
- So I need to split the subquery into two parts, union them, then group? Or union two grouped results?

Since the grouping is on ss_ticket_number and ss_customer_sk, and the OR condition is on household_demographics which is joined before the group by, I can:
1. Filter dates and stores early
2. Create two branches for the OR condition, each joining with the appropriate hd_buy_potential filter
3. Union them
4. Then group by

Or I could group in each branch and then union. But since COUNT(*) is additive across disjoint sets, both approaches work. However, grouping after union is usually better if the union reduces rows significantly, but here the OR is on a dimension table (household_demographics) joined to the fact table (store_sales).

Actually, looking at the query plan:
- store_sales is the fact table
- It joins to date_dim, store, and household_demographics
- The OR is on household_demographics.hd_buy_potential

So the OR_TO_UNION transform would split the query into:
Branch 1: ... AND hd_buy_potential = '501-1000' ...
Branch 2: ... AND hd_buy_potential = 'Unknown' ...

And UNION ALL them.

But I should also push down other filters like:
- date_dim filters (d_dom, d_year)
- store.s_county filter
- hd_vehicle_count > 0
- The CASE condition (which is actually redundant with hd_vehicle_count > 0 check, but let's keep it)

Also, I can push the customer join and the cnt filter earlier? The cnt filter is on the result of the aggregation, so it has to happen after the GROUP BY. But the join to customer happens after the subquery, and the filter on cnt also happens after.

Wait, looking at the query structure:
- The subquery (dj) groups and counts
- Then it joins to customer
- Then filters cnt BETWEEN 1 AND 5

The cnt filter could be pushed into the subquery (HAVING clause), but that's not one of the allowed transforms explicitly, though it's part of early_filter or pushdown.

But the allowed transforms are: pushdown, decorrelate, or_to_union, in_to_exists, projection_prune, early_filter.

So I can use early_filter to push the cnt filter into the subquery as a HAVING clause, and also push the customer join? No, the customer join uses columns not in the subquery, but the cnt filter only uses the subquery columns.

Actually, looking at the output columns and grain:
- The subquery grain is ss_ticket_number, ss_customer_sk
- The main query joins to customer on ss_customer_sk = c_customer_sk
- Then filters cnt BETWEEN 1 AND 5

I could push the cnt filter into the subquery as a HAVING clause. This is an early_filter transform.

But the detected opportunity specifically mentions OR_TO_UNION.

Let me focus on the OR_TO_UNION as the primary transform, but I can combine it with early_filter for the date and store predicates, and maybe pushdown.

Actually, looking at the example output format, it seems I should create multiple nodes in the rewrite set.

Let me draft the rewrite:

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "or_to_union",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_dom BETWEEN 1 AND 2 AND d_year IN (2000, 2001, 2002)",
        "filtered_store": "SELECT s_store_sk FROM store WHERE s_county IN ('Fairfield County', 'Walker County', 'Daviess County', 'Barrow County')",
        "dj_branch1": "SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_store ON ss_store_sk = s_store_sk JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk WHERE hd_buy_potential = '501-1000' AND hd_vehicle_count > 0 AND CASE WHEN hd_vehicle_count > 0 THEN hd_dep_count / hd_vehicle_count ELSE NULL END > 1 GROUP BY ss_ticket_number, ss_customer_sk",
        "dj_branch2": "SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_store ON ss_store_sk = s_store_sk JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk WHERE hd_buy_potential = 'Unknown' AND hd_vehicle_count > 0 AND CASE WHEN hd_vehicle_count > 0 THEN hd_dep_count / hd_vehicle_count ELSE NULL END > 1 GROUP BY ss_ticket_number, ss_customer_sk",
        "dj": "SELECT ss_ticket_number, ss_customer_sk, cnt FROM (SELECT * FROM dj_branch1 UNION ALL SELECT * FROM dj_branch2) AS unioned WHERE cnt BETWEEN 1 AND 5",
        "main_query": "SELECT c_last_name, c_first_name, c_salutation, c_preferred_cust_flag, ss_ticket_number, cnt FROM dj JOIN customer ON ss_customer_sk = c_customer_sk ORDER BY cnt DESC, c_last_name ASC"
      },
      ...
    }
  ]
}
```

Wait, I need to check if I can push the cnt filter into the subquery. The original query has:
```sql
... AS dj, customer 
WHERE ss_customer_sk = c_customer_sk 
  AND cnt BETWEEN 1 AND 5 
```

So yes, I can push cnt BETWEEN 1 AND 5 into the dj subquery as a HAVING clause or WHERE clause on the grouped result. Since dj is defined as a subquery with GROUP BY, I should add HAVING cnt BETWEEN 1 AND 5 to both branches or filter after the union.

Actually, looking at the original query structure again:
```sql
SELECT ... FROM (SELECT ... GROUP BY ...) AS dj, customer 
WHERE ... AND cnt BETWEEN 1 AND 5
```

The cnt is available in the dj subquery output, so I can add it as a HAVING clause in the branches or as a filter on the union result.

But also, I notice that the CASE condition:
`CASE WHEN household_demographics.hd_vehicle_count > 0 THEN household_demographics.hd_dep_count / household_demographics.hd_vehicle_count ELSE NULL END > 1`

Given that we already have `hd_vehicle_count > 0`, the CASE simplifies to `hd_dep_count / hd_vehicle_count > 1`.

But I should keep the SQL as close to original semantics as possible unless optimizing.

Now, regarding the node contracts:
- main_query output columns: ['c_last_name', 'c_first_name', 'c_salutation', 'c_preferred_cust_flag', 'ss_ticket_number', 'cnt']
- grain: ['ss_ticket_number', 'ss_customer_sk']
- required_predicates: ['ss_customer_sk = c_customer_sk']

In my rewrite, I need to make sure the main_query node preserves these.

Also, I should consider if I can use early_filter to push the date and store filters into CTEs, as shown in the examples.

Let me refine:

1. Create `filtered_dates` with date filters
2. Create `filtered_store` with store filters  
3. Create `branch_501_1000` for the first OR condition with all other filters
4. Create `branch_unknown` for the second OR condition with all other filters
5. Create `dj` as UNION ALL of the two branches, with the cnt filter applied (HAVING or WHERE)
6. Create `main_query` joining dj with customer and ordering

Actually, looking at the example OR_TO_UNION, they created filtered_sales as the UNION ALL of three branches, each with one OR condition.

So for this query, I should create the dj subquery as a UNION ALL.

But wait, the dj subquery in the original does GROUP BY. If I split into two branches, I can either:
- Group in each branch then union (requires adding the counts if there could be overlap, but since hd_buy_potential is mutually exclusive values '501-1000' vs 'Unknown', there's no overlap, so UNION ALL is fine)
- Union then group

Since the OR is on a dimension attribute that filters the fact table, and we're counting rows, splitting the fact table scan into two parts (one for each dimension filter) and grouping each separately then unioning is valid.

However, looking at the query, store_sales joins to household_demographics. If I filter household_demographics first by hd_buy_potential, then join to store_sales, that's efficient.

So:
- Branch 1: store_sales -> filtered_dates -> filtered_store -> household_demographics (hd_buy_potential = '501-1000') -> group by
- Branch 2: store_sales -> filtered_dates -> filtered_store -> household_demographics (hd_buy_potential = 'Unknown') -> group by
- Union them
- Filter cnt between 1 and 5
- Join to customer

But I can also push the cnt filter (HAVING) into each branch.

Let me check the expected_speedup. The prompt says "Expected: 2x speedup" for the OR_TO_UNION.

Risk is low.

Invariants kept should include:
- output columns unchanged
- same rows after aggregation (or same final result)
- same ordering

Now, let me write the SQL carefully.

Original filters in the subquery:
- date_dim.d_dom BETWEEN 1 AND 2
- date_dim.d_year IN (2000, 2000 + 1, 2000 + 2) = IN (2000, 2001, 2002)
- store.s_county IN ('Fairfield County', 'Walker County', 'Daviess County', 'Barrow County')
- hd_buy_potential OR condition
- hd_vehicle_count > 0
- CASE condition

The CASE condition: `CASE WHEN household_demographics.hd_vehicle_count > 0 THEN household_demographics.hd_dep_count / household_demographics.hd_vehicle_count ELSE NULL END > 1`

Since we have `hd_vehicle_count > 0` in the WHERE clause, the CASE WHEN is redundant for the NULL check, but I should preserve the logic.

Actually, looking at the SQL: `AND CASE WHEN household_demographics.hd_vehicle_count > 0 THEN household_demographics.hd_dep_count / household_demographics.hd_vehicle_count ELSE NULL END > 1`

Since `hd_vehicle_count > 0` is already required, this simplifies to `hd_dep_count / hd_vehicle_count > 1`, but I'll keep the CASE to be safe and preserve semantics exactly.

Now for the rewrite:

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "or_to_union",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_dom BETWEEN 1 AND 2 AND d_year IN (2000, 2001, 2002)",
        "filtered_stores": "SELECT s_store_sk FROM store WHERE s_county IN ('Fairfield County', 'Walker County', 'Daviess County', 'Barrow County')",
        "dj_buy_potential_501_1000": "SELECT ss.ss_ticket_number, ss.ss_customer_sk, COUNT(*) AS cnt FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN filtered_stores fs ON ss.ss_store_sk = fs.s_store_sk JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk WHERE hd.hd_buy_potential = '501-1000' AND hd.hd_vehicle_count > 0 AND CASE WHEN hd.hd_vehicle_count > 0 THEN hd.hd_dep_count / hd.hd_vehicle_count ELSE NULL END > 1 GROUP BY ss.ss_ticket_number, ss.ss_customer_sk HAVING COUNT(*) BETWEEN 1 AND 5",
        "dj_buy_potential_unknown": "SELECT ss.ss_ticket_number, ss.ss_customer_sk, COUNT(*) AS cnt FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN filtered_stores fs ON ss.ss_store_sk = fs.s_store_sk JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk WHERE hd.hd_buy_potential = 'Unknown' AND hd.hd_vehicle_count > 0 AND CASE WHEN hd.hd_vehicle_count > 0 THEN hd.hd_dep_count / hd.hd_vehicle_count ELSE NULL END > 1 GROUP BY ss.ss_ticket_number, ss.ss_customer_sk HAVING COUNT(*) BETWEEN 1 AND 5",
        "dj": "SELECT ss_ticket_number, ss_customer_sk, cnt FROM dj_buy_potential_501_1000 UNION ALL SELECT ss_ticket_number, ss_customer_sk, cnt FROM dj_buy_potential_unknown",
        "main_query": "SELECT c.c_last_name, c.c_first_name, c.c_salutation, c.c_preferred_cust_flag, dj.ss_ticket_number, dj.cnt FROM dj JOIN customer c ON dj.ss_customer_sk = c.c_customer_sk ORDER BY dj.cnt DESC, c.c_last_name ASC"
      },
      "invariants_kept": [
        "output columns unchanged",
        "same result rows",
        "same ordering"
      ],
      "expected_speedup": "2.00x",
      "risk": "low"
    }
  ]
}
```

Wait, I need to check if I should include the cnt filter in the main_query or in dj. In the original, it's in the main_query WHERE clause. But since dj is now a CTE/subquery, I can put it in dj or keep it in main_query. 

Actually, looking at the original:
```sql
FROM (...) AS dj, customer 
WHERE ss_customer_sk = c_customer_sk AND cnt BETWEEN 1 AND 5
```

So the cnt filter is applied after the join with customer. But since cnt comes from dj and doesn't depend on customer, I can push it into dj (the subquery). This would be an early_filter.

But the transform requested is OR_TO_UNION. I can combine transforms? The example shows "OR_TO_UNION + EARLY_FILTER" in the first example title, but in the output it's listed as "or_to_union" transform. So I can include multiple optimizations in one rewrite set.

However, looking at the example 2, it only lists "or_to_union" as the transform, but it also does early filtering by creating filtered_dates and pushing conditions there.

So I think it's fine to include the early filtering of dates and stores, and also push the cnt filter into the subqueries (HAVING).

But wait, if I push cnt into the HAVING clause of each branch, and then UNION ALL, that's fine.

Also, I should check if I need to handle the join to customer. The main_query should preserve the join.

One thing: in the original query, the subquery is named `dj` and is used in the FROM clause with `customer`. The join condition is `ss_customer_sk = c_customer_sk`.

In my rewrite, I have `dj` as the union result, then join to customer in main_query.

Let me double-check the column aliases. In the original subquery:
`SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt`

So dj has columns: ss_ticket_number, ss_customer_sk, cnt.

Then main_query selects from dj and customer where ss_customer_sk = c_customer_sk.

So my main_query should be correct.

One optimization: I could also push the customer join into the branches? No, because that would duplicate the customer lookup. Better to filter with cnt first (which reduces rows) then join to customer.

But the cnt filter is on the grouped result. The grouping is on ss_ticket_number and ss_customer_sk. If I filter by cnt BETWEEN 1 AND 5 in each branch (HAVING), I reduce the rows before the union. Then after union, I join to customer.

This is efficient.

Now, regarding the CASE statement: `CASE WHEN household_demographics.hd_vehicle_count > 0 THEN household_demographics.hd_dep_count / household_demographics.hd_vehicle_count ELSE NULL END > 1`

Since we already filter `hd_vehicle_count > 0`, the division is safe. The CASE is technically redundant but I'll keep it to preserve exact semantics.

Also, note that `2000 + 1` and `2000 + 2` should be evaluated to `2001` and `2002` in the rewritten SQL for clarity, or I can keep them as expressions. The example used literal values. I'll use 2001 and 2002.

Let me verify the invariants:
- output_columns: main_query selects c_last_name, c_first_name, c_salutation, c_preferred_cust_flag, ss_ticket_number, cnt - matches original.
- grain: The final output has one row per ss_ticket_number, ss_customer_sk (implied by the grouping in dj and the join to customer which is 1:1 on customer_sk). Actually, the grain of the final output is the same as dj, which is ss_ticket_number, ss_customer_sk. The customer join doesn't change the grain assuming c_customer_sk is unique (primary key).
- required_predicates: ss_customer_sk = c_customer_sk is preserved in main_query.

Expected speedup: 2x as suggested.
Risk: low.

I think this is good.

One final check: should I use `UNION ALL` or `UNION`? Since the two branches are mutually exclusive (hd_buy_potential cannot be both '501-1000' and 'Unknown'), UNION ALL is correct and more efficient.

Also, should I include `filtered_household_501_1000` and `filtered_household_unknown` as separate CTEs? The example showed pushing filters into the branches directly. I think joining to household_demographics with the filter in the WHERE clause of each branch is clear and follows the pattern.

Actually, looking at the example again:
```sql
"filtered_sales": "SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE substr(ca_zip,1,5) IN (...) UNION ALL ..."
```

So they put the OR condition split into the WHERE clauses of the UNION ALL branches. This is exactly what I did.

So my rewrite looks correct.

One small thing: in the original query, the subquery is aliased as `dj` and the main query does `FROM (...) AS dj, customer`. This is an implicit join (comma join) with WHERE clause conditions. In my rewrite, I used explicit JOIN syntax `FROM dj JOIN customer ON ...` which is equivalent and cleaner.

Also, I should make sure to qualify all columns properly to avoid ambiguity.

In dj_buy_potential_501_1000:
- ss.ss_ticket_number, ss.ss_customer_sk - good
- COUNT(*) AS cnt - good

In dj_buy_potential_unknown:
- same

In dj:
- SELECT ss_ticket_number, ss_customer_sk, cnt - good (no table alias needed since it's selecting from the CTEs)

In main_query:
- c.c_last_name, etc.
- dj.ss_ticket_number, dj.cnt
- ORDER BY dj.cnt DESC, c.c_last_name ASC

Wait, in the original ORDER BY: `ORDER BY cnt DESC, c_last_name ASC`

Since cnt and c_last_name are in the output, and in my main_query I have dj.cnt and c.c_last_name, I should use the table aliases or just the column names if unambiguous. But to be safe and clear, I'll use the aliases.

Actually, looking at the original: `ORDER BY cnt DESC, c_last_name ASC`

It uses unqualified names. In my main_query, I can use `dj.cnt` and `c.c_last_name` or just `cnt` and `c_last_name` if I alias the output columns. But since I select `dj.cnt` and `c.c_last_name`, I should reference them appropriately.

In the SELECT list of main_query, I have:
`SELECT c.c_last_name, c.c_first_name, c.c_salutation, c.c_preferred_cust_flag, dj.ss_ticket_number, dj.cnt`

So in ORDER BY, I can use `dj.cnt DESC, c.c_last_name ASC` or just `cnt DESC, c_last_name ASC` since those are the output column names effectively. But to be consistent with the examples, I'll use the aliases.

Actually, looking at example 1:
```sql
"main_query": "SELECT c.c_customer_id FROM customer_total_return ctr1 JOIN store_avg_return sar ON ctr1.ctr_store_sk = sar.ctr_store_sk JOIN customer c ON ctr1.ctr_customer_sk = c.c_customer_sk WHERE ctr1.ctr_total_return > sar.avg_return_threshold ORDER BY c.c_customer_id LIMIT 100"
```

They use table aliases in ORDER BY.

So I'll use `ORDER BY dj.cnt DESC, c.c_last_name ASC`.

One final check: the original query has `date_dim.d_year IN (2000, 2000 + 1, 2000 + 2)`. I replaced this with `IN (2000, 2001, 2002)`. This is a constant folding which preserves semantics.

Also, `d_dom BETWEEN 1 AND 2` is preserved.

The `s_county IN (...)` is preserved.

The `hd_vehicle_count > 0` and CASE condition are preserved.

The `cnt BETWEEN 1 AND 5` is preserved (moved to HAVING in branches).

The join to customer is preserved.

The final ordering is preserved.

I think this is complete. </think> ```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "or_to_union",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_dom BETWEEN 1 AND 2 AND d_year IN (2000, 2001, 2002)",
        "filtered_stores": "SELECT s_store_sk FROM store WHERE s_county IN ('Fairfield County', 'Walker County', 'Daviess County', 'Barrow County')",
        "dj_buy_potential_501_1000": "SELECT ss.ss_ticket_number, ss.ss_customer_sk, COUNT(*) AS cnt FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN filtered_stores fs ON ss.ss_store_sk = fs.s_store_sk JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk WHERE hd.hd_buy_potential = '501-1000' AND hd.hd_vehicle_count > 0 AND CASE WHEN hd.hd_vehicle_count > 0 THEN hd.hd_dep_count / hd.hd_vehicle_count ELSE NULL END > 1 GROUP BY ss.ss_ticket_number, ss.ss_customer_sk HAVING COUNT(*) BETWEEN 1 AND 5",
        "dj_buy_potential_unknown": "SELECT ss.ss_ticket_number, ss.ss_customer_sk, COUNT(*) AS cnt FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN filtered_stores fs ON ss.ss_store_sk = fs.s_store_sk JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk WHERE hd.hd_buy_potential = 'Unknown' AND hd.hd_vehicle_count > 0 AND CASE WHEN hd.hd_vehicle_count > 0 THEN hd.hd_dep_count / hd.hd_vehicle_count ELSE NULL END > 1 GROUP BY ss.ss_ticket_number, ss.ss_customer_sk HAVING COUNT(*) BETWEEN 1 AND 5",
        "dj": "SELECT ss_ticket_number, ss_customer_sk, cnt FROM dj_buy_potential_501_1000 UNION ALL SELECT ss_ticket_number, ss_customer_sk, cnt FROM dj_buy_potential_unknown",
        "main_query": "SELECT c.c_last_name, c.c_first_name, c.c_salutation, c.c_preferred_cust_flag, dj.ss_ticket_number, dj.cnt FROM dj JOIN customer c ON dj.ss_customer_sk = c.c_customer_sk ORDER BY dj.cnt DESC, c.c_last_name ASC"
      },
      "invariants_kept": [
        "output columns unchanged",
        "same result rows",
        "same ordering"
      ],
      "expected_speedup": "2.00x",
      "risk": "low"
    }
  ],
  "explanation": "Split the OR condition on hd_buy_potential into two UNION ALL branches to enable separate filtered scans on household_demographics. Pushed down date_dim filters (d_dom, d_year) and store filters (s_county) into early CTEs. Pushed the cnt BETWEEN 1 AND 5 filter into each branch as HAVING to reduce rows before the union and customer join."
}
```