 ```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "decorrelate",
      "nodes": {
        "threshold_calc": "SELECT AVG(ss_net_profit) * 0.9 AS profit_threshold FROM store_sales WHERE ss_store_sk = 146 AND ss_addr_sk IS NULL GROUP BY ss_store_sk",
        "qualified_items": "SELECT ss1.ss_item_sk AS item_sk, AVG(ss1.ss_net_profit) AS rank_col FROM store_sales ss1 CROSS JOIN threshold_calc WHERE ss1.ss_store_sk = 146 GROUP BY ss1.ss_item_sk HAVING AVG(ss1.ss_net_profit) > threshold_calc.profit_threshold",
        "ascending": "SELECT item_sk, rnk FROM (SELECT item_sk, RANK() OVER (ORDER BY rank_col ASC) AS rnk FROM qualified_items) t WHERE rnk < 11",
        "descending": "SELECT item_sk, rnk FROM (SELECT item_sk, RANK() OVER (ORDER BY rank_col DESC) AS rnk FROM qualified_items) t WHERE rnk < 11",
        "main_query": "SELECT a.rnk, i1.i_product_name AS best_performing, i2.i_product_name AS worst_performing FROM ascending a JOIN descending d ON a.rnk = d.rnk JOIN item i1 ON i1.i_item_sk = a.item_sk JOIN item i2 ON i2.i_item_sk = d.item_sk ORDER BY a.rnk LIMIT 100"
      },
      "invariants_kept": [
        "output columns unchanged",
        "same row filtering (rnk < 11)",
        "same join predicates",
        "same ordering",
        "same limit"
      ],
      "expected_speedup": "1.80x",
      "risk": "low"
    }
  ],
  "explanation": "Extracted the scalar subquery from the HAVING clause into a separate threshold_calc node (decorrelate). This eliminates redundant computation of the 0.9*avg threshold. Additionally, factored out the common item aggregation (qualified_items) that was previously computed twice (once for ascending, once for descending). Now store_sales is scanned only twice (once for threshold, once for item aggregates) instead of three times, and the aggregation is computed once and reused for both ranking directions."
}
```