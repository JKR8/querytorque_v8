 ```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "early_filter",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_day_name FROM date_dim WHERE d_year = 2000",
        "filtered_stores": "SELECT s_store_sk, s_store_name, s_store_id FROM store WHERE s_gmt_offset = -5",
        "main_query": "SELECT s.s_store_name, s.s_store_id, SUM(CASE WHEN d.d_day_name = 'Sunday' THEN ss.ss_sales_price END) AS sun_sales, SUM(CASE WHEN d.d_day_name = 'Monday' THEN ss.ss_sales_price END) AS mon_sales, SUM(CASE WHEN d.d_day_name = 'Tuesday' THEN ss.ss_sales_price END) AS tue_sales, SUM(CASE WHEN d.d_day_name = 'Wednesday' THEN ss.ss_sales_price END) AS wed_sales, SUM(CASE WHEN d.d_day_name = 'Thursday' THEN ss.ss_sales_price END) AS thu_sales, SUM(CASE WHEN d.d_day_name = 'Friday' THEN ss.ss_sales_price END) AS fri_sales, SUM(CASE WHEN d.d_day_name = 'Saturday' THEN ss.ss_sales_price END) AS sat_sales FROM filtered_dates d JOIN store_sales ss ON d.d_date_sk = ss.ss_sold_date_sk JOIN filtered_stores s ON s.s_store_sk = ss.ss_store_sk GROUP BY s.s_store_name, s.s_store_id ORDER BY s.s_store_name, s.s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same aggregation semantics"
      ],
      "expected_speedup": "3.50x",
      "risk": "low"
    }
  ],
  "explanation": "Applied early_filter to push d_year=2000 predicate into date_dim and s_gmt_offset=-5 predicate into store table before joining. This reduces the cardinality of both dimension tables significantly (date_dim filtered from ~10 years to 1 year, store filtered to specific timezone) before the expensive join with the large store_sales fact table. Also projects only necessary columns in the filtered CTEs to reduce I/O."
}
```