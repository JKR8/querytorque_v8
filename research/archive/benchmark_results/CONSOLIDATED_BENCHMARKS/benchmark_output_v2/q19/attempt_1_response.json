```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_moy = 12 AND d_year = 1999",
        "filtered_items": "SELECT i_item_sk, i_brand_id, i_brand, i_manufact_id, i_manufact FROM item WHERE i_manager_id = 2",
        "filtered_stores": "SELECT s_store_sk, s_zip FROM store",
        "filtered_customers": "SELECT c_customer_sk, c_current_addr_sk FROM customer",
        "filtered_addresses": "SELECT ca_address_sk, ca_zip FROM customer_address",
        "qualified_sales": "SELECT ss_item_sk, ss_customer_sk, ss_ext_sales_price, ss_store_sk FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk",
        "joined_data": "SELECT i.i_brand_id, i.i_brand, i.i_manufact_id, i.i_manufact, qs.ss_ext_sales_price, ca.ca_zip, s.s_zip FROM qualified_sales qs JOIN filtered_items i ON qs.ss_item_sk = i.i_item_sk JOIN filtered_customers c ON qs.ss_customer_sk = c.c_customer_sk JOIN filtered_addresses ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN filtered_stores s ON qs.ss_store_sk = s.s_store_sk WHERE SUBSTRING(ca.ca_zip, 1, 5) <> SUBSTRING(s.s_zip, 1, 5)",
        "main_query": "SELECT i_brand_id AS brand_id, i_brand AS brand, i_manufact_id, i_manufact, SUM(ss_ext_sales_price) AS ext_price FROM joined_data GROUP BY i_brand, i_brand_id, i_manufact_id, i_manufact ORDER BY ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same grouping and aggregation",
        "same ordering"
      ],
      "expected_speedup": "3.5x",
      "risk": "low"
    }
  ],
  "explanation": "The rewrite isolates date_dim filtering into a CTE (filtered_dates) to reduce early join cardinality. It also creates focused CTEs for filtered items (i_manager_id=2), stores, customers, and addresses. The main join (qualified_sales) starts with store_sales filtered by date only, then joins with pre-filtered dimension tables. This allows each dimension table to be scanned once with its predicate applied early, avoiding repeated filtering during the large join. The zip comparison predicate is applied in the final joined_data CTE. This reduces the initial store_sales join from scanning 34M rows with multiple predicates to a more focused date-filtered set."
}
```