```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_year, d_moy FROM date_dim WHERE d_year = 1999 OR (d_year = 1998 AND d_moy = 12) OR (d_year = 2000 AND d_moy = 1)",
        "v1": "SELECT i_category, i_brand, s_store_name, s_company_name, d_year, d_moy, SUM(ss_sales_price) AS sum_sales, AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_category, i_brand, s_store_name, s_company_name, d_year) AS avg_monthly_sales, RANK() OVER (PARTITION BY i_category, i_brand, s_store_name, s_company_name ORDER BY d_year, d_moy) AS rn FROM item JOIN store_sales ON ss_item_sk = i_item_sk JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN store ON ss_store_sk = s_store_sk GROUP BY i_category, i_brand, s_store_name, s_company_name, d_year, d_moy"
      },
      "invariants_kept": [
        "same result rows",
        "same column output",
        "same grain"
      ],
      "expected_speedup": "1.8x",
      "risk": "low"
    },
    {
      "id": "rs_02",
      "transform": "or_to_union",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_year, d_moy FROM date_dim WHERE d_year = 1999 UNION ALL SELECT d_date_sk, d_year, d_moy FROM date_dim WHERE d_year = 1998 AND d_moy = 12 UNION ALL SELECT d_date_sk, d_year, d_moy FROM date_dim WHERE d_year = 2000 AND d_moy = 1"
      },
      "invariants_kept": [
        "same result rows",
        "same column output"
      ],
      "expected_speedup": "2.2x",
      "risk": "medium"
    }
  ],
  "explanation": "First, isolate date filtering into a CTE to reduce join cardinality early (date_cte_isolate). Second, split the OR condition on date_dim into UNION ALL branches for better predicate pushdown and potential parallelization (or_to_union). This targets the 90.9% cost of v1 where date_dim is filtered from 73K rows to ~1.8K rows, but the optimizer misestimates. Pre-filtering dates reduces the fact table join cardinality significantly."
}
```