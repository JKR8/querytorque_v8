Looking at the input queries and opportunities, I can see the main optimization opportunity is applying date filtering early to reduce the massive fact table scans. The `date_cte_isolate` pattern is particularly relevant since date_dim is filtered to only 15 rows from 73,049.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('2000-08-23' AS DATE) AND CAST('2000-09-06' AS DATE)",
        "wsr_rewritten": "SELECT web_site_id, SUM(sales_price) AS sales, SUM(profit) AS profit, SUM(return_amt) AS returns_, SUM(net_loss) AS profit_loss FROM (SELECT ws_web_site_sk AS wsr_web_site_sk, ws_sold_date_sk AS date_sk, ws_ext_sales_price AS sales_price, ws_net_profit AS profit, CAST(0 AS DECIMAL(7, 2)) AS return_amt, CAST(0 AS DECIMAL(7, 2)) AS net_loss FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk UNION ALL SELECT ws_web_site_sk AS wsr_web_site_sk, wr_returned_date_sk AS date_sk, CAST(0 AS DECIMAL(7, 2)) AS sales_price, CAST(0 AS DECIMAL(7, 2)) AS profit, wr_return_amt AS return_amt, wr_net_loss AS net_loss FROM web_returns LEFT OUTER JOIN web_sales ON (wr_item_sk = ws_item_sk AND wr_order_number = ws_order_number) JOIN filtered_dates ON wr_returned_date_sk = d_date_sk) AS salesreturns, web_site WHERE wsr_web_site_sk = web_site_sk GROUP BY web_site_id",
        "ssr_rewritten": "SELECT s_store_id, SUM(sales_price) AS sales, SUM(profit) AS profit, SUM(return_amt) AS returns_, SUM(net_loss) AS profit_loss FROM (SELECT ss_store_sk AS store_sk, ss_sold_date_sk AS date_sk, ss_ext_sales_price AS sales_price, ss_net_profit AS profit, CAST(0 AS DECIMAL(7, 2)) AS return_amt, CAST(0 AS DECIMAL(7, 2)) AS net_loss FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk UNION ALL SELECT sr_store_sk AS store_sk, sr_returned_date_sk AS date_sk, CAST(0 AS DECIMAL(7, 2)) AS sales_price, CAST(0 AS DECIMAL(7, 2)) AS profit, sr_return_amt AS return_amt, sr_net_loss AS net_loss FROM store_returns JOIN filtered_dates ON sr_returned_date_sk = d_date_sk) AS salesreturns, store WHERE store_sk = s_store_sk GROUP BY s_store_id"
      },
      "invariants_kept": [
        "same output columns",
        "same grouping and aggregation",
        "date filter applied at correct logical point"
      ],
      "expected_speedup": "3.5x",
      "risk": "low"
    }
  ],
  "explanation": "Isolated date filter into a CTE that selects only 15 rows instead of scanning entire date_dim table multiple times. Applied date filter early in both UNION branches of wsr and ssr, which prevents scanning millions of irrelevant fact rows. This leverages the fact that date_dim is small and highly selective (73,049 â†’ 15 rows). The same date_range CTE can be reused for csr if that CTE becomes available."
}
```