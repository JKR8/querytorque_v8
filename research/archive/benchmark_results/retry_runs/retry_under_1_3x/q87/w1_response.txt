Looking at this query, I can see it's performing three EXCEPT operations on similar subqueries, each joining a sales fact table with date_dim and customer, filtering by the same date range. The key insight is that each subquery is scanning the large sales tables (store_sales, catalog_sales, web_sales) with the same date filter applied through joins.

**Primary optimization opportunity:** Isolate the date filter into a CTE and push it early to reduce the fact table scans. Currently, the date_dim filter is applied after joining with huge fact tables.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1200 AND 1200 + 11",
        "store_sales_customers": "SELECT DISTINCT c.c_last_name, c.c_first_name, fd.d_date FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk",
        "catalog_sales_customers": "SELECT DISTINCT c.c_last_name, c.c_first_name, fd.d_date FROM catalog_sales cs JOIN filtered_dates fd ON cs.cs_sold_date_sk = fd.d_date_sk JOIN customer c ON cs.cs_bill_customer_sk = c.c_customer_sk",
        "web_sales_customers": "SELECT DISTINCT c.c_last_name, c.c_first_name, fd.d_date FROM web_sales ws JOIN filtered_dates fd ON ws.ws_sold_date_sk = fd.d_date_sk JOIN customer c ON ws.ws_bill_customer_sk = c.c_customer_sk",
        "main_query": "SELECT COUNT(*) FROM ((SELECT * FROM store_sales_customers) EXCEPT (SELECT * FROM catalog_sales_customers) EXCEPT (SELECT * FROM web_sales_customers)) AS cool_cust"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same EXCEPT semantics"
      ],
      "expected_speedup": "3.5x",
      "risk": "low"
    },
    {
      "id": "rs_02",
      "transform": "reorder_join",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1200 AND 1200 + 11",
        "store_sales_filtered": "SELECT ss_customer_sk, ss_sold_date_sk FROM store_sales JOIN filtered_dates fd ON store_sales.ss_sold_date_sk = fd.d_date_sk",
        "catalog_sales_filtered": "SELECT cs_bill_customer_sk, cs_sold_date_sk FROM catalog_sales JOIN filtered_dates fd ON catalog_sales.cs_sold_date_sk = fd.d_date_sk",
        "web_sales_filtered": "SELECT ws_bill_customer_sk, ws_sold_date_sk FROM web_sales JOIN filtered_dates fd ON web_sales.ws_sold_date_sk = fd.d_date_sk",
        "store_sales_customers": "SELECT DISTINCT c.c_last_name, c.c_first_name, fd.d_date FROM store_sales_filtered ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk",
        "catalog_sales_customers": "SELECT DISTINCT c.c_last_name, c.c_first_name, fd.d_date FROM catalog_sales_filtered cs JOIN filtered_dates fd ON cs.cs_sold_date_sk = fd.d_date_sk JOIN customer c ON cs.cs_bill_customer_sk = c.c_customer_sk",
        "web_sales_customers": "SELECT DISTINCT c.c_last_name, c.c_first_name, fd.d_date FROM web_sales_filtered ws JOIN filtered_dates fd ON ws.ws_sold_date_sk = fd.d_date_sk JOIN customer c ON ws.ws_bill_customer_sk = c.c_customer_sk",
        "main_query": "SELECT COUNT(*) FROM ((SELECT * FROM store_sales_customers) EXCEPT (SELECT * FROM catalog_sales_customers) EXCEPT (SELECT * FROM web_sales_customers)) AS cool_cust"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same EXCEPT semantics"
      ],
      "expected_speedup": "1.8x",
      "risk": "low"
    }
  ],
  "explanation": "Applied DATE_CTE_ISOLATE to filter date_dim early (366 rows instead of 73,049) before joining with massive fact tables (store_sales: 345M rows, catalog_sales: 172M rows, web_sales: 86M rows). This reduces the fact table scans by 39.9x (per execution plan misestimates). Added REORDER_JOIN variant that pushes date filter even earlier to reduce intermediate join sizes."
}
```

**Key insights:**
1. The date filter reduces date_dim from 73,049 rows to 366 rows (39.9x reduction)
2. Each fact table is scanned once in original query but joins happen before filtering
3. By isolating dates into a CTE first, we filter before joining with massive fact tables
4. The reorder_join variant filters fact tables before joining with customer (reduces intermediate result sizes)