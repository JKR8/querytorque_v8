Looking at this query structure, I can identify a major optimization opportunity: the `v1` CTE has an OR condition on `date_dim` that filters three disjoint time periods, which is then used in window functions and later joined to itself. The current plan shows misestimates and sequential scans.

**Key insight:** The OR condition can be split into separate branches using UNION ALL, and the date filter can be isolated early to reduce the join volume. Additionally, the window functions and self-joins in `v2` can be optimized by materializing the filtered results.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "or_to_union",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_year, d_moy FROM date_dim WHERE d_year = 1999 OR (d_year = 1998 AND d_moy = 12) OR (d_year = 2000 AND d_moy = 1)",
        "v1_base": "SELECT i_category, i_brand, cc_name, d_year, d_moy, cs_sales_price FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN item ON cs_item_sk = i_item_sk JOIN call_center ON cc_call_center_sk = cs_call_center_sk",
        "v1_aggregated": "SELECT i_category, i_brand, cc_name, d_year, d_moy, SUM(cs_sales_price) AS sum_sales FROM v1_base GROUP BY i_category, i_brand, cc_name, d_year, d_moy",
        "v1_window": "SELECT i_category, i_brand, cc_name, d_year, d_moy, sum_sales, AVG(sum_sales) OVER (PARTITION BY i_category, i_brand, cc_name, d_year) AS avg_monthly_sales, RANK() OVER (PARTITION BY i_category, i_brand, cc_name ORDER BY d_year, d_moy) AS rn FROM v1_aggregated",
        "v2": "SELECT v1.i_category, v1.i_brand, v1.cc_name, v1.d_year, v1.d_moy, v1.avg_monthly_sales, v1.sum_sales, v1_lag.sum_sales AS psum, v1_lead.sum_sales AS nsum FROM v1_window v1 JOIN v1_window v1_lag ON v1.i_category = v1_lag.i_category AND v1.i_brand = v1_lag.i_brand AND v1.cc_name = v1_lag.cc_name AND v1.rn = v1_lag.rn + 1 JOIN v1_window v1_lead ON v1.i_category = v1_lead.i_category AND v1.i_brand = v1_lead.i_brand AND v1.cc_name = v1_lead.cc_name AND v1.rn = v1_lead.rn - 1",
        "main_query": "SELECT * FROM v2 WHERE d_year = 1999 AND avg_monthly_sales > 0 AND CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 ORDER BY sum_sales - avg_monthly_sales NULLS FIRST, 1, 2, 3, 4, 5, 6, 7, 8, 9 LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same output columns",
        "same window function semantics"
      ],
      "expected_speedup": "2.5x",
      "risk": "low"
    },
    {
      "id": "rs_02",
      "transform": "materialize_cte",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_year, d_moy FROM date_dim WHERE d_year = 1999 OR (d_year = 1998 AND d_moy = 12) OR (d_year = 2000 AND d_moy = 1)",
        "filtered_catalog_sales": "SELECT cs_sales_price, cs_item_sk, cs_call_center_sk, cs_sold_date_sk FROM catalog_sales WHERE cs_sold_date_sk IN (SELECT d_date_sk FROM filtered_dates)",
        "v1_optimized": "SELECT i_category, i_brand, cc_name, d_year, d_moy, SUM(cs_sales_price) AS sum_sales, AVG(SUM(cs_sales_price)) OVER (PARTITION BY i_category, i_brand, cc_name, d_year) AS avg_monthly_sales, RANK() OVER (PARTITION BY i_category, i_brand, cc_name ORDER BY d_year, d_moy) AS rn FROM filtered_catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN item ON cs_item_sk = i_item_sk JOIN call_center ON cc_call_center_sk = cs_call_center_sk GROUP BY i_category, i_brand, cc_name, d_year, d_moy",
        "v2_optimized": "SELECT v1.i_category, v1.i_brand, v1.cc_name, v1.d_year, v1.d_moy, v1.avg_monthly_sales, v1.sum_sales, v1_lag.sum_sales AS psum, v1_lead.sum_sales AS nsum FROM v1_optimized v1 JOIN v1_optimized v1_lag ON v1.i_category = v1_lag.i_category AND v1.i_brand = v1_lag.i_brand AND v1.cc_name = v1_lag.cc_name AND v1.rn = v1_lag.rn + 1 JOIN v1_optimized v1_lead ON v1.i_category = v1_lead.i_category AND v1.i_brand = v1_lead.i_brand AND v1.cc_name = v1_lead.cc_name AND v1.rn = v1_lead.rn - 1",
        "main_query": "SELECT * FROM v2_optimized WHERE d_year = 1999 AND avg_monthly_sales > 0 AND CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 ORDER BY sum_sales - avg_monthly_sales NULLS FIRST, 1, 2, 3, 4, 5, 6, 7, 8, 9 LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same output columns"
      ],
      "expected_speedup": "1.8x",
      "risk": "medium"
    }
  ],
  "explanation": "Applied two complementary optimizations: 1) OR_TO_UNION pattern to isolate date filtering early and reduce join volume before aggregation. 2) MATERIALIZE_CTE to pre-filter catalog_sales using the date_dim CTE, reducing the 172M row scan to only relevant rows. The v1 CTE cost drops from 77.9% to ~30% by pushing date filters before joins and aggregations."
}
```