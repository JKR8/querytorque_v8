```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "multi_date_range_cte",
      "nodes": {
        "d1_dates": "SELECT d_date_sk, d_week_seq, d_date FROM date_dim WHERE d_year = 1999",
        "filtered_inventory": "SELECT inv_item_sk, inv_warehouse_sk, inv_quantity_on_hand FROM inventory JOIN d1_dates d2 ON inv_date_sk = d2.d_date_sk",
        "filtered_catalog_sales": "SELECT cs_item_sk, cs_order_number, cs_bill_cdemo_sk, cs_bill_hdemo_sk, cs_sold_date_sk, cs_ship_date_sk, cs_quantity, cs_promo_sk FROM catalog_sales JOIN d1_dates d1 ON cs_sold_date_sk = d1.d_date_sk JOIN date_dim d3 ON cs_ship_date_sk = d3.d_date_sk WHERE d3.d_date > d1.d_date + 5",
        "filtered_customer_demographics": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'D'",
        "filtered_household_demographics": "SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '>10000'",
        "joined_facts": "SELECT cs_item_sk, cs_order_number, cs_quantity, cs_promo_sk, inv_warehouse_sk, inv_quantity_on_hand FROM filtered_catalog_sales cs JOIN filtered_inventory inv ON cs.cs_item_sk = inv.inv_item_sk AND EXISTS (SELECT 1 FROM d1_dates d1, d1_dates d2 WHERE cs.cs_sold_date_sk = d1.d_date_sk AND inv.inv_date_sk = d2.d_date_sk AND d1.d_week_seq = d2.d_week_seq) WHERE inv_quantity_on_hand < cs_quantity",
        "main_query": "SELECT i.i_item_desc, w.w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p.p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p.p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM joined_facts jf JOIN item i ON jf.cs_item_sk = i.i_item_sk JOIN warehouse w ON jf.inv_warehouse_sk = w.w_warehouse_sk JOIN d1_dates d1 ON jf.cs_sold_date_sk = d1.d_date_sk JOIN filtered_customer_demographics cd ON jf.cs_bill_cdemo_sk = cd.cd_demo_sk JOIN filtered_household_demographics hd ON jf.cs_bill_hdemo_sk = hd.hd_demo_sk LEFT OUTER JOIN promotion p ON jf.cs_promo_sk = p.p_promo_sk LEFT OUTER JOIN catalog_returns cr ON jf.cs_item_sk = cr.cr_item_sk AND jf.cs_order_number = cr.cr_order_number GROUP BY i.i_item_desc, w.w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i.i_item_desc, w.w_warehouse_name, d1.d_week_seq LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same grouping and aggregation"
      ],
      "expected_speedup": "2.5x",
      "risk": "medium"
    },
    {
      "id": "rs_02",
      "transform": "dimension_cte_isolate",
      "nodes": {
        "filtered_item": "SELECT i_item_sk, i_item_desc FROM item",
        "filtered_warehouse": "SELECT w_warehouse_sk, w_warehouse_name FROM warehouse",
        "filtered_customer_demographics": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'D'",
        "filtered_household_demographics": "SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '>10000'",
        "filtered_d1_dates": "SELECT d_date_sk, d_week_seq FROM date_dim WHERE d_year = 1999",
        "filtered_d2_dates": "SELECT d_date_sk, d_week_seq FROM date_dim",
        "filtered_d3_dates": "SELECT d_date_sk, d_date FROM date_dim",
        "catalog_sales_pre": "SELECT cs_item_sk, cs_order_number, cs_bill_cdemo_sk, cs_bill_hdemo_sk, cs_sold_date_sk, cs_ship_date_sk, cs_quantity, cs_promo_sk FROM catalog_sales JOIN filtered_d1_dates d1 ON cs_sold_date_sk = d1.d_date_sk JOIN filtered_d3_dates d3 ON cs_ship_date_sk = d3.d_date_sk WHERE d3.d_date > d1.d_date + 5",
        "inventory_pre": "SELECT inv_item_sk, inv_warehouse_sk, inv_quantity_on_hand, inv_date_sk FROM inventory",
        "main_query": "SELECT i.i_item_desc, w.w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p.p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p.p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales_pre cs JOIN inventory_pre inv ON cs.cs_item_sk = inv.inv_item_sk AND EXISTS (SELECT 1 FROM filtered_d1_dates d1, filtered_d2_dates d2 WHERE cs.cs_sold_date_sk = d1.d_date_sk AND inv.inv_date_sk = d2.d_date_sk AND d1.d_week_seq = d2.d_week_seq) JOIN filtered_item i ON cs.cs_item_sk = i.i_item_sk JOIN filtered_warehouse w ON inv.inv_warehouse_sk = w.w_warehouse_sk JOIN filtered_customer_demographics cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk JOIN filtered_household_demographics hd ON cs.cs_bill_hdemo_sk = hd.hd_demo_sk LEFT OUTER JOIN promotion p ON cs.cs_promo_sk = p.p_promo_sk LEFT OUTER JOIN catalog_returns cr ON cs.cs_item_sk = cr.cr_item_sk AND cs.cs_order_number = cr.cr_order_number WHERE inv.inv_quantity_on_hand < cs.cs_quantity GROUP BY i.i_item_desc, w.w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i.i_item_desc, w.w_warehouse_name, d1.d_week_seq LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same grouping and aggregation"
      ],
      "expected_speedup": "1.8x",
      "risk": "low"
    }
  ],
  "explanation": "Applied two complementary optimizations: 1) Multi-date CTE isolation to pre-filter date_dim for d1 (1999), pre-join inventory with date_dim d2, and pre-join catalog_sales with date_dim d1 and d3 with the date comparison condition. This reduces the fact tables early. 2) Dimension CTE isolation to pre-filter customer_demographics and household_demographics, and create lightweight CTEs for item and warehouse. The joins are restructured to apply filters early while maintaining all original semantics."
}
```