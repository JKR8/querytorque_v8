FAILURE_ANALYSIS:
All workers attempted predicate pushdown and CTE isolation but missed the core bottleneck: the query requires 6 self-joins on year_total (3 channels × 2 years) with complex ratio comparisons. Worker 1's modest gains (1.54x) came from reducing initial row counts but still performed massive self-joins on the union result. Worker 2's regression (0.97x) stemmed from isolating date filtering without addressing the join explosion. Worker 3's split-by-year approach (1.24x) reduced union size but still performed redundant customer joins across channels. Worker 4's single-pass aggregation failed due to improper column references and ambiguous joins from CROSS JOIN + OR conditions. Worker 5 repeated Worker 3's approach. The fundamental issue is the quadratic explosion from self-joining a pre-aggregated union where most customers won't meet all three channel requirements.

UNEXPLORED_OPPORTUNITIES:
1. **Pre-aggregate with early pruning**: Compute channel-year aggregates separately, then immediately filter to only customers with positive 1999 sales across all three channels before performing ratio comparisons.
2. **Materialize intersection first**: Use INTERSECT to find customers with all three channels in 1999, then compute their 2000 values only for that subset.
3. **Pivot aggregation**: Use conditional aggregation within each year to create three channel columns per customer-year, eliminating the need for self-joins.
4. **Leverage DuckDB's struct or map types**: Group by customer once with MAP_AGG or STRUCT to collect channel-year totals in a single pass.
5. **Window function for ratios**: Compute growth ratios within each channel using LAG, then filter directly without self-joins.

REFINED_STRATEGY:
Create three separate CTEs for store, catalog, and web sales, each aggregating both years (1999, 2000) in a single pass with conditional aggregation. Then join these three CTEs on customer_id (1 join per channel instead of 6 self-joins). Apply positive 1999 filters and ratio comparisons directly in the final WHERE clause. This reduces the join complexity from O(n²) to O(n), eliminates the massive UNION ALL, and minimizes repeated customer table scans.

EXAMPLES: single_pass_aggregation, early_filter, dimension_cte_isolate, pushdown
HINT: Transform the three UNION ALL branches into three separate CTEs where each aggregates both 1999 and 2000 totals using conditional SUM(CASE WHEN d_year=...). Then join these three CTEs once and apply all filters. Pre-filter date_dim and customer early.