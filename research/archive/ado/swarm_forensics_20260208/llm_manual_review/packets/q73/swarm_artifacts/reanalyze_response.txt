FAILURE_ANALYSIS:
All workers relied heavily on dimension-table pre-filtering CTEs, which DuckDB's optimizer already implements automatically through predicate pushdown and join reordering. The minimal speedups (1.02x-1.12x) indicate:
1. **Overhead of forced CTE materialization**: DuckDB's optimizer is already pushing filters down; materializing filtered dimension tables adds unnecessary intermediate result spooling without reducing the main bottleneck—the massive store_sales fact table.
2. **Missing fact-table reduction**: None of the attempts aggressively reduce store_sales rows BEFORE joins. The filters on date, store, and household_demographics are selective, but store_sales is still scanned entirely before applying join conditions.
3. **Inefficient OR handling**: Worker 4's UNION ALL for hd_buy_potential added overhead without benefit—the condition is low-selectivity on a small dimension table.
4. **Group-by cardinality unchanged**: All attempts perform aggregation on the same (ss_ticket_number, ss_customer_sk) combination after full joins, missing opportunities to pre-aggregate fact data using dimension keys.

UNEXPLORED_OPPORTUNITIES:
1. **Early fact-table pruning**: Use dimension keys to filter store_sales via semi-joins or bloom filters before the main join.
2. **Two-phase aggregation**: Pre-aggregate store_sales by dimension-compatible keys (ss_sold_date_sk, ss_store_sk, ss_hdemo_sk), then join to dimension tables for final grouping.
3. **Materialized bitmask filtering**: Pre-compute qualifying dimension keys and use them as a filter condition directly on store_sales.
4. **Lateral join pattern**: Use a correlated subquery to filter store_sales rows per qualifying dimension combination.
5. **Aggregation pushdown into join**: Perform counting during the join process rather than after full materialization.

REFINED_STRATEGY:
Implement **fact-first two-phase aggregation**:
1. Pre-compute qualifying dimension key sets as integer arrays.
2. Use these arrays to filter store_sales via IN-list predicates before any joins.
3. Perform partial aggregation on store_sales using dimension foreign keys.
4. Complete the aggregation after lightweight dimension lookups.
This reduces the fact table scan cost and avoids materializing large intermediate joins.

EXAMPLES: single_pass_aggregation, prefetch_fact_join, pushdown
HINT: Use ARRAY_AGG to create dimension key lists, apply store_sales filtering via IN predicates, perform GROUP BY on dimension FKs first, then join to dimension tables for final grouping and customer lookup. Avoid CTEs for dimension filtering—use subqueries to force early filter application.