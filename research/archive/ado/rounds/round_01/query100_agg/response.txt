```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "dsb_self_join_decomposition",
      "nodes": {
        "node_id": "main_query",
        "sql": "WITH filtered_base AS (\n    SELECT ss.ss_ticket_number, ss.ss_item_sk, ss.ss_list_price\n    FROM store_sales ss\n    JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk\n    JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk\n    JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk\n    JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk\n    WHERE d.d_year BETWEEN 2000 AND 2000 + 1\n      AND cd.cd_marital_status = 'S'\n      AND cd.cd_education_status = 'Secondary'\n      AND ss.ss_list_price BETWEEN 16 AND 30\n),\nitem1_filtered AS (\n    SELECT fb.ss_ticket_number, i.i_item_sk\n    FROM filtered_base fb\n    JOIN item i ON fb.ss_item_sk = i.i_item_sk\n    WHERE i.i_category IN ('Electronics', 'Men')\n),\nitem2_filtered AS (\n    SELECT fb.ss_ticket_number, i.i_item_sk\n    FROM filtered_base fb\n    JOIN item i ON fb.ss_item_sk = i.i_item_sk\n    WHERE i.i_manager_id BETWEEN 81 AND 100\n)\nSELECT i1.i_item_sk, i2.i_item_sk, COUNT(*) AS cnt\nFROM item1_filtered i1\nJOIN item2_filtered i2 ON i1.ss_ticket_number = i2.ss_ticket_number\nWHERE i1.i_item_sk < i2.i_item_sk\nGROUP BY i1.i_item_sk, i2.i_item_sk\nORDER BY cnt"
      },
      "invariants_kept": [
        "output_columns: i_item_sk, i_item_sk, cnt",
        "grain: i_item_sk, i_item_sk", 
        "semantics: same store_sales pairs filtered by date, customer demographics, item categories, manager ID, and price",
        "ordering: cnt"
      ],
      "expected_speedup": "3x",
      "risk": "medium"
    },
    {
      "id": "rs_02",
      "transform": "early_filter",
      "nodes": {
        "node_id": "main_query",
        "sql": "SELECT item1.i_item_sk, item2.i_item_sk, COUNT(*) AS cnt\nFROM (\n    SELECT ss_ticket_number, ss_item_sk\n    FROM store_sales ss\n    JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk\n    WHERE d.d_year BETWEEN 2000 AND 2000 + 1\n      AND ss.ss_list_price BETWEEN 16 AND 30\n      AND EXISTS (\n          SELECT 1\n          FROM customer c\n          JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk\n          JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk\n          WHERE ss.ss_customer_sk = c.c_customer_sk\n            AND cd.cd_marital_status = 'S'\n            AND cd.cd_education_status = 'Secondary'\n      )\n) s1\nJOIN (\n    SELECT ss_ticket_number, ss_item_sk\n    FROM store_sales ss\n    WHERE ss.ss_list_price BETWEEN 16 AND 30\n) s2 ON s1.ss_ticket_number = s2.ss_ticket_number\nJOIN item item1 ON s1.ss_item_sk = item1.i_item_sk\nJOIN item item2 ON s2.ss_item_sk = item2.i_item_sk\nWHERE item1.i_item_sk < item2.i_item_sk\n  AND item1.i_category IN ('Electronics', 'Men')\n  AND item2.i_manager_id BETWEEN 81 AND 100\nGROUP BY item1.i_item_sk, item2.i_item_sk\nORDER BY cnt"
      },
      "invariants_kept": [
        "output_columns: i_item_sk, i_item_sk, cnt",
        "grain: i_item_sk, i_item_sk",
        "semantics: same filters applied"
      ],
      "expected_speedup": "1.5x",
      "risk": "low"
    }
  ],
  "explanation": "Applied two complementary rewrites: 1) DSB_SELF_JOIN_DECOMPOSITION pattern breaks the self-join into separate filtered CTEs, allowing each item filter to be applied early and reducing the self-join cross product. 2) EARLY_FILTER pushes date and customer filters into subqueries, reducing rows before the expensive self-join. Both preserve all original filters exactly (Electronics/Men category, manager_id 81-100, marital status 'S', education 'Secondary', year 2000-2001, price 16-30). The first rewrite is more aggressive but follows the proven DSB pattern for items-sold-together queries."
}
```