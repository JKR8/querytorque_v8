Looking at this query, I can see several optimization opportunities:

1. **Correlated subquery** in main_query that computes AVG(ctr_total_return) per state
2. **Multiple filters applied after aggregation** that could be pushed down
3. **Date dimension filter** that could be isolated early

The key insight is that the correlated subquery with aggregation can be pre-computed, and filters should be pushed into the CTE where possible.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "semantic_rewrite",
      "nodes": {
        "main_query": "WITH date_cte AS (\n    SELECT d_date_sk FROM date_dim WHERE d_year = 1998\n),\nfiltered_web_returns AS (\n    SELECT \n        wr_returning_customer_sk,\n        ca_state,\n        wr_reason_sk,\n        wr_return_amt\n    FROM web_returns\n    INNER JOIN date_cte ON wr_returned_date_sk = date_cte.d_date_sk\n    INNER JOIN customer_address ON wr_returning_addr_sk = ca_address_sk\n    INNER JOIN item ON wr_item_sk = i_item_sk\n    WHERE i_manager_id BETWEEN 17 AND 26\n      AND wr_return_amt / wr_return_quantity BETWEEN 25 AND 54\n      AND ca_state IN ('IL', 'LA', 'MN', 'SC')\n      AND wr_reason_sk IN (50, 73)\n),\ncustomer_total_return AS (\n    SELECT \n        wr_returning_customer_sk AS ctr_customer_sk,\n        ca_state AS ctr_state,\n        wr_reason_sk AS ctr_reason_sk,\n        SUM(wr_return_amt) AS ctr_total_return\n    FROM filtered_web_returns\n    GROUP BY wr_returning_customer_sk, ca_state, wr_reason_sk\n),\nstate_avg AS (\n    SELECT \n        ctr_state,\n        AVG(ctr_total_return) * 1.2 AS threshold\n    FROM customer_total_return\n    GROUP BY ctr_state\n)\nSELECT \n    c_customer_id,\n    c_salutation,\n    c_first_name,\n    c_last_name,\n    c_preferred_cust_flag,\n    c_birth_day,\n    c_birth_month,\n    c_birth_year,\n    c_birth_country,\n    c_login,\n    c_email_address,\n    c_last_review_date_sk,\n    ctr_total_return\nFROM customer_total_return ctr1\nINNER JOIN state_avg ON ctr1.ctr_state = state_avg.ctr_state\nINNER JOIN customer ON ctr1.ctr_customer_sk = c_customer_sk\nINNER JOIN customer_address ON ca_address_sk = c_current_addr_sk\nWHERE ctr1.ctr_total_return > state_avg.threshold\n  AND c_birth_year BETWEEN 1961 AND 1967\nORDER BY \n    c_customer_id,\n    c_salutation,\n    c_first_name,\n    c_last_name,\n    c_preferred_cust_flag,\n    c_birth_day,\n    c_birth_month,\n    c_birth_year,\n    c_birth_country,\n    c_login,\n    c_email_address,\n    c_last_review_date_sk,\n    ctr_total_return\nLIMIT 100"
      },
      "invariants_kept": [
        "Same output columns and order",
        "Same aggregation logic (SUM)",
        "Same filter values (1998, 17-26, 25-54, 'IL','LA','MN','SC', 50,73, 1961-1967)",
        "Same grouping keys",
        "Same correlation logic (state-level comparison)"
      ],
      "expected_speedup": "3x",
      "risk": "low"
    }
  ],
  "explanation": "Applied three key optimizations: 1) Isolated date filter into CTE for early reduction, 2) Pushed state and reason filters before aggregation to reduce data volume, 3) Decorrelated subquery by pre-computing state averages in a separate CTE. This eliminates the correlated subquery execution per row and reduces data early through predicate pushdown."
}
```

**Key changes made:**

1. **Date CTE Isolation**: Created `date_cte` to filter `date_dim` early (QT-OPT-003)
2. **Predicate Pushdown**: Moved `ca_state IN ('IL', 'LA', 'MN', 'SC')` and `wr_reason_sk IN (50, 73)` into the base table scan before aggregation
3. **Decorrelate Subquery**: Converted the correlated subquery into a `state_avg` CTE that computes per-state thresholds once, then joins

**Why this should be faster:**
- Reduces data volume before expensive aggregation
- Eliminates NÂ² behavior of correlated subquery
- Allows better join ordering and indexing opportunities
- Filters selective dimension tables early

**Semantic Preservation:**
- All literal values preserved exactly (LITERAL_PRESERVATION)
- Aggregation logic unchanged
- Output columns and ordering identical
- Grouping keys preserved
- All original filters applied (just moved earlier)