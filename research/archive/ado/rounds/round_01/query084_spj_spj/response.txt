```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "early_filter",
      "nodes": {
        "main_query": "WITH filtered_customer_address AS (\n    SELECT ca_address_sk\n    FROM customer_address\n    WHERE ca_city = 'Lakeview'\n),\nfiltered_income_band AS (\n    SELECT ib_income_band_sk\n    FROM income_band\n    WHERE ib_lower_bound >= 7 * 10000\n      AND ib_upper_bound <= 7 * 10000 + 50000\n)\nSELECT MIN(c_customer_id), MIN(sr_ticket_number), MIN(sr_item_sk)\nFROM customer\nJOIN filtered_customer_address ON c_current_addr_sk = ca_address_sk\nJOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk\nJOIN household_demographics ON hd_demo_sk = c_current_hdemo_sk\nJOIN filtered_income_band ON ib_income_band_sk = hd_income_band_sk\nJOIN store_returns ON sr_cdemo_sk = cd_demo_sk"
      },
      "invariants_kept": [
        "output columns: MIN(c_customer_id), MIN(sr_ticket_number), MIN(sr_item_sk)",
        "all original join conditions and filters are preserved",
        "literal values preserved exactly"
      ],
      "expected_speedup": "2x",
      "risk": "low"
    }
  ],
  "explanation": "Applied early filtering on dimension tables with selective predicates (customer_address on city='Lakeview' and income_band on income range). This reduces the rows joined into the main query, especially important for the large store_returns fact table. The rewrite preserves all original semantics while potentially changing join order to filter-first execution."
}
```