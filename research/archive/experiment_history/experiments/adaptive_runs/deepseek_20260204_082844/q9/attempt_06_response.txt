Looking at the query pattern, I can see the main issue: the query has 5 separate CTEs that all scan the `store_sales` table with different quantity ranges, and the main query uses scalar subqueries to access each CTE's results. This causes 5 separate full scans of the `store_sales` table.

However, the allowed transforms don't include `materialize_cte`. Looking at the execution plan, I see that all 5 CTEs are being computed independently with sequential scans. The key insight is that we can combine these scans into a single pass over the `store_sales` table using conditional aggregation.

Let me use the `semantic_rewrite` transform to combine all 5 quantity range aggregations into a single scan:

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "semantic_rewrite",
      "nodes": {
        "quantity_range_1": "SELECT COUNT(*) AS cnt_1_20, AVG(ss_ext_sales_price) AS avg_ext_1_20, AVG(ss_net_profit) AS avg_net_1_20 FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20",
        "quantity_range_2": "SELECT COUNT(*) AS cnt_21_40, AVG(ss_ext_sales_price) AS avg_ext_21_40, AVG(ss_net_profit) AS avg_net_21_40 FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40",
        "quantity_range_3": "SELECT COUNT(*) AS cnt_41_60, AVG(ss_ext_sales_price) AS avg_ext_41_60, AVG(ss_net_profit) AS avg_net_41_60 FROM store_sales WHERE ss_quantity BETWEEN 41 AND 60",
        "quantity_range_4": "SELECT COUNT(*) AS cnt_61_80, AVG(ss_ext_sales_price) AS avg_ext_61_80, AVG(ss_net_profit) AS avg_net_61_80 FROM store_sales WHERE ss_quantity BETWEEN 61 AND 80",
        "quantity_range_5": "SELECT COUNT(*) AS cnt_81_100, AVG(ss_ext_sales_price) AS avg_ext_81_100, AVG(ss_net_profit) AS avg_net_81_100 FROM store_sales WHERE ss_quantity BETWEEN 81 AND 100",
        "main_query": "WITH all_ranges AS (SELECT COUNT(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 END) AS cnt_1_20, AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_ext_sales_price END) AS avg_ext_1_20, AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_net_profit END) AS avg_net_1_20, COUNT(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN 1 END) AS cnt_21_40, AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_ext_sales_price END) AS avg_ext_21_40, AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_net_profit END) AS avg_net_21_40, COUNT(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN 1 END) AS cnt_41_60, AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_ext_sales_price END) AS avg_ext_41_60, AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_net_profit END) AS avg_net_41_60, COUNT(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN 1 END) AS cnt_61_80, AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_ext_sales_price END) AS avg_ext_61_80, AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_net_profit END) AS avg_net_61_80, COUNT(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN 1 END) AS cnt_81_100, AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_ext_sales_price END) AS avg_ext_81_100, AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_net_profit END) AS avg_net_81_100 FROM store_sales) SELECT CASE WHEN cnt_1_20 > 2972190 THEN avg_ext_1_20 ELSE avg_net_1_20 END AS bucket1, CASE WHEN cnt_21_40 > 4505785 THEN avg_ext_21_40 ELSE avg_net_21_40 END AS bucket2, CASE WHEN cnt_41_60 > 1575726 THEN avg_ext_41_60 ELSE avg_net_41_60 END AS bucket3, CASE WHEN cnt_61_80 > 3188917 THEN avg_ext_61_80 ELSE avg_net_61_80 END AS bucket4, CASE WHEN cnt_81_100 > 3525216 THEN avg_ext_81_100 ELSE avg_net_81_100 END AS bucket5 FROM all_ranges, reason WHERE r_reason_sk = 1"
      },
      "invariants_kept": [
        "same result rows",
        "same aggregation results",
        "same output columns",
        "required predicate r_reason_sk = 1 preserved"
      ],
      "expected_speedup": "3.0x",
      "risk": "low"
    }
  ],
  "explanation": "Combined all 5 separate CTE scans of store_sales into a single scan with conditional aggregation. Instead of scanning the store_sales table 5 times (once for each quantity range), we now scan it once and compute all aggregations in parallel using CASE expressions. This reduces I/O from 5 full table scans to 1 full table scan while computing the same results."
}
```