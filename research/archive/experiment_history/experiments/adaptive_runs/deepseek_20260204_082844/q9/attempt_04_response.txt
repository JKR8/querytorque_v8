Looking at the query and execution plan, I can see the main issue: there are 10 separate scans of the `store_sales` table (5 for counts, 5 for averages), each with different quantity range filters. This is extremely inefficient. The query computes the same quantity range aggregations multiple times.

The key insight is that we can compute all the necessary aggregates (counts and averages for both price and profit) for all quantity ranges in a single scan of the `store_sales` table, then use those pre-computed aggregates in the CASE expressions.

**Optimization Strategy:** Use `pushdown` to compute all aggregates in a single CTE, then reference them in the main query. This eliminates 9 redundant table scans.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "pushdown",
      "nodes": {
        "store_sales_aggregates": "SELECT \n  COUNT(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 END) as cnt_1_20,\n  AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_ext_sales_price END) as avg_price_1_20,\n  AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_net_profit END) as avg_profit_1_20,\n  COUNT(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN 1 END) as cnt_21_40,\n  AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_ext_sales_price END) as avg_price_21_40,\n  AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_net_profit END) as avg_profit_21_40,\n  COUNT(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN 1 END) as cnt_41_60,\n  AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_ext_sales_price END) as avg_price_41_60,\n  AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_net_profit END) as avg_profit_41_60,\n  COUNT(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN 1 END) as cnt_61_80,\n  AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_ext_sales_price END) as avg_price_61_80,\n  AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_net_profit END) as avg_profit_61_80,\n  COUNT(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN 1 END) as cnt_81_100,\n  AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_ext_sales_price END) as avg_price_81_100,\n  AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_net_profit END) as avg_profit_81_100\nFROM store_sales",
        "main_query": "SELECT \n  CASE WHEN (SELECT cnt_1_20 FROM store_sales_aggregates) > 2972190 \n       THEN (SELECT avg_price_1_20 FROM store_sales_aggregates) \n       ELSE (SELECT avg_profit_1_20 FROM store_sales_aggregates) \n  END AS bucket1,\n  CASE WHEN (SELECT cnt_21_40 FROM store_sales_aggregates) > 4505785 \n       THEN (SELECT avg_price_21_40 FROM store_sales_aggregates) \n       ELSE (SELECT avg_profit_21_40 FROM store_sales_aggregates) \n  END AS bucket2,\n  CASE WHEN (SELECT cnt_41_60 FROM store_sales_aggregates) > 1575726 \n       THEN (SELECT avg_price_41_60 FROM store_sales_aggregates) \n       ELSE (SELECT avg_profit_41_60 FROM store_sales_aggregates) \n  END AS bucket3,\n  CASE WHEN (SELECT cnt_61_80 FROM store_sales_aggregates) > 3188917 \n       THEN (SELECT avg_price_61_80 FROM store_sales_aggregates) \n       ELSE (SELECT avg_profit_61_80 FROM store_sales_aggregates) \n  END AS bucket4,\n  CASE WHEN (SELECT cnt_81_100 FROM store_sales_aggregates) > 3525216 \n       THEN (SELECT avg_price_81_100 FROM store_sales_aggregates) \n       ELSE (SELECT avg_profit_81_100 FROM store_sales_aggregates) \n  END AS bucket5\nFROM reason \nWHERE r_reason_sk = 1"
      },
      "invariants_kept": [
        "same result rows",
        "same aggregation results",
        "same output columns",
        "required predicate r_reason_sk = 1 preserved"
      ],
      "expected_speedup": "3.0x",
      "risk": "low"
    }
  ],
  "explanation": "Replaced 10 separate scans of store_sales table with a single scan that computes all required aggregates (counts and averages for both price and profit across all 5 quantity ranges) in one pass. The main query then references these pre-computed aggregates. This reduces I/O from 10 table scans to 1, dramatically improving performance while maintaining identical results."
}
```