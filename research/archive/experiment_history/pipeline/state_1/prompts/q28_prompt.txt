You are an autonomous Query Rewrite Engine. Your goal is to maximize execution speed while strictly preserving semantic invariants.

RULES:
- Maximize execution speed while preserving semantic invariants (output columns, grain, total result rows).
- Group dependent changes into a single rewrite_set.
- Use descriptive CTE names (e.g., `filtered_returns` not `cte1`).
- If a standard SQL optimization applies that is not in the allowed list, label it "semantic_rewrite".

ALLOWED TRANSFORMS: pushdown, decorrelate, or_to_union, early_filter, date_cte_isolate, materialize_cte, flatten_subquery, reorder_join, multi_push_predicate, inline_cte, remove_redundant, semantic_rewrite

---
## Query Structure

### DAG Topology
```
  [main_query] type=main tables=[store_sales, store_sales, store_sales, store_sales, store_sales] 
```

### Target Nodes
[main_query]

### SQL
[main_query] type=main
```sql
SELECT
  *
FROM (
  SELECT
    AVG(ss_list_price) AS B1_LP,
    COUNT(ss_list_price) AS B1_CNT,
    COUNT(DISTINCT ss_list_price) AS B1_CNTD
  FROM store_sales
  WHERE
    ss_quantity BETWEEN 0 AND 5
    AND (
      ss_list_price BETWEEN 131 AND 131 + 10
      OR ss_coupon_amt BETWEEN 16798 AND 16798 + 1000
      OR ss_wholesale_cost BETWEEN 25 AND 25 + 20
    )
) AS B1, (
  SELECT
    AVG(ss_list_price) AS B2_LP,
    COUNT(ss_list_price) AS B2_CNT,
    COUNT(DISTINCT ss_list_price) AS B2_CNTD
  FROM store_sales
  WHERE
    ss_quantity BETWEEN 6 AND 10
    AND (
      ss_list_price BETWEEN 145 AND 145 + 10
      OR ss_coupon_amt BETWEEN 14792 AND 14792 + 1000
      OR ss_wholesale_cost BETWEEN 46 AND 46 + 20
    )
) AS B2, (
  SELECT
    AVG(ss_list_price) AS B3_LP,
    COUNT(ss_list_price) AS B3_CNT,
    COUNT(DISTINCT ss_list_price) AS B3_CNTD
  FROM store_sales
  WHERE
    ss_quantity BETWEEN 11 AND 15
    AND (
      ss_list_price BETWEEN 150 AND 150 + 10
      OR ss_coupon_amt BETWEEN 6600 AND 6600 + 1000
      OR ss_wholesale_cost BETWEEN 9 AND 9 + 20
    )
) AS B3, (
  SELECT
    AVG(ss_list_price) AS B4_LP,
    COUNT(ss_list_price) AS B4_CNT,
    COUNT(DISTINCT ss_list_price) AS B4_CNTD
  FROM store_sales
  WHERE
    ss_quantity BETWEEN 16 AND 20
    AND (
      ss_list_price BETWEEN 91 AND 91 + 10
      OR ss_coupon_amt BETWEEN 13493 AND 13493 + 1000
      OR ss_wholesale_cost BETWEEN 36 AND 36 + 20
    )
) AS B4, (
  SELECT
    AVG(ss_list_price) AS B5_LP,
    COUNT(ss_list_price) AS B5_CNT,
    COUNT(DISTINCT ss_list_price) AS B5_CNTD
  FROM store_sales
  WHERE
    ss_quantity BETWEEN 21 AND 25
    AND (
      ss_list_price BETWEEN 0 AND 0 + 10
      OR ss_coupon_amt BETWEEN 7629 AND 7629 + 1000
      OR ss_wholesale_cost BETWEEN 6 AND 6 + 20
    )
) AS B5, (
  SELECT
    AVG(ss_list_price) AS B6_LP,
    COUNT(ss_list_price) AS B6_CNT,
    COUNT(DISTINCT ss_list_price) AS B6_CNTD
  FROM store_sales
  WHERE
    ss_quantity BETWEEN 26 AND 30
    AND (
      ss_list_price BETWEEN 89 AND 89 + 10
      OR ss_coupon_amt BETWEEN 15257 AND 15257 + 1000
      OR ss_wholesale_cost BETWEEN 31 AND 31 + 20
    )
) AS B6
LIMIT 100
```

### Contracts
[main_query]:
  output_columns: ['*']

### Downstream Usage
No usage data.

---
## Performance Profile

### Cost Attribution
[main_query]: 92.3% cost, ~1375330 rows, ops=[SEQ_SCAN[store_sales], SEQ_SCAN[store_sales], SEQ_SCAN[store_sales]]

### Execution Plan
```
Operators by cost:
- SEQ_SCAN(store_sales): 62.9% cost, 1,374,872 rows
- SEQ_SCAN(store_sales): 4.8% cost, 1,373,928 rows
- SEQ_SCAN(store_sales): 4.5% cost, 1,375,330 rows
- SEQ_SCAN(store_sales): 4.4% cost, 1,375,150 rows
- SEQ_SCAN(store_sales): 4.4% cost, 1,374,086 rows

Scans:
- store_sales x6: 345,611,892 → 1,375,330 rows (filtered)
```

### Optimization Opportunities
1. **QT-OPT-001** - OR to UNION ALL Decomposition
  Trigger: OR conditions spanning different columns (col_a = X OR col_b = Y)
  Rewrite: Split into separate SELECTs with UNION ALL, add exclusion predicates to avoid duplicates
   Matched: OR condition in WHERE clause

2. **QT-OPT-007** - Materialize Repeated Subquery
  Trigger: Same subquery pattern appears multiple times in query
  Rewrite: Extract to CTE with MATERIALIZED hint, reference by name
   Matched: Repeated subquery pattern

OR_TO_UNION: [main_query] has OR condition
  Fix: Split into UNION ALL branches
  Expected: 2x speedup (verified Q15: 2.98x)

---
## Previous Attempts

- baseline: 1.00x [none] NEUTRAL
- kimi: 1.33x [none] WIN
- v2_standard: 1.00x [semantic_rewrite] NEUTRAL
- dsr1: 0.92x [semantic_rewrite] REGRESSION

**Regression**: semantic_rewrite

**Recommended patterns** (details in Examples section below):
- **single_pass_aggregation** (4.47x) — Consolidate multiple subqueries scanning the same table into a single CTE with conditional aggregates.
- **pushdown** (2.11x) — Push filters from outer query into CTEs/subqueries to reduce intermediate result sizes.

---
## Examples (Verified Patterns)

## Example: Single Pass Aggregation (SINGLE_PASS_AGGREGATION)
Verified speedup: 4.47x
Benchmark: Q9

### Original SQL:
```sql
select case when (select count(*) 
                  from store_sales 
                  where ss_quantity between 1 and 20) > 2972190
            then (select avg(ss_ext_sales_price) 
                  from store_sales 
                  where ss_quantity between 1 and 20) 
            else (select avg(ss_net_profit)
                  from store_sales
                  where ss_quantity between 1 and 20) end bucket1 ,
       case when (select count(*)
                  from store_sales
                  where ss_quantity between 21 and 40) > 4505785
            then (select avg(ss_ext_sales_price)
                  from store_sales
                  where ss_quantity between 21 and 40) 
            else (select avg(ss_net_profit)
                  from store_sales
                  where ss_quantity between 21 and 40) end bucket2,
       case when (select count(*)
                  from store_sales
                  where ss_quantity between 41 and 60) > 1575726
            then (select avg(ss_ext_sales_price)
                  from store_sales
                  where ss_quantity between 41 and 60)
            else (select avg(ss_net_profit)
                  from store_sales
                  where ss_quantity between 41 and 60) end bucket3,
       case when (select count(*)
                  from store_sales
                  where ss_quantity between 61 and 80) > 3188917
            then (select avg(ss_ext_sales_price)
                  from store_sales
                  where ss_quantity between 61 and 80)
            else (select avg(ss_net_profit)
                  from store_sales
                  where ss_quantity between 61 and 80) end bucket4,
       case when (select count(*)
                  from store_sales
                  where ss_quantity between 81 and 100) > 3525216
            then (select avg(ss_ext_sales_price)
                  from store_sales
                  where ss_quantity between 81 and 100)
            else (select avg(ss_net_profit)
                  from store_sales
                  where ss_quantity between 81 and 100) end bucket5
from reason
where r_reason_sk = 1;
```

### Optimized SQL:
```sql
WITH sales_stats AS (SELECT COUNT(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 END) AS cnt1, AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_ext_sales_price END) AS avg_price1, AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_net_profit END) AS avg_profit1, COUNT(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN 1 END) AS cnt2, AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_ext_sales_price END) AS avg_price2, AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_net_profit END) AS avg_profit2, COUNT(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN 1 END) AS cnt3, AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_ext_sales_price END) AS avg_price3, AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_net_profit END) AS avg_profit3, COUNT(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN 1 END) AS cnt4, AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_ext_sales_price END) AS avg_price4, AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_net_profit END) AS avg_profit4, COUNT(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN 1 END) AS cnt5, AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_ext_sales_price END) AS avg_price5, AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_net_profit END) AS avg_profit5 FROM store_sales)
SELECT CASE WHEN s.cnt1 > 2972190 THEN s.avg_price1 ELSE s.avg_profit1 END AS bucket1, CASE WHEN s.cnt2 > 4505785 THEN s.avg_price2 ELSE s.avg_profit2 END AS bucket2, CASE WHEN s.cnt3 > 1575726 THEN s.avg_price3 ELSE s.avg_profit3 END AS bucket3, CASE WHEN s.cnt4 > 3188917 THEN s.avg_price4 ELSE s.avg_profit4 END AS bucket4, CASE WHEN s.cnt5 > 3525216 THEN s.avg_price5 ELSE s.avg_profit5 END AS bucket5 FROM reason AS r, sales_stats AS s WHERE r.r_reason_sk = 1;
```

**Key insight:** Multiple scalar subqueries with different filter conditions on the same table can be consolidated into a single CTE using conditional CASE expressions inside aggregates. Reduces N scans to 1 scan.


## Example: Filter Pushdown (PUSHDOWN)
Verified speedup: 2.11x
Benchmark: Q9

### Original SQL:
```sql
select case when (select count(*) 
                  from store_sales 
                  where ss_quantity between 1 and 20) > 2972190
            then (select avg(ss_ext_sales_price) 
                  from store_sales 
                  where ss_quantity between 1 and 20) 
            else (select avg(ss_net_profit)
                  from store_sales
                  where ss_quantity between 1 and 20) end bucket1 ,
       case when (select count(*)
                  from store_sales
                  where ss_quantity between 21 and 40) > 4505785
            then (select avg(ss_ext_sales_price)
                  from store_sales
                  where ss_quantity between 21 and 40) 
            else (select avg(ss_net_profit)
                  from store_sales
                  where ss_quantity between 21 and 40) end bucket2,
       case when (select count(*)
                  from store_sales
                  where ss_quantity between 41 and 60) > 1575726
            then (select avg(ss_ext_sales_price)
                  from store_sales
                  where ss_quantity between 41 and 60)
            else (select avg(ss_net_profit)
                  from store_sales
                  where ss_quantity between 41 and 60) end bucket3,
       case when (select count(*)
                  from store_sales
                  where ss_quantity between 61 and 80) > 3188917
            then (select avg(ss_ext_sales_price)
                  from store_sales
                  where ss_quantity between 61 and 80)
            else (select avg(ss_net_profit)
                  from store_sales
                  where ss_quantity between 61 and 80) end bucket4,
       case when (select count(*)
                  from store_sales
                  where ss_quantity between 81 and 100) > 3525216
            then (select avg(ss_ext_sales_price)
                  from store_sales
                  where ss_quantity between 81 and 100)
            else (select avg(ss_net_profit)
                  from store_sales
                  where ss_quantity between 81 and 100) end bucket5
from reason
where r_reason_sk = 1;
```

### Optimized SQL:
```sql
WITH quantity_aggregations AS (SELECT CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 WHEN ss_quantity BETWEEN 21 AND 40 THEN 2 WHEN ss_quantity BETWEEN 41 AND 60 THEN 3 WHEN ss_quantity BETWEEN 61 AND 80 THEN 4 WHEN ss_quantity BETWEEN 81 AND 100 THEN 5 END AS bucket, COUNT(*) AS cnt, AVG(ss_ext_discount_amt) AS avg_disc, AVG(ss_net_paid) AS avg_net FROM store_sales WHERE ss_quantity BETWEEN 1 AND 100 GROUP BY CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 WHEN ss_quantity BETWEEN 21 AND 40 THEN 2 WHEN ss_quantity BETWEEN 41 AND 60 THEN 3 WHEN ss_quantity BETWEEN 61 AND 80 THEN 4 WHEN ss_quantity BETWEEN 81 AND 100 THEN 5 END)
SELECT CASE WHEN q1.cnt > 74129 THEN q1.avg_disc ELSE q1.avg_net END AS bucket1, CASE WHEN q2.cnt > 122840 THEN q2.avg_disc ELSE q2.avg_net END AS bucket2, CASE WHEN q3.cnt > 56580 THEN q3.avg_disc ELSE q3.avg_net END AS bucket3, CASE WHEN q4.cnt > 10097 THEN q4.avg_disc ELSE q4.avg_net END AS bucket4, CASE WHEN q5.cnt > 165306 THEN q5.avg_disc ELSE q5.avg_net END AS bucket5 FROM reason CROSS JOIN (SELECT cnt, avg_disc, avg_net FROM quantity_aggregations WHERE bucket = 1) AS q1 CROSS JOIN (SELECT cnt, avg_disc, avg_net FROM quantity_aggregations WHERE bucket = 2) AS q2 CROSS JOIN (SELECT cnt, avg_disc, avg_net FROM quantity_aggregations WHERE bucket = 3) AS q3 CROSS JOIN (SELECT cnt, avg_disc, avg_net FROM quantity_aggregations WHERE bucket = 4) AS q4 CROSS JOIN (SELECT cnt, avg_disc, avg_net FROM quantity_aggregations WHERE bucket = 5) AS q5 WHERE r_reason_sk = 1;
```

**Key insight:** Extract repeated quantity-range subqueries into CTEs. Each CTE computes count, avg_ext_price, avg_net_profit in ONE pass instead of scanning store_sales 15+ times.


---
## Constraints

**CTE_COLUMN_COMPLETENESS** [CRITICAL]: CRITICAL: When creating or modifying a CTE, its SELECT list MUST include ALL columns referenced by downstream queries. Check the Node Contracts section: every column in downstream_refs MUST appear in the CTE output. Also ensure: (1) JOIN columns used by consumers are included in SELECT, (2) every table referenced in WHERE is present in FROM/JOIN, (3) no ambiguous column names between the CTE and re-joined tables. Dropping a column that a downstream node needs will cause an execution error.

**LITERAL_PRESERVATION** [CRITICAL]: CRITICAL: When rewriting SQL, you MUST copy ALL literal values (strings, numbers, dates) EXACTLY from the original query. Do NOT invent, substitute, or 'improve' any filter values. If the original says d_year = 2000, your rewrite MUST say d_year = 2000. If the original says ca_state = 'GA', your rewrite MUST say ca_state = 'GA'. Changing these values will produce WRONG RESULTS and the rewrite will be REJECTED.

**MIN_BASELINE_THRESHOLD** [HIGH]: If the query execution plan shows very fast runtime (under 100ms), be conservative with CTE-based transforms. Each CTE adds materialization overhead (hash table creation, intermediate result storage). On fast queries, this overhead can exceed the filtering benefit. Prefer minimal changes or no change over adding multiple CTEs to an already-fast query.

**NO_UNFILTERED_DIMENSION_CTE** [HIGH]: Every CTE you create must include a WHERE clause that actually reduces row count. Selecting fewer columns is not filtering — the CTE still materializes every row. If a dimension table has no predicate to push down, leave it as a direct join in the main query instead of wrapping it in a CTE.

**OR_TO_UNION_GUARD** [HIGH]: Only apply or_to_union when (a) the OR branches involve different tables or fundamentally different access paths — never when all branches filter the same column (e.g., t_hour ranges), since the optimizer already handles same-column ORs efficiently in a single scan — and (b) the result is 3 or fewer UNION ALL branches. Nested ORs that would expand into 4+ branches (e.g., 3 conditions x 3 values = 9 combinations) must be left as-is. Violating these rules causes 0.23x–0.59x regressions from multiplied fact table scans.

**REMOVE_REPLACED_CTES** [HIGH]: When creating replacement CTEs, overwrite the original by using the same node_id in your rewrite_sets, or ensure the original is removed from the WITH clause. Every CTE in the final query should be actively used — dead CTEs still get materialized and waste resources (caused 0.49x on Q31, 0.68x on Q74).

**NO_MATERIALIZE_EXISTS** [CRITICAL]: Keep EXISTS and NOT EXISTS as-is — they use semi-join short-circuiting that stops scanning after the first match. Converting them to materialized CTEs (e.g., WITH cte AS (SELECT DISTINCT ... FROM large_table)) forces a full table scan, which is catastrophically slower (0.14x observed on Q16). When you see EXISTS, preserve it.


---
## Output Format

Respond with a JSON object containing your rewrite_sets:

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "transform_name",
      "nodes": {
        "node_id": "new SQL..."
      },
      "invariants_kept": ["same result rows", "same ordering"],
      "expected_speedup": "2x",
      "risk": "low"
    }
  ],
  "explanation": "what was changed and why"
}
```

Now output your rewrite_sets: