You are an autonomous Query Rewrite Engine. Your goal is to maximize execution speed while strictly preserving semantic invariants.

RULES:
- Maximize execution speed while preserving semantic invariants (output columns, grain, total result rows).
- Group dependent changes into a single rewrite_set.
- Use descriptive CTE names (e.g., `filtered_returns` not `cte1`).
- If a standard SQL optimization applies that is not in the allowed list, label it "semantic_rewrite".

ALLOWED TRANSFORMS: pushdown, decorrelate, or_to_union, early_filter, date_cte_isolate, materialize_cte, flatten_subquery, reorder_join, multi_push_predicate, inline_cte, remove_redundant, semantic_rewrite

---
## Query Structure

### DAG Topology
```
  [main_query] type=main tables=[store_sales, store_returns, date_dim, web_sales, web_returns] GROUP_BY
```

### Target Nodes
[main_query] GROUP_BY

### SQL
[main_query] type=main
```sql
SELECT
  channel,
  item,
  return_ratio,
  return_rank,
  currency_rank
FROM (
  SELECT
    'web' AS channel,
    web.item,
    web.return_ratio,
    web.return_rank,
    web.currency_rank
  FROM (
    SELECT
      item,
      return_ratio,
      currency_ratio,
      RANK() OVER (ORDER BY return_ratio) AS return_rank,
      RANK() OVER (ORDER BY currency_ratio) AS currency_rank
    FROM (
      SELECT
        ws.ws_item_sk AS item,
        (
          CAST(SUM(COALESCE(wr.wr_return_quantity, 0)) AS DECIMAL(15, 4)) / CAST(SUM(COALESCE(ws.ws_quantity, 0)) AS DECIMAL(15, 4))
        ) AS return_ratio,
        (
          CAST(SUM(COALESCE(wr.wr_return_amt, 0)) AS DECIMAL(15, 4)) / CAST(SUM(COALESCE(ws.ws_net_paid, 0)) AS DECIMAL(15, 4))
        ) AS currency_ratio
      FROM web_sales AS ws
      LEFT OUTER JOIN web_returns AS wr
        ON (
          ws.ws_order_number = wr.wr_order_number AND ws.ws_item_sk = wr.wr_item_sk
        ), date_dim
      WHERE
        wr.wr_return_amt > 10000
        AND ws.ws_net_profit > 1
        AND ws.ws_net_paid > 0
        AND ws.ws_quantity > 0
        AND ws_sold_date_sk = d_date_sk
        AND d_year = 1999
        AND d_moy = 12
      GROUP BY
        ws.ws_item_sk
    ) AS in_web
  ) AS web
  WHERE
    (
      web.return_rank <= 10 OR web.currency_rank <= 10
    )
  UNION
  SELECT
    'catalog' AS channel,
    catalog.item,
    catalog.return_ratio,
    catalog.return_rank,
    catalog.currency_rank
  FROM (
    SELECT
      item,
      return_ratio,
      currency_ratio,
      RANK() OVER (ORDER BY return_ratio) AS return_rank,
      RANK() OVER (ORDER BY currency_ratio) AS currency_rank
    FROM (
      SELECT
        cs.cs_item_sk AS item,
        (
          CAST(SUM(COALESCE(cr.cr_return_quantity, 0)) AS DECIMAL(15, 4)) / CAST(SUM(COALESCE(cs.cs_quantity, 0)) AS DECIMAL(15, 4))
        ) AS return_ratio,
        (
          CAST(SUM(COALESCE(cr.cr_return_amount, 0)) AS DECIMAL(15, 4)) / CAST(SUM(COALESCE(cs.cs_net_paid, 0)) AS DECIMAL(15, 4))
        ) AS currency_ratio
      FROM catalog_sales AS cs
      LEFT OUTER JOIN catalog_returns AS cr
        ON (
          cs.cs_order_number = cr.cr_order_number AND cs.cs_item_sk = cr.cr_item_sk
        ), date_dim
      WHERE
        cr.cr_return_amount > 10000
        AND cs.cs_net_profit > 1
        AND cs.cs_net_paid > 0
        AND cs.cs_quantity > 0
        AND cs_sold_date_sk = d_date_sk
        AND d_year = 1999
        AND d_moy = 12
      GROUP BY
        cs.cs_item_sk
    ) AS in_cat
  ) AS catalog
  WHERE
    (
      catalog.return_rank <= 10 OR catalog.currency_rank <= 10
    )
  UNION
  SELECT
    'store' AS channel,
    store.item,
    store.return_ratio,
    store.return_rank,
    store.currency_rank
  FROM (
    SELECT
      item,
      return_ratio,
      currency_ratio,
      RANK() OVER (ORDER BY return_ratio) AS return_rank,
      RANK() OVER (ORDER BY currency_ratio) AS currency_rank
    FROM (
      SELECT
        sts.ss_item_sk AS item,
        (
          CAST(SUM(COALESCE(sr.sr_return_quantity, 0)) AS DECIMAL(15, 4)) / CAST(SUM(COALESCE(sts.ss_quantity, 0)) AS DECIMAL(15, 4))
        ) AS return_ratio,
        (
          CAST(SUM(COALESCE(sr.sr_return_amt, 0)) AS DECIMAL(15, 4)) / CAST(SUM(COALESCE(sts.ss_net_paid, 0)) AS DECIMAL(15, 4))
        ) AS currency_ratio
      FROM store_sales AS sts
      LEFT OUTER JOIN store_returns AS sr
        ON (
          sts.ss_ticket_number = sr.sr_ticket_number AND sts.ss_item_sk = sr.sr_item_sk
        ), date_dim
      WHERE
        sr.sr_return_amt > 10000
        AND sts.ss_net_profit > 1
        AND sts.ss_net_paid > 0
        AND sts.ss_quantity > 0
        AND ss_sold_date_sk = d_date_sk
        AND d_year = 1999
        AND d_moy = 12
      GROUP BY
        sts.ss_item_sk
    ) AS in_store
  ) AS store
  WHERE
    (
      store.return_rank <= 10 OR store.currency_rank <= 10
    )
)
ORDER BY
  1,
  4,
  5,
  2
LIMIT 100
```

### Contracts
[main_query]:
  output_columns: ['channel', 'item', 'return_ratio', 'return_rank', 'currency_rank']
  grain: ['ss_item_sk']
  required_predicates: ['store.return_rank <= 10', 'store.currency_rank <= 10']

### Downstream Usage
No usage data.

---
## Performance Profile

### Cost Attribution
[main_query]: 99.6% cost, ~231261 rows, ops=[SEQ_SCAN[web_returns], SEQ_SCAN[web_sales], SEQ_SCAN[date_dim]]

### Execution Plan
```
Operators by cost:
- SEQ_SCAN(store_sales): 65.5% cost, 231,261 rows
- SEQ_SCAN(store_sales): 24.5% cost, 94,072 rows
- SEQ_SCAN(store_sales): 6.1% cost, 4,813 rows
- SEQ_SCAN(store_sales): 1.3% cost, 187,852 rows
- SEQ_SCAN(store_sales): 1.2% cost, 5,972 rows

Scans:
- store_sales x1: 345,611,892 → 231,261 rows (filtered)
- catalog_sales x1: 172,815,132 → 187,852 rows (filtered)
- web_sales x1: 86,370,792 → 94,072 rows (filtered)
- store_returns x1: 34,530,384 → 4,813 rows (filtered)
- catalog_returns x1: 17,294,688 → 409 rows (filtered)
- web_returns x1: 4,315,332 → 5,972 rows (filtered)
- date_dim x3: 73,049 → 31 rows (filtered)

Misestimates:
- HASH_GROUP_BY: est 4,900 vs actual 41 (119.5x)
- HASH_GROUP_BY: est 2,210 vs actual 29 (76.2x)
- PROJECTION: est 1,555 vs actual 12 (129.6x)
- PROJECTION: est 1,555 vs actual 12 (129.6x)
- FILTER: est 1,555 vs actual 12 (129.6x)
- PROJECTION: est 7,777 vs actual 150 (51.8x)
- PROJECTION: est 7,777 vs actual 150 (51.8x)
- HASH_GROUP_BY: est 7,777 vs actual 150 (51.8x)
- PROJECTION: est 8,109 vs actual 150 (54.1x)
- HASH_JOIN: est 8,109 vs actual 150 (54.1x)
- SEQ_SCAN: est 143,844 vs actual 5,972 (24.1x)
- HASH_JOIN: est 11,528 vs actual 94,072 (8.2x)
- SEQ_SCAN: est 1,439,513 vs actual 94,072 (15.3x)
- PROJECTION: est 2,210 vs actual 17 (130.0x)
- PROJECTION: est 2,210 vs actual 17 (130.0x)
- FILTER: est 2,210 vs actual 17 (130.0x)
- PROJECTION: est 11,052 vs actual 369 (30.0x)
- PROJECTION: est 11,052 vs actual 369 (30.0x)
- HASH_GROUP_BY: est 11,052 vs actual 369 (30.0x)
- PROJECTION: est 11,741 vs actual 370 (31.7x)
- HASH_JOIN: est 11,741 vs actual 370 (31.7x)
- SEQ_SCAN: est 288,244 vs actual 409 (704.8x)
- HASH_JOIN: est 23,065 vs actual 187,852 (8.1x)
- FILTER: est 2,880,252 vs actual 187,852 (15.3x)
- SEQ_SCAN: est 2,880,252 vs actual 187,852 (15.3x)
- PROJECTION: est 4,900 vs actual 12 (408.3x)
- PROJECTION: est 4,900 vs actual 12 (408.3x)
- FILTER: est 4,900 vs actual 12 (408.3x)
- PROJECTION: est 24,504 vs actual 124 (197.6x)
- PROJECTION: est 24,504 vs actual 124 (197.6x)
- HASH_GROUP_BY: est 24,504 vs actual 124 (197.6x)
- PROJECTION: est 28,290 vs actual 124 (228.1x)
- HASH_JOIN: est 28,290 vs actual 124 (228.1x)
- SEQ_SCAN: est 575,506 vs actual 4,813 (119.6x)
- HASH_JOIN: est 46,129 vs actual 231,261 (5.0x)
- FILTER: est 5,760,198 vs actual 231,261 (24.9x)
- SEQ_SCAN: est 5,760,198 vs actual 231,261 (24.9x)

Joins:
- HASH_JOIN: web_returns x ? -> 150 rows
- HASH_JOIN: web_sales x ? -> 94,072 rows
- HASH_JOIN: catalog_returns x ? -> 370 rows (late)
- HASH_JOIN: ? x ? -> 187,852 rows (late)
- HASH_JOIN: store_returns x ? -> 124 rows
```

### Optimization Opportunities
1. **QT-OPT-001** - OR to UNION ALL Decomposition
  Trigger: OR conditions spanning different columns (col_a = X OR col_b = Y)
  Rewrite: Split into separate SELECTs with UNION ALL, add exclusion predicates to avoid duplicates
   Matched: OR condition in WHERE clause

2. **QT-OPT-003** - Date CTE Isolation
  Trigger: date_dim joined with d_year/d_qoy/d_month filter, fact table present
  Rewrite: Create CTE: SELECT d_date_sk FROM date_dim WHERE filter, join fact to CTE early
   Matched: date_dim filter with fact table

3. **QT-OPT-007** - Materialize Repeated Subquery
  Trigger: Same subquery pattern appears multiple times in query
  Rewrite: Extract to CTE with MATERIALIZED hint, reference by name
   Matched: Repeated subquery pattern

OR_TO_UNION: [main_query] has OR condition
  Fix: Split into UNION ALL branches
  Expected: 2x speedup (verified Q15: 2.98x)

---
## Previous Attempts

- baseline: 1.00x [none] NEUTRAL
- kimi: 1.02x [none] NEUTRAL
- v2_standard: 1.00x [date_cte_isolate] NEUTRAL
- dsr1: 0.98x [prefetch_fact_join, materialize_cte] NEUTRAL

**No effect**: date_cte_isolate, materialize_cte, prefetch_fact_join

**Recommended patterns** (details in Examples section below):
- **union_cte_split** (1.36x) — Split a generic UNION ALL CTE into specialized CTEs when the main query filters by year or discriminator - eliminates redundant scans.
- **deferred_window_aggregation** (1.36x) — When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joined with FULL OUTER JOIN followed by another WINDOW pass for NULL carry-forward: defer the WINDOW out of the CTEs, join daily totals, then compute cumulative sums once on the joined result.

---
## Examples (Verified Patterns)

## Example: Union CTE Split/Specialization (UNION_CTE_SPLIT)
Verified speedup: 1.36x
Benchmark: Q74

### Original SQL:
```sql
with year_total as (
 select c_customer_id customer_id
       ,c_first_name customer_first_name
       ,c_last_name customer_last_name
       ,d_year as year
       ,stddev_samp(ss_net_paid) year_total
       ,'s' sale_type
 from customer
     ,store_sales
     ,date_dim
 where c_customer_sk = ss_customer_sk
   and ss_sold_date_sk = d_date_sk
   and d_year in (1999,1999+1)
 group by c_customer_id
         ,c_first_name
         ,c_last_name
         ,d_year
 union all
 select c_customer_id customer_id
       ,c_first_name customer_first_name
       ,c_last_name customer_last_name
       ,d_year as year
       ,stddev_samp(ws_net_paid) year_total
       ,'w' sale_type
 from customer
     ,web_sales
     ,date_dim
 where c_customer_sk = ws_bill_customer_sk
   and ws_sold_date_sk = d_date_sk
   and d_year in (1999,1999+1)
 group by c_customer_id
         ,c_first_name
         ,c_last_name
         ,d_year
         )
  select
        t_s_secyear.customer_id, t_s_secyear.customer_first_name, t_s_secyear.customer_last_name
 from year_total t_s_firstyear
     ,year_total t_s_secyear
     ,year_total t_w_firstyear
     ,year_total t_w_secyear
 where t_s_secyear.customer_id = t_s_firstyear.customer_id
         and t_s_firstyear.customer_id = t_w_secyear.customer_id
         and t_s_firstyear.customer_id = t_w_firstyear.customer_id
         and t_s_firstyear.sale_type = 's'
         and t_w_firstyear.sale_type = 'w'
         and t_s_secyear.sale_type = 's'
         and t_w_secyear.sale_type = 'w'
         and t_s_firstyear.year = 1999
         and t_s_secyear.year = 1999+1
         and t_w_firstyear.year = 1999
         and t_w_secyear.year = 1999+1
         and t_s_firstyear.year_total > 0
         and t_w_firstyear.year_total > 0
         and case when t_w_firstyear.year_total > 0 then t_w_secyear.year_total / t_w_firstyear.year_total else null end
           > case when t_s_firstyear.year_total > 0 then t_s_secyear.year_total / t_s_firstyear.year_total else null end
 order by 2,1,3
 LIMIT 100;
```

### Optimized SQL:
```sql
WITH year_total AS (SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, STDDEV_SAMP(ss_net_paid) AS year_total, 's' AS sale_type FROM customer, store_sales, date_dim WHERE c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1) GROUP BY c_customer_id, c_first_name, c_last_name, d_year UNION ALL SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, STDDEV_SAMP(ws_net_paid) AS year_total, 'w' AS sale_type FROM customer, web_sales, date_dim WHERE c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1) GROUP BY c_customer_id, c_first_name, c_last_name, d_year), year_total_store AS (SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, STDDEV_SAMP(ss_net_paid) AS year_total FROM customer, store_sales, date_dim WHERE c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1) GROUP BY c_customer_id, c_first_name, c_last_name, d_year), year_total_web AS (SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, STDDEV_SAMP(ws_net_paid) AS year_total FROM customer, web_sales, date_dim WHERE c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1) GROUP BY c_customer_id, c_first_name, c_last_name, d_year)
SELECT t_s_secyear.customer_id, t_s_secyear.customer_first_name, t_s_secyear.customer_last_name FROM year_total_store AS t_s_firstyear, year_total_store AS t_s_secyear, year_total_web AS t_w_firstyear, year_total_web AS t_w_secyear WHERE t_s_secyear.customer_id = t_s_firstyear.customer_id AND t_s_firstyear.customer_id = t_w_secyear.customer_id AND t_s_firstyear.customer_id = t_w_firstyear.customer_id AND t_s_firstyear.year = 1999 AND t_s_secyear.year = 1999 + 1 AND t_w_firstyear.year = 1999 AND t_w_secyear.year = 1999 + 1 AND t_s_firstyear.year_total > 0 AND t_w_firstyear.year_total > 0 AND CASE WHEN t_w_firstyear.year_total > 0 THEN t_w_secyear.year_total / t_w_firstyear.year_total ELSE NULL END > CASE WHEN t_s_firstyear.year_total > 0 THEN t_s_secyear.year_total / t_s_firstyear.year_total ELSE NULL END ORDER BY 2, 1, 3 LIMIT 100;
```

**Key insight:** The original query scans the generic wswscs CTE twice and joins to date_dim twice to filter by year. By pushing year filters INTO the CTE definition, we create specialized CTEs (wswscs_1998, wswscs_1999) that filter during aggregation instead of after. This eliminates redundant date_dim lookups and reduces the rows aggregated.


## Example: Deferred Window Aggregation (DEFERRED_WINDOW_AGGREGATION)
Verified speedup: 1.36x
Benchmark: Q51

### Original SQL:
```sql
WITH web_v1 as (
select
  ws_item_sk item_sk, d_date,
  sum(sum(ws_sales_price))
      over (partition by ws_item_sk order by d_date rows between unbounded preceding and current row) cume_sales
from web_sales
    ,date_dim
where ws_sold_date_sk=d_date_sk
  and d_month_seq between 1216 and 1216+11
  and ws_item_sk is not NULL
group by ws_item_sk, d_date),
store_v1 as (
select
  ss_item_sk item_sk, d_date,
  sum(sum(ss_sales_price))
      over (partition by ss_item_sk order by d_date rows between unbounded preceding and current row) cume_sales
from store_sales
    ,date_dim
where ss_sold_date_sk=d_date_sk
  and d_month_seq between 1216 and 1216+11
  and ss_item_sk is not NULL
group by ss_item_sk, d_date)
 select *
from (select item_sk
     ,d_date
     ,web_sales
     ,store_sales
     ,max(web_sales)
         over (partition by item_sk order by d_date rows between unbounded preceding and current row) web_cumulative
     ,max(store_sales)
         over (partition by item_sk order by d_date rows between unbounded preceding and current row) store_cumulative
     from (select case when web.item_sk is not null then web.item_sk else store.item_sk end item_sk
                 ,case when web.d_date is not null then web.d_date else store.d_date end d_date
                 ,web.cume_sales web_sales
                 ,store.cume_sales store_sales
           from web_v1 web full outer join store_v1 store on (web.item_sk = store.item_sk
                                                          and web.d_date = store.d_date)
          )x )y
where web_cumulative > store_cumulative
order by item_sk
        ,d_date
 LIMIT 100;
```

### Optimized SQL:
```sql
WITH filtered_dates AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1216 AND 1216 + 11), filtered_web_sales AS (SELECT ws_item_sk AS item_sk, d_date, ws_sales_price FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk WHERE NOT ws_item_sk IS NULL), filtered_store_sales AS (SELECT ss_item_sk AS item_sk, d_date, ss_sales_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk WHERE NOT ss_item_sk IS NULL), web_v1 AS (SELECT item_sk, d_date, SUM(SUM(ws_sales_price)) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS cume_sales FROM filtered_web_sales GROUP BY item_sk, d_date), store_v1 AS (SELECT item_sk, d_date, SUM(SUM(ss_sales_price)) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS cume_sales FROM filtered_store_sales GROUP BY item_sk, d_date)
SELECT * FROM (SELECT item_sk, d_date, web_sales, store_sales, MAX(web_sales) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS web_cumulative, MAX(store_sales) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS store_cumulative FROM (SELECT CASE WHEN NOT web.item_sk IS NULL THEN web.item_sk ELSE store.item_sk END AS item_sk, CASE WHEN NOT web.d_date IS NULL THEN web.d_date ELSE store.d_date END AS d_date, web.cume_sales AS web_sales, store.cume_sales AS store_sales FROM web_v1 AS web FULL OUTER JOIN store_v1 AS store ON (web.item_sk = store.item_sk AND web.d_date = store.d_date)) AS x) AS y WHERE web_cumulative > store_cumulative ORDER BY item_sk, d_date LIMIT 100;
```

**Key insight:** When CTEs compute GROUP BY + WINDOW (running sum), then FULL OUTER JOIN introduces NULLs requiring a MAX() OVER() carry-forward pass: remove WINDOW from the CTEs (keep only GROUP BY for daily totals), join the daily totals, then compute SUM() OVER() once on the joined result. SUM() naturally skips NULLs, so the carry-forward is free. Reduces 3 WINDOW passes (2 in CTEs + 1 MAX carry-forward) to 1.

**When NOT to use:** Do not use when the CTE window function is referenced by other consumers besides the final join (the cumulative value is needed elsewhere). Do not use when the window function is not a monotonically accumulating SUM - e.g., AVG, COUNT, or non-monotonic window functions require separate computation. Only applies when the join is FULL OUTER and the carry-forward window is MAX/LAST_VALUE over a cumulative sum.


---
## Constraints

**CTE_COLUMN_COMPLETENESS** [CRITICAL]: CRITICAL: When creating or modifying a CTE, its SELECT list MUST include ALL columns referenced by downstream queries. Check the Node Contracts section: every column in downstream_refs MUST appear in the CTE output. Also ensure: (1) JOIN columns used by consumers are included in SELECT, (2) every table referenced in WHERE is present in FROM/JOIN, (3) no ambiguous column names between the CTE and re-joined tables. Dropping a column that a downstream node needs will cause an execution error.

**LITERAL_PRESERVATION** [CRITICAL]: CRITICAL: When rewriting SQL, you MUST copy ALL literal values (strings, numbers, dates) EXACTLY from the original query. Do NOT invent, substitute, or 'improve' any filter values. If the original says d_year = 2000, your rewrite MUST say d_year = 2000. If the original says ca_state = 'GA', your rewrite MUST say ca_state = 'GA'. Changing these values will produce WRONG RESULTS and the rewrite will be REJECTED.

**MIN_BASELINE_THRESHOLD** [HIGH]: If the query execution plan shows very fast runtime (under 100ms), be conservative with CTE-based transforms. Each CTE adds materialization overhead (hash table creation, intermediate result storage). On fast queries, this overhead can exceed the filtering benefit. Prefer minimal changes or no change over adding multiple CTEs to an already-fast query.

**NO_UNFILTERED_DIMENSION_CTE** [HIGH]: Every CTE you create must include a WHERE clause that actually reduces row count. Selecting fewer columns is not filtering — the CTE still materializes every row. If a dimension table has no predicate to push down, leave it as a direct join in the main query instead of wrapping it in a CTE.

**OR_TO_UNION_GUARD** [HIGH]: Only apply or_to_union when (a) the OR branches involve different tables or fundamentally different access paths — never when all branches filter the same column (e.g., t_hour ranges), since the optimizer already handles same-column ORs efficiently in a single scan — and (b) the result is 3 or fewer UNION ALL branches. Nested ORs that would expand into 4+ branches (e.g., 3 conditions x 3 values = 9 combinations) must be left as-is. Violating these rules causes 0.23x–0.59x regressions from multiplied fact table scans.

**REMOVE_REPLACED_CTES** [HIGH]: When creating replacement CTEs, overwrite the original by using the same node_id in your rewrite_sets, or ensure the original is removed from the WITH clause. Every CTE in the final query should be actively used — dead CTEs still get materialized and waste resources (caused 0.49x on Q31, 0.68x on Q74).

**NO_MATERIALIZE_EXISTS** [CRITICAL]: Keep EXISTS and NOT EXISTS as-is — they use semi-join short-circuiting that stops scanning after the first match. Converting them to materialized CTEs (e.g., WITH cte AS (SELECT DISTINCT ... FROM large_table)) forces a full table scan, which is catastrophically slower (0.14x observed on Q16). When you see EXISTS, preserve it.


---
## Output Format

Respond with a JSON object containing your rewrite_sets:

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "transform_name",
      "nodes": {
        "node_id": "new SQL..."
      },
      "invariants_kept": ["same result rows", "same ordering"],
      "expected_speedup": "2x",
      "risk": "low"
    }
  ],
  "explanation": "what was changed and why"
}
```

Now output your rewrite_sets: