{
  "query059_multi": {
    "params": {
      "work_mem": "256MB",
      "max_parallel_workers_per_gather": "4",
      "jit": "off"
    },
    "reasoning": "1. Sort spills to disk: 'Sort Method: external merge Space: 39168kB (Disk)' on the main sort node. 2. Multiple hash/sort operations: Plan shows 4+ hash/sort nodes (Gather Merge sort, Hash Join, final Sort). With 256MB per operation, total ~1GB memory usage is reasonable. 3. JIT overhead: JIT compiled 96 functions but shows 0.0ms cost - likely measurement artifact, but JIT provides no benefit for this aggregation-heavy query. Disabling eliminates compilation overhead. 4. Parallel workers: 2 workers launched on large store_sales scan (1.2M rows). Increasing to 4 may improve scan speed.",
    "config_cmds": [
      "SET LOCAL jit = 'off'",
      "SET LOCAL max_parallel_workers_per_gather = '4'",
      "SET LOCAL work_mem = '256MB'"
    ],
    "baseline_ms": 26944.0,
    "config_ms": 18779.4,
    "config_speedup": 1.435,
    "rows_match": true,
    "verdict": "WIN"
  },
  "query080_multi": {
    "params": {},
    "reasoning": "No configuration bottlenecks identified. The plan shows optimal access patterns: all sorts use in-memory quicksort (25KB), hash joins show no batching, parallel workers are launching (2/2 and 1/1), index scans are used appropriately on selective predicates, and no JIT overhead is indicated. The query appears I/O-bound with 8,722 buffer reads; configuration changes would not address the fundamental data access requirement.",
    "config_speedup": 1.0,
    "verdict": "NO_CHANGE"
  },
  "query069_multi": {
    "params": {
      "work_mem": "256MB",
      "parallel_setup_cost": "100.0",
      "parallel_tuple_cost": "0.001"
    },
    "reasoning": "The plan shows 2 hash joins (Hash Join Semi and Hash Join Inner) and 1 sort operation (Sort node) - 3 total hash/sort operations. Current work_mem=4MB may cause spilling for the 97K-row hash table (Hash Join Semi). 256MB per operation accommodates all three within safe memory limits. Anti-join subplans show 'Workers: 0/2 launched' despite high overall runtime - reducing parallel_setup_cost and parallel_tuple_cost encourages parallel execution of these anti-joins.",
    "config_cmds": [
      "SET LOCAL parallel_setup_cost = '100.0'",
      "SET LOCAL parallel_tuple_cost = '0.001'",
      "SET LOCAL work_mem = '256MB'"
    ],
    "baseline_ms": 2171.8,
    "config_ms": 2080.1,
    "config_speedup": 1.044,
    "rows_match": true,
    "verdict": "NEUTRAL"
  },
  "query085_agg": {
    "params": {
      "work_mem": "64MB",
      "hash_mem_multiplier": "2.0",
      "parallel_setup_cost": "100.0",
      "parallel_tuple_cost": "0.001"
    },
    "reasoning": "Plan shows 3 sort operations (all in memory but small) and 1 hash operation potential. Current work_mem=4MB is very low - increasing to 64MB prevents potential hash join spills while staying safe (4 operations \u00d7 64MB = 256MB). hash_mem_multiplier=2.0 gives hash joins more memory. Workers are launched (2/2) but parallel overhead may be limiting; reducing parallel_setup_cost and parallel_tuple_cost encourages more aggressive parallelism throughout the plan.",
    "config_cmds": [
      "SET LOCAL hash_mem_multiplier = '2.0'",
      "SET LOCAL parallel_setup_cost = '100.0'",
      "SET LOCAL parallel_tuple_cost = '0.001'",
      "SET LOCAL work_mem = '64MB'"
    ],
    "baseline_ms": 3107.4,
    "config_ms": 3083.0,
    "config_speedup": 1.008,
    "rows_match": true,
    "verdict": "NEUTRAL"
  }
}