## Phase 1: Bottleneck Decomposition

Primary expensive nodes (>10% of total runtime):

1. **Nested Loop Inner** in ssr (70.4ms, 54% of total):
   - Inputs: Hash Join (4,857 rows × 3 workers) × item index scan
   - The optimizer chooses nested loop because item filter is highly selective (rows=0 after filter). However, it processes 4,857 rows × 3 workers through the index scan, each accessing item table individually.
   - Better plan: Push item filter earlier via materialized CTE to reduce rows before nested loop.

2. **Sort** operations before aggregation (70.4ms + 34.8ms + 24.2ms):
   - Each CTE sorts its entire result before aggregation.
   - The optimizer sorts because of GROUP BY s_store_id/cp_catalog_page_id/web_site_id.
   - Better plan: Use hash aggregation instead of sort+group, but requires planner to estimate grouping will fit in work_mem.

3. **Repeated identical scans** of promotion table:
   - promotion scanned 3 times (once per CTE) with same filter.
   - Better plan: Materialize filtered promotion once.

## Phase 2: Attack Design

### ATTACK_1:
**TARGET_NODE**: Nested Loop Inner join with item table in each CTE
**GAP_HYPOTHESIS**: PostgreSQL cannot push selective filters on dimension tables (item) through joins to reduce fact table (store_sales) cardinality early when the join graph is complex with multiple dimension tables.
**STRUCTURAL_PRECONDITIONS**: 
1. Star/snowflake schema with one large fact table joined to multiple dimension tables.
2. Highly selective filter exists on a dimension table (item.i_current_price > 50 AND i_category IN (...)).
3. Join order is locked to fact→dimension due to foreign key indexes.
**MECHANISM**: Create a materialized CTE with pre-filtered item keys, then join fact tables directly to this reduced set using semi-join or inner join.
**EXPECTED_PLAN_CHANGE**: 
- Materialized CTE with filtered item keys (small result).
- Fact table (store_sales) filtered via index scan on ss_item_sk IN (SELECT...) before other joins.
- Reduced rows flowing into promotion/date/store joins.
**SEMANTIC_RISK**: None - item join is inner join already, preserving same rows.
**SQL**:
```sql
SET LOCAL jit = 'off';

WITH filtered_items AS (
    SELECT i_item_sk
    FROM item
    WHERE i_current_price > 50
      AND i_category IN ('Children', 'Sports')
    /* Materialize to avoid re-evaluation */
), filtered_promotion AS (
    SELECT p_promo_sk
    FROM promotion
    WHERE p_channel_email = 'N'
      AND p_channel_tv = 'N' 
      AND p_channel_radio = 'N'
      AND p_channel_press = 'N'
      AND p_channel_event = 'N'
), ssr AS (
    SELECT s_store_id as store_id,
           sum(ss_ext_sales_price) as sales,
           sum(coalesce(sr_return_amt, 0)) as returns,
           sum(ss_net_profit - coalesce(sr_net_loss, 0)) as profit
    FROM store_sales
    LEFT OUTER JOIN store_returns ON (
        ss_item_sk = sr_item_sk 
        AND ss_ticket_number = sr_ticket_number
    )
    INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk
    INNER JOIN store ON ss_store_sk = s_store_sk
    INNER JOIN filtered_items ON ss_item_sk = filtered_items.i_item_sk
    INNER JOIN filtered_promotion ON ss_promo_sk = filtered_promotion.p_promo_sk
    WHERE d_date BETWEEN cast('1998-08-29' as date)
                     AND cast('1998-08-29' as date) + interval '30 day'
      AND ss_wholesale_cost BETWEEN 23 AND 38
    GROUP BY s_store_id
), csr AS (
    SELECT cp_catalog_page_id as catalog_page_id,
           sum(cs_ext_sales_price) as sales,
           sum(coalesce(cr_return_amount, 0)) as returns,
           sum(cs_net_profit - coalesce(cr_net_loss, 0)) as profit
    FROM catalog_sales
    LEFT OUTER JOIN catalog_returns ON (
        cs_item_sk = cr_item_sk 
        AND cs_order_number = cr_order_number
    )
    INNER JOIN date_dim ON cs_sold_date_sk = d_date_sk
    INNER JOIN catalog_page ON cs_catalog_page_sk = cp_catalog_page_sk
    INNER JOIN filtered_items ON cs_item_sk = filtered_items.i_item_sk
    INNER JOIN filtered_promotion ON cs_promo_sk = filtered_promotion.p_promo_sk
    WHERE d_date BETWEEN cast('1998-08-29' as date)
                     AND cast('1998-08-29' as date) + interval '30 day'
      AND cs_wholesale_cost BETWEEN 23 AND 38
    GROUP BY cp_catalog_page_id
), wsr AS (
    SELECT web_site_id,
           sum(ws_ext_sales_price) as sales,
           sum(coalesce(wr_return_amt, 0)) as returns,
           sum(ws_net_profit - coalesce(wr_net_loss, 0)) as profit
    FROM web_sales
    LEFT OUTER JOIN web_returns ON (
        ws_item_sk = wr_item_sk 
        AND ws_order_number = wr_order_number
    )
    INNER JOIN date_dim ON ws_sold_date_sk = d_date_sk
    INNER JOIN web_site ON ws_web_site_sk = web_site_sk
    INNER JOIN filtered_items ON ws_item_sk = filtered_items.i_item_sk
    INNER JOIN filtered_promotion ON ws_promo_sk = filtered_promotion.p_promo_sk
    WHERE d_date BETWEEN cast('1998-08-29' as date)
                     AND cast('1998-08-29' as date) + interval '30 day'
      AND ws_wholesale_cost BETWEEN 23 AND 38
    GROUP BY web_site_id
)
SELECT channel
     , id
     , sum(sales) as sales
     , sum(returns) as returns
     , sum(profit) as profit
FROM (
    SELECT 'store channel' as channel
         , 'store' || store_id as id
         , sales
         , returns
         , profit
    FROM ssr
    UNION ALL
    SELECT 'catalog channel' as channel
         , 'catalog_page' || catalog_page_id as id
         , sales
         , returns
         , profit
    FROM csr
    UNION ALL
    SELECT 'web channel' as channel
         , 'web_site' || web_site_id as id
         , sales
         , returns
         , profit
    FROM wsr
) x
GROUP BY ROLLUP (channel, id)
ORDER BY channel, id
LIMIT 100;
```

### ATTACK_2:
**TARGET_NODE**: Sort before aggregation in each CTE
**GAP_HYPOTHESIS**: PostgreSQL fails to choose hash aggregation when grouping cardinality is low but estimates are inaccurate due to complex join filtering.
**STRUCTURAL_PRECONDITIONS**:
1. GROUP BY on low-cardinality column (store_id, catalog_page_id, web_site_id).
2. Complex join predicates make cardinality estimation inaccurate.
3. Sort uses quicksort in memory (no spill).
**MECHANISM**: Force hash aggregation by disabling sort-based aggregation temporarily, or restructure to make grouping cardinality more visible to planner.
**EXPECTED_PLAN_CHANGE**: HashAggregate instead of Sort + GroupAggregate, eliminating sort operations.
**SEMANTIC_RISK**: None if work_mem sufficient.
**SQL**:
```sql
SET LOCAL jit = 'off';
SET LOCAL enable_sort = 'off';  /* Force hash aggregation */

/* Original query unchanged from line 1 to 111 */
WITH ssr AS (
    SELECT s_store_id as store_id,
           sum(ss_ext_sales_price) as sales,
           sum(coalesce(sr_return_amt, 0)) as returns,
           sum(ss_net_profit - coalesce(sr_net_loss, 0)) as profit
    FROM store_sales LEFT OUTER JOIN store_returns ON
           (ss_item_sk = sr_item_sk and ss_ticket_number = sr_ticket_number),
        date_dim,
        store,
        item,
        promotion
    WHERE ss_sold_date_sk = d_date_sk
          AND d_date between cast('1998-08-29' as date)
                     AND cast('1998-08-29' as date) + interval '30 day'
          AND ss_store_sk = s_store_sk
          AND ss_item_sk = i_item_sk
          AND i_current_price > 50
          AND ss_promo_sk = p_promo_sk
          AND p_channel_email = 'N'
          AND p_channel_tv = 'N'
          AND p_channel_radio = 'N'
          AND p_channel_press = 'N'
          AND p_channel_event = 'N'
          AND ss_wholesale_cost BETWEEN 23 AND 38
          AND i_category IN ('Children', 'Sports')
    GROUP BY s_store_id
),
csr AS (
    SELECT cp_catalog_page_id as catalog_page_id,
           sum(cs_ext_sales_price) as sales,
           sum(coalesce(cr_return_amount, 0)) as returns,
           sum(cs_net_profit - coalesce(cr_net_loss, 0)) as profit
    FROM catalog_sales LEFT OUTER JOIN catalog_returns ON
           (cs_item_sk = cr_item_sk and cs_order_number = cr_order_number),
        date_dim,
        catalog_page,
        item,
        promotion
    WHERE cs_sold_date_sk = d_date_sk
          AND d_date between cast('1998-08-29' as date)
                     AND cast('1998-08-29' as date) + interval '30 day'
          AND cs_catalog_page_sk = cp_catalog_page_sk
          AND cs_item_sk = i_item_sk
          AND i_current_price > 50
          AND cs_promo_sk = p_promo_sk
          AND p_channel_email = 'N'
          AND p_channel_tv = 'N'
          AND p_channel_radio = 'N'
          AND p_channel_press = 'N'
          AND p_channel_event = 'N'
          AND cs_wholesale_cost BETWEEN 23 AND 38
          AND i_category IN ('Children', 'Sports')
    GROUP BY cp_catalog_page_id
),
wsr AS (
    SELECT web_site_id,
           sum(ws_ext_sales_price) as sales,
           sum(coalesce(wr_return_amt, 0)) as returns,
           sum(ws_net_profit - coalesce(wr_net_loss, 0)) as profit
    FROM web_sales LEFT OUTER JOIN web_returns ON
           (ws_item_sk = wr_item_sk and ws_order_number = wr_order_number),
        date_dim,
        web_site,
        item,
        promotion
    WHERE ws_sold_date_sk = d_date_sk
          AND d_date between cast('1998-08-29' as date)
                     AND cast('1998-08-29' as date) + interval '30 day'
          AND ws_web_site_sk = web_site_sk
          AND ws_item_sk = i_item_sk
          AND i_current_price > 50
          AND ws_promo_sk = p_promo_sk
          AND p_channel_email = 'N'
          AND p_channel_tv = 'N'
          AND p_channel_radio = 'N'
          AND p_channel_press = 'N'
          AND p_channel_event = 'N'
          AND ws_wholesale_cost BETWEEN 23 AND 38
          AND i_category IN ('Children', 'Sports')
    GROUP BY web_site_id
)
SELECT channel
     , id
     , sum(sales) as sales
     , sum(returns) as returns
     , sum(profit) as profit
FROM (
    SELECT 'store channel' as channel
         , 'store' || store_id as id
         , sales
         , returns
         , profit
    FROM ssr
    UNION ALL
    SELECT 'catalog channel' as channel
         , 'catalog_page' || catalog_page_id as id
         , sales
         , returns
         , profit
    FROM csr
    UNION ALL
    SELECT 'web channel' as channel
         , 'web_site' || web_site_id as id
         , sales
         , returns
         , profit
    FROM wsr
) x
GROUP BY ROLLUP (channel, id)
ORDER BY channel, id
LIMIT 100;
```

## Phase 3: Self-Critique

ATTACK_1: 
- Preserves semantic equivalence (inner joins remain inner, same filters).
- Realistic: Planner likely to materialize filtered_items CTE (small result) and use it for semi-joins.
- Risk: CTE fencing might prevent push-down of other predicates, but joins are explicit.
- Different from known gaps: Targets early reduction of fact table rows via pre-filtered dimension keys.

ATTACK_2:
- Preserves semantics (only changes aggregation method).
- Realistic: With enable_sort=off, planner must choose hash aggregation.
- Risk: If grouping cardinality is underestimated, hash aggregation could spill, but current sorts are in-memory.
- This tests a known gap (planner's aggregation method choice) but in new context of post-join grouping.

## DISCOVERY_SUMMARY:
**NEW_GAPS**:
1. **Star Schema Dimension Filter Push-Down Gap**: PostgreSQL cannot reorder joins to push highly selective dimension table filters early in star/snowflake schemas when foreign key indexes encourage fact→dimension join order. Materializing filtered dimension keys as CTE enables early reduction.

2. **Grouping Cardinality Estimation Gap**: Planner underestimates grouping cardinality after complex joins, causing suboptimal choice of sort-based aggregation over hash aggregation even when groups are few and fit in memory.

**EXTENDED_GAPS**:
- Aggregation method selection (known gap) extended to multi-CTE union with rollup scenario.

**NEGATIVE_RESULTS**:
- Repeated promotion table scans: Optimizer already handles well via shared scans (promotion scanned once per CTE, not per row). The 0.1ms scans are negligible.
- Nested loop joins: Optimizer correctly chooses nested loops due to highly selective index conditions on dimension tables. Changing to hash joins would be catastrophic as indicated by plan-space scanner.
- Memory usage: No significant spills, work_mem sufficient for current operations.