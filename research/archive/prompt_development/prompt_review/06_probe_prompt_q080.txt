You are an optimizer weakness researcher for PostgreSQL.

Your job: find what this query optimizer CANNOT do well, 
prove it with a rewrite that exploits the weakness, and 
document the structural conditions that make the weakness 
exploitable.

You are not optimizing this query for a customer. You are 
probing the engine to discover exploitable gaps in its 
optimizer. A successful probe is one that achieves >=1.5x 
speedup — this proves the optimizer left performance on 
the table. A failed probe (<=1.0x) is ALSO valuable if 
you document WHY the engine handled it well.

## Known Gaps (already discovered)

No gaps discovered yet. This is the first probe round.

Your job is to find ADDITIONAL gaps, or to find new 
structural conditions where known gaps apply. Do not 
re-prove known gaps unless the structural context is 
materially different from documented evidence.

## Query

```sql
  1 | with ssr as
  2 |  (select  s_store_id as store_id,
  3 |           sum(ss_ext_sales_price) as sales,
  4 |           sum(coalesce(sr_return_amt, 0)) as returns,
  5 |           sum(ss_net_profit - coalesce(sr_net_loss, 0)) as profit
  6 |   from store_sales left outer join store_returns on
  7 |          (ss_item_sk = sr_item_sk and ss_ticket_number = sr_ticket_number),
  8 |      date_dim,
  9 |      store,
 10 |      item,
 11 |      promotion
 12 |  where ss_sold_date_sk = d_date_sk
 13 |        and d_date between cast('1998-08-29' as date)
 14 |                   and cast('1998-08-29' as date) + interval '30 day'
 15 |        and ss_store_sk = s_store_sk
 16 |        and ss_item_sk = i_item_sk
 17 |        and i_current_price > 50
 18 |        and ss_promo_sk = p_promo_sk
 19 |        and p_channel_email = 'N'
 20 |        and p_channel_tv = 'N'
 21 |        and p_channel_radio = 'N'
 22 |        and p_channel_press = 'N'
 23 |        and p_channel_event = 'N'
 24 |        and ss_wholesale_cost BETWEEN 23 AND 38
 25 |        and i_category IN ('Children', 'Sports')
 26 |  group by s_store_id)
 27 |  ,
 28 |  csr as
 29 |  (select  cp_catalog_page_id as catalog_page_id,
 30 |           sum(cs_ext_sales_price) as sales,
 31 |           sum(coalesce(cr_return_amount, 0)) as returns,
 32 |           sum(cs_net_profit - coalesce(cr_net_loss, 0)) as profit
 33 |   from catalog_sales left outer join catalog_returns on
 34 |          (cs_item_sk = cr_item_sk and cs_order_number = cr_order_number),
 35 |      date_dim,
 36 |      catalog_page,
 37 |      item,
 38 |      promotion
 39 |  where cs_sold_date_sk = d_date_sk
 40 |        and d_date between cast('1998-08-29' as date)
 41 |                   and cast('1998-08-29' as date) + interval '30 day'
 42 |         and cs_catalog_page_sk = cp_catalog_page_sk
 43 |        and cs_item_sk = i_item_sk
 44 |        and i_current_price > 50
 45 |        and cs_promo_sk = p_promo_sk
 46 |        and p_channel_email = 'N'
 47 |        and p_channel_tv = 'N'
 48 |        and p_channel_radio = 'N'
 49 |        and p_channel_press = 'N'
 50 |        and p_channel_event = 'N'
 51 |        and cs_wholesale_cost BETWEEN 23 AND 38
 52 |        and i_category IN ('Children', 'Sports')
 53 | group by cp_catalog_page_id)
 54 |  ,
 55 |  wsr as
 56 |  (select  web_site_id,
 57 |           sum(ws_ext_sales_price) as sales,
 58 |           sum(coalesce(wr_return_amt, 0)) as returns,
 59 |           sum(ws_net_profit - coalesce(wr_net_loss, 0)) as profit
 60 |   from web_sales left outer join web_returns on
 61 |          (ws_item_sk = wr_item_sk and ws_order_number = wr_order_number),
 62 |      date_dim,
 63 |      web_site,
 64 |      item,
 65 |      promotion
 66 |  where ws_sold_date_sk = d_date_sk
 67 |        and d_date between cast('1998-08-29' as date)
 68 |                   and cast('1998-08-29' as date) + interval '30 day'
 69 |         and ws_web_site_sk = web_site_sk
 70 |        and ws_item_sk = i_item_sk
 71 |        and i_current_price > 50
 72 |        and ws_promo_sk = p_promo_sk
 73 |        and p_channel_email = 'N'
 74 |        and p_channel_tv = 'N'
 75 |        and p_channel_radio = 'N'
 76 |        and p_channel_press = 'N'
 77 |        and p_channel_event = 'N'
 78 |        and ws_wholesale_cost BETWEEN 23 AND 38
 79 |        and i_category IN ('Children', 'Sports')
 80 | group by web_site_id)
 81 |   select  channel
 82 |         , id
 83 |         , sum(sales) as sales
 84 |         , sum(returns) as returns
 85 |         , sum(profit) as profit
 86 |  from
 87 |  (select 'store channel' as channel
 88 |         , 'store' || store_id as id
 89 |         , sales
 90 |         , returns
 91 |         , profit
 92 |  from   ssr
 93 |  union all
 94 |  select 'catalog channel' as channel
 95 |         , 'catalog_page' || catalog_page_id as id
 96 |         , sales
 97 |         , returns
 98 |         , profit
 99 |  from  csr
100 |  union all
101 |  select 'web channel' as channel
102 |         , 'web_site' || web_site_id as id
103 |         , sales
104 |         , returns
105 |         , profit
106 |  from   wsr
107 |  ) x
108 |  group by rollup (channel, id)
109 |  order by channel
110 |          ,id
111 |  limit 100;
```

## EXPLAIN ANALYZE

```
Total execution time: 129.5ms
Planning time: 5.0ms

-> Limit  (rows=14 loops=1 time=129.5ms)
  -> Aggregate  (rows=14 loops=1 time=129.5ms)
    -> Sort  (rows=10 loops=1 time=129.4ms)
       Sort Method: quicksort  Space: 26kB (Memory)
      -> Append  (rows=10 loops=1 time=129.4ms)
        -> Subquery Scan ssr  (rows=4 loops=1 time=70.5ms)
          -> Aggregate  (rows=4 loops=1 time=70.4ms)
            -> Sort  (rows=4 loops=1 time=70.4ms)
               Sort Method: quicksort  Space: 25kB (Memory)
              -> Nested Loop Inner  (rows=4 loops=1 time=70.4ms)
                -> Nested Loop Left  (rows=4 loops=1 time=70.4ms)
                  -> Gather  (rows=4 loops=1 time=69.7ms)
                     Workers: 2/2 launched
                    -> Nested Loop Inner  (rows=1 loops=3 time=25.1ms)
                      -> Hash Join Inner  (rows=119 loops=3 time=24.5ms)
                         Hash Cond: (store_sales.ss_promo_sk = promotion.p_promo_sk)
                        -> Nested Loop Inner  (rows=4,857 loops=3 time=24.1ms)
                          -> Index Scan on date_dim  (rows=10 loops=3 time=3.5ms)
                             Filter: ((d_date >= '1998-08-29'::date) AND (d_date <= '1998-09-28 00:00:00'::timestamp without time zone))
                             Rows Removed by Filter: 24K
                          -> Index Only Scan on store_sales  (rows=470 loops=31 time=1.9ms)
                             Filter: ((ss_wholesale_cost >= '23'::numeric) AND (ss_wholesale_cost <= '38'::numeric))
                             Index Cond: (ss_sold_date_sk = date_dim.d_date_sk)
                             Rows Removed by Filter: 4,639
                        -> Hash  (rows=11 loops=1 time=0.1ms)
                          -> Seq Scan on promotion  (rows=11 loops=1 time=0.1ms)
                             Filter: ((p_channel_email = 'N'::bpchar) AND (p_channel_tv = 'N'::bpchar) AND (p_channel_radio = 'N'::bpc...
                             Rows Removed by Filter: 489
                      -> Index Scan on item  (rows=0 loops=358 time=0.0ms)
                         Filter: ((i_current_price > '50'::numeric) AND (i_category = ANY ('{Children,Sports}'::bpchar[])))
                         Index Cond: (i_item_sk = store_sales.ss_item_sk)
                         Rows Removed by Filter: 1
                  -> Index Scan on store_returns  (rows=0 loops=4 time=0.2ms)
                     Index Cond: ((sr_item_sk = store_sales.ss_item_sk) AND (sr_ticket_number = store_sales.ss_ticket_number))
                -> Index Only Scan on store  (rows=1 loops=4 time=0.0ms)
                   Index Cond: (s_store_sk = store_sales.ss_store_sk)
        -> Subquery Scan csr  (rows=5 loops=1 time=34.8ms)
          -> Aggregate  (rows=5 loops=1 time=34.8ms)
            -> Sort  (rows=5 loops=1 time=34.8ms)
               Sort Method: quicksort  Space: 25kB (Memory)
              -> Nested Loop Inner  (rows=5 loops=1 time=34.7ms)
                -> Nested Loop Left  (rows=5 loops=1 time=34.4ms)
                  -> Gather  (rows=5 loops=1 time=34.2ms)
                     Workers: 1/1 launched
                    -> Nested Loop Inner  (rows=2 loops=2 time=18.1ms)
                      -> Hash Join Inner  (rows=259 loops=2 time=16.7ms)
                         Hash Cond: (catalog_sales.cs_promo_sk = promotion_1.p_promo_sk)
                        -> Nested Loop Inner  (rows=9,750 loops=2 time=16.0ms)
                          -> Seq Scan on date_dim date_dim_1  (rows=16 loops=2 time=1.7ms)
                             Filter: ((d_date >= '1998-08-29'::date) AND (d_date <= '1998-09-28 00:00:00'::timestamp without time zone))
                             Rows Removed by Filter: 37K
                          -> Index Scan on catalog_sales  (rows=629 loops=31 time=0.9ms)
                             Filter: ((cs_wholesale_cost >= '23'::numeric) AND (cs_wholesale_cost <= '38'::numeric))
                             Index Cond: (cs_sold_date_sk = date_dim_1.d_date_sk)
                             Rows Removed by Filter: 2,585
                        -> Hash  (rows=11 loops=2 time=0.1ms)
                          -> Seq Scan on promotion promotion_1  (rows=11 loops=2 time=0.1ms)
                             Filter: ((p_channel_email = 'N'::bpchar) AND (p_channel_tv = 'N'::bpchar) AND (p_channel_radio = 'N'::bpc...
                             Rows Removed by Filter: 489
                      -> Index Scan on item item_1  (rows=0 loops=518 time=0.0ms)
                         Filter: ((i_current_price > '50'::numeric) AND (i_category = ANY ('{Children,Sports}'::bpchar[])))
                         Index Cond: (i_item_sk = catalog_sales.cs_item_sk)
                         Rows Removed by Filter: 1
                  -> Index Scan on catalog_returns  (rows=0 loops=5 time=0.0ms)
                     Index Cond: ((cr_item_sk = catalog_sales.cs_item_sk) AND (cr_order_number = catalog_sales.cs_order_number))
                -> Index Scan on catalog_page  (rows=1 loops=5 time=0.1ms)
                   Index Cond: (cp_catalog_page_sk = catalog_sales.cs_catalog_page_sk)
        -> Subquery Scan wsr  (rows=1 loops=1 time=24.2ms)
          -> Aggregate  (rows=1 loops=1 time=24.2ms)
            -> Nested Loop Left  (rows=1 loops=1 time=24.2ms)
              -> Gather Merge  (rows=1 loops=1 time=24.1ms)
                 Workers: 1/1 launched
                -> Sort  (rows=0 loops=2 time=13.1ms)
                   Sort Method: quicksort  Space: 25kB (Memory)
                  -> Nested Loop Inner  (rows=0 loops=2 time=13.1ms)
                    -> Nested Loop Inner  (rows=0 loops=2 time=13.1ms)
                      -> Hash Join Inner  (rows=58 loops=2 time=12.8ms)
                         Hash Cond: (web_sales.ws_promo_sk = promotion_2.p_promo_sk)
                        -> Nested Loop Inner  (rows=2,509 loops=2 time=12.5ms)
                          -> Seq Scan on date_dim date_dim_2  (rows=16 loops=2 time=2.0ms)
                             Filter: ((d_date >= '1998-08-29'::date) AND (d_date <= '1998-09-28 00:00:00'::timestamp without time zone))
                             Rows Removed by Filter: 37K
                          -> Index Scan on web_sales  (rows=162 loops=31 time=0.7ms)
                             Filter: ((ws_wholesale_cost >= '23'::numeric) AND (ws_wholesale_cost <= '38'::numeric))
                             Index Cond: (ws_sold_date_sk = date_dim_2.d_date_sk)
                             Rows Removed by Filter: 1,877
                        -> Hash  (rows=11 loops=1 time=0.1ms)
                          -> Seq Scan on promotion promotion_2  (rows=11 loops=1 time=0.1ms)
                             Filter: ((p_channel_email = 'N'::bpchar) AND (p_channel_tv = 'N'::bpchar) AND (p_channel_radio = 'N'::bpc...
                             Rows Removed by Filter: 489
                      -> Index Scan on item item_2  (rows=0 loops=115 time=0.0ms)
                         Filter: ((i_current_price > '50'::numeric) AND (i_category = ANY ('{Children,Sports}'::bpchar[])))
                         Index Cond: (i_item_sk = web_sales.ws_item_sk)
                         Rows Removed by Filter: 1
                    -> Index Scan on web_site  (rows=1 loops=1 time=0.0ms)
                       Index Cond: (web_site_sk = web_sales.ws_web_site_sk)
              -> Index Scan on web_returns  (rows=0 loops=1 time=0.0ms)
                 Index Cond: ((wr_item_sk = web_sales.ws_item_sk) AND (wr_order_number = web_sales.ws_order_number))
```

## Plan-Space Scanner Intelligence

Baseline: 73ms | CONFIDENCE: LOW
  (baseline 73ms, ceiling improvement ~16ms ≈ noise floor)
CONFIG_CEILING: 1.29x (jit=off) — LOW
Config alone insufficient. SQL restructuring required.

JOINS: LOCKED on nested loops. Alternatives = catastrophic (1% baseline).
  -> Do NOT change join methods. Reduce what nested loops process.
MEMORY: Minor (work_mem_1gb -> 1.10x). No significant spill.
JIT: Overhead (1.29x from disabling). Recommend SET LOCAL jit = off.

Plan diversity: 23 distinct plans, 8 plan changers | HIGH

STRATEGY:
  JOINS=LOCKED (nested loop) →
    Reduce nested-loop inner side via pre-filtering CTE.
    Memory is fine — focus purely on cardinality reduction.

CONFIG: SET LOCAL jit = 'off'

### Algorithm: plan_scanner

1. **CONFIG line present** — Emit ALL listed SET LOCAL commands with every rewrite. These are measured wins — do not omit or second-guess them.

2. **Ceiling = HIGH (>=1.5x)** — The optimizer is choosing a bad plan. Your SQL rewrite should guide it toward the winning plan shape. You can BEAT the ceiling by combining the config with SQL restructuring.

3. **Ceiling = LOW or NONE (<1.5x)** — Config alone is insufficient. All meaningful improvement must come from SQL restructuring: tighter filters, earlier aggregation, smaller intermediate result sets, CTE factoring.

4. **JOINS: LOCKED** — Join alternatives are catastrophic. Do NOT restructure in ways that change join types. Focus on reducing what the current joins process: push filters earlier, pre-aggregate, shrink the inner side of nested loops.

5. **JOINS: SENSITIVE** — The optimizer picked a suboptimal join method. Rewrite SQL to guide it toward the winning strategy. To discourage nested loops: enlarge inner relation (CTE, subquery). To discourage hash joins: add highly selective predicates on the inner table.

6. **JOIN ORDER: Fragile** — The written join order outperforms the optimizer's reordering. Use explicit JOIN syntax (FROM a JOIN b ON ... JOIN c ON ...) and preserve the original table access order.

7. **MEMORY: HIGH** — Hash joins or sorts are spilling to disk. The CONFIG line already includes work_mem. Additionally reduce hash build side cardinality via SQL restructuring (pre-filter, early aggregation).

**Priority**: CONFIG first (proven wins), then address the primary bottleneck (JOINS or MEMORY), then reduce intermediate cardinality. Never contradict a LOCKED diagnosis.

## Phase 1: Bottleneck Decomposition

Read the EXPLAIN plan. Identify every node that contributes 
>10% of total runtime. For each expensive node, answer:

1. What operation is it? (nested-loop, hash join, seq scan, 
   sort, aggregate, materialize)
2. What are its input cardinalities?
3. WHY is the optimizer choosing this plan? What would a 
   better plan look like?
4. Is this a known gap? If yes, does the structural context 
   match the documented evidence, or is it different?
5. Is the optimizer ALREADY handling this well? If you can't 
   articulate a better plan, move on.

## Phase 2: Attack Design

For each bottleneck where you identified a plausible better 
plan, design a rewrite that forces the optimizer toward that 
plan. You may attempt up to 4 attacks. Each attack should 
target a DIFFERENT bottleneck or exploit a different 
structural property.

Prefer attacks that:
- Exploit a gap NOT in the known gaps list (new discovery)
- Combine two known gaps in a way not previously tested
- Test a known gap under structural conditions not yet 
  documented

For each attack:

ATTACK_N:
  TARGET_NODE: [the EXPLAIN node you're attacking]
  GAP_HYPOTHESIS: [what optimizer weakness you believe 
    exists, stated as a testable claim]
  STRUCTURAL_PRECONDITIONS: [what features of THIS query 
    make the gap exploitable — these must be stated 
    generally enough to detect in other queries]
  MECHANISM: [how your rewrite forces a better plan — 
    what changes in the join graph, scan pattern, or 
    materialization strategy]
  EXPECTED_PLAN_CHANGE: [what the EXPLAIN should look 
    like after your rewrite — be specific about node 
    types and cardinalities]
  SEMANTIC_RISK: [what could break — aggregation traps, 
    join multiplicity, NULL handling, CTE fence effects]
  SQL: [the rewritten query]

## Phase 3: Self-Critique

Before finalizing, review each attack:
- Does the rewrite preserve semantic equivalence? Check 
  JOIN types, GROUP BY membership, NULL handling.
- Is the expected plan change realistic? Would the 
  optimizer actually choose the plan you're hoping for, 
  or might it do something else?
- Have you seen evidence in the known gaps that this 
  type of attack regresses? If so, what's structurally 
  different here?

Drop any attack that fails self-critique. It's better to 
output 2 sound attacks than 4 shaky ones.

## Output Schema

For each surviving attack, output the full ATTACK_N block 
above. Then output:

DISCOVERY_SUMMARY:
  NEW_GAPS: [gaps not in the known list that you're testing]
  EXTENDED_GAPS: [known gaps being tested under new 
    structural conditions]
  NEGATIVE_RESULTS: [bottlenecks you analyzed but concluded 
    the optimizer handles well — state why]