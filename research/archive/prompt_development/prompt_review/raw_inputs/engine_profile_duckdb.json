{
  "engine": "duckdb",
  "version_tested": "1.1+",
  "profile_type": "engine_profile",
  "briefing_note": "This is field intelligence gathered from 88 TPC-DS queries at SF1-SF10. Use it to guide your analysis but apply your own judgment — every query is different. Add to this knowledge if you observe something new.",

  "strengths": [
    {
      "id": "INTRA_SCAN_PREDICATE_PUSHDOWN",
      "summary": "Pushes WHERE filters directly into SEQ_SCAN. Single-table predicates are applied at scan time, zero overhead.",
      "field_note": "If EXPLAIN shows the filter already inside the scan node, don't create a CTE to push it — the engine already did it."
    },
    {
      "id": "SAME_COLUMN_OR",
      "summary": "OR on the SAME column (e.g., t_hour BETWEEN 8 AND 11 OR t_hour BETWEEN 16 AND 17) is handled in a single scan with range checks.",
      "field_note": "Splitting same-column ORs into UNION ALL doubled the fact scan on Q90 (0.59x) and 9-branch expansion on Q13 hit 0.23x. The engine handles these natively — leave them alone."
    },
    {
      "id": "HASH_JOIN_SELECTION",
      "summary": "Selects hash joins automatically. Join ordering is generally sound for 2-4 table joins.",
      "field_note": "Restructuring simple join orders rarely helps. Focus on what happens BEFORE the join (input reduction), not the join itself. See CROSS_CTE_PREDICATE_BLINDNESS for pre-filtering strategies that reduce join input."
    },
    {
      "id": "CTE_INLINING",
      "summary": "CTEs referenced once are typically inlined (treated as subquery). Multi-referenced CTEs may be materialized.",
      "field_note": "Single-reference CTEs are free — use for clarity. Multi-referenced CTEs: the engine decides whether to materialize. This makes CTE-based strategies (pre-filtering, isolation) low-cost on DuckDB compared to PostgreSQL where multi-referenced CTEs are materialized and create optimization fences."
    },
    {
      "id": "COLUMNAR_PROJECTION",
      "summary": "Only reads columns actually referenced. Unused columns have zero I/O cost.",
      "field_note": "SELECT * isn't as bad as in row-stores, but explicit columns still matter for intermediate CTEs — fewer columns = less memory for materialization. When creating pre-filter CTEs, only SELECT the columns downstream nodes actually need."
    },
    {
      "id": "PARALLEL_AGGREGATION",
      "summary": "Scans and aggregations parallelized across threads. PERFECT_HASH_GROUP_BY is highly efficient.",
      "field_note": "Simple aggregation queries are already fast. Restructuring them rarely helps unless you're reducing input rows. See REDUNDANT_SCAN_ELIMINATION for consolidating repeated scans, and CROSS_CTE_PREDICATE_BLINDNESS for reducing rows entering the aggregation."
    },
    {
      "id": "EXISTS_SEMI_JOIN",
      "summary": "EXISTS/NOT EXISTS uses semi-join with early termination — stops after first match per outer row.",
      "field_note": "Converting EXISTS to a materialized CTE with SELECT DISTINCT forces a full scan. Semi-join is usually faster. We saw 0.14x on Q16 and 0.54x on Q95 from this mistake. However, if the optimizer fails to decorrelate the EXISTS (check EXPLAIN for nested-loop re-execution), materializing may help."
    }
  ],

  "gaps": [
    {
      "id": "CROSS_CTE_PREDICATE_BLINDNESS",
      "priority": "HIGH",
      "what": "Cannot push predicates from the outer query backward into CTE definitions.",
      "why": "CTEs are planned as independent subplans. The optimizer does not trace data lineage through CTE boundaries.",
      "opportunity": "Move selective predicates INTO the CTE definition. Pre-filter dimensions/facts before they get materialized.",
      "what_worked": [
        "Q6/Q11: 4.00x — date filter moved into CTE",
        "Q63: 3.77x — pre-joined filtered dates with fact table before other dims",
        "Q93: 2.97x — dimension filter applied before LEFT JOIN chain",
        "Q26: 1.93x — all dimensions pre-filtered into separate CTEs"
      ],
      "what_didnt_work": [
        "Q25: 0.50x — query was 31ms baseline, CTE overhead exceeded filter savings",
        "Q31: 0.49x — over-decomposed an already-efficient query into too many sub-CTEs"
      ],
      "field_notes": [
        "Check EXPLAIN: if the filter appears AFTER a large scan or join, there's opportunity to push it earlier via CTE.",
        "On fast queries (<100ms), CTE materialization overhead can negate the savings. Assess whether it's worth it.",
        "This is our most productive gap — ~35% of all wins exploit it. Most reliable on star-join queries with late dim filters.",
        "Don't create unfiltered CTEs — a CTE without a WHERE clause just adds overhead.",
        "NEVER CROSS JOIN 3+ pre-filtered dimension CTEs together — Cartesian explosion creates massive intermediate results. Q80 hit 0.0076x (132x slower) when 3 dims (30x200x20=120K rows) were cross-joined. Instead, join each filtered dimension directly to the fact table.",
        "Limit cascading fact-table CTE chains to 2 levels. A 3rd cascading CTE causes excessive materialization — Q4 hit 0.78x from triple-chained fact CTEs. Each level should be highly selective (<5% rows) to justify the overhead.",
        "Orphaned CTEs that are defined but not referenced in the final query still get materialized. Always remove dead CTEs when restructuring."
      ]
    },
    {
      "id": "REDUNDANT_SCAN_ELIMINATION",
      "priority": "HIGH",
      "what": "Cannot detect when the same fact table is scanned N times with similar filters across subquery boundaries.",
      "why": "Common Subexpression Elimination doesn't cross scalar subquery boundaries. Each subquery is planned independently.",
      "opportunity": "Consolidate N subqueries on the same table into 1 scan with CASE WHEN / FILTER() inside aggregates.",
      "what_worked": [
        "Q88: 6.28x — 8 time-bucket subqueries consolidated into 1 scan with 8 CASE branches",
        "Q9: 4.47x — 15 separate store_sales scans consolidated into 1 scan with 5 CASE buckets"
      ],
      "what_didnt_work": [],
      "field_notes": [
        "Count scans per base table in the EXPLAIN. If a fact table appears 3+ times, this gap is active.",
        "DuckDB supports native FILTER clause: COUNT(*) FILTER (WHERE cond) — use it instead of CASE WHEN for cleaner SQL.",
        "STDDEV_SAMP, VARIANCE, PERCENTILE_CONT are grouping-sensitive. CASE branches compute per-group differently than separate per-branch queries. Verify equivalence when these appear.",
        "We tested up to 8 CASE branches successfully. Beyond that is untested territory, not proven harmful — use judgment.",
        "This produced our single biggest win (Q88 6.28x). Always check for multi-scan patterns."
      ]
    },
    {
      "id": "CORRELATED_SUBQUERY_PARALYSIS",
      "priority": "HIGH",
      "what": "Cannot automatically decorrelate correlated aggregate subqueries into GROUP BY + JOIN.",
      "why": "Decorrelation requires recognizing that the correlated predicate = GROUP BY + JOIN equivalence. The optimizer doesn't do this for complex correlation patterns.",
      "opportunity": "Convert correlated WHERE to CTE with GROUP BY on the correlation column, then JOIN back.",
      "what_worked": [
        "Q1: 2.92x — correlated AVG with store_sk correlation converted to GROUP BY store_sk + JOIN"
      ],
      "what_didnt_work": [],
      "field_notes": [
        "Look for WHERE col > (SELECT AGG FROM ... WHERE outer.key = inner.key) patterns.",
        "EXPLAIN will show nested-loop with repeated subquery execution if the optimizer failed to decorrelate.",
        "CRITICAL: when decorrelating, you MUST preserve all WHERE filters from the original subquery in the new CTE. Dropping a filter changes which rows participate in the aggregate — this produces wrong results, not just a regression.",
        "Only applies to correlated scalar subqueries with aggregates. EXISTS correlation is handled by semi-join (see strengths)."
      ]
    },
    {
      "id": "CROSS_COLUMN_OR_DECOMPOSITION",
      "priority": "MEDIUM",
      "what": "Cannot decompose OR conditions that span DIFFERENT columns into independent targeted scans.",
      "why": "The optimizer evaluates OR as a single filter. It can't recognize that each branch targets a different column with different selectivity.",
      "opportunity": "Split cross-column ORs into UNION ALL branches, each with a targeted single-column filter.",
      "what_worked": [
        "Q88: 6.28x — 8 time-bucket subqueries with distinct hour ranges (distinct access paths)",
        "Q15: 3.17x — (zip OR state OR price) split to 3 targeted branches",
        "Q10: 1.49x, Q45: 1.35x, Q41: 1.89x"
      ],
      "what_didnt_work": [
        "Q13: 0.23x — nested OR expansion (3×3=9 branches = 9 fact scans). Cartesian OR explosion.",
        "Q48: 0.41x — same nested OR explosion pattern",
        "Q90: 0.59x — same-column OR (the engine already handles this, see strengths)",
        "Q23: 0.51x — self-join table split. Each UNION branch had to independently re-do the self-join."
      ],
      "field_notes": [
        "The key distinction is CROSS-COLUMN (good candidate) vs SAME-COLUMN (engine handles it).",
        "Count the resulting branches before committing. If nested ORs expand to 6+ branches, it's almost certainly harmful.",
        "Self-joins (same table aliased twice) are risky to split — each branch re-does the self-join independently.",
        "Each UNION branch rescans the fact table. The math: if selectivity per branch is S, benefit = N×(1-S) saved rows vs cost = N extra scans. Only works when S is very small (<20% per branch).",
        "This is high-variance: our biggest win (6.28x) and worst regressions (0.23x) both come from or_to_union. Context matters enormously."
      ]
    },
    {
      "id": "LEFT_JOIN_FILTER_ORDER_RIGIDITY",
      "priority": "MEDIUM",
      "what": "Cannot reorder LEFT JOINs to apply selective dimension filters before expensive fact table joins.",
      "why": "LEFT JOIN must preserve all rows from the left table. The optimizer can't move a dimension filter before the LEFT JOIN.",
      "opportunity": "Pre-filter the selective dimension into a CTE, then use the filtered result as the JOIN partner.",
      "what_worked": [
        "Q93: 2.97x — filtered reason dimension FIRST, then LEFT JOIN to returns then fact",
        "Q80: 1.40x — dimension isolation before fact join"
      ],
      "what_didnt_work": [],
      "field_notes": [
        "Only applies to LEFT JOINs. INNER JOINs are freely reordered by the optimizer.",
        "The dimension filter needs to be highly selective (>50% row reduction) to justify the CTE overhead.",
        "Check EXPLAIN: if a dimension filter appears AFTER a large join, you can restructure to apply it before."
      ]
    },
    {
      "id": "UNION_CTE_SELF_JOIN_DECOMPOSITION",
      "priority": "LOW",
      "what": "When a UNION ALL CTE is self-joined N times with each join filtering to a different discriminator, the optimizer materializes the full UNION once and probes it N times, discarding most rows each time.",
      "why": "The optimizer can't recognize that each probe only needs a partition of the UNION result.",
      "opportunity": "Split the UNION ALL into N separate CTEs (one per discriminator value).",
      "what_worked": [
        "Q74: 1.36x — UNION of store/web sales split into separate year-partitioned CTEs"
      ],
      "what_didnt_work": [],
      "field_notes": [
        "Only applies when the UNION ALL CTE is self-joined 2+ times with different discriminator filters.",
        "When splitting, you MUST remove the original UNION CTE and redirect all references to the new split CTEs. Leaving dead CTEs causes materialization overhead (Q31 hit 0.49x, Q74 hit 0.68x from this mistake)."
      ]
    }
  ]
}
