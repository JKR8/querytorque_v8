Optimize this SQL query for performance.

## Algorithm

1. **FIND BOTTLENECK**: Look at the largest row sources below
2. **REDUCE EARLY**: For each bottleneck, ask "can we filter this earlier?"
   - Push dimension filters INTO CTEs/subqueries before GROUP BY
   - Convert correlated subqueries to window functions or CTEs
   - Join small filtered tables early to reduce rows before aggregation
3. **VERIFY**: Result must return identical data

Principle: The earlier you reduce rows, the faster everything downstream runs.

## Example

WRONG - filters 1M rows AFTER aggregating all 100M:
```sql
WITH sales_agg AS (
    SELECT store_id, SUM(amount) as total
    FROM sales
    GROUP BY store_id  -- aggregates ALL 100M rows
)
SELECT * FROM sales_agg
WHERE store_id IN (SELECT store_id FROM stores WHERE region = 'West')  -- filters AFTER
```

RIGHT - filters to 1M rows BEFORE aggregating:
```sql
WITH sales_agg AS (
    SELECT s.store_id, SUM(amount) as total
    FROM sales
    JOIN stores s ON sales.store_id = s.store_id
    WHERE s.region = 'West'  -- filter BEFORE GROUP BY
    GROUP BY s.store_id  -- aggregates only 1M West rows
)
SELECT * FROM sales_agg
```

The RIGHT version is 100x faster because it aggregates 100x fewer rows.

## Bottlenecks

{bottlenecks}

## Table Scans (with selectivity)

{table_scans_with_selectivity}

## SQL

```sql
{query}
```

## Output

Return:
1. The optimized SQL query
2. One sentence explaining what you changed and why
