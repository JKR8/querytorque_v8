Optimize this SQL query.

## Optimization Process

1. ANALYZE: Look at the plan summary. Find where rows are largest.
2. OPTIMIZE: For each large row source, ask "what could reduce it earlier?"
   - Can a filter be moved inside a CTE/subquery instead of applied after?
   - Can a join with a small table happen INSIDE an aggregation to filter before GROUP BY?
   - Is there a correlated subquery that runs repeatedly? Convert to a single CTE + JOIN.
3. VERIFY: The result must be semantically equivalent.

Key principle: Reduce rows as early as possible.

## Plan Summary

Top operators by cost:
{operators_by_cost}

Table scans:
{table_scans}

Cardinality misestimates:
{misestimates}

## SQL

```sql
{query}
```

## Response Format

Return JSON with patches:

```json
{
  "patches": [
    {
      "search": "exact text from original SQL",
      "replace": "replacement text",
      "description": "What was fixed"
    }
  ],
  "explanation": "Brief explanation"
}
```

Rules:
- search must be EXACT text from original (including whitespace)
- each patch fixes one issue
- patches applied in order
- return valid JSON only, no markdown
