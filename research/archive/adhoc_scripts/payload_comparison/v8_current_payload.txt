============================================================
V8 CURRENT PAYLOAD (what we send now)
============================================================

Optimize this SQL query.

Table scans (row counts):
  - store_returns: 345,507,384 rows
  - date_dim: 73,049 rows
  - customer: 24,000,000 rows
  - CTE_SCAN: 5,436,732 rows
  - COLUMN_DATA_SCAN: 777,703 rows
  - CTE_SCAN: 5,436,732 rows

```sql
-- start query 1 in stream 0 using template query1.tpl
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sum(SR_FEE) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2000
group by sr_customer_sk
,sr_store_sk)
 select c_customer_id
from customer_total_return ctr1
,store
,customer
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk)
and s_store_sk = ctr1.ctr_store_sk
and s_state = 'SD'
and ctr1.ctr_customer_sk = c_customer_sk
order by c_customer_id
 LIMIT 100;

-- end query 1 in stream 0 using template query1.tpl

```

## Optimization Process

Follow this process to optimize:

1. ANALYZE: Look at the row counts. Find where rows are largest.

2. OPTIMIZE: For each large row source, ask "what could reduce it earlier?"
   - Can a filter be moved inside a CTE/subquery instead of applied after?
   - Can a join with a small table happen INSIDE an aggregation to filter before GROUP BY?
   - Is there a correlated subquery that runs repeatedly? Convert to a single CTE + JOIN.

3. VERIFY: The result must be semantically equivalent.

Key principle: **Reduce rows as early as possible.** Move any filtering operation inside aggregations, not after them.

## Output

Return ONLY the optimized SQL in a code block. No explanation needed.

```sql
