# DSPy Full-SQL Mode Prompt (SQLOptimizer)

This is the prompt structure DSPy sends to the LLM for full-SQL optimization.
It uses ChainOfThought to generate reasoning before the output.

## Signature

```python
class SQLOptimizer(dspy.Signature):
    """Optimize SQL query for better execution performance."""

    # INPUTS
    original_query: str       # The original SQL query to optimize
    execution_plan: str       # Parsed execution plan showing operator costs
    row_estimates: str        # Table scan statistics
    optimization_hints: str   # Detected optimization opportunities
    constraints: str          # Model and DB-specific constraints

    # OUTPUTS
    optimized_query: str           # The optimized SQL with identical semantics
    optimization_rationale: str    # Explanation of what was optimized
```

---

## Few-Shot Example 1 (Q15 - 2.98x speedup)

**Original Query:**
```sql
select ca_zip, sum(cs_sales_price)
from catalog_sales, customer, customer_address, date_dim
where cs_bill_customer_sk = c_customer_sk
  and c_current_addr_sk = ca_address_sk
  and (substr(ca_zip,1,5) in ('85669', '86197', ...)
       or ca_state in ('CA','WA','GA')
       or cs_sales_price > 500)
  and cs_sold_date_sk = d_date_sk
  and d_qoy = 1 and d_year = 2001
group by ca_zip order by ca_zip LIMIT 100;
```

**Optimized Query:**
```sql
WITH filtered_dates AS (
    SELECT d_date_sk FROM date_dim WHERE d_qoy = 1 AND d_year = 2001
),
filtered_catalog_sales AS (
    SELECT cs_bill_customer_sk, cs_sales_price, ca_zip
    FROM catalog_sales
    INNER JOIN filtered_dates ON cs_sold_date_sk = d_date_sk
    INNER JOIN customer ON cs_bill_customer_sk = c_customer_sk
    INNER JOIN customer_address ON c_current_addr_sk = ca_address_sk
    WHERE substr(ca_zip,1,5) IN ('85669', '86197', ...)
    UNION ALL
    SELECT ... WHERE ca_state IN ('CA','WA','GA')
    UNION ALL
    SELECT ... WHERE cs_sales_price > 500
)
SELECT ca_zip, SUM(cs_sales_price) FROM filtered_catalog_sales
GROUP BY ca_zip ORDER BY ca_zip LIMIT 100;
```

**Rationale:**
Early date filtering via CTE, OR decomposition into UNION ALL branches for parallel execution.

---

## Few-Shot Example 2 (Q39 - 2.44x speedup)

**Original:** CTE groups all 12 months, main query filters to months 1,2

**Optimized:** Push `d_moy IN (1, 2)` into CTE to filter before aggregation

**Rationale:** Reduced rows before GROUP BY by ~83%

---

## Actual Q1 Input

**original_query:**
```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk,
        sr_store_sk as ctr_store_sk,
        sum(SR_FEE) as ctr_total_return
 from store_returns, date_dim
 where sr_returned_date_sk = d_date_sk and d_year = 2000
 group by sr_customer_sk, sr_store_sk)
select c_customer_id
from customer_total_return ctr1, store, customer
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
                                from customer_total_return ctr2
                                where ctr1.ctr_store_sk = ctr2.ctr_store_sk)
  and s_store_sk = ctr1.ctr_store_sk
  and s_state = 'SD'
  and ctr1.ctr_customer_sk = c_customer_sk
order by c_customer_id LIMIT 100;
```

**execution_plan:**
```
SEQ_SCAN[customer]: 2M rows, 66% cost
HASH_JOIN: 9% cost
HASH_GROUP_BY: 5% cost
```

**row_estimates:**
```
store_returns: 288K rows [NO FILTER]
customer: 2M rows [NO FILTER]
date_dim: 73K rows [FILTERED by d_year]
```

**optimization_hints:**
```
SQL-SUB-001: Correlated Subquery
  Trigger: AVG() in WHERE referencing outer table
  Fix: Convert to window function in CTE
  Speedup: 2.5x
```

**constraints:**
```
DuckDB-specific:
- Window functions are highly optimized
- Hash joins preferred over nested loops
- Filter pushdown very effective (columnar)
```

---

## Expected Output

The LLM generates via ChainOfThought:

1. **reasoning**: "The query has a correlated subquery that computes AVG per store.
   This causes O(n²) behavior. I can compute the threshold once using a window function..."

2. **optimized_query**: Complete rewritten SQL with window function

3. **optimization_rationale**: "Replaced correlated subquery with AVG() OVER (PARTITION BY store_sk)
   computed once in CTE, eliminating O(n²) lookup"
