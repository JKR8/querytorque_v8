Your previous witness data did NOT make the query return any rows.
Output ONLY corrected JSON (same format).

## Query analysis
TABLES:
  date_dim
  item
  store
  store_sales

JOINS:
  item.i_item_sk = sc.ss_item_sk
  store.s_store_sk = sc.ss_store_sk
  sb.ss_store_sk = sc.ss_store_sk
  store_sales.ss_sold_date_sk = date_dim.d_date_sk

FILTERS:
  store.s_state IN ('KS', 'OH', 'SD')
  item.i_manager_id BETWEEN 10 AND 14
  sc.revenue <= 0.1 * sb.ave
  ss_sales_price / ss_list_price BETWEEN 79 * 0.01 AND 89 * 0.01
  date_dim.d_month_seq BETWEEN 1215 AND 1215 + 11

AGGREGATES:
  GROUP BY: store_sales.ss_store_sk
  GROUP BY: store_sales.ss_store_sk, store_sales.ss_item_sk

NOTES:
  Division in filter: ss_sales_price / ss_list_price — denominator must be > 0
  Division in filter: ss_sales_price / ss_list_price — denominator must be > 0
  Division in filter: ss_sales_price / ss_list_price — denominator must be > 0

COLUMNS NEEDED (table.column : type):
  date_dim: d_date_sk (INTEGER), d_month_seq (INTEGER)
  item: i_brand (VARCHAR), i_current_price (DECIMAL(7), i_item_desc (VARCHAR), i_item_sk (INTEGER), i_manager_id (INTEGER), i_wholesale_cost (DECIMAL(7)
  store: s_state (VARCHAR), s_store_name (VARCHAR), s_store_sk (INTEGER)
  store_sales: ss_item_sk (INTEGER), ss_list_price (DECIMAL(7), ss_sales_price (DECIMAL(7), ss_sold_date_sk (INTEGER), ss_store_sk (INTEGER)

## Feedback
Table/CTE diagnostics:
Table date_dim: 2 rows
Table item: 4 rows
Table store: 2 rows
Table store_sales: 4 rows

No SQL errors, but query returned 0 rows. The data satisfied the schema but NOT the query logic. Check: join FK matches, WHERE filter values, aggregate math.

## Your previous data
{
  "reasoning": "We need at least 2 rows in the final result. The query groups by ss_store_sk, ss_item_sk in subquery sc, then filters sc.revenue <= 0.1 * sb.ave (where sb.ave is the average revenue per item per store). To satisfy this, we need at least two distinct (store, item) pairs where each pair's revenue is very small compared to the store's average revenue across items. We'll create two stores (KS and OH) each with two items. For each store, we'll set one item's revenue to 1 and the other to 1000, making the average (1+1000)/2 = 500.5. Then 0.1 * ave = 50.05. The item with revenue 1 passes the filter (1 <= 50.05). Both stores will contribute one qualifying row, giving two final rows. Ensure all filters: s_state in ('KS','OH','SD'), i_manager_id between 10 and 14, d_month_seq between 1215 and 1226, ss_sales_price/ss_list_price between 0.79 and 0.89 (set ss_list_price=10, ss_sales_price=8 for all rows).",
  "tables": {
    "date_dim": {
      "columns": [
        "d_date_sk",
        "d_month_seq"
      ],
      "rows": [
        [
          1000,
          1215
        ],
        [
          1001,
          1216
        ]
      ]
    },
    "item": {
      "columns": [
        "i_item_sk",
        "i_manager_id",
        "i_brand",
        "i_current_price",
        "i_item_desc",
        "i_wholesale_cost"
      ],
      "rows": [
        [
          2000,
          10,
          "BrandA",
          15.0,
          "Item one",
          5.0
        ],
        [
          2001,
          11,
          "BrandB",
          20.0,
          "Item two",
          8.0
        ],
        [
          2002,
          12,
          "BrandC",
          18.0,
          "Item three",
          6.0
        ],
        [
          2003,
          13,
          "BrandD",
          22.0,
          "Item four",
          9.0
        ]
      ]
    },
    "store": {
      "columns": [
        "s_store_sk",
        "s_state",
        "s_store_name"
      ],
      "rows": [
        [
          3000,
          "KS",
          "Store KS"
        ],
        [
          3001,
          "OH",
          "Store OH"
        ]
      ]
    },
    "store_sales": {
      "columns": [
        "ss_sold_date_sk",
        "ss_store_sk",
        "ss_item_sk",
        "ss_sales_price",
        "ss_list_price"
      ],
      "rows": [
        [
          1000,
          3000,
          2000,
          8.0,
          10.0
        ],
        [
          1000,
          3000,
          2001,
          8.0,
          10.0
        ],
        [
          1001,
          3001,
          2002,
          8.0,
          10.0
        ],
        [
          1001,
          3001,
          2003,
          8.0,
          10.0
        ]
      ]
    }
  }
}

## SQL
select 
	s_store_name,
	i_item_desc,
	sc.revenue,
	i_current_price,
	i_wholesale_cost,
	i_brand
 from store, item,
     (select ss_store_sk, avg(revenue) as ave
 	from
 	    (select  ss_store_sk, ss_item_sk,
 		     sum(ss_sales_price) as revenue
 		from store_sales, date_dim
 		where ss_sold_date_sk = d_date_sk and d_month_seq between 1215 and 1215+11
    and ss_sales_price / ss_list_price BETWEEN 79 * 0.01 AND 89 * 0.01
 		group by ss_store_sk, ss_item_sk) sa
 	group by ss_store_sk) sb,
     (select  ss_store_sk, ss_item_sk, sum(ss_sales_price) as revenue
 	from store_sales, date_dim
 	where ss_sold_date_sk = d_date_sk and d_month_seq between 1215 and 1215+11
  and ss_sales_price / ss_list_price BETWEEN 79 * 0.01 AND 89 * 0.01
 	group by ss_store_sk, ss_item_sk) sc
 where sb.ss_store_sk = sc.ss_store_sk and
       sc.revenue <= 0.1 * sb.ave and
       s_store_sk = sc.ss_store_sk and
       i_item_sk = sc.ss_item_sk
       and i_manager_id BETWEEN 10 and 14
       and s_state in ('KS','OH','SD')
 order by s_store_name, i_item_desc
limit 100;


Common mistakes:
- Missing FK rows (every _sk join needs matching rows on BOTH sides)
- Aggregate math wrong (need value > avg*1.2 but only 1 row per group = impossible)
- Division by zero (denominator columns must be > 0)
- Date or string values don't match FILTERS exactly
