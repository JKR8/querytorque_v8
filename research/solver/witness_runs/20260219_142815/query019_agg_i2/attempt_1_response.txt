{
  "reasoning": "We need at least 2 rows in the result after grouping by i_brand, i_brand_id, i_manufact_id, i_manufact. So we need at least two distinct brand/manufacturer combinations that satisfy all filters. We'll create two items in category 'Shoes' with different brands/manufacturers. For each, we need a store_sales row with ss_wholesale_cost between 76 and 96, linked to a customer with c_birth_month=2, customer_address with ca_state='KS', date_dim with d_moy=2 and d_year=1999, and store. Also, the condition substring(ca_zip,1,5) <> substring(s_zip,1,5) must hold, so we set different zip prefixes. We'll create one store, one customer_address, one customer, one date_dim row, and two items. Then two store_sales rows linking them all, with different items to get two groups.",
  "tables": {
    "customer": {
      "columns": ["c_customer_sk", "c_current_addr_sk", "c_birth_month"],
      "rows": [[1000, 1000, 2]]
    },
    "customer_address": {
      "columns": ["ca_address_sk", "ca_state"],
      "rows": [[1000, "KS"]]
    },
    "date_dim": {
      "columns": ["d_date_sk", "d_moy", "d_year"],
      "rows": [[1000, 2, 1999]]
    },
    "item": {
      "columns": ["i_item_sk", "i_brand", "i_brand_id", "i_category", "i_manufact", "i_manufact_id"],
      "rows": [[1000, "BrandA", 1, "Shoes", "ManufactX", 10], [1001, "BrandB", 2, "Shoes", "ManufactY", 11]]
    },
    "store": {
      "columns": ["s_store_sk"],
      "rows": [[1000]]
    },
    "store_sales": {
      "columns": ["ss_item_sk", "ss_customer_sk", "ss_sold_date_sk", "ss_store_sk", "ss_wholesale_cost", "ss_ext_sales_price"],
      "rows": [[1000, 1000, 1000, 1000, 80.0, 100.0], [1001, 1000, 1000, 1000, 85.0, 150.0]]
    }
  }
}