Your previous witness data did NOT make the query return any rows.
Output ONLY corrected JSON (same format).

## Query analysis
TABLES:
  customer
  customer_address
  date_dim
  item
  store
  store_sales

JOINS:
  store_sales.ss_store_sk = store.s_store_sk
  customer.c_current_addr_sk = customer_address.ca_address_sk
  store_sales.ss_customer_sk = customer.c_customer_sk
  date_dim.d_date_sk = store_sales.ss_sold_date_sk
  store_sales.ss_item_sk = item.i_item_sk

FILTERS:
  store_sales.ss_wholesale_cost BETWEEN 76 AND 96
  customer.c_birth_month = 2
  customer_address.ca_state = 'KS'
  date_dim.d_moy = 2
  date_dim.d_year = 1999
  item.i_category = 'Shoes'

AGGREGATES:
  GROUP BY: item.i_brand, item.i_brand_id, item.i_manufact_id, item.i_manufact

COLUMNS NEEDED (table.column : type):
  customer: c_birth_month (INTEGER), c_current_addr_sk (INTEGER), c_customer_sk (INTEGER)
  customer_address: ca_address_sk (INTEGER), ca_state (VARCHAR)
  date_dim: d_date_sk (INTEGER), d_moy (INTEGER), d_year (INTEGER)
  item: i_brand (VARCHAR), i_brand_id (INTEGER), i_category (VARCHAR), i_item_sk (INTEGER), i_manufact (VARCHAR), i_manufact_id (INTEGER)
  store: s_store_sk (INTEGER)
  store_sales: ss_customer_sk (INTEGER), ss_ext_sales_price (DECIMAL(7), ss_item_sk (INTEGER), ss_sold_date_sk (INTEGER), ss_store_sk (INTEGER), ss_wholesale_cost (DECIMAL(7)

## Feedback
Table/CTE diagnostics:
Table date_dim: 1 rows
Table item: 2 rows
Table store_sales: 2 rows

No SQL errors, but query returned 0 rows. The data satisfied the schema but NOT the query logic. Check: join FK matches, WHERE filter values, aggregate math.

## Your previous data
{
  "reasoning": "We need at least 2 rows in the result after grouping by i_brand, i_brand_id, i_manufact_id, i_manufact. So we need at least two distinct brand/manufacturer combinations that satisfy all filters. We'll create two items in category 'Shoes' with different brands/manufacturers. For each, we need a store_sales row with ss_wholesale_cost between 76 and 96, linked to a customer with c_birth_month=2, customer_address with ca_state='KS', date_dim with d_moy=2 and d_year=1999, and store. Also, the condition substring(ca_zip,1,5) <> substring(s_zip,1,5) must hold, so we set different zip prefixes. We'll create one store, one customer_address, one customer, one date_dim row, and two items. Then two store_sales rows linking them all, with different items to get two groups.",
  "tables": {
    "customer": {
      "columns": [
        "c_customer_sk",
        "c_current_addr_sk",
        "c_birth_month"
      ],
      "rows": [
        [
          1000,
          1000,
          2
        ]
      ]
    },
    "customer_address": {
      "columns": [
        "ca_address_sk",
        "ca_state"
      ],
      "rows": [
        [
          1000,
          "KS"
        ]
      ]
    },
    "date_dim": {
      "columns": [
        "d_date_sk",
        "d_moy",
        "d_year"
      ],
      "rows": [
        [
          1000,
          2,
          1999
        ]
      ]
    },
    "item": {
      "columns": [
        "i_item_sk",
        "i_brand",
        "i_brand_id",
        "i_category",
        "i_manufact",
        "i_manufact_id"
      ],
      "rows": [
        [
          1000,
          "BrandA",
          1,
          "Shoes",
          "ManufactX",
          10
        ],
        [
          1001,
          "BrandB",
          2,
          "Shoes",
          "ManufactY",
          11
        ]
      ]
    },
    "store": {
      "columns": [
        "s_store_sk"
      ],
      "rows": [
        [
          1000
        ]
      ]
    },
    "store_sales": {
      "columns": [
        "ss_item_sk",
        "ss_customer_sk",
        "ss_sold_date_sk",
        "ss_store_sk",
        "ss_wholesale_cost",
        "ss_ext_sales_price"
      ],
      "rows": [
        [
          1000,
          1000,
          1000,
          1000,
          80.0,
          100.0
        ],
        [
          1001,
          1000,
          1000,
          1000,
          85.0,
          150.0
        ]
      ]
    }
  }
}

## SQL
select  i_brand_id brand_id, i_brand brand, i_manufact_id, i_manufact,
 	sum(ss_ext_sales_price) ext_price
  from date_dim, store_sales, item,customer,customer_address,store
  where  d_date_sk = ss_sold_date_sk
    and ss_item_sk = i_item_sk
    and ss_customer_sk = c_customer_sk
    and c_current_addr_sk = ca_address_sk
    and ss_store_sk = s_store_sk
    AND i_category  = 'Shoes'
    and d_year=1999
    and d_moy = 2
    and substring(ca_zip,1,5) <> substring(s_zip,1,5)
    and ca_state  = 'KS'
    and c_birth_month = 2
    and ss_wholesale_cost BETWEEN 76 AND 96
 group by i_brand
      ,i_brand_id
      ,i_manufact_id
      ,i_manufact
 order by ext_price desc
         ,i_brand
         ,i_brand_id
         ,i_manufact_id
         ,i_manufact
limit 100 ;


Common mistakes:
- Missing FK rows (every _sk join needs matching rows on BOTH sides)
- Aggregate math wrong (need value > avg*1.2 but only 1 row per group = impossible)
- Division by zero (denominator columns must be > 0)
- Date or string values don't match FILTERS exactly
