Generate minimal witness data so this SQL query returns at least 2 rows.
Output ONLY valid JSON â€” no markdown fences, no extra text.

## Query analysis (pre-computed)
TABLES:
  customer_address (alias: ad1)
  customer_address (alias: ad2)
  catalog_returns
  catalog_sales
  customer_demographics (alias: cd1)
  customer_demographics (alias: cd2)
  customer
  date_dim (alias: d1)
  date_dim (alias: d2)
  date_dim (alias: d3)
  household_demographics (alias: hd1)
  household_demographics (alias: hd2)
  income_band (alias: ib1)
  income_band (alias: ib2)
  item
  promotion
  store
  store_returns
  store_sales

JOINS:
  catalog_sales.cs_item_sk = catalog_returns.cr_item_sk
  catalog_sales.cs_order_number = catalog_returns.cr_order_number
  household_demographics.hd_income_band_sk = income_band.ib_income_band_sk
  store_sales.ss_promo_sk = promotion.p_promo_sk
  customer.c_first_shipto_date_sk = date_dim.d_date_sk
  customer.c_first_sales_date_sk = date_dim.d_date_sk
  customer.c_current_addr_sk = customer_address.ca_address_sk
  customer.c_current_hdemo_sk = household_demographics.hd_demo_sk
  customer.c_current_cdemo_sk = customer_demographics.cd_demo_sk
  store_sales.ss_item_sk = cs_ui.cs_item_sk
  store_sales.ss_ticket_number = store_returns.sr_ticket_number
  store_sales.ss_item_sk = store_returns.sr_item_sk
  store_sales.ss_item_sk = item.i_item_sk
  store_sales.ss_addr_sk = customer_address.ca_address_sk
  store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk
  store_sales.ss_cdemo_sk = customer_demographics.cd_demo_sk
  store_sales.ss_customer_sk = customer.c_customer_sk
  store_sales.ss_store_sk = store.s_store_sk
  store_sales.ss_sold_date_sk = date_dim.d_date_sk

FILTERS:
  cross_sales.cnt <= cross_sales.cnt
  cross_sales.syear = 1998 + 1
  cross_sales.syear = 1998
  catalog_sales.cs_wholesale_cost BETWEEN 35 AND 55
  customer_demographics.cd_education_status IN ('Unknown', 'Advanced Degree', 'College')
  customer_demographics.cd_marital_status IN ('M', 'M', 'U')
  store_sales.ss_wholesale_cost BETWEEN 35 AND 55
  customer_address.ca_state IN ('IA', 'IL', 'TX')
  promotion.p_channel_radio = 'N'
  promotion.p_channel_tv = 'Y'
  promotion.p_channel_email = 'N'
  item.i_current_price BETWEEN 26 AND 26 + 10

AGGREGATES:
  GROUP BY: catalog_sales.cs_item_sk
  GROUP BY: item.i_product_name, item.i_item_sk, store.s_store_name, store.s_zip, customer_address.ca_street_number, customer_address.ca_street_name, customer_address.ca_city, customer_address.ca_zip, customer_address.ca_street_number, customer_address.ca_street_name, customer_address.ca_city, customer_address.ca_zip, date_dim.d_year, date_dim.d_year, date_dim.d_year

CTEs:
  cs_ui:
    FROM: catalog_sales, catalog_returns
    WHERE: catalog_sales.cs_wholesale_cost BETWEEN 35 AND 55, catalog_sales.cs_item_sk = catalog_returns.cr_item_sk (JOIN), catalog_sales.cs_order_number = catalog_returns.cr_order_number (JOIN)
    GROUP BY: catalog_sales.cs_item_sk
    OUTPUT: catalog_sales.cs_item_sk, sale = SUM(cs_ext_list_price), refund = SUM(cr_refunded_cash + cr_reversed_charge + cr_store_credit)
  cross_sales:
    FROM: store_sales, store_returns, date_dim, date_dim, date_dim, store, customer, customer_demographics, customer_demographics, promotion, household_demographics, household_demographics, customer_address, customer_address, income_band, income_band, item
    WHERE: store_sales.ss_wholesale_cost BETWEEN 35 AND 55, promotion.p_channel_radio = 'N', promotion.p_channel_tv = 'Y', promotion.p_channel_email = 'N', item.i_current_price BETWEEN 26 AND 26 + 10, household_demographics.hd_income_band_sk = income_band.ib_income_band_sk (JOIN), household_demographics.hd_income_band_sk = income_band.ib_income_band_sk (JOIN), store_sales.ss_promo_sk = promotion.p_promo_sk (JOIN), customer.c_first_shipto_date_sk = date_dim.d_date_sk (JOIN), customer.c_first_sales_date_sk = date_dim.d_date_sk (JOIN), customer.c_current_addr_sk = customer_address.ca_address_sk (JOIN), customer.c_current_hdemo_sk = household_demographics.hd_demo_sk (JOIN), customer.c_current_cdemo_sk = customer_demographics.cd_demo_sk (JOIN), store_sales.ss_item_sk = cs_ui.cs_item_sk (JOIN), store_sales.ss_ticket_number = store_returns.sr_ticket_number (JOIN), store_sales.ss_item_sk = store_returns.sr_item_sk (JOIN), store_sales.ss_item_sk = item.i_item_sk (JOIN), store_sales.ss_addr_sk = customer_address.ca_address_sk (JOIN), store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk (JOIN), store_sales.ss_cdemo_sk = customer_demographics.cd_demo_sk (JOIN), store_sales.ss_customer_sk = customer.c_customer_sk (JOIN), store_sales.ss_store_sk = store.s_store_sk (JOIN), store_sales.ss_sold_date_sk = date_dim.d_date_sk (JOIN)
    GROUP BY: item.i_product_name, item.i_item_sk, store.s_store_name, store.s_zip, customer_address.ca_street_number, customer_address.ca_street_name, customer_address.ca_city, customer_address.ca_zip, customer_address.ca_street_number, customer_address.ca_street_name, customer_address.ca_city, customer_address.ca_zip, date_dim.d_year, date_dim.d_year, date_dim.d_year
    OUTPUT: product_name = item.i_product_name, item_sk = item.i_item_sk, store_name = store.s_store_name, store_zip = store.s_zip, b_street_number = customer_address.ca_street_number, b_street_name = customer_address.ca_street_name, b_city = customer_address.ca_city, b_zip = customer_address.ca_zip, c_street_number = customer_address.ca_street_number, c_street_name = customer_address.ca_street_name, c_city = customer_address.ca_city, c_zip = customer_address.ca_zip, syear = date_dim.d_year, fsyear = date_dim.d_year, s2year = date_dim.d_year, cnt = COUNT(*), s1 = SUM(ss_wholesale_cost), s2 = SUM(ss_list_price), s3 = SUM(ss_coupon_amt)

COLUMNS NEEDED (table.column : type):
  catalog_returns: cr_item_sk (INTEGER), cr_order_number (INTEGER), cr_refunded_cash (DECIMAL(7), cr_reversed_charge (DECIMAL(7), cr_store_credit (DECIMAL(7)
  catalog_sales: cs_ext_list_price (DECIMAL(7), cs_item_sk (INTEGER), cs_order_number (INTEGER), cs_wholesale_cost (DECIMAL(7)
  customer: c_current_addr_sk (INTEGER), c_current_cdemo_sk (INTEGER), c_current_hdemo_sk (INTEGER), c_customer_sk (INTEGER), c_first_sales_date_sk (INTEGER), c_first_shipto_date_sk (INTEGER)
  customer_address: ca_address_sk (INTEGER), ca_city (VARCHAR), ca_state (VARCHAR), ca_street_name (VARCHAR), ca_street_number (VARCHAR), ca_zip (VARCHAR)
  customer_demographics: cd_demo_sk (INTEGER), cd_education_status (VARCHAR), cd_marital_status (VARCHAR)
  date_dim: d_date_sk (INTEGER), d_year (INTEGER)
  household_demographics: hd_demo_sk (INTEGER), hd_income_band_sk (INTEGER)
  income_band: ib_income_band_sk (INTEGER)
  item: i_current_price (DECIMAL(7), i_item_sk (INTEGER), i_product_name (VARCHAR)
  promotion: p_channel_email (VARCHAR), p_channel_radio (VARCHAR), p_channel_tv (VARCHAR), p_promo_sk (INTEGER)
  store: s_store_name (VARCHAR), s_store_sk (INTEGER), s_zip (VARCHAR)
  store_returns: sr_item_sk (INTEGER), sr_ticket_number (INTEGER)
  store_sales: ss_addr_sk (INTEGER), ss_cdemo_sk (INTEGER), ss_coupon_amt (DECIMAL(7), ss_customer_sk (INTEGER), ss_hdemo_sk (INTEGER), ss_item_sk (INTEGER), ss_list_price (DECIMAL(7), ss_promo_sk (INTEGER), ss_sold_date_sk (INTEGER), ss_store_sk (INTEGER), ss_ticket_number (INTEGER), ss_wholesale_cost (DECIMAL(7)

## SQL (for reference)
with cs_ui as
 (select cs_item_sk
        ,sum(cs_ext_list_price) as sale,sum(cr_refunded_cash+cr_reversed_charge+cr_store_credit) as refund
  from catalog_sales
      ,catalog_returns
  where cs_item_sk = cr_item_sk
    and cs_order_number = cr_order_number
    and cs_wholesale_cost BETWEEN 35 AND 55
   group by cs_item_sk
  having sum(cs_ext_list_price)>2*sum(cr_refunded_cash+cr_reversed_charge+cr_store_credit)),
cross_sales as
 (select i_product_name product_name
     ,i_item_sk item_sk
     ,s_store_name store_name
     ,s_zip store_zip
     ,ad1.ca_street_number b_street_number
     ,ad1.ca_street_name b_street_name
     ,ad1.ca_city b_city
     ,ad1.ca_zip b_zip
     ,ad2.ca_street_number c_street_number
     ,ad2.ca_street_name c_street_name
     ,ad2.ca_city c_city
     ,ad2.ca_zip c_zip
     ,d1.d_year as syear
     ,d2.d_year as fsyear
     ,d3.d_year s2year
     ,count(*) cnt
     ,sum(ss_wholesale_cost) s1
     ,sum(ss_list_price) s2
     ,sum(ss_coupon_amt) s3
  FROM   store_sales
        ,store_returns
        ,cs_ui
        ,date_dim d1
        ,date_dim d2
        ,date_dim d3
        ,store
        ,customer
        ,customer_demographics cd1
        ,customer_demographics cd2
        ,promotion
        ,household_demographics hd1
        ,household_demographics hd2
        ,customer_address ad1
        ,customer_address ad2
        ,income_band ib1
        ,income_band ib2
        ,item
  WHERE  ss_store_sk = s_store_sk AND
         ss_sold_date_sk = d1.d_date_sk AND
         ss_customer_sk = c_customer_sk AND
         ss_cdemo_sk= cd1.cd_demo_sk AND
         ss_hdemo_sk = hd1.hd_demo_sk AND
         ss_addr_sk = ad1.ca_address_sk and
         ss_item_sk = i_item_sk and
         ss_item_sk = sr_item_sk and
         ss_ticket_number = sr_ticket_number and
         ss_item_sk = cs_ui.cs_item_sk and
         c_current_cdemo_sk = cd2.cd_demo_sk AND
         c_current_hdemo_sk = hd2.hd_demo_sk AND
         c_current_addr_sk = ad2.ca_address_sk and
         c_first_sales_date_sk = d2.d_date_sk and
         c_first_shipto_date_sk = d3.d_date_sk and
         ss_promo_sk = p_promo_sk and
         hd1.hd_income_band_sk = ib1.ib_income_band_sk and
         hd2.hd_income_band_sk = ib2.ib_income_band_sk and
         cd1.cd_marital_status <> cd2.cd_marital_status and
         i_current_price between 26 and 26 + 10
         and p_channel_email = 'N'
         and p_channel_tv = 'Y'
         and p_channel_radio = 'N'
         and ad2.ca_state in ('IA','IL','TX')
         and ss_wholesale_cost BETWEEN 35 AND 55
         and cd1.cd_marital_status in ('M', 'M', 'U')
         and cd1.cd_education_status in ('Unknown', 'Advanced Degree', 'College')
         and cd2.cd_marital_status in ('M', 'M', 'U')
         and cd2.cd_education_status in ('Unknown', 'Advanced Degree', 'College')
group by i_product_name
       ,i_item_sk
       ,s_store_name
       ,s_zip
       ,ad1.ca_street_number
       ,ad1.ca_street_name
       ,ad1.ca_city
       ,ad1.ca_zip
       ,ad2.ca_street_number
       ,ad2.ca_street_name
       ,ad2.ca_city
       ,ad2.ca_zip
       ,d1.d_year
       ,d2.d_year
       ,d3.d_year
)
select cs1.product_name
     ,cs1.store_name
     ,cs1.store_zip
     ,cs1.b_street_number
     ,cs1.b_street_name
     ,cs1.b_city
     ,cs1.b_zip
     ,cs1.c_street_number
     ,cs1.c_street_name
     ,cs1.c_city
     ,cs1.c_zip
     ,cs1.syear
     ,cs1.cnt
     ,cs1.s1 as s11
     ,cs1.s2 as s21
     ,cs1.s3 as s31
     ,cs2.s1 as s12
     ,cs2.s2 as s22
     ,cs2.s3 as s32
     ,cs2.syear
     ,cs2.cnt
from cross_sales cs1,cross_sales cs2
where cs1.item_sk=cs2.item_sk and
     cs1.syear = 1998 and
     cs2.syear = 1998 + 1 and
     cs2.cnt <= cs1.cnt and
     cs1.store_name = cs2.store_name and
     cs1.store_zip = cs2.store_zip
order by cs1.product_name
       ,cs1.store_name
       ,cs2.cnt
       ,cs1.s1
       ,cs2.s1
;


## Example (different query, shows the format)
For a query: "SELECT c_name FROM customer, store WHERE c_store_sk = s_store_sk AND s_state = 'TX' AND c_age > (SELECT avg(c_age)*1.2 FROM customer c2 WHERE c2.c_store_sk = c.c_store_sk)"

{"reasoning": "Need 2+ customers at same store. avg age = (50+20)/2=35, 1.2*35=42. Customer with age 50>42 qualifies. Second store: avg=(60+25)/2=42.5, 1.2*42.5=51. Customer 60>51 qualifies.", "tables": {"store": {"columns": ["s_store_sk", "s_state"], "rows": [[1000, "TX"], [1001, "TX"]]}, "customer": {"columns": ["c_customer_sk", "c_name", "c_store_sk", "c_age"], "rows": [[2000, "Alice", 1000, 50], [2001, "Bob", 1000, 20], [2002, "Carol", 1001, 60], [2003, "Dan", 1001, 25]]}}}

## Rules
1. Include ONLY the columns listed in COLUMNS NEEDED above.
2. Every _sk join must have matching rows on both sides.
3. For correlated aggregate comparisons (value > avg*1.2): you need 2+ rows per group.
   The "winner" row's value must exceed 1.2x the group average (which includes that row).
   SHOW THE MATH in reasoning.
4. Denominators in division must be > 0.
5. String values are case-sensitive: use exact values from FILTERS.
6. Use integer keys starting at 1000.
7. Dates as strings: "2002-06-15".
8. null for columns you don't care about.
