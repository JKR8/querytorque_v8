Generate minimal witness data so this SQL query returns at least 2 rows.
Output ONLY valid JSON â€” no markdown fences, no extra text.

## Query analysis (pre-computed)
TABLES:
  catalog_sales
  customer
  customer_address
  date_dim
  item
  store
  store_sales
  web_sales

JOINS:
  customer.c_customer_sk = cs_or_ws_sales.customer_sk
  customer.c_customer_sk = store_sales.ss_customer_sk
  store_sales.ss_sold_date_sk = date_dim.d_date_sk
  customer_address.ca_state = store.s_state
  customer.c_current_addr_sk = customer_address.ca_address_sk
  customer_address.ca_county = store.s_county

FILTERS:
  customer.c_birth_year BETWEEN 1928 AND 1941
  wholesale_cost BETWEEN 35 AND 65
  date_dim.d_year = 1998
  date_dim.d_moy = 1
  item.i_class = 'personal'
  item.i_category = 'Electronics'
  sold_date_sk = date_dim.d_date_sk
  item_sk = item.i_item_sk
  date_dim.d_month_seq BETWEEN (SELECT DISTINCT d_month_seq + 1 FROM date_dim WHERE d_year = 1998 AND d_moy = 1) AND (SELECT DISTINCT d_month_seq + 3 FROM date_dim WHERE d_year = 1998 AND d_moy = 1)
  store.s_state IN ('AR', 'CO', 'IA', 'IL', 'KY', 'NC', 'NM', 'NY', 'PA', 'TX')
  store_sales.ss_wholesale_cost BETWEEN 35 AND 65

AGGREGATES:
  GROUP BY: segment
  GROUP BY: customer.c_customer_sk

CTEs:
  my_customers:
    FROM: item, date_dim, customer, catalog_sales, web_sales
    WHERE: customer.c_birth_year BETWEEN 1928 AND 1941, wholesale_cost BETWEEN 35 AND 65, date_dim.d_year = 1998, date_dim.d_moy = 1, customer.c_customer_sk = cs_or_ws_sales.customer_sk (JOIN), item.i_class = 'personal', item.i_category = 'Electronics', sold_date_sk = date_dim.d_date_sk (JOIN), item_sk = item.i_item_sk (JOIN)
    OUTPUT: customer.c_customer_sk, customer.c_current_addr_sk
  my_revenue:
    FROM: store_sales, customer_address, store, date_dim, date_dim, date_dim
    WHERE: date_dim.d_month_seq BETWEEN (SELECT DISTINCT d_month_seq + 1 FROM date_dim WHERE d_year = 1998 AND d_moy = 1) AND (SELECT DISTINCT d_month_seq + 3 FROM date_dim WHERE d_year = 1998 AND d_moy = 1), store_sales.ss_wholesale_cost BETWEEN 35 AND 65, customer.c_customer_sk = store_sales.ss_customer_sk (JOIN), store_sales.ss_sold_date_sk = date_dim.d_date_sk (JOIN), customer_address.ca_state = store.s_state (JOIN), date_dim.d_year = 1998, date_dim.d_moy = 1, date_dim.d_year = 1998, date_dim.d_moy = 1, customer.c_current_addr_sk = customer_address.ca_address_sk (JOIN), customer_address.ca_county = store.s_county (JOIN)
    GROUP BY: customer.c_customer_sk
    OUTPUT: customer.c_customer_sk, revenue = SUM(ss_ext_sales_price)
  segments:
    FROM: 
    OUTPUT: segment = CAST((revenue / 50) AS INT)

COLUMNS NEEDED (table.column : type):
  customer: c_birth_year (INTEGER), c_current_addr_sk (INTEGER), c_customer_sk (INTEGER)
  customer_address: ca_address_sk (INTEGER), ca_county (VARCHAR), ca_state (VARCHAR)
  date_dim: d_date_sk (INTEGER), d_month_seq (INTEGER), d_moy (INTEGER), d_year (INTEGER)
  item: i_category (VARCHAR), i_class (VARCHAR), i_item_sk (INTEGER)
  store: s_county (VARCHAR), s_state (VARCHAR)
  store_sales: ss_customer_sk (INTEGER), ss_ext_sales_price (DECIMAL(7), ss_sold_date_sk (INTEGER), ss_wholesale_cost (DECIMAL(7)

## SQL (for reference)
with my_customers as (
 select distinct c_customer_sk
        , c_current_addr_sk
 from
        ( select cs_sold_date_sk sold_date_sk,
                 cs_bill_customer_sk customer_sk,
                 cs_item_sk item_sk,
                 cs_wholesale_cost wholesale_cost
          from   catalog_sales
          union all
          select ws_sold_date_sk sold_date_sk,
                 ws_bill_customer_sk customer_sk,
                 ws_item_sk item_sk,
                 ws_wholesale_cost wholesale_cost
          from   web_sales
         ) cs_or_ws_sales,
         item,
         date_dim,
         customer
 where   sold_date_sk = d_date_sk
         and item_sk = i_item_sk
         and i_category = 'Electronics'
         and i_class = 'personal'
         and c_customer_sk = cs_or_ws_sales.customer_sk
         and d_moy = 1
         and d_year = 1998
         and wholesale_cost BETWEEN 35 AND 65
         and c_birth_year BETWEEN 1928 AND 1941
 )
 , my_revenue as (
 select c_customer_sk,
        sum(ss_ext_sales_price) as revenue
 from   my_customers,
        store_sales,
        customer_address,
        store,
        date_dim
 where  c_current_addr_sk = ca_address_sk
        and ca_county = s_county
        and ca_state = s_state
        and ss_sold_date_sk = d_date_sk
        and c_customer_sk = ss_customer_sk
        and ss_wholesale_cost BETWEEN 35 AND 65
        and s_state in ('AR','CO','IA'
                    ,'IL','KY','NC'
                    ,'NM','NY','PA'
                    ,'TX')
        and d_month_seq between (select distinct d_month_seq+1
                                 from   date_dim where d_year = 1998 and d_moy = 1)
                           and  (select distinct d_month_seq+3
                                 from   date_dim where d_year = 1998 and d_moy = 1)
 group by c_customer_sk
 )
 , segments as
 (select cast((revenue/50) as int) as segment
  from   my_revenue
 )
  select  segment, count(*) as num_customers, segment*50 as segment_base
 from segments
 group by segment
 order by segment, num_customers
 limit 100;


## Example (different query, shows the format)
For a query: "SELECT c_name FROM customer, store WHERE c_store_sk = s_store_sk AND s_state = 'TX' AND c_age > (SELECT avg(c_age)*1.2 FROM customer c2 WHERE c2.c_store_sk = c.c_store_sk)"

{"reasoning": "Need 2+ customers at same store. avg age = (50+20)/2=35, 1.2*35=42. Customer with age 50>42 qualifies. Second store: avg=(60+25)/2=42.5, 1.2*42.5=51. Customer 60>51 qualifies.", "tables": {"store": {"columns": ["s_store_sk", "s_state"], "rows": [[1000, "TX"], [1001, "TX"]]}, "customer": {"columns": ["c_customer_sk", "c_name", "c_store_sk", "c_age"], "rows": [[2000, "Alice", 1000, 50], [2001, "Bob", 1000, 20], [2002, "Carol", 1001, 60], [2003, "Dan", 1001, 25]]}}}

## Rules
1. Include ONLY the columns listed in COLUMNS NEEDED above.
2. Every _sk join must have matching rows on both sides.
3. For correlated aggregate comparisons (value > avg*1.2): you need 2+ rows per group.
   The "winner" row's value must exceed 1.2x the group average (which includes that row).
   SHOW THE MATH in reasoning.
4. Denominators in division must be > 0.
5. String values are case-sensitive: use exact values from FILTERS.
6. Use integer keys starting at 1000.
7. Dates as strings: "2002-06-15".
8. null for columns you don't care about.
