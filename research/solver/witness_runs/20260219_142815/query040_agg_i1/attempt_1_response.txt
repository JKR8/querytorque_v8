{
  "reasoning": "Need 2+ groups (w_state, i_item_id) with at least one catalog_sales row each, matching all filters. For each group, we need one catalog_sales row with a matching catalog_returns row (cr_reason_sk=33) and matching date_dim, item, warehouse rows. We'll create two groups: (w_state='CA', i_item_id='item1') and (w_state='NY', i_item_id='item2'). For each group, we need one catalog_sales row with cs_wholesale_cost between 42 and 61, and a matching catalog_returns row. The item rows must have i_category='Jewelry' and i_manager_id between 61 and 100. The date_dim rows must have d_date between '2002-01-20' and '2002-03-21' (30 days before/after 2002-02-19). We'll pick dates: one before 2002-02-19 (e.g., '2002-02-10') and one after (e.g., '2002-02-28') to ensure both sales_before and sales_after sums are non-zero for demonstration, but the query only sums per group across all rows. We'll assign unique _sk keys starting at 1000.",
  "tables": {
    "warehouse": {
      "columns": ["w_warehouse_sk", "w_state"],
      "rows": [[1000, "CA"], [1001, "NY"]]
    },
    "item": {
      "columns": ["i_item_sk", "i_item_id", "i_category", "i_manager_id"],
      "rows": [[1000, "item1", "Jewelry", 70], [1001, "item2", "Jewelry", 80]]
    },
    "date_dim": {
      "columns": ["d_date_sk", "d_date"],
      "rows": [[1000, "2002-02-10"], [1001, "2002-02-28"]]
    },
    "catalog_sales": {
      "columns": ["cs_item_sk", "cs_sales_price", "cs_sold_date_sk", "cs_warehouse_sk", "cs_wholesale_cost", "cs_order_number", "cs_warehouse_sk"],
      "rows": [[1000, 100.00, 1000, 1000, 50.00, 1, 1000], [1001, 150.00, 1001, 1001, 55.00, 2, 1001]]
    },
    "catalog_returns": {
      "columns": ["cr_reason_sk", "cr_refunded_cash", "cr_order_number", "cr_item_sk"],
      "rows": [[33, 10.00, 1, 1000], [33, 20.00, 2, 1001]]
    }
  }
}