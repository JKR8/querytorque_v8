Generate minimal witness data so this SQL query returns at least 2 rows.
Output ONLY valid JSON — no markdown fences, no extra text.

## Query analysis (pre-computed)
TABLES:
  catalog_returns
  date_dim
  item
  store_returns
  web_returns

JOINS:
  sr_items.item_id = cr_items.item_id
  sr_items.item_id = wr_items.item_id
  store_returns.sr_returned_date_sk = date_dim.d_date_sk
  store_returns.sr_item_sk = item.i_item_sk
  catalog_returns.cr_returned_date_sk = date_dim.d_date_sk
  catalog_returns.cr_item_sk = item.i_item_sk
  web_returns.wr_returned_date_sk = date_dim.d_date_sk
  web_returns.wr_item_sk = item.i_item_sk

FILTERS:
  store_returns.sr_reason_sk IN (7, 18, 19, 22, 36)
  sr_return_amt / sr_return_quantity BETWEEN 253 AND 282
  item.i_manager_id BETWEEN 15 AND 24
  item.i_category IN ('Children', 'Electronics')
  date_dim.d_date IN ()
  date_dim.d_month_seq IN ()
  date_dim.d_date IN ('1999-01-10', '1999-06-17', '1999-08-04', '1999-11-05')
  catalog_returns.cr_reason_sk IN (7, 18, 19, 22, 36)
  cr_return_amount / cr_return_quantity BETWEEN 253 AND 282
  web_returns.wr_reason_sk IN (7, 18, 19, 22, 36)
  wr_return_amt / wr_return_quantity BETWEEN 253 AND 282

AGGREGATES:
  GROUP BY: item.i_item_id

CTEs:
  sr_items:
    FROM: store_returns, item, date_dim, date_dim, date_dim
    WHERE: sr_return_amt / sr_return_quantity BETWEEN 253 AND 282, item.i_manager_id BETWEEN 15 AND 24, store_returns.sr_returned_date_sk = date_dim.d_date_sk (JOIN), store_returns.sr_item_sk = item.i_item_sk (JOIN)
    GROUP BY: item.i_item_id
    OUTPUT: item_id = item.i_item_id, sr_item_qty = SUM(sr_return_quantity)
  cr_items:
    FROM: catalog_returns, item, date_dim, date_dim, date_dim
    WHERE: cr_return_amount / cr_return_quantity BETWEEN 253 AND 282, item.i_manager_id BETWEEN 15 AND 24, catalog_returns.cr_returned_date_sk = date_dim.d_date_sk (JOIN), catalog_returns.cr_item_sk = item.i_item_sk (JOIN)
    GROUP BY: item.i_item_id
    OUTPUT: item_id = item.i_item_id, cr_item_qty = SUM(cr_return_quantity)
  wr_items:
    FROM: web_returns, item, date_dim, date_dim, date_dim
    WHERE: wr_return_amt / wr_return_quantity BETWEEN 253 AND 282, item.i_manager_id BETWEEN 15 AND 24, web_returns.wr_returned_date_sk = date_dim.d_date_sk (JOIN), web_returns.wr_item_sk = item.i_item_sk (JOIN)
    GROUP BY: item.i_item_id
    OUTPUT: item_id = item.i_item_id, wr_item_qty = SUM(wr_return_quantity)

NOTES:
  Division in filter: sr_return_amt / sr_return_quantity — denominator must be > 0
  Division in filter: cr_return_amount / cr_return_quantity — denominator must be > 0
  Division in filter: wr_return_amt / wr_return_quantity — denominator must be > 0

COLUMNS NEEDED (table.column : type):
  catalog_returns: cr_item_qty (?), cr_item_sk (INTEGER), cr_reason_sk (INTEGER), cr_return_amount (DECIMAL(7), cr_return_quantity (INTEGER), cr_returned_date_sk (INTEGER)
  date_dim: d_date (DATE), d_date_sk (INTEGER), d_month_seq (INTEGER)
  item: i_category (VARCHAR), i_item_id (VARCHAR), i_item_sk (INTEGER), i_manager_id (INTEGER)
  store_returns: sr_item_qty (?), sr_item_sk (INTEGER), sr_reason_sk (INTEGER), sr_return_amt (DECIMAL(7), sr_return_quantity (INTEGER), sr_returned_date_sk (INTEGER)
  web_returns: wr_item_qty (?), wr_item_sk (INTEGER), wr_reason_sk (INTEGER), wr_return_amt (DECIMAL(7), wr_return_quantity (INTEGER), wr_returned_date_sk (INTEGER)

## SQL (for reference)
with sr_items as
 (select i_item_id item_id,
        sum(sr_return_quantity) sr_item_qty
 from store_returns,
      item,
      date_dim
 where sr_item_sk = i_item_sk
 and   d_date    in
	(select d_date
	from date_dim
	where d_month_seq in
		(select d_month_seq
		from date_dim
	  where d_date in ('1999-01-10','1999-06-17','1999-08-04','1999-11-05')))
 and   sr_returned_date_sk   = d_date_sk
 and i_category IN ('Children', 'Electronics')
 and i_manager_id BETWEEN 15 and 24
 and sr_return_amt / sr_return_quantity between 253 and 282
 and sr_reason_sk in (7, 18, 19, 22, 36)
group by i_item_id),
 cr_items as
 (select i_item_id item_id,
        sum(cr_return_quantity) cr_item_qty
 from catalog_returns,
      item,
      date_dim
 where cr_item_sk = i_item_sk
 and   d_date    in
	(select d_date
	from date_dim
  where d_month_seq in
		(select d_month_seq
		from date_dim
	  	  where d_date in ('1999-01-10','1999-06-17','1999-08-04','1999-11-05')))
 and   cr_returned_date_sk   = d_date_sk
 and i_category IN ('Children', 'Electronics')
 and i_manager_id BETWEEN 15 and 24
 and cr_return_amount / cr_return_quantity between 253 and 282
 and cr_reason_sk in (7, 18, 19, 22, 36)
 group by i_item_id),
 wr_items as
 (select i_item_id item_id,
        sum(wr_return_quantity) wr_item_qty
 from web_returns,
      item,
      date_dim
 where wr_item_sk = i_item_sk
 and   d_date    in
	(select d_date
	from date_dim
  where d_month_seq in
		(select d_month_seq
		from date_dim
			  where d_date in ('1999-01-10','1999-06-17','1999-08-04','1999-11-05')))
 and   wr_returned_date_sk   = d_date_sk
 and i_category IN ('Children', 'Electronics')
 and i_manager_id BETWEEN 15 and 24
 and wr_return_amt / wr_return_quantity between 253 and 282
 and wr_reason_sk in (7, 18, 19, 22, 36)
 group by i_item_id)
  select  sr_items.item_id
       ,sr_item_qty
       ,sr_item_qty/(sr_item_qty+cr_item_qty+wr_item_qty)/3.0 * 100 sr_dev
       ,cr_item_qty
       ,cr_item_qty/(sr_item_qty+cr_item_qty+wr_item_qty)/3.0 * 100 cr_dev
       ,wr_item_qty
       ,wr_item_qty/(sr_item_qty+cr_item_qty+wr_item_qty)/3.0 * 100 wr_dev
       ,(sr_item_qty+cr_item_qty+wr_item_qty)/3.0 average
 from sr_items
     ,cr_items
     ,wr_items
 where sr_items.item_id=cr_items.item_id
   and sr_items.item_id=wr_items.item_id
 order by sr_items.item_id
         ,sr_item_qty
 limit 100;


## Example (different query, shows the format)
For a query: "SELECT c_name FROM customer, store WHERE c_store_sk = s_store_sk AND s_state = 'TX' AND c_age > (SELECT avg(c_age)*1.2 FROM customer c2 WHERE c2.c_store_sk = c.c_store_sk)"

{"reasoning": "Need 2+ customers at same store. avg age = (50+20)/2=35, 1.2*35=42. Customer with age 50>42 qualifies. Second store: avg=(60+25)/2=42.5, 1.2*42.5=51. Customer 60>51 qualifies.", "tables": {"store": {"columns": ["s_store_sk", "s_state"], "rows": [[1000, "TX"], [1001, "TX"]]}, "customer": {"columns": ["c_customer_sk", "c_name", "c_store_sk", "c_age"], "rows": [[2000, "Alice", 1000, 50], [2001, "Bob", 1000, 20], [2002, "Carol", 1001, 60], [2003, "Dan", 1001, 25]]}}}

## Rules
1. Include ONLY the columns listed in COLUMNS NEEDED above.
2. Every _sk join must have matching rows on both sides.
3. For correlated aggregate comparisons (value > avg*1.2): you need 2+ rows per group.
   The "winner" row's value must exceed 1.2x the group average (which includes that row).
   SHOW THE MATH in reasoning.
4. Denominators in division must be > 0.
5. String values are case-sensitive: use exact values from FILTERS.
6. Use integer keys starting at 1000.
7. Dates as strings: "2002-06-15".
8. null for columns you don't care about.
