Generate minimal witness data so this SQL query returns at least 2 rows.
Output ONLY valid JSON â€” no markdown fences, no extra text.

## Query analysis (pre-computed)
TABLES:
  catalog_sales
  date_dim (alias: d1)
  date_dim (alias: d2)
  date_dim (alias: d3)
  date_dim
  item (alias: ics)
  item (alias: iss)
  item
  item (alias: iws)
  store_sales
  web_sales

JOINS:
  this_year.i_category_id = last_year.i_category_id
  this_year.i_brand_id = last_year.i_brand_id
  this_year.i_class_id = last_year.i_class_id
  store_sales.ss_sold_date_sk = date_dim.d_date_sk
  store_sales.ss_item_sk = item.i_item_sk
  web_sales.ws_sold_date_sk = date_dim.d_date_sk
  web_sales.ws_item_sk = item.i_item_sk
  catalog_sales.cs_item_sk = item.i_item_sk
  catalog_sales.cs_sold_date_sk = date_dim.d_date_sk

FILTERS:
  store_sales.ss_wholesale_cost BETWEEN 35 AND 55
  item.i_manager_id BETWEEN 91 AND 100
  item.i_category IN ('Electronics', 'Jewelry', 'Men')
  date_dim.d_week_seq = (SELECT d_week_seq FROM date_dim WHERE d_year = 1999 + 1 AND d_moy = 12 AND d_dom = 20)
  store_sales.ss_item_sk IN ()
  date_dim.d_dom = 20
  date_dim.d_year = 1999 + 1
  date_dim.d_moy = 12
  date_dim.d_week_seq = (SELECT d_week_seq FROM date_dim WHERE d_year = 1999 AND d_moy = 12 AND d_dom = 20)
  date_dim.d_year = 1999
  item.i_category_id = category_id
  item.i_brand_id = brand_id
  item.i_class_id = class_id
  date_dim.d_year BETWEEN 1999 AND 1999 + 2
  web_sales.ws_wholesale_cost BETWEEN 35 AND 55
  catalog_sales.cs_wholesale_cost BETWEEN 35 AND 55

AGGREGATES:
  Correlated: SUM(ss_quantity * ss_list_price) > (SELECT average_sales)
  GROUP BY: item.i_brand_id, item.i_class_id, item.i_category_id

CTEs:
  cross_items:
    FROM: item, web_sales, item, date_dim, store_sales, item, date_dim, catalog_sales, item, date_dim
    WHERE: item.i_manager_id BETWEEN 91 AND 100, item.i_category_id = category_id (JOIN), item.i_brand_id = brand_id (JOIN), item.i_class_id = class_id (JOIN)
    OUTPUT: ss_item_sk = item.i_item_sk
  avg_sales:
    FROM: web_sales, date_dim, store_sales, date_dim, catalog_sales, date_dim
    WHERE: date_dim.d_year BETWEEN 1999 AND 1999 + 2, web_sales.ws_sold_date_sk = date_dim.d_date_sk (JOIN), web_sales.ws_wholesale_cost BETWEEN 35 AND 55
    OUTPUT: average_sales = AVG(quantity * list_price)

COLUMNS NEEDED (table.column : type):
  catalog_sales: cs_item_sk (INTEGER), cs_sold_date_sk (INTEGER), cs_wholesale_cost (DECIMAL(7)
  date_dim: d_date_sk (INTEGER), d_dom (INTEGER), d_moy (INTEGER), d_week_seq (INTEGER), d_year (INTEGER)
  item: i_brand_id (INTEGER), i_category (VARCHAR), i_category_id (INTEGER), i_class_id (INTEGER), i_item_sk (INTEGER), i_manager_id (INTEGER)
  store_sales: ss_item_sk (INTEGER), ss_list_price (DECIMAL(7), ss_quantity (INTEGER), ss_sold_date_sk (INTEGER), ss_wholesale_cost (DECIMAL(7)
  web_sales: ws_item_sk (INTEGER), ws_sold_date_sk (INTEGER), ws_wholesale_cost (DECIMAL(7)

## SQL (for reference)
with  cross_items as
 (select i_item_sk ss_item_sk
 from item,
 (select iss.i_brand_id brand_id
     ,iss.i_class_id class_id
     ,iss.i_category_id category_id
 from store_sales
     ,item iss
     ,date_dim d1
 where ss_item_sk = iss.i_item_sk
   and ss_sold_date_sk = d1.d_date_sk
   and d1.d_year between 1999 AND 1999 + 2
   and i_category IN ('Electronics', 'Jewelry', 'Men')
   and i_manager_id BETWEEN 91 and 100
   and ss_wholesale_cost BETWEEN 35 AND 55
intersect
 select ics.i_brand_id
     ,ics.i_class_id
     ,ics.i_category_id
 from catalog_sales
     ,item ics
     ,date_dim d2
 where cs_item_sk = ics.i_item_sk
   and cs_sold_date_sk = d2.d_date_sk
   and d2.d_year between 1999 AND 1999 + 2
   and i_category IN ('Electronics', 'Jewelry', 'Men')
   and i_manager_id BETWEEN 91 and 100
   and cs_wholesale_cost BETWEEN 35 AND 55
intersect
 select iws.i_brand_id
     ,iws.i_class_id
     ,iws.i_category_id
 from web_sales
     ,item iws
     ,date_dim d3
 where ws_item_sk = iws.i_item_sk
   and ws_sold_date_sk = d3.d_date_sk
   and ws_wholesale_cost BETWEEN 35 AND 55
   and d3.d_year between 1999 AND 1999 + 2) x
 where i_brand_id = brand_id
      and i_class_id = class_id
      and i_category_id = category_id
      and i_category IN ('Electronics', 'Jewelry', 'Men')
      and i_manager_id BETWEEN 91 and 100
),
 avg_sales as
(select avg(quantity*list_price) average_sales
  from (select ss_quantity quantity
             ,ss_list_price list_price
       from store_sales
           ,date_dim
       where ss_sold_date_sk = d_date_sk
         and d_year between 1999 and 1999 + 2
         and ss_wholesale_cost BETWEEN 35 AND 55
       union all
       select cs_quantity quantity
             ,cs_list_price list_price
       from catalog_sales
           ,date_dim
       where cs_sold_date_sk = d_date_sk
         and d_year between 1999 and 1999 + 2
         and cs_wholesale_cost BETWEEN 35 AND 55
       union all
       select ws_quantity quantity
             ,ws_list_price list_price
       from web_sales
           ,date_dim
       where ws_sold_date_sk = d_date_sk
        and ws_wholesale_cost BETWEEN 35 AND 55
         and d_year between 1999 and 1999 + 2) x)
  select  this_year.channel ty_channel
                           ,this_year.i_brand_id ty_brand
                           ,this_year.i_class_id ty_class
                           ,this_year.i_category_id ty_category
                           ,this_year.sales ty_sales
                           ,this_year.number_sales ty_number_sales
                           ,last_year.channel ly_channel
                           ,last_year.i_brand_id ly_brand
                           ,last_year.i_class_id ly_class
                           ,last_year.i_category_id ly_category
                           ,last_year.sales ly_sales
                           ,last_year.number_sales ly_number_sales
 from
 (select 'store' channel, i_brand_id,i_class_id,i_category_id
        ,sum(ss_quantity*ss_list_price) sales, count(*) number_sales
 from store_sales
     ,item
     ,date_dim
 where ss_item_sk in (select ss_item_sk from cross_items)
   and ss_item_sk = i_item_sk
   and ss_sold_date_sk = d_date_sk
   and d_week_seq = (select d_week_seq
                     from date_dim
                     where d_year = 1999 + 1
                       and d_moy = 12
                       and d_dom = 20)
   and i_category IN ('Electronics', 'Jewelry', 'Men')
   and i_manager_id BETWEEN 91 and 100
   and ss_wholesale_cost BETWEEN 35 AND 55
 group by i_brand_id,i_class_id,i_category_id
 having sum(ss_quantity*ss_list_price) > (select average_sales from avg_sales)) this_year,
 (select 'store' channel, i_brand_id,i_class_id
        ,i_category_id, sum(ss_quantity*ss_list_price) sales, count(*) number_sales
 from store_sales
     ,item
     ,date_dim
 where ss_item_sk in (select ss_item_sk from cross_items)
   and ss_item_sk = i_item_sk
   and ss_sold_date_sk = d_date_sk
   and d_week_seq = (select d_week_seq
                     from date_dim
                     where d_year = 1999
                       and d_moy = 12
                       and d_dom = 20)
   and i_category IN ('Electronics', 'Jewelry', 'Men')
   and ss_wholesale_cost BETWEEN 35 AND 55
   and i_manager_id BETWEEN 91 and 100
group by i_brand_id,i_class_id,i_category_id
 having sum(ss_quantity*ss_list_price) > (select average_sales from avg_sales)) last_year
 where this_year.i_brand_id= last_year.i_brand_id
   and this_year.i_class_id = last_year.i_class_id
   and this_year.i_category_id = last_year.i_category_id
 order by this_year.channel, this_year.i_brand_id, this_year.i_class_id, this_year.i_category_id
 limit 100;


## Example (different query, shows the format)
For a query: "SELECT c_name FROM customer, store WHERE c_store_sk = s_store_sk AND s_state = 'TX' AND c_age > (SELECT avg(c_age)*1.2 FROM customer c2 WHERE c2.c_store_sk = c.c_store_sk)"

{"reasoning": "Need 2+ customers at same store. avg age = (50+20)/2=35, 1.2*35=42. Customer with age 50>42 qualifies. Second store: avg=(60+25)/2=42.5, 1.2*42.5=51. Customer 60>51 qualifies.", "tables": {"store": {"columns": ["s_store_sk", "s_state"], "rows": [[1000, "TX"], [1001, "TX"]]}, "customer": {"columns": ["c_customer_sk", "c_name", "c_store_sk", "c_age"], "rows": [[2000, "Alice", 1000, 50], [2001, "Bob", 1000, 20], [2002, "Carol", 1001, 60], [2003, "Dan", 1001, 25]]}}}

## Rules
1. Include ONLY the columns listed in COLUMNS NEEDED above.
2. Every _sk join must have matching rows on both sides.
3. For correlated aggregate comparisons (value > avg*1.2): you need 2+ rows per group.
   The "winner" row's value must exceed 1.2x the group average (which includes that row).
   SHOW THE MATH in reasoning.
4. Denominators in division must be > 0.
5. String values are case-sensitive: use exact values from FILTERS.
6. Use integer keys starting at 1000.
7. Dates as strings: "2002-06-15".
8. null for columns you don't care about.
