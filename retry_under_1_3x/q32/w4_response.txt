Looking at this query, I can see a correlated subquery that's being evaluated for each row in the outer query. The subquery computes the average discount for each item in the same date range, which creates two performance issues:

1. **Date filter redundancy**: The date filter `d_date BETWEEN '2000-01-27' AND CAST('2000-04-26' AS DATE)` appears twice (once in outer query, once in subquery)
2. **Correlated execution**: The subquery runs for each item due to correlation through `cs_item_sk = i_item_sk`

I'll rewrite this by:
1. Isolating the date filter into a CTE (date_cte_isolate)
2. Precomputing item averages in a separate CTE (decorrelate)

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2000-01-27' AND CAST('2000-04-26' AS DATE)",
        "main_query": "SELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\" FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN item ON i_item_sk = cs_item_sk WHERE i_manufact_id = 977 AND cs_ext_discount_amt > (SELECT 1.3 * AVG(cs_ext_discount_amt) FROM catalog_sales cs2 JOIN filtered_dates fd2 ON cs2.cs_sold_date_sk = fd2.d_date_sk WHERE cs2.cs_item_sk = i_item_sk) LIMIT 100"
      },
      "invariants_kept": [
        "same result values",
        "same date filtering logic"
      ],
      "expected_speedup": "1.8x",
      "risk": "low"
    },
    {
      "id": "rs_02",
      "transform": "decorrelate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2000-01-27' AND CAST('2000-04-26' AS DATE)",
        "item_avg_discounts": "SELECT cs_item_sk, 1.3 * AVG(cs_ext_discount_amt) AS avg_threshold FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk GROUP BY cs_item_sk",
        "main_query": "SELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\" FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN item ON i_item_sk = cs_item_sk LEFT JOIN item_avg_discounts iad ON cs_item_sk = iad.cs_item_sk WHERE i_manufact_id = 977 AND cs_ext_discount_amt > COALESCE(iad.avg_threshold, 0) LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same aggregation",
        "same filtering logic"
      ],
      "expected_speedup": "3.5x",
      "risk": "medium"
    }
  ],
  "explanation": "Applied two transforms: (1) Isolated date filtering into a CTE to avoid redundant date_dim scans and push filters earlier. (2) Decorrelated the subquery by precomputing item average discounts in a separate CTE and joining, eliminating per-row correlated execution. The LEFT JOIN with COALESCE handles items with no sales in the date range (avg_threshold NULL becomes 0, matching original subquery behavior when no rows match)."
}
```