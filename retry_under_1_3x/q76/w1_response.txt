Looking at this query, I can see a significant optimization opportunity: **pushing the NULL filters down and isolating date dimension joins**. The current query scans all three large fact tables (store_sales, web_sales, catalog_sales) and then filters for NULL values in specific columns. However, we can filter these tables early and potentially materialize the filtered results.

**Key insights:**
1. Each UNION branch has a specific column that must be NULL (`ss_store_sk`, `ws_ship_customer_sk`, `cs_ship_addr_sk`)
2. The same `date_dim` table is joined three times - we can pre-filter it
3. The `item` table is joined three times but has no filters
4. There's heavy sequential scanning of large fact tables

**Optimization strategy:**
1. Create filtered CTEs for each fact table early with the NULL condition
2. Isolate date dimension filtering into a CTE to reduce multiple scans
3. Materialize the filtered fact tables since they're used multiple times in UNION

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_year, d_qoy FROM date_dim",
        "store_filtered": "SELECT ss_ext_sales_price, d_year, d_qoy, i_category, 'store' AS channel, 'ss_store_sk' AS col_name FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN item ON ss_item_sk = i_item_sk WHERE ss_store_sk IS NULL",
        "web_filtered": "SELECT ws_ext_sales_price, d_year, d_qoy, i_category, 'web' AS channel, 'ws_ship_customer_sk' AS col_name FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN item ON ws_item_sk = i_item_sk WHERE ws_ship_customer_sk IS NULL",
        "catalog_filtered": "SELECT cs_ext_sales_price, d_year, d_qoy, i_category, 'catalog' AS channel, 'cs_ship_addr_sk' AS col_name FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN item ON cs_item_sk = i_item_sk WHERE cs_ship_addr_sk IS NULL",
        "main_query": "SELECT channel, col_name, d_year, d_qoy, i_category, COUNT(*) AS sales_cnt, SUM(ext_sales_price) AS sales_amt FROM (SELECT * FROM store_filtered UNION ALL SELECT * FROM web_filtered UNION ALL SELECT * FROM catalog_filtered) AS foo GROUP BY channel, col_name, d_year, d_qoy, i_category ORDER BY channel NULLS FIRST, col_name NULLS FIRST, d_year NULLS FIRST, d_qoy NULLS FIRST, i_category NULLS FIRST LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same grain and ordering"
      ],
      "expected_speedup": "2.1x",
      "risk": "low"
    },
    {
      "id": "rs_02",
      "transform": "materialize_cte",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_year, d_qoy FROM date_dim",
        "store_materialized": "WITH store_filtered AS (SELECT ss_ext_sales_price, d_year, d_qoy, i_category, 'store' AS channel, 'ss_store_sk' AS col_name FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN item ON ss_item_sk = i_item_sk WHERE ss_store_sk IS NULL) SELECT * FROM store_filtered",
        "web_materialized": "WITH web_filtered AS (SELECT ws_ext_sales_price, d_year, d_qoy, i_category, 'web' AS channel, 'ws_ship_customer_sk' AS col_name FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN item ON ws_item_sk = i_item_sk WHERE ws_ship_customer_sk IS NULL) SELECT * FROM web_filtered",
        "catalog_materialized": "WITH catalog_filtered AS (SELECT cs_ext_sales_price, d_year, d_qoy, i_category, 'catalog' AS channel, 'cs_ship_addr_sk' AS col_name FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN item ON cs_item_sk = i_item_sk WHERE cs_ship_addr_sk IS NULL) SELECT * FROM catalog_filtered",
        "main_query": "SELECT channel, col_name, d_year, d_qoy, i_category, COUNT(*) AS sales_cnt, SUM(ext_sales_price) AS sales_amt FROM (SELECT * FROM store_materialized UNION ALL SELECT * FROM web_materialized UNION ALL SELECT * FROM catalog_materialized) AS foo GROUP BY channel, col_name, d_year, d_qoy, i_category ORDER BY channel NULLS FIRST, col_name NULLS FIRST, d_year NULLS FIRST, d_qoy NULLS FIRST, i_category NULLS FIRST LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same grain and ordering"
      ],
      "expected_speedup": "3.5x",
      "risk": "medium",
      "note": "Materializing filtered CTEs can provide significant speedup by avoiding repeated joins and scans, but uses more memory"
    }
  ],
  "explanation": "The original query scans three large fact tables (store_sales, web_sales, catalog_sales) multiple times and joins with date_dim and item tables repeatedly. The rewrite isolates the date_dim scan into a CTE to avoid redundant scans, pushes the NULL column filters early to reduce the fact table scan sizes, and optionally materializes the filtered results to avoid recomputation. This reduces the number of sequential scans from 6 (3 fact tables + 3 date_dim) to 4 (3 fact tables + 1 date_dim CTE), with further benefits from early filtering of large fact tables based on NULL conditions."
}
```