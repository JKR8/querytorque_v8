Looking at this query, I can see several optimization opportunities:

1. **OR_TO_UNION**: The OR condition on `hd_buy_potential` can be split into UNION ALL branches
2. **DATE_CTE_ISOLATE**: The date_dim filters can be isolated to reduce join size early
3. **EARLY_FILTER**: Multiple CTEs can filter dimensions before joining with fact table
4. **PUSHDOWN**: Complex CASE expression can be pushed into household_demographics filtering

The biggest cost is the full table scan of store_sales (83% of cost). By creating filtered CTEs and splitting the OR condition, we can reduce the fact table joins significantly.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "or_to_union",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_dom BETWEEN 1 AND 2 AND d_year IN (1999, 2000, 2001)",
        "filtered_stores": "SELECT s_store_sk FROM store WHERE s_county IN ('Orange County', 'Bronx County', 'Franklin Parish', 'Williamson County')",
        "filtered_hd_unknown": "SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = 'Unknown' AND hd_vehicle_count > 0 AND (hd_dep_count * 1.000) / hd_vehicle_count > 1",
        "filtered_hd_high": "SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '>10000' AND hd_vehicle_count > 0 AND (hd_dep_count * 1.000) / hd_vehicle_count > 1",
        "union_aggregate": "SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_stores ON ss_store_sk = s_store_sk JOIN filtered_hd_unknown ON ss_hdemo_sk = hd_demo_sk GROUP BY ss_ticket_number, ss_customer_sk UNION ALL SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_stores ON ss_store_sk = s_store_sk JOIN filtered_hd_high ON ss_hdemo_sk = hd_demo_sk GROUP BY ss_ticket_number, ss_customer_sk",
        "main_query": "SELECT c_last_name, c_first_name, c_salutation, c_preferred_cust_flag, ss_ticket_number, cnt FROM (SELECT ss_ticket_number, ss_customer_sk, SUM(cnt) AS cnt FROM union_aggregate GROUP BY ss_ticket_number, ss_customer_sk HAVING SUM(cnt) BETWEEN 1 AND 5) AS dj, customer WHERE ss_customer_sk = c_customer_sk ORDER BY cnt DESC, c_last_name ASC LIMIT 100"
      },
      "invariants_kept": [
        "output columns unchanged", 
        "same grouping grain (ss_ticket_number, ss_customer_sk)",
        "same filter conditions applied",
        "same result rows after aggregation"
      ],
      "expected_speedup": "3.5x",
      "risk": "medium"
    }
  ],
  "explanation": "Transformed OR condition on hd_buy_potential into UNION ALL branches, each with focused predicates. Isolated date and store filters into CTEs to reduce fact table joins early. Moved complex CASE expression into household_demographics CTEs. Each branch now processes only relevant rows, allowing better index usage and reduced intermediate result sizes."
}
```

**Key insight**: The OR condition on `hd_buy_potential` is the main filter that could benefit from UNION ALL decomposition. By creating separate CTEs for each value and pushing down all other filters, each branch only processes the relevant subset of store_sales. The date_dim filter reduces 73,049 rows to just 72, which is a key early filter. The store filter reduces to 52 rows. Combined, these filtered CTEs drastically reduce the fact table join size from 172M rows.