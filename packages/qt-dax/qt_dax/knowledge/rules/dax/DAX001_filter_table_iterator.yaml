rule_id: DAX001
name: FILTER_TABLE_ITERATOR
category: dax_anti_pattern
severity: critical
penalty: 20

description: >
  FILTER iterating entire table instead of column. This forces row-by-row
  iteration in the single-threaded Formula Engine.

why_bad: >
  The Storage Engine cannot optimize FILTER(Table, condition). Every row must
  be evaluated individually, preventing parallelization and efficient bitmap
  filtering. Performance impact is typically 10-100x slower than CALCULATE
  filter arguments.

detection_pattern: "FILTER\\s*\\(\\s*'?[A-Za-z][A-Za-z0-9_ ]*'?\\s*,"
exclude_pattern: "FILTER\\s*\\(\\s*(ALL|VALUES|DISTINCT|CALCULATETABLE|SUMMARIZE)"

fix_pattern: >
  Replace FILTER(Table, condition) with CALCULATE filter arguments:
  - CALCULATE([Measure], Table[Column] = Value)
  - Or use CALCULATETABLE for filtered table results

examples:
  - description: "Simple filter replacement"
    before_code: |
      SUMX(
          FILTER('Sales', 'Sales'[Amount] > 100),
          'Sales'[Amount]
      )
    after_code: |
      CALCULATE(
          SUM('Sales'[Amount]),
          'Sales'[Amount] > 100
      )
    explanation: >
      The CALCULATE approach pushes the filter to the Storage Engine,
      enabling efficient columnar filtering with parallelization.
    improvement_estimate: "~10-50x for large tables"

  - description: "Multi-condition filter"
    before_code: |
      SUMX(
          FILTER(
              'Sales',
              'Sales'[Status] = "Complete" && 'Sales'[Year] = 2024
          ),
          'Sales'[Amount]
      )
    after_code: |
      CALCULATE(
          SUM('Sales'[Amount]),
          'Sales'[Status] = "Complete",
          'Sales'[Year] = 2024
      )
    explanation: >
      Multiple filter arguments in CALCULATE are combined efficiently
      by the Storage Engine using bitmap operations.
