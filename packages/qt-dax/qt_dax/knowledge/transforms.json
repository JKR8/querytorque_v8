[
  {
    "id": "measure_forest_collapse",
    "principle": "Collapse deep measure dependency chains into a single orchestrator measure with VARs. Each measure reference produces an independent SE query plan — N measures = N table scans. A single orchestrator computes all intermediate results once.",
    "precondition_features": [
      "MEASURE_CHAIN_3+",
      "SHARED_TABLE_SCAN"
    ],
    "contraindications": [
      {
        "id": "MULTI_VISUAL_REUSE",
        "instruction": "If intermediate measures are reused across 5+ visuals with different filter contexts, collapsing may break context-dependent behavior",
        "severity": "MEDIUM",
        "worst_ratio": null
      },
      {
        "id": "CALCULATION_GROUP_WRAP",
        "instruction": "If measures are wrapped by Calculation Groups, test with ALL calculation items before collapsing — CG interaction may change",
        "severity": "HIGH",
        "worst_ratio": null
      }
    ],
    "gap": "MEASURE_CHAIN_REPEATED_SCANS",
    "notes": "The single most impactful DAX transform. esg_carbon_005: 38-measure chain for CR Intensity collapsed into single orchestrator with VARs → 150x (60s→0.4s). GS Asset, Daily Position, ESG Trucost Climate each scanned independently by multiple measures. After collapse: 3 SE queries instead of ~38. Steps: (1) map full dependency closure via MeasureDependencyAnalyzer, (2) identify shared table scans, (3) collapse into VAR-based orchestrator, (4) build intermediate tables at ISIN grain using ADDCOLUMNS + VALUES/SUMMARIZE. Always apply first — enables all downstream transforms (P2 slicer caching, P3 GROUPBY elimination, P5 ratio fix). Related trials: esg_carbon_012 (94s), esg_carbon_001 (14s), esg_carbon_002 (9s), esg_carbon_010 (25s), esg_carbon_011 (25s).",
    "min_baseline_ms": 5000.0,
    "confirm_with_explain": false,
    "engines": [
      "dax"
    ]
  },
  {
    "id": "cache_slicer_state",
    "principle": "Move SELECTEDVALUE/ISINSCOPE calls from inside iterators to VARs above the iterator scope. Slicer state does not change per row — caching it in a VAR eliminates redundant per-row evaluation.",
    "precondition_features": [
      "SELECTEDVALUE_IN_ITERATOR"
    ],
    "contraindications": [
      {
        "id": "ROW_VARYING_SELECTEDVALUE",
        "instruction": "If SELECTEDVALUE references a column IN the iterated table, it IS row-varying and must NOT be hoisted",
        "severity": "CRITICAL",
        "worst_ratio": null
      }
    ],
    "gap": "SELECTEDVALUE_IN_ITERATOR",
    "notes": "Zero-risk transform — VAR caching never changes semantics because filter context at VAR declaration = filter context at SUMX start. Observed in esg_carbon_005: SELECTEDVALUE('Scope Emission Types'[Scope_Type_Code]) and SELECTEDVALUE('Market Cap Type'[Market_Cap_Code]) were evaluated inside nested SWITCH/IF branches within iterators. Optimized version caches both at top of measure. Always combined with measure_forest_collapse (P1). Steps: (1) identify all SELECTEDVALUE/ISINSCOPE calls inside iterator scope, (2) move each to VAR above outermost iterator, (3) replace references with VAR name.",
    "min_baseline_ms": null,
    "confirm_with_explain": false,
    "engines": [
      "dax"
    ]
  },
  {
    "id": "grain_first_materialize",
    "principle": "Build compact per-grain tables (e.g., per-ISIN) using ADDCOLUMNS + VALUES/SUMMARIZE before aggregation. Computes ownership, carbon, revenue etc. once per grain instead of per-row inside SUMX.",
    "precondition_features": [
      "SUMX_LARGE_TABLE",
      "CONTEXT_TRANSITION_IN_ITERATOR"
    ],
    "contraindications": [
      {
        "id": "HELPER_COLUMNS_REQUIRED",
        "instruction": "Optimized form may require pre-computed calculated columns (e.g., Ownership_Factor_MC) that must exist in the model",
        "severity": "HIGH",
        "worst_ratio": null
      }
    ],
    "gap": "MEASURE_CHAIN_REPEATED_SCANS",
    "notes": "Core of the CR Intensity win. Original: SUMX('GS Asset', [MV Ownership_BM] * (SUMX('ESG Trucost Climate', scope-specific sums))) → per-asset context transition triggering full ownership recalculation. Optimized: (1) OwnershipByAsset = CALCULATETABLE(ADDCOLUMNS(SUMMARIZE('Daily Position', 'GS Asset'[ISIN]), '@Ownership', ...)), (2) CarbonRevByAsset = ADDCOLUMNS(VALUES('GS Asset'[ISIN]), '@Revenue', ..., '@Carbon', ...), (3) Joined = NATURALINNERJOIN(OwnershipByAsset, CarbonRevByAsset), (4) SUMX(Joined, [@Ownership] * [@Carbon]). The NATURALINNERJOIN on ISIN produces a compact table (~thousands of rows vs millions of raw rows). Always combine with cache_slicer_state and measure_forest_collapse.",
    "min_baseline_ms": 5000.0,
    "confirm_with_explain": false,
    "engines": [
      "dax"
    ]
  },
  {
    "id": "ratio_of_sums",
    "principle": "Replace sum-of-ratios with ratio-of-sums for intensity/weighted-average metrics. Accumulate weighted numerator and weighted denominator separately, divide once at the end.",
    "precondition_features": [
      "DIVISION_IN_ITERATOR"
    ],
    "contraindications": [
      {
        "id": "PER_ROW_RATIO_INTENTIONAL",
        "instruction": "WACI (Weighted Average Carbon Intensity) IS a sum-of-ratios by definition — weight * (carbon/revenue) per asset. Do NOT convert to ratio-of-sums",
        "severity": "CRITICAL",
        "worst_ratio": null
      },
      {
        "id": "CONSTANT_DENOMINATOR",
        "instruction": "If denominator is the same for all rows, ratio-of-sums = sum-of-ratios — transform has no benefit",
        "severity": "LOW",
        "worst_ratio": null
      }
    ],
    "gap": "SUM_OF_RATIOS_PATTERN",
    "notes": "Both a correctness AND performance fix. Sum(C_i/R_i) mixes different bases — mathematically incorrect for intensity. Sum(W*C)/Sum(W*R) is proper weighted intensity. The per-row division also forces CallbackDataID overhead. Confirmed in esg_carbon_005: original chain computed apportioned carbon and revenue in separate chains then divided. Optimized: DIVIDE(SUMX(Joined, own*carbon), SUMX(Joined, own*revenue)). CRITICAL EXCEPTION: esg_carbon_010 (WACI) uses weight * (carbon/revenue) per asset — this IS intentionally sum-of-ratios. Check the metric's mathematical definition before applying. Rule: DAX028.",
    "min_baseline_ms": null,
    "confirm_with_explain": false,
    "engines": [
      "dax"
    ]
  },
  {
    "id": "groupby_to_addcolumns",
    "principle": "Replace GROUPBY + SUMX(CURRENTGROUP(), ...) with ADDCOLUMNS(SUMMARIZE(...), ..., CALCULATE(SUM(...))). GROUPBY forces FE iteration; SUMMARIZE + CALCULATE pushes to SE.",
    "precondition_features": [
      "GROUPBY_SUMX"
    ],
    "contraindications": [
      {
        "id": "CURRENTGROUP_ESSENTIAL",
        "instruction": "If CURRENTGROUP() is used for logic beyond simple aggregation (e.g., row-level filtering within groups), CALCULATE(SUM(...)) may not be equivalent",
        "severity": "MEDIUM",
        "worst_ratio": null
      }
    ],
    "gap": "GROUPBY_SUMX_CONDITIONAL",
    "notes": "GROUPBY is an FE iterator function — SUMX(CURRENTGROUP(), ...) adds a nested iteration layer. When inside IF/SWITCH branches, overhead multiplies. Observed in esg_carbon_005: Benchmark pathway used SUMX(GROUPBY('Benchmark Portfolio Mapping'[Sub_Sector]), [Aggregate MV ...]). Parent measure (esg_carbon_012, 94s) was slower than Portfolio-only child (esg_carbon_005, 60s), suggesting GROUPBY path adds ~34s overhead. Fix: ADDCOLUMNS(SUMMARIZE('Benchmark Portfolio Mapping', [Sub_Sector]), '@Total', CALCULATE(SUM(...))). Move grain computation OUTSIDE the IF/SWITCH branch using VAR. Rule: DAX026.",
    "min_baseline_ms": null,
    "confirm_with_explain": false,
    "engines": [
      "dax"
    ]
  },
  {
    "id": "hoist_global_constant",
    "principle": "Compute global constants (total market value, benchmark weights) once as VARs outside iterators. Prevents re-computation per row inside SUMX/ADDCOLUMNS.",
    "precondition_features": [
      "SUMX_LARGE_TABLE",
      "CALCULATE_SUM_IN_ITERATOR"
    ],
    "contraindications": [],
    "gap": "MEASURE_CHAIN_REPEATED_SCANS",
    "notes": "Observed in esg_carbon_010 (WACI, 25s): total market value denominator computed inside nested measures, recalculated per context transition. Optimized form pre-computes: VAR _TotalMarketValue = IF(_IsBenchmark, CALCULATE(SUM([MARKET VALUE BASE]), ALLEXCEPT(...), type filters...), ...). Also in esg_carbon_012 (94s): benchmark market value computed via ALLEXCEPT repeatedly. Must preserve ALLEXCEPT expanded table semantics when hoisting.",
    "min_baseline_ms": null,
    "confirm_with_explain": false,
    "engines": [
      "dax"
    ]
  },
  {
    "id": "shared_intermediate_reuse",
    "principle": "When a measure calls the same sub-measure twice with different filter contexts (e.g., Benchmark vs Portfolio), compute shared intermediate results once and derive both contexts from the shared base.",
    "precondition_features": [
      "MEASURE_CHAIN_3+",
      "SHARED_TABLE_SCAN"
    ],
    "contraindications": [
      {
        "id": "CONTEXT_DEPENDENT_INTERMEDIATE",
        "instruction": "If the intermediate values genuinely differ by filter context (e.g., carbon values vary by Position_Type), sharing is incorrect",
        "severity": "CRITICAL",
        "worst_ratio": null
      }
    ],
    "gap": "MEASURE_CHAIN_REPEATED_SCANS",
    "notes": "Observed in esg_carbon_011 (Position Relative Difference, 25s): calls [Matrix MV Apportioned Carbon Switch_BM] twice — once with Benchmark filter, once with Portfolio. Each call triggers full 38-measure chain independently, doubling all table scans. Fix: carbon-per-ISIN is identical for both position types (only ownership weights differ). Compute carbon once, join to two separate ownership tables. Requires verifying that carbon values are position-type-independent.",
    "min_baseline_ms": null,
    "confirm_with_explain": false,
    "engines": [
      "dax"
    ]
  },
  {
    "id": "filter_to_calculate",
    "principle": "Replace FILTER('Table', condition) with CALCULATE filter arguments or CALCULATETABLE. Pushes predicate evaluation from single-threaded Formula Engine to multi-threaded Storage Engine.",
    "precondition_features": [
      "FILTER_TABLE"
    ],
    "contraindications": [
      {
        "id": "MULTI_HOP_RELATED",
        "instruction": "If condition uses RELATED across multiple relationship hops, the iterator form may be required for correctness",
        "severity": "MEDIUM",
        "worst_ratio": null
      }
    ],
    "gap": "FILTER_TABLE_FULL_SCAN",
    "notes": "Industry-standard DAX optimization — not observed in ESG trials (those measures already used CALCULATE(SUM(...))). Common in less mature DAX codebases. FILTER('Sales', [Amount] > 100) forces 1M FE evaluations; CALCULATE(SUM([Amount]), [Amount] > 100) uses SE bitmap filter. Variants: single condition → CALCULATE filter arg, multi-condition → multiple filter args, table output → CALCULATETABLE. Exclude: FILTER(ALL(...)), FILTER(VALUES(...)), FILTER(DISTINCT(...)) are intentional patterns. Rules: DAX001 (critical), DAX002 (critical).",
    "min_baseline_ms": null,
    "confirm_with_explain": false,
    "engines": [
      "dax"
    ]
  },
  {
    "id": "eliminate_callback",
    "principle": "Remove complex expressions (IF/SWITCH/FORMAT/division/string ops) from inside iterators to prevent CallbackDataID. Move branch logic to measure-level CALCULATE or pre-compute as calculated columns.",
    "precondition_features": [
      "IF_IN_ITERATOR",
      "SWITCH_IN_ITERATOR"
    ],
    "contraindications": [
      {
        "id": "ROW_VARYING_CONDITION",
        "instruction": "If the condition genuinely varies per row and cannot be pre-computed, the callback cost must be accepted",
        "severity": "LOW",
        "worst_ratio": null
      },
      {
        "id": "REFRESH_COST",
        "instruction": "If pre-computing as a calculated column, assess refresh-time impact on large tables",
        "severity": "MEDIUM",
        "worst_ratio": null
      }
    ],
    "gap": "CALLBACK_DATA_ID",
    "notes": "CallbackDataID occurs when SE encounters expressions it cannot evaluate natively — it calls back to FE per row, destroying parallelism and caching. Partially observed in esg_carbon_005: SWITCH(TRUE(), ...) for scope inside nested measures contributed to FE overhead. Addressed via P1 (collapse) + P2 (slicer caching) rather than directly eliminating callbacks. Worst form: IF inside SUMX over >10K rows. Fix options: (1) CALCULATE filter context, (2) calculated column, (3) SWITCH at measure level outside iterator. Rules: DAX006, DAX008.",
    "min_baseline_ms": null,
    "confirm_with_explain": false,
    "engines": [
      "dax"
    ]
  },
  {
    "id": "flatten_calculate",
    "principle": "Flatten nested CALCULATE chains into a single CALCULATE with combined filter arguments. Reduces context transition overhead from O(2^N) to O(1).",
    "precondition_features": [
      "CALCULATE_NESTING_4+"
    ],
    "contraindications": [
      {
        "id": "MIXED_FILTER_DIRECTIONS",
        "instruction": "If nesting chain mixes REMOVEFILTERS and KEEPFILTERS, flattening may change filter interaction semantics",
        "severity": "HIGH",
        "worst_ratio": null
      },
      {
        "id": "MULTI_CONSUMER_INTERMEDIATE",
        "instruction": "If an intermediate CALCULATE result is consumed by multiple downstream branches, flattening eliminates the shared intermediate",
        "severity": "MEDIUM",
        "worst_ratio": null
      }
    ],
    "gap": "CALCULATE_NESTING_EXPLOSION",
    "notes": "Each nested CALCULATE triggers a context transition. 4 nested = 16x overhead, 12 nested = 4096x. Indirectly observed in esg_carbon_005: 38-measure chain had implicit nesting (each measure adding a CALCULATE layer). Addressed via P1 (collapse) rather than directly. Standalone flatten_calculate has no independent trial evidence — industry consensus on exponential scaling. Fix: list all filter args across chain, combine into single CALCULATE, use KEEPFILTERS for intersection semantics. Rules: DAX003, DAX004.",
    "min_baseline_ms": null,
    "confirm_with_explain": false,
    "engines": [
      "dax"
    ]
  }
]
