Looking at the query, I can see an opportunity to optimize by **decorrelating the query** and **pushing filters earlier**. The current query performs a Cartesian product between `store_sales LEFT OUTER JOIN store_returns` and `reason`, then filters after the join. This is inefficient because:

1. The `reason` table filter (`r_reason_desc = 'duplicate purchase'`) can be applied first to get exactly one row
2. The outer join can be converted to a more efficient inner join since `sr_reason_sk = r_reason_sk` in the WHERE clause forces an inner join
3. The CASE expression can be simplified once we know we're only dealing with returns that have the specific reason

Here's my optimized version:

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "decorrelate",
      "nodes": {
        "duplicate_reason": "SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'",
        "filtered_returns": "SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN duplicate_reason ON sr_reason_sk = r_reason_sk",
        "sales_with_returns": "SELECT ss_customer_sk, (ss_quantity - COALESCE(sr_return_quantity, 0)) * ss_sales_price AS act_sales FROM store_sales LEFT JOIN filtered_returns ON sr_item_sk = ss_item_sk AND sr_ticket_number = ss_ticket_number",
        "main_query": "SELECT ss_customer_sk, SUM(act_sales) AS sumsales FROM sales_with_returns GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same grouping and aggregation",
        "same ordering"
      ],
      "expected_speedup": "3.0x",
      "risk": "low"
    }
  ],
  "explanation": "1. Extracted the reason filter into a CTE that returns exactly one row (r_reason_sk for 'duplicate purchase'). 2. Created filtered_returns CTE that only includes returns with the specific reason. 3. Simplified the CASE expression to simple arithmetic since sr_return_quantity will be NULL only when there's no matching return with that reason. 4. Avoided Cartesian product by joining reason early and filtering store_returns. This reduces the join size from ~2.9M rows to only returns with the specific reason."
}
```

**Key insights:**
- The original Cartesian product between the LEFT JOIN result and `reason` is unnecessary and expensive
- Filtering `reason` first reduces it to 1 row, then filtering `store_returns` by that reason_sk significantly reduces the join size
- The outer join can remain as LEFT JOIN but now with a much smaller right side
- The CASE expression simplifies because if there's no matching return with that reason, `sr_return_quantity` will be NULL and `COALESCE(sr_return_quantity, 0)` handles it correctly