```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_year, d_qoy, d_moy FROM date_dim WHERE d_month_seq BETWEEN 1206 AND 1217",
        "joined_sales": "SELECT i.i_category, i.i_class, i.i_brand, i.i_product_name, fd.d_year, fd.d_qoy, fd.d_moy, s.s_store_id, ss.ss_sales_price * ss.ss_quantity AS sales_amount FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN item i ON ss.ss_item_sk = i.i_item_sk JOIN store s ON ss.ss_store_sk = s.s_store_sk",
        "aggregated_sales": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, SUM(COALESCE(sales_amount, 0)) AS sumsales FROM joined_sales GROUP BY ROLLUP (i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id)",
        "ranked_sales": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, RANK() OVER (PARTITION BY i_category ORDER BY sumsales DESC) AS rk FROM aggregated_sales",
        "main_query": "SELECT * FROM ranked_sales WHERE rk <= 100 ORDER BY i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, rk LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same grouping and aggregation",
        "same window function behavior"
      ],
      "expected_speedup": "4.0x",
      "risk": "low"
    }
  ],
  "explanation": "Extracted date_dim filter into CTE to reduce join cardinality early. The d_month_seq filter reduces date_dim from 73,049 rows to 365 rows (12 months). By isolating this filter into a CTE, the expensive store_sales scan (34M rows) joins only with the filtered dates, dramatically reducing intermediate join results. All other semantics preserved exactly."
}
```