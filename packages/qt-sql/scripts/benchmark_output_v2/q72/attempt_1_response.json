Looking at the query, I can see several optimization opportunities:

1. **Date CTE Isolation**: The query uses three `date_dim` joins with complex conditions. I can extract these into focused CTEs.
2. **Early Filtering**: Multiple dimension tables have filters that can be pushed into CTEs early.
3. **Redundant Scans**: The execution plan shows multiple scans on the same tables, particularly `inventory`.

Here's the optimized rewrite:

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "semantic_rewrite",
      "nodes": {
        "sold_dates": "SELECT d_date_sk, d_week_seq, d_date FROM date_dim WHERE d_year = 2002",
        "ship_dates": "SELECT d_date_sk, d_date FROM date_dim",
        "filtered_cd": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'W'",
        "filtered_hd": "SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '501-1000'",
        "inventory_with_week": "SELECT inv_item_sk, inv_warehouse_sk, inv_date_sk, inv_quantity_on_hand, d_week_seq FROM inventory JOIN date_dim ON inv_date_sk = d_date_sk",
        "filtered_sales": "SELECT cs_item_sk, cs_order_number, cs_promo_sk, cs_bill_cdemo_sk, cs_bill_hdemo_sk, cs_sold_date_sk, cs_ship_date_sk, cs_quantity FROM catalog_sales JOIN sold_dates ON cs_sold_date_sk = sold_dates.d_date_sk JOIN ship_dates ON cs_ship_date_sk = ship_dates.d_date_sk WHERE ship_dates.d_date > sold_dates.d_date + 5",
        "main_query": "SELECT i_item_desc, w_warehouse_name, sold_dates.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM filtered_sales JOIN inventory_with_week ON (cs_item_sk = inv_item_sk AND sold_dates.d_week_seq = inventory_with_week.d_week_seq) JOIN warehouse ON (w_warehouse_sk = inv_warehouse_sk) JOIN item ON (i_item_sk = cs_item_sk) JOIN filtered_cd ON (cs_bill_cdemo_sk = filtered_cd.cd_demo_sk) JOIN filtered_hd ON (cs_bill_hdemo_sk = filtered_hd.hd_demo_sk) LEFT OUTER JOIN promotion ON (cs_promo_sk = p_promo_sk) LEFT OUTER JOIN catalog_returns ON (cr_item_sk = cs_item_sk AND cr_order_number = cs_order_number) WHERE inv_quantity_on_hand < cs_quantity GROUP BY i_item_desc, w_warehouse_name, sold_dates.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, sold_dates.d_week_seq LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same grouping and aggregation",
        "same ordering"
      ],
      "expected_speedup": "3.5x",
      "risk": "medium"
    }
  ],
  "explanation": "1. Extracted date_dim filters into focused CTEs: 'sold_dates' for d1 (year=2002), 'ship_dates' for d3. 2. Pushed customer_demographics and household_demographics filters into early CTEs. 3. Combined inventory with date_dim to include week_seq early, eliminating the need for separate d2 join. 4. Created 'filtered_sales' CTE that pre-joins catalog_sales with date CTEs and applies the date comparison condition (d3.d_date > d1.d_date + 5). This reduces the main query complexity by moving date logic and filtering into CTEs, allowing each to be scanned once with focused filters."
}
```

**Key insights:**
1. The date condition `d3.d_date > d1.d_date + 5` can be computed early in the `filtered_sales` CTE.
2. The `inventory` table is scanned multiple times in the original - by joining it with `date_dim` early and including `d_week_seq`, we eliminate the need for a separate `d2` join in the main query.
3. All dimension table filters are pushed into CTEs for early filtering.
4. The rewrite maintains the same LEFT OUTER JOIN semantics with promotion and catalog_returns.