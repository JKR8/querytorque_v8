{
  "id": "NOT_IN_TO_NOT_EXISTS",
  "name": "NOT IN to NOT EXISTS",
  "description": "PostgreSQL CANNOT automatically transform NOT IN to anti-join due to different NULL semantics. NOT EXISTS handles NULLs correctly and enables anti-join.",
  "verified_speedup": "10x+",
  "benchmark": "dsb",
  "database": "postgres",
  "example": {
    "opportunity": "NOT_IN_TO_NOT_EXISTS",
    "before_sql": "SELECT * FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM blacklist);",
    "after_sql": "SELECT * FROM customers c WHERE NOT EXISTS (SELECT 1 FROM blacklist b WHERE b.customer_id = c.customer_id);",
    "transforms": ["not_in_to_exists", "anti_join"],
    "key_insight": "NOT IN with any NULL in subquery returns 0 rows! NOT EXISTS handles NULLs correctly and enables Hash Anti Join vs O(N^2) SubPlan.",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "not_in_to_exists",
          "nodes": {
            "main_query": "SELECT * FROM customers c WHERE NOT EXISTS (SELECT 1 FROM blacklist b WHERE b.customer_id = c.customer_id);"
          },
          "invariants_kept": ["same result rows when no NULLs", "correct NULL handling"],
          "expected_speedup": "10x+",
          "risk": "low"
        }
      ]
    }
  }
}
