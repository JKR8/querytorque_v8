[
  {
    "id": "deferred_window_aggregation",
    "name": "Deferred Window Aggregation",
    "description": "When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joined with FULL OUTER JOIN followed by another WINDOW pass for NULL carry-forward: defer the WINDOW out of the CTEs, join daily totals, then compute cumulative sums once on the joined result. SUM() OVER() naturally skips NULLs, eliminating the need for a separate MAX() carry-forward window.",
    "benchmark_queries": [
      "Q51"
    ],
    "verified_speedup": "1.36x",
    "example": {
      "opportunity": "CONSOLIDATE WINDOW PASSES",
      "input_slice": "[web_v1] type=cte\nSELECT ws_item_sk AS item_sk, d_date,\n  SUM(SUM(ws_sales_price)) OVER (PARTITION BY ws_item_sk ORDER BY d_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cume_sales\nFROM web_sales, date_dim\nWHERE ws_sold_date_sk = d_date_sk AND d_month_seq BETWEEN 1216 AND 1216+11 AND ws_item_sk IS NOT NULL\nGROUP BY ws_item_sk, d_date\n\n[store_v1] type=cte\nSELECT ss_item_sk AS item_sk, d_date,\n  SUM(SUM(ss_sales_price)) OVER (PARTITION BY ss_item_sk ORDER BY d_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cume_sales\nFROM store_sales, date_dim\nWHERE ss_sold_date_sk = d_date_sk AND d_month_seq BETWEEN 1216 AND 1216+11 AND ss_item_sk IS NOT NULL\nGROUP BY ss_item_sk, d_date\n\n[main_query] type=main\nSELECT * FROM (\n  SELECT item_sk, d_date, web_sales, store_sales,\n    MAX(web_sales) OVER (PARTITION BY item_sk ORDER BY d_date ROWS UNBOUNDED PRECEDING) AS web_cumulative,\n    MAX(store_sales) OVER (PARTITION BY item_sk ORDER BY d_date ROWS UNBOUNDED PRECEDING) AS store_cumulative\n  FROM (\n    SELECT COALESCE(web.item_sk, store.item_sk) AS item_sk, COALESCE(web.d_date, store.d_date) AS d_date,\n      web.cume_sales AS web_sales, store.cume_sales AS store_sales\n    FROM web_v1 web FULL OUTER JOIN store_v1 store ON (web.item_sk = store.item_sk AND web.d_date = store.d_date)\n  ) x\n) y\nWHERE web_cumulative > store_cumulative ORDER BY item_sk, d_date LIMIT 100",
      "output": {
        "rewrite_sets": [
          {
            "id": "rs_01",
            "transform": "semantic_rewrite",
            "nodes": {
              "web_daily": "SELECT ws_item_sk AS item_sk, d_date, SUM(ws_sales_price) AS daily_sales FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND d_month_seq BETWEEN 1216 AND 1216 + 11 AND ws_item_sk IS NOT NULL GROUP BY ws_item_sk, d_date",
              "store_daily": "SELECT ss_item_sk AS item_sk, d_date, SUM(ss_sales_price) AS daily_sales FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_month_seq BETWEEN 1216 AND 1216 + 11 AND ss_item_sk IS NOT NULL GROUP BY ss_item_sk, d_date",
              "main_query": "SELECT * FROM (SELECT COALESCE(web.item_sk, store.item_sk) AS item_sk, COALESCE(web.d_date, store.d_date) AS d_date, SUM(web.daily_sales) OVER (PARTITION BY COALESCE(web.item_sk, store.item_sk) ORDER BY COALESCE(web.d_date, store.d_date) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS web_cumulative, SUM(store.daily_sales) OVER (PARTITION BY COALESCE(web.item_sk, store.item_sk) ORDER BY COALESCE(web.d_date, store.d_date) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS store_cumulative FROM web_daily web FULL OUTER JOIN store_daily store ON web.item_sk = store.item_sk AND web.d_date = store.d_date) y WHERE web_cumulative > store_cumulative ORDER BY item_sk, d_date LIMIT 100"
            },
            "invariants_kept": [
              "same result rows",
              "same ordering",
              "same column output",
              "same cumulative semantics"
            ],
            "expected_speedup": "1.4x",
            "risk": "low"
          }
        ]
      },
      "key_insight": "When CTEs compute GROUP BY + WINDOW (running sum), then FULL OUTER JOIN introduces NULLs requiring a MAX() OVER() carry-forward pass: remove WINDOW from the CTEs (keep only GROUP BY for daily totals), join the daily totals, then compute SUM() OVER() once on the joined result. SUM() naturally skips NULLs, so the carry-forward is free. Reduces 3 WINDOW passes (2 in CTEs + 1 MAX carry-forward) to 1.",
      "when_not_to_use": "Do not use when the CTE window function is referenced by other consumers besides the final join (the cumulative value is needed elsewhere). Do not use when the window function is not a monotonically accumulating SUM - e.g., AVG, COUNT, or non-monotonic window functions require separate computation. Only applies when the join is FULL OUTER and the carry-forward window is MAX/LAST_VALUE over a cumulative sum."
    },
    "original_sql": "WITH web_v1 as (\nselect\n  ws_item_sk item_sk, d_date,\n  sum(sum(ws_sales_price))\n      over (partition by ws_item_sk order by d_date rows between unbounded preceding and current row) cume_sales\nfrom web_sales\n    ,date_dim\nwhere ws_sold_date_sk=d_date_sk\n  and d_month_seq between 1216 and 1216+11\n  and ws_item_sk is not NULL\ngroup by ws_item_sk, d_date),\nstore_v1 as (\nselect\n  ss_item_sk item_sk, d_date,\n  sum(sum(ss_sales_price))\n      over (partition by ss_item_sk order by d_date rows between unbounded preceding and current row) cume_sales\nfrom store_sales\n    ,date_dim\nwhere ss_sold_date_sk=d_date_sk\n  and d_month_seq between 1216 and 1216+11\n  and ss_item_sk is not NULL\ngroup by ss_item_sk, d_date)\n select *\nfrom (select item_sk\n     ,d_date\n     ,web_sales\n     ,store_sales\n     ,max(web_sales)\n         over (partition by item_sk order by d_date rows between unbounded preceding and current row) web_cumulative\n     ,max(store_sales)\n         over (partition by item_sk order by d_date rows between unbounded preceding and current row) store_cumulative\n     from (select case when web.item_sk is not null then web.item_sk else store.item_sk end item_sk\n                 ,case when web.d_date is not null then web.d_date else store.d_date end d_date\n                 ,web.cume_sales web_sales\n                 ,store.cume_sales store_sales\n           from web_v1 web full outer join store_v1 store on (web.item_sk = store.item_sk\n                                                          and web.d_date = store.d_date)\n          )x )y\nwhere web_cumulative > store_cumulative\norder by item_sk\n        ,d_date\n LIMIT 100;",
    "optimized_sql": "WITH filtered_dates AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1216 AND 1216 + 11), filtered_web_sales AS (SELECT ws_item_sk AS item_sk, d_date, ws_sales_price FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk WHERE NOT ws_item_sk IS NULL), filtered_store_sales AS (SELECT ss_item_sk AS item_sk, d_date, ss_sales_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk WHERE NOT ss_item_sk IS NULL), web_v1 AS (SELECT item_sk, d_date, SUM(SUM(ws_sales_price)) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS cume_sales FROM filtered_web_sales GROUP BY item_sk, d_date), store_v1 AS (SELECT item_sk, d_date, SUM(SUM(ss_sales_price)) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS cume_sales FROM filtered_store_sales GROUP BY item_sk, d_date)\nSELECT * FROM (SELECT item_sk, d_date, web_sales, store_sales, MAX(web_sales) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS web_cumulative, MAX(store_sales) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS store_cumulative FROM (SELECT CASE WHEN NOT web.item_sk IS NULL THEN web.item_sk ELSE store.item_sk END AS item_sk, CASE WHEN NOT web.d_date IS NULL THEN web.d_date ELSE store.d_date END AS d_date, web.cume_sales AS web_sales, store.cume_sales AS store_sales FROM web_v1 AS web FULL OUTER JOIN store_v1 AS store ON (web.item_sk = store.item_sk AND web.d_date = store.d_date)) AS x) AS y WHERE web_cumulative > store_cumulative ORDER BY item_sk, d_date LIMIT 100;",
    "optimized_source": "dsr1",
    "benchmark_query_num": 51,
    "sf10_baseline_ms": 1735.51
  },
  {
    "id": "early_filter",
    "name": "Early Dimension Filter",
    "description": "Filter dimension tables FIRST, then join to fact tables to reduce expensive joins",
    "benchmark_queries": [
      "Q93",
      "Q11"
    ],
    "verified_speedup": "4.00x",
    "example": {
      "opportunity": "EARLY_FILTER",
      "input_slice": "[main_query]:\nSELECT ss_customer_sk, SUM(act_sales) AS sumsales\nFROM (SELECT ss.ss_customer_sk, CASE WHEN sr.sr_return_quantity IS NOT NULL\n        THEN (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price\n        ELSE ss.ss_quantity * ss.ss_sales_price END AS act_sales\n      FROM store_sales ss LEFT JOIN store_returns sr ON ss.ss_item_sk = sr.sr_item_sk\n      JOIN reason r ON sr.sr_reason_sk = r.r_reason_sk\n      WHERE r.r_reason_desc = 'duplicate purchase') t\nGROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100",
      "output": {
        "rewrite_sets": [
          {
            "id": "rs_01",
            "transform": "early_filter",
            "nodes": {
              "filtered_reason": "SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'",
              "filtered_returns": "SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk",
              "main_query": "SELECT ss_customer_sk, SUM(act_sales) AS sumsales FROM (SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales ss JOIN filtered_returns fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100"
            },
            "invariants_kept": [
              "output columns unchanged",
              "grain preserved",
              "same result rows"
            ],
            "expected_speedup": "2.71x",
            "risk": "low"
          }
        ]
      },
      "key_insight": "Filter dimension table (reason) FIRST, then join to fact. Reduces returns to only 'duplicate purchase' before expensive store_sales join."
    },
    "original_sql": "select ss_customer_sk\n            ,sum(act_sales) sumsales\n      from (select ss_item_sk\n                  ,ss_ticket_number\n                  ,ss_customer_sk\n                  ,case when sr_return_quantity is not null then (ss_quantity-sr_return_quantity)*ss_sales_price\n                                                            else (ss_quantity*ss_sales_price) end act_sales\n            from store_sales left outer join store_returns on (sr_item_sk = ss_item_sk\n                                                               and sr_ticket_number = ss_ticket_number)\n                ,reason\n            where sr_reason_sk = r_reason_sk\n              and r_reason_desc = 'duplicate purchase') t\n      group by ss_customer_sk\n      order by sumsales, ss_customer_sk\n LIMIT 100;",
    "optimized_sql": "WITH filtered_reason AS (SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'), filtered_returns AS (SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk)\nSELECT ss_customer_sk, SUM(act_sales) AS sumsales FROM (SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales AS ss JOIN filtered_returns AS fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100;",
    "optimized_source": "kimi",
    "benchmark_query_num": 93,
    "sf10_baseline_ms": 499.71,
    "sf10_speedup": 2.97,
    "sf10_rows_match": true
  },
  {
    "id": "shared_dimension_multi_channel",
    "name": "Shared Dimension CTEs Across Multi-Channel Queries",
    "description": "Extract shared dimension filters (date, item, promotion) into CTEs when multiple channel CTEs (store/catalog/web) apply identical filters independently",
    "benchmark_queries": [
      "Q80"
    ],
    "verified_speedup": "1.30x",
    "example": {
      "opportunity": "DIMENSION_CTE_ISOLATE + PREFETCH_FACT_JOIN",
      "input_slice": "[ssr] type=cte:\nSELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, ...\nFROM store_sales LEFT OUTER JOIN store_returns ON (...), date_dim, store, item, promotion\nWHERE ss_sold_date_sk = d_date_sk\n  AND d_date BETWEEN '1998-08-28' AND '1998-08-28' + 30 days\n  AND ss_item_sk = i_item_sk AND i_current_price > 50\n  AND ss_promo_sk = p_promo_sk AND p_channel_tv = 'N'\nGROUP BY s_store_id\n\n[wsr] type=cte:\nSELECT web_site_id, SUM(ws_ext_sales_price) AS sales, ...\nFROM web_sales LEFT OUTER JOIN web_returns ON (...), date_dim, web_site, item, promotion\nWHERE ws_sold_date_sk = d_date_sk\n  AND d_date BETWEEN '1998-08-28' AND '1998-08-28' + 30 days\n  AND ws_item_sk = i_item_sk AND i_current_price > 50\n  AND ws_promo_sk = p_promo_sk AND p_channel_tv = 'N'\nGROUP BY web_site_id\n\n[csr] type=cte: (same pattern for catalog_sales)\n\n[main_query]: SELECT channel, id, SUM(sales), SUM(returns), SUM(profit)\nFROM (ssr UNION ALL csr UNION ALL wsr) GROUP BY ROLLUP(channel, id)",
      "output": {
        "rewrite_sets": [
          {
            "id": "rs_01",
            "transform": "dimension_cte_isolate",
            "nodes": {
              "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' AS DATE) + INTERVAL '30' DAY)",
              "filtered_items": "SELECT i_item_sk FROM item WHERE i_current_price > 50",
              "filtered_promotions": "SELECT p_promo_sk FROM promotion WHERE p_channel_tv = 'N'",
              "prefiltered_store_sales": "SELECT ss_item_sk, ss_store_sk, ss_ticket_number, ss_ext_sales_price, ss_net_profit FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_items ON ss_item_sk = i_item_sk JOIN filtered_promotions ON ss_promo_sk = p_promo_sk",
              "prefiltered_web_sales": "SELECT ws_item_sk, ws_web_site_sk, ws_order_number, ws_ext_sales_price, ws_net_profit FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_items ON ws_item_sk = i_item_sk JOIN filtered_promotions ON ws_promo_sk = p_promo_sk",
              "ssr": "SELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, SUM(COALESCE(sr_return_amt, 0)) AS returns, SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit FROM prefiltered_store_sales LEFT OUTER JOIN store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number) JOIN store ON ss_store_sk = s_store_sk GROUP BY s_store_id",
              "wsr": "SELECT web_site_id, SUM(ws_ext_sales_price) AS sales, SUM(COALESCE(wr_return_amt, 0)) AS returns, SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit FROM prefiltered_web_sales LEFT OUTER JOIN web_returns ON (ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number) JOIN web_site ON ws_web_site_sk = web_site_sk GROUP BY web_site_id"
            },
            "invariants_kept": [
              "same result rows",
              "same ordering",
              "same column output",
              "same ROLLUP semantics"
            ],
            "expected_speedup": "1.30x",
            "risk": "low"
          }
        ]
      },
      "key_insight": "When multiple CTEs (store/catalog/web channels) apply identical dimension filters (same date range, same item price threshold, same promotion filter), extract those filters into shared dimension CTEs and pre-join them with each fact table. This eliminates redundant dimension scans. Note: only pre-join channels where the join is straightforward. If one channel (e.g., catalog) has a more complex join structure, leave it unchanged."
    },
    "original_sql": "with ssr as\n (select  s_store_id as store_id,\n          sum(ss_ext_sales_price) as sales,\n          sum(coalesce(sr_return_amt, 0)) as \"returns\",\n          sum(ss_net_profit - coalesce(sr_net_loss, 0)) as profit\n  from store_sales left outer join store_returns on\n         (ss_item_sk = sr_item_sk and ss_ticket_number = sr_ticket_number),\n     date_dim,\n     store,\n     item,\n     promotion\n where ss_sold_date_sk = d_date_sk\n       and d_date between cast('1998-08-28' as date) \n                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)\n       and ss_store_sk = s_store_sk\n       and ss_item_sk = i_item_sk\n       and i_current_price > 50\n       and ss_promo_sk = p_promo_sk\n       and p_channel_tv = 'N'\n group by s_store_id)\n ,\n csr as\n (select  cp_catalog_page_id as catalog_page_id,\n          sum(cs_ext_sales_price) as sales,\n          sum(coalesce(cr_return_amount, 0)) as \"returns\",\n          sum(cs_net_profit - coalesce(cr_net_loss, 0)) as profit\n  from catalog_sales left outer join catalog_returns on\n         (cs_item_sk = cr_item_sk and cs_order_number = cr_order_number),\n     date_dim,\n     catalog_page,\n     item,\n     promotion\n where cs_sold_date_sk = d_date_sk\n       and d_date between cast('1998-08-28' as date)\n                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)\n        and cs_catalog_page_sk = cp_catalog_page_sk\n       and cs_item_sk = i_item_sk\n       and i_current_price > 50\n       and cs_promo_sk = p_promo_sk\n       and p_channel_tv = 'N'\ngroup by cp_catalog_page_id)\n ,\n wsr as\n (select  web_site_id,\n          sum(ws_ext_sales_price) as sales,\n          sum(coalesce(wr_return_amt, 0)) as \"returns\",\n          sum(ws_net_profit - coalesce(wr_net_loss, 0)) as profit\n  from web_sales left outer join web_returns on\n         (ws_item_sk = wr_item_sk and ws_order_number = wr_order_number),\n     date_dim,\n     web_site,\n     item,\n     promotion\n where ws_sold_date_sk = d_date_sk\n       and d_date between cast('1998-08-28' as date)\n                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)\n        and ws_web_site_sk = web_site_sk\n       and ws_item_sk = i_item_sk\n       and i_current_price > 50\n       and ws_promo_sk = p_promo_sk\n       and p_channel_tv = 'N'\ngroup by web_site_id)\n  select channel\n        , id\n        , sum(sales) as sales\n        , sum(\"returns\") as \"returns\"\n        , sum(profit) as profit\n from \n (select 'store channel' as channel\n        , 'store' || store_id as id\n        , sales\n        , \"returns\"\n        , profit\n from   ssr\n union all\n select 'catalog channel' as channel\n        , 'catalog_page' || catalog_page_id as id\n        , sales\n        , \"returns\"\n        , profit\n from  csr\n union all\n select 'web channel' as channel\n        , 'web_site' || web_site_id as id\n        , sales\n        , \"returns\"\n        , profit\n from   wsr\n ) x\n group by rollup (channel, id)\n order by channel\n         ,id\n LIMIT 100;",
    "optimized_sql": "WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' AS DATE) + INTERVAL '30' DAY)), filtered_items AS (SELECT i_item_sk FROM item WHERE i_current_price > 50), filtered_promotions AS (SELECT p_promo_sk FROM promotion WHERE p_channel_tv = 'N'), prefiltered_store_sales AS (SELECT ss_item_sk, ss_store_sk, ss_ticket_number, ss_ext_sales_price, ss_net_profit FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_items ON ss_item_sk = i_item_sk JOIN filtered_promotions ON ss_promo_sk = p_promo_sk), prefiltered_web_sales AS (SELECT ws_item_sk, ws_web_site_sk, ws_order_number, ws_ext_sales_price, ws_net_profit FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_items ON ws_item_sk = i_item_sk JOIN filtered_promotions ON ws_promo_sk = p_promo_sk), ssr AS (SELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, SUM(COALESCE(sr_return_amt, 0)) AS \"returns\", SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit FROM prefiltered_store_sales LEFT OUTER JOIN store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number) JOIN store ON ss_store_sk = s_store_sk GROUP BY s_store_id), wsr AS (SELECT web_site_id, SUM(ws_ext_sales_price) AS sales, SUM(COALESCE(wr_return_amt, 0)) AS \"returns\", SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit FROM prefiltered_web_sales LEFT OUTER JOIN web_returns ON (ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number) JOIN web_site ON ws_web_site_sk = web_site_sk GROUP BY web_site_id), csr AS (SELECT cp_catalog_page_id AS catalog_page_id, SUM(cs_ext_sales_price) AS sales, SUM(COALESCE(cr_return_amount, 0)) AS \"returns\", SUM(cs_net_profit - COALESCE(cr_net_loss, 0)) AS profit FROM catalog_sales LEFT OUTER JOIN catalog_returns ON (cs_item_sk = cr_item_sk AND cs_order_number = cr_order_number), date_dim, catalog_page, item, promotion WHERE cs_sold_date_sk = d_date_sk AND d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' AS DATE) + INTERVAL '30' DAY) AND cs_catalog_page_sk = cp_catalog_page_sk AND cs_item_sk = i_item_sk AND i_current_price > 50 AND cs_promo_sk = p_promo_sk AND p_channel_tv = 'N' GROUP BY cp_catalog_page_id)\nSELECT channel, id, SUM(sales) AS sales, SUM(\"returns\") AS \"returns\", SUM(profit) AS profit FROM (SELECT 'store channel' AS channel, 'store' || store_id AS id, sales, \"returns\", profit FROM ssr UNION ALL SELECT 'catalog channel' AS channel, 'catalog_page' || catalog_page_id AS id, sales, \"returns\", profit FROM csr UNION ALL SELECT 'web channel' AS channel, 'web_site' || web_site_id AS id, sales, \"returns\", profit FROM wsr) AS x GROUP BY ROLLUP (channel, id) ORDER BY channel, id LIMIT 100;",
    "optimized_source": "dsr1",
    "benchmark_query_num": 80,
    "sf10_baseline_ms": 268.48,
    "sf10_speedup": 1.4,
    "sf10_rows_match": true
  }
]