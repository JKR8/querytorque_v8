## 1. STRUCTURAL BREAKDOWN

**year_total CTE**: Aggregates yearly sales totals per customer across three sales channels (store, catalog, web). It joins the large fact tables (store_sales, catalog_sales, web_sales) with customer and date_dim, groups by all customer attributes plus year, and calculates a complex revenue formula. Outputs approximately thousands of rows per sales channel per year (likely millions total).

**main_query**: Performs a 6-way self-join on the year_total CTE to compare each customer's sales growth across channels between 1999 and 2000. Filters for specific years and sale types, requires positive first-year sales, and compares growth ratios. Outputs at most 100 customers meeting the growth conditions.

## 2. BOTTLENECK IDENTIFICATION

The dominant cost is the **year_total CTE** computing aggregates across *all years* only to be filtered to 2 years later. The mechanism is:
1. **Premature full-channel aggregation**: Each UNION branch performs a full table scan of massive sales tables (store_sales, catalog_sales, web_sales) and aggregates across all years, when only 1999-2000 data is needed.
2. **Repeated dimension joins**: Customer and date_dim are joined three times separately, once per channel, with no predicate pushdown.
3. **Explosive 6-way self-join**: The main query self-joins the CTE six times on customer_id, creating a Cartesian-like explosion (O(n⁶) worst case) before filtering by year/sale_type.

The root cause: **Failure to push year filters into the fact table scans**, causing massive unnecessary aggregation. The UNION_ALL structure prevents predicate pushdown across channels.

## 3. PROPOSED OPTIMIZATION

**Change 1: Pre-filter date_dim and push into UNION branches**
- **What**: Create a filtered date_dim CTE with only 1999-2000, then join it in each UNION branch.
- **Why**: Reduces fact table joins by ~98% (assuming uniform year distribution). Enables partition pruning if date_dim is partitioned.
- **Risk**: Must ensure date_dim filtering matches exact year logic (1999 AND 2000 needed for both first/secyear comparisons).
- **Impact**: Significant (50-70% reduction in scanned rows).

**Change 2: Split year_total into separate CTEs by sale_type before filtering**
- **What**: Create three separate CTEs (store_year, catalog_year, web_year) with year filters applied within each.
- **Why**: Allows optimizer to push year filters directly into each fact table scan. Eliminates scanning irrelevant years.
- **Risk**: Must maintain correct UNION semantics for the self-join pattern.
- **Impact**: Significant (further 50% reduction per channel).

**Change 3: Pivot year totals in CTE to avoid 6-way self-join**
- **What**: Restructure year_total to output columns: customer_id, store_1999, store_2000, catalog_1999, catalog_2000, web_1999, web_2000.
- **Why**: Replaces 6-way self-join with single row per customer. Eliminates exponential join explosion.
- **Risk**: Complex restructuring; must handle NULLs for customers missing certain channel-year combinations correctly.
- **Impact**: Moderate to significant (reduces join complexity from O(n⁶) to O(n)).

## 5. RECOMMENDED STRATEGY

**Implement a hybrid approach**:
1. **Create filtered_date CTE**: `SELECT d_date_sk, d_year FROM date_dim WHERE d_year IN (1999, 2000)`
2. **Create channel-specific CTEs**: Build three CTEs that join customer, filtered_date, and respective sales table, aggregating by customer_id and d_year only (drop unnecessary customer attributes).
3. **Pivot within main query**: Use conditional aggregation to create columns for each channel-year combination, then apply the growth comparison logic.

**Implementation sketch**:
```sql
WITH filtered_dates AS (
  SELECT d_date_sk, d_year FROM date_dim 
  WHERE d_year IN (1999, 2000)
),
store_totals AS (
  SELECT c_customer_id, d_year,
    SUM(((ss_ext_list_price - ss_ext_wholesale_cost - ss_ext_discount_amt) + ss_ext_sales_price)/2) AS total
  FROM customer 
  JOIN store_sales ON c_customer_sk = ss_customer_sk
  JOIN filtered_dates ON ss_sold_date_sk = d_date_sk
  GROUP BY c_customer_id, d_year
),
-- Repeat for catalog_sales, web_sales with similar patterns
pivoted AS (
  SELECT 
    customer_id,
    MAX(CASE WHEN channel='s' AND year=1999 THEN total END) as s_1999,
    MAX(CASE WHEN channel='s' AND year=2000 THEN total END) as s_2000,
    -- ... similarly for c_1999, c_2000, w_1999, w_2000
  FROM (
    SELECT c_customer_id as customer_id, 's' as channel, d_year as year, total FROM store_totals
    UNION ALL SELECT c_customer_id, 'c', d_year, total FROM catalog_totals
    UNION ALL SELECT c_customer_id, 'w', d_year, total FROM web_totals
  )
  GROUP BY customer_id
)
SELECT customer_id, c_first_name, c_last_name, c_birth_country
FROM pivoted p
JOIN customer c ON c.c_customer_id = p.customer_id
WHERE s_1999 > 0 AND c_1999 > 0 AND w_1999 > 0
  AND c_2000/c_1999 > s_2000/s_1999
  AND c_2000/c_1999 > w_2000/w_1999
ORDER BY customer_id, c_first_name, c_last_name, c_birth_country
LIMIT 100;
```

## 6. EXAMPLE SELECTION

The FAISS picks are relevant but incomplete:
- **union_cte_split**: Highly relevant - splitting the UNION into separate CTEs enables predicate pushdown.
- **intersect_to_exists**: Not directly applicable (no INTERSECT in query).
- **shared_dimension_multi_channel**: Relevant - extracting shared dimension (date_dim) filtering.

**Better examples**:
- **early_filter**: Critical - filtering date_dim early before joining fact tables.
- **single_pass_aggregation**: Relevant - could consolidate multiple year aggregates.
- **pushdown**: Essential - pushing year filters into UNION branches.

**EXAMPLES: union_cte_split, early_filter, single_pass_aggregation**