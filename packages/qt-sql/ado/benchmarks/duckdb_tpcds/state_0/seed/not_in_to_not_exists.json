{
  "id": "NOT_IN_TO_NOT_EXISTS",
  "name": "Not In To Not Exists",
  "description": "PostgreSQL CANNOT automatically transform NOT IN to anti-join due to\n      different NULL semantics. NOT IN with any NULL in subquery returns\n      no rows, while NOT EXISTS handles NULLs correctly and enables anti-join.",
  "category": "subquery_transformations",
  "priority": "medium",
  "verified_speedup": "High - enables Hash Anti Join vs O(N\u00b2) SubPlan",
  "example": {
    "before_sql": "SELECT * FROM customers \n      WHERE customer_id NOT IN (\n          SELECT customer_id FROM blacklist\n      );\n      -- Returns 0 rows if ANY blacklist.customer_id is NULL!",
    "after_sql": "SELECT * FROM customers c\n      WHERE NOT EXISTS (\n          SELECT 1 FROM blacklist b \n          WHERE b.customer_id = c.customer_id\n      );",
    "alternative_sql": "-- LEFT JOIN pattern also produces anti-join\n      SELECT c.* FROM customers c\n      LEFT JOIN blacklist b ON c.customer_id = b.customer_id\n      WHERE b.customer_id IS NULL;",
    "key_insight": "Always prefer NOT EXISTS over NOT IN for exclusion patterns. Critical\n      for correctness when subquery may contain NULLs.",
    "transforms": [
      "not_in_to_not_exists"
    ]
  },
  "metadata": {
    "pg_version": "All",
    "auto_applied_by_pg": "false",
    "research_source": "",
    "notes": ""
  }
}