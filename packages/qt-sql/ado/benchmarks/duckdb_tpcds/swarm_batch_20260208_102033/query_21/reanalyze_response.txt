FAILURE_ANALYSIS:
All attempts focused on dimension table filtering and CTE isolation, which are sensible optimizations but insufficient for 2.0x speedup. The fundamental bottleneck is the massive inventory table (likely billions of rows) and the expensive 3-way join + aggregation. Key issues: (1) All workers used the same basic star-join pattern with early filtering but missed structural transformations of the fact table itself. (2) The conditional aggregation requires scanning all inventory rows within the 61-day window, regardless of dimension filters. (3) Worker 3's "prefetch_fact_join" showed 0.95x degradation because it created a large intermediate result (inventory_prejoined) before warehouse join, increasing memory pressure. (4) The ratio filter happens AFTER full aggregation, forcing computation of all warehouse-item combinations before filtering. (5) No attempt addressed data layout, partition pruning, or index-like optimizations.

UNEXPLORED_OPPORTUNITIES:
1. **Horizontal partitioning on date_sk**: If inventory is partitioned by inv_date_sk, the 61-day filter could skip ~98% of table scans.
2. **Aggregation pushdown before warehouse join**: Aggregate at warehouse-item-date level before joining with warehouse dimension to reduce data volume.
3. **Vectorized conditional aggregation**: Use FILTER clauses instead of CASE for better vectorization in DuckDB.
4. **Early ratio pruning**: Use HAVING to filter during aggregation rather than nested query.
5. **Materialized view pattern**: Pre-aggregate inventory by date range and warehouse/item combinations.
6. **Bloom filter joins**: Use semi-join reduction from date/item dimensions to inventory.
7. **Reordering joins**: Place smallest dimension (warehouse) first to build minimal hash table.

REFINED_STRATEGY:
Combine aggressive dimension filtering with two-stage aggregation and structural query transformation: (1) Use CTEs for filtered dimensions with small result sets. (2) Perform a semi-join reduction using these dimensions to extract only relevant inventory keys. (3) Aggregate at warehouse-item-date grain before final warehouse join. (4) Push ratio filtering into HAVING clause to avoid materializing all groups. (5) Use FILTER syntax for conditional aggregation. (6) Force join order: date → item → inventory → warehouse.

EXAMPLES: single_pass_aggregation, early_filter, pushdown
HINT: Transform query to use two-phase aggregation with semi-join reduction, FILTER clauses for conditional sums, and HAVING for early ratio pruning. Force join order from smallest to largest filtered dimensions.