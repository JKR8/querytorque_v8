{
  "failure_analysis": "All workers attempted predicate pushdown and CTE isolation but missed the core bottleneck: the query requires 6 self-joins on year_total (3 channels \u00d7 2 years) with complex ratio comparisons. Worker 1's modest gains (1.54x) came from reducing initial row counts but still performed massive self-joins on the union result. Worker 2's regression (0.97x) stemmed from isolating date filtering without addressing the join explosion. Worker 3's split-by-year approach (1.24x) reduced union size but still performed redundant customer joins across channels. Worker 4's single-pass aggregation failed due to improper column references and ambiguous joins from CROSS JOIN + OR conditions. Worker 5 repeated Worker 3's approach. The fundamental issue is the quadratic explosion from self-joining a pre-aggregated union where most customers won't meet all three channel requirements.",
  "unexplored": "1. **Pre-aggregate with early pruning**: Compute channel-year aggregates separately, then immediately filter to only customers with positive 1999 sales across all three channels before performing ratio comparisons.\n2. **Materialize intersection first**: Use INTERSECT to find customers with all three channels in 1999, then compute their 2000 values only for that subset.\n3. **Pivot aggregation**: Use conditional aggregation within each year to create three channel columns per customer-year, eliminating the need for self-joins.\n4. **Leverage DuckDB's struct or map types**: Group by customer once with MAP_AGG or STRUCT to collect channel-year totals in a single pass.\n5. **Window function for ratios**: Compute growth ratios within each channel using LAG, then filter directly without self-joins.",
  "refined_strategy": "Create three separate CTEs for store, catalog, and web sales, each aggregating both years (1999, 2000) in a single pass with conditional aggregation. Then join these three CTEs on customer_id (1 join per channel instead of 6 self-joins). Apply positive 1999 filters and ratio comparisons directly in the final WHERE clause. This reduces the join complexity from O(n\u00b2) to O(n), eliminates the massive UNION ALL, and minimizes repeated customer table scans.",
  "examples": [
    "single_pass_aggregation",
    "early_filter",
    "dimension_cte_isolate",
    "pushdown"
  ],
  "hint": "Transform the three UNION ALL branches into three separate CTEs where each aggregates both 1999 and 2000 totals using conditional SUM(CASE WHEN d_year=...). Then join these three CTEs once and apply all filters. Pre-filter date_dim and customer early."
}