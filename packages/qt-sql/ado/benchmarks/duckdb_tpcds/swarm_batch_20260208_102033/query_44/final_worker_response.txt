```sql
WITH filtered_store_sales AS (
  SELECT 
    ss_item_sk, 
    ss_net_profit,
    CASE WHEN ss_addr_sk IS NULL THEN ss_net_profit END AS store_net_profit
  FROM store_sales
  WHERE ss_store_sk = 146
),
store_avg AS (
  SELECT 
    AVG(store_net_profit) AS avg_profit
  FROM filtered_store_sales
),
item_stats AS (
  SELECT 
    ss_item_sk AS item_sk,
    AVG(ss_net_profit) AS avg_item_profit
  FROM filtered_store_sales
  GROUP BY ss_item_sk
  HAVING AVG(ss_net_profit) > 0.9 * (SELECT avg_profit FROM store_avg)
),
ascending_items AS (
  SELECT 
    item_sk,
    avg_item_profit,
    ROW_NUMBER() OVER (ORDER BY avg_item_profit ASC) AS rnk
  FROM item_stats
  ORDER BY avg_item_profit ASC
  LIMIT 10
),
descending_items AS (
  SELECT 
    item_sk,
    avg_item_profit,
    ROW_NUMBER() OVER (ORDER BY avg_item_profit DESC) AS rnk
  FROM item_stats
  ORDER BY avg_item_profit DESC
  LIMIT 10
),
relevant_items AS (
  SELECT i_item_sk, i_product_name
  FROM item
  WHERE i_item_sk IN (SELECT item_sk FROM ascending_items UNION SELECT item_sk FROM descending_items)
)
SELECT 
  a.rnk,
  ri1.i_product_name AS best_performing,
  ri2.i_product_name AS worst_performing
FROM ascending_items a
JOIN descending_items d ON a.rnk = d.rnk
JOIN relevant_items ri1 ON a.item_sk = ri1.i_item_sk
JOIN relevant_items ri2 ON d.item_sk = ri2.i_item_sk
ORDER BY a.rnk
LIMIT 100;
```

Changes: Combined multiple scans of store_sales into a single filtered CTE, computed store average via conditional aggregation in the same pass, pre-filtered item table to only relevant items, and used ROW_NUMBER() with LIMIT 10 to avoid full window computation over all qualifying items while maintaining exact ranking semantics.

Expected speedup: 2-3x reduction in execution time due to elimination of redundant table scans and early filtering of dimension tables.