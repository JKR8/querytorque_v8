You are a SQL query rewrite engine.

Your goal: rewrite the complete SQL query to maximize execution speed
while preserving exact semantic equivalence (same rows, same columns,
same ordering).

You will receive the full query, its DAG structure showing how CTEs and
subqueries connect, cost analysis per node, and suggested rewrite patterns.
You may restructure the query freely: create new CTEs, merge existing ones,
push filters across node boundaries, or decompose subqueries.

## Query: query083_multi

```sql
WITH sr_items AS (
  SELECT
    i_item_id AS item_id,
    SUM(sr_return_quantity) AS sr_item_qty
  FROM store_returns, item, date_dim
  WHERE
    sr_item_sk = i_item_sk
    AND d_date IN (
      SELECT
        d_date
      FROM date_dim
      WHERE
        d_month_seq IN (
          SELECT
            d_month_seq
          FROM date_dim
          WHERE
            d_date IN ('2002-02-01', '2002-04-11', '2002-07-17', '2002-10-09')
        )
    )
    AND sr_returned_date_sk = d_date_sk
    AND i_category IN ('Jewelry', 'Music')
    AND i_manager_id BETWEEN 16 AND 25
    AND sr_return_amt / sr_return_quantity BETWEEN 184 AND 213
    AND sr_reason_sk IN (26, 32, 40, 66, 73)
  GROUP BY
    i_item_id
), cr_items AS (
  SELECT
    i_item_id AS item_id,
    SUM(cr_return_quantity) AS cr_item_qty
  FROM catalog_returns, item, date_dim
  WHERE
    cr_item_sk = i_item_sk
    AND d_date IN (
      SELECT
        d_date
      FROM date_dim
      WHERE
        d_month_seq IN (
          SELECT
            d_month_seq
          FROM date_dim
          WHERE
            d_date IN ('2002-02-01', '2002-04-11', '2002-07-17', '2002-10-09')
        )
    )
    AND cr_returned_date_sk = d_date_sk
    AND i_category IN ('Jewelry', 'Music')
    AND i_manager_id BETWEEN 16 AND 25
    AND cr_return_amount / cr_return_quantity BETWEEN 184 AND 213
    AND cr_reason_sk IN (26, 32, 40, 66, 73)
  GROUP BY
    i_item_id
), wr_items AS (
  SELECT
    i_item_id AS item_id,
    SUM(wr_return_quantity) AS wr_item_qty
  FROM web_returns, item, date_dim
  WHERE
    wr_item_sk = i_item_sk
    AND d_date IN (
      SELECT
        d_date
      FROM date_dim
      WHERE
        d_month_seq IN (
          SELECT
            d_month_seq
          FROM date_dim
          WHERE
            d_date IN ('2002-02-01', '2002-04-11', '2002-07-17', '2002-10-09')
        )
    )
    AND wr_returned_date_sk = d_date_sk
    AND i_category IN ('Jewelry', 'Music')
    AND i_manager_id BETWEEN 16 AND 25
    AND wr_return_amt / wr_return_quantity BETWEEN 184 AND 213
    AND wr_reason_sk IN (26, 32, 40, 66, 73)
  GROUP BY
    i_item_id
)
SELECT
  sr_items.item_id,
  sr_item_qty,
  sr_item_qty / (
    sr_item_qty + cr_item_qty + wr_item_qty
  ) / 3.0 * 100 AS sr_dev,
  cr_item_qty,
  cr_item_qty / (
    sr_item_qty + cr_item_qty + wr_item_qty
  ) / 3.0 * 100 AS cr_dev,
  wr_item_qty,
  wr_item_qty / (
    sr_item_qty + cr_item_qty + wr_item_qty
  ) / 3.0 * 100 AS wr_dev,
  (
    sr_item_qty + cr_item_qty + wr_item_qty
  ) / 3.0 AS average
FROM sr_items, cr_items, wr_items
WHERE
  sr_items.item_id = cr_items.item_id AND sr_items.item_id = wr_items.item_id
ORDER BY
  sr_items.item_id,
  sr_item_qty
LIMIT 100
```

## DAG Topology

```sql
-- DAG TOPOLOGY
-- Depth 0:
--   sr_items (cte, 25% cost) [GROUP_BY]
--     outputs: [item_id, sr_item_qty]
--   cr_items (cte, 25% cost) [GROUP_BY]
--     outputs: [item_id, cr_item_qty]
--   wr_items (cte, 25% cost) [GROUP_BY]
--     outputs: [item_id, wr_item_qty]
-- Depth 1:
--   main_query (main, 25% cost) [GROUP_BY] ← reads [sr_items, cr_items, wr_items]
--     outputs: [item_id, sr_item_qty, sr_dev, cr_item_qty, cr_dev, wr_item_qty, wr_dev, average]
-- Edges:
--   sr_items → main_query
--   cr_items → main_query
--   wr_items → main_query
```

## Performance Profile

**sr_items**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, SEQ_SCAN[store_returns], SEQ_SCAN[item], SEQ_SCAN[date_dim]
**cr_items**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, SEQ_SCAN[catalog_returns], SEQ_SCAN[item], SEQ_SCAN[date_dim]
**wr_items**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, SEQ_SCAN[web_returns], SEQ_SCAN[item], SEQ_SCAN[date_dim]
**main_query**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, HASH_JOIN, SEQ_SCAN[sr_items], SEQ_SCAN[cr_items], SEQ_SCAN[wr_items]

## Suggested Rewrite Strategy

Phase 2 analysis identified these optimization opportunities:

- **sr_items** → apply **pushdown**
  Heuristic: 25.0% cost, flags=['GROUP_BY']
- **cr_items** → apply **pushdown**
  Heuristic: 25.0% cost, flags=['GROUP_BY']
- **wr_items** → apply **pushdown**
  Heuristic: 25.0% cost, flags=['GROUP_BY']

Nodes not flagged (low cost or no opportunity):
- main_query: No matching pattern for flags=['GROUP_BY']

## Reference Example: pushdown

### BEFORE (slow)
```sql
[main_query]:
SELECT CASE WHEN (SELECT COUNT(*) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20) > 2972190 
  THEN (SELECT AVG(ss_ext_sales_price) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20)
  ELSE (SELECT AVG(ss_net_profit) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20) END AS bucket1,
  CASE WHEN (SELECT COUNT(*) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40) > 4505785
  THEN (SELECT AVG(ss_ext_sales_price) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40)
  ELSE (SELECT AVG(ss_net_profit) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40) END AS bucket2
FROM reason WHERE r_reason_sk = 1
```

**Key insight:** Extract repeated quantity-range subqueries into CTEs. Each CTE computes count, avg_ext_price, avg_net_profit in ONE pass instead of scanning store_sales 15+ times.

### AFTER (fast)
[quantity_1_20_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20
```
[quantity_21_40_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40
```
[quantity_41_60_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 41 AND 60
```
[quantity_61_80_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 61 AND 80
```
[quantity_81_100_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 81 AND 100
```
[main_query]:
```sql
SELECT CASE WHEN q1.cnt > 2972190 THEN q1.avg_ext_price ELSE q1.avg_net_profit END AS bucket1, CASE WHEN q2.cnt > 4505785 THEN q2.avg_ext_price ELSE q2.avg_net_profit END AS bucket2, CASE WHEN q3.cnt > 1575726 THEN q3.avg_ext_price ELSE q3.avg_net_profit END AS bucket3, CASE WHEN q4.cnt > 3188917 THEN q4.avg_ext_price ELSE q4.avg_net_profit END AS bucket4, CASE WHEN q5.cnt > 3525216 THEN q5.avg_ext_price ELSE q5.avg_net_profit END AS bucket5 FROM reason CROSS JOIN quantity_1_20_stats AS q1 CROSS JOIN quantity_21_40_stats AS q2 CROSS JOIN quantity_41_60_stats AS q3 CROSS JOIN quantity_61_80_stats AS q4 CROSS JOIN quantity_81_100_stats AS q5 WHERE r_reason_sk = 1
```

## Constraints

### CRITICAL — Correctness Guards (top of sandwich)

**SEMANTIC_EQUIVALENCE**
The rewritten query MUST return exactly the same rows, columns, and
ordering as the original. This is the prime directive.

**LITERAL_PRESERVATION**
Keep all literal values (dates, strings, numbers) exactly as they appear in
the original SQL. Do not round, truncate, or reformat them.

### HIGH — Performance and Style Rules (middle of sandwich)

**NO_UNFILTERED_DIM_CTE**
When creating a new CTE that scans a dimension table, include at least one
filter predicate. Never materialize an entire dimension without a WHERE clause.

**OR_TO_UNION_LIMIT**
When converting OR predicates to UNION ALL, limit to 4 branches maximum.
Beyond 4, the UNION overhead exceeds the OR scan cost for most planners.

**EXPLICIT_JOINS**
Convert comma-separated implicit joins to explicit JOIN ... ON syntax.
This gives the optimizer better join-order freedom.

### CRITICAL — Correctness Guards (bottom of sandwich)

**KEEP_EXISTS_AS_EXISTS**
Preserve EXISTS/NOT EXISTS subqueries as-is. Do not convert them to
IN/NOT IN or to JOINs — this risks NULL-handling semantic changes.

**COMPLETE_OUTPUT**
The rewritten query must output ALL columns from the original SELECT.
Never drop, rename, or reorder output columns.

## Output

Return the complete rewritten SQL query. The query must be syntactically
valid and ready to execute.

```sql
-- Your rewritten query here
```

After the SQL, briefly explain what you changed:

```
Changes: <1-2 sentence summary of the rewrite>
Expected speedup: <estimate>
```

Now output your rewritten SQL: