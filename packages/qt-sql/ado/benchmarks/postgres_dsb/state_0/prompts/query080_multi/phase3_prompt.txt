You are a SQL query rewrite engine.

Your goal: rewrite the complete SQL query to maximize execution speed
while preserving exact semantic equivalence (same rows, same columns,
same ordering).

You will receive the full query, its DAG structure showing how CTEs and
subqueries connect, cost analysis per node, and suggested rewrite patterns.
You may restructure the query freely: create new CTEs, merge existing ones,
push filters across node boundaries, or decompose subqueries.

## Query: query080_multi

```sql
WITH ssr AS (
  SELECT
    s_store_id AS store_id,
    SUM(ss_ext_sales_price) AS sales,
    SUM(COALESCE(sr_return_amt, 0)) AS returns,
    SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit
  FROM store_sales
  LEFT OUTER JOIN store_returns
    ON (
      ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number
    ), date_dim, store, item, promotion
  WHERE
    ss_sold_date_sk = d_date_sk
    AND d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY'
    AND ss_store_sk = s_store_sk
    AND ss_item_sk = i_item_sk
    AND i_current_price > 50
    AND ss_promo_sk = p_promo_sk
    AND p_channel_email = 'Y'
    AND p_channel_tv = 'Y'
    AND p_channel_radio = 'N'
    AND p_channel_press = 'N'
    AND p_channel_event = 'Y'
    AND ss_wholesale_cost BETWEEN 63 AND 78
    AND i_category IN ('Jewelry', 'Music')
  GROUP BY
    s_store_id
), csr AS (
  SELECT
    cp_catalog_page_id AS catalog_page_id,
    SUM(cs_ext_sales_price) AS sales,
    SUM(COALESCE(cr_return_amount, 0)) AS returns,
    SUM(cs_net_profit - COALESCE(cr_net_loss, 0)) AS profit
  FROM catalog_sales
  LEFT OUTER JOIN catalog_returns
    ON (
      cs_item_sk = cr_item_sk AND cs_order_number = cr_order_number
    ), date_dim, catalog_page, item, promotion
  WHERE
    cs_sold_date_sk = d_date_sk
    AND d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY'
    AND cs_catalog_page_sk = cp_catalog_page_sk
    AND cs_item_sk = i_item_sk
    AND i_current_price > 50
    AND cs_promo_sk = p_promo_sk
    AND p_channel_email = 'Y'
    AND p_channel_tv = 'Y'
    AND p_channel_radio = 'N'
    AND p_channel_press = 'N'
    AND p_channel_event = 'Y'
    AND cs_wholesale_cost BETWEEN 63 AND 78
    AND i_category IN ('Jewelry', 'Music')
  GROUP BY
    cp_catalog_page_id
), wsr AS (
  SELECT
    web_site_id,
    SUM(ws_ext_sales_price) AS sales,
    SUM(COALESCE(wr_return_amt, 0)) AS returns,
    SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit
  FROM web_sales
  LEFT OUTER JOIN web_returns
    ON (
      ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number
    ), date_dim, web_site, item, promotion
  WHERE
    ws_sold_date_sk = d_date_sk
    AND d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY'
    AND ws_web_site_sk = web_site_sk
    AND ws_item_sk = i_item_sk
    AND i_current_price > 50
    AND ws_promo_sk = p_promo_sk
    AND p_channel_email = 'Y'
    AND p_channel_tv = 'Y'
    AND p_channel_radio = 'N'
    AND p_channel_press = 'N'
    AND p_channel_event = 'Y'
    AND ws_wholesale_cost BETWEEN 63 AND 78
    AND i_category IN ('Jewelry', 'Music')
  GROUP BY
    web_site_id
)
SELECT
  channel,
  id,
  SUM(sales) AS sales,
  SUM(returns) AS returns,
  SUM(profit) AS profit
FROM (
  SELECT
    'store channel' AS channel,
    'store' || store_id AS id,
    sales,
    returns,
    profit
  FROM ssr
  UNION ALL
  SELECT
    'catalog channel' AS channel,
    'catalog_page' || catalog_page_id AS id,
    sales,
    returns,
    profit
  FROM csr
  UNION ALL
  SELECT
    'web channel' AS channel,
    'web_site' || web_site_id AS id,
    sales,
    returns,
    profit
  FROM wsr
) AS x
GROUP BY
  ROLLUP (
    channel,
    id
  )
ORDER BY
  channel,
  id
LIMIT 100
```

## DAG Topology

```sql
-- DAG TOPOLOGY
-- Depth 0:
--   ssr (cte, 25% cost) [GROUP_BY]
--     outputs: [store_id, sales, returns, profit]
--   csr (cte, 25% cost) [GROUP_BY]
--     outputs: [catalog_page_id, sales, returns, profit]
--   wsr (cte, 25% cost) [GROUP_BY]
--     outputs: [web_site_id, sales, returns, profit]
-- Depth 1:
--   main_query (main, 25% cost) [GROUP_BY] ← reads [wsr, ssr, csr]
--     outputs: [channel, id, sales, returns, profit]
-- Edges:
--   wsr → main_query
--   ssr → main_query
--   csr → main_query
```

## Performance Profile

**ssr**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, SEQ_SCAN[store_sales], SEQ_SCAN[store_returns], SEQ_SCAN[date_dim]
**csr**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, SEQ_SCAN[catalog_sales], SEQ_SCAN[catalog_returns], SEQ_SCAN[date_dim]
**wsr**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, SEQ_SCAN[web_sales], SEQ_SCAN[web_returns], SEQ_SCAN[date_dim]
**main_query**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, HASH_JOIN, SEQ_SCAN[wsr], SEQ_SCAN[ssr], SEQ_SCAN[csr]

## Suggested Rewrite Strategy

Phase 2 analysis identified these optimization opportunities:

- **ssr** → apply **pushdown**
  Heuristic: 25.0% cost, flags=['GROUP_BY']
- **csr** → apply **pushdown**
  Heuristic: 25.0% cost, flags=['GROUP_BY']
- **wsr** → apply **pushdown**
  Heuristic: 25.0% cost, flags=['GROUP_BY']

Nodes not flagged (low cost or no opportunity):
- main_query: No matching pattern for flags=['GROUP_BY']

## Reference Example: pushdown

### BEFORE (slow)
```sql
[main_query]:
SELECT CASE WHEN (SELECT COUNT(*) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20) > 2972190 
  THEN (SELECT AVG(ss_ext_sales_price) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20)
  ELSE (SELECT AVG(ss_net_profit) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20) END AS bucket1,
  CASE WHEN (SELECT COUNT(*) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40) > 4505785
  THEN (SELECT AVG(ss_ext_sales_price) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40)
  ELSE (SELECT AVG(ss_net_profit) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40) END AS bucket2
FROM reason WHERE r_reason_sk = 1
```

**Key insight:** Extract repeated quantity-range subqueries into CTEs. Each CTE computes count, avg_ext_price, avg_net_profit in ONE pass instead of scanning store_sales 15+ times.

### AFTER (fast)
[quantity_1_20_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20
```
[quantity_21_40_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40
```
[quantity_41_60_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 41 AND 60
```
[quantity_61_80_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 61 AND 80
```
[quantity_81_100_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 81 AND 100
```
[main_query]:
```sql
SELECT CASE WHEN q1.cnt > 2972190 THEN q1.avg_ext_price ELSE q1.avg_net_profit END AS bucket1, CASE WHEN q2.cnt > 4505785 THEN q2.avg_ext_price ELSE q2.avg_net_profit END AS bucket2, CASE WHEN q3.cnt > 1575726 THEN q3.avg_ext_price ELSE q3.avg_net_profit END AS bucket3, CASE WHEN q4.cnt > 3188917 THEN q4.avg_ext_price ELSE q4.avg_net_profit END AS bucket4, CASE WHEN q5.cnt > 3525216 THEN q5.avg_ext_price ELSE q5.avg_net_profit END AS bucket5 FROM reason CROSS JOIN quantity_1_20_stats AS q1 CROSS JOIN quantity_21_40_stats AS q2 CROSS JOIN quantity_41_60_stats AS q3 CROSS JOIN quantity_61_80_stats AS q4 CROSS JOIN quantity_81_100_stats AS q5 WHERE r_reason_sk = 1
```

## Constraints

### CRITICAL — Correctness Guards (top of sandwich)

**SEMANTIC_EQUIVALENCE**
The rewritten query MUST return exactly the same rows, columns, and
ordering as the original. This is the prime directive.

**LITERAL_PRESERVATION**
Keep all literal values (dates, strings, numbers) exactly as they appear in
the original SQL. Do not round, truncate, or reformat them.

### HIGH — Performance and Style Rules (middle of sandwich)

**NO_UNFILTERED_DIM_CTE**
When creating a new CTE that scans a dimension table, include at least one
filter predicate. Never materialize an entire dimension without a WHERE clause.

**OR_TO_UNION_LIMIT**
When converting OR predicates to UNION ALL, limit to 4 branches maximum.
Beyond 4, the UNION overhead exceeds the OR scan cost for most planners.

**EXPLICIT_JOINS**
Convert comma-separated implicit joins to explicit JOIN ... ON syntax.
This gives the optimizer better join-order freedom.

### CRITICAL — Correctness Guards (bottom of sandwich)

**KEEP_EXISTS_AS_EXISTS**
Preserve EXISTS/NOT EXISTS subqueries as-is. Do not convert them to
IN/NOT IN or to JOINs — this risks NULL-handling semantic changes.

**COMPLETE_OUTPUT**
The rewritten query must output ALL columns from the original SELECT.
Never drop, rename, or reorder output columns.

## Output

Return the complete rewritten SQL query. The query must be syntactically
valid and ready to execute.

```sql
-- Your rewritten query here
```

After the SQL, briefly explain what you changed:

```
Changes: <1-2 sentence summary of the rewrite>
Expected speedup: <estimate>
```

Now output your rewritten SQL: