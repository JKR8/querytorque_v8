You are a SQL query rewrite engine.

Your goal: rewrite the complete SQL query to maximize execution speed
while preserving exact semantic equivalence (same rows, same columns,
same ordering).

You will receive the full query, its DAG structure showing how CTEs and
subqueries connect, cost analysis per node, and suggested rewrite patterns.
You may restructure the query freely: create new CTEs, merge existing ones,
push filters across node boundaries, or decompose subqueries.

## Query: query058_multi

```sql
WITH ss_items AS (
  SELECT
    i_item_id AS item_id,
    c_birth_year AS birth_year,
    SUM(ss_ext_sales_price) AS ss_item_rev
  FROM store_sales, item, date_dim, customer
  WHERE
    ss_item_sk = i_item_sk
    AND d_date IN (
      SELECT
        d_date
      FROM date_dim
      WHERE
        d_month_seq = (
          SELECT
            d_month_seq
          FROM date_dim
          WHERE
            d_date = '1999-05-02'
        )
    )
    AND ss_sold_date_sk = d_date_sk
    AND ss_list_price BETWEEN 217 AND 246
    AND i_manager_id BETWEEN 25 AND 54
    AND ss_customer_sk = c_customer_sk
    AND c_birth_year BETWEEN 1961 AND 1967
  GROUP BY
    i_item_id,
    c_birth_year
), cs_items AS (
  SELECT
    i_item_id AS item_id,
    c_birth_year AS birth_year,
    SUM(cs_ext_sales_price) AS cs_item_rev
  FROM catalog_sales, item, date_dim, customer
  WHERE
    cs_item_sk = i_item_sk
    AND d_date IN (
      SELECT
        d_date
      FROM date_dim
      WHERE
        d_month_seq = (
          SELECT
            d_month_seq
          FROM date_dim
          WHERE
            d_date = '1999-05-02'
        )
    )
    AND cs_sold_date_sk = d_date_sk
    AND cs_list_price BETWEEN 217 AND 246
    AND i_manager_id BETWEEN 25 AND 54
    AND cs_bill_customer_sk = c_customer_sk
    AND c_birth_year BETWEEN 1961 AND 1967
  GROUP BY
    i_item_id,
    c_birth_year
), ws_items AS (
  SELECT
    i_item_id AS item_id,
    c_birth_year AS birth_year,
    SUM(ws_ext_sales_price) AS ws_item_rev
  FROM web_sales, item, date_dim, customer
  WHERE
    ws_item_sk = i_item_sk
    AND d_date IN (
      SELECT
        d_date
      FROM date_dim
      WHERE
        d_month_seq = (
          SELECT
            d_month_seq
          FROM date_dim
          WHERE
            d_date = '1999-05-02'
        )
    )
    AND ws_sold_date_sk = d_date_sk
    AND ws_list_price BETWEEN 217 AND 246
    AND i_manager_id BETWEEN 25 AND 54
    AND ws_bill_customer_sk = c_customer_sk
    AND c_birth_year BETWEEN 1961 AND 1967
  GROUP BY
    i_item_id,
    c_birth_year
)
SELECT
  ss_items.item_id,
  ss_items.birth_year,
  ss_item_rev,
  ss_item_rev / (
    (
      ss_item_rev + cs_item_rev + ws_item_rev
    ) / 3
  ) * 100 AS ss_dev,
  cs_item_rev,
  cs_item_rev / (
    (
      ss_item_rev + cs_item_rev + ws_item_rev
    ) / 3
  ) * 100 AS cs_dev,
  ws_item_rev,
  ws_item_rev / (
    (
      ss_item_rev + cs_item_rev + ws_item_rev
    ) / 3
  ) * 100 AS ws_dev,
  (
    ss_item_rev + cs_item_rev + ws_item_rev
  ) / 3 AS average
FROM ss_items, cs_items, ws_items
WHERE
  ss_items.item_id = cs_items.item_id
  AND ss_items.item_id = ws_items.item_id
  AND ss_items.birth_year = cs_items.birth_year
  AND ss_items.birth_year = ws_items.birth_year
  AND ss_item_rev BETWEEN 0.9 * cs_item_rev AND 1.1 * cs_item_rev
  AND ss_item_rev BETWEEN 0.9 * ws_item_rev AND 1.1 * ws_item_rev
  AND cs_item_rev BETWEEN 0.9 * ss_item_rev AND 1.1 * ss_item_rev
  AND cs_item_rev BETWEEN 0.9 * ws_item_rev AND 1.1 * ws_item_rev
  AND ws_item_rev BETWEEN 0.9 * ss_item_rev AND 1.1 * ss_item_rev
  AND ws_item_rev BETWEEN 0.9 * cs_item_rev AND 1.1 * cs_item_rev
ORDER BY
  item_id,
  birth_year,
  ss_item_rev
LIMIT 100
```

## DAG Topology

```sql
-- DAG TOPOLOGY
-- Depth 0:
--   ss_items (cte, 25% cost) [GROUP_BY]
--     outputs: [item_id, birth_year, ss_item_rev]
--   cs_items (cte, 25% cost) [GROUP_BY]
--     outputs: [item_id, birth_year, cs_item_rev]
--   ws_items (cte, 25% cost) [GROUP_BY]
--     outputs: [item_id, birth_year, ws_item_rev]
-- Depth 1:
--   main_query (main, 25% cost) [GROUP_BY] ← reads [ss_items, cs_items, ws_items]
--     outputs: [item_id, birth_year, ss_item_rev, ss_dev, cs_item_rev, cs_dev, ws_item_rev, ws_dev, ...]
-- Edges:
--   ss_items → main_query
--   cs_items → main_query
--   ws_items → main_query
```

## Performance Profile

**ss_items**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, SEQ_SCAN[store_sales], SEQ_SCAN[item], SEQ_SCAN[date_dim]
**cs_items**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, SEQ_SCAN[catalog_sales], SEQ_SCAN[item], SEQ_SCAN[date_dim]
**ws_items**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, SEQ_SCAN[web_sales], SEQ_SCAN[item], SEQ_SCAN[date_dim]
**main_query**: 25% of total cost, ~1,000 rows
  operators: HASH_GROUP_BY, HASH_JOIN, SEQ_SCAN[ss_items], SEQ_SCAN[cs_items], SEQ_SCAN[ws_items]

## Suggested Rewrite Strategy

Phase 2 analysis identified these optimization opportunities:

- **ss_items** → apply **pushdown**
  Heuristic: 25.0% cost, flags=['GROUP_BY']
- **cs_items** → apply **pushdown**
  Heuristic: 25.0% cost, flags=['GROUP_BY']
- **ws_items** → apply **pushdown**
  Heuristic: 25.0% cost, flags=['GROUP_BY']

Nodes not flagged (low cost or no opportunity):
- main_query: No matching pattern for flags=['GROUP_BY']

## Reference Example: pushdown

### BEFORE (slow)
```sql
[main_query]:
SELECT CASE WHEN (SELECT COUNT(*) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20) > 2972190 
  THEN (SELECT AVG(ss_ext_sales_price) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20)
  ELSE (SELECT AVG(ss_net_profit) FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20) END AS bucket1,
  CASE WHEN (SELECT COUNT(*) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40) > 4505785
  THEN (SELECT AVG(ss_ext_sales_price) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40)
  ELSE (SELECT AVG(ss_net_profit) FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40) END AS bucket2
FROM reason WHERE r_reason_sk = 1
```

**Key insight:** Extract repeated quantity-range subqueries into CTEs. Each CTE computes count, avg_ext_price, avg_net_profit in ONE pass instead of scanning store_sales 15+ times.

### AFTER (fast)
[quantity_1_20_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20
```
[quantity_21_40_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40
```
[quantity_41_60_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 41 AND 60
```
[quantity_61_80_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 61 AND 80
```
[quantity_81_100_stats]:
```sql
SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext_price, AVG(ss_net_profit) AS avg_net_profit FROM store_sales WHERE ss_quantity BETWEEN 81 AND 100
```
[main_query]:
```sql
SELECT CASE WHEN q1.cnt > 2972190 THEN q1.avg_ext_price ELSE q1.avg_net_profit END AS bucket1, CASE WHEN q2.cnt > 4505785 THEN q2.avg_ext_price ELSE q2.avg_net_profit END AS bucket2, CASE WHEN q3.cnt > 1575726 THEN q3.avg_ext_price ELSE q3.avg_net_profit END AS bucket3, CASE WHEN q4.cnt > 3188917 THEN q4.avg_ext_price ELSE q4.avg_net_profit END AS bucket4, CASE WHEN q5.cnt > 3525216 THEN q5.avg_ext_price ELSE q5.avg_net_profit END AS bucket5 FROM reason CROSS JOIN quantity_1_20_stats AS q1 CROSS JOIN quantity_21_40_stats AS q2 CROSS JOIN quantity_41_60_stats AS q3 CROSS JOIN quantity_61_80_stats AS q4 CROSS JOIN quantity_81_100_stats AS q5 WHERE r_reason_sk = 1
```

## Constraints

### CRITICAL — Correctness Guards (top of sandwich)

**SEMANTIC_EQUIVALENCE**
The rewritten query MUST return exactly the same rows, columns, and
ordering as the original. This is the prime directive.

**LITERAL_PRESERVATION**
Keep all literal values (dates, strings, numbers) exactly as they appear in
the original SQL. Do not round, truncate, or reformat them.

### HIGH — Performance and Style Rules (middle of sandwich)

**NO_UNFILTERED_DIM_CTE**
When creating a new CTE that scans a dimension table, include at least one
filter predicate. Never materialize an entire dimension without a WHERE clause.

**OR_TO_UNION_LIMIT**
When converting OR predicates to UNION ALL, limit to 4 branches maximum.
Beyond 4, the UNION overhead exceeds the OR scan cost for most planners.

**EXPLICIT_JOINS**
Convert comma-separated implicit joins to explicit JOIN ... ON syntax.
This gives the optimizer better join-order freedom.

### CRITICAL — Correctness Guards (bottom of sandwich)

**KEEP_EXISTS_AS_EXISTS**
Preserve EXISTS/NOT EXISTS subqueries as-is. Do not convert them to
IN/NOT IN or to JOINs — this risks NULL-handling semantic changes.

**COMPLETE_OUTPUT**
The rewritten query must output ALL columns from the original SELECT.
Never drop, rename, or reorder output columns.

## Output

Return the complete rewritten SQL query. The query must be syntactically
valid and ready to execute.

```sql
-- Your rewritten query here
```

After the SQL, briefly explain what you changed:

```
Changes: <1-2 sentence summary of the rewrite>
Expected speedup: <estimate>
```

Now output your rewritten SQL: