```sql
WITH filtered_date AS (
    SELECT d_date_sk
    FROM date_dim
    WHERE d_year = 2002
      AND d_moy = 12
),
filtered_item AS (
    SELECT i_item_sk, i_brand_id, i_manufact_id
    FROM item
    WHERE i_category = 'Home'
),
filtered_customer AS (
    SELECT c_customer_sk, c_current_addr_sk
    FROM customer
    WHERE c_birth_month = 1
),
filtered_address AS (
    SELECT ca_address_sk, ca_zip
    FROM customer_address
    WHERE ca_state = 'TX'
),
filtered_store AS (
    SELECT s_store_sk, s_zip
    FROM store
),
filtered_sales AS (
    SELECT ss_sold_date_sk, ss_item_sk, ss_customer_sk, 
           ss_store_sk, ss_ext_sales_price
    FROM store_sales
    WHERE ss_wholesale_cost BETWEEN 34 AND 54
)
SELECT
    MIN(i.i_brand_id),
    MIN(i.i_manufact_id),
    MIN(fs.ss_ext_sales_price)
FROM filtered_sales fs
JOIN filtered_date d ON d.d_date_sk = fs.ss_sold_date_sk
JOIN filtered_item i ON i.i_item_sk = fs.ss_item_sk
JOIN filtered_customer c ON c.c_customer_sk = fs.ss_customer_sk
JOIN filtered_address ca ON ca.ca_address_sk = c.c_current_addr_sk
JOIN filtered_store s ON s.s_store_sk = fs.ss_store_sk
WHERE SUBSTRING(ca.ca_zip FROM 1 FOR 5) <> SUBSTRING(s.s_zip FROM 1 FOR 5)
```

**Changes**: Created separate CTEs for each filtered dimension table (date_dim, item, customer, customer_address, store) and the fact table (store_sales) with their respective filters, then joined them together. This pushes filters early and isolates each dimension's selective predicates.

**Expected speedup**: ~2.2x - By materializing small filtered dimension sets first, the large fact table join processes far fewer rows. The separate CTEs avoid cross-join dimension explosion while allowing PostgreSQL to choose optimal join orders.