FAILURE_ANALYSIS:
All attempts fell short of 2.0x because they focused on dimension table pre-filtering and CTE materialization without addressing the fundamental bottleneck: the massive Cartesian product between store_sales and store_returns before applying the multi-key join conditions. Each worker tried variations of:
1. Pushing date filters early (Worker 1-4) - helps but insufficient
2. Materializing dimension tables (Worker 3-5) - adds CTE overhead
3. Breaking join chains (Worker 3-4) - still leaves the large fact table join intact

The key missed mechanism: The query joins store_sales (billions of rows) with store_returns (hundreds of millions) on three equality conditions (ss_ticket_number = sr_ticket_number, ss_item_sk = sr_item_sk, ss_customer_sk = sr_customer_sk), but PostgreSQL's optimizer struggles with estimating selectivity of this multi-key join. No attempt addressed the fact that this join produces massive intermediate results before date filtering.

UNEXPLORED_OPPORTUNITIES:
1. **Pre-aggregation before dimension joins**: Compute date differences and counts at the fact level (grouped by ss_store_sk) before joining to store table
2. **Partial condition decomposition**: Separate the most selective join condition (ss_ticket_number = sr_ticket_number) into its own CTE before adding other conditions
3. **Hash aggregation optimization**: Force hash aggregation instead of group aggregation for the store_sales/store_returns join
4. **Merge join hinting**: Explicitly guide the planner to use merge joins on the date_sk columns which are sorted
5. **Avoid double date_dim scan**: Compute the 120-day window mathematically instead of joining to d1

REFINED_STRATEGY:
Combine aggressive pre-aggregation with mathematical date computation and selective join decomposition:
1. First, compute a filtered store_returns CTE with only returns from August 2002
2. Join this with store_sales ONLY on ticket_number (most selective)
3. Compute date difference mathematically using the date_dim keys (avoid second date_dim join)
4. Aggregate by ss_store_sk and date_diff category at the fact level
5. Finally join once to store table for attributes
This reduces the join fanout by orders of magnitude before aggregation.

EXAMPLES: pg_self_join_decomposition, early_filter_decorrelate, pg_materialized_dimension_fact_prefilter
HINT: Pre-aggregate at fact level using mathematical date computation to avoid double date_dim scan, decompose the multi-key join into staged joins starting with most selective condition (ticket_number), and use explicit hash/merge join hints for large fact table joins.