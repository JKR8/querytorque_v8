[
  {
    "worker_id": 1,
    "strategy": "conservative_filter_pushdown_explicit_join",
    "examples": [
      "early_filter_decorrelate",
      "pg_date_cte_explicit_join",
      "pg_dimension_prefetch_star"
    ],
    "hint": "Focus on converting implicit joins to explicit JOIN syntax and pushing down selective filters (state, date, price) early into the correlated subqueries and main FROM clause to reduce row volumes before grouping."
  },
  {
    "worker_id": 2,
    "strategy": "moderate_date_dimension_isolation",
    "examples": [
      "pg_date_cte_explicit_join",
      "pg_dimension_prefetch_star",
      "pg_materialized_dimension_fact_prefilter"
    ],
    "hint": "Isolate the repetitive date_dim filter (d_year=2002, d_moy 3-5) into a reusable CTE. Pre-filter customer and address tables into separate CTEs before the main join and correlation checks to minimize repeated work."
  },
  {
    "worker_id": 3,
    "strategy": "aggressive_multi_cte_fact_decomposition",
    "examples": [
      "pg_materialized_dimension_fact_prefilter",
      "pg_self_join_decomposition",
      "pg_dimension_prefetch_star"
    ],
    "hint": "Materialize all dimension and fact table subsets (store_sales, web_sales, catalog_sales) into separate CTEs with their respective date joins and price filters. Then rewrite the EXISTS/NOT EXISTS logic as joins against these pre\u2011aggregated CTEs to eliminate repeated scans."
  },
  {
    "worker_id": 4,
    "strategy": "novel_exists_to_antijoin_transform",
    "examples": [
      "pg_self_join_decomposition",
      "early_filter_decorrelate",
      "pg_date_cte_explicit_join"
    ],
    "hint": "Transform the NOT EXISTS subqueries into explicit LEFT JOIN \u2026 IS NULL anti\u2011join patterns. Consider rewriting the entire query as a single\u2011pass aggregation over customer dimensions with conditional LEFT JOINs to the three sales channels, using CASE or FILTER to compute the three counts without multiple scans."
  }
]