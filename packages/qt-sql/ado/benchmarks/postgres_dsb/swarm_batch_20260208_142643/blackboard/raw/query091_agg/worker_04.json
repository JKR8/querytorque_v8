{
  "query_id": "query091_agg",
  "worker_id": 4,
  "run_name": "swarm_batch_20260208_142643",
  "timestamp": "2026-02-08T20:24:42.375807",
  "query_intent": "",
  "query_fingerprint": "",
  "examples_used": [
    "pg_self_join_decomposition",
    "pg_materialized_dimension_fact_prefilter",
    "pg_date_cte_explicit_join"
  ],
  "strategy": "novel_or_to_union_restructuring",
  "status": "REGRESSION",
  "speedup": 0.27264263420150997,
  "transforms_applied": [
    "pushdown"
  ],
  "error_category": null,
  "error_messages": [],
  "what_worked": null,
  "why_it_worked": null,
  "what_failed": "Regression (0.27x): Decomposed the OR condition on customer demographics into a UNION ALL of two separate branches, each with its own demographic filter. Created separate CTEs for filtered dimension tables to push filters early. This enables better filter pushdown and potentially different join plans for each demographic pattern.",
  "why_it_failed": "All attempts failed because they didn't address the fundamental performance bottleneck: the massive catalog_returns table scan. Worker 1-3 used CTE-based filter pushdown but joined everything at once, forcing PostgreSQL to process the entire fact table. Worker 4's UNION ALL approach actually doubled the work by scanning catalog_returns twice. Worker 5's IN subqueries prevented join optimization. The common mistake was assuming CTE materialization alone reduces fact table access - PostgreSQL's op",
  "principle": null,
  "reviewed": true
}