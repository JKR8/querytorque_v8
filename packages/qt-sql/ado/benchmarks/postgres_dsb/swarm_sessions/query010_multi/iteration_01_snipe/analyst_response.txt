FAILURE_ANALYSIS:
All workers fell short of 2.0x because they incorrectly assumed the main bottleneck was dimension table filtering, when the real bottleneck lies in the massive EXISTS subqueries against three large fact tables. Worker 1 achieved mild success (1.21x) by safely pre-filtering customer tables but kept the expensive correlated EXISTS intact. Worker 4's OR-to-UNION approach (1.47x) was better but still materialized all three sales channels separately, causing redundant work: customers meeting store_sales condition must also be checked against web/catalog sales, but each CTE recomputes the same dimension joins. Workers 2-3 regressed because their CTEs added materialization overhead without reducing the fundamental correlated join cost. The optimizer cannot push customer predicates into the sales CTEs, forcing full scans of pre-filtered sales data for every qualifying customer.

UNEXPLORED_OPPORTUNITIES:
1. **Aggressive predicate pushdown**: Transform EXISTS to IN with pre-joined fact tables that include customer keys, allowing the optimizer to use hash semi-joins.
2. **Single-pass sales aggregation**: Instead of three separate CTEs, create a unified sales CTE that aggregates customer eligibility across all channels in one scan per fact table.
3. **Early customer filtering with bloom filters**: Use the selective customer_address and customer_demographics filters to build a candidate customer set first, then probe sales tables only for those customers.
4. **Partial materialization**: Materialize only the most selective dimension filters (date/item) and use them to directly filter fact tables in the main query without intermediate CTEs.

REFINED_STRATEGY:
Create a single CTE that pre-joins each sales fact table with filtered date/item dimensions and aggregates customer keys with channel flags. Then use this CTE in the main query with efficient IN conditions and bitmap operations on channel flags. This eliminates redundant dimension joins, enables hash join optimization, and reduces the number of fact table scans from three to one logical scan per channel with early customer filtering.

EXAMPLES: pg_self_join_decomposition, early_filter_decorrelate, pg_materialized_dimension_fact_prefilter
HINT: Build a unified sales CTE containing distinct customer keys with three boolean columns indicating presence in each channel. Pre-filter date and item once. Join this CTE with pre-filtered customers using INNER JOIN on customer key, then filter for store_sales=true AND (web_sales=true OR catalog_sales=true). This transforms correlated EXISTS into a single hash join with bitmap filtering.