{
  "id": "OR_TO_UNION_LIMIT",
  "severity": "HIGH",
  "description": "OR→UNION transform should only be used for simple cases with ≤3 branches. Over-splitting causes multiple scans of fact tables.",
  "failure_rate": "4 queries with >2x regression (0.23x-0.41x speedup) from over-splitting",
  "observed_failures": [
    {
      "query": "Q13",
      "speedup": "0.32x",
      "original": "3 OR conditions in WHERE clause",
      "rewrite": "9 UNION ALL branches (3 conditions × 3 state groups)",
      "problem": "9x scans of store_sales fact table instead of 1 scan with OR"
    },
    {
      "query": "Q48",
      "speedup": "0.32x",
      "original": "3 OR conditions in WHERE clause",
      "rewrite": "Multiple UNION ALL branches with repeated scans",
      "problem": "Same pattern - over-fragmentation of OR conditions"
    },
    {
      "query": "Q34",
      "speedup": "0.41x",
      "original": "Simple OR on d_dom (1-3 OR 25-28)",
      "rewrite": "Separate CTEs for each date range",
      "problem": "Unnecessary fragmentation adds overhead"
    },
    {
      "query": "Q16",
      "speedup": "0.23x",
      "original": "Simple JOINs with filters",
      "rewrite": "Multiple CTEs with IN subqueries + invented extra logic",
      "problem": "Converted efficient JOINs to slower IN subqueries, added non-existent filters"
    }
  ],
  "constraint_rules": [
    {
      "rule": "MAX_UNION_BRANCHES",
      "description": "Only split OR to UNION when result is ≤3 branches total",
      "rationale": "Each UNION branch rescans fact tables. 3+ branches often slower than single scan with OR."
    },
    {
      "rule": "NO_CARTESIAN_EXPANSION",
      "description": "Never expand N OR conditions × M OR conditions into N×M branches",
      "rationale": "3×3=9 branches means 9x fact table scans - always a regression"
    },
    {
      "rule": "PRESERVE_EFFICIENT_OR",
      "description": "DuckDB handles OR conditions efficiently with predicate pushdown. Don't split unless there's a clear benefit.",
      "rationale": "Modern optimizers can push OR predicates down. Splitting removes this optimization opportunity."
    },
    {
      "rule": "NO_INVENTED_FILTERS",
      "description": "Never add WHERE conditions or JOINs that don't exist in the original query",
      "rationale": "Q16 regression was caused by adding multi_warehouse_orders and returned_orders filters"
    }
  ],
  "when_or_to_union_helps": [
    "When OR branches have completely different join patterns",
    "When OR branches access different indexes",
    "When one branch is much more selective than others"
  ],
  "when_or_to_union_hurts": [
    "When all branches scan the same fact table",
    "When expanding creates >3 branches",
    "When original OR is on simple filter predicates"
  ],
  "prompt_instruction": "CAUTION with OR→UNION: Only split OR conditions into UNION ALL when there are ≤3 simple branches AND they have different access patterns. If you have nested ORs (e.g., 3 conditions × 3 values = 9 combinations), DO NOT expand them - keep the original OR structure. DuckDB handles OR predicates efficiently. Over-splitting causes multiple scans of fact tables and severe regressions (0.23x-0.41x observed). When in doubt, preserve the original OR structure."
}
