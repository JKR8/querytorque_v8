## Example: Correlated Aggregate to LATERAL (CORRELATED_AGGREGATE_TO_LATERAL)
Verified speedup: 5-20x

### Input:
[main_query]:
SELECT c.id, c.name, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id) AS total_spent FROM customers c;

### Output:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "decorrelate",
      "nodes": {
        "main_query": "SELECT c.id, c.name, agg.total_spent FROM customers c LEFT JOIN LATERAL (SELECT SUM(amount) AS total_spent FROM orders WHERE customer_id = c.id) agg ON TRUE;"
      },
      "invariants_kept": [
        "same result rows",
        "same aggregation"
      ],
      "expected_speedup": "5x+",
      "risk": "low"
    }
  ]
}
```

**Key insight:** LATERAL enables the optimizer to select hash/merge join instead of being restricted to nested loop execution for correlated aggregates.

---

## Example: Correlated Scalar to LEFT JOIN (CORRELATED_SCALAR_TO_LEFT_JOIN)
Verified speedup: 5-10x

### Input:
[main_query]:
SELECT o.order_id, o.customer_id, (SELECT c.name FROM customers c WHERE c.id = o.customer_id) AS customer_name FROM orders o;

### Output:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "decorrelate",
      "nodes": {
        "main_query": "SELECT o.order_id, o.customer_id, c.name AS customer_name FROM orders o LEFT JOIN customers c ON c.id = o.customer_id;"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns"
      ],
      "expected_speedup": "5x+",
      "risk": "low"
    }
  ]
}
```

**Key insight:** PostgreSQL executes scalar subqueries as nested loops. LEFT JOIN enables hash/merge join strategies.

---

## Example: Correlated WHERE to Derived Table (CORRELATED_WHERE_TO_DERIVED_TABLE)
Verified speedup: 5-20x

### Input:
[main_query]:
SELECT * FROM employees emp WHERE salary > (SELECT AVG(salary) FROM employees WHERE department = emp.department);

### Output:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "decorrelate",
      "nodes": {
        "main_query": "SELECT emp.* FROM employees emp JOIN (SELECT department, AVG(salary) AS avg_salary FROM employees GROUP BY department) dept_avg ON emp.department = dept_avg.department WHERE emp.salary > dept_avg.avg_salary;"
      },
      "invariants_kept": [
        "same result rows",
        "same comparison semantics"
      ],
      "expected_speedup": "5x+",
      "risk": "low"
    }
  ]
}
```

**Key insight:** Correlated subqueries execute O(N) times. Derived table with GROUP BY executes once, then hash join provides O(1) lookup.

---

## CONSTRAINTS (Learned from Benchmark Failures)

The following constraints are MANDATORY based on observed failures:

### ðŸš¨ LITERAL_PRESERVATION (CRITICAL)
CRITICAL: When rewriting SQL, you MUST copy ALL literal values (strings, numbers, dates) EXACTLY from the original query. Do NOT invent, substitute, or 'improve' any filter values. If the original says d_year = 2000, your rewrite MUST say d_year = 2000. If the original says ca_state = 'GA', your rewrite MUST say ca_state = 'GA'. Changing these values will produce WRONG RESULTS and the rewrite will be REJECTED.

### âš ï¸ OR_TO_UNION_LIMIT (HIGH)
CAUTION with ORâ†’UNION: Only split OR conditions into UNION ALL when there are â‰¤3 simple branches AND they have different access patterns. If you have nested ORs (e.g., 3 conditions Ã— 3 values = 9 combinations), DO NOT expand them - keep the original OR structure. DuckDB handles OR predicates efficiently. Over-splitting causes multiple scans of fact tables and severe regressions (0.23x-0.41x observed). When in doubt, preserve the original OR structure.


---

You are an autonomous Query Rewrite Engine. Your goal is to maximize execution speed while strictly preserving semantic invariants.

Output atomic rewrite sets in JSON.

RULES:
- Primary Goal: Maximize execution speed while strictly preserving semantic invariants.
- Allowed Transforms: Use the provided list. If a standard SQL optimization applies that is not listed, label it "semantic_rewrite".
- Atomic Sets: Group dependent changes (e.g., creating a CTE and joining it) into a single rewrite_set.
- Contracts: Output columns, grain, and total result rows must remain invariant.
- Naming: Use descriptive CTE names (e.g., `filtered_returns` vs `cte1`).
- Column Aliasing: Permitted only for aggregations or disambiguation.

ALLOWED TRANSFORMS: pushdown, decorrelate, or_to_union, early_filter, date_cte_isolate, materialize_cte, flatten_subquery, reorder_join, multi_push_predicate, inline_cte, remove_redundant, semantic_rewrite

OUTPUT FORMAT:
```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "transform_name",
      "nodes": {
        "node_id": "new SQL..."
      },
      "invariants_kept": ["list of preserved semantics"],
      "expected_speedup": "2x",
      "risk": "low"
    }
  ],
  "explanation": "what was changed and why"
}
```

## Target Nodes
  [main_query] 

## Subgraph Slice
[main_query] type=main
```sql
SELECT c.customer_id, c.name, (SELECT SUM(o.amount) FROM orders AS o WHERE o.customer_id = c.customer_id) AS total_orders FROM customers AS c WHERE c.region = 'WEST'
```


## Node Contracts
[main_query]:
  output_columns: ['customer_id', 'name', 'total_orders']
  required_predicates: ["c.region = 'WEST'"]

## Downstream Usage
No usage data.

## Cost Attribution
No cost data.

## Detected Opportunities
No obvious opportunities detected.

Now output your rewrite_sets:

## Execution Plan
```
Seq Scan on customers
  SubPlan 1
    ->  Aggregate
          ->  Seq Scan on orders
```
