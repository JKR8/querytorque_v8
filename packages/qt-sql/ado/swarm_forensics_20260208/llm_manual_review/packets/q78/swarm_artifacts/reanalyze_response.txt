FAILURE_ANALYSIS:
All attempts fell short because they failed to address the fundamental bottleneck: massive redundant scanning of three large fact tables (store_sales, web_sales, catalog_sales) with anti-joins against their respective returns tables. Workers 1-3 only applied superficial filter pushdowns but kept the same three-way parallel anti-join pattern. Worker 4's OR-to-UNION rewrite was misapplied to the wrong clause, introducing heavy overhead. Worker 5 correctly identified the anti-join could be rewritten with NOT EXISTS but still processed all three channels independently, missing the critical opportunity to consolidate fact table scans. The core issue remains unaddressed: each channel CTE performs a full scan of its fact table with an anti-join, when we only need store sales in 2000 and matching web/catalog sales for the same year.

UNEXPLORED_OPPORTUNITIES:
1. **Consolidate anti-join preprocessing**: Pre-materialize a distinct set of non-returned (item_sk, customer_sk, sold_year) combinations from each channel in a single CTE using UNION ALL, then use this for all three aggregations.
2. **Aggressive fact table reduction**: Use Bloom filters or semi-joins from the pre-filtered date_dim (2000 only) to drastically reduce fact table scans before aggregation.
3. **Channel consolidation via single-pass aggregation**: Transform the three channel CTEs into a single CTE that pivots channel metrics using conditional aggregation, eliminating redundant scans.
4. **Join order inversion**: Start with filtered store sales, then probe web/catalog sales only for matching (item, customer, year) instead of computing full aggregates for all web/catalog sales.

REFINED_STRATEGY:
1. Create a consolidated "non_returned_sales" CTE that unions distinct (item_sk, customer_sk, d_date_sk, channel) from all three sales tables where no return exists, joining only with date_dim filtered to 2000.
2. Use this CTE as a filter via semi-join against each fact table to compute aggregates, ensuring each fact table is scanned only once with early filtering.
3. Transform the three channel aggregations into a single pivot CTE that computes store, web, and catalog metrics in one pass over each fact table using conditional aggregation.
4. Materialize the date_dim filter as a small CTE and use it to build Bloom filters for fact table scans.

EXAMPLES: single_pass_aggregation, prefetch_fact_join, composite_decorrelate_union
HINT: Transform the three independent anti-join aggregations into a single consolidated pass using UNION ALL of distinct non-returned keys, then join back for metrics. Use conditional aggregation to pivot channel results and avoid redundant scans.