{
  "failure_analysis": "All previous attempts fell short because they failed to address the fundamental bottleneck: repeated full scans of massive fact tables (store_sales, web_sales, catalog_sales) for each customer evaluation. While they attempted decorrelation via precomputed CTEs (Workers 3,5), these CTEs still performed expensive DISTINCT aggregations on entire fact tables before filtering by eligible customers. The optimizer likely cannot push the customer address/demographic filters into these fact table scans, resulting in unnecessary I/O. The best attempt (1.04x) shows marginal gain from decorrelation, but the real bottleneck\u2014scanning fact tables without early restriction to relevant customers\u2014remains unaddressed.",
  "unexplored": "1. **Early fact table restriction**: Use the filtered customer set (by address/demographics) to directly restrict fact table scans via JOINs before DISTINCT.\n2. **Combined channel processing**: Instead of three separate CTEs scanning fact tables independently, use a single CTE that marks channel presence via UNION ALL with conditional columns.\n3. **Aggregate pushdown**: Compute customer-level channel flags directly in the fact table scans using conditional aggregation, avoiding separate DISTINCT operations.\n4. **Anti-join transformation**: Replace NOT EXISTS with explicit LEFT JOIN ... IS NULL patterns after precomputing channel flags, enabling better join ordering.",
  "refined_strategy": "1. Start by creating a highly restricted customer set using address and demographic filters.\n2. Pre-join this customer set with each fact table separately, but push the customer restriction into the fact scan using an INNER JOIN, ensuring fact tables are only scanned for relevant customers.\n3. Use conditional aggregation to compute three boolean flags (has_store, has_web, has_catalog) per customer in a single pass over each joined result, then combine via UNION ALL.\n4. Aggregate these flags at customer level, then filter for customers with has_store=1 and has_web=0 and has_catalog=0.\n5. Finally join with customer_demographics for grouping, avoiding repeated joins.",
  "examples": [
    "early_filter",
    "single_pass_aggregation",
    "prefetch_fact_join",
    "pushdown"
  ],
  "hint": "Force early restriction of fact tables by joining with pre-filtered customer set before DISTINCT or aggregation. Use UNION ALL to consolidate channel checks into one logical scan per fact table, then aggregate flags per customer."
}