```sql
WITH year_total AS (
  SELECT
    c_customer_id AS customer_id,
    c_first_name AS customer_first_name,
    c_last_name AS customer_last_name,
    c_birth_country AS customer_birth_country,
    d_year AS dyear,
    sale_type,
    SUM(
      CASE sale_type
        WHEN 's' THEN ((ss_ext_list_price - ss_ext_wholesale_cost - ss_ext_discount_amt) + ss_ext_sales_price) / 2
        WHEN 'c' THEN ((cs_ext_list_price - cs_ext_wholesale_cost - cs_ext_discount_amt) + cs_ext_sales_price) / 2
        WHEN 'w' THEN ((ws_ext_list_price - ws_ext_wholesale_cost - ws_ext_discount_amt) + ws_ext_sales_price) / 2
      END
    ) AS year_total
  FROM customer
  CROSS JOIN (SELECT 's' AS sale_type UNION ALL SELECT 'c' UNION ALL SELECT 'w') sale_types
  LEFT JOIN store_sales ON sale_type = 's' AND c_customer_sk = ss_customer_sk
  LEFT JOIN catalog_sales ON sale_type = 'c' AND c_customer_sk = cs_bill_customer_sk
  LEFT JOIN web_sales ON sale_type = 'w' AND c_customer_sk = ws_bill_customer_sk
  LEFT JOIN date_dim ON 
    (sale_type = 's' AND ss_sold_date_sk = d_date_sk) OR
    (sale_type = 'c' AND cs_sold_date_sk = d_date_sk) OR
    (sale_type = 'w' AND ws_sold_date_sk = d_date_sk)
  WHERE d_year IN (1999, 2000)
  GROUP BY
    c_customer_id,
    c_first_name,
    c_last_name,
    c_birth_country,
    d_year,
    sale_type
  HAVING SUM(
    CASE sale_type
      WHEN 's' THEN ((ss_ext_list_price - ss_ext_wholesale_cost - ss_ext_discount_amt) + ss_ext_sales_price) / 2
      WHEN 'c' THEN ((cs_ext_list_price - cs_ext_wholesale_cost - cs_ext_discount_amt) + cs_ext_sales_price) / 2
      WHEN 'w' THEN ((ws_ext_list_price - ws_ext_wholesale_cost - ws_ext_discount_amt) + ws_ext_sales_price) / 2
    END
  ) IS NOT NULL
)
SELECT
  s2.customer_id,
  s2.customer_first_name,
  s2.customer_last_name,
  s2.customer_birth_country
FROM (
  SELECT
    customer_id,
    customer_first_name,
    customer_last_name,
    customer_birth_country
  FROM year_total s1
  WHERE s1.dyear = 1999 AND s1.sale_type = 's' AND s1.year_total > 0
    AND EXISTS (
      SELECT 1 FROM year_total s2 
      WHERE s2.customer_id = s1.customer_id 
        AND s2.dyear = 2000 AND s2.sale_type = 's'
    )
    AND EXISTS (
      SELECT 1 FROM year_total c1 
      WHERE c1.customer_id = s1.customer_id 
        AND c1.dyear = 1999 AND c1.sale_type = 'c' AND c1.year_total > 0
    )
    AND EXISTS (
      SELECT 1 FROM year_total c2 
      WHERE c2.customer_id = s1.customer_id 
        AND c2.dyear = 2000 AND c2.sale_type = 'c'
    )
    AND EXISTS (
      SELECT 1 FROM year_total w1 
      WHERE w1.customer_id = s1.customer_id 
        AND w1.dyear = 1999 AND w1.sale_type = 'w' AND w1.year_total > 0
    )
    AND EXISTS (
      SELECT 1 FROM year_total w2 
      WHERE w2.customer_id = s1.customer_id 
        AND w2.dyear = 2000 AND w2.sale_type = 'w'
    )
) eligible_customers
JOIN year_total s2 ON eligible_customers.customer_id = s2.customer_id 
  AND s2.dyear = 2000 AND s2.sale_type = 's'
JOIN year_total c1 ON eligible_customers.customer_id = c1.customer_id 
  AND c1.dyear = 1999 AND c1.sale_type = 'c'
JOIN year_total c2 ON eligible_customers.customer_id = c2.customer_id 
  AND c2.dyear = 2000 AND c2.sale_type = 'c'
JOIN year_total w1 ON eligible_customers.customer_id = w1.customer_id 
  AND w1.dyear = 1999 AND w1.sale_type = 'w'
JOIN year_total w2 ON eligible_customers.customer_id = w2.customer_id 
  AND w2.dyear = 2000 AND w2.sale_type = 'w'
WHERE 
  c2.year_total / c1.year_total > s2.year_total / s1.year_total
  AND c2.year_total / c1.year_total > w2.year_total / w1.year_total
ORDER BY
  s2.customer_id,
  s2.customer_first_name,
  s2.customer_last_name,
  s2.customer_birth_country
LIMIT 100
```

**Changes**: 
1. Consolidated three separate channel aggregations into a single pass using conditional aggregation with a CROSS JOIN to sale types
2. Replaced the 6-way self-join pattern with EXISTS subqueries to filter eligible customers first
3. Applied explicit JOIN syntax and pushed year/sale_type filters directly into joins

**Expected speedup**: 2-3x due to reduced data scanning from single-pass aggregation and early filtering via EXISTS