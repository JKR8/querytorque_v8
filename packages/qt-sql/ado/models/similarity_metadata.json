{
  "query_metadata": {
    "AGGREGATE_PULL_UP_CONSTANTS": {
      "vector_index": 0,
      "name": "Aggregate Pull Up Constants",
      "description": "Pull up constant GROUP BY keys (SF=100 cited)",
      "verified_speedup": "unknown",
      "transforms": [
        "aggregate_pull_up_constants"
      ],
      "winning_transform": "aggregate_pull_up_constants",
      "key_insight": "When a GROUP BY key is constant, avoid unnecessary grouping work or move constant filters earlier."
    },
    "CORRELATED_AGGREGATE_TO_LATERAL": {
      "vector_index": 1,
      "name": "Correlated Aggregate to LATERAL",
      "description": "Rewrite scalar subqueries with aggregations to LATERAL joins, enabling the optimizer to select optimal join strategies (hash, merge) rather than nested loop.",
      "verified_speedup": "5-20x",
      "transforms": [
        "decorrelate",
        "lateral_join"
      ],
      "winning_transform": "decorrelate",
      "key_insight": "LATERAL enables the optimizer to select hash/merge join instead of being restricted to nested loop execution for correlated aggregates."
    },
    "CORRELATED_SCALAR_TO_LEFT_JOIN": {
      "vector_index": 2,
      "name": "Correlated Scalar to LEFT JOIN",
      "description": "Convert correlated scalar subqueries in SELECT clause to LEFT JOIN. PostgreSQL executes scalar subqueries as nested loops and cannot decorrelate them automatically.",
      "verified_speedup": "5-10x",
      "transforms": [
        "decorrelate",
        "scalar_to_join"
      ],
      "winning_transform": "decorrelate",
      "key_insight": "PostgreSQL executes scalar subqueries as nested loops. LEFT JOIN enables hash/merge join strategies."
    },
    "CORRELATED_WHERE_TO_DERIVED_TABLE": {
      "vector_index": 3,
      "name": "Correlated WHERE to Derived Table",
      "description": "Convert correlated subqueries in WHERE clause to derived table joins when PostgreSQL fails to decorrelate automatically. Common for 'above average' type queries.",
      "verified_speedup": "5-20x",
      "transforms": [
        "decorrelate",
        "derived_table"
      ],
      "winning_transform": "decorrelate",
      "key_insight": "Correlated subqueries execute O(N) times. Derived table with GROUP BY executes once, then hash join provides O(1) lookup."
    },
    "CTE_INLINE_NOT_MATERIALIZED": {
      "vector_index": 4,
      "name": "CTE Inline with NOT MATERIALIZED",
      "description": "Force CTE inlining with NOT MATERIALIZED to enable predicate pushdown when CTE is referenced multiple times but benefits from different filters in each reference.",
      "verified_speedup": "2-5x",
      "transforms": [
        "cte_not_materialized",
        "pushdown"
      ],
      "winning_transform": "cte_not_materialized",
      "key_insight": "WITHOUT NOT MATERIALIZED, PostgreSQL scans entire table then filters twice. WITH NOT MATERIALIZED, predicates are pushed down enabling two filtered scans."
    },
    "FILTER_INTO_JOIN": {
      "vector_index": 5,
      "name": "Filter Into Join",
      "description": "Push filters to one side of a join",
      "verified_speedup": "unknown",
      "transforms": [
        "filter_into_join"
      ],
      "winning_transform": "filter_into_join",
      "key_insight": "Push selective predicates into the joined table to reduce join input size."
    },
    "FILTER_SUB_QUERY_TO_JOIN": {
      "vector_index": 6,
      "name": "Filter Subquery to Join",
      "description": "Scalar/IN/EXISTS subquery in WHERE rewritten to JOIN",
      "verified_speedup": "unknown",
      "transforms": [
        "filter_sub_query_to_join"
      ],
      "winning_transform": "filter_sub_query_to_join",
      "key_insight": "Rewrite scalar/IN/EXISTS subqueries into joins to enable predicate pushdown and better join planning."
    },
    "NOT_IN_TO_NOT_EXISTS": {
      "vector_index": 7,
      "name": "NOT IN to NOT EXISTS",
      "description": "PostgreSQL CANNOT automatically transform NOT IN to anti-join due to different NULL semantics. NOT EXISTS handles NULLs correctly and enables anti-join.",
      "verified_speedup": "10x+",
      "transforms": [
        "not_in_to_exists",
        "anti_join"
      ],
      "winning_transform": "not_in_to_exists",
      "key_insight": "NOT IN with any NULL in subquery returns 0 rows! NOT EXISTS handles NULLs correctly and enables Hash Anti Join vs O(N^2) SubPlan."
    },
    "TOP_N_PER_GROUP_TO_LATERAL": {
      "vector_index": 8,
      "name": "Top N Per Group to LATERAL",
      "description": "Convert correlated subqueries for 'top N per group' to LATERAL joins with LIMIT, enabling index-only scans per group instead of window functions over entire dataset.",
      "verified_speedup": "10x+",
      "transforms": [
        "decorrelate",
        "lateral_join",
        "top_n_lateral"
      ],
      "winning_transform": "decorrelate",
      "key_insight": "With index on (customer_id, order_date DESC), PostgreSQL performs efficient index scan per customer rather than sorting all orders."
    },
    "date_cte_isolate": {
      "vector_index": 9,
      "name": "Date CTE Isolation",
      "description": "Extract date filtering into a separate CTE to enable predicate pushdown and reduce scans",
      "verified_speedup": "4.00x",
      "transforms": [
        "date_cte_isolate + category_avg"
      ],
      "winning_transform": "date_cte_isolate + category_avg",
      "key_insight": "Extract date month_seq subquery into CTE. Extract category average into separate CTE with GROUP BY. Join instead of correlated subquery. This allows each CTE to be scanned once."
    },
    "decorrelate": {
      "vector_index": 10,
      "name": "Decorrelate Subquery",
      "description": "Convert correlated subquery to separate CTE with GROUP BY, then JOIN",
      "verified_speedup": "2.92x",
      "transforms": [
        "decorrelate + pushdown"
      ],
      "winning_transform": "decorrelate + pushdown",
      "key_insight": "Push s_state='SD' filter EARLY into first CTE. Compute average as SEPARATE CTE with GROUP BY (NOT window function). Join on average instead of correlated subquery."
    },
    "early_filter": {
      "vector_index": 11,
      "name": "Early Dimension Filter",
      "description": "Filter dimension tables FIRST, then join to fact tables to reduce expensive joins",
      "verified_speedup": "4.00x",
      "transforms": [
        "early_filter"
      ],
      "winning_transform": "early_filter",
      "key_insight": "Filter dimension table (reason) FIRST, then join to fact. Reduces returns to only 'duplicate purchase' before expensive store_sales join."
    },
    "intersect_to_exists": {
      "vector_index": 12,
      "name": "INTERSECT to EXISTS",
      "description": "Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join planning",
      "verified_speedup": "1.83x",
      "transforms": [
        "intersect_to_exists"
      ],
      "winning_transform": "intersect_to_exists",
      "key_insight": "INTERSECT forces materialization and sorting of all three subqueries before computing set intersection. Converting to EXISTS allows the optimizer to use semi-join strategies and stop early when a match is found. Each EXISTS can use indexes on the join columns."
    },
    "materialize_cte": {
      "vector_index": 13,
      "name": "Materialize Repeated Subquery",
      "description": "Extract repeated subquery patterns into a CTE to avoid recomputation",
      "verified_speedup": "1.37x",
      "transforms": [
        "materialize_cte"
      ],
      "winning_transform": "materialize_cte",
      "key_insight": "Extract the EXISTS subquery into a CTE that finds multi-warehouse orders ONCE. Extract returned orders into another CTE. Join instead of nested EXISTS checks."
    },
    "or_to_union": {
      "vector_index": 14,
      "name": "OR to UNION ALL",
      "description": "Split OR conditions on different columns into UNION ALL branches for better index usage",
      "verified_speedup": "3.17x",
      "transforms": [
        "or_to_union + early_filter"
      ],
      "winning_transform": "or_to_union + early_filter",
      "key_insight": "Each OR branch becomes a separate query with focused predicates. Date filter is extracted as CTE and joined into each branch."
    },
    "pushdown": {
      "vector_index": 15,
      "name": "Filter Pushdown",
      "description": "Push filters from outer query into CTEs/subqueries to reduce intermediate result sizes",
      "verified_speedup": "2.11x",
      "transforms": [
        "pushdown"
      ],
      "winning_transform": "pushdown",
      "key_insight": "Extract repeated quantity-range subqueries into CTEs. Each CTE computes count, avg_ext_price, avg_net_profit in ONE pass instead of scanning store_sales 15+ times."
    },
    "union_cte_split": {
      "vector_index": 16,
      "name": "Union CTE Split/Specialization",
      "description": "Split a generic UNION ALL CTE into specialized CTEs when the main query filters by year or discriminator - eliminates redundant scans",
      "verified_speedup": "1.36x",
      "transforms": [
        "union_cte_split: cte with union all is scanned twice with different year filters - split into year-specific ctes"
      ],
      "winning_transform": "union_cte_split: cte with union all is scanned twice with different year filters - split into year-specific ctes",
      "key_insight": "The original query scans the generic wswscs CTE twice and joins to date_dim twice to filter by year. By pushing year filters INTO the CTE definition, we create specialized CTEs (wswscs_1998, wswscs_1999) that filter during aggregation instead of after. This eliminates redundant date_dim lookups and reduces the rows aggregated."
    }
  },
  "index_stats": {
    "total_vectors": 17,
    "dimensions": 90,
    "index_type": "IndexFlatL2 (cosine similarity via normalization)",
    "normalized_sql": true,
    "zscore_normalized": true,
    "feature_stats_file": "feature_stats.json",
    "dialect": "postgres",
    "normalization": "literals replaced with $N placeholders, identifiers lowercased"
  }
}