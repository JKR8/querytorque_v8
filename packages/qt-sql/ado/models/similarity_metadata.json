{
  "query_metadata": {
    "AGGREGATE_PULL_UP_CONSTANTS": {
      "vector_index": 0,
      "name": "Aggregate Pull Up Constants",
      "description": "Pull up constant GROUP BY keys (SF=100 cited)",
      "verified_speedup": "unknown",
      "transforms": [
        "aggregate_pull_up_constants"
      ],
      "winning_transform": "aggregate_pull_up_constants",
      "key_insight": "When a GROUP BY key is constant, avoid unnecessary grouping work or move constant filters earlier."
    },
    "AGGREGATE_PUSH_BELOW_JOIN": {
      "vector_index": 1,
      "name": "Aggregate Push Below Join",
      "description": "Push aggregation below join when only aggregated values are needed\n      from one side, reducing join cardinality.",
      "verified_speedup": "unknown",
      "transforms": [
        "aggregate_push_below_join"
      ],
      "winning_transform": "aggregate_push_below_join",
      "key_insight": "Join followed by aggregation where one side contributes only to\n      aggregate, not to grouping."
    },
    "ANTI_JOIN_LEFT_JOIN_IS_NULL": {
      "vector_index": 2,
      "name": "Anti Join Left Join Is Null",
      "description": "Convert NOT EXISTS to LEFT JOIN with IS NULL check when the optimizer\n      produces better plans for the join-based pattern.",
      "verified_speedup": "unknown",
      "transforms": [
        "anti_join_left_join_is_null"
      ],
      "winning_transform": "anti_join_left_join_is_null",
      "key_insight": "When NOT EXISTS produces SubPlan instead of Anti Join. Some query\n      structures work better with explicit LEFT JOIN pattern."
    },
    "COALESCE_NULL_PROPAGATION": {
      "vector_index": 3,
      "name": "Coalesce Null Propagation",
      "description": "Use COALESCE to provide default values and prevent NULL propagation\n      in calculations.",
      "verified_speedup": "unknown",
      "transforms": [
        "coalesce_null_propagation"
      ],
      "winning_transform": "coalesce_null_propagation",
      "key_insight": "Arithmetic with potentially NULL values where NULL should be\n      treated as zero or default."
    },
    "CONSTANT_FOLDING_COLUMN_SIDE": {
      "vector_index": 4,
      "name": "Constant Folding Column Side",
      "description": "Move calculations to constant side of comparisons to enable index\n      usage. PostgreSQL folds constants but won't rearrange expressions.",
      "verified_speedup": "unknown",
      "transforms": [
        "constant_folding_column_side"
      ],
      "winning_transform": "constant_folding_column_side",
      "key_insight": "Arithmetic or function on indexed column in WHERE clause."
    },
    "CORRELATED_AGGREGATE_TO_LATERAL": {
      "vector_index": 5,
      "name": "Correlated Aggregate To Lateral",
      "description": "Rewrite scalar subqueries with aggregations to LATERAL joins, enabling\n      the optimizer to select optimal join strategies (hash, merge) rather\n      than being restricted to nested loop execution.",
      "verified_speedup": "unknown",
      "transforms": [
        "correlated_aggregate_to_lateral"
      ],
      "winning_transform": "correlated_aggregate_to_lateral",
      "key_insight": "When scalar subqueries contain aggregates (COUNT, SUM, AVG, MAX, MIN)\n      that reference outer query columns."
    },
    "CORRELATED_SCALAR_TO_LEFT_JOIN": {
      "vector_index": 6,
      "name": "Correlated Scalar To Left Join",
      "description": "Convert correlated scalar subqueries in SELECT clause to LEFT JOIN.\n      PostgreSQL executes scalar subqueries as nested loops and cannot \n      decorrelate them automatically, preventing optimal join strategies.",
      "verified_speedup": "unknown",
      "transforms": [
        "correlated_scalar_to_left_join"
      ],
      "winning_transform": "correlated_scalar_to_left_join",
      "key_insight": "When a correlated subquery returns a single value and the outer table \n      is large. Look for scalar subqueries in SELECT list referencing outer columns."
    },
    "CORRELATED_SUBQUERY_TO_WINDOW": {
      "vector_index": 7,
      "name": "Correlated Subquery To Window",
      "description": "Rewrite scalar subqueries computing group aggregates to window functions,\n      eliminating correlated execution and enabling single-pass processing.",
      "verified_speedup": "High - single scan vs N scans",
      "transforms": [
        "correlated_subquery_to_window"
      ],
      "winning_transform": "correlated_subquery_to_window",
      "key_insight": "Correlated subquery calculates aggregate for current row's group\n      without changing row count."
    },
    "CORRELATED_WHERE_TO_DERIVED_TABLE": {
      "vector_index": 8,
      "name": "Correlated Where To Derived Table",
      "description": "Convert correlated subqueries in WHERE clause to derived table joins\n      when PostgreSQL fails to decorrelate automatically.",
      "verified_speedup": "unknown",
      "transforms": [
        "correlated_where_to_derived_table"
      ],
      "winning_transform": "correlated_where_to_derived_table",
      "key_insight": "Queries comparing row values against group aggregates. Common pattern\n      for \"above average\" type queries."
    },
    "CTE_INLINE_NOT_MATERIALIZED": {
      "vector_index": 9,
      "name": "Cte Inline Not Materialized",
      "description": "Force CTE inlining with NOT MATERIALIZED to enable predicate pushdown\n      when CTE is referenced multiple times but benefits from different\n      filters in each reference.",
      "verified_speedup": "unknown",
      "transforms": [
        "cte_inline_not_materialized"
      ],
      "winning_transform": "cte_inline_not_materialized",
      "key_insight": "When CTE is referenced multiple times and each reference has different\n      WHERE conditions that could be pushed down."
    },
    "CTE_OPTIMIZATION_FENCE_MATERIALIZED": {
      "vector_index": 10,
      "name": "Cte Optimization Fence Materialized",
      "description": "Use MATERIALIZED to create optimization fence, preventing predicate\n      pushdown and forcing single evaluation of expensive CTE computation.",
      "verified_speedup": "unknown",
      "transforms": [
        "cte_optimization_fence_materialized"
      ],
      "winning_transform": "cte_optimization_fence_materialized",
      "key_insight": "- CTE contains expensive computation that should run once\n      - Need to isolate subquery planning to prevent bad plan choices\n      - Force specific join ordering"
    },
    "DSB_NON_EQUI_JOIN_WINDOW": {
      "vector_index": 11,
      "name": "Dsb Non Equi Join Window",
      "description": "Rewrite non-equi joins with temporal ordering into window function\n      patterns for better estimation.",
      "verified_speedup": "unknown",
      "transforms": [
        "dsb_non_equi_join_window"
      ],
      "winning_transform": "dsb_non_equi_join_window",
      "key_insight": "DSB Query 101, 102 patterns with range/temporal constraints."
    },
    "DSB_PREDICATE_CORRELATION_STATS": {
      "vector_index": 12,
      "name": "Dsb Predicate Correlation Stats",
      "description": "Create extended statistics for DSB's intentionally correlated\n      predicates that defeat independence assumption.",
      "verified_speedup": "unknown",
      "transforms": [
        "dsb_predicate_correlation_stats"
      ],
      "winning_transform": "dsb_predicate_correlation_stats",
      "key_insight": "DSB explicitly introduces cross-table correlations. Create\n      statistics after identifying correlated filter patterns."
    },
    "DSB_SELF_JOIN_DECOMPOSITION": {
      "vector_index": 13,
      "name": "Dsb Self Join Decomposition",
      "description": "Decompose many-to-many self-joins into multiple passes with\n      intermediate materialization for better cardinality estimation.",
      "verified_speedup": "unknown",
      "transforms": [
        "dsb_self_join_decomposition"
      ],
      "winning_transform": "dsb_self_join_decomposition",
      "key_insight": "DSB Query 100 pattern: items frequently sold together."
    },
    "EXISTS_INSTEAD_OF_COUNT": {
      "vector_index": 14,
      "name": "Exists Instead Of Count",
      "description": "Replace COUNT(*) > 0 existence checks with EXISTS for early termination.\n      EXISTS stops after finding first match.",
      "verified_speedup": "30-40x faster in many cases",
      "transforms": [
        "exists_instead_of_count"
      ],
      "winning_transform": "exists_instead_of_count",
      "key_insight": "Checking if any matching rows exist rather than needing exact count."
    },
    "EXISTS_SUBPLAN_TO_SEMI_JOIN": {
      "vector_index": 15,
      "name": "Exists Subplan To Semi Join",
      "description": "Restructure EXISTS subqueries to ensure PostgreSQL recognizes semi-join\n      pattern. Moving correlation condition placement can enable semi-join\n      vs SubPlan execution.",
      "verified_speedup": "unknown",
      "transforms": [
        "exists_subplan_to_semi_join"
      ],
      "winning_transform": "exists_subplan_to_semi_join",
      "key_insight": "When EXPLAIN shows SubPlan for EXISTS instead of Semi Join. Often\n      triggered by ANSI JOIN syntax inside the EXISTS subquery."
    },
    "EXPRESSION_TO_SARGABLE": {
      "vector_index": 16,
      "name": "Expression To Sargable",
      "description": "Transform non-sargable predicates (functions on columns) to sargable\n      form enabling index usage.",
      "verified_speedup": "unknown",
      "transforms": [
        "expression_to_sargable"
      ],
      "winning_transform": "expression_to_sargable",
      "key_insight": "Functions applied to indexed columns preventing index scan."
    },
    "FILTER_INTO_JOIN": {
      "vector_index": 17,
      "name": "Filter Into Join",
      "description": "Push filters to one side of a join",
      "verified_speedup": "unknown",
      "transforms": [
        "filter_into_join"
      ],
      "winning_transform": "filter_into_join",
      "key_insight": "Push selective predicates into the joined table to reduce join input size."
    },
    "FILTER_SUB_QUERY_TO_JOIN": {
      "vector_index": 18,
      "name": "Filter Subquery to Join",
      "description": "Scalar/IN/EXISTS subquery in WHERE rewritten to JOIN",
      "verified_speedup": "unknown",
      "transforms": [
        "filter_sub_query_to_join"
      ],
      "winning_transform": "filter_sub_query_to_join",
      "key_insight": "Rewrite scalar/IN/EXISTS subqueries into joins to enable predicate pushdown and better join planning."
    },
    "GROUPING_SETS_INSTEAD_OF_UNION": {
      "vector_index": 19,
      "name": "Grouping Sets Instead Of Union",
      "description": "Replace multiple GROUP BY queries with UNION ALL using single\n      GROUPING SETS/ROLLUP/CUBE query for multi-level aggregations.",
      "verified_speedup": "unknown",
      "transforms": [
        "grouping_sets_instead_of_union"
      ],
      "winning_transform": "grouping_sets_instead_of_union",
      "key_insight": "Reports requiring multiple aggregation levels (subtotals, grand totals)."
    },
    "IS_NOT_DISTINCT_FROM_NULL_SAFE": {
      "vector_index": 20,
      "name": "Is Not Distinct From Null Safe",
      "description": "Use IS NOT DISTINCT FROM for NULL-safe equality comparisons where\n      NULL should equal NULL.",
      "verified_speedup": "unknown",
      "transforms": [
        "is_not_distinct_from_null_safe"
      ],
      "winning_transform": "is_not_distinct_from_null_safe",
      "key_insight": "Self-joins or comparisons on nullable columns where NULL=NULL\n      should be TRUE."
    },
    "JOIN_ORDER_COLLAPSE_LIMIT": {
      "vector_index": 21,
      "name": "Join Order Collapse Limit",
      "description": "Set join_collapse_limit = 1 to force PostgreSQL to respect explicit\n      JOIN clause ordering instead of reordering for optimization.",
      "verified_speedup": "unknown",
      "transforms": [
        "join_order_collapse_limit"
      ],
      "winning_transform": "join_order_collapse_limit",
      "key_insight": "- Optimizer consistently chooses suboptimal join order\n      - Specific knowledge about data distribution optimizer lacks\n      - Complex queries where planning time is excessive"
    },
    "LATERAL_FORCE_NESTED_LOOP": {
      "vector_index": 22,
      "name": "Lateral Force Nested Loop",
      "description": "Use CROSS JOIN LATERAL to force nested loop execution when you know\n      it's optimal (small outer table, indexed inner lookup).",
      "verified_speedup": "unknown",
      "transforms": [
        "lateral_force_nested_loop"
      ],
      "winning_transform": "lateral_force_nested_loop",
      "key_insight": "When planner incorrectly chooses hash/merge join but nested loop with\n      parameterized index scan would be faster."
    },
    "LIKE_PREFIX_INDEX_USAGE": {
      "vector_index": 23,
      "name": "Like Prefix Index Usage",
      "description": "Ensure LIKE 'prefix%' uses index by creating text_pattern_ops index\n      for non-C locale databases.",
      "verified_speedup": "unknown",
      "transforms": [
        "like_prefix_index_usage"
      ],
      "winning_transform": "like_prefix_index_usage",
      "key_insight": "Prefix searches on text columns in non-C collation databases."
    },
    "LIMITED_COUNT_FOR_THRESHOLD": {
      "vector_index": 24,
      "name": "Limited Count For Threshold",
      "description": "When checking if count exceeds threshold, use LIMIT to avoid\n      counting all rows.",
      "verified_speedup": "unknown",
      "transforms": [
        "limited_count_for_threshold"
      ],
      "winning_transform": "limited_count_for_threshold",
      "key_insight": "Need to know if \"at least N\" rows exist, not exact count."
    },
    "NOT_IN_TO_NOT_EXISTS": {
      "vector_index": 25,
      "name": "Not In To Not Exists",
      "description": "PostgreSQL CANNOT automatically transform NOT IN to anti-join due to\n      different NULL semantics. NOT IN with any NULL in subquery returns\n      no rows, while NOT EXISTS handles NULLs correctly and enables anti-join.",
      "verified_speedup": "High - enables Hash Anti Join vs O(N\u00b2) SubPlan",
      "transforms": [
        "not_in_to_not_exists"
      ],
      "winning_transform": "not_in_to_not_exists",
      "key_insight": "Always prefer NOT EXISTS over NOT IN for exclusion patterns. Critical\n      for correctness when subquery may contain NULLs."
    },
    "OR_TO_UNION_ALL": {
      "vector_index": 26,
      "name": "Or To Union All",
      "description": "Rewrite OR conditions to UNION ALL when OR prevents efficient index\n      usage, especially in JOIN contexts.",
      "verified_speedup": "unknown",
      "transforms": [
        "or_to_union_all"
      ],
      "winning_transform": "or_to_union_all",
      "key_insight": "OR conditions span different columns with separate indexes.\n      Ensure result sets are mutually exclusive for UNION ALL."
    },
    "PARTITION_PRUNING_PREDICATE": {
      "vector_index": 27,
      "name": "Partition Pruning Predicate",
      "description": "Rewrite predicates to enable partition pruning by using direct\n      comparisons on partition key columns.",
      "verified_speedup": "unknown",
      "transforms": [
        "partition_pruning_predicate"
      ],
      "winning_transform": "partition_pruning_predicate",
      "key_insight": "Partitioned tables where pruning isn't occurring due to\n      functions/expressions on partition key."
    },
    "REDUNDANT_JOIN_ELIMINATION": {
      "vector_index": 28,
      "name": "Redundant Join Elimination",
      "description": "Remove unnecessary joins to parent tables when only the foreign key\n      is used from the joined table and the FK is NOT NULL. PostgreSQL\n      does not automatically eliminate these (unlike Oracle/DB2).",
      "verified_speedup": "unknown",
      "transforms": [
        "redundant_join_elimination"
      ],
      "winning_transform": "redundant_join_elimination",
      "key_insight": "When only FK column is selected from joined table and FK has NOT NULL\n      constraint ensuring all rows match."
    },
    "SELF_JOIN_TO_WINDOW": {
      "vector_index": 29,
      "name": "Self Join To Window",
      "description": "Replace self-joins used to access group-level values with window\n      functions, eliminating the join entirely.",
      "verified_speedup": "unknown",
      "transforms": [
        "self_join_to_window"
      ],
      "winning_transform": "self_join_to_window",
      "key_insight": "Self-join retrieves aggregate values or rankings within a group."
    },
    "STAR_SCHEMA_DIMENSION_FILTER_FIRST": {
      "vector_index": 30,
      "name": "Star Schema Dimension Filter First",
      "description": "Restructure star schema queries to filter dimension tables first\n      using optimization barriers, then join filtered results to fact table.",
      "verified_speedup": "unknown",
      "transforms": [
        "star_schema_dimension_filter_first"
      ],
      "winning_transform": "star_schema_dimension_filter_first",
      "key_insight": "Star schema queries with selective dimension filters where optimizer\n      scans fact table first instead of filtering dimensions."
    },
    "SUBQUERY_OFFSET_ZERO_BARRIER": {
      "vector_index": 31,
      "name": "Subquery Offset Zero Barrier",
      "description": "Add OFFSET 0 to subquery to create optimization barrier preventing\n      subquery pull-up, forcing materialization and specific execution order.",
      "verified_speedup": "unknown",
      "transforms": [
        "subquery_offset_zero_barrier"
      ],
      "winning_transform": "subquery_offset_zero_barrier",
      "key_insight": "- Force specific join order without global setting changes\n      - Subquery results should compute before joining\n      - Debug plans by isolating subquery execution"
    },
    "TOP_N_PER_GROUP_DISTINCT_ON": {
      "vector_index": 32,
      "name": "Top N Per Group Distinct On",
      "description": "Use PostgreSQL's DISTINCT ON for \"top-1-per-group\" instead of\n      ROW_NUMBER() window function.  More concise and often faster.",
      "verified_speedup": "unknown",
      "transforms": [
        "top_n_per_group_distinct_on"
      ],
      "winning_transform": "top_n_per_group_distinct_on",
      "key_insight": "Retrieving exactly one row per group based on ordering.\n      PostgreSQL-specific extension."
    },
    "TOP_N_PER_GROUP_ROW_NUMBER": {
      "vector_index": 33,
      "name": "Top N Per Group Row Number",
      "description": "Use ROW_NUMBER() window function instead of correlated subquery\n      COUNT for top-N-per-group patterns.",
      "verified_speedup": "unknown",
      "transforms": [
        "top_n_per_group_row_number"
      ],
      "winning_transform": "top_n_per_group_row_number",
      "key_insight": "Retrieving multiple rows per group based on ranking."
    },
    "TOP_N_PER_GROUP_TO_LATERAL": {
      "vector_index": 34,
      "name": "Top N Per Group To Lateral",
      "description": "Convert correlated subqueries for \"top N per group\" to LATERAL joins\n      with LIMIT, enabling index-only scans per group instead of window\n      functions over entire dataset.",
      "verified_speedup": "unknown",
      "transforms": [
        "top_n_per_group_to_lateral"
      ],
      "winning_transform": "top_n_per_group_to_lateral",
      "key_insight": "Finding top N rows per group where an appropriate index exists on\n      (group_key, sort_column). Especially effective when N is small."
    },
    "UNION_TO_UNION_ALL": {
      "vector_index": 35,
      "name": "Union To Union All",
      "description": "Replace UNION with UNION ALL when duplicate elimination is unnecessary,\n      avoiding expensive sort/hash operations.",
      "verified_speedup": "unknown",
      "transforms": [
        "union_to_union_all"
      ],
      "winning_transform": "union_to_union_all",
      "key_insight": "Result sets are provably disjoint or duplicates are acceptable."
    },
    "WINDOW_SORT_ALIGNMENT": {
      "vector_index": 36,
      "name": "Window Sort Alignment",
      "description": "Align window function ORDER BY clauses to minimize sorts when\n      multiple window functions are used in same query.",
      "verified_speedup": "unknown",
      "transforms": [
        "window_sort_alignment"
      ],
      "winning_transform": "window_sort_alignment",
      "key_insight": "Queries with multiple window functions using different orderings.\n      Group windows with same sort together."
    }
  },
  "index_stats": {
    "total_vectors": 37,
    "dimensions": 90,
    "index_type": "IndexFlatL2 (cosine similarity via normalization)",
    "normalized_sql": true,
    "zscore_normalized": true,
    "feature_stats_file": "feature_stats.json",
    "dialect": "postgres",
    "normalization": "literals replaced with $N placeholders, identifiers lowercased"
  }
}