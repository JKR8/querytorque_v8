{
  "query_metadata": {
    "composite_decorrelate_union": {
      "vector_index": 0,
      "name": "Decorrelate EXISTS + OR-to-UNION Composite",
      "description": "Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT customer CTEs with a shared date filter, and replace OR(EXISTS a, EXISTS b) with UNION of key sets",
      "verified_speedup": "2.42x",
      "transforms": [
        "decorrelate + date_cte_isolate + or_to_union"
      ],
      "winning_transform": "decorrelate + date_cte_isolate + or_to_union",
      "key_insight": "Three-part composite: (1) Extract shared date filter into CTE (all 3 EXISTS use same d_year/d_qoy). (2) Decorrelate each EXISTS into SELECT DISTINCT customer_sk joined with filtered_dates. (3) Replace OR(EXISTS web, EXISTS catalog) with UNION of customer key CTEs. The EXISTS->JOIN conversion works because the main query only needs to know IF a customer exists, which DISTINCT + JOIN achieves. The UNION replaces OR logic at the set level.",
      "engine": "duckdb",
      "type": "gold"
    },
    "date_cte_isolate": {
      "vector_index": 1,
      "name": "Date CTE Isolation",
      "description": "Extract date filtering into a separate CTE to enable predicate pushdown and reduce scans",
      "verified_speedup": "4.00x",
      "transforms": [
        "date_cte_isolate + category_avg"
      ],
      "winning_transform": "date_cte_isolate + category_avg",
      "key_insight": "Extract date month_seq subquery into CTE. Extract category average into separate CTE with GROUP BY. Join instead of correlated subquery. This allows each CTE to be scanned once.",
      "engine": "duckdb",
      "type": "gold"
    },
    "decorrelate": {
      "vector_index": 2,
      "name": "Decorrelate Subquery",
      "description": "Convert correlated subquery to separate CTE with GROUP BY, then JOIN",
      "verified_speedup": "2.92x",
      "transforms": [
        "decorrelate + pushdown"
      ],
      "winning_transform": "decorrelate + pushdown",
      "key_insight": "Push s_state='SD' filter EARLY into first CTE. Compute average as SEPARATE CTE with GROUP BY (NOT window function). Join on average instead of correlated subquery.",
      "engine": "duckdb",
      "type": "gold"
    },
    "deferred_window_aggregation": {
      "vector_index": 3,
      "name": "Deferred Window Aggregation",
      "description": "When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joined with FULL OUTER JOIN followed by another WINDOW pass for NULL carry-forward: defer the WINDOW out of the CTEs, join daily totals, then compute cumulative sums once on the joined result. SUM() OVER() naturally skips NULLs, eliminating the need for a separate MAX() carry-forward window.",
      "verified_speedup": "1.36x",
      "transforms": [
        "consolidate window passes"
      ],
      "winning_transform": "consolidate window passes",
      "key_insight": "When CTEs compute GROUP BY + WINDOW (running sum), then FULL OUTER JOIN introduces NULLs requiring a MAX() OVER() carry-forward pass: remove WINDOW from the CTEs (keep only GROUP BY for daily totals), join the daily totals, then compute SUM() OVER() once on the joined result. SUM() naturally skips NULLs, so the carry-forward is free. Reduces 3 WINDOW passes (2 in CTEs + 1 MAX carry-forward) to 1.",
      "engine": "duckdb",
      "type": "gold"
    },
    "dimension_cte_isolate": {
      "vector_index": 4,
      "name": "Dimension CTE Isolation",
      "description": "Pre-filter ALL dimension tables into CTEs before joining with fact table, not just date_dim",
      "verified_speedup": "1.93x",
      "transforms": [
        "dimension cte isolation"
      ],
      "winning_transform": "dimension cte isolation",
      "key_insight": "Pre-filter EACH dimension table into its own CTE returning only the surrogate key. This reduces the cardinality of subsequent joins. Works best when dimension filters are highly selective.",
      "engine": "duckdb",
      "type": "gold"
    },
    "early_filter": {
      "vector_index": 5,
      "name": "Early Dimension Filter",
      "description": "Filter dimension tables FIRST, then join to fact tables to reduce expensive joins",
      "verified_speedup": "4.00x",
      "transforms": [
        "early_filter"
      ],
      "winning_transform": "early_filter",
      "key_insight": "Filter dimension table (reason) FIRST, then join to fact. Reduces returns to only 'duplicate purchase' before expensive store_sales join.",
      "engine": "duckdb",
      "type": "gold"
    },
    "intersect_to_exists": {
      "vector_index": 6,
      "name": "INTERSECT to EXISTS",
      "description": "Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join planning",
      "verified_speedup": "1.83x",
      "transforms": [
        "intersect_to_exists"
      ],
      "winning_transform": "intersect_to_exists",
      "key_insight": "INTERSECT forces materialization and sorting of all three subqueries before computing set intersection. Converting to EXISTS allows the optimizer to use semi-join strategies and stop early when a match is found. Each EXISTS can use indexes on the join columns.",
      "engine": "duckdb",
      "type": "gold"
    },
    "materialize_cte": {
      "vector_index": 7,
      "name": "Materialize Repeated Subquery",
      "description": "Extract repeated subquery patterns into a CTE to avoid recomputation",
      "verified_speedup": "1.37x",
      "transforms": [
        "materialize_cte"
      ],
      "winning_transform": "materialize_cte",
      "key_insight": "Extract the EXISTS subquery into a CTE that finds multi-warehouse orders ONCE. Extract returned orders into another CTE. Join instead of nested EXISTS checks.",
      "engine": "duckdb",
      "type": "gold"
    },
    "multi_date_range_cte": {
      "vector_index": 8,
      "name": "Multi Date Range CTE",
      "description": "When query uses multiple date_dim aliases with different filters (d1, d2, d3), create separate CTEs for each date range and pre-join with fact tables",
      "verified_speedup": "2.35x",
      "transforms": [
        "multi date range cte"
      ],
      "winning_transform": "multi date range cte",
      "key_insight": "When a query references date_dim multiple times with different filters (d1, d2, d3 pattern), create separate CTEs for each date range. Then pre-join each date CTE with its corresponding fact table. This filters the fact tables early before the expensive multi-way join.",
      "engine": "duckdb",
      "type": "gold"
    },
    "multi_dimension_prefetch": {
      "vector_index": 9,
      "name": "Multi Dimension Prefetch",
      "description": "Pre-filter multiple dimension tables (date + store) into separate CTEs before joining with fact table",
      "verified_speedup": "2.71x",
      "transforms": [
        "multi dimension prefetch"
      ],
      "winning_transform": "multi dimension prefetch",
      "key_insight": "Pre-filter BOTH date_dim AND store into separate CTEs. Include only the columns needed for the join and grouping. The optimizer can then use these smaller CTEs efficiently when joining with the fact table.",
      "engine": "duckdb",
      "type": "gold"
    },
    "or_to_union": {
      "vector_index": 10,
      "name": "OR to UNION ALL",
      "description": "Split OR conditions on different columns into UNION ALL branches for better index usage",
      "verified_speedup": "3.17x",
      "transforms": [
        "or_to_union + early_filter"
      ],
      "winning_transform": "or_to_union + early_filter",
      "key_insight": "Each OR branch becomes a separate query with focused predicates. Date filter is extracted as CTE and joined into each branch.",
      "engine": "duckdb",
      "type": "gold"
    },
    "prefetch_fact_join": {
      "vector_index": 11,
      "name": "Prefetch Fact Join",
      "description": "Pre-filter dimension table into CTE, then pre-join with fact table in second CTE before joining other dimensions",
      "verified_speedup": "3.77x",
      "transforms": [
        "prefetch fact join"
      ],
      "winning_transform": "prefetch fact join",
      "key_insight": "First CTE filters the dimension (date_dim). Second CTE pre-joins this with the fact table (store_sales). This creates a smaller intermediate result before joining with other dimension tables. The pre-join materializes the filtered fact rows, making subsequent joins faster.",
      "engine": "duckdb",
      "type": "gold"
    },
    "pushdown": {
      "vector_index": 12,
      "name": "Filter Pushdown",
      "description": "Push filters from outer query into CTEs/subqueries to reduce intermediate result sizes",
      "verified_speedup": "2.11x",
      "transforms": [
        "pushdown"
      ],
      "winning_transform": "pushdown",
      "key_insight": "Extract repeated quantity-range subqueries into CTEs. Each CTE computes count, avg_ext_price, avg_net_profit in ONE pass instead of scanning store_sales 15+ times.",
      "engine": "duckdb",
      "type": "gold"
    },
    "regression_q16_semantic_rewrite": {
      "vector_index": 13,
      "name": "Q16 regression: semantic_rewrite (0.14x)",
      "description": "Never materialize GROUP BY aggregates with HAVING clauses on fact tables before filtering those fact tables through dimension joins.",
      "verified_speedup": "0.14x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "Never materialize GROUP BY aggregates with HAVING clauses on fact tables before filtering those fact tables through dimension joins.",
      "engine": "duckdb",
      "type": "regression"
    },
    "regression_q1_decorrelate": {
      "vector_index": 14,
      "name": "Q1 regression: decorrelate (0.71x)",
      "description": "Do not pre-aggregate GROUP BY results into CTEs when the query uses them in a correlated comparison (e.g., customer return > 1.2x store average). The optimizer can compute aggregates incrementally with filter pushdown; materialization loses this.",
      "verified_speedup": "0.71x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "Do not pre-aggregate GROUP BY results into CTEs when the query uses them in a correlated comparison (e.g., customer return > 1.2x store average). The optimizer can compute aggregates incrementally with filter pushdown; materialization loses this.",
      "engine": "duckdb",
      "type": "regression"
    },
    "regression_q25_date_cte_isolate": {
      "vector_index": 15,
      "name": "Q25 regression: date_cte_isolate (0.5x)",
      "description": "Do not pre-filter and materialize fact tables when the query has 3+ fact table joins. The optimizer needs freedom to reorder multi-way fact joins and push filters across them.",
      "verified_speedup": "0.5x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "Do not pre-filter and materialize fact tables when the query has 3+ fact table joins. The optimizer needs freedom to reorder multi-way fact joins and push filters across them.",
      "engine": "duckdb",
      "type": "regression"
    },
    "regression_q31_pushdown": {
      "vector_index": 16,
      "name": "Q31 regression: pushdown (0.49x)",
      "description": "When creating filtered versions of existing CTEs, always REMOVE the original unfiltered CTEs. Keeping both causes redundant materialization and 1000x+ cardinality misestimates on self-joins.",
      "verified_speedup": "0.49x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "When creating filtered versions of existing CTEs, always REMOVE the original unfiltered CTEs. Keeping both causes redundant materialization and 1000x+ cardinality misestimates on self-joins.",
      "engine": "duckdb",
      "type": "regression"
    },
    "regression_q51_date_cte_isolate": {
      "vector_index": 17,
      "name": "Q51 regression: date_cte_isolate (0.87x)",
      "description": "Do not materialize running/cumulative window aggregates into CTEs before joins that filter based on those aggregates. The optimizer can co-optimize window evaluation and join filtering together.",
      "verified_speedup": "0.87x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "Do not materialize running/cumulative window aggregates into CTEs before joins that filter based on those aggregates. The optimizer can co-optimize window evaluation and join filtering together.",
      "engine": "duckdb",
      "type": "regression"
    },
    "regression_q67_date_cte_isolate": {
      "vector_index": 18,
      "name": "Q67 regression: date_cte_isolate (0.85x)",
      "description": "Do not materialize dimension filters into CTEs before complex aggregations (ROLLUP, CUBE, GROUPING SETS) with window functions. The optimizer needs to push aggregation through joins; CTEs create materialization barriers.",
      "verified_speedup": "0.85x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "Do not materialize dimension filters into CTEs before complex aggregations (ROLLUP, CUBE, GROUPING SETS) with window functions. The optimizer needs to push aggregation through joins; CTEs create materialization barriers.",
      "engine": "duckdb",
      "type": "regression"
    },
    "regression_q74_pushdown": {
      "vector_index": 19,
      "name": "Q74 regression: pushdown (0.68x)",
      "description": "When splitting a UNION CTE by year, you MUST remove or replace the original UNION CTE. Keeping both the split and original versions causes redundant materialization and extreme cardinality misestimates.",
      "verified_speedup": "0.68x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "When splitting a UNION CTE by year, you MUST remove or replace the original UNION CTE. Keeping both the split and original versions causes redundant materialization and extreme cardinality misestimates.",
      "engine": "duckdb",
      "type": "regression"
    },
    "regression_q90_materialize_cte": {
      "vector_index": 20,
      "name": "Q90 regression: materialize_cte (0.59x)",
      "description": "Never convert OR conditions on the SAME column (e.g., range conditions on t_hour) into UNION ALL. The optimizer already handles same-column ORs as a single scan. UNION ALL only helps when branches access fundamentally different tables or columns.",
      "verified_speedup": "0.59x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "Never convert OR conditions on the SAME column (e.g., range conditions on t_hour) into UNION ALL. The optimizer already handles same-column ORs as a single scan. UNION ALL only helps when branches access fundamentally different tables or columns.",
      "engine": "duckdb",
      "type": "regression"
    },
    "regression_q93_decorrelate": {
      "vector_index": 21,
      "name": "Q93 regression: decorrelate (0.34x)",
      "description": "Do not decorrelate correlated LEFT JOINs that the optimizer already executes as semi-joins. Materializing the correlated subquery into a CTE forces redundant scans.",
      "verified_speedup": "0.34x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "Do not decorrelate correlated LEFT JOINs that the optimizer already executes as semi-joins. Materializing the correlated subquery into a CTE forces redundant scans.",
      "engine": "duckdb",
      "type": "regression"
    },
    "regression_q95_semantic_rewrite": {
      "vector_index": 22,
      "name": "Q95 regression: semantic_rewrite (0.54x)",
      "description": "Do not decompose tightly-correlated EXISTS/NOT EXISTS clause pairs into independent CTEs. Their cardinality estimates depend on each other; materializing them independently causes severe join cost misestimates.",
      "verified_speedup": "0.54x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "Do not decompose tightly-correlated EXISTS/NOT EXISTS clause pairs into independent CTEs. Their cardinality estimates depend on each other; materializing them independently causes severe join cost misestimates.",
      "engine": "duckdb",
      "type": "regression"
    },
    "shared_dimension_multi_channel": {
      "vector_index": 23,
      "name": "Shared Dimension CTEs Across Multi-Channel Queries",
      "description": "Extract shared dimension filters (date, item, promotion) into CTEs when multiple channel CTEs (store/catalog/web) apply identical filters independently",
      "verified_speedup": "1.30x",
      "transforms": [
        "dimension_cte_isolate + prefetch_fact_join"
      ],
      "winning_transform": "dimension_cte_isolate + prefetch_fact_join",
      "key_insight": "When multiple CTEs (store/catalog/web channels) apply identical dimension filters (same date range, same item price threshold, same promotion filter), extract those filters into shared dimension CTEs and pre-join them with each fact table. This eliminates redundant dimension scans. Note: only pre-join channels where the join is straightforward. If one channel (e.g., catalog) has a more complex join structure, leave it unchanged.",
      "engine": "duckdb",
      "type": "gold"
    },
    "single_pass_aggregation": {
      "vector_index": 24,
      "name": "Single Pass Aggregation",
      "description": "Consolidate multiple subqueries scanning the same table into a single CTE with conditional aggregates",
      "verified_speedup": "4.47x",
      "transforms": [
        "consolidate repeated scans"
      ],
      "winning_transform": "consolidate repeated scans",
      "key_insight": "Multiple scalar subqueries with different filter conditions on the same table can be consolidated into a single CTE using conditional CASE expressions inside aggregates. Reduces N scans to 1 scan.",
      "engine": "duckdb",
      "type": "gold"
    },
    "union_cte_split": {
      "vector_index": 25,
      "name": "Union CTE Split/Specialization",
      "description": "Split a generic UNION ALL CTE into specialized CTEs when the main query filters by year or discriminator - eliminates redundant scans",
      "verified_speedup": "1.36x",
      "transforms": [
        "union_cte_split: cte with union all is scanned twice with different year filters - split into year-specific ctes"
      ],
      "winning_transform": "union_cte_split: cte with union all is scanned twice with different year filters - split into year-specific ctes",
      "key_insight": "The original query scans the generic wswscs CTE twice and joins to date_dim twice to filter by year. By pushing year filters INTO the CTE definition, we create specialized CTEs (wswscs_1998, wswscs_1999) that filter during aggregation instead of after. This eliminates redundant date_dim lookups and reduces the rows aggregated.",
      "engine": "duckdb",
      "type": "gold"
    },
    "pg_date_cte_explicit_join": {
      "vector_index": 26,
      "name": "Date CTE with Explicit JOIN Conversion (PostgreSQL)",
      "description": "Isolate a selective date_dim filter into a CTE AND convert all comma-separated joins to explicit JOIN syntax. The combination is key on PostgreSQL - the CTE alone can hurt, but CTE + explicit JOINs together enable better hash join planning with a tiny probe table.",
      "verified_speedup": "2.28x",
      "transforms": [
        "date_cte_explicit_join"
      ],
      "winning_transform": "date_cte_explicit_join",
      "key_insight": "date_dim with d_month_seq BETWEEN x AND x+23 selects ~730 rows from 73K. Materializing into a CTE creates a tiny hash table that catalog_sales probes against, replacing a large merge/nested-loop join. CRITICAL: Must also convert comma joins to explicit JOIN syntax for PostgreSQL to explore optimal join ordering. The CTE alone without explicit JOINs does NOT help on PostgreSQL.",
      "engine": "postgres",
      "type": "gold"
    },
    "pg_dimension_prefetch_star": {
      "vector_index": 27,
      "name": "Dimension Pre-filter with Explicit JOINs (PostgreSQL)",
      "description": "On multi-channel UNION queries with comma-separated implicit joins, pre-filter dimension tables (date, item, promotion) into CTEs and convert to explicit JOIN syntax. PostgreSQL's optimizer gets better cardinality estimates and join ordering from explicit JOINs with pre-materialized small dimension results.",
      "verified_speedup": "3.32x",
      "transforms": [
        "dimension_prefetch_star"
      ],
      "winning_transform": "dimension_prefetch_star",
      "key_insight": "Pre-filtering dimension tables (date: 30 days from 73K, item: 2 categories, promotion: 5 boolean filters) into CTEs creates tiny hash tables. Converting comma joins to explicit INNER JOIN gives PostgreSQL's optimizer better join-order freedom and cardinality estimates. Even partial transformation (one UNION branch) helps when that branch dominates runtime.",
      "engine": "postgres",
      "type": "gold"
    },
    "early_filter_decorrelate": {
      "vector_index": 28,
      "name": "Early Filter + Decorrelate",
      "description": "",
      "verified_speedup": "1.13x",
      "transforms": [],
      "winning_transform": "",
      "key_insight": "",
      "engine": "postgres",
      "type": "gold"
    },
    "pg_materialized_dimension_fact_prefilter": {
      "vector_index": 29,
      "name": "MATERIALIZED Dimension + Fact Pre-filter (PostgreSQL)",
      "description": "Pre-filter ALL dimension tables AND the fact table into MATERIALIZED CTEs, then join with explicit JOIN syntax. On queries with expensive non-equi joins (inventory quantity < sales quantity, week_seq correlation), reducing both dimension AND fact table sizes before the join dramatically cuts the search space. The MATERIALIZED keyword on PG12+ forces early execution of each CTE.",
      "verified_speedup": "2.68x",
      "transforms": [
        "materialized_dimension_fact_prefilter"
      ],
      "winning_transform": "materialized_dimension_fact_prefilter",
      "key_insight": "When a query has expensive non-equi joins (inv_quantity < cs_quantity, d_week_seq correlation across 3 date_dim instances), reducing BOTH dimension AND fact table sizes before the join dramatically shrinks the search space. MATERIALIZED CTEs on PG12+ force early execution. The fact table CTE (cs_wholesale_cost BETWEEN x AND y) removes ~70% of catalog_sales rows before hitting the inventory join. Combined with tiny dimension CTEs (date: ~365 rows from 73K, item: 3 categories, cd/hd: single-value filters), the optimizer gets much smaller inputs for the expensive joins.",
      "engine": "postgres",
      "type": "gold"
    },
    "pg_self_join_decomposition": {
      "vector_index": 30,
      "name": "Self-Join Decomposition (PostgreSQL)",
      "description": "Eliminate duplicate fact table scans in self-join patterns by computing the aggregation ONCE in a CTE and deriving both per-item and per-store averages from the same materialized result. PostgreSQL materializes CTEs by default, making this extremely effective.",
      "verified_speedup": "3.93x",
      "transforms": [
        "self_join_decomposition"
      ],
      "winning_transform": "self_join_decomposition",
      "key_insight": "The original scans store_sales+date_dim TWICE with identical predicates (sa/sc subqueries). On PostgreSQL, CTE materialization computes the fact table aggregation ONCE and reuses it for both per-item revenue and per-store averages. Combined with dimension pre-filtering (store, item), this eliminates the dominant I/O cost.",
      "engine": "postgres",
      "type": "gold"
    },
    "AGGREGATE_PULL_UP_CONSTANTS": {
      "vector_index": 68,
      "name": "Aggregate Pull Up Constants",
      "description": "Pull up constant GROUP BY keys (SF=100 cited)",
      "verified_speedup": "unknown",
      "transforms": [
        "aggregate_pull_up_constants"
      ],
      "winning_transform": "aggregate_pull_up_constants",
      "key_insight": "When a GROUP BY key is constant, avoid unnecessary grouping work or move constant filters earlier.",
      "engine": "seed",
      "type": "gold"
    },
    "AGGREGATE_PUSH_BELOW_JOIN": {
      "vector_index": 69,
      "name": "Aggregate Push Below Join",
      "description": "Push aggregation below join when only aggregated values are needed\n      from one side, reducing join cardinality.",
      "verified_speedup": "unknown",
      "transforms": [
        "aggregate_push_below_join"
      ],
      "winning_transform": "aggregate_push_below_join",
      "key_insight": "Join followed by aggregation where one side contributes only to\n      aggregate, not to grouping.",
      "engine": "seed",
      "type": "gold"
    },
    "ANTI_JOIN_LEFT_JOIN_IS_NULL": {
      "vector_index": 70,
      "name": "Anti Join Left Join Is Null",
      "description": "Convert NOT EXISTS to LEFT JOIN with IS NULL check when the optimizer\n      produces better plans for the join-based pattern.",
      "verified_speedup": "unknown",
      "transforms": [
        "anti_join_left_join_is_null"
      ],
      "winning_transform": "anti_join_left_join_is_null",
      "key_insight": "When NOT EXISTS produces SubPlan instead of Anti Join. Some query\n      structures work better with explicit LEFT JOIN pattern.",
      "engine": "seed",
      "type": "gold"
    },
    "COALESCE_NULL_PROPAGATION": {
      "vector_index": 71,
      "name": "Coalesce Null Propagation",
      "description": "Use COALESCE to provide default values and prevent NULL propagation\n      in calculations.",
      "verified_speedup": "unknown",
      "transforms": [
        "coalesce_null_propagation"
      ],
      "winning_transform": "coalesce_null_propagation",
      "key_insight": "Arithmetic with potentially NULL values where NULL should be\n      treated as zero or default.",
      "engine": "seed",
      "type": "gold"
    },
    "CONSTANT_FOLDING_COLUMN_SIDE": {
      "vector_index": 72,
      "name": "Constant Folding Column Side",
      "description": "Move calculations to constant side of comparisons to enable index\n      usage. PostgreSQL folds constants but won't rearrange expressions.",
      "verified_speedup": "unknown",
      "transforms": [
        "constant_folding_column_side"
      ],
      "winning_transform": "constant_folding_column_side",
      "key_insight": "Arithmetic or function on indexed column in WHERE clause.",
      "engine": "seed",
      "type": "gold"
    },
    "CORRELATED_AGGREGATE_TO_LATERAL": {
      "vector_index": 73,
      "name": "Correlated Aggregate To Lateral",
      "description": "Rewrite scalar subqueries with aggregations to LATERAL joins, enabling\n      the optimizer to select optimal join strategies (hash, merge) rather\n      than being restricted to nested loop execution.",
      "verified_speedup": "unknown",
      "transforms": [
        "correlated_aggregate_to_lateral"
      ],
      "winning_transform": "correlated_aggregate_to_lateral",
      "key_insight": "When scalar subqueries contain aggregates (COUNT, SUM, AVG, MAX, MIN)\n      that reference outer query columns.",
      "engine": "seed",
      "type": "gold"
    },
    "CORRELATED_SCALAR_TO_LEFT_JOIN": {
      "vector_index": 74,
      "name": "Correlated Scalar To Left Join",
      "description": "Convert correlated scalar subqueries in SELECT clause to LEFT JOIN.\n      PostgreSQL executes scalar subqueries as nested loops and cannot \n      decorrelate them automatically, preventing optimal join strategies.",
      "verified_speedup": "unknown",
      "transforms": [
        "correlated_scalar_to_left_join"
      ],
      "winning_transform": "correlated_scalar_to_left_join",
      "key_insight": "When a correlated subquery returns a single value and the outer table \n      is large. Look for scalar subqueries in SELECT list referencing outer columns.",
      "engine": "seed",
      "type": "gold"
    },
    "CORRELATED_SUBQUERY_TO_WINDOW": {
      "vector_index": 75,
      "name": "Correlated Subquery To Window",
      "description": "Rewrite scalar subqueries computing group aggregates to window functions,\n      eliminating correlated execution and enabling single-pass processing.",
      "verified_speedup": "High - single scan vs N scans",
      "transforms": [
        "correlated_subquery_to_window"
      ],
      "winning_transform": "correlated_subquery_to_window",
      "key_insight": "Correlated subquery calculates aggregate for current row's group\n      without changing row count.",
      "engine": "seed",
      "type": "gold"
    },
    "CORRELATED_WHERE_TO_DERIVED_TABLE": {
      "vector_index": 76,
      "name": "Correlated Where To Derived Table",
      "description": "Convert correlated subqueries in WHERE clause to derived table joins\n      when PostgreSQL fails to decorrelate automatically.",
      "verified_speedup": "unknown",
      "transforms": [
        "correlated_where_to_derived_table"
      ],
      "winning_transform": "correlated_where_to_derived_table",
      "key_insight": "Queries comparing row values against group aggregates. Common pattern\n      for \"above average\" type queries.",
      "engine": "seed",
      "type": "gold"
    },
    "CTE_INLINE_NOT_MATERIALIZED": {
      "vector_index": 77,
      "name": "Cte Inline Not Materialized",
      "description": "Force CTE inlining with NOT MATERIALIZED to enable predicate pushdown\n      when CTE is referenced multiple times but benefits from different\n      filters in each reference.",
      "verified_speedup": "unknown",
      "transforms": [
        "cte_inline_not_materialized"
      ],
      "winning_transform": "cte_inline_not_materialized",
      "key_insight": "When CTE is referenced multiple times and each reference has different\n      WHERE conditions that could be pushed down.",
      "engine": "seed",
      "type": "gold"
    },
    "CTE_OPTIMIZATION_FENCE_MATERIALIZED": {
      "vector_index": 78,
      "name": "Cte Optimization Fence Materialized",
      "description": "Use MATERIALIZED to create optimization fence, preventing predicate\n      pushdown and forcing single evaluation of expensive CTE computation.",
      "verified_speedup": "unknown",
      "transforms": [
        "cte_optimization_fence_materialized"
      ],
      "winning_transform": "cte_optimization_fence_materialized",
      "key_insight": "- CTE contains expensive computation that should run once\n      - Need to isolate subquery planning to prevent bad plan choices\n      - Force specific join ordering",
      "engine": "seed",
      "type": "gold"
    },
    "DSB_NON_EQUI_JOIN_WINDOW": {
      "vector_index": 79,
      "name": "Dsb Non Equi Join Window",
      "description": "Rewrite non-equi joins with temporal ordering into window function\n      patterns for better estimation.",
      "verified_speedup": "unknown",
      "transforms": [
        "dsb_non_equi_join_window"
      ],
      "winning_transform": "dsb_non_equi_join_window",
      "key_insight": "DSB Query 101, 102 patterns with range/temporal constraints.",
      "engine": "seed",
      "type": "gold"
    },
    "DSB_PREDICATE_CORRELATION_STATS": {
      "vector_index": 80,
      "name": "Dsb Predicate Correlation Stats",
      "description": "Create extended statistics for DSB's intentionally correlated\n      predicates that defeat independence assumption.",
      "verified_speedup": "unknown",
      "transforms": [
        "dsb_predicate_correlation_stats"
      ],
      "winning_transform": "dsb_predicate_correlation_stats",
      "key_insight": "DSB explicitly introduces cross-table correlations. Create\n      statistics after identifying correlated filter patterns.",
      "engine": "seed",
      "type": "gold"
    },
    "DSB_SELF_JOIN_DECOMPOSITION": {
      "vector_index": 81,
      "name": "Dsb Self Join Decomposition",
      "description": "Decompose many-to-many self-joins into multiple passes with\n      intermediate materialization for better cardinality estimation.",
      "verified_speedup": "unknown",
      "transforms": [
        "dsb_self_join_decomposition"
      ],
      "winning_transform": "dsb_self_join_decomposition",
      "key_insight": "DSB Query 100 pattern: items frequently sold together.",
      "engine": "seed",
      "type": "gold"
    },
    "EXISTS_INSTEAD_OF_COUNT": {
      "vector_index": 82,
      "name": "Exists Instead Of Count",
      "description": "Replace COUNT(*) > 0 existence checks with EXISTS for early termination.\n      EXISTS stops after finding first match.",
      "verified_speedup": "30-40x faster in many cases",
      "transforms": [
        "exists_instead_of_count"
      ],
      "winning_transform": "exists_instead_of_count",
      "key_insight": "Checking if any matching rows exist rather than needing exact count.",
      "engine": "seed",
      "type": "gold"
    },
    "EXISTS_SUBPLAN_TO_SEMI_JOIN": {
      "vector_index": 83,
      "name": "Exists Subplan To Semi Join",
      "description": "Restructure EXISTS subqueries to ensure PostgreSQL recognizes semi-join\n      pattern. Moving correlation condition placement can enable semi-join\n      vs SubPlan execution.",
      "verified_speedup": "unknown",
      "transforms": [
        "exists_subplan_to_semi_join"
      ],
      "winning_transform": "exists_subplan_to_semi_join",
      "key_insight": "When EXPLAIN shows SubPlan for EXISTS instead of Semi Join. Often\n      triggered by ANSI JOIN syntax inside the EXISTS subquery.",
      "engine": "seed",
      "type": "gold"
    },
    "EXPRESSION_TO_SARGABLE": {
      "vector_index": 84,
      "name": "Expression To Sargable",
      "description": "Transform non-sargable predicates (functions on columns) to sargable\n      form enabling index usage.",
      "verified_speedup": "unknown",
      "transforms": [
        "expression_to_sargable"
      ],
      "winning_transform": "expression_to_sargable",
      "key_insight": "Functions applied to indexed columns preventing index scan.",
      "engine": "seed",
      "type": "gold"
    },
    "FILTER_INTO_JOIN": {
      "vector_index": 85,
      "name": "Filter Into Join",
      "description": "Push filters to one side of a join",
      "verified_speedup": "unknown",
      "transforms": [
        "filter_into_join"
      ],
      "winning_transform": "filter_into_join",
      "key_insight": "Push selective predicates into the joined table to reduce join input size.",
      "engine": "seed",
      "type": "gold"
    },
    "FILTER_SUB_QUERY_TO_JOIN": {
      "vector_index": 86,
      "name": "Filter Subquery to Join",
      "description": "Scalar/IN/EXISTS subquery in WHERE rewritten to JOIN",
      "verified_speedup": "unknown",
      "transforms": [
        "filter_sub_query_to_join"
      ],
      "winning_transform": "filter_sub_query_to_join",
      "key_insight": "Rewrite scalar/IN/EXISTS subqueries into joins to enable predicate pushdown and better join planning.",
      "engine": "seed",
      "type": "gold"
    },
    "GROUPING_SETS_INSTEAD_OF_UNION": {
      "vector_index": 87,
      "name": "Grouping Sets Instead Of Union",
      "description": "Replace multiple GROUP BY queries with UNION ALL using single\n      GROUPING SETS/ROLLUP/CUBE query for multi-level aggregations.",
      "verified_speedup": "unknown",
      "transforms": [
        "grouping_sets_instead_of_union"
      ],
      "winning_transform": "grouping_sets_instead_of_union",
      "key_insight": "Reports requiring multiple aggregation levels (subtotals, grand totals).",
      "engine": "seed",
      "type": "gold"
    },
    "IS_NOT_DISTINCT_FROM_NULL_SAFE": {
      "vector_index": 88,
      "name": "Is Not Distinct From Null Safe",
      "description": "Use IS NOT DISTINCT FROM for NULL-safe equality comparisons where\n      NULL should equal NULL.",
      "verified_speedup": "unknown",
      "transforms": [
        "is_not_distinct_from_null_safe"
      ],
      "winning_transform": "is_not_distinct_from_null_safe",
      "key_insight": "Self-joins or comparisons on nullable columns where NULL=NULL\n      should be TRUE.",
      "engine": "seed",
      "type": "gold"
    },
    "JOIN_ORDER_COLLAPSE_LIMIT": {
      "vector_index": 89,
      "name": "Join Order Collapse Limit",
      "description": "Set join_collapse_limit = 1 to force PostgreSQL to respect explicit\n      JOIN clause ordering instead of reordering for optimization.",
      "verified_speedup": "unknown",
      "transforms": [
        "join_order_collapse_limit"
      ],
      "winning_transform": "join_order_collapse_limit",
      "key_insight": "- Optimizer consistently chooses suboptimal join order\n      - Specific knowledge about data distribution optimizer lacks\n      - Complex queries where planning time is excessive",
      "engine": "seed",
      "type": "gold"
    },
    "LATERAL_FORCE_NESTED_LOOP": {
      "vector_index": 90,
      "name": "Lateral Force Nested Loop",
      "description": "Use CROSS JOIN LATERAL to force nested loop execution when you know\n      it's optimal (small outer table, indexed inner lookup).",
      "verified_speedup": "unknown",
      "transforms": [
        "lateral_force_nested_loop"
      ],
      "winning_transform": "lateral_force_nested_loop",
      "key_insight": "When planner incorrectly chooses hash/merge join but nested loop with\n      parameterized index scan would be faster.",
      "engine": "seed",
      "type": "gold"
    },
    "LIKE_PREFIX_INDEX_USAGE": {
      "vector_index": 91,
      "name": "Like Prefix Index Usage",
      "description": "Ensure LIKE 'prefix%' uses index by creating text_pattern_ops index\n      for non-C locale databases.",
      "verified_speedup": "unknown",
      "transforms": [
        "like_prefix_index_usage"
      ],
      "winning_transform": "like_prefix_index_usage",
      "key_insight": "Prefix searches on text columns in non-C collation databases.",
      "engine": "seed",
      "type": "gold"
    },
    "LIMITED_COUNT_FOR_THRESHOLD": {
      "vector_index": 92,
      "name": "Limited Count For Threshold",
      "description": "When checking if count exceeds threshold, use LIMIT to avoid\n      counting all rows.",
      "verified_speedup": "unknown",
      "transforms": [
        "limited_count_for_threshold"
      ],
      "winning_transform": "limited_count_for_threshold",
      "key_insight": "Need to know if \"at least N\" rows exist, not exact count.",
      "engine": "seed",
      "type": "gold"
    },
    "NOT_IN_TO_NOT_EXISTS": {
      "vector_index": 93,
      "name": "Not In To Not Exists",
      "description": "PostgreSQL CANNOT automatically transform NOT IN to anti-join due to\n      different NULL semantics. NOT IN with any NULL in subquery returns\n      no rows, while NOT EXISTS handles NULLs correctly and enables anti-join.",
      "verified_speedup": "High - enables Hash Anti Join vs O(N\u00b2) SubPlan",
      "transforms": [
        "not_in_to_not_exists"
      ],
      "winning_transform": "not_in_to_not_exists",
      "key_insight": "Always prefer NOT EXISTS over NOT IN for exclusion patterns. Critical\n      for correctness when subquery may contain NULLs.",
      "engine": "seed",
      "type": "gold"
    },
    "OR_TO_UNION_ALL": {
      "vector_index": 94,
      "name": "Or To Union All",
      "description": "Rewrite OR conditions to UNION ALL when OR prevents efficient index\n      usage, especially in JOIN contexts.",
      "verified_speedup": "unknown",
      "transforms": [
        "or_to_union_all"
      ],
      "winning_transform": "or_to_union_all",
      "key_insight": "OR conditions span different columns with separate indexes.\n      Ensure result sets are mutually exclusive for UNION ALL.",
      "engine": "seed",
      "type": "gold"
    },
    "PARTITION_PRUNING_PREDICATE": {
      "vector_index": 95,
      "name": "Partition Pruning Predicate",
      "description": "Rewrite predicates to enable partition pruning by using direct\n      comparisons on partition key columns.",
      "verified_speedup": "unknown",
      "transforms": [
        "partition_pruning_predicate"
      ],
      "winning_transform": "partition_pruning_predicate",
      "key_insight": "Partitioned tables where pruning isn't occurring due to\n      functions/expressions on partition key.",
      "engine": "seed",
      "type": "gold"
    },
    "REDUNDANT_JOIN_ELIMINATION": {
      "vector_index": 96,
      "name": "Redundant Join Elimination",
      "description": "Remove unnecessary joins to parent tables when only the foreign key\n      is used from the joined table and the FK is NOT NULL. PostgreSQL\n      does not automatically eliminate these (unlike Oracle/DB2).",
      "verified_speedup": "unknown",
      "transforms": [
        "redundant_join_elimination"
      ],
      "winning_transform": "redundant_join_elimination",
      "key_insight": "When only FK column is selected from joined table and FK has NOT NULL\n      constraint ensuring all rows match.",
      "engine": "seed",
      "type": "gold"
    },
    "SELF_JOIN_TO_WINDOW": {
      "vector_index": 97,
      "name": "Self Join To Window",
      "description": "Replace self-joins used to access group-level values with window\n      functions, eliminating the join entirely.",
      "verified_speedup": "unknown",
      "transforms": [
        "self_join_to_window"
      ],
      "winning_transform": "self_join_to_window",
      "key_insight": "Self-join retrieves aggregate values or rankings within a group.",
      "engine": "seed",
      "type": "gold"
    },
    "STAR_SCHEMA_DIMENSION_FILTER_FIRST": {
      "vector_index": 98,
      "name": "Star Schema Dimension Filter First",
      "description": "Restructure star schema queries to filter dimension tables first\n      using optimization barriers, then join filtered results to fact table.",
      "verified_speedup": "unknown",
      "transforms": [
        "star_schema_dimension_filter_first"
      ],
      "winning_transform": "star_schema_dimension_filter_first",
      "key_insight": "Star schema queries with selective dimension filters where optimizer\n      scans fact table first instead of filtering dimensions.",
      "engine": "seed",
      "type": "gold"
    },
    "SUBQUERY_OFFSET_ZERO_BARRIER": {
      "vector_index": 99,
      "name": "Subquery Offset Zero Barrier",
      "description": "Add OFFSET 0 to subquery to create optimization barrier preventing\n      subquery pull-up, forcing materialization and specific execution order.",
      "verified_speedup": "unknown",
      "transforms": [
        "subquery_offset_zero_barrier"
      ],
      "winning_transform": "subquery_offset_zero_barrier",
      "key_insight": "- Force specific join order without global setting changes\n      - Subquery results should compute before joining\n      - Debug plans by isolating subquery execution",
      "engine": "seed",
      "type": "gold"
    },
    "TOP_N_PER_GROUP_DISTINCT_ON": {
      "vector_index": 100,
      "name": "Top N Per Group Distinct On",
      "description": "Use PostgreSQL's DISTINCT ON for \"top-1-per-group\" instead of\n      ROW_NUMBER() window function.  More concise and often faster.",
      "verified_speedup": "unknown",
      "transforms": [
        "top_n_per_group_distinct_on"
      ],
      "winning_transform": "top_n_per_group_distinct_on",
      "key_insight": "Retrieving exactly one row per group based on ordering.\n      PostgreSQL-specific extension.",
      "engine": "seed",
      "type": "gold"
    },
    "TOP_N_PER_GROUP_ROW_NUMBER": {
      "vector_index": 101,
      "name": "Top N Per Group Row Number",
      "description": "Use ROW_NUMBER() window function instead of correlated subquery\n      COUNT for top-N-per-group patterns.",
      "verified_speedup": "unknown",
      "transforms": [
        "top_n_per_group_row_number"
      ],
      "winning_transform": "top_n_per_group_row_number",
      "key_insight": "Retrieving multiple rows per group based on ranking.",
      "engine": "seed",
      "type": "gold"
    },
    "TOP_N_PER_GROUP_TO_LATERAL": {
      "vector_index": 102,
      "name": "Top N Per Group To Lateral",
      "description": "Convert correlated subqueries for \"top N per group\" to LATERAL joins\n      with LIMIT, enabling index-only scans per group instead of window\n      functions over entire dataset.",
      "verified_speedup": "unknown",
      "transforms": [
        "top_n_per_group_to_lateral"
      ],
      "winning_transform": "top_n_per_group_to_lateral",
      "key_insight": "Finding top N rows per group where an appropriate index exists on\n      (group_key, sort_column). Especially effective when N is small.",
      "engine": "seed",
      "type": "gold"
    },
    "UNION_TO_UNION_ALL": {
      "vector_index": 103,
      "name": "Union To Union All",
      "description": "Replace UNION with UNION ALL when duplicate elimination is unnecessary,\n      avoiding expensive sort/hash operations.",
      "verified_speedup": "unknown",
      "transforms": [
        "union_to_union_all"
      ],
      "winning_transform": "union_to_union_all",
      "key_insight": "Result sets are provably disjoint or duplicates are acceptable.",
      "engine": "seed",
      "type": "gold"
    },
    "WINDOW_SORT_ALIGNMENT": {
      "vector_index": 104,
      "name": "Window Sort Alignment",
      "description": "Align window function ORDER BY clauses to minimize sorts when\n      multiple window functions are used in same query.",
      "verified_speedup": "unknown",
      "transforms": [
        "window_sort_alignment"
      ],
      "winning_transform": "window_sort_alignment",
      "key_insight": "Queries with multiple window functions using different orderings.\n      Group windows with same sort together.",
      "engine": "seed",
      "type": "gold"
    }
  },
  "index_stats": {
    "total_vectors": 105,
    "dimensions": 90,
    "index_type": "IndexFlatL2 (cosine similarity via normalization)",
    "normalized_sql": true,
    "zscore_normalized": true,
    "feature_stats_file": "feature_stats.json",
    "dialect": "postgres",
    "normalization": "literals replaced with $N placeholders, identifiers lowercased"
  }
}