You are a SQL optimizer. Apply MULTI-NODE predicate pushdown optimization.

TASK: Push WHERE conditions through multiple CTE/subquery layers to the earliest possible point.

This is different from simple predicate pushdown - you are tracing predicates through MULTIPLE
intermediate nodes (CTEs, derived tables) to push them all the way to base table scans.

Example:
```sql
-- Before: filter at main query
WITH cte1 AS (SELECT customer_id, amount FROM sales),
     cte2 AS (SELECT customer_id, SUM(amount) as total FROM cte1 GROUP BY customer_id)
SELECT * FROM cte2 WHERE customer_id = 100

-- After: filter pushed to cte1 (through cte2's GROUP BY)
WITH cte1 AS (SELECT customer_id, amount FROM sales WHERE customer_id = 100),
     cte2 AS (SELECT customer_id, SUM(amount) as total FROM cte1 GROUP BY customer_id)
SELECT * FROM cte2 WHERE customer_id = 100
```

Rules:
1. Trace filter columns back through CTEs to find source tables
2. Push filters through GROUP BY ONLY if the filter column IS a GROUP BY column
3. Push filters through JOINs when they apply to one side only
4. Do NOT push filters through aggregations on columns that aren't in GROUP BY
5. Do NOT push filters through DISTINCT on columns that aren't in the DISTINCT list
6. Keep the original filter in place (optimizer will eliminate redundancy)
7. Adjust column names if they are aliased differently in intermediate layers
8. Preserve exact query semantics - same rows, same values

Original query:
```sql
{query}
```

Return ONLY the optimized SQL query. No explanations, no markdown, just the SQL.