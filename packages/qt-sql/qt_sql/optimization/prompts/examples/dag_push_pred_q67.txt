Apply ONLY predicate pushdown optimization using node-level rewrites.

TASK: Push WHERE conditions as close to base tables as possible.

## Query DAG

```
Nodes:
  [derived_1] type=derived_table tables=['store_sales', 'date_dim', 'store', 'item']
  [derived_2] type=derived_table
  [main_query] type=main_query

Edges:
```

## Node SQL

### derived_1
```sql
SELECT
  i_category,
  i_class,
  i_brand,
  i_product_name,
  d_year,
  d_qoy,
  d_moy,
  s_store_id,
  SUM(COALESCE(ss_sales_price * ss_quantity, 0)) AS sumsales
FROM store_sales, date_dim, store, item
WHERE
  ss_sold_date_sk = d_date_sk
  AND ss_item_sk = i_item_sk
  AND ss_store_sk = s_store_sk
  AND d_month_seq BETWEEN 1206 AND 1206 + 11
GROUP BY
  ROLLUP (
    i_category,
    i_class,
    i_brand,
    i_product_name,
    d_year,
    d_qoy,
    d_moy,
    s_store_id
  )
```

### derived_2
```sql
SELECT
  i_category,
  i_class,
  i_brand,
  i_product_name,
  d_year,
  d_qoy,
  d_moy,
  s_store_id,
  sumsales,
  RANK() OVER (PARTITION BY i_category ORDER BY sumsales DESC) AS rk
FROM (
  SELECT
    i_category,
    i_class,
    i_brand,
    i_product_name,
    d_year,
    d_qoy,
    d_moy,
    s_store_id,
    SUM(COALESCE(ss_sales_price * ss_quantity, 0)) AS sumsales
  FROM store_sales, date_dim, store, item
  WHERE
    ss_sold_date_sk = d_date_sk
    AND ss_item_sk = i_item_sk
    AND ss_store_sk = s_store_sk
    AND d_month_seq BETWEEN 1206 AND 1206 + 11
  GROUP BY
    ROLLUP (
      i_category,
      i_class,
      i_brand,
      i_product_name,
      d_year,
      d_qoy,
      d_moy,
      s_store_id
    )
) AS dw1
```

### main_query
```sql
/* start query 67 in stream 0 using template query67.tpl */
SELECT
  *
FROM (
  SELECT
    i_category,
    i_class,
    i_brand,
    i_product_name,
    d_year,
    d_qoy,
    d_moy,
    s_store_id,
    sumsales,
    RANK() OVER (PARTITION BY i_category ORDER BY sumsales DESC) AS rk
  FROM (
    SELECT
      i_category,
      i_class,
      i_brand,
      i_product_name,
      d_year,
      d_qoy,
      d_moy,
      s_store_id,
      SUM(COALESCE(ss_sales_price * ss_quantity, 0)) AS sumsales
    FROM store_sales, date_dim, store, item
    WHERE
      ss_sold_date_sk = d_date_sk
      AND ss_item_sk = i_item_sk
      AND ss_store_sk = s_store_sk
      AND d_month_seq BETWEEN 1206 AND 1206 + 11
    GROUP BY
      ROLLUP (
        i_category,
        i_class,
        i_brand,
        i_product_name,
        d_year,
        d_qoy,
        d_moy,
        s_store_id
      )
  ) AS dw1
) AS dw2
WHERE
  rk <= 100
ORDER BY
  i_category,
  i_class,
  i_brand,
  i_product_name,
  d_year,
  d_qoy,
  d_moy,
  s_store_id,
  sumsales,
  rk
LIMIT 100
```


Available nodes: `derived_1`, `derived_2`, `main_query`

Rules:
1. Move predicates that filter on a single table into that node's CTE or subquery
2. Push predicates through inner joins when safe
3. Push predicates into CTEs if they filter on CTE columns only
4. Do NOT change join types, column lists, or aggregations
5. Preserve exact query semantics - same rows, same values
6. Return JSON with rewrites for affected nodes only

Return JSON:
```json
{"rewrites": {"node_id": "SELECT ..."}, "explanation": "..."}
```