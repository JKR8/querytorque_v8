# DSPy SQLDagOptimizer Example Input (q67)
# This is what gets sent to the LLM via DSPy ChainOfThought

## query_dag
## Query DAG

```
Nodes:
  [derived_1] type=derived_table tables=['store_sales', 'date_dim', 'store', 'item']
  [derived_2] type=derived_table
  [main_query] type=main_query

Edges:
  (none - nested structure)
```

## node_sql

### derived_1
```sql
SELECT
  i_category,
  i_class,
  i_brand,
  i_product_name,
  d_year,
  d_qoy,
  d_moy,
  s_store_id,
  SUM(COALESCE(ss_sales_price * ss_quantity, 0)) AS sumsales
FROM store_sales, date_dim, store, item
WHERE
  ss_sold_date_sk = d_date_sk
  AND ss_item_sk = i_item_sk
  AND ss_store_sk = s_store_sk
  AND d_month_seq BETWEEN 1206 AND 1206 + 11
GROUP BY
  ROLLUP (i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id)
```

### derived_2
```sql
SELECT
  i_category, i_class, i_brand, i_product_name,
  d_year, d_qoy, d_moy, s_store_id, sumsales,
  RANK() OVER (PARTITION BY i_category ORDER BY sumsales DESC) AS rk
FROM derived_1 AS dw1
```

### main_query
```sql
SELECT *
FROM derived_2 AS dw2
WHERE rk <= 100
ORDER BY i_category, i_class, i_brand, i_product_name,
         d_year, d_qoy, d_moy, s_store_id, sumsales, rk
LIMIT 100
```

Available nodes: `derived_1`, `derived_2`, `main_query`

## execution_plan
**Operators by cost:**
- SEQ_SCAN (store_sales): 45% cost, 287,997,024 rows
- HASH_GROUP_BY: 25% cost, 10,000,000 rows
- WINDOW: 15% cost, 10,000,000 rows

## optimization_hints
WINDOW_OVER_LARGE_SET: RANK() over 10M+ rows from ROLLUP

## constraints
(Model and DB-specific constraints loaded from configs)

---
Expected Output:

rewrites:
{
  "derived_1": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, SUM(COALESCE(ss_sales_price * ss_quantity, 0)) AS sumsales FROM date_dim, store_sales, item, store WHERE ss_sold_date_sk = d_date_sk AND ss_item_sk = i_item_sk AND ss_store_sk = s_store_sk AND d_month_seq BETWEEN 1206 AND 1206 + 11 GROUP BY ROLLUP (i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id)"
}

explanation:
  "Reordered joins in derived_1 to put date_dim first since it has the
   filter predicate, reducing intermediate result size before joining
   to store_sales."
