# DuckDB Query Optimization Prompt

You are an expert DuckDB query optimizer specializing in analytical workloads. Your task is to rewrite the provided query to achieve better execution performance while preserving exact semantic equivalence.

**Critical context:** DuckDB is a columnar, vectorized, in-process analytical database. Its optimizer is significantly more advanced than traditional row-store optimizers in several areas â€” particularly automatic subquery decorrelation and filter pushdown. However, it has distinct weaknesses around join ordering with skewed data, cardinality estimation without HyperLogLog statistics, grouped TopN recognition, and cyclic/non-equi join patterns. Your rewrites must target DuckDB's actual blind spots, not generic SQL anti-patterns that DuckDB already handles automatically.

---

## Input Context

### DuckDB Version & Configuration
```
DuckDB v0.9.2 (linux_amd64)
```

**Relevant Settings:**
```
memory_limit = 8GB
threads = 8
temp_directory = /tmp/duckdb
preserve_insertion_order = true
enable_progress_bar = false
```

### Data Source Format
```
Parquet files on local SSD
Row groups: 100,000 rows each
Compression: ZSTD
```

---

### Database Schema

```sql
CREATE TABLE store_returns (
    sr_returned_date_sk INTEGER,
    sr_return_time_sk INTEGER,
    sr_item_sk INTEGER NOT NULL,
    sr_customer_sk INTEGER,
    sr_cdemo_sk INTEGER,
    sr_hdemo_sk INTEGER,
    sr_addr_sk INTEGER,
    sr_store_sk INTEGER,
    sr_reason_sk INTEGER,
    sr_ticket_number BIGINT NOT NULL,
    sr_return_quantity INTEGER,
    sr_return_amt DECIMAL(7,2),
    sr_return_tax DECIMAL(7,2),
    sr_return_amt_inc_tax DECIMAL(7,2),
    sr_fee DECIMAL(7,2),
    sr_return_ship_cost DECIMAL(7,2),
    sr_refunded_cash DECIMAL(7,2),
    sr_reversed_charge DECIMAL(7,2),
    sr_store_credit DECIMAL(7,2),
    sr_net_loss DECIMAL(7,2),
    PRIMARY KEY (sr_item_sk, sr_ticket_number)
);

CREATE TABLE date_dim (
    d_date_sk INTEGER NOT NULL PRIMARY KEY,
    d_date_id VARCHAR(16) NOT NULL,
    d_date DATE,
    d_month_seq INTEGER,
    d_week_seq INTEGER,
    d_quarter_seq INTEGER,
    d_year INTEGER,
    d_dow INTEGER,
    d_moy INTEGER,
    d_dom INTEGER,
    d_qoy INTEGER,
    d_fy_year INTEGER,
    d_fy_quarter_seq INTEGER,
    d_fy_week_seq INTEGER,
    d_day_name VARCHAR(9),
    d_quarter_name VARCHAR(6),
    d_holiday VARCHAR(1),
    d_weekend VARCHAR(1),
    d_following_holiday VARCHAR(1),
    d_first_dom INTEGER,
    d_last_dom INTEGER,
    d_same_day_ly INTEGER,
    d_same_day_lq INTEGER,
    d_current_day VARCHAR(1),
    d_current_week VARCHAR(1),
    d_current_month VARCHAR(1),
    d_current_quarter VARCHAR(1),
    d_current_year VARCHAR(1)
);

CREATE TABLE store (
    s_store_sk INTEGER NOT NULL PRIMARY KEY,
    s_store_id VARCHAR(16) NOT NULL,
    s_rec_start_date DATE,
    s_rec_end_date DATE,
    s_closed_date_sk INTEGER,
    s_store_name VARCHAR(50),
    s_number_employees INTEGER,
    s_floor_space INTEGER,
    s_hours VARCHAR(20),
    s_manager VARCHAR(40),
    s_market_id INTEGER,
    s_geography_class VARCHAR(100),
    s_market_desc VARCHAR(100),
    s_market_manager VARCHAR(40),
    s_division_id INTEGER,
    s_division_name VARCHAR(50),
    s_company_id INTEGER,
    s_company_name VARCHAR(50),
    s_street_number VARCHAR(10),
    s_street_name VARCHAR(60),
    s_street_type VARCHAR(15),
    s_suite_number VARCHAR(10),
    s_city VARCHAR(60),
    s_county VARCHAR(30),
    s_state VARCHAR(2),
    s_zip VARCHAR(10),
    s_country VARCHAR(20),
    s_gmt_offset DECIMAL(5,2),
    s_tax_percentage DECIMAL(5,2)
);

CREATE TABLE customer (
    c_customer_sk INTEGER NOT NULL PRIMARY KEY,
    c_customer_id VARCHAR(16) NOT NULL,
    c_current_cdemo_sk INTEGER,
    c_current_hdemo_sk INTEGER,
    c_current_addr_sk INTEGER,
    c_first_shipto_date_sk INTEGER,
    c_first_sales_date_sk INTEGER,
    c_salutation VARCHAR(10),
    c_first_name VARCHAR(20),
    c_last_name VARCHAR(30),
    c_preferred_cust_flag VARCHAR(1),
    c_birth_day INTEGER,
    c_birth_month INTEGER,
    c_birth_year INTEGER,
    c_birth_country VARCHAR(20),
    c_login VARCHAR(13),
    c_email_address VARCHAR(50),
    c_last_review_date_sk INTEGER
);
```

---

### Table Statistics

```
store_returns: 28,795,080 rows (2.3 GB on disk)
  - Sorted by: sr_returned_date_sk
  - Zonemaps active on: sr_returned_date_sk, sr_store_sk

date_dim: 73,049 rows (1.2 MB on disk)
  - All columns have zonemaps

store: 402 rows (32 KB on disk)

customer: 2,000,000 rows (156 MB on disk)
  - Sorted by: c_customer_sk
```

---

### Original Query

```sql
WITH customer_total_return AS (
    SELECT sr_customer_sk AS ctr_customer_sk,
           sr_store_sk AS ctr_store_sk,
           SUM(SR_FEE) AS ctr_total_return
    FROM store_returns, date_dim
    WHERE sr_returned_date_sk = d_date_sk
      AND d_year = 2000
    GROUP BY sr_customer_sk, sr_store_sk
)
SELECT c_customer_id
FROM customer_total_return ctr1, store, customer
WHERE ctr1.ctr_total_return > (
    SELECT avg(ctr_total_return) * 1.2
    FROM customer_total_return ctr2
    WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk
)
  AND s_store_sk = ctr1.ctr_store_sk
  AND s_state = 'SD'
  AND ctr1.ctr_customer_sk = c_customer_sk
ORDER BY c_customer_id
LIMIT 100
```

---

### Execution Plan Analysis

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              QUERY PLAN                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ EXPLAIN ANALYZE                                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚ â”‚       TOP_N (100)         â”‚                                                   â”‚
â”‚ â”‚   [SORT: c_customer_id]   â”‚                                                   â”‚
â”‚ â”‚    EC: 100  Actual: 100   â”‚                                                   â”‚
â”‚ â”‚    Time: 0.02ms           â”‚                                                   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚               â”‚                                                                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚ â”‚       HASH_JOIN           â”‚                                                   â”‚
â”‚ â”‚     [c_customer_sk =      â”‚                                                   â”‚
â”‚ â”‚      ctr_customer_sk]     â”‚                                                   â”‚
â”‚ â”‚   EC: 4444  Actual: 4521  â”‚                                                   â”‚
â”‚ â”‚    Time: 45.3ms           â”‚                                                   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚               â”‚                                                                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚ â”‚       HASH_JOIN           â”‚    â”‚     SEQ_SCAN          â”‚                      â”‚
â”‚ â”‚  [ctr_store_sk = store_sk]â”‚â—„â”€â”€â”€â”‚      customer         â”‚                      â”‚
â”‚ â”‚   EC: 8888  Actual: 9042  â”‚    â”‚  EC: 2M  Actual: 2M   â”‚                      â”‚
â”‚ â”‚    Time: 234.5ms          â”‚    â”‚    Time: 890.2ms      â”‚                      â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚               â”‚                                                                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚ â”‚    DEPENDENT JOIN         â”‚    â”‚     SEQ_SCAN          â”‚                      â”‚
â”‚ â”‚   [ctr1.ctr_total_return  â”‚â—„â”€â”€â”€â”‚       store           â”‚                      â”‚
â”‚ â”‚    > subquery result]     â”‚    â”‚ Filter: s_state='SD'  â”‚                      â”‚
â”‚ â”‚   EC: 88  Actual: 9042    â”‚    â”‚  EC: 12  Actual: 12   â”‚                      â”‚
â”‚ â”‚    Time: 12456.7ms  <<<   â”‚    â”‚    Time: 0.1ms        â”‚                      â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚               â”‚                                                                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚ â”‚   CTE_SCAN (ctr1)         â”‚                                                   â”‚
â”‚ â”‚  customer_total_return    â”‚                                                   â”‚
â”‚ â”‚   EC: 532K  Actual: 532K  â”‚                                                   â”‚
â”‚ â”‚    Time: 2345.6ms         â”‚                                                   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚               â”‚                                                                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚ â”‚    HASH_GROUP_BY          â”‚                                                   â”‚
â”‚ â”‚  [sr_customer_sk,         â”‚                                                   â”‚
â”‚ â”‚   sr_store_sk]            â”‚                                                   â”‚
â”‚ â”‚   EC: 532K  Actual: 532K  â”‚                                                   â”‚
â”‚ â”‚    Time: 1890.4ms         â”‚                                                   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚               â”‚                                                                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚ â”‚       HASH_JOIN           â”‚    â”‚     SEQ_SCAN          â”‚                      â”‚
â”‚ â”‚  [sr_returned_date_sk =   â”‚â—„â”€â”€â”€â”‚      date_dim         â”‚                      â”‚
â”‚ â”‚   d_date_sk]              â”‚    â”‚ Filter: d_year=2000   â”‚                      â”‚
â”‚ â”‚   EC: 2.8M  Actual: 2.8M  â”‚    â”‚  EC: 366  Actual: 366 â”‚                      â”‚
â”‚ â”‚    Time: 567.8ms          â”‚    â”‚    Time: 1.2ms        â”‚                      â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚               â”‚                                                                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚ â”‚    PARQUET_SCAN           â”‚                                                   â”‚
â”‚ â”‚     store_returns         â”‚                                                   â”‚
â”‚ â”‚   EC: 28.7M Actual: 28.7M â”‚                                                   â”‚
â”‚ â”‚    Time: 3456.7ms         â”‚                                                   â”‚
â”‚ â”‚ Columns: sr_customer_sk,  â”‚                                                   â”‚
â”‚ â”‚  sr_store_sk, sr_fee,     â”‚                                                   â”‚
â”‚ â”‚  sr_returned_date_sk      â”‚                                                   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚                                                                                  â”‚
â”‚ Total Time: 15.2s                                                               â”‚
â”‚ Peak Memory: 1.2 GB                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

BOTTLENECK IDENTIFIED:
- DEPENDENT JOIN taking 12.4s (82% of query time)
- Subquery executed 9042 times (once per outer row)
- DuckDB's automatic decorrelation DID NOT FIRE due to the
  comparison operator (>) in the correlation condition
```

---

## CONSTRAINTS (Learned from Benchmark Failures)

The following constraints are MANDATORY based on observed failures:

### ðŸš¨ LITERAL_PRESERVATION (CRITICAL)
CRITICAL: When rewriting SQL, you MUST copy ALL literal values (strings, numbers, dates) EXACTLY from the original query. Do NOT invent, substitute, or 'improve' any filter values. If the original says d_year = 2000, your rewrite MUST say d_year = 2000. If the original says ca_state = 'GA', your rewrite MUST say ca_state = 'GA'. Changing these values will produce WRONG RESULTS and the rewrite will be REJECTED.

### âš ï¸ OR_TO_UNION_LIMIT (HIGH)
CAUTION with ORâ†’UNION: Only split OR conditions into UNION ALL when there are â‰¤3 simple branches AND they have different access patterns. If you have nested ORs (e.g., 3 conditions Ã— 3 values = 9 combinations), DO NOT expand them - keep the original OR structure. DuckDB handles OR predicates efficiently. Over-splitting causes multiple scans of fact tables and severe regressions (0.23x-0.41x observed). When in doubt, preserve the original OR structure.

---

## What DuckDB Already Handles Automatically

**Do NOT rewrite for these â€” DuckDB's optimizer handles them:**

1. **Correlated subquery decorrelation**: DuckDB uses a state-of-the-art algorithm (Unnesting Arbitrary Queries, Neumann & Kemper) to automatically decorrelate ALL subqueries into efficient joins. Unlike PostgreSQL, correlated subqueries do NOT imply performance degradation in DuckDB. Do not manually convert correlated subqueries to joins unless the EXPLAIN ANALYZE shows the decorrelation produced a suboptimal plan.

2. **NOT IN / NOT EXISTS equivalence**: DuckDB automatically detects anti-join patterns from both NOT IN and NOT EXISTS. No manual rewrite needed.

3. **Filter pushdown/pull-up**: DuckDB aggressively pushes filters through joins, projections, and aggregations â€” and pulls them up across equivalence sets to duplicate filters on both sides of joins.

4. **Join filter pushdown**: DuckDB automatically creates min/max range filters from the build side of hash joins and pushes them into probe-side scans (up to 10Ã— improvement automatically).

5. **TopN optimization**: For simple `ORDER BY ... LIMIT N`, DuckDB avoids full sorting and uses a heap-based top-N algorithm automatically.

6. **Expression simplification**: Constant folding, arithmetic simplification, CASE simplification, date part simplification, comparison normalization, and IN clause rewriting are all automatic.

7. **Common subexpression elimination**: DuckDB extracts and caches duplicate expressions across projections and filters.

8. **CTE inlining**: DuckDB automatically decides whether to materialize or inline CTEs (controlled by the MATERIALIZED_CTE optimizer rule).

---

## Optimization Analysis Framework

### Step 1: Identify Performance Bottlenecks

Examine the EXPLAIN ANALYZE output for these DuckDB-specific red flags:

1. **Cardinality misestimates (EC vs actual)**: Ratio > 10Ã— indicates optimizer made wrong decisions downstream. Especially common with:
   - Correlated/skewed distributions
   - Parquet sources without HyperLogLog stats
   - Multi-column filter correlations (DuckDB assumes independence)

2. **Nested loop joins**: Always a red flag in DuckDB's analytical context. Usually indicates the optimizer thinks one side is tiny (EC=1) when it's not. Look for `NESTED_LOOP_JOIN` operators.

3. **Large intermediate results in wrong join order**: If a `HASH_JOIN` produces far more rows than estimated, subsequent operators process too much data. Look for actual >> EC on join outputs.

4. **Missing filter pushdown**: A `SEQ_SCAN` or `PARQUET_SCAN` without filter info, followed by a separate `FILTER` operator, means the filter wasn't pushed into the scan.

5. **Full sort for grouped TopN**: DuckDB doesn't recognize `ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ...) <= N` as a grouped top-N aggregation. It performs a full sort per group.

6. **Disk spilling**: If `temp_directory` is active and the query spills, look for operators that could be restructured to reduce memory pressure.

7. **Excessive column reads**: A scan reading many columns when only a few are needed downstream.

### Step 2: Match Bottlenecks to Rewrite Patterns

Apply these DuckDB-specific rewrites in priority order:

---

#### Pattern A: Join Order Override (10-1000Ã— improvement potential)

**The #1 issue for analytical queries on DuckDB.** DuckDB uses the DPccp algorithm for join ordering, but it relies on cardinality estimates. Correlated data causes systematic estimation errors, leading to catastrophic join orders.

**Detect**: Large actual-vs-estimated gaps on join outputs; fact table joined before selective dimension filters are applied.

```sql
-- Disable join optimizer and force explicit order
SET disabled_optimizers = 'join_order,build_side_probe_side';

-- Write joins in optimal order: most selective dimensions first,
-- fact tables last, ordered by increasing expected intermediate size
SELECT ...
FROM most_selective_dimension d1
JOIN fact_table f ON d1.sk = f.d1_sk
JOIN less_selective_dimension d2 ON f.d2_sk = d2.sk
WHERE d1.filter_col = 'value';

RESET disabled_optimizers;
```

**Star-schema guidance**: Optimal order is typically:
1. Most selective dimension table (fewest rows after WHERE filters)
2. Fact table joined to that dimension
3. Remaining dimensions joined in order of selectivity

**Alternative â€” pre-aggregate before joining:**
```sql
SELECT d.name, f_agg.total
FROM (
    SELECT dim_sk, SUM(amount) as total
    FROM fact_table
    WHERE date_sk BETWEEN 2451911 AND 2451941
    GROUP BY dim_sk
) f_agg
JOIN dimension d ON f_agg.dim_sk = d.sk
WHERE d.category = 'Electronics';
```

---

#### Pattern B: Sargable Predicate Rewriting (2-100Ã— improvement)

**Detect**: Filters that prevent zonemap/pushdown optimization â€” functions on columns, implicit casts, expressions.

```sql
-- BEFORE: Function on column blocks zonemap usage
SELECT * FROM sales WHERE YEAR(sale_date) = 2023;

-- AFTER: Range predicate enables zonemap skip
SELECT * FROM sales
WHERE sale_date >= DATE '2023-01-01'
  AND sale_date < DATE '2024-01-01';
```

```sql
-- BEFORE: CAST blocks pushdown
SELECT * FROM t WHERE col::VARCHAR = '100';

-- AFTER: Cast the literal, not the column
SELECT * FROM t WHERE col = 100;
```

---

#### Pattern C: Grouped TopN â†’ QUALIFY or arg_max (5-50Ã— improvement)

**Detect**: `ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ...)` followed by filter `<= N`.

```sql
-- BEFORE: Full sort per group
SELECT * FROM (
    SELECT *, ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) as rn
    FROM sales
) sub WHERE rn <= 3;

-- AFTER: Use QUALIFY
SELECT *
FROM sales
QUALIFY ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) <= 3;

-- AFTER (for top-1 only): Use arg_max
SELECT region, arg_max(customer_id, amount) as top_customer, max(amount) as top_amount
FROM sales
GROUP BY region;
```

---

#### Pattern D: Avoid Unnecessary DISTINCT / Redundant Grouping

**Detect**: `DISTINCT` on columns known to be unique from join structure.

```sql
-- BEFORE: DISTINCT forces hash aggregate
SELECT DISTINCT d.category, d.name
FROM dimension d
JOIN fact_table f ON d.sk = f.dim_sk
WHERE f.amount > 100;

-- AFTER: Use semi-join via EXISTS
SELECT d.category, d.name
FROM dimension d
WHERE EXISTS (SELECT 1 FROM fact_table f WHERE f.dim_sk = d.sk AND f.amount > 100);
```

---

#### Pattern E: UNION ALL â†’ Single Scan with Conditional Aggregation

**Detect**: Multiple scans of the same large table with different filters.

```sql
-- BEFORE: Multiple scans
SELECT 'cat_a' as cat, SUM(amount) FROM sales WHERE category = 'A'
UNION ALL
SELECT 'cat_b' as cat, SUM(amount) FROM sales WHERE category = 'B';

-- AFTER: Single scan with FILTER
SELECT
    SUM(amount) FILTER (WHERE category = 'A') as cat_a_total,
    SUM(amount) FILTER (WHERE category = 'B') as cat_b_total
FROM sales WHERE category IN ('A', 'B');
```

---

#### Pattern F: Exploit Data Ordering for Zonemap Effectiveness

**Detect**: Selective filters on columns that don't align with the table's sort order.

```sql
-- If table is sorted by date but frequently filtered by region:
CREATE TABLE sales_by_region AS
    SELECT * FROM sales ORDER BY region, sale_date;
```

---

#### Pattern G: Replace Non-Equi Joins with Range Joins or ASOF Joins

**Detect**: `NESTED_LOOP_JOIN` on non-equality conditions.

```sql
-- For temporal lookups, use ASOF JOIN (DuckDB-native):
SELECT s.*, p.price
FROM sales s
ASOF JOIN prices p
  ON s.product_id = p.product_id
  AND s.sale_date >= p.effective_date;
```

---

#### Pattern H: Leverage DuckDB-Specific Syntax

```sql
-- GROUP BY ALL: avoids redundant column listing
SELECT region, category, SUM(amount), COUNT(*)
FROM sales
GROUP BY ALL;

-- QUALIFY: filter window results without subquery
SELECT customer_id, amount, sale_date
FROM sales
QUALIFY ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY sale_date DESC) = 1;

-- FILTER clause on aggregates
SELECT region,
    COUNT(*) FILTER (WHERE amount > 100) as high_value_count,
    AVG(amount) FILTER (WHERE category = 'A') as cat_a_avg
FROM sales
GROUP BY region;
```

---

#### Pattern I: Memory Pressure Management

```sql
-- Increase memory for hash-heavy queries
SET memory_limit = '16GB';

-- Disable preservation of insertion order
SET preserve_insertion_order = false;

-- Pre-aggregate before joining to reduce hash table sizes
SELECT d.name, f_agg.total
FROM (SELECT sk, SUM(amount) as total FROM fact GROUP BY sk) f_agg
JOIN dim d ON f_agg.sk = d.sk;
```

---

### Step 3: Verify Semantic Equivalence

For each rewrite, verify:
1. **NULL handling**: Manual rewrites must preserve NULL behavior
2. **Duplicate handling**: Converting DISTINCT to EXISTS changes semantics if not careful
3. **Sort stability**: DuckDB does not guarantee stable sorts
4. **Empty group handling**: `QUALIFY` returns no rows when no matches exist per group
5. **Type coercion**: Rewriting predicates may change type resolution

---

## Output Format

Provide your response in this structure:

### Analysis

**Identified Bottlenecks:**
1. [Bottleneck description with operator/EC-vs-actual from EXPLAIN ANALYZE]

**Root Causes:**
- [Why DuckDB's optimizer made this choice]

**DuckDB auto-optimizations already in effect:**
- [Note which optimizations should NOT be undone]

### Recommended Rewrites

**Rewrite 1: [Pattern Name]**

*Rationale:* [Why this rewrite helps]

*Original fragment:*
```sql
[relevant portion]
```

*Rewritten fragment:*
```sql
[optimized version]
```

*Expected improvement:* [Estimated speedup]

### Complete Optimized Query

```sql
-- Your complete optimized query here
```

### Verification Checklist

- [ ] NULL semantics preserved
- [ ] Duplicate rows handled correctly
- [ ] Empty group/no-match cases return same results
- [ ] All columns in SELECT/ORDER BY still accessible
- [ ] All literal values EXACTLY match original query
- [ ] OR conditions NOT over-expanded (â‰¤3 UNION branches max)

