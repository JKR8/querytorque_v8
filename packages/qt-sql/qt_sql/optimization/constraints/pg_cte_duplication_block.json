{
  "id": "PG_CTE_DUPLICATION_BLOCK",
  "severity": "HIGH",
  "engine": "postgresql",
  "description": "NEVER duplicate a CTE body to push a filter inside when the CTE contains 5+ table joins. If a CTE is referenced N times in the original, the optimized version must reference it at most N times. Duplicating expensive CTEs forces the full join to execute multiple times.",
  "failure_rate": "1/1 query regressed severely (0.65x)",
  "observed_failures": [
    {
      "query": "DSB Q064_multi",
      "speedup": "0.65x",
      "original": "cross_sales CTE (18-table join) referenced twice with year filter in WHERE",
      "rewrite": "Duplicated cross_sales into cross_sales_1998 and cross_sales_1999, each with year pushed inside",
      "problem": "18-table join executed TWICE instead of once. Original computed it once and self-joined with year filter."
    }
  ],
  "constraint_rules": [
    {
      "rule": "NO_CTE_BODY_DUPLICATION",
      "description": "If a CTE has 5+ table joins, never duplicate its body to push a filter inside",
      "rationale": "The CTE computation cost dominates. Computing it twice always exceeds the filter benefit."
    },
    {
      "rule": "REUSE_MATERIALIZED_CTE",
      "description": "PostgreSQL materializes CTEs. Reuse the materialized result with WHERE filters instead of duplicating.",
      "rationale": "CTE materialization means the result is computed once and stored. Filter on the stored result, don't recompute."
    }
  ],
  "prompt_instruction": "POSTGRESQL RULE: NEVER duplicate a CTE body to push a single-column filter inside. If the original has one CTE referenced multiple times, keep it as one CTE and filter in the WHERE clause. PostgreSQL materializes CTEs, so computing an expensive multi-table join twice is always worse than computing once and filtering. Observed 0.65x regression on 18-table CTE duplication."
}
