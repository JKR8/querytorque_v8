{
  "id": "semantic_late_materialization",
  "name": "Late Materialization by Key",
  "description": "Aggregate on surrogate keys first, then join descriptive columns after aggregation",
  "example_class": "semantic",
  "benchmark_queries": [],
  "verified_speedup": "unknown",
  "example": {
    "opportunity": "LATE MATERIALIZATION",
    "input_slice": "SQL\nSELECT s.store_name, s.city, SUM(ss.sales_price) AS total_sales\nFROM store_sales ss\nJOIN store s ON ss.store_sk = s.store_sk\nWHERE ss.sold_date_sk BETWEEN 2450816 AND 2450846\nGROUP BY s.store_name, s.city",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "semantic_rewrite",
          "nodes": {
            "sales_by_store": "SELECT store_sk, SUM(sales_price) AS total_sales FROM store_sales WHERE sold_date_sk BETWEEN 2450816 AND 2450846 GROUP BY store_sk",
            "main_query": "SELECT s.store_name, s.city, sb.total_sales FROM sales_by_store sb JOIN store s ON sb.store_sk = s.store_sk"
          },
          "invariants_kept": ["same result rows", "same column output"],
          "expected_speedup": "unknown",
          "risk": "low"
        }
      ],
      "explanation": "Aggregate by surrogate keys first to avoid hashing/sorting large text columns, then join descriptive attributes after aggregation."
    },
    "key_insight": "Group by surrogate keys first, then add descriptive columns after aggregation."
  }
}
