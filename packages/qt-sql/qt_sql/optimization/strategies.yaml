# SQL Optimization Strategies
# Patterns that have produced >2x speedups on analytical queries

strategies:
  - id: dimension_filter_hoisting
    name: Dimension Filter Hoisting
    description: |
      Move filtered dimension joins from outer query into CTE/subquery that
      aggregates fact data with FK relationship to that dimension.
    signal:
      - Filtered dimension table in main_query (e.g., state='X', year=2000)
      - CTE aggregates fact table that has FK to that dimension
      - CTE does NOT include the dimension filter
    fix: |
      Join the filtered dimension INTO the CTE before GROUP BY.
      This filters fact rows early, reducing aggregation work.
    example:
      before: |
        WITH agg AS (SELECT fk_col, SUM(val) FROM fact GROUP BY fk_col)
        SELECT * FROM agg, dim WHERE agg.fk_col = dim.pk AND dim.filter = 'X'
      after: |
        WITH agg AS (
          SELECT fk_col, SUM(val) FROM fact, dim
          WHERE fact.fk_col = dim.pk AND dim.filter = 'X'
          GROUP BY fk_col
        )
        SELECT * FROM agg
    verified_speedup: "2.44x"

  - id: correlated_to_precomputed_cte
    name: Correlated Subquery to Pre-computed CTE
    description: |
      Replace correlated subqueries that compare against per-group aggregates
      with a pre-computed CTE using GROUP BY, then JOIN.
    signal:
      - Correlated subquery in WHERE computing AVG, SUM, COUNT per group
      - Subquery used for threshold comparison (>, <, =)
      - Same CTE referenced in both main query and correlated subquery
    fix: |
      Create separate CTE with GROUP BY to pre-compute the aggregate.
      JOIN the pre-computed CTE instead of correlated subquery.
    example:
      before: |
        WITH ctr AS (SELECT store_sk, SUM(fee) AS total FROM returns GROUP BY store_sk, customer_sk)
        SELECT * FROM ctr c1 WHERE c1.total > (SELECT AVG(total)*1.2 FROM ctr c2 WHERE c1.store_sk = c2.store_sk)
      after: |
        WITH ctr AS (...),
             store_avg AS (SELECT store_sk, AVG(total)*1.2 AS threshold FROM ctr GROUP BY store_sk)
        SELECT * FROM ctr c1 JOIN store_avg sa ON c1.store_sk = sa.store_sk WHERE c1.total > sa.threshold
    verified_speedup: "2.81x"
    verified_query: "Q1"

  - id: date_cte_isolation
    name: Date CTE Isolation
    description: |
      Extract date dimension filtering into a small, early CTE.
      Particularly effective when date filter is repeated or complex.
    signal:
      - Date dimension joined with filter (d_year, d_qoy, d_month_seq, etc.)
      - Same date filter repeated in multiple CTEs or joins
      - Complex date range expression
    fix: |
      Create small CTE selecting only d_date_sk with the date filter.
      Join fact tables to this CTE instead of date_dim directly.
    example:
      before: |
        SELECT ... FROM fact, date_dim WHERE fact.date_sk = d_date_sk AND d_year = 2001 AND d_qoy = 1
      after: |
        WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_qoy = 1)
        SELECT ... FROM fact JOIN filtered_dates ON fact.date_sk = d_date_sk
    verified_speedup: "1.2-2.7x"
    verified_query: "Q6, Q15, Q27"

  - id: correlated_to_window
    name: Correlated Subquery to Window Function
    description: |
      Replace correlated subqueries in SELECT list that compute per-group aggregates
      with window functions computed in a single pass.
    signal:
      - Correlated subquery in SELECT computing AVG, SUM, COUNT per group
      - Aggregate needed alongside each row (not just for filtering)
    fix: |
      Add window function: AGG(...) OVER (PARTITION BY group_col)
    example:
      before: |
        SELECT *, (SELECT AVG(val) FROM t1 t2 WHERE t1.grp = t2.grp) as grp_avg FROM t1
      after: |
        SELECT *, AVG(val) OVER (PARTITION BY grp) as grp_avg FROM t1
    verified_speedup: "2x+"
    note: "For threshold comparisons in WHERE, prefer correlated_to_precomputed_cte"

  - id: join_elimination
    name: Join Elimination
    description: |
      Remove tables that are joined only to validate FK existence,
      when no columns from that table are used in output.
    signal:
      - Table joined but no columns selected from it
      - Join is on FK relationship
      - No filters on the joined table
    fix: |
      Remove the join entirely.
      Add WHERE fk_column IS NOT NULL to preserve the FK validation.
    example:
      before: |
        SELECT a.* FROM fact a, dim b WHERE a.dim_sk = b.dim_sk
      after: |
        SELECT a.* FROM fact a WHERE a.dim_sk IS NOT NULL
    verified_speedup: "2.18x"

  - id: union_all_decomposition
    name: UNION ALL Decomposition
    description: |
      Split complex OR conditions into separate queries with simple filters,
      then UNION ALL the results.
    signal:
      - Complex OR condition in WHERE clause
      - OR spans different columns or value ranges
      - Query does full table scan due to OR
    fix: |
      Create separate queries for each OR branch with simple equality/range filters.
      UNION ALL the results (ensure no duplicates or handle with DISTINCT).
    example:
      before: |
        SELECT * FROM t WHERE (col1 IN (...) OR col2 = 'X' OR col3 > 500)
      after: |
        SELECT * FROM t WHERE col3 > 500
        UNION ALL
        SELECT * FROM t WHERE col3 <= 500 AND (col1 IN (...) OR col2 = 'X')
    verified_speedup: "1.37x"

  - id: scan_consolidation
    name: Scan Consolidation
    description: |
      Combine multiple scans of the same table (with different filters)
      into a single scan with conditional aggregation.
    signal:
      - Same table appears in multiple CTEs or subqueries
      - Each scan has different filter conditions
      - Results are combined later
    fix: |
      Single scan with CASE WHEN expressions to compute multiple aggregates.
    example:
      before: |
        SELECT (SELECT SUM(x) FROM t WHERE year=2000),
               (SELECT SUM(x) FROM t WHERE year=2001)
      after: |
        SELECT SUM(CASE WHEN year=2000 THEN x END),
               SUM(CASE WHEN year=2001 THEN x END)
        FROM t WHERE year IN (2000, 2001)
    verified_speedup: "Variable - depends on scan cost"

# Priority order for applying strategies
priority:
  - correlated_to_precomputed_cte  # Highest impact - 2.81x on Q1
  - dimension_filter_hoisting       # 2.71x on Q93 - filters early
  - union_all_decomposition         # 2.67x on Q15 - OR splitting
  - date_cte_isolation              # 1.2-2.7x - enables partition pruning
  - correlated_to_window            # Eliminates O(n²) in SELECT
  - join_elimination                # Removes unnecessary work
  - scan_consolidation              # Reduces I/O

# Detection hints for prompts
detection_signals:
  correlated_to_precomputed_cte:
    - "Correlated subquery comparing against AVG/SUM of same CTE"
    - "WHERE val > (SELECT AGG(...) FROM cte WHERE correlated)"
    - "Self-referencing CTE with aggregate threshold"
  dimension_filter_hoisting:
    - "Filtered dimension in main_query, unfiltered fact aggregation in CTE"
    - "Table scans show: dim table FILTERED, fact table NO FILTER"
  date_cte_isolation:
    - "Date dimension joined with d_year, d_qoy, d_month_seq filter"
    - "Same date filter in multiple CTEs"
    - "Date filter in main WHERE clause with fact table"
  correlated_to_window:
    - "Correlated subquery in SELECT with AVG/SUM/COUNT"
    - "Aggregate needed alongside row, not just for filtering"
  join_elimination:
    - "Table in FROM but no columns in SELECT"
    - "Join only validates FK existence"
  union_all_decomposition:
    - "Complex OR condition spanning multiple columns"
    - "Full table scan despite selective conditions"
  scan_consolidation:
    - "Same table scanned N× in different CTEs"
    - "Repeated Scans section shows table: N×"
