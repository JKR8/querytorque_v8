## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~500K
    ├── [~] CTE filtered_date  (materialized, 31 rows)
    ├── [~] CTE store_customers  (materialized, 151K rows)
    ├── [~] CTE web_customers  (materialized, 84K rows)
    ├── [~] CTE catalog_customers  (materialized, 332K rows)
    ├── [~] CTE customer_base  (22K rows)
    ├── [~] CTE set_joins  (964 rows)
    ├── [=] AGG (GROUP BY)
    ├── [=] SORT (cd_gender ASC, cd_marital_status ASC, cd_education_status ASC, cd_purchase_estimate ASC, cd_credit_rating ASC)
    └── [=] OUTPUT (cd_gender, cd_marital_status, cd_education_status, cnt1, cd_purchase_estimate, cnt2, cd_credit_rating, cnt3)

CHANGES:
- Replaced correlated EXISTS/NOT EXISTS subqueries with CTE-based decorrelation
- Added MATERIALIZED CTEs for channel customer sets to prevent per-row re-execution
- Converted anti-join semantics to LEFT JOIN / IS NULL pattern (preserving NOT EXISTS logic)
- Maintained exact same filtering conditions across all three channel CTEs
- Preserved all original literal values and guard conditions
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16.11",
  "rewrite_rules": [
    {"id": "R1", "type": "decorrelation", "description": "Replace correlated EXISTS/NOT EXISTS with precomputed CTE sets + LEFT JOIN anti-join", "applied_to": ["filtered_date", "store_customers", "web_customers", "catalog_customers", "set_joins"]},
    {"id": "R2", "type": "materialization", "description": "Add MATERIALIZED keyword to large CTEs to prevent inlining and per-row re-execution", "applied_to": ["store_customers", "web_customers", "catalog_customers"]},
    {"id": "R3", "type": "guard_preservation", "description": "Preserve all original literal values and filter conditions exactly", "applied_to": ["filtered_date", "store_customers", "web_customers", "catalog_customers", "customer_base"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 12",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT ss_customer_sk FROM store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk WHERE ss_list_price BETWEEN 80 AND 169",
        "interfaces": {"outputs": ["ss_customer_sk"], "consumes": ["filtered_date"]}
      },
      "web_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN filtered_date ON ws_sold_date_sk = d_date_sk WHERE ws_list_price BETWEEN 80 AND 169",
        "interfaces": {"outputs": ["ws_bill_customer_sk"], "consumes": ["filtered_date"]}
      },
      "catalog_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales JOIN filtered_date ON cs_sold_date_sk = d_date_sk WHERE cs_list_price BETWEEN 80 AND 169",
        "interfaces": {"outputs": ["cs_ship_customer_sk"], "consumes": ["filtered_date"]}
      },
      "customer_base": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c.c_customer_sk, cd.cd_gender, cd.cd_marital_status, cd.cd_education_status, cd.cd_purchase_estimate, cd.cd_credit_rating FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk WHERE ca.ca_state IN ('CO','NC','TX') AND cd.cd_marital_status IN ('S','M','U') AND cd.cd_education_status IN ('Primary','College')",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": []}
      },
      "set_joins": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cb.cd_gender, cb.cd_marital_status, cb.cd_education_status, cb.cd_purchase_estimate, cb.cd_credit_rating FROM customer_base cb INNER JOIN store_customers sc ON cb.c_customer_sk = sc.ss_customer_sk LEFT JOIN web_customers wc ON cb.c_customer_sk = wc.ws_bill_customer_sk LEFT JOIN catalog_customers cc ON cb.c_customer_sk = cc.cs_ship_customer_sk WHERE wc.ws_bill_customer_sk IS NULL AND cc.cs_ship_customer_sk IS NULL",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["customer_base", "store_customers", "web_customers", "catalog_customers"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM set_joins GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"], "consumes": ["set_joins"]}
      }
    },
    "reconstruction_order": ["filtered_date", "store_customers", "web_customers", "catalog_customers", "customer_base", "set_joins", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), store_customers AS MATERIALIZED ({store_customers}), web_customers AS MATERIALIZED ({web_customers}), catalog_customers AS MATERIALIZED ({catalog_customers}), customer_base AS ({customer_base}), set_joins AS ({set_joins}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

## Changes

Replaced correlated EXISTS/NOT EXISTS subqueries with CTE-based decorrelation using precomputed customer sets for each channel, converted anti-join semantics to LEFT JOIN/IS NULL pattern, and added MATERIALIZED keywords to large channel CTEs to prevent per-row re-execution while preserving exact semantic equivalence.

Expected speedup: 3-5x (eliminates nested-loop correlated subquery execution, enables hash joins on precomputed sets, reduces date_dim scans from per-row to single scan)