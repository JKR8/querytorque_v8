## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [!] date_cte (CTE)  [+]
├── [!] hd_cte (CTE)  [+]
├── [!] cd_cte (CTE)  [+]
├── [!] ca_cte (CTE)  [+]
├── [!] store_cte (CTE)  [+]
├── [!] fact_filtered (CTE)  [+]
│   ├── SCAN store_sales
│   ├── JOIN date_cte ON ss_sold_date_sk = d_date_sk
│   ├── JOIN hd_cte ON ss_hdemo_sk = hd_demo_sk
│   ├── JOIN cd_cte ON ss_cdemo_sk = cd_demo_sk
│   ├── JOIN ca_cte ON ss_addr_sk = ca_address_sk
│   ├── JOIN store_cte ON ss_store_sk = s_store_sk
│   └── FILTER ((ss_sales_price BETWEEN 100.00 AND 150.00) OR ...)
└── [!] final_aggregate (CTE)  [+]
    ├── FROM fact_filtered
    ├── AGGREGATE MIN(ss_quantity), ...
    └── OUTPUT min(ss_quantity), min(ss_ext_sales_price), min(ss_ext_wholesale_cost), min(ss_ext_wholesale_cost)
```

**Change markers:**
- `[!] date_cte (CTE)  [+]`: New CTE isolating date_dim filter for d_year=2001
- `[!] hd_cte (CTE)  [+]`: New CTE isolating household_demographics filter for hd_dep_count in (3,1)
- `[!] cd_cte (CTE)  [+]`: New CTE isolating customer_demographics filter for marital/education combinations
- `[!] ca_cte (CTE)  [+]`: New CTE isolating customer_address filter for country and state/profit conditions
- `[!] store_cte (CTE)  [+]`: New CTE selecting all stores (no filter)
- `[!] fact_filtered (CTE)  [+]`: New CTE joining all dimension CTEs and applying ss_sales_price OR filter
- `[!] final_aggregate (CTE)  [+]`: New CTE performing the four MIN aggregates

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefetch", "description": "Pre-filter all dimension tables into CTEs before joining to fact table", "applied_to": ["date_cte", "hd_cte", "cd_cte", "ca_cte", "store_cte"]},
    {"id": "R2", "type": "explicit_join_syntax", "description": "Convert comma-separated implicit joins to explicit INNER JOIN syntax", "applied_to": ["fact_filtered"]},
    {"id": "R3", "type": "cte_aggregation_isolation", "description": "Isolate final aggregation in separate CTE for clear separation of concerns", "applied_to": ["final_aggregate"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "hd_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE (hd_dep_count = 3) OR (hd_dep_count = 1)",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "cd_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd_demo_sk FROM customer_demographics WHERE ((cd_marital_status = 'M' AND cd_education_status = '2 yr Degree') OR (cd_marital_status = 'S' AND cd_education_status = 'Primary') OR (cd_marital_status = 'W' AND cd_education_status = 'Primary'))",
        "interfaces": {"outputs": ["cd_demo_sk"], "consumes": []}
      },
      "ca_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_country = 'United States' AND ((ca_state IN ('GA', 'KY', 'SD')) OR (ca_state IN ('AR', 'IN', 'VA')) OR (ca_state IN ('KS', 'OH', 'SD')))",
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s_store_sk FROM store",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "fact_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost, ss_net_profit, ca_state FROM store_sales INNER JOIN date_cte ON ss_sold_date_sk = date_cte.d_date_sk INNER JOIN hd_cte ON ss_hdemo_sk = hd_cte.hd_demo_sk INNER JOIN cd_cte ON ss_cdemo_sk = cd_cte.cd_demo_sk INNER JOIN ca_cte ON ss_addr_sk = ca_cte.ca_address_sk INNER JOIN store_cte ON ss_store_sk = store_cte.s_store_sk WHERE ((ss_sales_price BETWEEN 100.00 AND 150.00) OR (ss_sales_price BETWEEN 50.00 AND 100.00) OR (ss_sales_price BETWEEN 150.00 AND 200.00)) AND ((ca_state IN ('GA', 'KY', 'SD') AND ss_net_profit BETWEEN 100 AND 200) OR (ca_state IN ('AR', 'IN', 'VA') AND ss_net_profit BETWEEN 150 AND 300) OR (ca_state IN ('KS', 'OH', 'SD') AND ss_net_profit BETWEEN 50 AND 250))",
        "interfaces": {"outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"], "consumes": ["date_cte", "hd_cte", "cd_cte", "ca_cte", "store_cte"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT MIN(ss_quantity) AS min_ss_quantity, MIN(ss_ext_sales_price) AS min_ss_ext_sales_price, MIN(ss_ext_wholesale_cost) AS min_ss_ext_wholesale_cost, MIN(ss_ext_wholesale_cost) AS min_ss_ext_wholesale_cost_duplicate FROM fact_filtered",
        "interfaces": {"outputs": ["min_ss_quantity", "min_ss_ext_sales_price", "min_ss_ext_wholesale_cost", "min_ss_ext_wholesale_cost_duplicate"], "consumes": ["fact_filtered"]}
      }
    },
    "reconstruction_order": ["date_cte", "hd_cte", "cd_cte", "ca_cte", "store_cte", "fact_filtered", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), hd_cte AS ({hd_cte}), cd_cte AS ({cd_cte}), ca_cte AS ({ca_cte}), store_cte AS ({store_cte}), fact_filtered AS ({fact_filtered}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL effective_cache_size = '4GB'",
    "SET LOCAL work_mem = '16MB'",
    "SET LOCAL hash_mem_multiplier = 2.0",
    "SET LOCAL enable_nestloop = off"
  ],
  "validation_checks": []
}
```

**Changes:** The rewrite transforms implicit comma joins into explicit INNER JOINs and prefilters all dimension tables into CTEs, creating tiny hash tables for PostgreSQL to probe efficiently. The original OR conditions are preserved exactly, maintaining semantic equivalence.

**Expected speedup:** 2.0-3.0x due to better hash join planning with pre-materialized small dimension results and explicit join syntax enabling optimal join order selection.