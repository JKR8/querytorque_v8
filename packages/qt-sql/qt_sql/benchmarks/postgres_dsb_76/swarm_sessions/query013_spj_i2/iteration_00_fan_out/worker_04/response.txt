## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~168K
    ├── [~] date_cte  [=]  Filter: d_year = 2001
    ├── [~] hd_cte  [=]  Filter: (hd_dep_count = 3) OR (hd_dep_count = 1)
    ├── [~] cd_cte  [=]  Filter: ((cd_marital_status = 'M' AND cd_education_status = '2 yr Degree') OR (cd_marital_status = 'S' AND cd_education_status = 'Primary') OR (cd_marital_status = 'W' AND cd_education_status = 'Primary'))
    ├── [~] ca_cte  [=]  Filter: ca_country = 'United States' AND ca_state IN ('GA', 'KY', 'SD', 'AR', 'IN', 'VA', 'KS', 'OH', 'SD')
    ├── [~] store_cte  [=]  No filter
    ├── [~] fact_filtered  [~]  Explicit joins + sales price OR filter
    ├── [~] union_branches  [+]  Split address/profit OR into UNION ALL
    └── [~] final_aggregate  [=]  MIN aggregates
```

**Key changes:**
1. **fact_filtered**: Changed from comma joins to explicit INNER JOINs with CTEs
2. **union_branches**: Added new node to split address/profit OR conditions into UNION ALL
3. **CTE structure**: Added all dimension prefetch CTEs

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "pg_dimension_prefetch_star",
      "description": "Pre-filter selective dimensions into CTEs for better cardinality estimates",
      "applied_to": ["date_cte", "hd_cte", "cd_cte", "ca_cte", "store_cte", "fact_filtered"]
    },
    {
      "id": "R2",
      "type": "or_to_union",
      "description": "Split address/profit OR conditions into UNION ALL for independent filtering",
      "applied_to": ["union_branches"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "date_cte": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "hd_cte": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT hd_demo_sk FROM household_demographics WHERE (hd_dep_count = 3) OR (hd_dep_count = 1)",
          "interfaces": {
            "outputs": ["hd_demo_sk"],
            "consumes": []
          }
        },
        "cd_cte": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT cd_demo_sk FROM customer_demographics WHERE ((cd_marital_status = 'M' AND cd_education_status = '2 yr Degree') OR (cd_marital_status = 'S' AND cd_education_status = 'Primary') OR (cd_marital_status = 'W' AND cd_education_status = 'Primary'))",
          "interfaces": {
            "outputs": ["cd_demo_sk"],
            "consumes": []
          }
        },
        "ca_cte": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_country = 'United States' AND ca_state IN ('GA', 'KY', 'SD', 'AR', 'IN', 'VA', 'KS', 'OH', 'SD')",
          "interfaces": {
            "outputs": ["ca_address_sk"],
            "consumes": []
          }
        },
        "store_cte": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT s_store_sk FROM store",
          "interfaces": {
            "outputs": ["s_store_sk"],
            "consumes": []
          }
        },
        "fact_filtered": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT ss.ss_quantity, ss.ss_ext_sales_price, ss.ss_ext_wholesale_cost, ss.ss_net_profit, ca.ca_state FROM store_sales ss INNER JOIN date_cte d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN hd_cte hd ON ss.ss_hdemo_sk = hd.hd_demo_sk INNER JOIN cd_cte cd ON ss.ss_cdemo_sk = cd.cd_demo_sk INNER JOIN ca_cte ca ON ss.ss_addr_sk = ca.ca_address_sk INNER JOIN store_cte s ON ss.ss_store_sk = s.s_store_sk WHERE ((ss.ss_sales_price BETWEEN 100.00 AND 150.00) OR (ss.ss_sales_price BETWEEN 50.00 AND 100.00) OR (ss.ss_sales_price BETWEEN 150.00 AND 200.00))",
          "interfaces": {
            "outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost", "ss_net_profit", "ca_state"],
            "consumes": ["date_cte", "hd_cte", "cd_cte", "ca_cte", "store_cte"]
          }
        },
        "union_branches": {
          "type": "cte",
          "change": "new",
          "sql": "(SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM fact_filtered WHERE ca_state IN ('GA','KY','SD') AND ss_net_profit BETWEEN 100 AND 200) UNION ALL (SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM fact_filtered WHERE ca_state IN ('AR','IN','VA') AND ss_net_profit BETWEEN 150 AND 300) UNION ALL (SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM fact_filtered WHERE ca_state IN ('KS','OH','SD') AND ss_net_profit BETWEEN 50 AND 250)",
          "interfaces": {
            "outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"],
            "consumes": ["fact_filtered"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT MIN(ss_quantity), MIN(ss_ext_sales_price), MIN(ss_ext_wholesale_cost), MIN(ss_ext_wholesale_cost) FROM union_branches",
          "interfaces": {
            "outputs": ["min(ss_quantity)", "min(ss_ext_sales_price)", "min(ss_ext_wholesale_cost)", "min(ss_ext_wholesale_cost)"],
            "consumes": ["union_branches"]
          }
        }
      },
      "reconstruction_order": ["date_cte", "hd_cte", "cd_cte", "ca_cte", "store_cte", "fact_filtered", "union_branches", "main_query"],
      "assembly_template": "WITH date_cte AS ({date_cte}), hd_cte AS ({hd_cte}), cd_cte AS ({cd_cte}), ca_cte AS ({ca_cte}), store_cte AS ({store_cte}), fact_filtered AS ({fact_filtered}), union_branches AS ({union_branches}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL enable_mergejoin = off",
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL work_mem = '32MB'",
    "SET LOCAL hash_mem_multiplier = 2.0"
  ],
  "validation_checks": []
}
```

**Changes:** 1) Dimension prefetch CTEs create small hash tables for better join planning. 2) UNION ALL splits the address/profit OR conditions, allowing independent filtering per branch. 3) Explicit JOIN syntax gives optimizer better control over join order.

**Expected speedup:** ~3-4x from dimension prefetch + ~1.5x from UNION ALL splitting = total ~4.5-6x speedup. The UNION ALL allows each branch to use its own filters independently, while dimension CTEs give accurate row estimates for hash joins.

**Runtime config justification:** 
- `enable_hashjoin = on`: Hash joins optimal for small dimension CTEs
- `enable_mergejoin = off`: No merge benefits with random access
- `enable_nestloop = off`: Large fact table makes nested loops inefficient
- `work_mem = '32MB'`: For hash table builds from small CTEs (store_cte: 102 rows, date_cte: 122 rows)
- `hash_mem_multiplier = 2.0`: Extra headroom for hash operations