# DIAGNOSE: Why 1.23x fell short

The best attempt (W2) achieved only 1.23x because it still suffers from **non-equi join blindness** despite some pre-filtering. The execution plan reveals:

1. **Premature hash join explosion**: The query joins `web_sales` (482K rows) with `customer` (22K rows) BEFORE applying the crucial date range filter (`d2.d_date BETWEEN d1.d_date AND d1.d_date + 30 days`). This creates a massive intermediate result (1383 rows) that then probes `store_sales` via nested loops.

2. **Missing critical pre-filter**: The `ws_wholesale_cost BETWEEN 76 AND 96` filter isn't pushed into the initial web_sales scan in CTEs. It's applied late in the main join.

3. **Inefficient date range handling**: The date range condition is evaluated late in nested loops instead of being used to pre-filter web_sales dates relative to store_sales dates.

4. **Suboptimal join order**: The plan joins store_sales LAST via index scan, causing repeated random I/O instead of hash joins.

# IDENTIFY: Unexplored optimization angles

1. **Pre-compute date windows**: Create a CTE that pairs store_sales dates (1998 only) with their 30-day windows, then use this to pre-filter web_sales by date range BEFORE joining to customer.

2. **Stage-wise fact table reduction**: Filter BOTH fact tables separately before the expensive multi-way join:
   - Store_sales: join with filtered items, filtered customers, 1998 dates, inventory, warehouse, store
   - Web_sales: join with same filtered items, filtered customers, and pre-computed date windows
   - THEN join the two pre-aggregated results

3. **Eliminate redundant customer joins**: Since both fact tables use the same customer filter, we can compute customer demographics once and reuse.

4. **Aggregate early**: Since we're just counting matches, we can aggregate at the customer-item level before the final join.

# REWRITE: Staged reduction with date window pre-computation

## Modified Logic Tree

```
[+] dim_item: (unchanged from best)
[+] dim_customer: (unchanged from best)  
[+] dim_date_1998: (unchanged from best)
[+] store_sales_base: store_sales filtered by dim_item, dim_customer, dim_date_1998
    - Also joins inventory, warehouse, store for state equality
    - Filters: inv_quantity_on_hand >= ss_quantity
[+] date_windows: For each store_sales date, compute date range window
[+] web_sales_base: web_sales filtered by dim_item, dim_customer, date_windows, wholesale_cost
[+] matched_pairs: Join store_sales_base and web_sales_base on item+customer
[+] main_query: Aggregate demographics from matched_pairs
```

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "staged_reduction", "description": "Pre-filter both fact tables separately before expensive join", "applied_to": ["store_sales_base", "web_sales_base"]},
    {"id": "R2", "type": "date_window_precompute", "description": "Compute date windows from store_sales to pre-filter web_sales", "applied_to": ["date_windows", "web_sales_base"]},
    {"id": "R3", "type": "early_aggregation", "description": "Aggregate at customer-item level before final demographic grouping", "applied_to": ["matched_pairs"]},
    {"id": "R4", "type": "explicit_join_syntax", "description": "Convert comma joins to explicit JOINs for better planning", "applied_to": ["store_sales_base", "web_sales_base", "matched_pairs"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "dim_item": {
        "type": "cte",
        "change": "unchanged",
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Men', 'Shoes', 'Sports') AND i_manager_id IN (6, 11, 16, 17, 19, 28, 47, 82, 88, 98)",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "dim_customer": {
        "type": "cte", 
        "change": "unchanged",
        "sql": "SELECT c_customer_sk, cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count FROM customer JOIN customer_address ON c_current_addr_sk = ca_address_sk JOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk WHERE ca_state IN ('AR', 'CA', 'KS', 'NY', 'VA')",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count"], "consumes": []}
      },
      "dim_date_1998": {
        "type": "cte",
        "change": "unchanged", 
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_year = 1998",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "store_sales_base": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss.ss_item_sk, ss.ss_customer_sk, dc.cd_gender, dc.cd_marital_status, dc.cd_education_status, dc.hd_vehicle_count, dd.d_date FROM store_sales ss JOIN dim_item di ON ss.ss_item_sk = di.i_item_sk JOIN dim_customer dc ON ss.ss_customer_sk = dc.c_customer_sk JOIN dim_date_1998 dd ON ss.ss_sold_date_sk = dd.d_date_sk JOIN inventory inv ON inv.inv_item_sk = ss.ss_item_sk AND inv.inv_date_sk = ss.ss_sold_date_sk JOIN warehouse w ON w.w_warehouse_sk = inv.inv_warehouse_sk JOIN store s ON s.s_state = w.w_state WHERE inv.inv_quantity_on_hand >= ss.ss_quantity",
        "interfaces": {"outputs": ["ss_item_sk", "ss_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "d_date"], "consumes": ["dim_item", "dim_customer", "dim_date_1998"]}
      },
      "date_windows": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_item_sk, ss_customer_sk, cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, d_date, d_date + INTERVAL '30 day' AS window_end FROM store_sales_base",
        "interfaces": {"outputs": ["ss_item_sk", "ss_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "d_date", "window_end"], "consumes": ["store_sales_base"]}
      },
      "web_sales_base": {
        "type": "cte", 
        "change": "new",
        "sql": "SELECT ws.ws_item_sk, ws.ws_bill_customer_sk FROM web_sales ws JOIN dim_item di ON ws.ws_item_sk = di.i_item_sk JOIN dim_customer dc ON ws.ws_bill_customer_sk = dc.c_customer_sk JOIN date_dim d2 ON ws.ws_sold_date_sk = d2.d_date_sk JOIN date_windows dw ON ws.ws_item_sk = dw.ss_item_sk AND ws.ws_bill_customer_sk = dw.ss_customer_sk AND d2.d_date BETWEEN dw.d_date AND dw.window_end WHERE ws.ws_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {"outputs": ["ws_item_sk", "ws_bill_customer_sk"], "consumes": ["dim_item", "dim_customer", "date_windows"]}
      },
      "matched_pairs": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT dw.cd_gender, dw.cd_marital_status, dw.cd_education_status, dw.hd_vehicle_count FROM date_windows dw JOIN web_sales_base wb ON dw.ss_item_sk = wb.ws_item_sk AND dw.ss_customer_sk = wb.ws_bill_customer_sk",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count"], "consumes": ["date_windows", "web_sales_base"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM matched_pairs GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "cnt"], "consumes": ["matched_pairs"]}
      }
    },
    "reconstruction_order": ["dim_item", "dim_customer", "dim_date_1998", "store_sales_base", "date_windows", "web_sales_base", "matched_pairs", "main_query"],
    "assembly_template": "WITH dim_item AS ({dim_item}), dim_customer AS ({dim_customer}), dim_date_1998 AS ({dim_date_1998}), store_sales_base AS ({store_sales_base}), date_windows AS ({date_windows}), web_sales_base AS ({web_sales_base}), matched_pairs AS ({matched_pairs}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '512MB'", "SET LOCAL enable_nestloop = off", "SET LOCAL enable_hashjoin = on", "SET LOCAL enable_mergejoin = off"],
  "validation_checks": []
}
```

**Changes**: Staged reduction pre-filters both fact tables separately using date windows to eliminate the expensive nested-loop date range check. The store_sales path includes all necessary joins (inventory, warehouse, store) early, while web_sales is filtered by the pre-computed date windows and wholesale cost.

**Expected speedup**: 2.5-3.0x by eliminating the massive intermediate hash join and nested-loop index scans, replacing them with two streamlined hash join pipelines.