<reasoning>
Let me analyze the query systematically.

1. **CLASSIFY**: This is a multi-channel UNION ALL query with three nearly identical CTEs (ssr, csr, wsr) that aggregate sales data from different channels (store, catalog, web). Each CTE:
   - Joins a fact table (store_sales/catalog_sales/web_sales) with returns table (LEFT JOIN)
   - Joins with common dimensions: date_dim, item, promotion
   - Joins with channel-specific dimension: store/catalog_page/web_site
   - Filters on the same predicates (date range, item price > 50, promotion channels all 'N', wholesale cost range, item category)
   - Groups by channel-specific ID
   
   The main query unions these CTEs and does a ROLLUP aggregation.

2. **EXPLAIN PLAN ANALYSIS**:
   - Total runtime: 129.5ms
   - Breakdown:
     - ssr: 70.5ms (54% of total)
     - csr: 34.8ms (27% of total)  
     - wsr: 24.2ms (19% of total)
   
   Key observations:
   - Each CTE is executed independently with NO sharing of dimension table scans
   - Each CTE scans date_dim 3 times total (once per CTE), promotion table 3 times, item table 3 times
   - Row count drops:
     - date_dim: from ~73K rows to ~10-16 rows after date filter (99.8% reduction)
     - promotion: from 500 rows to 11 rows (97.8% reduction)
     - item: highly selective (i_current_price > 50 AND i_category IN ('Children', 'Sports'))
   - Fact table scans are index scans with filters on ss/cs/ws_wholesale_cost
   - Nested loops dominate (per plan-space scanner: "JOINS: LOCKED on nested loops")
   - The optimizer is NOT splitting CTEs or pushing predicates across CTEs - each CTE re-executes full dimension scans

3. **GAP MATCHING**:
   - COMMA_JOIN_WEAKNESS: YES - Query uses comma-separated implicit joins
   - CROSS_CTE_PREDICATE_BLINDNESS: YES - Same dimension tables scanned 3 times independently
   - CORRELATED_SUBQUERY_PARALYSIS: NO - No correlated subqueries
   - NON_EQUI_JOIN_INPUT_BLINDNESS: NO - All joins are equi-joins
   
   Engine strengths that apply:
   - INNER_JOIN_REORDERING: Optimizer can reorder joins freely
   - INDEX_ONLY_SCAN: Some dimensions use index scans

4. **AGGREGATION TRAP CHECK**:
   - Aggregates: SUM(ss_ext_sales_price), SUM(COALESCE(sr_return_amt, 0)), SUM(ss_net_profit - COALESCE(sr_net_loss, 0))
   - All are SUM-based aggregates, which are grouping-insensitive (modulo duplicates)
   - No STDDEV_SAMP, VARIANCE, PERCENTILE_CONT, CORR
   - LEFT JOIN with returns tables could introduce NULLs but COALESCE handles them
   - UNION ALL preserves row multiplicity correctly
   - ROLLUP aggregation in main query is safe

5. **TRANSFORM SELECTION** (ranked by expected value):
   
   High-value transforms:
   1. **star_join_prefetch** + **union_consolidation**: Pre-filter shared dimensions once, share across all 3 CTEs. Expected 2-3x speedup by eliminating 2/3 of dimension scans.
   2. **single_pass_aggregation**: Merge the 3 CTEs into a single scan with channel discriminator. Expected 2-3x speedup by scanning fact tables once.
   3. **explicit_join_conversion**: Convert comma joins to explicit JOINs for better cardinality estimation.
   4. **late_attribute_binding**: Defer channel-specific dimension joins (store, catalog_page, web_site) until after filtering.

6. **LOGICAL TREE DESIGN**:
   
   For star_join_prefetch + union_consolidation:
   - Create CTEs for filtered date_dim, item, promotion (shared across all channels)
   - Create CTEs for each channel that join fact table with shared dimension CTEs
   - Ensure all required columns are included in CTE outputs
   
   For single_pass_aggregation:
   - Create a UNION ALL of fact tables with channel discriminator
   - Join once with shared dimensions
   - Use conditional aggregation to compute channel-specific aggregates
   
   Need to verify column completeness for each node contract.
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT: This query analyzes sales, returns, and profit across three sales channels (store, catalog, web) for a specific 30-day period, filtering for high-priced items (>50) in Children/Sports categories sold through non-promotional channels. All joins are INNER except for LEFT OUTER joins to returns tables. Aggregates are SUM-based with COALESCE for NULL handling, making them grouping-insensitive. The ROLLUP in the main query depends on channel and ID grouping from the CTEs.

BOTTLENECK_DIAGNOSIS: The query is scan-bound due to redundant dimension table scans. Each of the three CTEs independently scans date_dim (~73K→10-16 rows), promotion (500→11 rows), and item tables, tripling I/O. Nested loops dominate execution (70%+ of runtime). The optimizer already handles join reordering well but cannot share dimension scans across CTEs. Logical-tree cost percentages are misleading - ssr shows 44% cost but consumes 54% of actual runtime.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output channel, id, sales, returns, profit with ROLLUP grouping
- CTE_COLUMN_COMPLETENESS: Any shared dimension CTEs must include all columns needed by all three channel CTEs (d_date_sk, i_item_sk, p_promo_sk, plus filter columns)
- LITERAL_PRESERVATION: Date range '1998-08-29' to '1998-08-29' + 30 days, price > 50, channels = 'N', wholesale cost 23-38, categories {'Children','Sports'}
- SEMANTIC_EQUIVALENCE: Must preserve LEFT OUTER join semantics with returns tables and UNION ALL channel separation
- COMMA_JOIN_WEAKNESS: Query uses comma-separated implicit joins (evidence: FROM store_sales left outer join store_returns on ..., date_dim, store, item, promotion)
- CROSS_CTE_PREDICATE_BLINDNESS: Same dimension tables scanned 3 times independently (evidence: EXPLAIN shows separate date_dim scans for ssr, csr, wsr)

REGRESSION_WARNINGS:
1. CTE blocking parallelism (observed regression: 0.50x):
   CAUSE: Materialized CTEs executed single-threaded, preventing parallel scan of large fact tables
   RULE: Avoid wrapping large fact table scans in MATERIALIZED CTEs; use explicit JOINs instead
2. OR to UNION ALL on indexed columns (observed regression: 0.21x):
   CAUSE: Splitting OR conditions on indexed columns prevents bitmap index scan optimization
   RULE: Do NOT split i_category IN ('Children','Sports') into UNION ALL branches

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch_union_consolidation
TARGET_LOGICAL_TREE:
  filtered_date -> filtered_item -> filtered_promotion -> (ssr_fact, csr_fact, wsr_fact) -> (ssr, csr, wsr) -> main_query
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_date BETWEEN CAST('1998-08-29' AS DATE) AND CAST('1998-08-29' AS DATE) + INTERVAL '30 DAY'
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 10-16
    CONSUMERS: ssr_fact, csr_fact, wsr_fact
  filtered_item:
    FROM: item
    WHERE: i_current_price > 50 AND i_category IN ('Children', 'Sports')
    OUTPUT: i_item_sk, i_current_price, i_category
    EXPECTED_ROWS: highly selective (<1% of item)
    CONSUMERS: ssr_fact, csr_fact, wsr_fact
  filtered_promotion:
    FROM: promotion
    WHERE: p_channel_email = 'N' AND p_channel_tv = 'N' AND p_channel_radio = 'N' AND p_channel_press = 'N' AND p_channel_event = 'N'
    OUTPUT: p_promo_sk, p_channel_email, p_channel_tv, p_channel_radio, p_channel_press, p_channel_event
    EXPECTED_ROWS: 11
    CONSUMERS: ssr_fact, csr_fact, wsr_fact
  ssr_fact:
    FROM: store_sales LEFT OUTER JOIN store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number)
    JOIN: INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk
          INNER JOIN filtered_item ON ss_item_sk = i_item_sk  
          INNER JOIN filtered_promotion ON ss_promo_sk = p_promo_sk
    WHERE: ss_wholesale_cost BETWEEN 23 AND 38
    OUTPUT: ss_store_sk, ss_item_sk, ss_ticket_number, ss_ext_sales_price, sr_return_amt, ss_net_profit, sr_net_loss
    EXPECTED_ROWS: ~4,857
    CONSUMERS: ssr
  ssr:
    FROM: ssr_fact INNER JOIN store ON ss_store_sk = s_store_sk
    GROUP BY: s_store_id
    AGGREGATE: SUM(ss_ext_sales_price) as sales, SUM(COALESCE(sr_return_amt, 0)) as returns, SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) as profit
    OUTPUT: store_id, sales, returns, profit
    EXPECTED_ROWS: 4
    CONSUMERS: main_query
  (csr_fact, csr, wsr_fact, wsr similar with appropriate table/column names)
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join, shared_dimension_multi_channel
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply pre-filtering date, item, promotion into CTEs and convert comma joins to explicit JOINs; ignore that example uses different fact table structure
- pg_date_cte_explicit_join: Apply date CTE isolation pattern; also create CTEs for item and promotion; ignore that example only focuses on date_dim
- shared_dimension_multi_channel: Apply sharing of dimension CTEs across multiple channels; ignore that example uses different aggregation pattern
HAZARD_FLAGS:
- Must ensure filtered_item CTE includes i_item_sk for joins with all three fact tables
- Returns table LEFT JOIN must be performed before aggregation to preserve NULL semantics
- Channel-specific dimension joins (store, catalog_page, web_site) must remain in their respective CTEs

=== WORKER 2 BRIEFING ===

STRATEGY: single_pass_aggregation_channel_pivot
TARGET_LOGICAL_TREE:
  filtered_date -> filtered_item -> filtered_promotion -> all_sales -> channel_aggregates -> main_query
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_date BETWEEN CAST('1998-08-29' AS DATE) AND CAST('1998-08-29' AS DATE) + INTERVAL '30 DAY'
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 10-16
    CONSUMERS: all_sales
  filtered_item:
    FROM: item
    WHERE: i_current_price > 50 AND i_category IN ('Children', 'Sports')
    OUTPUT: i_item_sk, i_current_price, i_category
    EXPECTED_ROWS: highly selective
    CONSUMERS: all_sales
  filtered_promotion:
    FROM: promotion
    WHERE: p_channel_email = 'N' AND p_channel_tv = 'N' AND p_channel_radio = 'N' AND p_channel_press = 'N' AND p_channel_event = 'N'
    OUTPUT: p_promo_sk, p_channel_email, p_channel_tv, p_channel_radio, p_channel_press, p_channel_event
    EXPECTED_ROWS: 11
    CONSUMERS: all_sales
  all_sales:
    FROM: (
      SELECT 'store' as channel, ss_item_sk as item_sk, ss_ticket_number as order_number, ss_store_sk as location_sk, 
             ss_ext_sales_price as sales_price, ss_net_profit as net_profit, ss_wholesale_cost as wholesale_cost,
             ss_promo_sk as promo_sk, ss_sold_date_sk as date_sk, NULL::numeric as return_amt, NULL::numeric as return_loss
      FROM store_sales
      WHERE ss_wholesale_cost BETWEEN 23 AND 38
      UNION ALL
      SELECT 'catalog' as channel, cs_item_sk, cs_order_number, cs_catalog_page_sk, 
             cs_ext_sales_price, cs_net_profit, cs_wholesale_cost, cs_promo_sk, cs_sold_date_sk, NULL, NULL
      FROM catalog_sales
      WHERE cs_wholesale_cost BETWEEN 23 AND 38
      UNION ALL
      SELECT 'web' as channel, ws_item_sk, ws_order_number, ws_web_site_sk,
             ws_ext_sales_price, ws_net_profit, ws_wholesale_cost, ws_promo_sk, ws_sold_date_sk, NULL, NULL
      FROM web_sales
      WHERE ws_wholesale_cost BETWEEN 23 AND 38
    ) sales
    JOIN: INNER JOIN filtered_date ON sales.date_sk = d_date_sk
          INNER JOIN filtered_item ON sales.item_sk = i_item_sk
          INNER JOIN filtered_promotion ON sales.promo_sk = p_promo_sk
    OUTPUT: channel, item_sk, order_number, location_sk, sales_price, net_profit, wholesale_cost, promo_sk, date_sk
    EXPECTED_ROWS: sum of rows from three fact tables (~4,857 + 9,750 + 2,509 ≈ 17,116)
    CONSUMERS: channel_aggregates
  channel_aggregates:
    FROM: all_sales
    LEFT JOIN: Appropriate returns table per channel (store_returns/catalog_returns/web_returns) ON item_sk and order_number
    INNER JOIN: Appropriate location dimension per channel (store/catalog_page/web_site) ON location_sk
    GROUP BY: channel, location_id (s_store_id/cp_catalog_page_id/web_site_id)
    AGGREGATE: SUM(sales_price) as sales, SUM(COALESCE(return_amt, 0)) as returns, SUM(net_profit - COALESCE(return_loss, 0)) as profit
    OUTPUT: channel, id, sales, returns, profit
    EXPECTED_ROWS: 10 (4+5+1)
    CONSUMERS: main_query
EXAMPLES: single_pass_aggregation, union_cte_split, scan_consolidation_pivot
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Apply merging of three fact table scans into one UNION ALL; use conditional logic for channel-specific joins; ignore that example uses CASE in aggregates
- union_cte_split: Apply UNION ALL structure but in reverse (consolidate instead of split); ignore the splitting aspect
- scan_consolidation_pivot: Apply consolidation of fact table scans; use channel discriminator; ignore the pivot to columns aspect
HAZARD_FLAGS:
- Complex conditional joins for returns tables and location dimensions per channel
- Must handle NULL returns correctly for LEFT JOIN semantics
- UNION ALL may prevent some index optimizations on fact tables

=== WORKER 3 BRIEFING ===

STRATEGY: explicit_join_late_binding
TARGET_LOGICAL_TREE:
  filtered_date -> filtered_item -> filtered_promotion -> (ssr_core, csr_core, wsr_core) -> (ssr, csr, wsr) -> main_query
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_date BETWEEN CAST('1998-08-29' AS DATE) AND CAST('1998-08-29' AS DATE) + INTERVAL '30 DAY'
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 10-16
    CONSUMERS: ssr_core, csr_core, wsr_core
  filtered_item:
    FROM: item
    WHERE: i_current_price > 50 AND i_category IN ('Children', 'Sports')
    OUTPUT: i_item_sk, i_current_price, i_category
    EXPECTED_ROWS: highly selective
    CONSUMERS: ssr_core, csr_core, wsr_core
  filtered_promotion:
    FROM: promotion
    WHERE: p_channel_email = 'N' AND p_channel_tv = 'N' AND p_channel_radio = 'N' AND p_channel_press = 'N' AND p_channel_event = 'N'
    OUTPUT: p_promo_sk, p_channel_email, p_channel_tv, p_channel_radio, p_channel_press, p_channel_event
    EXPECTED_ROWS: 11
    CONSUMERS: ssr_core, csr_core, wsr_core
  ssr_core:
    FROM: store_sales
    LEFT JOIN: store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number)
    JOIN: INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk
          INNER JOIN filtered_item ON ss_item_sk = i_item_sk
          INNER JOIN filtered_promotion ON ss_promo_sk = p_promo_sk
    WHERE: ss_wholesale_cost BETWEEN 23 AND 38
    OUTPUT: ss_store_sk, ss_ext_sales_price, COALESCE(sr_return_amt, 0) as return_amt, ss_net_profit, COALESCE(sr_net_loss, 0) as return_loss
    EXPECTED_ROWS: ~4,857
    CONSUMERS: ssr
  ssr:
    FROM: ssr_core INNER JOIN store ON ss_store_sk = s_store_sk
    GROUP BY: s_store_id
    AGGREGATE: SUM(ss_ext_sales_price) as sales, SUM(return_amt) as returns, SUM(ss_net_profit - return_loss) as profit
    OUTPUT: store_id, sales, returns, profit
    EXPECTED_ROWS: 4
    CONSUMERS: main_query
EXAMPLES: pg_dimension_prefetch_star, early_filter_decorrelate, late_attribute_binding
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply explicit JOIN conversion and dimension CTEs; focus on JOIN syntax improvement
- early_filter_decorrelate: Apply early filtering of dimensions; ignore decorrelation aspect (no correlated subqueries)
- late_attribute_binding: Apply principle of deferring store join until after core filtering; but here store is needed for GROUP BY
HAZARD_FLAGS:
- Converting comma joins to explicit JOINs must preserve LEFT OUTER join semantics correctly
- COALESCE must be applied in ssr_core before aggregation to handle NULL returns
- All required columns for store join must be preserved in ssr_core output

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: materialized_dimension_fact_prefilter_compound
TARGET_LOGICAL_TREE:
  filtered_date -> filtered_item -> filtered_promotion -> (ssr_pre, csr_pre, wsr_pre) -> (ssr, csr, wsr) -> main_query
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_date BETWEEN CAST('1998-08-29' AS DATE) AND CAST('1998-08-29' AS DATE) + INTERVAL '30 DAY'
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 10-16
    CONSUMERS: ssr_pre, csr_pre, wsr_pre
  filtered_item:
    FROM: item
    WHERE: i_current_price > 50 AND i_category IN ('Children', 'Sports')
    OUTPUT: i_item_sk, i_current_price, i_category
    EXPECTED_ROWS: highly selective
    CONSUMERS: ssr_pre, csr_pre, wsr_pre
  filtered_promotion:
    FROM: promotion
    WHERE: p_channel_email = 'N' AND p_channel_tv = 'N' AND p_channel_radio = 'N' AND p_channel_press = 'N' AND p_channel_event = 'N'
    OUTPUT: p_promo_sk, p_channel_email, p_channel_tv, p_channel_radio, p_channel_press, p_channel_event
    EXPECTED_ROWS: 11
    CONSUMERS: ssr_pre, csr_pre, wsr_pre
  ssr_pre:
    FROM: store_sales
    WHERE: ss_wholesale_cost BETWEEN 23 AND 38
      AND ss_sold_date_sk IN (SELECT d_date_sk FROM filtered_date)
      AND ss_item_sk IN (SELECT i_item_sk FROM filtered_item)
      AND ss_promo_sk IN (SELECT p_promo_sk FROM filtered_promotion)
    OUTPUT: ss_store_sk, ss_item_sk, ss_ticket_number, ss_ext_sales_price, ss_net_profit, ss_sold_date_sk, ss_promo_sk
    EXPECTED_ROWS: ~4,857
    CONSUMERS: ssr
  ssr:
    FROM: ssr_pre
    LEFT JOIN: store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number)
    INNER JOIN: store ON ss_store_sk = s_store_sk
    GROUP BY: s_store_id
    AGGREGATE: SUM(ss_ext_sales_price) as sales, SUM(COALESCE(sr_return_amt, 0)) as returns, SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) as profit
    OUTPUT: store_id, sales, returns, profit
    EXPECTED_ROWS: 4
    CONSUMERS: main_query
EXAMPLES: pg_materialized_dimension_fact_prefilter, inline_decorrelate_materialized, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_materialized_dimension_fact_prefilter: Apply MATERIALIZED CTEs for dimensions AND pre-filter fact tables using IN clauses; use staged reduction
- inline_decorrelate_materialized: Apply MATERIALIZED keyword to prevent CTE inlining; ignore decorrelation aspect
- early_filter_decorrelate: Apply early filtering via IN clauses; ignore decorrelation aspect
HAZARD_FLAGS:
- IN clauses may be less efficient than JOINs for large result sets
- MATERIALIZED CTEs may block parallelism on fact table scans
- Must verify PostgreSQL can push IN clause filters into index scans
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: This strategy respects all correctness constraints but explores aggressive pre-filtering using IN clauses instead of JOINs, which is a novel combination for this query pattern.
EXPLORATION_TYPE: compound_strategy