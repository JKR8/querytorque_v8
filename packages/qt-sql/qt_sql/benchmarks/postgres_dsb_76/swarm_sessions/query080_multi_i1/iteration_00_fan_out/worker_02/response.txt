### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_date  [+]
│   ├── SCAN date_dim
│   ├── FILTER (d_date BETWEEN '1998-08-29' AND '1998-08-29' + 30 days)
│   └── OUTPUT (d_date_sk, d_date)
├── [CTE] filtered_item  [+]
│   ├── SCAN item
│   ├── FILTER (i_current_price > 50 AND i_category IN ('Children','Sports'))
│   └── OUTPUT (i_item_sk, i_current_price, i_category)
├── [CTE] filtered_promotion  [+]
│   ├── SCAN promotion
│   ├── FILTER (all channel fields = 'N')
│   └── OUTPUT (p_promo_sk, p_channel_email, p_channel_tv, p_channel_radio, p_channel_press, p_channel_event)
├── [CTE] all_sales  [+]
│   ├── SCAN (store_sales, catalog_sales, web_sales) via UNION ALL with wholesale_cost filter
│   ├── JOIN (INNER) filtered_date ON date_sk
│   ├── JOIN (INNER) filtered_item ON item_sk
│   ├── JOIN (INNER) filtered_promotion ON promo_sk
│   └── OUTPUT (channel, item_sk, order_number, location_sk, sales_price, net_profit, wholesale_cost, promo_sk, date_sk)
├── [CTE] channel_aggregates  [+]
│   ├── SCAN all_sales
│   ├── JOIN (LEFT) appropriate returns table per channel
│   ├── JOIN (INNER) appropriate location dimension per channel
│   ├── AGG (GROUP BY channel, location_id)
│   └── OUTPUT (channel, id, sales, returns, profit)
└── [MAIN] main_query  [~]
    ├── SCAN channel_aggregates
    ├── TRANSFORM (add channel/id prefixes)
    ├── AGG (GROUP BY ROLLUP channel, id)
    ├── SORT (channel ASC, id ASC)
    ├── LIMIT 100
    └── OUTPUT (channel, id, sales, returns, profit)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL v16.11",
  "rewrite_rules": [
    {"id": "R1", "type": "scan_consolidation", "description": "Consolidated three separate fact table scans (store_sales, catalog_sales, web_sales) into single UNION ALL in all_sales CTE", "applied_to": ["all_sales"]},
    {"id": "R2", "type": "dimension_prefilter", "description": "Extracted dimension filters into separate CTEs (filtered_date, filtered_item, filtered_promotion) for reuse", "applied_to": ["filtered_date", "filtered_item", "filtered_promotion"]},
    {"id": "R3", "type": "conditional_join", "description": "Replaced comma-separated joins with explicit INNER JOINs and channel-specific LEFT JOINs in channel_aggregates", "applied_to": ["channel_aggregates"]},
    {"id": "R4", "type": "cte_inlining", "description": "Eliminated materialized CTEs for large fact table scans to allow parallelism", "applied_to": ["all_sales"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN CAST('1998-08-29' AS DATE) AND CAST('1998-08-29' AS DATE) + INTERVAL '30 DAY'",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_current_price, i_category FROM item WHERE i_current_price > 50 AND i_category IN ('Children', 'Sports')",
        "interfaces": {"outputs": ["i_item_sk", "i_current_price", "i_category"], "consumes": []}
      },
      "filtered_promotion": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT p_promo_sk, p_channel_email, p_channel_tv, p_channel_radio, p_channel_press, p_channel_event FROM promotion WHERE p_channel_email = 'N' AND p_channel_tv = 'N' AND p_channel_radio = 'N' AND p_channel_press = 'N' AND p_channel_event = 'N'",
        "interfaces": {"outputs": ["p_promo_sk", "p_channel_email", "p_channel_tv", "p_channel_radio", "p_channel_press", "p_channel_event"], "consumes": []}
      },
      "all_sales": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT sales.channel, sales.item_sk, sales.order_number, sales.location_sk, sales.sales_price, sales.net_profit, sales.wholesale_cost, sales.promo_sk, sales.date_sk FROM (SELECT 'store' AS channel, ss_item_sk AS item_sk, ss_ticket_number AS order_number, ss_store_sk AS location_sk, ss_ext_sales_price AS sales_price, ss_net_profit AS net_profit, ss_wholesale_cost AS wholesale_cost, ss_promo_sk AS promo_sk, ss_sold_date_sk AS date_sk FROM store_sales WHERE ss_wholesale_cost BETWEEN 23 AND 38 UNION ALL SELECT 'catalog' AS channel, cs_item_sk, cs_order_number, cs_catalog_page_sk, cs_ext_sales_price, cs_net_profit, cs_wholesale_cost, cs_promo_sk, cs_sold_date_sk FROM catalog_sales WHERE cs_wholesale_cost BETWEEN 23 AND 38 UNION ALL SELECT 'web' AS channel, ws_item_sk, ws_order_number, ws_web_site_sk, ws_ext_sales_price, ws_net_profit, ws_wholesale_cost, ws_promo_sk, ws_sold_date_sk FROM web_sales WHERE ws_wholesale_cost BETWEEN 23 AND 38) sales INNER JOIN filtered_date ON sales.date_sk = filtered_date.d_date_sk INNER JOIN filtered_item ON sales.item_sk = filtered_item.i_item_sk INNER JOIN filtered_promotion ON sales.promo_sk = filtered_promotion.p_promo_sk",
        "interfaces": {"outputs": ["channel", "item_sk", "order_number", "location_sk", "sales_price", "net_profit", "wholesale_cost", "promo_sk", "date_sk"], "consumes": ["filtered_date", "filtered_item", "filtered_promotion"]}
      },
      "channel_aggregates": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT channel, id, SUM(sales_price) AS sales, SUM(COALESCE(return_amt, 0)) AS returns, SUM(net_profit - COALESCE(return_loss, 0)) AS profit FROM (SELECT a.channel, a.item_sk, a.order_number, a.location_sk, a.sales_price, a.net_profit, sr.sr_return_amt AS return_amt, sr.sr_net_loss AS return_loss, s.s_store_id AS id FROM all_sales a INNER JOIN store s ON a.location_sk = s.s_store_sk LEFT JOIN store_returns sr ON a.item_sk = sr.sr_item_sk AND a.order_number = sr.sr_ticket_number WHERE a.channel = 'store' UNION ALL SELECT a.channel, a.item_sk, a.order_number, a.location_sk, a.sales_price, a.net_profit, cr.cr_return_amount AS return_amt, cr.cr_net_loss AS return_loss, cp.cp_catalog_page_id AS id FROM all_sales a INNER JOIN catalog_page cp ON a.location_sk = cp.cp_catalog_page_sk LEFT JOIN catalog_returns cr ON a.item_sk = cr.cr_item_sk AND a.order_number = cr.cr_order_number WHERE a.channel = 'catalog' UNION ALL SELECT a.channel, a.item_sk, a.order_number, a.location_sk, a.sales_price, a.net_profit, wr.wr_return_amt AS return_amt, wr.wr_net_loss AS return_loss, web.web_site_id AS id FROM all_sales a INNER JOIN web_site web ON a.location_sk = web.web_site_sk LEFT JOIN web_returns wr ON a.item_sk = wr.wr_item_sk AND a.order_number = wr.wr_order_number WHERE a.channel = 'web') t GROUP BY channel, id",
        "interfaces": {"outputs": ["channel", "id", "sales", "returns", "profit"], "consumes": ["all_sales"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT channel, id, SUM(sales) AS sales, SUM(returns) AS returns, SUM(profit) AS profit FROM (SELECT CASE channel WHEN 'store' THEN 'store channel' WHEN 'catalog' THEN 'catalog channel' WHEN 'web' THEN 'web channel' END AS channel, CASE channel WHEN 'store' THEN 'store' || id WHEN 'catalog' THEN 'catalog_page' || id WHEN 'web' THEN 'web_site' || id END AS id, sales, returns, profit FROM channel_aggregates) t GROUP BY ROLLUP (channel, id) ORDER BY channel, id LIMIT 100",
        "interfaces": {"outputs": ["channel", "id", "sales", "returns", "profit"], "consumes": ["channel_aggregates"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_item", "filtered_promotion", "all_sales", "channel_aggregates", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_item AS ({filtered_item}), filtered_promotion AS ({filtered_promotion}), all_sales AS ({all_sales}), channel_aggregates AS ({channel_aggregates}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Consolidated three separate fact table scans into a single UNION ALL in `all_sales` CTE, pre-filtered dimensions into reusable CTEs, replaced comma-separated joins with explicit INNER/LEFT JOINs, and eliminated materialized CTEs blocking parallelism.

**Expected speedup**: 1.8-2.5x due to reduced repeated dimension scans, better join optimization, and parallel scan enablement on fact tables.