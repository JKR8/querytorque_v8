You are a SQL rewrite engine for PostgreSQL v16.11-0ubuntu0.24.04.1). Follow the Target Logical Tree structure below. Your job is to write correct, executable SQL for each node — not to decide whether to restructure. Preserve exact semantic equivalence (same rows, same columns, same ordering). Preserve defensive guards: if the original uses CASE WHEN x > 0 THEN y/x END around a division, keep it — even when a WHERE clause makes the zero case unreachable. Guards prevent silent breakage if filters change upstream. Strip benchmark comments (-- start query, -- end query) from your output.

## Semantic Contract (MUST preserve)

Find customers with high return amounts in 2000 compared to their store average, filtering for specific demographics and locations. All joins are INNER (all sides must match). The correlated subquery computes average returns PER STORE (grouping by ctr_store_sk), comparing individual customer returns against 1.2× that store average. The AVG must include ALL customers/reasons for that store, not just those matching the outer row's reason_sk filter. The ratio filter (sr_return_amt/sr_return_quantity BETWEEN 115 AND 174) must be applied BEFORE aggregation.

## Target Logical Tree + Node Contracts

Build your rewrite following this CTE structure. Each node's OUTPUT list is exhaustive — your SQL must produce exactly those columns.

TARGET_LOGICAL_TREE:
returns_with_store_avg -> filtered_results -> final
NODE_CONTRACTS:
  returns_with_store_avg:
    FROM: store_returns sr 
          JOIN date_dim ON sr_returned_date_sk = d_date_sk
    WHERE: d_year = 2000
           AND sr_return_amt / sr_return_quantity BETWEEN 115 AND 174
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
    AGGREGATE: SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return,
               AVG(SUM(SR_RETURN_AMT_INC_TAX)) OVER (PARTITION BY sr_store_sk) * 1.2 AS store_avg_threshold
    OUTPUT: sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, 
            ctr_total_return, store_avg_threshold
    EXPECTED_ROWS: ~93K
    CONSUMERS: filtered_results
  filtered_results:
    FROM: returns_with_store_avg r
          JOIN store ON s_store_sk = r.ctr_store_sk
          JOIN customer ON c_customer_sk = r.ctr_customer_sk
          JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk
    WHERE: r.ctr_total_return > r.store_avg_threshold
           AND r.ctr_reason_sk BETWEEN 17 AND 20
           AND s_state IN ('IA', 'KY', 'NE')
           AND cd_marital_status IN ('S', 'S')
           AND cd_education_status IN ('4 yr Degree', '4 yr Degree')
           AND cd_gender = 'M'
           AND c_birth_month = 4
           AND c_birth_year BETWEEN 1987 AND 1993
    OUTPUT: c_customer_id
    EXPECTED_ROWS: ~final rows
    CONSUMERS: final

NODE_CONTRACTS:
returns_with_store_avg:
    FROM: store_returns sr 
          JOIN date_dim ON sr_returned_date_sk = d_date_sk
    WHERE: d_year = 2000
           AND sr_return_amt / sr_return_quantity BETWEEN 115 AND 174
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
    AGGREGATE: SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return,
               AVG(SUM(SR_RETURN_AMT_INC_TAX)) OVER (PARTITION BY sr_store_sk) * 1.2 AS store_avg_threshold
    OUTPUT: sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, 
            ctr_total_return, store_avg_threshold
    EXPECTED_ROWS: ~93K
    CONSUMERS: filtered_results
  filtered_results:
    FROM: returns_with_store_avg r
          JOIN store ON s_store_sk = r.ctr_store_sk
          JOIN customer ON c_customer_sk = r.ctr_customer_sk
          JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk
    WHERE: r.ctr_total_return > r.store_avg_threshold
           AND r.ctr_reason_sk BETWEEN 17 AND 20
           AND s_state IN ('IA', 'KY', 'NE')
           AND cd_marital_status IN ('S', 'S')
           AND cd_education_status IN ('4 yr Degree', '4 yr Degree')
           AND cd_gender = 'M'
           AND c_birth_month = 4
           AND c_birth_year BETWEEN 1987 AND 1993
    OUTPUT: c_customer_id
    EXPECTED_ROWS: ~final rows
    CONSUMERS: final

## Hazard Flags (avoid these specific risks)

- Window function AVG(SUM(...)) OVER may not compute same as original correlated subquery due to grouping.
- Must verify window function partition by sr_store_sk computes average across ALL groups for that store.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: novel_combination

## Regression Warnings (observed failures on similar queries)

None applicable.

## Constraints (analyst-filtered for this query)

- CORRECTNESS_CONSTRAINT_ID: COMPLETE_OUTPUT: Must output exactly c_customer_id ordered ascending.
- CORRECTNESS_CONSTRAINT_ID: CTE_COLUMN_COMPLETENESS: Any CTE must include all columns referenced downstream (ctr_customer_sk, ctr_store_sk, ctr_reason_sk, ctr_total_return, plus join keys for dimensions).
- CORRECTNESS_CONSTRAINT_ID: LITERAL_PRESERVATION: All filter values (2000, 115, 174, 17, 20, 'IA', 'KY', 'NE', 'S', '4 yr Degree', 'M', 4, 1987, 1993) must be preserved exactly.
- CORRECTNESS_CONSTRAINT_ID: SEMANTIC_EQUIVALENCE: Must return same 100 customer IDs in same order.
- ENGINE_GAP_ID: CORRELATED_SUBQUERY_PARALYSIS: EXPLAIN shows SubPlan executed 8,834 times (4.9ms each), scanning entire CTE each time.
- ENGINE_GAP_ID: COMMA_JOIN_WEAKNESS: Query uses comma-separated implicit joins in CTE and main query, confusing cardinality estimation.
- ENGINE_GAP_ID: CROSS_CTE_PREDICATE_BLINDNESS: Same CTE scanned twice (ctr1, ctr2) with predicate ctr1.ctr_store_sk = ctr2.ctr_store_sk applied late.

## Example Adaptation Notes

For each example: what to apply to your rewrite, and what to ignore.

- No direct examples. Create novel approach using window function to compute store average alongside customer aggregates in single pass.

## Original SQL

```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sr_reason_sk as ctr_reason_sk
,sum(SR_RETURN_AMT_INC_TAX) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2000
and sr_return_amt / sr_return_quantity between 115 and 174
group by sr_customer_sk
,sr_store_sk, sr_reason_sk)
 select  c_customer_id
from customer_total_return ctr1
,store
,customer
,customer_demographics
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk
)
and ctr1.ctr_reason_sk BETWEEN 17 AND 20
and s_store_sk = ctr1.ctr_store_sk
and s_state IN ('IA', 'KY', 'NE')
and ctr1.ctr_customer_sk = c_customer_sk
and c_current_cdemo_sk = cd_demo_sk
and cd_marital_status IN ('S', 'S')
and cd_education_status IN ('4 yr Degree', '4 yr Degree')
and cd_gender = 'M'
and c_birth_month = 4
and c_birth_year BETWEEN 1987 AND 1993
order by c_customer_id
limit 100;
```

## Rewrite Checklist (must pass before final SQL)

- Follow every node in `TARGET_LOGICAL_TREE` and produce each `NODE_CONTRACT` output column exactly.
- Keep all semantic invariants from `Semantic Contract` and `Constraints` (including join/null behavior).
- Preserve all literals and the exact final output schema/order.
- Apply `Hazard Flags` and `Regression Warnings` as hard guards against known failure modes.

## Original Query Structure

This is the current query structure. All nodes are `[=]` (unchanged). Your modified Logic Tree below should show which nodes you changed.

```
QUERY: (single statement)
├── [CTE] customer_total_return  [=]  Cost: 4%  Rows: ~93K
│   ├── SCAN (store_returns, date_dim (join))
│   ├── JOIN (sr_returned_date_sk = d_date_sk)
│   ├── FILTER (d_year = 2000)
│   ├── FILTER (sr_return_amt / sr_return_quantity BETWEEN 115 AND 174)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (ctr_customer_sk, ctr_store_sk, ctr_reason_sk, ctr_total_return)
└── [MAIN] main_query  [=]  Cost: 96%  Rows: ~21.1M
    ├── SCAN (customer_total_return AS ctr1 (join), store (join), customer (join), customer_demographics (join), customer_total_return AS ctr2 (correlated subquery))
    ├── JOIN (s_store_sk = ctr1.ctr_store_sk)
    ├── JOIN (ctr1.ctr_customer_sk = c_customer_sk)
    ├── JOIN (+1 more)
    ├── FILTER (ctr1.ctr_total_return > AVG(ctr_total_return) * 1.2 (per store_sk))
    ├── FILTER (ctr1.ctr_reason_sk BETWEEN 17 AND 20)
    ├── FILTER (+6 more)
    ├── AGG (GROUP BY)
    ├── SORT (c_customer_id ASC)
    └── OUTPUT (c_customer_id)
```

## Output Format

Your response has **two parts** in order:

### Part 1: Modified Logic Tree

Show what changed using change markers. Generate the tree BEFORE writing SQL.

Change markers:
- `[+]` — New component added
- `[-]` — Component removed
- `[~]` — Component modified (describe what changed)
- `[=]` — Unchanged (no children needed)
- `[!]` — Structural change (e.g. CTE → subquery)

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "<dialect>",
  "rewrite_rules": [
    {"id": "R1", "type": "<transform_name>", "description": "<what changed>", "applied_to": ["<component_id>"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "<cte_name>": {
        "type": "cte",
        "change": "modified",
        "sql": "<complete SQL for this CTE body>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<upstream_id>"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "<final SELECT>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<cte_name>"]}
      }
    },
    "reconstruction_order": ["<cte_name>", "main_query"],
    "assembly_template": "WITH <cte_name> AS ({<cte_name>}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '512MB'"],
  "validation_checks": []
}
```

### Rules
- **Tree first, always.** Generate the Logic Tree before writing any SQL
- **One component at a time.** When writing SQL for component X, treat others as opaque interfaces
- **No ellipsis.** Every `sql` value must be complete, executable SQL
- **Frozen blocks are copy-paste.** Large CASE-WHEN lookups must be verbatim
- **Validate interfaces.** Verify every `consumes` reference exists in upstream `outputs`
- Only include components you **changed or added** — set unchanged components to `"change": "unchanged"` with `"sql": ""`
- `main_query` output columns must match the Column Completeness Contract above
- `runtime_config`: SET LOCAL commands for PostgreSQL. Omit or use empty array if not needed
- `reconstruction_order`: topological order of components for assembly

After the JSON, explain the mechanism:

```
Changes: <1-2 sentences: what structural change + the expected mechanism>
Expected speedup: <estimate>
```

Now output your Logic Tree and Component Payload JSON: