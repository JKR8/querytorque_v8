## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~55K
    ├── [CTE] customer_address_cte  [+]  
    │   └── SCAN (customer_address, filter: ca_state='IL')  
    ├── [CTE] customer_cte  [+]  
    │   ├── SCAN (customer, filter: c_birth_month=1)  
    │   └── JOIN (INNER JOIN customer_address_cte ON ca_address_sk = c_current_addr_sk)  
    ├── [CTE] date_cte  [+]  
    │   └── SCAN (date_dim, filter: d_year=2002 AND d_moy=4)  
    ├── [CTE] item_cte  [+]  
    │   └── SCAN (item, filter: i_category='Jewelry')  
    ├── [CTE] store_cte  [+]  
    │   └── SCAN (store)  
    ├── [CTE] store_sales_join  [+]  
    │   ├── SCAN (store_sales, filter: ss_wholesale_cost BETWEEN 35 AND 55)  
    │   ├── JOIN (INNER JOIN customer_cte ON c_customer_sk = ss_customer_sk)  
    │   ├── JOIN (INNER JOIN date_cte ON d_date_sk = ss_sold_date_sk)  
    │   ├── JOIN (INNER JOIN item_cte ON i_item_sk = ss_item_sk)  
    │   ├── JOIN (INNER JOIN store_cte ON s_store_sk = ss_store_sk)  
    │   └── FILTER (substring(customer_cte.ca_zip,1,5) <> substring(store_cte.s_zip,1,5))  
    ├── AGG (GROUP BY i_brand_id, i_brand, i_manufact_id, i_manufact)  
    ├── SORT (ext_price DESC, i_brand ASC, i_brand_id ASC, i_manufact_id ASC, i_manufact ASC)  
    └── OUTPUT (brand_id, brand, i_manufact_id, i_manufact, ext_price)
```

Changes:
- `[+]` Added 5 CTEs for dimension prefetch (customer_address_cte, customer_cte, date_cte, item_cte, store_cte)
- `[+]` Added store_sales_join CTE that joins all CTEs and applies the zip inequality filter
- `[~]` Modified main query to reference CTEs instead of raw table joins

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "pg_dimension_prefetch_star",
      "description": "Convert comma-separated implicit joins to explicit CTE-based prefetch of selective dimensions",
      "applied_to": ["customer_address_cte", "customer_cte", "date_cte", "item_cte", "store_cte", "store_sales_join", "main_query"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "customer_address_cte": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT ca_address_sk, ca_zip FROM customer_address WHERE ca_state = 'IL'",
          "interfaces": {
            "outputs": ["ca_address_sk", "ca_zip"],
            "consumes": []
          }
        },
        "customer_cte": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT c.c_customer_sk, c.c_current_addr_sk, ca.ca_zip FROM customer c INNER JOIN customer_address_cte ca ON ca.ca_address_sk = c.c_current_addr_sk WHERE c.c_birth_month = 1",
          "interfaces": {
            "outputs": ["c_customer_sk", "c_current_addr_sk", "ca_zip"],
            "consumes": ["customer_address_cte"]
          }
        },
        "date_cte": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy = 4",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "item_cte": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT i_item_sk, i_brand_id, i_brand, i_manufact_id, i_manufact FROM item WHERE i_category = 'Jewelry'",
          "interfaces": {
            "outputs": ["i_item_sk", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact"],
            "consumes": []
          }
        },
        "store_cte": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT s_store_sk, s_zip FROM store",
          "interfaces": {
            "outputs": ["s_store_sk", "s_zip"],
            "consumes": []
          }
        },
        "store_sales_join": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT i.i_brand_id, i.i_brand, i.i_manufact_id, i.i_manufact, ss.ss_ext_sales_price FROM store_sales ss INNER JOIN customer_cte c ON c.c_customer_sk = ss.ss_customer_sk INNER JOIN date_cte d ON d.d_date_sk = ss.ss_sold_date_sk INNER JOIN item_cte i ON i.i_item_sk = ss.ss_item_sk INNER JOIN store_cte s ON s.s_store_sk = ss.ss_store_sk WHERE ss.ss_wholesale_cost BETWEEN 35 AND 55 AND substring(c.ca_zip,1,5) <> substring(s.s_zip,1,5)",
          "interfaces": {
            "outputs": ["i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "ss_ext_sales_price"],
            "consumes": ["customer_cte", "date_cte", "item_cte", "store_cte"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, i_manufact_id, i_manufact, SUM(ss_ext_sales_price) AS ext_price FROM store_sales_join GROUP BY i_brand_id, i_brand, i_manufact_id, i_manufact ORDER BY ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact LIMIT 100",
          "interfaces": {
            "outputs": ["brand_id", "brand", "i_manufact_id", "i_manufact", "ext_price"],
            "consumes": ["store_sales_join"]
          }
        }
      },
      "reconstruction_order": ["customer_address_cte", "customer_cte", "date_cte", "item_cte", "store_cte", "store_sales_join", "main_query"],
      "assembly_template": "WITH customer_address_cte AS ({customer_address_cte}), customer_cte AS ({customer_cte}), date_cte AS ({date_cte}), item_cte AS ({item_cte}), store_cte AS ({store_cte}), store_sales_join AS ({store_sales_join}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL work_mem = '64MB'",
    "SET LOCAL hash_mem_multiplier = 2.0"
  ],
  "validation_checks": []
}
```

Changes: Converted the comma-separated implicit joins to explicit CTEs for dimension prefetch, allowing PostgreSQL to build hash tables from selective filters early and improve join cardinality estimates.

Expected speedup: 2-3x by allowing better join order optimization and hash table construction from pre-filtered dimension CTEs.

Runtime config rationale:
1. `enable_hashjoin = on`: The CTE structure benefits from hash joins between small dimension CTEs and the fact table.
2. `work_mem = '64MB'`: Provides sufficient memory for hash tables built from the dimension CTEs (customer_cte ~ selective, item_cte ~ selective, store_cte 102 rows).
3. `hash_mem_multiplier = 2.0`: Gives extra headroom for hash operations given the multiple joins in store_sales_join CTE.