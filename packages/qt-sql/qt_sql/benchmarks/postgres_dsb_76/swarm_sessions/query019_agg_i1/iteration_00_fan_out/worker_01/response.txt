## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [~] date_cte (new CTE)
│   └── SCAN date_dim with d_year=2002 AND d_moy=4
├── [~] item_cte (new CTE)  
│   └── SCAN item with i_category='Jewelry'
├── [~] customer_cte (new CTE)
│   └── SCAN customer with c_birth_month=1
├── [~] customer_address_cte (new CTE)
│   └── SCAN customer_address with ca_state='IL'
├── [~] store_cte (new CTE)
│   └── SCAN store (unfiltered)
├── [~] main_join (transformed)
│   ├── FROM store_sales
│   ├── JOIN date_cte ON d_date_sk = ss_sold_date_sk
│   ├── JOIN item_cte ON i_item_sk = ss_item_sk
│   ├── JOIN customer_cte ON c_customer_sk = ss_customer_sk
│   ├── JOIN customer_address_cte ON ca_address_sk = c_current_addr_sk
│   ├── JOIN store_cte ON s_store_sk = ss_store_sk
│   ├── FILTER ss_wholesale_cost BETWEEN 35 AND 55
│   └── FILTER substring(ca_zip,1,5) <> substring(s_zip,1,5)
├── [~] aggregation (transformed)
│   ├── FROM main_join
│   ├── GROUP BY i_brand, i_brand_id, i_manufact_id, i_manufact
│   └── AGGREGATE SUM(ss_ext_sales_price) AS ext_price
├── [=] SORT ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact
└── [=] OUTPUT brand_id, brand, i_manufact_id, i_manufact, ext_price
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "multi_dimension_prefetch",
      "description": "Convert comma-separated implicit joins to explicit JOINs with pre-filtered dimension CTEs",
      "applied_to": ["date_cte", "item_cte", "customer_cte", "customer_address_cte", "store_cte", "main_join"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "date_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy = 4",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "item_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT i_item_sk, i_brand_id, i_brand, i_manufact_id, i_manufact FROM item WHERE i_category = 'Jewelry'",
          "interfaces": {
            "outputs": ["i_item_sk", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact"],
            "consumes": []
          }
        },
        "customer_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT c_customer_sk, c_current_addr_sk FROM customer WHERE c_birth_month = 1",
          "interfaces": {
            "outputs": ["c_customer_sk", "c_current_addr_sk"],
            "consumes": []
          }
        },
        "customer_address_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT ca_address_sk, ca_zip FROM customer_address WHERE ca_state = 'IL'",
          "interfaces": {
            "outputs": ["ca_address_sk", "ca_zip"],
            "consumes": []
          }
        },
        "store_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT s_store_sk, s_zip FROM store",
          "interfaces": {
            "outputs": ["s_store_sk", "s_zip"],
            "consumes": []
          }
        },
        "main_join": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT i.i_brand_id, i.i_brand, i.i_manufact_id, i.i_manufact, ss.ss_ext_sales_price FROM store_sales ss INNER JOIN date_cte d ON d.d_date_sk = ss.ss_sold_date_sk INNER JOIN item_cte i ON i.i_item_sk = ss.ss_item_sk INNER JOIN customer_cte c ON c.c_customer_sk = ss.ss_customer_sk INNER JOIN customer_address_cte ca ON ca.ca_address_sk = c.c_current_addr_sk INNER JOIN store_cte s ON s.s_store_sk = ss.ss_store_sk WHERE ss.ss_wholesale_cost BETWEEN 35 AND 55 AND substring(ca.ca_zip,1,5) <> substring(s.s_zip,1,5)",
          "interfaces": {
            "outputs": ["i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "ss_ext_sales_price"],
            "consumes": ["date_cte", "item_cte", "customer_cte", "customer_address_cte", "store_cte"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, i_manufact_id, i_manufact, SUM(ss_ext_sales_price) AS ext_price FROM main_join GROUP BY i_brand, i_brand_id, i_manufact_id, i_manufact ORDER BY ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact LIMIT 100",
          "interfaces": {
            "outputs": ["brand_id", "brand", "i_manufact_id", "i_manufact", "ext_price"],
            "consumes": ["main_join"]
          }
        }
      },
      "reconstruction_order": ["date_cte", "item_cte", "customer_cte", "customer_address_cte", "store_cte", "main_join", "main_query"],
      "assembly_template": "WITH date_cte AS ({date_cte}), item_cte AS ({item_cte}), customer_cte AS ({customer_cte}), customer_address_cte AS ({customer_address_cte}), store_cte AS ({store_cte}), main_join AS ({main_join}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL hash_mem_multiplier = 2.0",
    "SET LOCAL max_parallel_workers_per_gather = 2"
  ],
  "validation_checks": []
}
```

**Changes**: Converted comma-separated implicit joins to explicit JOINs with pre-filtered dimension CTEs, isolating selective dimension filters into small hash tables before the main join. This gives PostgreSQL better cardinality estimates and enables parallel hash joins with tiny probe tables.

**Expected speedup**: 2-3× based on similar patterns (pg_date_cte_explicit_join showed 2.28×, pg_dimension_prefetch_star showed 3.32×). The rewrite reduces the search space before applying the expensive zip inequality filter.