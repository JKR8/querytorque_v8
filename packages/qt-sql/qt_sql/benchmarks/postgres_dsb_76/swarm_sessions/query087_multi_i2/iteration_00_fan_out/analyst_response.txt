<reasoning>
1. **CLASSIFY**: This is a "multi-channel UNION ALL" archetype with EXCEPT set operations. The query finds customer-date combinations that exist in store_sales but not in catalog_sales and not in web_sales, under identical filtering conditions across three sales channels. Each branch has the same join pattern (sales ↔ date_dim ↔ customer) and same filters.

2. **EXPLAIN PLAN ANALYSIS**:
   - **Total runtime**: 1231.2ms
   - **Breakdown**:
     - store_sales branch: 626.5ms (51% of total)
     - catalog_sales branch: 348.9ms (28%)
     - web_sales branch: 249.0ms (20%)
     - Set operations overhead: ~7ms
   - **Dominant bottleneck**: Three separate nested-loop joins scanning the same dimension tables (date_dim, customer) multiple times.
   - **Row flow**:
     - date_dim: 182 rows after filter (from 36K) - very selective
     - store_sales: 152 rows per date (28K total)
     - catalog_sales: 21 rows per date (3,772 total)
     - web_sales: 32 rows per date (5,882 total)
     - customer: Almost all rows filtered out (rows=0 in loops)
   - **Optimizer already does**: Parallel execution (Gather/Gather Merge), index scans on sales tables, predicate pushdown to sales table filters.
   - **Missed opportunities**: 
     - date_dim scanned 3 times (once per branch)
     - customer table scanned 3 times (once per branch)
     - Same dimension filters (d_month_seq, c_birth_year) evaluated 3 times
     - Comma-separated implicit joins prevent optimal join ordering
   - **Scan counts**:
     - date_dim: 3 scans (182 rows each)
     - customer: 3 scans (heavy filtering each time)
     - store_sales: 1 scan
     - catalog_sales: 1 scan
     - web_sales: 1 scan

3. **GAP MATCHING**:
   - **COMMA_JOIN_WEAKNESS**: Strong match. Query uses comma-separated implicit joins in all three branches. This confuses cardinality estimation.
   - **CROSS_CTE_PREDICATE_BLINDNESS**: Partial match. The same dimension tables (date_dim, customer) are scanned 3 times with identical filters. Could be materialized once.
   - **CORRELATED_SUBQUERY_PARALYSIS**: Not applicable (no correlated subqueries).
   - **NON_EQUI_JOIN_INPUT_BLINDNESS**: Not applicable (all equi-joins).
   - **Engine strengths that apply**: 
     - INDEX_ONLY_SCAN: Not used on customer (needs birth_year filter)
     - PARALLEL_QUERY_EXECUTION: Already used (Gather nodes)
     - Optimizer is NOT doing: sharing dimension scans, converting implicit joins to explicit

4. **AGGREGATION TRAP CHECK**: No aggregation functions in query. Only COUNT(*) at top level, which is duplicate-safe. The DISTINCT in each branch ensures set semantics.

5. **TRANSFORM SELECTION** (ranked by potential):
   a) **star_join_prefetch + comma_join_fix**: Pre-filter date_dim and customer once, then probe all three sales tables. Expected high win (eliminates 2/3 of dimension scans).
   b) **union_consolidation**: Share dimension lookups across branches using CTEs. Expected medium-high win.
   c) **single_pass_aggregation**: Convert three separate EXCEPT branches to a single scan with conditional logic. Expected high win but riskier.
   d) **minimal-change baseline**: Just convert comma joins to explicit JOINs to test COMMA_JOIN_WEAKNESS fix.

6. **LOGICAL TREE DESIGN**:
   For shared CTE approach:
   - filtered_dates CTE: date_dim filtered by d_month_seq
   - filtered_customers CTE: customer filtered by c_birth_year
   - store_results CTE: filtered_dates JOIN store_sales JOIN filtered_customers with price filters
   - catalog_results CTE: filtered_dates JOIN catalog_sales JOIN filtered_customers with price filters
   - web_results CTE: filtered_dates JOIN web_sales JOIN filtered_customers with price filters
   Then EXCEPT between results.

   All CTEs must output (c_last_name, c_first_name, d_date) for the EXCEPT operation.
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT: Count distinct customer-date combinations present in store_sales but absent from both catalog_sales and web_sales, for customers born 1968-1974 during months 1213-1224, with list price 168-197 and wholesale cost 76-86 across all channels. INNER JOIN semantics require all three tables to match in each branch. No aggregation traps (only COUNT(*)). Filter dependencies: d_month_seq and c_birth_year filters apply identically to all three branches; price/wholesale_cost filters are channel-specific but same numeric ranges.

BOTTLENECK_DIAGNOSIS:
Dominant cost is three separate nested-loop joins scanning date_dim (182 rows) and customer (heavily filtered) three times each, consuming ~1.2s total. Scan-bound on dimension tables, not fact tables. Cardinality flow: date_dim filter reduces 36K→182 rows (0.5%), but this selective filter is evaluated 3 times. Customer filter eliminates almost all rows (rows=0 in loops). Optimizer already handles parallel execution, index scans on sales tables, and predicate pushdown to sales price filters. Logical-tree cost percentages misleading: store_sales branch shows 51% cost but processes more rows; catalog_sales and web_sales have lower row counts but similar join overhead due to repeated dimension scans.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output COUNT(*) as single column
- CTE_COLUMN_COMPLETENESS: Any CTE must include c_last_name, c_first_name, d_date for EXCEPT operations
- LITERAL_PRESERVATION: All numeric ranges (1213-1224, 168-197, 1968-1974, 76-86) must be preserved exactly
- SEMANTIC_EQUIVALENCE: EXCEPT semantics must be preserved (set difference, not anti-join with duplicates)
- COMMA_JOIN_WEAKNESS: All three branches use comma-separated implicit joins (store_sales, date_dim, customer)
- CROSS_CTE_PREDICATE_BLINDNESS: Same date_dim and customer filters applied three times independently

REGRESSION_WARNINGS:
1. EXISTS restructuring (observed 0.50x regression):
   CAUSE: Converting EXCEPT to NOT EXISTS changed NULL semantics and blocked hash anti-joins
   RULE: Preserve EXCEPT structure; do not convert to NOT EXISTS/NOT IN
2. CTE blocking parallelism (observed 0.21x regression):
   CAUSE: MATERIALIZED CTEs forced single-threaded execution on parallelizable fact scans
   RULE: Use non-materialized CTEs or ensure parallel-safe structure when fact tables are large
3. OR to UNION ALL splitting (observed 0.21x regression):
   CAUSE: Splitting OR conditions into UNION ALL branches lost bitmap index scan optimization
   RULE: Do not split channel-specific filters into UNION ALL; preserve per-branch structure

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  filtered_dates -> filtered_customers -> store_results -> catalog_results -> web_results -> EXCEPT chain -> COUNT
NODE_CONTRACTS:
  filtered_dates:
    FROM: date_dim
    WHERE: d_month_seq BETWEEN 1213 AND 1224
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 182
    CONSUMERS: store_results, catalog_results, web_results
  filtered_customers:
    FROM: customer
    WHERE: c_birth_year BETWEEN 1968 AND 1974
    OUTPUT: c_customer_sk, c_last_name, c_first_name
    EXPECTED_ROWS: ~5% of customer table (from EXPLAIN: heavy filtering)
    CONSUMERS: store_results, catalog_results, web_results
  store_results:
    FROM: filtered_dates fd JOIN store_sales ss ON ss.ss_sold_date_sk = fd.d_date_sk
          JOIN filtered_customers fc ON ss.ss_customer_sk = fc.c_customer_sk
    WHERE: ss.ss_list_price BETWEEN 168 AND 197 AND ss.ss_wholesale_cost BETWEEN 76 AND 86
    OUTPUT: fc.c_last_name, fc.c_first_name, fd.d_date
    EXPECTED_ROWS: 6,528 (after DISTINCT in original)
    CONSUMERS: EXCEPT operation
  catalog_results:
    FROM: filtered_dates fd JOIN catalog_sales cs ON cs.cs_sold_date_sk = fd.d_date_sk
          JOIN filtered_customers fc ON cs.cs_bill_customer_sk = fc.c_customer_sk
    WHERE: cs.cs_list_price BETWEEN 168 AND 197 AND cs.cs_wholesale_cost BETWEEN 76 AND 86
    OUTPUT: fc.c_last_name, fc.c_first_name, fd.d_date
    EXPECTED_ROWS: 885 (after DISTINCT in original)
    CONSUMERS: EXCEPT operation
  web_results:
    FROM: filtered_dates fd JOIN web_sales ws ON ws.ws_sold_date_sk = fd.d_date_sk
          JOIN filtered_customers fc ON ws.ws_bill_customer_sk = fc.c_customer_sk
    WHERE: ws.ws_list_price BETWEEN 168 AND 197 AND ws.ws_wholesale_cost BETWEEN 76 AND 86
    OUTPUT: fc.c_last_name, fc.c_first_name, fd.d_date
    EXPECTED_ROWS: 1,426 (after DISTINCT in original)
    CONSUMERS: EXCEPT operation
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply pre-filtering of date_dim and customer into CTEs; convert comma joins to explicit JOIN syntax. Ignore promotion/item dimensions (not in this query).
- pg_date_cte_explicit_join: Apply date_dim CTE isolation AND explicit JOIN conversion. Ignore single-channel focus (this is multi-channel).
- early_filter_decorrelate: Apply early dimension filtering before joins. Ignore decorrelation aspect (no correlated subqueries).
HAZARD_FLAGS:
- CTE materialization may block parallelism on fact table scans
- Must ensure DISTINCT semantics preserved (CTEs don't add duplicates)

=== WORKER 2 BRIEFING ===

STRATEGY: union_consolidation
TARGET_LOGICAL_TREE:
  filtered_dates -> filtered_customers -> all_sales_union -> grouped_results -> filter_present_only_in_store -> COUNT
NODE_CONTRACTS:
  filtered_dates:
    FROM: date_dim
    WHERE: d_month_seq BETWEEN 1213 AND 1224
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 182
    CONSUMERS: sales_union
  filtered_customers:
    FROM: customer
    WHERE: c_birth_year BETWEEN 1968 AND 1974
    OUTPUT: c_customer_sk, c_last_name, c_first_name
    EXPECTED_ROWS: ~5% of customer table
    CONSUMERS: sales_union
  sales_union:
    FROM: (SELECT 'store' as channel, fc.c_last_name, fc.c_first_name, fd.d_date
           FROM filtered_dates fd JOIN store_sales ss ON ss.ss_sold_date_sk = fd.d_date_sk
                JOIN filtered_customers fc ON ss.ss_customer_sk = fc.c_customer_sk
           WHERE ss.ss_list_price BETWEEN 168 AND 197 AND ss.ss_wholesale_cost BETWEEN 76 AND 86
           UNION ALL
           SELECT 'catalog', fc.c_last_name, fc.c_first_name, fd.d_date
           FROM filtered_dates fd JOIN catalog_sales cs ON cs.cs_sold_date_sk = fd.d_date_sk
                JOIN filtered_customers fc ON cs.cs_bill_customer_sk = fc.c_customer_sk
           WHERE cs.cs_list_price BETWEEN 168 AND 197 AND cs.cs_wholesale_cost BETWEEN 76 AND 86
           UNION ALL
           SELECT 'web', fc.c_last_name, fc.c_first_name, fd.d_date
           FROM filtered_dates fd JOIN web_sales ws ON ws.ws_sold_date_sk = fd.d_date_sk
                JOIN filtered_customers fc ON ws.ws_bill_customer_sk = fc.c_customer_sk
           WHERE ws.ws_list_price BETWEEN 168 AND 197 AND ws.ws_wholesale_cost BETWEEN 76 AND 86)
    OUTPUT: channel, c_last_name, c_first_name, d_date
    EXPECTED_ROWS: 6,528 + 885 + 1,426 = ~8,839
    CONSUMERS: grouped_results
  grouped_results:
    FROM: sales_union
    GROUP BY: c_last_name, c_first_name, d_date
    AGGREGATE: COUNT(CASE WHEN channel = 'store' THEN 1 END) as store_count,
               COUNT(CASE WHEN channel = 'catalog' THEN 1 END) as catalog_count,
               COUNT(CASE WHEN channel = 'web' THEN 1 END) as web_count
    OUTPUT: c_last_name, c_first_name, d_date, store_count, catalog_count, web_count
    EXPECTED_ROWS: ~6,520 (from EXPLAIN final rows)
    CONSUMERS: filter_present_only_in_store
  filter_present_only_in_store:
    FROM: grouped_results
    WHERE: store_count > 0 AND catalog_count = 0 AND web_count = 0
    OUTPUT: c_last_name, c_first_name, d_date
    EXPECTED_ROWS: Same as final EXCEPT result
    CONSUMERS: COUNT(*)
EXAMPLES: shared_dimension_multi_channel, union_cte_split
EXAMPLE_ADAPTATION:
- shared_dimension_multi_channel: Apply shared dimension CTEs across UNION ALL branches. Ignore different dimension tables (this query uses same dimensions).
- union_cte_split: Apply UNION ALL consolidation pattern. Ignore splitting aspect (we're consolidating, not splitting).
HAZARD_FLAGS:
- UNION ALL may produce duplicates that affect COUNT aggregation (but original has DISTINCT per branch)
- Must ensure GROUP BY correctly handles potential duplicates from sales tables

=== WORKER 3 BRIEFING ===

STRATEGY: single_pass_aggregation
TARGET_LOGICAL_TREE:
  filtered_dates -> filtered_customers -> all_sales_joined -> distinct_combinations -> filter_by_presence -> COUNT
NODE_CONTRACTS:
  filtered_dates:
    FROM: date_dim
    WHERE: d_month_seq BETWEEN 1213 AND 1224
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 182
    CONSUMERS: all_sales_joined
  filtered_customers:
    FROM: customer
    WHERE: c_birth_year BETWEEN 1968 AND 1974
    OUTPUT: c_customer_sk, c_last_name, c_first_name
    EXPECTED_ROWS: ~5% of customer table
    CONSUMERS: all_sales_joined
  all_sales_joined:
    FROM: filtered_dates fd
          LEFT JOIN store_sales ss ON ss.ss_sold_date_sk = fd.d_date_sk 
            AND ss.ss_customer_sk IN (SELECT c_customer_sk FROM filtered_customers)
            AND ss.ss_list_price BETWEEN 168 AND 197 AND ss.ss_wholesale_cost BETWEEN 76 AND 86
          LEFT JOIN catalog_sales cs ON cs.cs_sold_date_sk = fd.d_date_sk 
            AND cs.cs_bill_customer_sk IN (SELECT c_customer_sk FROM filtered_customers)
            AND cs.cs_list_price BETWEEN 168 AND 197 AND cs.cs_wholesale_cost BETWEEN 76 AND 86
          LEFT JOIN web_sales ws ON ws.ws_sold_date_sk = fd.d_date_sk 
            AND ws.ws_bill_customer_sk IN (SELECT c_customer_sk FROM filtered_customers)
            AND ws.ws_list_price BETWEEN 168 AND 197 AND ws.ws_wholesale_cost BETWEEN 76 AND 86
    OUTPUT: fd.d_date, 
            (SELECT c_last_name FROM filtered_customers WHERE c_customer_sk = ss.ss_customer_sk) as store_last_name,
            (SELECT c_first_name FROM filtered_customers WHERE c_customer_sk = ss.ss_customer_sk) as store_first_name,
            (SELECT c_last_name FROM filtered_customers WHERE c_customer_sk = cs.cs_bill_customer_sk) as catalog_last_name,
            (SELECT c_first_name FROM filtered_customers WHERE c_customer_sk = cs.cs_bill_customer_sk) as catalog_first_name,
            (SELECT c_last_name FROM filtered_customers WHERE c_customer_sk = ws.ws_bill_customer_sk) as web_last_name,
            (SELECT c_first_name FROM filtered_customers WHERE c_customer_sk = ws.ws_bill_customer_sk) as web_first_name
    EXPECTED_ROWS: 182 dates × customer matches
    CONSUMERS: distinct_combinations
  distinct_combinations:
    FROM: all_sales_joined
    WHERE: store_last_name IS NOT NULL AND store_first_name IS NOT NULL
    OUTPUT: store_last_name as c_last_name, store_first_name as c_first_name, d_date,
            CASE WHEN catalog_last_name IS NOT NULL THEN 1 ELSE 0 END as in_catalog,
            CASE WHEN web_last_name IS NOT NULL THEN 1 ELSE 0 END as in_web
    EXPECTED_ROWS: ~6,528 (store sales matches)
    CONSUMERS: filter_by_presence
  filter_by_presence:
    FROM: distinct_combinations
    WHERE: in_catalog = 0 AND in_web = 0
    OUTPUT: c_last_name, c_first_name, d_date
    EXPECTED_ROWS: Same as final EXCEPT result
    CONSUMERS: COUNT(*)
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Apply single scan with conditional logic for multiple channels. Ignore aggregation functions (this query uses set operations).
- channel_bitmap_aggregation: Apply bitmap-style tracking of channel presence. Ignore bitmap index specifics.
HAZARD_FLAGS:
- Complex LEFT JOIN with subqueries may perform worse than original
- Must handle NULL semantics correctly for customers not in certain channels
- DISTINCT semantics may be lost if same customer-date appears multiple times in sales

=== WORKER 4 BRIEFING ===

STRATEGY: minimal_explicit_joins
TARGET_LOGICAL_TREE:
  store_results -> catalog_results -> web_results -> EXCEPT chain -> COUNT
NODE_CONTRACTS:
  store_results:
    FROM: store_sales ss INNER JOIN date_dim dd ON ss.ss_sold_date_sk = dd.d_date_sk
          INNER JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk
    WHERE: dd.d_month_seq BETWEEN 1213 AND 1224
      AND ss.ss_list_price BETWEEN 168 AND 197
      AND c.c_birth_year BETWEEN 1968 AND 1974
      AND ss.ss_wholesale_cost BETWEEN 76 AND 86
    OUTPUT: c.c_last_name, c.c_first_name, dd.d_date
    EXPECTED_ROWS: 6,528 (after DISTINCT)
    CONSUMERS: EXCEPT operation
  catalog_results:
    FROM: catalog_sales cs INNER JOIN date_dim dd ON cs.cs_sold_date_sk = dd.d_date_sk
          INNER JOIN customer c ON cs.cs_bill_customer_sk = c.c_customer_sk
    WHERE: dd.d_month_seq BETWEEN 1213 AND 1224
      AND cs.cs_list_price BETWEEN 168 AND 197
      AND c.c_birth_year BETWEEN 1968 AND 1974
      AND cs.cs_wholesale_cost BETWEEN 76 AND 86
    OUTPUT: c.c_last_name, c.c_first_name, dd.d_date
    EXPECTED_ROWS: 885 (after DISTINCT)
    CONSUMERS: EXCEPT operation
  web_results:
    FROM: web_sales ws INNER JOIN date_dim dd ON ws.ws_sold_date_sk = dd.d_date_sk
          INNER JOIN customer c ON ws.ws_bill_customer_sk = c.c_customer_sk
    WHERE: dd.d_month_seq BETWEEN 1213 AND 1224
      AND ws.ws_list_price BETWEEN 168 AND 197
      AND c.c_birth_year BETWEEN 1968 AND 1974
      AND ws.ws_wholesale_cost BETWEEN 76 AND 86
    OUTPUT: c.c_last_name, c.c_first_name, dd.d_date
    EXPECTED_ROWS: 1,426 (after DISTINCT)
    CONSUMERS: EXCEPT operation
EXAMPLES: pg_date_cte_explicit_join, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_date_cte_explicit_join: Apply explicit JOIN conversion only (no CTE). Ignore date CTE isolation.
- early_filter_decorrelate: Apply explicit JOIN syntax improvement. Ignore early filtering and decorrelation.
HAZARD_FLAGS:
- May not improve performance significantly (optimizer might already handle implicit joins)
- But tests COMMA_JOIN_WEAKNESS hypothesis directly
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: constraint_relaxation (testing if comma join conversion alone provides benefit without other structural changes)