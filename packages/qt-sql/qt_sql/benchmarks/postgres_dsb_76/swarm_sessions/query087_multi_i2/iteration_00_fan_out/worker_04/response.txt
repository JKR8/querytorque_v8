## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [=]  Cost: 99%  Rows: ~55K
    ├── [~] CTE: store_results
    │   ├── [~] FROM: store_sales → INNER JOIN date_dim → INNER JOIN customer (explicit syntax)
    │   ├── [=] FILTER (d_month_seq BETWEEN 1213 AND 1224)
    │   ├── [=] FILTER (ss_list_price BETWEEN 168 AND 197)
    │   ├── [=] FILTER (c_birth_year BETWEEN 1968 AND 1974)
    │   ├── [=] FILTER (ss_wholesale_cost BETWEEN 76 AND 86)
    │   └── [=] OUTPUT (c_last_name, c_first_name, d_date)
    ├── [~] CTE: catalog_results
    │   ├── [~] FROM: catalog_sales → INNER JOIN date_dim → INNER JOIN customer (explicit syntax)
    │   ├── [=] FILTER (d_month_seq BETWEEN 1213 AND 1224)
    │   ├── [=] FILTER (cs_list_price BETWEEN 168 AND 197)
    │   ├── [=] FILTER (c_birth_year BETWEEN 1968 AND 1974)
    │   ├── [=] FILTER (cs_wholesale_cost BETWEEN 76 AND 86)
    │   └── [=] OUTPUT (c_last_name, c_first_name, d_date)
    ├── [~] CTE: web_results
    │   ├── [~] FROM: web_sales → INNER JOIN date_dim → INNER JOIN customer (explicit syntax)
    │   ├── [=] FILTER (d_month_seq BETWEEN 1213 AND 1224)
    │   ├── [=] FILTER (ws_list_price BETWEEN 168 AND 197)
    │   ├── [=] FILTER (c_birth_year BETWEEN 1968 AND 1974)
    │   ├── [=] FILTER (ws_wholesale_cost BETWEEN 76 AND 86)
    │   └── [=] OUTPUT (c_last_name, c_first_name, d_date)
    ├── [=] EXCEPT chain (store_results EXCEPT catalog_results EXCEPT web_results)
    └── [=] OUTPUT (COUNT(*))
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "explicit_join_conversion",
      "description": "Convert comma-separated implicit joins to explicit INNER JOIN syntax per TARGET_LOGICAL_TREE structure",
      "applied_to": ["store_results", "catalog_results", "web_results"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "store_results": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT c.c_last_name, c.c_first_name, dd.d_date FROM store_sales ss INNER JOIN date_dim dd ON ss.ss_sold_date_sk = dd.d_date_sk INNER JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk WHERE dd.d_month_seq BETWEEN 1213 AND 1224 AND ss.ss_list_price BETWEEN 168 AND 197 AND c.c_birth_year BETWEEN 1968 AND 1974 AND ss.ss_wholesale_cost BETWEEN 76 AND 86",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": []
        }
      },
      "catalog_results": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT c.c_last_name, c.c_first_name, dd.d_date FROM catalog_sales cs INNER JOIN date_dim dd ON cs.cs_sold_date_sk = dd.d_date_sk INNER JOIN customer c ON cs.cs_bill_customer_sk = c.c_customer_sk WHERE dd.d_month_seq BETWEEN 1213 AND 1224 AND cs.cs_list_price BETWEEN 168 AND 197 AND c.c_birth_year BETWEEN 1968 AND 1974 AND cs.cs_wholesale_cost BETWEEN 76 AND 86",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": []
        }
      },
      "web_results": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT c.c_last_name, c.c_first_name, dd.d_date FROM web_sales ws INNER JOIN date_dim dd ON ws.ws_sold_date_sk = dd.d_date_sk INNER JOIN customer c ON ws.ws_bill_customer_sk = c.c_customer_sk WHERE dd.d_month_seq BETWEEN 1213 AND 1224 AND ws.ws_list_price BETWEEN 168 AND 197 AND c.c_birth_year BETWEEN 1968 AND 1974 AND ws.ws_wholesale_cost BETWEEN 76 AND 86",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": []
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {
          "outputs": ["count"],
          "consumes": ["store_results", "catalog_results", "web_results"]
        }
      }
    },
    "reconstruction_order": ["store_results", "catalog_results", "web_results", "main_query"],
    "assembly_template": "WITH store_results AS ({store_results}), catalog_results AS ({catalog_results}), web_results AS ({web_results}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Final SQL:**
```sql
WITH store_results AS (
  SELECT DISTINCT c.c_last_name, c.c_first_name, dd.d_date
  FROM store_sales ss
  INNER JOIN date_dim dd ON ss.ss_sold_date_sk = dd.d_date_sk
  INNER JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk
  WHERE dd.d_month_seq BETWEEN 1213 AND 1224
    AND ss.ss_list_price BETWEEN 168 AND 197
    AND c.c_birth_year BETWEEN 1968 AND 1974
    AND ss.ss_wholesale_cost BETWEEN 76 AND 86
),
catalog_results AS (
  SELECT DISTINCT c.c_last_name, c.c_first_name, dd.d_date
  FROM catalog_sales cs
  INNER JOIN date_dim dd ON cs.cs_sold_date_sk = dd.d_date_sk
  INNER JOIN customer c ON cs.cs_bill_customer_sk = c.c_customer_sk
  WHERE dd.d_month_seq BETWEEN 1213 AND 1224
    AND cs.cs_list_price BETWEEN 168 AND 197
    AND c.c_birth_year BETWEEN 1968 AND 1974
    AND cs.cs_wholesale_cost BETWEEN 76 AND 86
),
web_results AS (
  SELECT DISTINCT c.c_last_name, c.c_first_name, dd.d_date
  FROM web_sales ws
  INNER JOIN date_dim dd ON ws.ws_sold_date_sk = dd.d_date_sk
  INNER JOIN customer c ON ws.ws_bill_customer_sk = c.c_customer_sk
  WHERE dd.d_month_seq BETWEEN 1213 AND 1224
    AND ws.ws_list_price BETWEEN 168 AND 197
    AND c.c_birth_year BETWEEN 1968 AND 1974
    AND ws.ws_wholesale_cost BETWEEN 76 AND 86
)
SELECT COUNT(*)
FROM (
  (SELECT * FROM store_results)
  EXCEPT
  (SELECT * FROM catalog_results)
  EXCEPT
  (SELECT * FROM web_results)
) cool_cust;
```

**Changes:** Converted all comma-separated joins to explicit INNER JOIN syntax while preserving the exact CTE structure, EXCEPT chain semantics, and all filter conditions as specified in TARGET_LOGICAL_TREE.

**Expected speedup:** Minimal (1.0-1.1x). This addresses the COMMA_JOIN_WEAKNESS hypothesis directly by enabling better join planning hints to the optimizer while maintaining identical query semantics. The primary benefit is structural clarity and potential for the optimizer to reorder joins more effectively, though performance gains are expected to be modest since the underlying data distribution and filter selectivity remain unchanged.