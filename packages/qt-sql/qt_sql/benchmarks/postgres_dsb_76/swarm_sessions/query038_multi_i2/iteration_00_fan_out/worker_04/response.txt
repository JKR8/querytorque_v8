## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 98%  Rows: ~150K
    ├── CTE filtered_date  [+]
    │   ├── SCAN date_dim
    │   └── FILTER (d_month_seq BETWEEN 1207 AND 1207 + 11)
    ├── CTE filtered_customer  [+]
    │   ├── SCAN customer
    │   └── FILTER (c_birth_month IN (2, 3, 4, 10))
    ├── CTE fact_join_store  [+]
    │   ├── JOIN store_sales ⇔ filtered_date (ss_sold_date_sk = d_date_sk)
    │   ├── JOIN ⇔ filtered_customer (ss_customer_sk = c_customer_sk)
    │   └── FILTER (ss_list_price 241-300, ss_wholesale_cost 76-96)
    ├── CTE fact_join_catalog  [+]
    │   ├── JOIN catalog_sales ⇔ filtered_date (cs_sold_date_sk = d_date_sk)
    │   ├── JOIN ⇔ filtered_customer (cs_bill_customer_sk = c_customer_sk)
    │   └── FILTER (cs_list_price 241-300, cs_wholesale_cost 76-96)
    ├── CTE fact_join_web  [+]
    │   ├── JOIN web_sales ⇔ filtered_date (ws_sold_date_sk = d_date_sk)
    │   ├── JOIN ⇔ filtered_customer (ws_bill_customer_sk = c_customer_sk)
    │   └── FILTER (ws_list_price 241-300, ws_wholesale_cost 76-96)
    ├── CTE intersect_materialized  [+]
    │   ├── SET INTERSECT fact_join_store, fact_join_catalog, fact_join_web
    │   └── OUTPUT (c_last_name, c_first_name, d_date)
    └── AGGREGATE COUNT(*)  [=]
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "materialized_dimension_fact_prefilter", "description": "Extract date_dim and customer filters into MATERIALIZED CTEs to prevent repeated scanning", "applied_to": ["filtered_date", "filtered_customer"]},
    {"id": "R2", "type": "explicit_join_decomposition", "description": "Replace comma joins with explicit JOIN syntax, preserving original semantics", "applied_to": ["fact_join_store", "fact_join_catalog", "fact_join_web"]},
    {"id": "R3", "type": "cte_pipeline", "description": "Stage channel-specific fact table joins as CTEs before INTERSECT", "applied_to": ["fact_join_store", "fact_join_catalog", "fact_join_web", "intersect_materialized"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1207 AND 1207 + 11",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "filtered_customer": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c_customer_sk, c_last_name, c_first_name FROM customer WHERE c_birth_month IN (2, 3, 4, 10)",
        "interfaces": {"outputs": ["c_customer_sk", "c_last_name", "c_first_name"], "consumes": []}
      },
      "fact_join_store": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT DISTINCT c_last_name, c_first_name, d_date FROM store_sales JOIN filtered_date ON store_sales.ss_sold_date_sk = filtered_date.d_date_sk JOIN filtered_customer ON store_sales.ss_customer_sk = filtered_customer.c_customer_sk WHERE ss_list_price BETWEEN 241 AND 300 AND ss_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_date", "filtered_customer"]}
      },
      "fact_join_catalog": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT DISTINCT c_last_name, c_first_name, d_date FROM catalog_sales JOIN filtered_date ON catalog_sales.cs_sold_date_sk = filtered_date.d_date_sk JOIN filtered_customer ON catalog_sales.cs_bill_customer_sk = filtered_customer.c_customer_sk WHERE cs_list_price BETWEEN 241 AND 300 AND cs_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_date", "filtered_customer"]}
      },
      "fact_join_web": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT DISTINCT c_last_name, c_first_name, d_date FROM web_sales JOIN filtered_date ON web_sales.ws_sold_date_sk = filtered_date.d_date_sk JOIN filtered_customer ON web_sales.ws_bill_customer_sk = filtered_customer.c_customer_sk WHERE ws_list_price BETWEEN 241 AND 300 AND ws_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_date", "filtered_customer"]}
      },
      "intersect_materialized": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c_last_name, c_first_name, d_date FROM fact_join_store INTERSECT SELECT c_last_name, c_first_name, d_date FROM fact_join_catalog INTERSECT SELECT c_last_name, c_first_name, d_date FROM fact_join_web",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["fact_join_store", "fact_join_catalog", "fact_join_web"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT COUNT(*) FROM intersect_materialized LIMIT 100",
        "interfaces": {"outputs": ["count"], "consumes": ["intersect_materialized"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_customer", "fact_join_store", "fact_join_catalog", "fact_join_web", "intersect_materialized", "main_query"],
    "assembly_template": "WITH filtered_date AS (MATERIALIZED {filtered_date}), filtered_customer AS (MATERIALIZED {filtered_customer}), fact_join_store AS ({fact_join_store}), fact_join_catalog AS ({fact_join_catalog}), fact_join_web AS ({fact_join_web}), intersect_materialized AS ({intersect_materialized}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '128MB'",
    "SET LOCAL max_parallel_workers_per_gather = 2",
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL enable_mergejoin = off"
  ],
  "validation_checks": []
}
```

**Changes**: Structured query into CTE pipeline with MATERIALIZED dimension CTEs to prevent redundant scanning, while preserving original INTERSECT logic and all literal filters. This reduces the 3x date_dim/customer scans to single materialized instances.

**Expected speedup**: ~2.5-3x from eliminating redundant dimension table scans and enabling parallel hash joins with adequate work_mem. The materialized CTEs prevent predicate pushdown but are justified given small filtered row counts (182 dates, ~25% customers).