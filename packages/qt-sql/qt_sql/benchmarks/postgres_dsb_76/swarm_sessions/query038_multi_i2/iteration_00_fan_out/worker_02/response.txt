## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  (changed from INTERSECT to EXISTS with CTEs)
    ├── CTE base_channel  [+]
    │   ├── SCAN (store_sales, date_dim, customer)
    │   ├── JOIN (store_sales.ss_sold_date_sk = date_dim.d_date_sk)
    │   ├── JOIN (store_sales.ss_customer_sk = customer.c_customer_sk)
    │   ├── FILTER (d_month_seq BETWEEN 1207 AND 1218)
    │   ├── FILTER (c_birth_month IN (2, 3, 4, 10))
    │   ├── FILTER (ss_list_price BETWEEN 241 AND 300)
    │   ├── FILTER (ss_wholesale_cost BETWEEN 76 AND 96)
    │   └── AGGREGATE (DISTINCT on c_last_name, c_first_name, d_date)
    ├── CTE catalog_exists  [+]
    │   ├── SCAN (catalog_sales, date_dim, customer)
    │   ├── JOIN (catalog_sales.cs_sold_date_sk = date_dim.d_date_sk)
    │   ├── JOIN (catalog_sales.cs_bill_customer_sk = customer.c_customer_sk)
    │   ├── FILTER (d_month_seq BETWEEN 1207 AND 1218)
    │   ├── FILTER (c_birth_month IN (2, 3, 4, 10))
    │   ├── FILTER (cs_list_price BETWEEN 241 AND 300)
    │   ├── FILTER (cs_wholesale_cost BETWEEN 76 AND 96)
    │   └── AGGREGATE (DISTINCT on c_last_name, c_first_name, d_date)
    ├── CTE web_exists  [+]
    │   ├── SCAN (web_sales, date_dim, customer)
    │   ├── JOIN (web_sales.ws_sold_date_sk = date_dim.d_date_sk)
    │   ├── JOIN (web_sales.ws_bill_customer_sk = customer.c_customer_sk)
    │   ├── FILTER (d_month_seq BETWEEN 1207 AND 1218)
    │   ├── FILTER (c_birth_month IN (2, 3, 4, 10))
    │   ├── FILTER (ws_list_price BETWEEN 241 AND 300)
    │   ├── FILTER (ws_wholesale_cost BETWEEN 76 AND 96)
    │   └── AGGREGATE (DISTINCT on c_last_name, c_first_name, d_date)
    ├── SEMI-JOIN (base_channel EXISTS in catalog_exists)
    ├── SEMI-JOIN (base_channel EXISTS in web_exists)
    └── AGGREGATE (COUNT(*))
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "intersect_to_exists", "description": "Convert 3-way INTERSECT to base channel CTE with EXISTS semi-joins", "applied_to": ["main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "base_channel": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT c_last_name, c_first_name, d_date FROM store_sales, date_dim, customer WHERE store_sales.ss_sold_date_sk = date_dim.d_date_sk AND store_sales.ss_customer_sk = customer.c_customer_sk AND d_month_seq BETWEEN 1207 AND 1207 + 11 AND c_birth_month IN (2, 3, 4, 10) AND ss_list_price BETWEEN 241 AND 300 AND ss_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": []}
      },
      "catalog_exists": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT c_last_name, c_first_name, d_date FROM catalog_sales, date_dim, customer WHERE catalog_sales.cs_sold_date_sk = date_dim.d_date_sk AND catalog_sales.cs_bill_customer_sk = customer.c_customer_sk AND d_month_seq BETWEEN 1207 AND 1207 + 11 AND c_birth_month IN (2, 3, 4, 10) AND cs_list_price BETWEEN 241 AND 300 AND cs_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": []}
      },
      "web_exists": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT c_last_name, c_first_name, d_date FROM web_sales, date_dim, customer WHERE web_sales.ws_sold_date_sk = date_dim.d_date_sk AND web_sales.ws_bill_customer_sk = customer.c_customer_sk AND d_month_seq BETWEEN 1207 AND 1207 + 11 AND c_birth_month IN (2, 3, 4, 10) AND ws_list_price BETWEEN 241 AND 300 AND ws_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT COUNT(*) FROM base_channel b WHERE EXISTS (SELECT 1 FROM catalog_exists c WHERE b.c_last_name = c.c_last_name AND b.c_first_name = c.c_first_name AND b.d_date = c.d_date) AND EXISTS (SELECT 1 FROM web_exists w WHERE b.c_last_name = w.c_last_name AND b.c_first_name = w.c_first_name AND b.d_date = w.d_date)",
        "interfaces": {"outputs": ["count"], "consumes": ["base_channel", "catalog_exists", "web_exists"]}
      }
    },
    "reconstruction_order": ["base_channel", "catalog_exists", "web_exists", "main_query"],
    "assembly_template": "WITH base_channel AS ({base_channel}), catalog_exists AS ({catalog_exists}), web_exists AS ({web_exists}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '32MB'", "SET LOCAL enable_hashjoin = off", "SET LOCAL enable_mergejoin = on", "SET LOCAL enable_nestloop = on", "SET LOCAL max_parallel_workers_per_gather = 0"],
  "validation_checks": []
}
```

**Changes**: Converted 3-way INTERSECT to EXISTS semi-joins with materialized CTEs for each channel, using store_sales as base. This eliminates set operation overhead and allows merge/nested-loop semi-joins.

**Expected speedup**: 15-25% by avoiding INTERSECT duplicate elimination across large sets and enabling more efficient join strategies for the small base_channel (21K rows).