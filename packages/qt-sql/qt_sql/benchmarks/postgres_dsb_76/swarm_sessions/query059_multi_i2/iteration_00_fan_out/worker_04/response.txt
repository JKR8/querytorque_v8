### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_dates1  [+]
│   ├── SCAN date_dim
│   └── FILTER d_month_seq BETWEEN 1183 AND 1194
├── [CTE] filtered_dates2  [+]
│   ├── SCAN date_dim
│   └── FILTER d_month_seq BETWEEN 1195 AND 1206
├── [CTE] sales_year1  [+]
│   ├── SCAN store_sales
│   ├── JOIN filtered_dates1 (ss_sold_date_sk = d_date_sk)
│   ├── FILTER ss_sales_price/ss_list_price BETWEEN 0.65 AND 0.85
│   ├── AGG GROUP BY d_week_seq, ss_store_sk
│   └── OUTPUT day-of-week aggregates
├── [CTE] sales_year2  [+]
│   ├── SCAN store_sales
│   ├── JOIN filtered_dates2 (ss_sold_date_sk = d_date_sk)
│   ├── FILTER ss_sales_price/ss_list_price BETWEEN 0.65 AND 0.85
│   ├── AGG GROUP BY d_week_seq, ss_store_sk
│   └── OUTPUT day-of-week aggregates
├── [CTE] stores_filtered  [+]
│   ├── SCAN store
│   └── FILTER s_state IN ('AR','GA','IN','KS','KY','OH','SD','VA')
└── [MAIN] main_deferred  [+]
    ├── JOIN (sales_year1 + stores_filtered) AS y
    ├── JOIN (sales_year2 + stores_filtered) AS x
    ├── JOIN y WITH x ON y.s_store_id = x.s_store_id AND y.d_week_seq = x.d_week_seq - 52
    ├── SORT y.s_store_name, y.s_store_id, y.d_week_seq
    └── OUTPUT 10 ratio columns
```

**Changes:**
- `[+]` Created new CTEs `filtered_dates1`, `filtered_dates2` to isolate date dimension filtering
- `[+]` Created new CTEs `sales_year1`, `sales_year2` to compute aggregates separately per year
- `[+]` Created new CTE `stores_filtered` to isolate store dimension filtering
- `[+]` Created new main query `main_deferred` joining the two filtered year datasets
- Original `wss` CTE removed in favor of decomposed structure

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Separate date dimension filtering into isolated CTEs", "applied_to": ["filtered_dates1", "filtered_dates2"]},
    {"id": "R2", "type": "early_filter", "description": "Push store state filter early into stores_filtered CTE", "applied_to": ["stores_filtered"]},
    {"id": "R3", "type": "split_aggregation_by_year", "description": "Separate yearly aggregations into distinct CTEs", "applied_to": ["sales_year1", "sales_year2"]},
    {"id": "R4", "type": "deferred_join", "description": "Defer joining year datasets until after separate aggregations", "applied_to": ["main_deferred"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates1": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_week_seq FROM date_dim WHERE d_month_seq BETWEEN 1183 AND 1194",
        "interfaces": {"outputs": ["d_date_sk", "d_week_seq"], "consumes": []}
      },
      "filtered_dates2": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_week_seq FROM date_dim WHERE d_month_seq BETWEEN 1195 AND 1206",
        "interfaces": {"outputs": ["d_date_sk", "d_week_seq"], "consumes": []}
      },
      "sales_year1": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d.d_week_seq, ss_store_sk, SUM(CASE WHEN d.d_day_name = 'Sunday' THEN ss_sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN d.d_day_name = 'Monday' THEN ss_sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN d.d_day_name = 'Tuesday' THEN ss_sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN d.d_day_name = 'Wednesday' THEN ss_sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN d.d_day_name = 'Thursday' THEN ss_sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN d.d_day_name = 'Friday' THEN ss_sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN d.d_day_name = 'Saturday' THEN ss_sales_price ELSE NULL END) AS sat_sales FROM store_sales JOIN filtered_dates1 d ON ss_sold_date_sk = d.d_date_sk WHERE ss_sales_price / ss_list_price BETWEEN 0.65 AND 0.85 GROUP BY d.d_week_seq, ss_store_sk",
        "interfaces": {"outputs": ["d_week_seq", "ss_store_sk", "sun_sales", "mon_sales", "tue_sales", "wed_sales", "thu_sales", "fri_sales", "sat_sales"], "consumes": ["filtered_dates1"]}
      },
      "sales_year2": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d.d_week_seq, ss_store_sk, SUM(CASE WHEN d.d_day_name = 'Sunday' THEN ss_sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN d.d_day_name = 'Monday' THEN ss_sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN d.d_day_name = 'Tuesday' THEN ss_sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN d.d_day_name = 'Wednesday' THEN ss_sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN d.d_day_name = 'Thursday' THEN ss_sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN d.d_day_name = 'Friday' THEN ss_sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN d.d_day_name = 'Saturday' THEN ss_sales_price ELSE NULL END) AS sat_sales FROM store_sales JOIN filtered_dates2 d ON ss_sold_date_sk = d.d_date_sk WHERE ss_sales_price / ss_list_price BETWEEN 0.65 AND 0.85 GROUP BY d.d_week_seq, ss_store_sk",
        "interfaces": {"outputs": ["d_week_seq", "ss_store_sk", "sun_sales", "mon_sales", "tue_sales", "wed_sales", "thu_sales", "fri_sales", "sat_sales"], "consumes": ["filtered_dates2"]}
      },
      "stores_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk, s_store_id, s_store_name FROM store WHERE s_state IN ('AR','GA','IN','KS','KY','OH','SD','VA')",
        "interfaces": {"outputs": ["s_store_sk", "s_store_id", "s_store_name"], "consumes": []}
      },
      "main_deferred": {
        "type": "main_query",
        "change": "new",
        "sql": "SELECT y.s_store_name AS s_store_name1, y.s_store_id AS s_store_id1, y.d_week_seq AS d_week_seq1, y.sun_sales / x.sun_sales, y.mon_sales / x.mon_sales, y.tue_sales / x.tue_sales, y.wed_sales / x.wed_sales, y.thu_sales / x.thu_sales, y.fri_sales / x.fri_sales, y.sat_sales / x.sat_sales FROM (SELECT s.s_store_name, s.s_store_id, sy1.d_week_seq, sy1.sun_sales, sy1.mon_sales, sy1.tue_sales, sy1.wed_sales, sy1.thu_sales, sy1.fri_sales, sy1.sat_sales FROM sales_year1 sy1 JOIN stores_filtered s ON sy1.ss_store_sk = s.s_store_sk) y JOIN (SELECT s.s_store_id, sy2.d_week_seq, sy2.sun_sales, sy2.mon_sales, sy2.tue_sales, sy2.wed_sales, sy2.thu_sales, sy2.fri_sales, sy2.sat_sales FROM sales_year2 sy2 JOIN stores_filtered s ON sy2.ss_store_sk = s.s_store_sk) x ON y.s_store_id = x.s_store_id AND y.d_week_seq = x.d_week_seq - 52 ORDER BY s_store_name1, s_store_id1, d_week_seq1 LIMIT 100",
        "interfaces": {"outputs": ["s_store_name1", "s_store_id1", "d_week_seq1", "sun_sales1/sun_sales2", "mon_sales1/mon_sales2", "tue_sales1/tue_sales2", "wed_sales1/wed_sales2", "thu_sales1/thu_sales2", "fri_sales1/fri_sales2", "sat_sales1/sat_sales2"], "consumes": ["sales_year1", "sales_year2", "stores_filtered"]}
      }
    },
    "reconstruction_order": ["filtered_dates1", "filtered_dates2", "sales_year1", "sales_year2", "stores_filtered", "main_deferred"],
    "assembly_template": "WITH filtered_dates1 AS ({filtered_dates1}), filtered_dates2 AS ({filtered_dates2}), sales_year1 AS ({sales_year1}), sales_year2 AS ({sales_year2}), stores_filtered AS ({stores_filtered}) {main_deferred}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Restructured query by isolating date dimension filters into separate CTEs, pushing store filtering early, computing year aggregates separately, then joining the filtered year datasets. This avoids the comma-join weakness and allows predicate pushdown.

**Expected speedup**: 2-3x due to smaller intermediate aggregates (separate year aggregations), better join cardinality estimation (explicit JOIN syntax), and early filtering of stores.