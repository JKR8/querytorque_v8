### Part 1: Modified Logic Tree
```
QUERY: (single statement)
├── [CTE] wss_both_years  [+]
│   ├── SCAN (store_sales, date_dim, store (joins))
│   ├── JOIN (d_date_sk = ss_sold_date_sk)
│   ├── JOIN (ss_store_sk = s_store_sk)
│   ├── FILTER (ss_sales_price / ss_list_price BETWEEN 0.65 AND 0.85 AND d_month_seq BETWEEN 1183 AND 1206 AND s_state IN ('AR','GA','IN','KS','KY','OH','SD','VA'))
│   ├── AGG (GROUP BY d_week_seq, ss_store_sk, s_store_id, s_store_name)
│   └── OUTPUT (d_week_seq, ss_store_sk, s_store_id, s_store_name, sun_sales_y1, mon_sales_y1, tue_sales_y1, wed_sales_y1, thu_sales_y1, fri_sales_y1, sat_sales_y1, sun_sales_y2, mon_sales_y2, tue_sales_y2, wed_sales_y2, thu_sales_y2, fri_sales_y2, sat_sales_y2)
└── [MAIN] main_pivot  [~]
    ├── SCAN (wss_both_years y, wss_both_years x (self-join))
    ├── JOIN (y.s_store_id = x.s_store_id AND y.d_week_seq = x.d_week_seq - 52)
    ├── SORT (y.s_store_name ASC, y.s_store_id ASC, y.d_week_seq ASC)
    └── OUTPUT (s_store_name1, s_store_id1, d_week_seq1, y.sun_sales_y1 / x.sun_sales_y2, y.mon_sales_y1 / x.mon_sales_y2, y.tue_sales_y1 / x.tue_sales_y2, y.wed_sales_y1 / x.wed_sales_y2, y.thu_sales_y1 / x.thu_sales_y2, y.fri_sales_y1 / x.fri_sales_y2, y.sat_sales_y1 / x.sat_sales_y2)
```

### Part 2: Component Payload JSON
```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL v16.11",
  "rewrite_rules": [
    {"id": "R1", "type": "single_pass_aggregation", "description": "Replaced two separate filtered scans with a single conditional aggregation over both year ranges in one CTE, preserving the same logical grouping and output columns.", "applied_to": ["wss_both_years"]},
    {"id": "R2", "type": "cte_self_join", "description": "Changed main query to self-join the unified CTE (wss_both_years) on s_store_id and week offset of 52, computing year-over-year ratios directly from pre-aggregated columns.", "applied_to": ["main_pivot"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "wss_both_years": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_week_seq, ss_store_sk, s_store_id, s_store_name, SUM(CASE WHEN d_month_seq BETWEEN 1183 AND 1194 AND d_day_name='Sunday' THEN ss_sales_price END) AS sun_sales_y1, SUM(CASE WHEN d_month_seq BETWEEN 1183 AND 1194 AND d_day_name='Monday' THEN ss_sales_price END) AS mon_sales_y1, SUM(CASE WHEN d_month_seq BETWEEN 1183 AND 1194 AND d_day_name='Tuesday' THEN ss_sales_price END) AS tue_sales_y1, SUM(CASE WHEN d_month_seq BETWEEN 1183 AND 1194 AND d_day_name='Wednesday' THEN ss_sales_price END) AS wed_sales_y1, SUM(CASE WHEN d_month_seq BETWEEN 1183 AND 1194 AND d_day_name='Thursday' THEN ss_sales_price END) AS thu_sales_y1, SUM(CASE WHEN d_month_seq BETWEEN 1183 AND 1194 AND d_day_name='Friday' THEN ss_sales_price END) AS fri_sales_y1, SUM(CASE WHEN d_month_seq BETWEEN 1183 AND 1194 AND d_day_name='Saturday' THEN ss_sales_price END) AS sat_sales_y1, SUM(CASE WHEN d_month_seq BETWEEN 1195 AND 1206 AND d_day_name='Sunday' THEN ss_sales_price END) AS sun_sales_y2, SUM(CASE WHEN d_month_seq BETWEEN 1195 AND 1206 AND d_day_name='Monday' THEN ss_sales_price END) AS mon_sales_y2, SUM(CASE WHEN d_month_seq BETWEEN 1195 AND 1206 AND d_day_name='Tuesday' THEN ss_sales_price END) AS tue_sales_y2, SUM(CASE WHEN d_month_seq BETWEEN 1195 AND 1206 AND d_day_name='Wednesday' THEN ss_sales_price END) AS wed_sales_y2, SUM(CASE WHEN d_month_seq BETWEEN 1195 AND 1206 AND d_day_name='Thursday' THEN ss_sales_price END) AS thu_sales_y2, SUM(CASE WHEN d_month_seq BETWEEN 1195 AND 1206 AND d_day_name='Friday' THEN ss_sales_price END) AS fri_sales_y2, SUM(CASE WHEN d_month_seq BETWEEN 1195 AND 1206 AND d_day_name='Saturday' THEN ss_sales_price END) AS sat_sales_y2 FROM store_sales JOIN date_dim ON d_date_sk = ss_sold_date_sk JOIN store ON ss_store_sk = s_store_sk WHERE ss_sales_price / ss_list_price BETWEEN 0.65 AND 0.85 AND d_month_seq BETWEEN 1183 AND 1206 AND s_state IN ('AR','GA','IN','KS','KY','OH','SD','VA') GROUP BY d_week_seq, ss_store_sk, s_store_id, s_store_name",
        "interfaces": {"outputs": ["d_week_seq", "ss_store_sk", "s_store_id", "s_store_name", "sun_sales_y1", "mon_sales_y1", "tue_sales_y1", "wed_sales_y1", "thu_sales_y1", "fri_sales_y1", "sat_sales_y1", "sun_sales_y2", "mon_sales_y2", "tue_sales_y2", "wed_sales_y2", "thu_sales_y2", "fri_sales_y2", "sat_sales_y2"], "consumes": []}
      },
      "main_pivot": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT y.s_store_name AS s_store_name1, y.s_store_id AS s_store_id1, y.d_week_seq AS d_week_seq1, y.sun_sales_y1 / x.sun_sales_y2, y.mon_sales_y1 / x.mon_sales_y2, y.tue_sales_y1 / x.tue_sales_y2, y.wed_sales_y1 / x.wed_sales_y2, y.thu_sales_y1 / x.thu_sales_y2, y.fri_sales_y1 / x.fri_sales_y2, y.sat_sales_y1 / x.sat_sales_y2 FROM wss_both_years y JOIN wss_both_years x ON y.s_store_id = x.s_store_id AND y.d_week_seq = x.d_week_seq - 52 ORDER BY s_store_name1, s_store_id1, d_week_seq1 LIMIT 100",
        "interfaces": {"outputs": ["s_store_name1", "s_store_id1", "d_week_seq1", "y.sun_sales_y1 / x.sun_sales_y2", "y.mon_sales_y1 / x.mon_sales_y2", "y.tue_sales_y1 / x.tue_sales_y2", "y.wed_sales_y1 / x.wed_sales_y2", "y.thu_sales_y1 / x.thu_sales_y2", "y.fri_sales_y1 / x.fri_sales_y2", "y.sat_sales_y1 / x.sat_sales_y2"], "consumes": ["wss_both_years"]}
      }
    },
    "reconstruction_order": ["wss_both_years", "main_pivot"],
    "assembly_template": "WITH wss_both_years AS ({wss_both_years}) {main_pivot}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: The original query used two separate filtered scans (year1 and year2) via derived tables. We replaced them with a single CTE (`wss_both_years`) that performs conditional aggregation for both year ranges in one pass over the base tables, then self-joins that CTE for year-over-year comparison.

**Expected speedup**: Moderate to high. By scanning the fact table once instead of twice (via separate filtered aggregates), we reduce I/O and avoid redundant joins. The single-pass aggregation also leverages PostgreSQL's vectorized aggregation more efficiently.