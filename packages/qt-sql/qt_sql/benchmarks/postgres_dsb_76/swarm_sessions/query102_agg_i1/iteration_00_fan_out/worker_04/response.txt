## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ~660K
    ├── [CTE] date_range_cte  [+]  
    │   ├── SCAN (date_dim AS d1)
    │   ├── JOIN (date_dim AS d2 ON d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY'))
    │   ├── FILTER (d1.d_year = 2001)
    │   └── OUTPUT (d1_date_sk, d2_date_sk)
    ├── [CTE] filtered_item  [+]  
    │   ├── SCAN (item)
    │   ├── FILTER (i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93))
    │   └── OUTPUT (i_item_sk)
    ├── [CTE] filtered_customer  [+]  
    │   ├── SCAN (customer)
    │   ├── JOIN (customer_demographics ON c_current_cdemo_sk = cd_demo_sk)
    │   ├── JOIN (household_demographics ON c_current_hdemo_sk = hd_demo_sk)
    │   ├── JOIN (customer_address ON c_current_addr_sk = ca_address_sk)
    │   ├── FILTER (ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA'))
    │   └── OUTPUT (c_customer_sk, cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count)
    ├── [CTE] fact_join  [+]  
    │   ├── SCAN (web_sales)
    │   ├── JOIN (filtered_item ON ws_item_sk = i_item_sk)
    │   ├── JOIN (filtered_customer ON ws_bill_customer_sk = c_customer_sk)
    │   ├── JOIN (date_range_cte ON ws_sold_date_sk = d2_date_sk)
    │   ├── JOIN (store_sales ON ss_item_sk = i_item_sk AND ss_customer_sk = c_customer_sk AND ss_sold_date_sk = d1_date_sk)
    │   ├── JOIN (inventory ON inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_warehouse_sk = ws_warehouse_sk)
    │   ├── JOIN (warehouse ON ws_warehouse_sk = w_warehouse_sk)
    │   ├── JOIN (store ON s_state = w_state)
    │   ├── FILTER (ws_wholesale_cost BETWEEN 35 AND 55 AND inv_quantity_on_hand >= ss_quantity)
    │   └── OUTPUT (cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count)
    ├── [CTE] aggregation  [+]  
    │   ├── SCAN (fact_join)
    │   ├── GROUP BY (cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count)
    │   ├── AGGREGATE (COUNT(*) AS cnt)
    │   └── OUTPUT (cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, cnt)
    ├── [CTE] sort  [+]  
    │   ├── SCAN (aggregation)
    │   ├── ORDER BY (cnt)
    │   └── OUTPUT (cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, cnt)
    └── SELECT FROM sort
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16.11",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_isolation", "description": "Convert comma-separated joins to explicit JOIN syntax and pre-filter selective dimensions into CTEs", "applied_to": ["date_range_cte", "filtered_item", "filtered_customer"]},
    {"id": "R2", "type": "cte_materialization", "description": "Materialize date range CTE and dimension filters to create small hash tables for joins", "applied_to": ["date_range_cte", "filtered_item", "filtered_customer"]},
    {"id": "R3", "type": "parallelism_tuning", "description": "Enable parallel query execution", "applied_to": ["main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_range_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d1.d_date_sk AS d1_date_sk, d2.d_date_sk AS d2_date_sk FROM date_dim d1 JOIN date_dim d2 ON d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') WHERE d1.d_year = 2001",
        "interfaces": {"outputs": ["d1_date_sk", "d2_date_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93)",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "filtered_customer": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c.c_customer_sk, cd.cd_gender, cd.cd_marital_status, cd.cd_education_status, hd.hd_vehicle_count FROM customer c JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk JOIN household_demographics hd ON c.c_current_hdemo_sk = hd.hd_demo_sk JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE ca.ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA')",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count"], "consumes": []}
      },
      "fact_join": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT fc.cd_gender, fc.cd_marital_status, fc.cd_education_status, fc.hd_vehicle_count FROM web_sales ws JOIN filtered_item fi ON ws.ws_item_sk = fi.i_item_sk JOIN filtered_customer fc ON ws.ws_bill_customer_sk = fc.c_customer_sk JOIN date_range_cte dr ON ws.ws_sold_date_sk = dr.d2_date_sk JOIN store_sales ss ON ss.ss_item_sk = fi.i_item_sk AND ss.ss_customer_sk = fc.c_customer_sk AND ss.ss_sold_date_sk = dr.d1_date_sk JOIN inventory inv ON inv.inv_item_sk = ss.ss_item_sk AND inv.inv_date_sk = ss.ss_sold_date_sk AND inv.inv_warehouse_sk = ws.ws_warehouse_sk JOIN warehouse w ON ws.ws_warehouse_sk = w.w_warehouse_sk JOIN store s ON s.s_state = w.w_state WHERE ws.ws_wholesale_cost BETWEEN 35 AND 55 AND inv.inv_quantity_on_hand >= ss.ss_quantity",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count"], "consumes": ["filtered_item", "filtered_customer", "date_range_cte"]}
      },
      "aggregation": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM fact_join GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "cnt"], "consumes": ["fact_join"]}
      },
      "sort": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, cnt FROM aggregation ORDER BY cnt",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "cnt"], "consumes": ["aggregation"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, cnt FROM sort",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "cnt"], "consumes": ["sort"]}
      }
    },
    "reconstruction_order": ["date_range_cte", "filtered_item", "filtered_customer", "fact_join", "aggregation", "sort", "main_query"],
    "assembly_template": "WITH date_range_cte AS ({{date_range_cte}}), filtered_item AS ({{filtered_item}}), filtered_customer AS ({{filtered_customer}}), fact_join AS ({{fact_join}}), aggregation AS ({{aggregation}}), sort AS ({{sort}}) {{main_query}}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL max_parallel_workers_per_gather = 4"],
  "validation_checks": []
}
```

**Changes**: Restructured from single large comma-separated join into explicit CTEs following the Target Logical Tree. Materialized selective dimension filters (date_range, item, customer) into separate CTEs, then joined facts with explicit JOIN syntax. This enables better hash join planning with small probe tables and preserves semantic equivalence.

**Expected speedup**: ~2-3x (based on similar patterns from reference examples pg_date_cte_explicit_join and pg_dimension_prefetch_star)