## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~660K
    ├── WITH filtered_fact AS (CTE)  [+]
    │   └── SCAN (web_sales with filter on ws_wholesale_cost)
    ├── WITH filtered_item AS (CTE)  [+]
    │   └── SCAN (item with filter on i_category and i_manager_id)
    ├── WITH filtered_customer AS (CTE)  [+]
    │   ├── SCAN (customer)
    │   ├── JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk
    │   ├── JOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk
    │   ├── JOIN customer_address ON c_current_addr_sk = ca_address_sk
    │   └── FILTER (ca_state IN ('AZ','KS','OH','TX','WA'))
    ├── WITH date_range AS (CTE)  [+]
    │   ├── SCAN (date_dim d1 with filter on d_year)
    │   ├── CROSS JOIN LATERAL generate_series
    │   └── JOIN date_dim d2 ON d2.d_date = generated date
    ├── staged_join  [~]
    │   ├── JOIN filtered_fact ON ws_item_sk = i_item_sk
    │   ├── JOIN filtered_item ON ws_item_sk = i_item_sk
    │   ├── JOIN filtered_customer ON ws_bill_customer_sk = c_customer_sk
    │   ├── JOIN date_range ON ws_sold_date_sk = d2.d_date_sk
    │   ├── JOIN store_sales ON ss_item_sk = i_item_sk AND ss_customer_sk = c_customer_sk AND ss_sold_date_sk = d1.d_date_sk
    │   ├── JOIN inventory ON inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_warehouse_sk = ws_warehouse_sk
    │   ├── JOIN warehouse ON ws_warehouse_sk = w_warehouse_sk
    │   ├── JOIN store ON s_state = w_state
    │   └── FILTER (inv_quantity_on_hand >= ss_quantity)
    ├── AGG (GROUP BY)  [=]
    ├── SORT (cnt ASC)  [=]
    └── OUTPUT (cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, cnt)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "pg_materialized_dimension_fact_prefilter", "description": "Staged reduction: pre-filter fact and dimension tables into CTEs before expensive date-range join", "applied_to": ["filtered_fact", "filtered_item", "filtered_customer", "date_range"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_fact": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ws_item_sk, ws_bill_customer_sk, ws_sold_date_sk, ws_warehouse_sk FROM web_sales WHERE ws_wholesale_cost BETWEEN 35 AND 55",
        "interfaces": {"outputs": ["ws_item_sk", "ws_bill_customer_sk", "ws_sold_date_sk", "ws_warehouse_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93)",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "filtered_customer": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c.c_customer_sk, cd.cd_gender, cd.cd_marital_status, cd.cd_education_status, hd.hd_vehicle_count FROM customer c JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk JOIN household_demographics hd ON c.c_current_hdemo_sk = hd.hd_demo_sk JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE ca.ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA')",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count"], "consumes": []}
      },
      "date_range": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d1.d_date_sk AS d1_date_sk, d2.d_date_sk AS d2_date_sk FROM date_dim d1 CROSS JOIN LATERAL generate_series(d1.d_date, d1.d_date + INTERVAL '30 DAY', INTERVAL '1 DAY') AS d2_date JOIN date_dim d2 ON d2.d_date = d2_date WHERE d1.d_year = 2001",
        "interfaces": {"outputs": ["d1_date_sk", "d2_date_sk"], "consumes": []}
      },
      "staged_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT fc.cd_gender, fc.cd_marital_status, fc.cd_education_status, fc.hd_vehicle_count FROM filtered_fact ff JOIN filtered_item fi ON ff.ws_item_sk = fi.i_item_sk JOIN filtered_customer fc ON ff.ws_bill_customer_sk = fc.c_customer_sk JOIN date_range dr ON ff.ws_sold_date_sk = dr.d2_date_sk JOIN store_sales ss ON fi.i_item_sk = ss.ss_item_sk AND fc.c_customer_sk = ss.ss_customer_sk AND dr.d1_date_sk = ss.ss_sold_date_sk JOIN inventory inv ON ss.ss_item_sk = inv.inv_item_sk AND ss.ss_sold_date_sk = inv.inv_date_sk AND ff.ws_warehouse_sk = inv.inv_warehouse_sk JOIN warehouse w ON ff.ws_warehouse_sk = w.w_warehouse_sk JOIN store s ON s.s_state = w.w_state WHERE inv.inv_quantity_on_hand >= ss.ss_quantity",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count"], "consumes": ["filtered_fact", "filtered_item", "filtered_customer", "date_range"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM staged_join GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "cnt"], "consumes": ["staged_join"]}
      }
    },
    "reconstruction_order": ["filtered_fact", "filtered_item", "filtered_customer", "date_range", "staged_join", "main_query"],
    "assembly_template": "WITH filtered_fact AS ({filtered_fact}), filtered_item AS ({filtered_item}), filtered_customer AS ({filtered_customer}), date_range AS ({date_range}), staged_join AS ({staged_join}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '512MB'"],
  "validation_checks": []
}
```

**Changes**: Replaced the original flat join structure with staged reduction CTEs (filtered_fact, filtered_item, filtered_customer, date_range) that pre-filter tables before the expensive date-range join. This reduces the search space for the non-equi date correlation and maintains exact semantic equivalence.

**Expected speedup**: ~2.5x (based on similar pattern performance in reference examples). The staged CTEs dramatically cut the row counts before the complex join, reducing hash table sizes and join complexity.