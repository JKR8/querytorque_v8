<reasoning>
First, let me systematically analyze the query structure, constraints, and optimization opportunities.

1. **CLASSIFY**: This is a "self-join pattern on pre-aggregated CTE" archetype. The query:
   - Computes aggregated statistics (stdev, mean, cov) per warehouse/item/month from a star-schema
   - Filters on coefficient of variation > 1
   - Self-joins the CTE to compare month 5 vs month 6 for same warehouse/item
   - Has two nearly identical versions (second adds `inv1.cov > 1.5` filter)

2. **EXPLAIN PLAN ANALYSIS**: No EXPLAIN available, but logical-tree shows 50% cost in CTE, 50% in main query. Key observations:
   - The CTE scans inventory (fact) with 3 dimension joins
   - The CTE is referenced twice in main query (self-join)
   - Filters on d_moy=5 and d_moy=6 are applied AFTER CTE materialization
   - CTE groups by d_moy, so months 5 and 6 are in same CTE
   - The CTE is likely materialized once (PostgreSQL materializes CTEs by default)
   - The main query self-joins the full CTE but filters each side to different months

3. **GAP MATCHING**:
   - COMMA_JOIN_WEAKNESS: Yes - CTE uses comma-separated joins (lines 6-9)
   - CROSS_CTE_PREDICATE_BLINDNESS: Yes - Same CTE scanned twice with month filters applied late
   - CORRELATED_SUBQUERY_PARALYSIS: No - No correlated subqueries
   - NON_EQUI_JOIN_INPUT_BLINDNESS: No - Only equality joins

4. **AGGREGATION TRAP CHECK**:
   - CTE uses STDDEV_SAMP and AVG grouped by (warehouse, item, month)
   - Each month's aggregates are independent (d_moy in GROUP BY)
   - Safe to split or pivot because grouping includes d_moy
   - Pivoting with MAX(CASE WHEN d_moy=5 THEN mean END) is safe - each (warehouse,item,month) group has exactly one row

5. **TRANSFORM SELECTION** (ranked by expected value):
   1. **star_join_prefetch**: Attack comma joins, pre-filter dimensions
   2. **scan_consolidation_pivot**: Attack repeated CTE scan - consolidate months 5&6 in one pass
   3. **self_join_elimination**: Attack self-join - split CTE into month5/month6 versions
   4. **predicate_pushdown**: Attack late month filters - push into CTE definition

6. **LOGICAL TREE DESIGN**:
   For each strategy, need to ensure CTE outputs all columns needed downstream
   Main query needs: w_warehouse_sk, i_item_sk, d_moy, mean, cov from both sides
   CTE needs to output these for downstream consumption
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
This query analyzes inventory variability, comparing coefficient of variation between consecutive months (May vs June 2002) for Sports/Shoes items managed by specific managers. The business intent is to identify items with high inventory volatility. JOIN semantics are INNER throughout—all dimension tables must match the fact table, and the self-join requires matching warehouse and item. Aggregation trap: STDDEV_SAMP requires ≥2 values per group; NULL groups are filtered out by CASE mean WHEN 0 THEN NULL. Filter dependencies: The cov>1 filter in CTE must be applied BEFORE the self-join; the d_moy=5/6 filters in main query are independent per side.

BOTTLENECK_DIAGNOSIS:
The dominant cost is the initial star-schema scan and aggregation (50% logical cost), which scans large inventory table with 3 dimension joins via comma syntax. Cardinality flow: inventory filtered by quantity range → joined with dimensions → grouped by warehouse/item/month (~1K rows) → filtered by cov>1 → self-joined with month filters. The optimizer already handles the self-join efficiently (hash join on warehouse/item keys). Logical-tree cost is misleading: the comma joins prevent optimal join order, and late month filters force full CTE materialization of all months when only 5 and 6 are needed.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output 10 columns in exact order: inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov, inv2.w_warehouse_sk, inv2.i_item_sk, inv2.d_moy, inv2.mean, inv2.cov
- CTE_COLUMN_COMPLETENESS: Any CTE must include w_warehouse_sk, i_item_sk, d_moy, mean, cov for downstream self-join and SELECT
- LITERAL_PRESERVATION: Must preserve literal values: 2002, 'Shoes','Sports', 42, 61, 791, 991, 5, 1, 1.5 (second query)
- SEMANTIC_EQUIVALENCE: Must return same rows—cov>1 filter in CTE and month filters in main query are critical
- COMMA_JOIN_WEAKNESS: CTE uses comma-separated joins (inventory, item, warehouse, date_dim)
- CROSS_CTE_PREDICATE_BLINDNESS: CTE contains all months, filtered late in main query (d_moy=5/6)

REGRESSION_WARNINGS:
1. CTE blocking parallelism (observed regression in Q045):
   CAUSE: Materialized CTE prevents parallel table scan on inventory
   RULE: Use LATERAL or subquery instead of CTE for fact table scan when parallel execution is needed
2. UNION ALL over-splitting (observed 0.21x on Q085):
   CAUSE: Splitting OR conditions into UNION ALL when PostgreSQL's bitmap scan handles it better
   RULE: Do NOT convert OR to UNION ALL—this query has no OR conditions requiring split

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  filtered_date -> filtered_item -> filtered_warehouse -> joined_fact -> aggregated -> filtered_cov -> main_self_join
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_year = 2002
    OUTPUT: d_date_sk, d_moy
    EXPECTED_ROWS: ~365
    CONSUMERS: joined_fact
  filtered_item:
    FROM: item
    WHERE: i_category IN ('Shoes', 'Sports') AND i_manager_id BETWEEN 42 AND 61
    OUTPUT: i_item_sk
    EXPECTED_ROWS: ~100s
    CONSUMERS: joined_fact
  filtered_warehouse:
    FROM: warehouse
    OUTPUT: w_warehouse_sk, w_warehouse_name
    EXPECTED_ROWS: ~100s
    CONSUMERS: joined_fact
  joined_fact:
    FROM: inventory
    JOIN: INNER JOIN filtered_date ON inv_date_sk = d_date_sk
    JOIN: INNER JOIN filtered_item ON inv_item_sk = i_item_sk
    JOIN: INNER JOIN filtered_warehouse ON inv_warehouse_sk = w_warehouse_sk
    WHERE: inv_quantity_on_hand BETWEEN 791 AND 991
    OUTPUT: w_warehouse_sk, w_warehouse_name, i_item_sk, d_moy, inv_quantity_on_hand
    EXPECTED_ROWS: ~10K-100K
    CONSUMERS: aggregated
  aggregated:
    FROM: joined_fact
    GROUP BY: w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy
    AGGREGATE: STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean
    OUTPUT: w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy, stdev, mean
    EXPECTED_ROWS: ~1K
    CONSUMERS: filtered_cov
  filtered_cov:
    FROM: aggregated
    WHERE: CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1
    OUTPUT: w_warehouse_sk, i_item_sk, d_moy, mean, stdev/mean AS cov
    EXPECTED_ROWS: ~100s
    CONSUMERS: main_self_join
  main_self_join:
    FROM: filtered_cov AS inv1 INNER JOIN filtered_cov AS inv2 ON inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk
    WHERE: inv1.d_moy = 5 AND inv2.d_moy = 6
    ORDER BY: inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov, inv2.d_moy, inv2.mean, inv2.cov
    OUTPUT: inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov, inv2.w_warehouse_sk, inv2.i_item_sk, inv2.d_moy, inv2.mean, inv2.cov
    EXPECTED_ROWS: ~10s
    CONSUMERS: final
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply pre-filtering of all 3 dimensions into CTEs with explicit JOIN syntax; ignore the UNION ALL aspect (not needed)
- pg_date_cte_explicit_join: Apply date_dim isolation into CTE and explicit JOINs; ignore the single-dimension focus—we need all 3 dimensions
- early_filter_decorrelate: Apply early dimension filtering; ignore decorrelation aspect (no correlated subqueries)
HAZARD_FLAGS:
- CTE materialization may block parallelism on inventory scan
- Multiple CTEs increase planning time

=== WORKER 2 BRIEFING ===

STRATEGY: scan_consolidation_pivot
TARGET_LOGICAL_TREE:
  filtered_star -> aggregated_both_months -> pivoted -> main_no_join
NODE_CONTRACTS:
  filtered_star:
    FROM: inventory 
    JOIN: date_dim ON inv_date_sk = d_date_sk
    JOIN: item ON inv_item_sk = i_item_sk  
    JOIN: warehouse ON inv_warehouse_sk = w_warehouse_sk
    WHERE: d_year = 2002 AND i_category IN ('Shoes', 'Sports') AND i_manager_id BETWEEN 42 AND 61 
           AND inv_quantity_on_hand BETWEEN 791 AND 991 AND d_moy IN (5, 6)
    OUTPUT: w_warehouse_sk, w_warehouse_name, i_item_sk, d_moy, inv_quantity_on_hand
    EXPECTED_ROWS: ~10K
    CONSUMERS: aggregated_both_months
  aggregated_both_months:
    FROM: filtered_star
    GROUP BY: w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy
    AGGREGATE: STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean
    OUTPUT: w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy, stdev, mean
    EXPECTED_ROWS: ~100s
    CONSUMERS: pivoted
  pivoted:
    FROM: aggregated_both_months
    WHERE: CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1
    GROUP BY: w_warehouse_sk, i_item_sk
    AGGREGATE: MAX(CASE WHEN d_moy = 5 THEN mean END) AS mean_5,
               MAX(CASE WHEN d_moy = 5 THEN stdev/mean END) AS cov_5,
               MAX(CASE WHEN d_moy = 6 THEN mean END) AS mean_6,
               MAX(CASE WHEN d_moy = 6 THEN stdev/mean END) AS cov_6
    OUTPUT: w_warehouse_sk, i_item_sk, mean_5, cov_5, mean_6, cov_6
    EXPECTED_ROWS: ~10s
    CONSUMERS: main_no_join
  main_no_join:
    FROM: pivoted
    WHERE: cov_5 IS NOT NULL AND cov_6 IS NOT NULL
    ORDER BY: w_warehouse_sk, i_item_sk, 5, mean_5, cov_5, 6, mean_6, cov_6
    OUTPUT: w_warehouse_sk AS inv1_warehouse_sk, i_item_sk AS inv1_item_sk, 5 AS inv1_d_moy, mean_5 AS inv1_mean, cov_5 AS inv1_cov,
            w_warehouse_sk AS inv2_warehouse_sk, i_item_sk AS inv2_item_sk, 6 AS inv2_d_moy, mean_6 AS inv2_mean, cov_6 AS inv2_cov
    EXPECTED_ROWS: ~10s
    CONSUMERS: final
EXAMPLES: pg_self_join_decomposition, single_pass_aggregation, pg_materialized_dimension_fact_prefilter
EXAMPLE_ADAPTATION:
- pg_self_join_decomposition: Apply single materialization of fact+dimensions; ignore deriving different aggregates—we need same aggregates for different months
- single_pass_aggregation: Apply single scan with CASE pivoting; ignore FILTER clauses (use MAX(CASE) for safety with STDDEV_SAMP)
- pg_materialized_dimension_fact_prefilter: Apply staged reduction with dimension CTEs; ignore non-equi join aspect
HAZARD_FLAGS:
- Pivoting with MAX(CASE) requires each (warehouse,item,month) has exactly one row (guaranteed by GROUP BY)
- Must handle NULL when month missing (filter out rows where either month missing)

=== WORKER 3 BRIEFING ===

STRATEGY: self_join_elimination
TARGET_LOGICAL_TREE:
  filtered_star_month5 -> aggregated5 -> filtered_cov5 -> 
  filtered_star_month6 -> aggregated6 -> filtered_cov6 -> 
  main_join_reduced
NODE_CONTRACTS:
  filtered_star_month5:
    FROM: inventory 
    JOIN: date_dim ON inv_date_sk = d_date_sk
    JOIN: item ON inv_item_sk = i_item_sk  
    JOIN: warehouse ON inv_warehouse_sk = w_warehouse_sk
    WHERE: d_year = 2002 AND d_moy = 5 AND i_category IN ('Shoes', 'Sports') 
           AND i_manager_id BETWEEN 42 AND 61 AND inv_quantity_on_hand BETWEEN 791 AND 991
    OUTPUT: w_warehouse_sk, w_warehouse_name, i_item_sk, inv_quantity_on_hand
    EXPECTED_ROWS: ~5K
    CONSUMERS: aggregated5
  aggregated5:
    FROM: filtered_star_month5
    GROUP BY: w_warehouse_name, w_warehouse_sk, i_item_sk
    AGGREGATE: STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean
    OUTPUT: w_warehouse_name, w_warehouse_sk, i_item_sk, stdev, mean
    EXPECTED_ROWS: ~100s
    CONSUMERS: filtered_cov5
  filtered_cov5:
    FROM: aggregated5
    WHERE: CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1
    OUTPUT: w_warehouse_sk, i_item_sk, mean AS mean_5, stdev/mean AS cov_5
    EXPECTED_ROWS: ~10s
    CONSUMERS: main_join_reduced
  filtered_star_month6:
    FROM: inventory 
    JOIN: date_dim ON inv_date_sk = d_date_sk
    JOIN: item ON inv_item_sk = i_item_sk  
    JOIN: warehouse ON inv_warehouse_sk = w_warehouse_sk
    WHERE: d_year = 2002 AND d_moy = 6 AND i_category IN ('Shoes', 'Sports') 
           AND i_manager_id BETWEEN 42 AND 61 AND inv_quantity_on_hand BETWEEN 791 AND 991
    OUTPUT: w_warehouse_sk, w_warehouse_name, i_item_sk, inv_quantity_on_hand
    EXPECTED_ROWS: ~5K
    CONSUMERS: aggregated6
  aggregated6:
    FROM: filtered_star_month6
    GROUP BY: w_warehouse_name, w_warehouse_sk, i_item_sk
    AGGREGATE: STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean
    OUTPUT: w_warehouse_name, w_warehouse_sk, i_item_sk, stdev, mean
    EXPECTED_ROWS: ~100s
    CONSUMERS: filtered_cov6
  filtered_cov6:
    FROM: aggregated6
    WHERE: CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1
    OUTPUT: w_warehouse_sk, i_item_sk, mean AS mean_6, stdev/mean AS cov_6
    EXPECTED_ROWS: ~10s
    CONSUMERS: main_join_reduced
  main_join_reduced:
    FROM: filtered_cov5 AS inv1 INNER JOIN filtered_cov6 AS inv2 ON inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk
    ORDER BY: inv1.w_warehouse_sk, inv1.i_item_sk, 5, inv1.mean_5, inv1.cov_5, 6, inv2.mean_6, inv2.cov_6
    OUTPUT: inv1.w_warehouse_sk, inv1.i_item_sk, 5 AS inv1_d_moy, inv1.mean_5 AS inv1_mean, inv1.cov_5 AS inv1_cov,
            inv2.w_warehouse_sk, inv2.i_item_sk, 6 AS inv2_d_moy, inv2.mean_6 AS inv2_mean, inv2.cov_6 AS inv2_cov
    EXPECTED_ROWS: ~10s
    CONSUMERS: final
EXAMPLES: pg_self_join_decomposition, union_cte_split, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_self_join_decomposition: Apply separate CTEs for each month; ignore single materialization aspect
- union_cte_split: Apply splitting by discriminator (month); ignore UNION ALL structure
- early_filter_decorrelate: Apply early month filtering; ignore decorrelation
HAZARD_FLAGS:
- Duplicates inventory scan (2x) but each scan is smaller (filtered by month)
- Must ensure both month CTEs include same warehouse/item combinations for join

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: lateral_parallel_union
TARGET_LOGICAL_TREE:
  dim_ctes -> lateral_union_months -> main_join
NODE_CONTRACTS:
  dim_date:
    FROM: date_dim
    WHERE: d_year = 2002 AND d_moy IN (5, 6)
    OUTPUT: d_date_sk, d_moy
    EXPECTED_ROWS: ~60
    CONSUMERS: lateral_union_months
  dim_item:
    FROM: item
    WHERE: i_category IN ('Shoes', 'Sports') AND i_manager_id BETWEEN 42 AND 61
    OUTPUT: i_item_sk
    EXPECTED_ROWS: ~100s
    CONSUMERS: lateral_union_months
  dim_warehouse:
    FROM: warehouse
    OUTPUT: w_warehouse_sk, w_warehouse_name
    EXPECTED_ROWS: ~100s
    CONSUMERS: lateral_union_months
  lateral_union_months:
    FROM: dim_warehouse, dim_item, LATERAL (
      SELECT d_moy, STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean
      FROM inventory
      JOIN dim_date ON inv_date_sk = d_date_sk
      WHERE inv_warehouse_sk = w_warehouse_sk AND inv_item_sk = i_item_sk 
        AND inv_quantity_on_hand BETWEEN 791 AND 991
      GROUP BY d_moy
      HAVING CASE AVG(inv_quantity_on_hand) WHEN 0 THEN 0 ELSE STDDEV_SAMP(inv_quantity_on_hand)/AVG(inv_quantity_on_hand) END > 1
    ) AS month_stats
    OUTPUT: w_warehouse_sk, i_item_sk, d_moy, mean, stdev/mean AS cov
    EXPECTED_ROWS: ~100s
    CONSUMERS: main_join
  main_join:
    FROM: lateral_union_months AS m5 INNER JOIN lateral_union_months AS m6 
          ON m5.w_warehouse_sk = m6.w_warehouse_sk AND m5.i_item_sk = m6.i_item_sk
    WHERE: m5.d_moy = 5 AND m6.d_moy = 6
    ORDER BY: m5.w_warehouse_sk, m5.i_item_sk, m5.d_moy, m5.mean, m5.cov, m6.d_moy, m6.mean, m6.cov
    OUTPUT: m5.w_warehouse_sk, m5.i_item_sk, m5.d_moy, m5.mean, m5.cov, m6.w_warehouse_sk, m6.i_item_sk, m6.d_moy, m6.mean, m6.cov
    EXPECTED_ROWS: ~10s
    CONSUMERS: final
EXAMPLES: pg_dimension_prefetch_star, pg_materialized_dimension_fact_prefilter, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply dimension CTEs; ignore explicit JOIN syntax in main query
- pg_materialized_dimension_fact_prefilter: Apply staged dimension reduction; ignore materialized fact CTE
- early_filter_decorrelate: Apply early dimension filtering; ignore decorrelation
HAZARD_FLAGS:
- LATERAL may prevent parallel execution of inventory scan
- Complex HAVING clause with aggregates in CASE expression
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: novel_combination