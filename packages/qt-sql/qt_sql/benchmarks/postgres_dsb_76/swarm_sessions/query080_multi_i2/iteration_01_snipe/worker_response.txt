## Modified Logic Tree

```
[=] root (UNION ALL + ROLLUP)
    [~] date_filtered (now MATERIALIZED, includes d_date_sk)
        [-] Original: SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN ...
        [+] New: MATERIALIZED CTE with same filter
    [~] item_filtered (now MATERIALIZED, includes i_item_sk)
        [-] Original: SELECT i_item_sk, i_current_price, i_category FROM item WHERE ...
        [+] New: MATERIALIZED CTE with same filter
    [~] promo_filtered (now MATERIALIZED, includes p_promo_sk)
        [-] Original: SELECT p_promo_sk FROM promotion WHERE ...
        [+] New: MATERIALIZED CTE with same filter
    [~] ssr (store channel aggregation)
        [~] Join structure
            [-] Comma joins with WHERE clause
            [+] Explicit JOIN syntax: store_sales LEFT JOIN store_returns ON ...
            [+] INNER JOIN to MATERIALIZED dimension CTEs
        [~] Filter placement
            [-] ss_wholesale_cost filter in WHERE clause
            [+] ss_wholesale_cost filter pushed to store_sales scan
    [~] csr (catalog channel aggregation)
        [~] Join structure
            [-] Comma joins with WHERE clause  
            [+] Explicit JOIN syntax: catalog_sales LEFT JOIN catalog_returns ON ...
            [+] INNER JOIN to MATERIALIZED dimension CTEs
        [~] Filter placement
            [-] cs_wholesale_cost filter in WHERE clause
            [+] cs_wholesale_cost filter pushed to catalog_sales scan
    [~] wsr (web channel aggregation)
        [~] Join structure
            [-] Comma joins with WHERE clause
            [+] Explicit JOIN syntax: web_sales LEFT JOIN web_returns ON ...
            [+] INNER JOIN to MATERIALIZED dimension CTEs
        [~] Filter placement
            [-] ws_wholesale_cost filter in WHERE clause
            [+] ws_wholesale_cost filter pushed to web_sales scan
    [=] union_all (combines three channels)
    [=] rollup_aggregation (GROUP BY ROLLUP)
    [=] final_sort_and_limit
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_materialization", "description": "Convert dimension CTEs to MATERIALIZED to prevent inlining and enable hash join planning", "applied_to": ["date_filtered", "item_filtered", "promo_filtered"]},
    {"id": "R2", "type": "explicit_join_syntax", "description": "Replace comma joins with explicit JOIN...ON syntax for better join ordering", "applied_to": ["ssr", "csr", "wsr"]},
    {"id": "R3", "type": "predicate_pushdown", "description": "Push wholesale_cost filter directly into fact table joins to reduce early rowcount", "applied_to": ["ssr", "csr", "wsr"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1999-10-21' AS DATE) AND CAST('1999-10-21' AS DATE) + INTERVAL '30 DAY'",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "item_filtered": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT i_item_sk, i_current_price, i_category FROM item WHERE i_current_price > 50 AND i_category IN ('Men', 'Music')",
        "interfaces": {"outputs": ["i_item_sk", "i_current_price", "i_category"], "consumes": []}
      },
      "promo_filtered": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT p_promo_sk FROM promotion WHERE p_channel_email = 'Y' AND p_channel_tv = 'N' AND p_channel_radio = 'N' AND p_channel_press = 'N' AND p_channel_event = 'N'",
        "interfaces": {"outputs": ["p_promo_sk"], "consumes": []}
      },
      "ssr": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, SUM(COALESCE(sr_return_amt, 0)) AS returns, SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit FROM store_sales INNER JOIN date_filtered ON ss_sold_date_sk = date_filtered.d_date_sk INNER JOIN store ON ss_store_sk = s_store_sk INNER JOIN item_filtered ON ss_item_sk = item_filtered.i_item_sk INNER JOIN promo_filtered ON ss_promo_sk = promo_filtered.p_promo_sk LEFT OUTER JOIN store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number) WHERE ss_wholesale_cost BETWEEN 21 AND 36 GROUP BY s_store_id",
        "interfaces": {"outputs": ["store_id", "sales", "returns", "profit"], "consumes": ["date_filtered", "item_filtered", "promo_filtered"]}
      },
      "csr": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cp_catalog_page_id AS catalog_page_id, SUM(cs_ext_sales_price) AS sales, SUM(COALESCE(cr_return_amount, 0)) AS returns, SUM(cs_net_profit - COALESCE(cr_net_loss, 0)) AS profit FROM catalog_sales INNER JOIN date_filtered ON cs_sold_date_sk = date_filtered.d_date_sk INNER JOIN catalog_page ON cs_catalog_page_sk = cp_catalog_page_sk INNER JOIN item_filtered ON cs_item_sk = item_filtered.i_item_sk INNER JOIN promo_filtered ON cs_promo_sk = promo_filtered.p_promo_sk LEFT OUTER JOIN catalog_returns ON (cs_item_sk = cr_item_sk AND cs_order_number = cr_order_number) WHERE cs_wholesale_cost BETWEEN 21 AND 36 GROUP BY cp_catalog_page_id",
        "interfaces": {"outputs": ["catalog_page_id", "sales", "returns", "profit"], "consumes": ["date_filtered", "item_filtered", "promo_filtered"]}
      },
      "wsr": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT web_site_id, SUM(ws_ext_sales_price) AS sales, SUM(COALESCE(wr_return_amt, 0)) AS returns, SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit FROM web_sales INNER JOIN date_filtered ON ws_sold_date_sk = date_filtered.d_date_sk INNER JOIN web_site ON ws_web_site_sk = web_site_sk INNER JOIN item_filtered ON ws_item_sk = item_filtered.i_item_sk INNER JOIN promo_filtered ON ws_promo_sk = promo_filtered.p_promo_sk LEFT OUTER JOIN web_returns ON (ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number) WHERE ws_wholesale_cost BETWEEN 21 AND 36 GROUP BY web_site_id",
        "interfaces": {"outputs": ["web_site_id", "sales", "returns", "profit"], "consumes": ["date_filtered", "item_filtered", "promo_filtered"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["channel", "id", "sales", "returns", "profit"], "consumes": ["ssr", "csr", "wsr"]}
      }
    },
    "reconstruction_order": ["date_filtered", "item_filtered", "promo_filtered", "ssr", "csr", "wsr", "main_query"],
    "assembly_template": "WITH date_filtered AS MATERIALIZED ({date_filtered}), item_filtered AS MATERIALIZED ({item_filtered}), promo_filtered AS MATERIALIZED ({promo_filtered}), ssr AS ({ssr}), csr AS ({csr}), wsr AS ({wsr}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL join_collapse_limit = 8",
    "SET LOCAL from_collapse_limit = 8", 
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL work_mem = '64MB'"
  ],
  "validation_checks": []
}
```

## Complete Optimized SQL

```sql
WITH date_filtered AS MATERIALIZED (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1999-10-21' AS DATE) AND CAST('1999-10-21' AS DATE) + INTERVAL '30 DAY'), item_filtered AS MATERIALIZED (SELECT i_item_sk, i_current_price, i_category FROM item WHERE i_current_price > 50 AND i_category IN ('Men', 'Music')), promo_filtered AS MATERIALIZED (SELECT p_promo_sk FROM promotion WHERE p_channel_email = 'Y' AND p_channel_tv = 'N' AND p_channel_radio = 'N' AND p_channel_press = 'N' AND p_channel_event = 'N'), ssr AS (SELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, SUM(COALESCE(sr_return_amt, 0)) AS returns, SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit FROM store_sales INNER JOIN date_filtered ON ss_sold_date_sk = date_filtered.d_date_sk INNER JOIN store ON ss_store_sk = s_store_sk INNER JOIN item_filtered ON ss_item_sk = item_filtered.i_item_sk INNER JOIN promo_filtered ON ss_promo_sk = promo_filtered.p_promo_sk LEFT OUTER JOIN store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number) WHERE ss_wholesale_cost BETWEEN 21 AND 36 GROUP BY s_store_id), csr AS (SELECT cp_catalog_page_id AS catalog_page_id, SUM(cs_ext_sales_price) AS sales, SUM(COALESCE(cr_return_amount, 0)) AS returns, SUM(cs_net_profit - COALESCE(cr_net_loss, 0)) AS profit FROM catalog_sales INNER JOIN date_filtered ON cs_sold_date_sk = date_filtered.d_date_sk INNER JOIN catalog_page ON cs_catalog_page_sk = cp_catalog_page_sk INNER JOIN item_filtered ON cs_item_sk = item_filtered.i_item_sk INNER JOIN promo_filtered ON cs_promo_sk = promo_filtered.p_promo_sk LEFT OUTER JOIN catalog_returns ON (cs_item_sk = cr_item_sk AND cs_order_number = cr_order_number) WHERE cs_wholesale_cost BETWEEN 21 AND 36 GROUP BY cp_catalog_page_id), wsr AS (SELECT web_site_id, SUM(ws_ext_sales_price) AS sales, SUM(COALESCE(wr_return_amt, 0)) AS returns, SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit FROM web_sales INNER JOIN date_filtered ON ws_sold_date_sk = date_filtered.d_date_sk INNER JOIN web_site ON ws_web_site_sk = web_site_sk INNER JOIN item_filtered ON ws_item_sk = item_filtered.i_item_sk INNER JOIN promo_filtered ON ws_promo_sk = promo_filtered.p_promo_sk LEFT OUTER JOIN web_returns ON (ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number) WHERE ws_wholesale_cost BETWEEN 21 AND 36 GROUP BY web_site_id) SELECT channel, id, SUM(sales) AS sales, SUM(returns) AS returns, SUM(profit) AS profit FROM (SELECT 'store channel' AS channel, 'store' || store_id AS id, sales, returns, profit FROM ssr UNION ALL SELECT 'catalog channel' AS channel, 'catalog_page' || catalog_page_id AS id, sales, returns, profit FROM csr UNION ALL SELECT 'web channel' AS channel, 'web_site' || web_site_id AS id, sales, returns, profit FROM wsr) AS x GROUP BY ROLLUP (channel, id) ORDER BY channel, id LIMIT 100
```

**Changes**: Materialized CTEs + explicit JOIN syntax + wholesale_cost pushdown to fact tables. This addresses PostgreSQL's comma-join weakness and enables hash join planning with tiny dimension tables.

**Expected speedup**: 1.8-2.2x. The materialization prevents CTE inlining and allows hash joins with small dimension results. Explicit JOIN syntax gives the optimizer better cardinality estimates for join ordering.