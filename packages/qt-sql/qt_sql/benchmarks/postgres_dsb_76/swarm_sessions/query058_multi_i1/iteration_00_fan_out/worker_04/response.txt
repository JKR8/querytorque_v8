## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_list_cte  [!]
│   ├── SCAN (date_dim)
│   ├── FILTER (d_month_seq = (SELECT d_month_seq FROM date_dim WHERE d_date = '1998-05-19'))
│   └── OUTPUT (d_date_sk, d_date)
├── [CTE] unified_sales_cte  [!]
│   ├── UNION_ALL [store_sales + catalog_sales + web_sales with channel discriminator]
│   │   ├── store_sales: ss_item_sk, ss_sold_date_sk, ss_customer_sk, ss_ext_sales_price, ss_list_price, 'store'
│   │   ├── catalog_sales: cs_item_sk, cs_sold_date_sk, cs_bill_customer_sk, cs_ext_sales_price, cs_list_price, 'catalog'
│   │   └── web_sales: ws_item_sk, ws_sold_date_sk, ws_bill_customer_sk, ws_ext_sales_price, ws_list_price, 'web'
│   ├── JOIN (sales.sold_date_sk = date_list_cte.d_date_sk)
│   ├── JOIN (sales.item_sk = item.i_item_sk)
│   ├── JOIN (sales.customer_sk = customer.c_customer_sk)
│   ├── FILTER (sales.list_price BETWEEN 242 AND 271)
│   ├── FILTER (item.i_manager_id BETWEEN 71 AND 100)
│   ├── FILTER (customer.c_birth_year BETWEEN 1945 AND 1951)
│   └── OUTPUT (i_item_id, c_birth_year, channel, sales_price)
├── [CTE] aggregated_sales_cte  [!]
│   ├── SCAN (unified_sales_cte)
│   ├── AGG (GROUP BY i_item_id, c_birth_year, channel)
│   ├── AGGREGATE (SUM(sales_price) AS channel_rev)
│   └── OUTPUT (item_id, birth_year, channel, channel_rev)
├── [CTE] pivoted_sales_cte  [!]
│   ├── SCAN (aggregated_sales_cte)
│   ├── AGG (GROUP BY item_id, birth_year)
│   ├── AGGREGATE (MAX(CASE WHEN channel='store' THEN channel_rev END) AS ss_item_rev)
│   ├── AGGREGATE (MAX(CASE WHEN channel='catalog' THEN channel_rev END) AS cs_item_rev)
│   ├── AGGREGATE (MAX(CASE WHEN channel='web' THEN channel_rev END) AS ws_item_rev)
│   └── OUTPUT (item_id, birth_year, ss_item_rev, cs_item_rev, ws_item_rev)
└── [MAIN] main_query  [~]
    ├── SCAN (pivoted_sales_cte)
    ├── FILTER (ss_item_rev BETWEEN 0.9 * cs_item_rev AND 1.1 * cs_item_rev)
    ├── FILTER (ss_item_rev BETWEEN 0.9 * ws_item_rev AND 1.1 * ws_item_rev)
    ├── FILTER (cs_item_rev BETWEEN 0.9 * ss_item_rev AND 1.1 * ss_item_rev)
    ├── FILTER (cs_item_rev BETWEEN 0.9 * ws_item_rev AND 1.1 * ws_item_rev)
    ├── FILTER (ws_item_rev BETWEEN 0.9 * ss_item_rev AND 1.1 * ss_item_rev)
    ├── FILTER (ws_item_rev BETWEEN 0.9 * cs_item_rev AND 1.1 * cs_item_rev)
    ├── COMPUTE (ss_item_rev/((ss_item_rev+cs_item_rev+ws_item_rev)/3) * 100 AS ss_dev)
    ├── COMPUTE (cs_item_rev/((ss_item_rev+cs_item_rev+ws_item_rev)/3) * 100 AS cs_dev)
    ├── COMPUTE (ws_item_rev/((ss_item_rev+cs_item_rev+ws_item_rev)/3) * 100 AS ws_dev)
    ├── COMPUTE ((ss_item_rev+cs_item_rev+ws_item_rev)/3 AS average)
    ├── SORT (item_id, birth_year, ss_item_rev)
    └── OUTPUT (item_id, birth_year, ss_item_rev, ss_dev, cs_item_rev, cs_dev, ws_item_rev, ws_dev, average)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16.11",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "union_consolidation",
      "description": "Consolidated three separate sales CTEs into single UNION ALL with channel discriminator",
      "applied_to": ["unified_sales_cte"]
    },
    {
      "id": "R2",
      "type": "star_join_prefetch",
      "description": "Replaced comma-separated joins with explicit INNER JOINs and moved date subquery to reusable CTE",
      "applied_to": ["date_list_cte", "unified_sales_cte"]
    },
    {
      "id": "R3",
      "type": "pivot_aggregation",
      "description": "Replaced triple join of channel-specific aggregates with single-pass aggregation + MAX(CASE) pivot",
      "applied_to": ["aggregated_sales_cte", "pivoted_sales_cte"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "date_list_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq = (SELECT d_month_seq FROM date_dim WHERE d_date = '1998-05-19')",
          "interfaces": {
            "outputs": ["d_date_sk", "d_date"],
            "consumes": []
          }
        },
        "unified_sales_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i.i_item_id, c.c_birth_year, sales.channel, sales.sales_price FROM (SELECT ss_item_sk AS item_sk, ss_sold_date_sk AS sold_date_sk, ss_customer_sk AS customer_sk, ss_ext_sales_price AS sales_price, ss_list_price AS list_price, 'store' AS channel FROM store_sales UNION ALL SELECT cs_item_sk, cs_sold_date_sk, cs_bill_customer_sk, cs_ext_sales_price, cs_list_price, 'catalog' FROM catalog_sales UNION ALL SELECT ws_item_sk, ws_sold_date_sk, ws_bill_customer_sk, ws_ext_sales_price, ws_list_price, 'web' FROM web_sales) sales INNER JOIN date_list_cte ON sales.sold_date_sk = date_list_cte.d_date_sk INNER JOIN item i ON sales.item_sk = i.i_item_sk INNER JOIN customer c ON sales.customer_sk = c.c_customer_sk WHERE sales.list_price BETWEEN 242 AND 271 AND i.i_manager_id BETWEEN 71 AND 100 AND c.c_birth_year BETWEEN 1945 AND 1951",
          "interfaces": {
            "outputs": ["i_item_id", "c_birth_year", "channel", "sales_price"],
            "consumes": ["date_list_cte"]
          }
        },
        "aggregated_sales_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i_item_id AS item_id, c_birth_year AS birth_year, channel, SUM(sales_price) AS channel_rev FROM unified_sales_cte GROUP BY i_item_id, c_birth_year, channel",
          "interfaces": {
            "outputs": ["item_id", "birth_year", "channel", "channel_rev"],
            "consumes": ["unified_sales_cte"]
          }
        },
        "pivoted_sales_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT item_id, birth_year, MAX(CASE WHEN channel = 'store' THEN channel_rev END) AS ss_item_rev, MAX(CASE WHEN channel = 'catalog' THEN channel_rev END) AS cs_item_rev, MAX(CASE WHEN channel = 'web' THEN channel_rev END) AS ws_item_rev FROM aggregated_sales_cte GROUP BY item_id, birth_year",
          "interfaces": {
            "outputs": ["item_id", "birth_year", "ss_item_rev", "cs_item_rev", "ws_item_rev"],
            "consumes": ["aggregated_sales_cte"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT item_id, birth_year, ss_item_rev, ss_item_rev / ((ss_item_rev + cs_item_rev + ws_item_rev) / 3) * 100 AS ss_dev, cs_item_rev, cs_item_rev / ((ss_item_rev + cs_item_rev + ws_item_rev) / 3) * 100 AS cs_dev, ws_item_rev, ws_item_rev / ((ss_item_rev + cs_item_rev + ws_item_rev) / 3) * 100 AS ws_dev, (ss_item_rev + cs_item_rev + ws_item_rev) / 3 AS average FROM pivoted_sales_cte WHERE ss_item_rev BETWEEN 0.9 * cs_item_rev AND 1.1 * cs_item_rev AND ss_item_rev BETWEEN 0.9 * ws_item_rev AND 1.1 * ws_item_rev AND cs_item_rev BETWEEN 0.9 * ss_item_rev AND 1.1 * ss_item_rev AND cs_item_rev BETWEEN 0.9 * ws_item_rev AND 1.1 * ws_item_rev AND ws_item_rev BETWEEN 0.9 * ss_item_rev AND 1.1 * ss_item_rev AND ws_item_rev BETWEEN 0.9 * cs_item_rev AND 1.1 * cs_item_rev ORDER BY item_id, birth_year, ss_item_rev LIMIT 100",
          "interfaces": {
            "outputs": ["item_id", "birth_year", "ss_item_rev", "ss_dev", "cs_item_rev", "cs_dev", "ws_item_rev", "ws_dev", "average"],
            "consumes": ["pivoted_sales_cte"]
          }
        }
      },
      "reconstruction_order": ["date_list_cte", "unified_sales_cte", "aggregated_sales_cte", "pivoted_sales_cte", "main_query"],
      "assembly_template": "WITH date_list_cte AS ({date_list_cte}), unified_sales_cte AS ({unified_sales_cte}), aggregated_sales_cte AS ({aggregated_sales_cte}), pivoted_sales_cte AS ({pivoted_sales_cte}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Consolidated three separate sales CTEs into a single unified sales CTE using UNION ALL with channel discriminator, then aggregated once with pivot via MAX(CASE). This eliminates repeated dimension table scans and comma-join cardinality estimation issues while preserving exact semantics.

**Expected speedup**: 1.5-2.0x due to eliminating redundant dimension table scans and improving join cardinality estimates. The main gains come from scanning each dimension table once instead of three times and better optimizer estimates from explicit JOIN syntax.