**Part 1: Modified Logic Tree**

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ~2.2M
    ├── WITH filtered_dates  [+]
    │   └── SCAN (date_dim)
    │       └── FILTER (d_year=1998 AND d_moy=2)
    ├── WITH filtered_customer_demographics  [+]
    │   └── SCAN (customer_demographics)
    │       └── FILTER (OR condition preserved)
    ├── WITH base_joins  [+]
    │   └── SCAN (catalog_returns)
    │       ├── JOIN (filtered_dates) explicit INNER
    │       ├── JOIN (call_center) explicit INNER
    │       ├── JOIN (customer) explicit INNER
    │       ├── JOIN (filtered_customer_demographics) explicit INNER
    │       ├── JOIN (household_demographics) explicit INNER with hd_buy_potential LIKE
    │       └── JOIN (customer_address) explicit INNER with ca_gmt_offset=-7
    └── final_aggregation  [!]
        ├── FROM (base_joins CTE)
        ├── GROUP BY (cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status)
        ├── AGG (SUM(cr_net_loss))
        └── SORT (SUM(cr_net_loss) DESC)
```

**Part 2: Component Payload JSON**

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_isolation", "description": "Isolate selective date_dim filter into CTE", "applied_to": ["filtered_dates"]},
    {"id": "R2", "type": "dimension_isolation", "description": "Isolate selective customer_demographics OR filter into CTE", "applied_to": ["filtered_customer_demographics"]},
    {"id": "R3", "type": "explicit_join_conversion", "description": "Convert comma joins to explicit INNER JOIN syntax with CTE references", "applied_to": ["base_joins"]},
    {"id": "R4", "type": "cte_assembly", "description": "Follow target logical tree structure with non-materialized CTEs", "applied_to": ["filtered_dates", "filtered_customer_demographics", "base_joins", "final_aggregation"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 2",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_customer_demographics": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cd_demo_sk, cd_marital_status, cd_education_status FROM customer_demographics WHERE ((cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree'))",
        "interfaces": {"outputs": ["cd_demo_sk", "cd_marital_status", "cd_education_status"], "consumes": []}
      },
      "base_joins": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cr.cr_net_loss, cc.cc_call_center_id, cc.cc_name, cc.cc_manager, cd.cd_marital_status, cd.cd_education_status FROM catalog_returns cr INNER JOIN filtered_dates fd ON cr.cr_returned_date_sk = fd.d_date_sk INNER JOIN call_center cc ON cr.cr_call_center_sk = cc.cc_call_center_sk INNER JOIN customer c ON cr.cr_returning_customer_sk = c.c_customer_sk INNER JOIN filtered_customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk INNER JOIN household_demographics hd ON hd.hd_demo_sk = c.c_current_hdemo_sk AND hd.hd_buy_potential LIKE '1001-5000%' INNER JOIN customer_address ca ON ca.ca_address_sk = c.c_current_addr_sk AND ca.ca_gmt_offset = -7",
        "interfaces": {"outputs": ["cr_net_loss", "cc_call_center_id", "cc_name", "cc_manager", "cd_marital_status", "cd_education_status"], "consumes": ["filtered_dates", "filtered_customer_demographics"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM base_joins GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC",
        "interfaces": {"outputs": ["Call_Center", "Call_Center_Name", "Manager", "Returns_Loss"], "consumes": ["base_joins"]}
      }
    },
    "reconstruction_order": ["filtered_dates", "filtered_customer_demographics", "base_joins", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), filtered_customer_demographics AS ({filtered_customer_demographics}), base_joins AS ({base_joins}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Isolated selective date and customer demographic filters into CTEs and converted comma-separated joins to explicit INNER JOIN syntax. This creates small hash tables for dimensions before joining to the large fact table (catalog_returns).

**Expected speedup**: 2-3x based on similar patterns in the examples. The combination of dimension prefetching (28 rows from date_dim, small set from customer_demographics) with explicit joins allows PostgreSQL to build efficient hash joins with the fact table as the probe side.