### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Rewritten to use CTE structure
    ├── [CTE] prefiltered_fact_with_early_joins  [+]
    │   ├── SCAN catalog_returns
    │   ├── JOIN date_dim ON cr_returned_date_sk = d_date_sk AND d_year=1998 AND d_moy=2
    │   ├── JOIN call_center ON cr_call_center_sk = cc_call_center_sk
    │   ├── JOIN customer ON cr_returning_customer_sk = c_customer_sk
    │   ├── JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk AND ((cd_marital_status='M' AND cd_education_status='Unknown') OR (cd_marital_status='W' AND cd_education_status='Advanced Degree'))
    │   ├── JOIN household_demographics ON hd_demo_sk = c_current_hdemo_sk AND hd_buy_potential LIKE '1001-5000%'
    │   └── JOIN customer_address ON ca_address_sk = c_current_addr_sk AND ca_gmt_offset=-7
    ├── [MAIN] final_aggregation  [+]
    │   ├── FROM prefiltered_fact_with_early_joins
    │   ├── GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status
    │   ├── AGGREGATE SUM(cr_net_loss) as Returns_Loss
    │   ├── ORDER BY Returns_Loss DESC
    │   └── OUTPUT Call_Center, Call_Center_Name, Manager, Returns_Loss
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter_decorrelate", "description": "Pushed all dimension filters into JOIN conditions for early reduction", "applied_to": ["prefiltered_fact_with_early_joins"]},
    {"id": "R2", "type": "cte_structure", "description": "Restructured to match target logical tree with two CTEs", "applied_to": ["main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "prefiltered_fact_with_early_joins": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cr_net_loss, cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status FROM catalog_returns INNER JOIN date_dim ON cr_returned_date_sk = d_date_sk AND d_year = 1998 AND d_moy = 2 INNER JOIN call_center ON cr_call_center_sk = cc_call_center_sk INNER JOIN customer ON cr_returning_customer_sk = c_customer_sk INNER JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk AND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) INNER JOIN household_demographics ON hd_demo_sk = c_current_hdemo_sk AND hd_buy_potential LIKE '1001-5000%' INNER JOIN customer_address ON ca_address_sk = c_current_addr_sk AND ca_gmt_offset = -7",
        "interfaces": {"outputs": ["cr_net_loss", "cc_call_center_id", "cc_name", "cc_manager", "cd_marital_status", "cd_education_status"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM prefiltered_fact_with_early_joins GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC",
        "interfaces": {"outputs": ["Call_Center", "Call_Center_Name", "Manager", "Returns_Loss"], "consumes": ["prefiltered_fact_with_early_joins"]}
      }
    },
    "reconstruction_order": ["prefiltered_fact_with_early_joins", "main_query"],
    "assembly_template": "WITH prefiltered_fact_with_early_joins AS ({prefiltered_fact_with_early_joins}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Restructured the original comma-join query into an explicit CTE structure that pushes all dimension filters into JOIN conditions for early row reduction, exactly matching the target logical tree. The OR condition remains intact as a single filter to preserve PostgreSQL's bitmap OR optimization.

**Expected speedup**: 1.1–1.3x due to explicit join ordering allowing better cardinality estimation while maintaining the same semantic guarantees.