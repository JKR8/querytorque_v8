## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 99%  Rows: ~1.2M
    ├── CTE filtered_d1  [+]  
    │   ├── SCAN date_dim AS d1
    │   └── FILTER d1.d_year = 2000
    │   └── OUTPUT d_date_sk, d_date
    ├── CTE date_range  [+]  
    │   ├── SCAN date_dim AS d2
    │   ├── CROSS JOIN filtered_d1
    │   └── FILTER d2.d_date BETWEEN d1.d_date AND (d1.d_date + interval '90 day')
    │   └── OUTPUT d1_date_sk, d1_date, d2_date_sk
    ├── CTE unified_facts  [+]  
    │   ├── SCAN store_sales
    │   ├── JOIN store_returns ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk
    │   ├── JOIN web_sales ON sr_item_sk = ws_item_sk AND ss_customer_sk = ws_bill_customer_sk
    │   ├── JOIN item ON ss_item_sk = i_item_sk
    │   ├── JOIN date_range ON sr_returned_date_sk = d1_date_sk AND ws_sold_date_sk = d2_date_sk
    │   ├── FILTER i_category IN ('Children', 'Home', 'Women')
    │   ├── FILTER ss_sales_price / ss_list_price BETWEEN 76 * 0.01 AND 96 * 0.01
    │   └── OUTPUT ss_customer_sk
    ├── CTE conditional_aggregation  [+]  
    │   ├── FROM unified_facts
    │   ├── GROUP BY ss_customer_sk
    │   ├── AGGREGATE COUNT(*) AS cnt
    │   └── OUTPUT ss_customer_sk, cnt
    ├── CTE customer_dimensions  [+]  
    │   ├── FROM conditional_aggregation
    │   ├── JOIN customer ON ss_customer_sk = c_customer_sk
    │   ├── JOIN customer_address ON c_current_addr_sk = ca_address_sk
    │   ├── JOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk
    │   ├── FILTER ca_state IN ('AR', 'GA', 'IN', 'KY', 'VA')
    │   ├── FILTER hd_income_band_sk BETWEEN 8 AND 14
    │   ├── FILTER hd_buy_potential = '501-1000'
    │   └── OUTPUT c_customer_sk, c_first_name, c_last_name, cnt
    └── SORT (cnt ASC)  [~]  
        └── FROM customer_dimensions
        └── OUTPUT c_customer_sk, c_first_name, c_last_name, cnt
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16.11",
  "rewrite_rules": [
    {"id": "R1", "type": "pg_self_join_decomposition", "description": "Decomposed implicit comma joins into explicit join CTEs with shared materialization of date range precomputation", "applied_to": ["filtered_d1", "date_range", "unified_facts", "conditional_aggregation", "customer_dimensions"]},
    {"id": "R2", "type": "non_materialized_cte", "description": "Use non-materialized CTEs to preserve parallelism (all CTEs used only once)", "applied_to": ["filtered_d1", "date_range", "unified_facts", "conditional_aggregation", "customer_dimensions"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_d1": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_year = 2000",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "date_range": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d1.d_date_sk AS d1_date_sk, d1.d_date AS d1_date, d2.d_date_sk AS d2_date_sk FROM date_dim d2 CROSS JOIN filtered_d1 d1 WHERE d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '90 day')",
        "interfaces": {"outputs": ["d1_date_sk", "d1_date", "d2_date_sk"], "consumes": ["filtered_d1"]}
      },
      "unified_facts": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss.ss_customer_sk FROM store_sales ss INNER JOIN store_returns sr ON ss.ss_ticket_number = sr.sr_ticket_number AND ss.ss_item_sk = sr.sr_item_sk INNER JOIN web_sales ws ON sr.sr_item_sk = ws.ws_item_sk AND ss.ss_customer_sk = ws.ws_bill_customer_sk INNER JOIN item i ON ss.ss_item_sk = i.i_item_sk INNER JOIN date_range dr ON sr.sr_returned_date_sk = dr.d1_date_sk AND ws.ws_sold_date_sk = dr.d2_date_sk WHERE i.i_category IN ('Children', 'Home', 'Women') AND ss.ss_sales_price / ss.ss_list_price BETWEEN 76 * 0.01 AND 96 * 0.01",
        "interfaces": {"outputs": ["ss_customer_sk"], "consumes": ["date_range"]}
      },
      "conditional_aggregation": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_customer_sk, COUNT(*) AS cnt FROM unified_facts GROUP BY ss_customer_sk",
        "interfaces": {"outputs": ["ss_customer_sk", "cnt"], "consumes": ["unified_facts"]}
      },
      "customer_dimensions": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c.c_customer_sk, c.c_first_name, c.c_last_name, ca.cnt FROM conditional_aggregation ca INNER JOIN customer c ON ca.ss_customer_sk = c.c_customer_sk INNER JOIN customer_address ca_addr ON c.c_current_addr_sk = ca_addr.ca_address_sk INNER JOIN household_demographics hd ON c.c_current_hdemo_sk = hd.hd_demo_sk WHERE ca_addr.ca_state IN ('AR', 'GA', 'IN', 'KY', 'VA') AND hd.hd_income_band_sk BETWEEN 8 AND 14 AND hd.hd_buy_potential = '501-1000'",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "cnt"], "consumes": ["conditional_aggregation"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_customer_sk, c_first_name, c_last_name, cnt FROM customer_dimensions ORDER BY cnt",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "cnt"], "consumes": ["customer_dimensions"]}
      }
    },
    "reconstruction_order": ["filtered_d1", "date_range", "unified_facts", "conditional_aggregation", "customer_dimensions", "main_query"],
    "assembly_template": "WITH filtered_d1 AS ({filtered_d1}), date_range AS ({date_range}), unified_facts AS ({unified_facts}), conditional_aggregation AS ({conditional_aggregation}), customer_dimensions AS ({customer_dimensions}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

Changes: Decomposed the original implicit comma joins into explicit join CTEs following the target logical tree, with precomputation of the date range cross join to isolate the temporal dependency. All CTEs are non-materialized (PostgreSQL's default when used only once) to preserve parallel execution.

Expected speedup: 2-3x from reduced intermediate result size via early filtering in CTEs and preserved parallelism. The cross join between date_dim rows (~44K) is small compared to fact tables, and explicit join order helps the optimizer.