## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]
    ├── [WITH] filtered_d1  [+]
    ├── [WITH] filtered_d2  [+]
    ├── [WITH] filtered_item  [+]
    ├── [WITH] fact_core  [+]
    │   ├── SCAN store_sales
    │   ├── JOIN store_returns (INNER) ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk
    │   ├── JOIN filtered_item (INNER) ON ss_item_sk = i_item_sk
    │   ├── JOIN filtered_d1 (INNER) ON sr_returned_date_sk = d1.d_date_sk
    │   ├── JOIN web_sales (INNER) ON sr_item_sk = ws_item_sk AND ss_customer_sk = ws_bill_customer_sk
    │   ├── JOIN filtered_d2 (INNER) ON ws_sold_date_sk = d2.d_date_sk
    │   └── FILTER ss_sales_price / ss_list_price BETWEEN 0.76 AND 0.96
    ├── [WITH] aggregation  [+]
    │   ├── FROM fact_core
    │   ├── GROUP BY ss_customer_sk
    │   └── AGG COUNT(*) AS cnt
    ├── [WITH] customer_decorate  [+]
    │   ├── FROM aggregation
    │   ├── JOIN customer (INNER) ON ss_customer_sk = c_customer_sk
    │   ├── JOIN customer_address (INNER) ON c_current_addr_sk = ca_address_sk
    │   ├── JOIN household_demographics (INNER) ON c_current_hdemo_sk = hd_demo_sk
    │   ├── FILTER ca_state IN ('AR','GA','IN','KY','VA')
    │   ├── FILTER hd_income_band_sk BETWEEN 8 AND 14
    │   └── FILTER hd_buy_potential = '501-1000'
    ├── SELECT FROM customer_decorate
    ├── SORT cnt ASC
    └── OUTPUT c_customer_sk, c_first_name, c_last_name, cnt
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefilter_cte", "description": "Pre-filter date_dim, item into CTEs before fact joins", "applied_to": ["filtered_d1", "filtered_d2", "filtered_item"]},
    {"id": "R2", "type": "fact_core_cte", "description": "Isolate fact joins and filters into CTE before aggregation", "applied_to": ["fact_core"]},
    {"id": "R3", "type": "late_dimension_decorate", "description": "Move customer, address, household demographics to after aggregation", "applied_to": ["customer_decorate"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_d1": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_year = 2000",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "filtered_d2": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim d2 WHERE EXISTS (SELECT 1 FROM filtered_d1 d1 WHERE d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '90 DAY'))",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": ["filtered_d1"]}
      },
      "filtered_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Children', 'Home', 'Women')",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "fact_core": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_customer_sk FROM store_sales INNER JOIN store_returns ON store_sales.ss_ticket_number = store_returns.sr_ticket_number AND store_sales.ss_item_sk = store_returns.sr_item_sk INNER JOIN filtered_item ON store_sales.ss_item_sk = filtered_item.i_item_sk INNER JOIN filtered_d1 ON store_returns.sr_returned_date_sk = filtered_d1.d_date_sk INNER JOIN web_sales ON store_returns.sr_item_sk = web_sales.ws_item_sk AND store_sales.ss_customer_sk = web_sales.ws_bill_customer_sk INNER JOIN filtered_d2 ON web_sales.ws_sold_date_sk = filtered_d2.d_date_sk WHERE store_sales.ss_sales_price / store_sales.ss_list_price BETWEEN 76 * 0.01 AND 96 * 0.01",
        "interfaces": {"outputs": ["ss_customer_sk"], "consumes": ["filtered_item", "filtered_d1", "filtered_d2"]}
      },
      "aggregation": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_customer_sk, COUNT(*) AS cnt FROM fact_core GROUP BY ss_customer_sk",
        "interfaces": {"outputs": ["ss_customer_sk", "cnt"], "consumes": ["fact_core"]}
      },
      "customer_decorate": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c_customer_sk, c_first_name, c_last_name, aggregation.cnt FROM aggregation INNER JOIN customer ON aggregation.ss_customer_sk = customer.c_customer_sk INNER JOIN customer_address ON customer.c_current_addr_sk = customer_address.ca_address_sk INNER JOIN household_demographics ON customer.c_current_hdemo_sk = household_demographics.hd_demo_sk WHERE customer_address.ca_state IN ('AR', 'GA', 'IN', 'KY', 'VA') AND household_demographics.hd_income_band_sk BETWEEN 8 AND 14 AND household_demographics.hd_buy_potential = '501-1000'",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "cnt"], "consumes": ["aggregation"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_customer_sk, c_first_name, c_last_name, cnt FROM customer_decorate ORDER BY cnt",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "cnt"], "consumes": ["customer_decorate"]}
      }
    },
    "reconstruction_order": ["filtered_d1", "filtered_d2", "filtered_item", "fact_core", "aggregation", "customer_decorate", "main_query"],
    "assembly_template": "WITH filtered_d1 AS ({filtered_d1}), filtered_d2 AS ({filtered_d2}), filtered_item AS ({filtered_item}), fact_core AS ({fact_core}), aggregation AS ({aggregation}), customer_decorate AS ({customer_decorate}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Restructured original comma-joins into explicit INNER JOINs with CTE-based dimension prefiltering (date_dim, item) and late decoration of customer/address/demographics after aggregation.

**Expected speedup:** ~3x (dimension prefiltering reduces fact join cardinality, late decoration avoids bloating aggregation with wide dimension columns, explicit joins improve optimizer estimates).