## Modified Logic Tree

[=] Original semantic contract (unchanged)
  [+] WITH filtered_sales AS MATERIALIZED (
      SELECT ss_ticket_number, ss_item_sk, ss_customer_sk
      FROM store_sales
      INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk
      WHERE d_year BETWEEN 1998 AND 1998 + 1
        AND ss_list_price BETWEEN 108 AND 122
    )
      [+] Pre-filter store_sales once with date and list_price conditions
      [+] Materialized to prevent duplicate scanning
  
  [+] WITH filtered_items1 AS (
      SELECT i_item_sk
      FROM item
      WHERE i_category IN ('Electronics', 'Jewelry')
    )
      [+] Pre-filter item1 dimension for category condition
  
  [+] WITH filtered_items2 AS (
      SELECT i_item_sk
      FROM item
      WHERE i_manager_id BETWEEN 81 AND 100
    )
      [+] Pre-filter item2 dimension for manager_id condition
  
  [+] WITH filtered_customers AS (
      SELECT c_customer_sk, c_current_cdemo_sk, c_current_addr_sk
      FROM customer
      INNER JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk
      WHERE cd_marital_status = 'S'
        AND cd_education_status = 'College'
    )
      [+] Pre-join customer with demographics filter
      [+] Creates small hash table for fast probing
  
  [+] WITH ticket_items AS (
      SELECT 
        fs.ss_ticket_number,
        fs.ss_customer_sk,
        ARRAY_AGG(fs.ss_item_sk ORDER BY fs.ss_item_sk) AS item_list
      FROM filtered_sales fs
      GROUP BY fs.ss_ticket_number, fs.ss_customer_sk
      HAVING COUNT(*) >= 2  -- At least 2 items to form a pair
    )
      [+] Single scan to group items by ticket
      [+] Materializes item arrays for pair generation
  
  [~] main_query: Generate pairs from arrays, join to dimensions, aggregate
      [+] Unnest arrays with ordinal positions to generate item pairs
      [+] Join to filtered dimensions using pre-computed keys
      [+] Apply item1.i_item_sk < item2.i_item_sk condition
      [+] Group and count pairs

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "materialized_fact_prefilter",
      "description": "Materialize filtered store_sales with date and price conditions once to prevent duplicate scanning",
      "applied_to": ["filtered_sales"]
    },
    {
      "id": "R2", 
      "type": "dimension_prefetch",
      "description": "Pre-filter all dimension tables into CTEs to create tiny hash tables",
      "applied_to": ["filtered_items1", "filtered_items2", "filtered_customers"]
    },
    {
      "id": "R3",
      "type": "array_aggregation_self_join",
      "description": "Group items by ticket using ARRAY_AGG, then unnest to generate pairs without expensive self-join",
      "applied_to": ["ticket_items", "main_query"]
    },
    {
      "id": "R4",
      "type": "explicit_join_syntax",
      "description": "Convert comma joins to explicit JOIN ON syntax for better optimizer cost modeling",
      "applied_to": ["main_query"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_sales": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_ticket_number, ss_item_sk, ss_customer_sk FROM store_sales INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk WHERE d_year BETWEEN 1998 AND 1998 + 1 AND ss_list_price BETWEEN 108 AND 122",
        "interfaces": {
          "outputs": ["ss_ticket_number", "ss_item_sk", "ss_customer_sk"],
          "consumes": []
        }
      },
      "filtered_items1": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Electronics', 'Jewelry')",
        "interfaces": {
          "outputs": ["i_item_sk"],
          "consumes": []
        }
      },
      "filtered_items2": {
        "type": "cte", 
        "change": "added",
        "sql": "SELECT i_item_sk FROM item WHERE i_manager_id BETWEEN 81 AND 100",
        "interfaces": {
          "outputs": ["i_item_sk"],
          "consumes": []
        }
      },
      "filtered_customers": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_customer_sk, c_current_cdemo_sk, c_current_addr_sk FROM customer INNER JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk WHERE cd_marital_status = 'S' AND cd_education_status = 'College'",
        "interfaces": {
          "outputs": ["c_customer_sk", "c_current_cdemo_sk", "c_current_addr_sk"],
          "consumes": []
        }
      },
      "ticket_items": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT fs.ss_ticket_number, fs.ss_customer_sk, ARRAY_AGG(fs.ss_item_sk ORDER BY fs.ss_item_sk) AS item_list FROM filtered_sales fs GROUP BY fs.ss_ticket_number, fs.ss_customer_sk HAVING COUNT(*) >= 2",
        "interfaces": {
          "outputs": ["ss_ticket_number", "ss_customer_sk", "item_list"],
          "consumes": ["filtered_sales"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i1.i_item_sk AS i_item_sk, i2.i_item_sk AS i_item_sk, COUNT(*) AS cnt FROM ticket_items ti CROSS JOIN LATERAL (SELECT item1, item2, idx1, idx2 FROM unnest(ti.item_list) WITH ORDINALITY AS items1(item1, idx1) CROSS JOIN unnest(ti.item_list) WITH ORDINALITY AS items2(item2, idx2) WHERE idx1 < idx2 AND item1 < item2) pairs INNER JOIN filtered_items1 i1 ON pairs.item1 = i1.i_item_sk INNER JOIN filtered_items2 i2 ON pairs.item2 = i2.i_item_sk INNER JOIN filtered_customers c ON ti.ss_customer_sk = c.c_customer_sk INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk GROUP BY i1.i_item_sk, i2.i_item_sk ORDER BY cnt",
        "interfaces": {
          "outputs": ["i_item_sk", "i_item_sk", "cnt"],
          "consumes": ["ticket_items", "filtered_items1", "filtered_items2", "filtered_customers"]
        }
      }
    },
    "reconstruction_order": ["filtered_sales", "filtered_items1", "filtered_items2", "filtered_customers", "ticket_items", "main_query"],
    "assembly_template": "WITH filtered_sales AS ({filtered_sales}), filtered_items1 AS ({filtered_items1}), filtered_items2 AS ({filtered_items2}), filtered_customers AS ({filtered_customers}), ticket_items AS ({ticket_items}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '512MB'",
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL enable_mergejoin = off", 
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL max_parallel_workers_per_gather = 4",
    "SET LOCAL parallel_tuple_cost = 0.001",
    "SET LOCAL parallel_setup_cost = 1000.0"
  ],
  "validation_checks": []
}
```

**Changes**: Replaced expensive self-join on store_sales with a single scan + array aggregation, pre-filtered all dimensions into CTEs for tiny hash tables, converted to explicit JOIN syntax. The array-based pair generation eliminates the O(NÂ²) self-join by generating pairs only within each ticket's item list.

**Expected speedup**: 2.5-3.0x. The rewrite eliminates duplicate fact table scanning, reduces nested loop joins, and enables parallel array processing. The materialized CTEs create small dimension hash tables for fast probing, while the array aggregation collapses the expensive self-join into a single scan with O(N log N) sorting.