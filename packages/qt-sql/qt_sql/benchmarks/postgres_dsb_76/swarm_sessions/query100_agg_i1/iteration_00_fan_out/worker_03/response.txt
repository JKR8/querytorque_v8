## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ~192
    ├── CTE date_filtered [=]
    ├── CTE fact_filtered [=]
    ├── CTE item1_filtered [=]
    ├── CTE item2_filtered [=]
    ├── CTE custdemo_filtered [=]
    ├── CTE customer_filtered [=]
    ├── CTE joined_fact [~] (changed: fixed dual item filter logic)
    ├── CTE pair_join [=]
    └── CTE final_aggregate [=]
```

Change markers:
- `[=]` — Unchanged CTE definitions from target logical tree
- `[~]` — Modified joined_fact: fixed logic to avoid requiring same item to satisfy both item1 and item2 filters simultaneously
- `[!]` — Structural change: Replaced original comma joins with explicit CTE-based staged reduction

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "staged_reduction", "description": "Replaced implicit comma joins with explicit CTE-based staged reduction for non-equi join", "applied_to": ["joined_fact", "pair_join"]},
    {"id": "R2", "type": "materialized_cte", "description": "Used non-materialized CTEs to preserve parallel scan capability", "applied_to": ["fact_filtered", "item1_filtered", "item2_filtered"]},
    {"id": "R3", "type": "predicate_preservation", "description": "Preserved all original literals and defensive CASE WHEN guards", "applied_to": ["all"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filtered": {
        "type": "cte",
        "change": "unchanged",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year BETWEEN 1998 AND 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "fact_filtered": {
        "type": "cte",
        "change": "unchanged",
        "sql": "SELECT ss_ticket_number, ss_item_sk, ss_customer_sk FROM store_sales JOIN date_filtered ON ss_sold_date_sk = d_date_sk WHERE ss_list_price BETWEEN 108 AND 122",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_item_sk", "ss_customer_sk"], "consumes": ["date_filtered"]}
      },
      "item1_filtered": {
        "type": "cte",
        "change": "unchanged",
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Electronics', 'Jewelry')",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "item2_filtered": {
        "type": "cte",
        "change": "unchanged",
        "sql": "SELECT i_item_sk FROM item WHERE i_manager_id BETWEEN 81 AND 100",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "custdemo_filtered": {
        "type": "cte",
        "change": "unchanged",
        "sql": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'S' AND cd_education_status = 'College'",
        "interfaces": {"outputs": ["cd_demo_sk"], "consumes": []}
      },
      "customer_filtered": {
        "type": "cte",
        "change": "unchanged",
        "sql": "SELECT c_customer_sk, c_current_addr_sk FROM customer JOIN custdemo_filtered ON c_current_cdemo_sk = cd_demo_sk",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": ["custdemo_filtered"]}
      },
      "joined_fact": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT f.ss_ticket_number, i1.i_item_sk AS item1_sk, c.c_current_addr_sk FROM fact_filtered f JOIN item1_filtered i1 ON f.ss_item_sk = i1.i_item_sk JOIN customer_filtered c ON f.ss_customer_sk = c.c_customer_sk",
        "interfaces": {"outputs": ["ss_ticket_number", "item1_sk", "c_current_addr_sk"], "consumes": ["fact_filtered", "item1_filtered", "customer_filtered"]}
      },
      "joined_fact2": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT f.ss_ticket_number, i2.i_item_sk AS item2_sk FROM fact_filtered f JOIN item2_filtered i2 ON f.ss_item_sk = i2.i_item_sk JOIN customer_filtered c ON f.ss_customer_sk = c.c_customer_sk",
        "interfaces": {"outputs": ["ss_ticket_number", "item2_sk"], "consumes": ["fact_filtered", "item2_filtered", "customer_filtered"]}
      },
      "pair_join": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT j1.item1_sk, j2.item2_sk, j1.c_current_addr_sk FROM joined_fact j1 JOIN joined_fact2 j2 ON j1.ss_ticket_number = j2.ss_ticket_number AND j1.item1_sk < j2.item2_sk",
        "interfaces": {"outputs": ["item1_sk", "item2_sk", "c_current_addr_sk"], "consumes": ["joined_fact", "joined_fact2"]}
      },
      "final_aggregate": {
        "type": "cte",
        "change": "unchanged",
        "sql": "SELECT item1_sk, item2_sk, COUNT(*) AS cnt FROM pair_join JOIN customer_address ON ca_address_sk = c_current_addr_sk GROUP BY item1_sk, item2_sk",
        "interfaces": {"outputs": ["item1_sk", "item2_sk", "cnt"], "consumes": ["pair_join"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT item1_sk, item2_sk, cnt FROM final_aggregate ORDER BY cnt",
        "interfaces": {"outputs": ["item1_sk", "item2_sk", "cnt"], "consumes": ["final_aggregate"]}
      }
    },
    "reconstruction_order": ["date_filtered", "fact_filtered", "item1_filtered", "item2_filtered", "custdemo_filtered", "customer_filtered", "joined_fact", "joined_fact2", "pair_join", "final_aggregate", "main_query"],
    "assembly_template": "WITH date_filtered AS ({date_filtered}), fact_filtered AS ({fact_filtered}), item1_filtered AS ({item1_filtered}), item2_filtered AS ({item2_filtered}), custdemo_filtered AS ({custdemo_filtered}), customer_filtered AS ({customer_filtered}), joined_fact AS ({joined_fact}), joined_fact2 AS ({joined_fact2}), pair_join AS ({pair_join}), final_aggregate AS ({final_aggregate}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Fixed the logical flaw in joined_fact that required the same item to satisfy both item1 and item2 filters simultaneously, which would eliminate valid pairs. Split into two separate CTEs (joined_fact and joined_fact2) that apply item1 and item2 filters separately, then join on ticket number with item1_sk < item2_sk condition.

**Expected speedup:** 2-3x from staged reduction and avoiding the cross-CTE predicate blindness issue. The separate CTEs for item1 and item2 filters allow parallel scanning of store_sales while dramatically reducing the search space before the non-equi join.