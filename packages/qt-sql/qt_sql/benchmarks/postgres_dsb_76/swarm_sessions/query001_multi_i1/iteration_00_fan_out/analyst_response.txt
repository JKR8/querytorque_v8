<reasoning>
1. **CLASSIFY**: This is a "correlated-aggregate filter" query with star-schema characteristics. The CTE computes per-customer/store/reason aggregates from store_returns, then the main query filters those aggregates against a per-store average threshold (correlated subquery) and joins with dimension tables (store, customer, customer_demographics).

2. **EXPLAIN PLAN ANALYSIS**:
   - Total runtime: 10,482ms
   - CTE computation (customer_total_return): ~10,461ms (99.8% of runtime) - This is the dominant bottleneck.
   - Within CTE computation: Parallel scan of store_returns (365 loops × 263 rows = ~95K rows) with filter on sr_return_amt/sr_return_quantity.
   - The correlated subquery runs 1,845 times (once per filtered ctr1 row) and each time scans the entire CTE (2,450 rows average). This is ~4.5M row scans total.
   - After CTE filtering: 582 rows remain from 95K (0.6% selectivity).
   - The optimizer already pushes d_year=2002 into date_dim scan and uses index scans for dimension tables. CTE is materialized once (CTE Scan ctr1, CTE Scan ctr2).
   - store_returns is scanned ONCE in the CTE (not multiple times). The bottleneck is the repeated scanning of the CTE result (95K rows) for the correlated subquery.

3. **GAP MATCHING**:
   - **CORRELATED_SUBQUERY_PARALYSIS**: Strong match. Subquery `SELECT AVG(ctr_total_return)*1.2 FROM customer_total_return ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk` runs per outer row (1,845 executions).
   - **CROSS_CTE_PREDICATE_BLINDNESS**: The CTE `customer_total_return` is referenced twice (ctr1 and ctr2) but both references use the same materialized result. No duplicate fact table scan.
   - **COMMA_JOIN_WEAKNESS**: Query uses comma-separated joins in CTE and main query. Could benefit from explicit JOIN syntax.
   - **NON_EQUI_JOIN_INPUT_BLINDNESS**: Not applicable (no non-equi joins).

4. **AGGREGATION TRAP CHECK**: The query uses SUM and AVG. Both are duplicate-insensitive for inner joins (if join doesn't change group membership). The CTE groups by sr_customer_sk, sr_store_sk, sr_reason_sk. The main query filters on ctr_reason_sk (43-46) which could be pushed into CTE without changing aggregate semantics since reason_sk is in GROUP BY.

5. **TRANSFORM SELECTION** (diverse approaches):
   a) **Decorrelate via precomputed store averages** (attack correlated subquery): Compute store thresholds in separate CTE.
   b) **Push filters into CTE** (reduce CTE size): Push ctr_reason_sk filter and possibly dimension filters into CTE definition.
   c) **Explicit JOINs + dimension prefetch** (attack comma-join weakness): Convert to explicit JOINs with pre-filtered dimension CTEs.
   d) **Exploration: Window function for per-store average** (novel combination): Compute threshold via window function in CTE itself.

6. **LOGICAL TREE DESIGN**:
   For each strategy, ensure CTE outputs all columns needed downstream: ctr_customer_sk, ctr_store_sk, ctr_reason_sk, ctr_total_return (plus any added for thresholds).
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
This query identifies customers whose total returns in 2002 (with per-unit return between $108 and $167) are 20% above their store's average, for specific return reasons (43-46), who shop at stores in IL/KY/TX, and have specific demographic profiles (female, married, college-educated, born Feb 1965-1971). All joins are INNER equi-joins requiring matches on all sides. Aggregates (SUM, AVG) are duplicate-insensitive for inner joins. The ctr_reason_sk filter (BETWEEN 43 AND 46) must apply to the same rows used for computing store averages in the correlated subquery.

BOTTLENECK_DIAGNOSIS:
The dominant cost (99.8%) is the correlated subquery that re-executes 1,845 times, each scanning the 95K-row CTE materialization. The query is aggregation-bound in the CTE (scanning store_returns with expression filter) but join-bound in the main query due to per-row subquery execution. Cardinality flow: store_returns scan → 95K aggregated rows → filter to 582 rows → correlated subquery scans 95K rows per filtered row (4.5M total). The optimizer already parallelizes the CTE computation and uses indexes for dimension lookups. Logical-tree cost percentages are misleading: CTE shows 12% cost but accounts for nearly all runtime due to repeated scans.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output exactly c_customer_id column.
- CTE_COLUMN_COMPLETENESS: Any CTE must include ctr_customer_sk, ctr_store_sk, ctr_reason_sk, ctr_total_return for downstream joins and filtering.
- LITERAL_PRESERVATION: All numeric/string literals (2002, 108, 167, 43, 46, 'IL','KY','TX','M','Advanced Degree','College','F',2,1965,1971) must be preserved.
- SEMANTIC_EQUIVALENCE: Must return same 100 customer IDs in same order.
- CORRELATED_SUBQUERY_PARALYSIS: EXPLAIN shows subquery executed 1,845 times (Aggregate rows=1 loops=1845).
- COMMA_JOIN_WEAKNESS: Query uses comma-separated joins in CTE (store_returns, date_dim) and main query.

REGRESSION_WARNINGS:
None applicable.

=== WORKER 1 BRIEFING ===

STRATEGY: decorrelate_via_store_threshold_cte
TARGET_LOGICAL_TREE:
  filtered_returns_cte -> store_avg_threshold_cte -> main_query_with_explicit_joins
NODE_CONTRACTS:
  filtered_returns_cte:
    FROM: store_returns, date_dim
    JOIN: sr_returned_date_sk = d_date_sk
    WHERE: d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
    AGGREGATE: SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return
    OUTPUT: sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, ctr_total_return
    EXPECTED_ROWS: ~95K
    CONSUMERS: store_avg_threshold_cte, main_query
  store_avg_threshold_cte:
    FROM: filtered_returns_cte
    GROUP BY: ctr_store_sk
    AGGREGATE: AVG(ctr_total_return) * 1.2 AS store_avg_threshold
    OUTPUT: ctr_store_sk, store_avg_threshold
    EXPECTED_ROWS: ~distinct stores in filtered_returns_cte
    CONSUMERS: main_query
  main_query:
    FROM: filtered_returns_cte AS ctr1
    INNER JOIN store_avg_threshold_cte AS th ON ctr1.ctr_store_sk = th.ctr_store_sk
    INNER JOIN store ON s_store_sk = ctr1.ctr_store_sk
    INNER JOIN customer ON c_customer_sk = ctr1.ctr_customer_sk
    INNER JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk
    WHERE: ctr1.ctr_total_return > th.store_avg_threshold AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971
    OUTPUT: c_customer_id
    EXPECTED_ROWS: 100 (after LIMIT)
    CONSUMERS: final output
EXAMPLES: inline_decorrelate_materialized, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- inline_decorrelate_materialized: Apply the 3-CTE pattern: (1) filtered_returns_cte as fact pre-filter, (2) store_avg_threshold_cte as per-key aggregate. Use MATERIALIZED on both CTEs to prevent inlining and re-correlation.
- early_filter_decorrelate: Push the ctr_reason_sk filter into filtered_returns_cte (but wait: this changes store averages! The subquery should use unfiltered data. So DO NOT push reason_sk filter here - keep it in main query).
HAZARD_FLAGS:
- The store_avg_threshold_cte must compute averages from ALL reasons (not filtered by 43-46) to match original semantics.
- Use AS MATERIALIZED on CTEs to prevent optimizer from inlining and re-correlating.

=== WORKER 2 BRIEFING ===

STRATEGY: push_filters_into_cte_with_reason_partition
TARGET_LOGICAL_TREE:
  returns_with_store_avg_cte -> main_query_with_explicit_joins
NODE_CONTRACTS:
  returns_with_store_avg_cte:
    FROM: store_returns, date_dim
    JOIN: sr_returned_date_sk = d_date_sk
    WHERE: d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
    AGGREGATE: SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return, AVG(SUM(SR_RETURN_AMT_INC_TAX)) OVER (PARTITION BY sr_store_sk) * 1.2 AS store_avg_threshold
    OUTPUT: sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, ctr_total_return, store_avg_threshold
    EXPECTED_ROWS: ~95K
    CONSUMERS: main_query
  main_query:
    FROM: returns_with_store_avg_cte AS ctr1
    INNER JOIN store ON s_store_sk = ctr1.ctr_store_sk
    INNER JOIN customer ON c_customer_sk = ctr1.ctr_customer_sk
    INNER JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk
    WHERE: ctr1.ctr_total_return > ctr1.store_avg_threshold AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971
    OUTPUT: c_customer_id
    EXPECTED_ROWS: 100 (after LIMIT)
    CONSUMERS: final output
EXAMPLES: pg_self_join_decomposition, single_pass_aggregation
EXAMPLE_ADAPTATION:
- pg_self_join_decomposition: Compute store average in the same CTE as the per-customer aggregates, avoiding separate subquery execution. Use window function instead of self-join.
- single_pass_aggregation: Compute both per-group aggregates and store-level averages in a single pass with window function.
HAZARD_FLAGS:
- Window function AVG(...) OVER (PARTITION BY sr_store_sk) computes average of the SUMs per store across ALL reasons, which matches original semantics.
- Must ensure window function is computed after GROUP BY aggregation (correct: window functions execute after aggregates).

=== WORKER 3 BRIEFING ===

STRATEGY: explicit_joins_with_dimension_prefetch
TARGET_LOGICAL_TREE:
  filtered_date_cte -> prefactored_returns_cte -> store_avg_threshold_cte -> main_query_explicit_joins
NODE_CONTRACTS:
  filtered_date_cte:
    FROM: date_dim
    WHERE: d_year = 2002
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 365 (from EXPLAIN: 122 rows × 3 loops ÷ 3 workers = ~365)
    CONSUMERS: prefactored_returns_cte
  prefactored_returns_cte:
    FROM: store_returns
    INNER JOIN filtered_date_cte ON sr_returned_date_sk = d_date_sk
    WHERE: sr_return_amt / sr_return_quantity BETWEEN 108 AND 167
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
    AGGREGATE: SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return
    OUTPUT: sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, ctr_total_return
    EXPECTED_ROWS: ~95K
    CONSUMERS: store_avg_threshold_cte, main_query
  store_avg_threshold_cte:
    FROM: prefactored_returns_cte
    GROUP BY: ctr_store_sk
    AGGREGATE: AVG(ctr_total_return) * 1.2 AS store_avg_threshold
    OUTPUT: ctr_store_sk, store_avg_threshold
    EXPECTED_ROWS: ~distinct stores
    CONSUMERS: main_query
  main_query:
    FROM: prefactored_returns_cte AS ctr1
    INNER JOIN store_avg_threshold_cte AS th ON ctr1.ctr_store_sk = th.ctr_store_sk
    INNER JOIN store ON s_store_sk = ctr1.ctr_store_sk
    INNER JOIN customer ON c_customer_sk = ctr1.ctr_customer_sk
    INNER JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk
    WHERE: ctr1.ctr_total_return > th.store_avg_threshold AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971
    OUTPUT: c_customer_id
    EXPECTED_ROWS: 100 (after LIMIT)
    CONSUMERS: final output
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Pre-filter date_dim into CTE, convert comma joins to explicit INNER JOIN syntax in prefactored_returns_cte.
- pg_date_cte_explicit_join: Materialize selective date filter into CTE AND use explicit JOINs. Apply to both CTE and main query.
HAZARD_FLAGS:
- The date_dim CTE must output d_date_sk for join equivalence.
- Explicit JOINs may change join order; use JOIN order that matches original semantics.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: reason_partitioned_cte_with_early_filter
TARGET_LOGICAL_TREE:
  returns_all_reasons_cte -> store_avg_threshold_cte -> returns_filtered_reasons_cte -> main_query_explicit_joins
NODE_CONTRACTS:
  returns_all_reasons_cte:
    FROM: store_returns, date_dim
    JOIN: sr_returned_date_sk = d_date_sk
    WHERE: d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
    AGGREGATE: SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return
    OUTPUT: sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, ctr_total_return
    EXPECTED_ROWS: ~95K
    CONSUMERS: store_avg_threshold_cte, returns_filtered_reasons_cte
  store_avg_threshold_cte:
    FROM: returns_all_reasons_cte
    GROUP BY: ctr_store_sk
    AGGREGATE: AVG(ctr_total_return) * 1.2 AS store_avg_threshold
    OUTPUT: ctr_store_sk, store_avg_threshold
    EXPECTED_ROWS: ~distinct stores
    CONSUMERS: main_query
  returns_filtered_reasons_cte:
    FROM: returns_all_reasons_cte
    WHERE: ctr_reason_sk BETWEEN 43 AND 46
    OUTPUT: ctr_customer_sk, ctr_store_sk, ctr_reason_sk, ctr_total_return
    EXPECTED_ROWS: ~582 (from EXPLAIN)
    CONSUMERS: main_query
  main_query:
    FROM: returns_filtered_reasons_cte AS ctr1
    INNER JOIN store_avg_threshold_cte AS th ON ctr1.ctr_store_sk = th.ctr_store_sk
    INNER JOIN store ON s_store_sk = ctr1.ctr_store_sk
    INNER JOIN customer ON c_customer_sk = ctr1.ctr_customer_sk
    INNER JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk
    WHERE: ctr1.ctr_total_return > th.store_avg_threshold AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971
    OUTPUT: c_customer_id
    EXPECTED_ROWS: 100 (after LIMIT)
    CONSUMERS: final output
EXAMPLES: pg_materialized_dimension_fact_prefilter, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_materialized_dimension_fact_prefilter: Materialize the fact aggregation once (returns_all_reasons_cte), then derive both filtered subset and store averages from it. Use MATERIALIZED keyword.
- early_filter_decorrelate: Push reason filter into a separate CTE (returns_filtered_reasons_cte) while keeping unfiltered version for averages.
HAZARD_FLAGS:
- Must ensure returns_all_reasons_cte is MATERIALIZED to avoid duplicate computation.
- The filtered CTE selects only 0.6% of rows, which reduces join workload.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy (combining shared materialization, early filtering, and decorrelation)