## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ≤100
    ├── [~] CTE_WITH: store_sales_filtered, store_avg, low_revenue_items, join_store, join_item
    │   ├── store_sales_filtered [=]
    │   │   ├── SCAN (store_sales)
    │   │   ├── JOIN (date_dim ON ss_sold_date_sk = d_date_sk)
    │   │   ├── FILTER (d_month_seq BETWEEN 1215 AND 1226)
    │   │   ├── FILTER (ss_sales_price/ss_list_price BETWEEN 0.79 AND 0.89)
    │   │   ├── AGG (GROUP BY ss_store_sk, ss_item_sk)
    │   │   └── OUTPUT (ss_store_sk, ss_item_sk, revenue)
    │   ├── store_avg [=]
    │   │   ├── FROM store_sales_filtered
    │   │   ├── AGG (GROUP BY ss_store_sk)
    │   │   └── OUTPUT (ss_store_sk, ave)
    │   ├── low_revenue_items [=]
    │   │   ├── JOIN (store_sales_filtered × store_avg ON ss_store_sk)
    │   │   ├── FILTER (revenue <= 0.1 * ave)
    │   │   └── OUTPUT (ss_store_sk, ss_item_sk, revenue)
    │   ├── join_store [=]
    │   │   ├── JOIN (low_revenue_items × store ON s_store_sk = ss_store_sk)
    │   │   ├── FILTER (s_state IN ('KS','OH','SD'))
    │   │   └── OUTPUT (ss_store_sk, ss_item_sk, revenue, s_store_name)
    │   ├── join_item [=]
    │   │   ├── JOIN (join_store × item ON i_item_sk = ss_item_sk)
    │   │   ├── FILTER (i_manager_id BETWEEN 10 AND 14)
    │   │   └── OUTPUT (s_store_name, i_item_desc, revenue, i_current_price, i_wholesale_cost, i_brand)
    │   └── sort_limit [=]
    │       ├── FROM join_item
    │       ├── SORT (s_store_name, i_item_desc)
    │       ├── LIMIT 100
    │       └── OUTPUT (s_store_name, i_item_desc, revenue, i_current_price, i_wholesale_cost, i_brand)
    └── OUTPUT (s_store_name, i_item_desc, revenue, i_current_price, i_wholesale_cost, i_brand)
```

**Change markers:**
- `[!]` — Structural change: Converted implicit joins and nested subqueries to explicit CTE-based logical tree
- `[~]` — Component modified: Entire query restructured into CTEs per Target Logical Tree
- `[=]` — All CTE nodes follow exact contract specifications (unchanged semantics)

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_decomposition",
      "description": "Decompose original nested subqueries into explicit CTEs per Target Logical Tree to eliminate duplicate scans and improve parallel execution",
      "applied_to": ["store_sales_filtered", "store_avg", "low_revenue_items", "join_store", "join_item", "sort_limit"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "store_sales_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_store_sk, ss_item_sk, SUM(ss_sales_price) AS revenue FROM store_sales JOIN date_dim ON ss_sold_date_sk = d_date_sk WHERE d_month_seq BETWEEN 1215 AND 1226 AND ss_sales_price / ss_list_price BETWEEN 0.79 AND 0.89 GROUP BY ss_store_sk, ss_item_sk",
        "interfaces": {
          "outputs": ["ss_store_sk", "ss_item_sk", "revenue"],
          "consumes": []
        }
      },
      "store_avg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_store_sk, AVG(revenue) AS ave FROM store_sales_filtered GROUP BY ss_store_sk",
        "interfaces": {
          "outputs": ["ss_store_sk", "ave"],
          "consumes": ["store_sales_filtered"]
        }
      },
      "low_revenue_items": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT store_sales_filtered.ss_store_sk, store_sales_filtered.ss_item_sk, store_sales_filtered.revenue FROM store_sales_filtered JOIN store_avg ON store_sales_filtered.ss_store_sk = store_avg.ss_store_sk WHERE store_sales_filtered.revenue <= 0.1 * store_avg.ave",
        "interfaces": {
          "outputs": ["ss_store_sk", "ss_item_sk", "revenue"],
          "consumes": ["store_sales_filtered", "store_avg"]
        }
      },
      "join_store": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT low_revenue_items.ss_store_sk, low_revenue_items.ss_item_sk, low_revenue_items.revenue, store.s_store_name FROM low_revenue_items JOIN store ON store.s_store_sk = low_revenue_items.ss_store_sk WHERE store.s_state IN ('KS','OH','SD')",
        "interfaces": {
          "outputs": ["ss_store_sk", "ss_item_sk", "revenue", "s_store_name"],
          "consumes": ["low_revenue_items"]
        }
      },
      "join_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT join_store.s_store_name, item.i_item_desc, join_store.revenue, item.i_current_price, item.i_wholesale_cost, item.i_brand FROM join_store JOIN item ON item.i_item_sk = join_store.ss_item_sk WHERE item.i_manager_id BETWEEN 10 AND 14",
        "interfaces": {
          "outputs": ["s_store_name", "i_item_desc", "revenue", "i_current_price", "i_wholesale_cost", "i_brand"],
          "consumes": ["join_store"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT s_store_name, i_item_desc, revenue, i_current_price, i_wholesale_cost, i_brand FROM join_item ORDER BY s_store_name, i_item_desc LIMIT 100",
        "interfaces": {
          "outputs": ["s_store_name", "i_item_desc", "revenue", "i_current_price", "i_wholesale_cost", "i_brand"],
          "consumes": ["join_item"]
        }
      }
    },
    "reconstruction_order": ["store_sales_filtered", "store_avg", "low_revenue_items", "join_store", "join_item", "main_query"],
    "assembly_template": "WITH store_sales_filtered AS ({store_sales_filtered}), store_avg AS ({store_avg}), low_revenue_items AS ({low_revenue_items}), join_store AS ({join_store}), join_item AS ({join_item}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Restructured original query's duplicate subqueries into explicit CTE pipeline per Target Logical Tree, eliminating the original dual scans of store_sales+date_dim while preserving exact semantics and column contracts.

**Expected speedup:** 1.8-2.2x (eliminates duplicate fact table scan, enables parallel CTE execution, maintains early aggregation)