## Part 1: Modified Logic Tree

```
[=] main_query (output columns unchanged)
  [~] date_cte → date_filter (materialized with d_date_sk only)
  [~] item_cte → item_filter (materialized with i_item_sk, i_item_id)
  [~] cd_cte → cd_filter (materialized with cd_demo_sk)
  [~] customer_cte → customer_ca_joined (NEW: pre-joins customer with customer_address)
      [+] customer_filter: c_customer_sk, c_birth_year, c_current_addr_sk
      [+] ca_filter: ca_address_sk, ca_country, ca_state, ca_county
  [~] filtered_sales → fact_dimensions_join (materialized with explicit JOIN syntax)
      [=] catalog_sales with cs_wholesale_cost filter
      [=] Joins: date_filter, item_filter, cd_filter, customer_ca_joined (replaces separate customer + customer_address joins)
  [=] aggregate with ROLLUP
  [=] ORDER BY, LIMIT
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "pg_dimension_prefetch_star", "description": "Materialize all selective dimension filters into CTEs for tiny hash tables", "applied_to": ["date_filter", "item_filter", "cd_filter", "customer_ca_joined"]},
    {"id": "R2", "type": "comma_join_conversion", "description": "Convert implicit comma joins to explicit JOIN...ON syntax to enable better optimizer join reordering", "applied_to": ["fact_dimensions_join"]},
    {"id": "R3", "type": "pre_join_dimension_chains", "description": "Pre-join customer with customer_address to eliminate one join level and enable batch filtering", "applied_to": ["customer_ca_joined"]},
    {"id": "R4", "type": "strategic_materialization", "description": "Use MATERIALIZED CTEs for dimension filters to create optimization fences that prevent predicate pushdown but create reusable hash tables", "applied_to": ["date_filter", "item_filter", "cd_filter", "customer_ca_joined"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filter": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1998",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "item_filter": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_id FROM item WHERE i_category = 'Sports'",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id"], "consumes": []}
      },
      "cd_filter": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_gender = 'F' AND cd_education_status = 'College'",
        "interfaces": {"outputs": ["cd_demo_sk"], "consumes": []}
      },
      "customer_ca_joined": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, c.c_birth_year, ca.ca_country, ca.ca_state, ca.ca_county FROM customer c INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE c.c_birth_month = 2 AND ca.ca_state IN ('AR', 'NY', 'TX')",
        "interfaces": {"outputs": ["c_customer_sk", "c_birth_year", "ca_country", "ca_state", "ca_county"], "consumes": []}
      },
      "fact_dimensions_join": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca.ca_country, ca.ca_state, ca.ca_county, i.i_item_id, cs.cs_quantity, cs.cs_list_price, cs.cs_coupon_amt, cs.cs_sales_price, cs.cs_net_profit, ca.c_birth_year FROM catalog_sales cs INNER JOIN date_filter d ON cs.cs_sold_date_sk = d.d_date_sk INNER JOIN item_filter i ON cs.cs_item_sk = i.i_item_sk INNER JOIN cd_filter cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk INNER JOIN customer_ca_joined ca ON cs.cs_bill_customer_sk = ca.c_customer_sk WHERE cs.cs_wholesale_cost BETWEEN 41 AND 46",
        "interfaces": {"outputs": ["ca_country", "ca_state", "ca_county", "i_item_id", "cs_quantity", "cs_list_price", "cs_coupon_amt", "cs_sales_price", "cs_net_profit", "c_birth_year"], "consumes": ["date_filter", "item_filter", "cd_filter", "customer_ca_joined"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, ca_country, ca_state, ca_county, AVG(CAST(cs_quantity AS DECIMAL(12,2))) AS agg1, AVG(CAST(cs_list_price AS DECIMAL(12,2))) AS agg2, AVG(CAST(cs_coupon_amt AS DECIMAL(12,2))) AS agg3, AVG(CAST(cs_sales_price AS DECIMAL(12,2))) AS agg4, AVG(CAST(cs_net_profit AS DECIMAL(12,2))) AS agg5, AVG(CAST(c_birth_year AS DECIMAL(12,2))) AS agg6 FROM fact_dimensions_join GROUP BY ROLLUP (i_item_id, ca_country, ca_state, ca_county) ORDER BY ca_country, ca_state, ca_county, i_item_id LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"], "consumes": ["fact_dimensions_join"]}
      }
    },
    "reconstruction_order": ["date_filter", "item_filter", "cd_filter", "customer_ca_joined", "fact_dimensions_join", "main_query"],
    "assembly_template": "WITH date_filter AS MATERIALIZED ({date_filter}), item_filter AS MATERIALIZED ({item_filter}), cd_filter AS MATERIALIZED ({cd_filter}), customer_ca_joined AS MATERIALIZED ({customer_ca_joined}), fact_dimensions_join AS ({fact_dimensions_join}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL enable_nestloop = off", "SET LOCAL work_mem = '256MB'", "SET LOCAL max_parallel_workers_per_gather = 4"],
  "validation_checks": []
}
```

## Mechanism Explanation

**Changes:** Pre-joined customer with customer_address into a single CTE, converted implicit comma joins to explicit JOIN syntax, and strategically materialized all dimension CTEs. This creates tiny hash tables for dimensions and enables the optimizer to choose hash joins over nested loops.

**Expected speedup:** 2.2-2.5x. The key improvements are: (1) eliminating one join level by pre-joining customer and address, (2) explicit JOIN syntax enables better join reordering, (3) materialized CTEs create optimization fences that prevent expensive predicate pushdown into large fact tables while providing reusable dimension hash tables, and (4) runtime settings disable nested loops (forcing hash joins) and allocate sufficient work_mem for hash operations.