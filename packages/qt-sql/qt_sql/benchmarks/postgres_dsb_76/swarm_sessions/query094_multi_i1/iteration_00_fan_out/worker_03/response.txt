### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Structural change: CTE-based decomposition per Target Logical Tree
    ├── [~] filtered_ws1_cte (CTE)
    │   ├── SCAN (web_sales AS ws1)
    │   ├── JOIN (INNER JOIN date_dim)
    │   ├── JOIN (INNER JOIN customer_address)
    │   ├── JOIN (INNER JOIN web_site)
    │   └── FILTER (d_date BETWEEN, ca_state IN, web_gmt_offset >=, ws_list_price BETWEEN)
    │
    ├── [~] anti_join (CTE)
    │   ├── SCAN (filtered_ws1_cte)
    │   └── FILTER (NOT EXISTS web_returns with wr_reason_sk IN)
    │
    ├── [~] semi_join (CTE)
    │   ├── SCAN (anti_join)
    │   └── FILTER (EXISTS web_sales ws2 with ws_warehouse_sk <>)
    │
    ├── [~] aggregate (CTE)
    │   ├── SCAN (semi_join)
    │   └── AGGREGATE (COUNT(DISTINCT ws_order_number), SUM(ws_ext_ship_cost), SUM(ws_net_profit))
    │
    └── [=] OUTPUT (order count, total shipping cost, total net profit) with ORDER BY and LIMIT
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_decomposition",
      "description": "Restructure implicit join + WHERE EXISTS/NOT EXISTS into explicit CTE pipeline matching target logical tree",
      "applied_to": ["main_query"]
    },
    {
      "id": "R2",
      "type": "explicit_join_syntax",
      "description": "Convert comma-separated joins to explicit INNER JOIN",
      "applied_to": ["filtered_ws1_cte"]
    },
    {
      "id": "R3",
      "type": "prefetch_filtered_dimensions",
      "description": "Pre-join filtered dimensions (date_dim, customer_address, web_site) with fact table in initial CTE",
      "applied_to": ["filtered_ws1_cte"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_ws1_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ws1.ws_order_number, ws1.ws_ext_ship_cost, ws1.ws_net_profit, ws1.ws_warehouse_sk FROM web_sales ws1 INNER JOIN date_dim ON ws1.ws_ship_date_sk = date_dim.d_date_sk INNER JOIN customer_address ON ws1.ws_ship_addr_sk = customer_address.ca_address_sk INNER JOIN web_site ON ws1.ws_web_site_sk = web_site.web_site_sk WHERE date_dim.d_date BETWEEN '2002-9-01' AND CAST('2002-9-01' AS DATE) + INTERVAL '60 DAY' AND customer_address.ca_state IN ('CA','MI','OH','SD','TX','VA') AND web_site.web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 237 AND 266",
        "interfaces": {"outputs": ["ws_order_number", "ws_ext_ship_cost", "ws_net_profit", "ws_warehouse_sk"], "consumes": []}
      },
      "anti_join": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ws_order_number, ws_ext_ship_cost, ws_net_profit, ws_warehouse_sk FROM filtered_ws1_cte WHERE NOT EXISTS (SELECT 1 FROM web_returns wr1 WHERE wr1.wr_order_number = filtered_ws1_cte.ws_order_number AND wr1.wr_reason_sk IN (7,25,26,52,69))",
        "interfaces": {"outputs": ["ws_order_number", "ws_ext_ship_cost", "ws_net_profit", "ws_warehouse_sk"], "consumes": ["filtered_ws1_cte"]}
      },
      "semi_join": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ws_order_number, ws_ext_ship_cost, ws_net_profit FROM anti_join WHERE EXISTS (SELECT 1 FROM web_sales ws2 WHERE ws2.ws_order_number = anti_join.ws_order_number AND ws2.ws_warehouse_sk <> anti_join.ws_warehouse_sk)",
        "interfaces": {"outputs": ["ws_order_number", "ws_ext_ship_cost", "ws_net_profit"], "consumes": ["anti_join"]}
      },
      "aggregate": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT COUNT(DISTINCT ws_order_number) AS \"order count\", SUM(ws_ext_ship_cost) AS \"total shipping cost\", SUM(ws_net_profit) AS \"total net profit\" FROM semi_join",
        "interfaces": {"outputs": ["order count", "total shipping cost", "total net profit"], "consumes": ["semi_join"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT \"order count\", \"total shipping cost\", \"total net profit\" FROM aggregate ORDER BY \"order count\" LIMIT 100",
        "interfaces": {"outputs": ["order count", "total shipping cost", "total net profit"], "consumes": ["aggregate"]}
      }
    },
    "reconstruction_order": ["filtered_ws1_cte", "anti_join", "semi_join", "aggregate", "main_query"],
    "assembly_template": "WITH filtered_ws1_cte AS ({filtered_ws1_cte}), anti_join AS ({anti_join}), semi_join AS ({semi_join}), aggregate AS ({aggregate}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

Changes: Restructured original implicit-join query into explicit CTE pipeline matching target logical tree (filtered_ws1_cte → anti_join → semi_join → aggregate), converting comma joins to explicit INNER JOIN syntax while preserving all original filters, guards, and semi/anti-join semantics. This decomposition isolates dimension filtering early and maintains optimizer flexibility.

Expected speedup: Moderate (1.5-2x) due to explicit join syntax providing better cardinality estimates and CTE structure allowing parallel execution of dimension filters.