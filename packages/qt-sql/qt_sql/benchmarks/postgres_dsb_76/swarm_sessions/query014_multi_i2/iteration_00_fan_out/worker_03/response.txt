## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] cross_items [!] Cost: 0% → 0% Rows: 4,735
│   ├── [~] STRUCTURE: Original INTERSECT preserved exactly
│   └── OUTPUT: ss_item_sk
├── [CTE] avg_sales [=] Cost: 18% Rows: 1
│   ├── SCAN (web_sales, date_dim, store_sales, catalog_sales)
│   └── OUTPUT: average_sales
├── [CTE] base_aggregation [+] Cost: new Rows: ~10K
│   ├── SCAN (store_sales, item, date_dim, cross_items)
│   ├── JOIN (ss_item_sk = i_item_sk AND ss_item_sk = cross_items.ss_item_sk AND ss_sold_date_sk = d_date_sk)
│   ├── FILTER (i_category IN list AND i_manager_id 42-51 AND ss_wholesale_cost 76-96 AND d_year IN (1999,2000))
│   └── OUTPUT: i_brand_id, i_class_id, i_category_id, d_year, d_week_seq, sales_amount, ss_quantity, ss_list_price
├── [CTE] year_split [+] Cost: new Rows: ~200
│   ├── FROM: base_aggregation
│   ├── GROUP BY: i_brand_id, i_class_id, i_category_id, d_year, d_week_seq
│   ├── HAVING: SUM(sales_amount) > (SELECT average_sales FROM avg_sales)
│   └── OUTPUT: i_brand_id, i_class_id, i_category_id, d_year, d_week_seq, sales, number_sales
└── [MAIN] final_join [!] Cost: 71% → new Rows: 55
    ├── [!] STRUCTURE: Single CTE scan + self-join replaces redundant base scans
    ├── FROM: year_split AS this_year (d_year=2000 + week_seq subquery)
    ├── JOIN: year_split AS last_year (d_year=1999 + week_seq subquery)
    └── OUTPUT: 12 columns exactly
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "pg_self_join_decomposition",
      "description": "Materialize store_sales+item+date_dim scan once in base_aggregation CTE, derive both year aggregates from same result",
      "applied_to": ["base_aggregation", "year_split", "final_join"]
    },
    {
      "id": "R2",
      "type": "cte_column_completeness",
      "description": "Ensure all CTEs include columns referenced downstream (cross_items.ss_item_sk, avg_sales.average_sales, etc.)",
      "applied_to": ["cross_items", "avg_sales", "base_aggregation", "year_split"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "cross_items": {
          "type": "cte",
          "change": "unchanged",
          "sql": "",
          "interfaces": {
            "outputs": ["ss_item_sk"],
            "consumes": []
          }
        },
        "avg_sales": {
          "type": "cte",
          "change": "unchanged",
          "sql": "",
          "interfaces": {
            "outputs": ["average_sales"],
            "consumes": []
          }
        },
        "base_aggregation": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i.i_brand_id, i.i_class_id, i.i_category_id, d.d_year, d.d_week_seq, ss.ss_quantity * ss.ss_list_price AS sales_amount, ss.ss_quantity, ss.ss_list_price FROM store_sales ss JOIN item i ON ss.ss_item_sk = i.i_item_sk JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk JOIN cross_items ci ON ss.ss_item_sk = ci.ss_item_sk WHERE i.i_category IN ('Electronics', 'Shoes', 'Sports') AND i.i_manager_id BETWEEN 42 AND 51 AND ss.ss_wholesale_cost BETWEEN 76 AND 96 AND d.d_year IN (1999, 2000)",
          "interfaces": {
            "outputs": ["i_brand_id", "i_class_id", "i_category_id", "d_year", "d_week_seq", "sales_amount", "ss_quantity", "ss_list_price"],
            "consumes": ["cross_items"]
          }
        },
        "year_split": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i_brand_id, i_class_id, i_category_id, d_year, d_week_seq, SUM(sales_amount) AS sales, COUNT(*) AS number_sales FROM base_aggregation GROUP BY i_brand_id, i_class_id, i_category_id, d_year, d_week_seq HAVING SUM(sales_amount) > (SELECT average_sales FROM avg_sales)",
          "interfaces": {
            "outputs": ["i_brand_id", "i_class_id", "i_category_id", "d_year", "d_week_seq", "sales", "number_sales"],
            "consumes": ["base_aggregation", "avg_sales"]
          }
        },
        "final_join": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT 'store' AS ty_channel, ty.i_brand_id AS ty_brand, ty.i_class_id AS ty_class, ty.i_category_id AS ty_category, ty.sales AS ty_sales, ty.number_sales AS ty_number_sales, 'store' AS ly_channel, ly.i_brand_id AS ly_brand, ly.i_class_id AS ly_class, ly.i_category_id AS ly_category, ly.sales AS ly_sales, ly.number_sales AS ly_number_sales FROM (SELECT * FROM year_split WHERE d_year = 2000 AND d_week_seq = (SELECT d_week_seq FROM date_dim WHERE d_year = 2000 AND d_moy = 12 AND d_dom = 12)) ty JOIN (SELECT * FROM year_split WHERE d_year = 1999 AND d_week_seq = (SELECT d_week_seq FROM date_dim WHERE d_year = 1999 AND d_moy = 12 AND d_dom = 12)) ly ON ty.i_brand_id = ly.i_brand_id AND ty.i_class_id = ly.i_class_id AND ty.i_category_id = ly.i_category_id ORDER BY ty_channel, ty_brand, ty_class, ty_category LIMIT 100",
          "interfaces": {
            "outputs": ["ty_channel", "ty_brand", "ty_class", "ty_category", "ty_sales", "ty_number_sales", "ly_channel", "ly_brand", "ly_class", "ly_category", "ly_sales", "ly_number_sales"],
            "consumes": ["year_split"]
          }
        }
      },
      "reconstruction_order": ["cross_items", "avg_sales", "base_aggregation", "year_split", "final_join"],
      "assembly_template": "WITH cross_items AS (SELECT i_item_sk ss_item_sk FROM item, (SELECT iss.i_brand_id brand_id, iss.i_class_id class_id, iss.i_category_id category_id FROM store_sales, item iss, date_dim d1 WHERE ss_item_sk = iss.i_item_sk AND ss_sold_date_sk = d1.d_date_sk AND d1.d_year BETWEEN 1999 AND 1999 + 2 AND i_category IN ('Electronics', 'Shoes', 'Sports') AND i_manager_id BETWEEN 42 AND 51 AND ss_wholesale_cost BETWEEN 76 AND 96 INTERSECT SELECT ics.i_brand_id, ics.i_class_id, ics.i_category_id FROM catalog_sales, item ics, date_dim d2 WHERE cs_item_sk = ics.i_item_sk AND cs_sold_date_sk = d2.d_date_sk AND d2.d_year BETWEEN 1999 AND 1999 + 2 AND i_category IN ('Electronics', 'Shoes', 'Sports') AND i_manager_id BETWEEN 42 AND 51 AND cs_wholesale_cost BETWEEN 76 AND 96 INTERSECT SELECT iws.i_brand_id, iws.i_class_id, iws.i_category_id FROM web_sales, item iws, date_dim d3 WHERE ws_item_sk = iws.i_item_sk AND ws_sold_date_sk = d3.d_date_sk AND ws_wholesale_cost BETWEEN 76 AND 96 AND d3.d_year BETWEEN 1999 AND 1999 + 2) x WHERE i_brand_id = brand_id AND i_class_id = class_id AND i_category_id = category_id AND i_category IN ('Electronics', 'Shoes', 'Sports') AND i_manager_id BETWEEN 42 AND 51), avg_sales AS (SELECT AVG(quantity*list_price) average_sales FROM (SELECT ss_quantity quantity, ss_list_price list_price FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year BETWEEN 1999 AND 1999 + 2 AND ss_wholesale_cost BETWEEN 76 AND 96 UNION ALL SELECT cs_quantity quantity, cs_list_price list_price FROM catalog_sales, date_dim WHERE cs_sold_date_sk = d_date_sk AND d_year BETWEEN 1999 AND 1999 + 2 AND cs_wholesale_cost BETWEEN 76 AND 96 UNION ALL SELECT ws_quantity quantity, ws_list_price list_price FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND ws_wholesale_cost BETWEEN 76 AND 96 AND d_year BETWEEN 1999 AND 1999 + 2) x), base_aggregation AS ({base_aggregation}), year_split AS ({year_split}) {final_join}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL max_parallel_workers_per_gather = 0",
    "SET LOCAL work_mem = '32MB'",
    "SET LOCAL enable_nestloop = off"
  ],
  "validation_checks": []
}
```

**Changes:** Materialized the shared store_sales+item+date_dim scan once in `base_aggregation` CTE, then derived both year aggregates from the same result via `year_split` CTE. This eliminates redundant scanning of the large fact table and preserves exact INTERSECT/UNION structures.

**Expected speedup:** 3-4x from eliminating duplicate store_sales scans and enabling parallel execution (though CTE materialization blocks parallelism for `base_aggregation`, the single scan still wins over original's 4 separate scans). `max_parallel_workers_per_gather = 0` avoids parallel overhead on small CTE results.