<reasoning>
CLASSIFY: This is a multi-channel comparison self-join query with three key characteristics: (1) repeated scans of the same fact table (store_sales) for different years, (2) a complex INTERSECT CTE that filters items appearing across all three sales channels, and (3) a UNION ALL CTE computing average sales across channels used as a threshold filter. Structural archetype: repeated fact scan + multi-channel set operations + self-join with correlated date filtering.

EXPLAIN PLAN ANALYSIS:
- Total runtime: 11.5s
- Dominant costs:
  1. cross_items CTE: 4.76s (41%) – due to three INTERSECT branches scanning store_sales, catalog_sales, web_sales with nested loops and high row filtering (719-2,186 rows per date, filtered down to 0-1 rows by item filters).
  2. avg_sales CTE: 2.73s (24%) – UNION ALL of three channels with similar nested loops.
  3. Main query nested loop join between this_year and last_year: 11.5s total, but the nested loop executes last_year subquery 194 times (10.6ms each → ~2.1s). The this_year aggregation takes 6.7s (sort + filter).
- Row count drops:
  - date_dim scans: 365 rows (year filter) → good selectivity
  - store_sales index scans: 2,186 rows per date → 21 rows after wholesale_cost filter → 0-1 rows after item join (severe drop)
  - cross_items: 841K rows across three branches → 435 rows after INTERSECT → 4,735 rows after final item join (expansion due to duplicate brand/class/category combos)
- The optimizer already materializes CTEs (cross_items scanned twice: 4.76s then 0.3ms). It uses nested loops throughout due to index availability.
- Scan counts: store_sales scanned 4 times (once in cross_items store_sales branch, once in avg_sales store_sales branch, once each for this_year and last_year). catalog_sales and web_sales each scanned twice (cross_items + avg_sales).

GAP MATCHING:
1. COMMA_JOIN_WEAKNESS: Present. All joins are comma-style implicit joins in CTEs (store_sales, item iss, date_dim d1). The optimizer may misestimate cardinalities.
2. CROSS_CTE_PREDICATE_BLINDNESS: Present. The same store_sales+date_dim+item scan pattern appears in cross_items (store_sales branch), avg_sales (store_sales branch), this_year, and last_year – each with slightly different filters but same base tables.
3. NON_EQUI_JOIN_INPUT_BLINDNESS: Not applicable (all equi-joins).
4. CORRELATED_SUBQUERY_PARALYSIS: Not applicable (no correlated subqueries).

AGGREGATION TRAP CHECK:
- Only AVG and SUM used. AVG in avg_sales is duplicate-sensitive, but the UNION ALL branches are independent with no joins that would cause duplication. The main query uses SUM and COUNT which are grouping-insensitive. No FILTER clauses. Safe to restructure.

TRANSFORM SELECTION:
1. **star_join_prefetch** (pg_dimension_prefetch_star): Addresses comma joins and pre-filters dimensions. High value due to repeated dimension filters (item category/manager_id, date year).
2. **scan_consolidation_pivot** (single_pass_aggregation): Combine this_year and last_year scans into one pass with CASE pivoting. Reduces store_sales scans from 2 to 1.
3. **self_join_elimination** (pg_self_join_decomposition): Materialize the common fact+dimension scan once and derive both year aggregates. Reduces repeated work.
4. **EXPLORATION**: Rewrite INTERSECT using EXISTS (intersect_to_exists) – though not in engine profile, the INTERSECT is expensive (4.76s). Risk: EXISTS may not be faster if optimizer already implements INTERSECT efficiently via hashing.

LOGICAL TREE DESIGN:
- Need to ensure CTE column completeness: cross_items outputs ss_item_sk; avg_sales outputs average_sales; any new CTEs must include all columns referenced downstream.
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
This query compares store channel sales for items that sold across all three channels (store, catalog, web) in consecutive years (1999 vs 2000) for the same week (week 49-50). It filters to Electronics/Shoes/Sports categories, manager_id 42-51, and wholesale_cost 76-96. JOIN semantics are strict INNER intersections: items must appear in all three sales channels (INTERSECT), and year comparisons require matching brand/class/category. Aggregation uses SUM and COUNT which are duplicate-insensitive, but AVG in the threshold CTE must preserve exact row sets from the UNION ALL branches. Filter dependencies: date_dim filters for specific years and week_seq must remain correlated to their respective year subqueries.

BOTTLENECK_DIAGNOSIS:
The query is join-bound with excessive nested loops (16x) due to index-driven plans. The cross_items CTE (41% runtime) performs three large fact table scans with severe filtering (2,186 rows per date → 0-1 after item join). The main query's nested loop join between this_year and last_year executes the last_year subquery 194 times (2.1s). The optimizer already materializes CTEs effectively (cross_items scanned once, reused). Logical-tree costs are misleading: cross_items shows 0% cost but consumes 4.76s; main_query shows 71% cost but includes CTE execution time.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must preserve all 12 output columns exactly.
- CTE_COLUMN_COMPLETENESS: New CTEs must include all columns referenced downstream (e.g., ss_item_sk, average_sales, i_brand_id, i_class_id, i_category_id).
- LITERAL_PRESERVATION: All filter values (1999, 2000, 12, 42, 51, 76, 96, category list) must remain exact.
- SEMANTIC_EQUIVALENCE: Result rows must match exactly.
- COMMA_JOIN_WEAKNESS: All CTEs use comma-style implicit joins causing cardinality estimation issues.
- CROSS_CTE_PREDICATE_BLINDNESS: Same store_sales+date_dim+item scan pattern repeated 4 times with minor filter variations.

REGRESSION_WARNINGS:
1. CTE blocking parallelism (observed regression in Q055):
   CAUSE: Materialized CTEs executed single-threaded, preventing parallel scans of large fact tables.
   RULE: Avoid wrapping large fact table scans in CTEs; keep them in main query for parallel execution.
2. EXISTS conversion regression (observed 0.50x on Q069):
   CAUSE: Converting INTERSECT to EXISTS changed semi-join to anti-join plan, losing hash optimization.
   RULE: Test EXISTS conversion cautiously; verify the optimizer chooses efficient semi-join.

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch_explicit
TARGET_LOGICAL_TREE:
  filtered_dates -> filtered_items -> prefactored_sales -> cross_items -> avg_sales -> main_query_explicit_joins
NODE_CONTRACTS:
  filtered_dates:
    FROM: date_dim
    WHERE: d_year BETWEEN 1999 AND 2001
    OUTPUT: d_date_sk, d_year, d_week_seq
    EXPECTED_ROWS: 365
    CONSUMERS: filtered_items, prefactored_sales, cross_items, avg_sales, main_query
  filtered_items:
    FROM: item
    WHERE: i_category IN ('Electronics', 'Shoes', 'Sports') AND i_manager_id BETWEEN 42 AND 51
    OUTPUT: i_item_sk, i_brand_id, i_class_id, i_category_id
    EXPECTED_ROWS: 4,750
    CONSUMERS: prefactored_sales, cross_items, main_query
  prefactored_sales:
    FROM: store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_items ON ss_item_sk = i_item_sk
    WHERE: ss_wholesale_cost BETWEEN 76 AND 96
    OUTPUT: ss_item_sk, ss_quantity, ss_list_price, ss_sold_date_sk, i_brand_id, i_class_id, i_category_id, d_week_seq, d_year
    EXPECTED_ROWS: ~100K (estimate)
    CONSUMERS: cross_items, avg_sales, main_query
  cross_items:
    FROM: (SELECT i_brand_id, i_class_id, i_category_id FROM prefactored_sales WHERE d_year BETWEEN 1999 AND 2001 INTERSECT ...) AS x JOIN filtered_items ON i_brand_id = brand_id AND i_class_id = class_id AND i_category_id = category_id
    OUTPUT: i_item_sk AS ss_item_sk
    EXPECTED_ROWS: 4,735
    CONSUMERS: main_query
  avg_sales:
    FROM: (SELECT ss_quantity, ss_list_price FROM prefactored_sales UNION ALL catalog_sales JOIN filtered_dates ... UNION ALL web_sales JOIN filtered_dates ...)
    OUTPUT: AVG(quantity * list_price) AS average_sales
    EXPECTED_ROWS: 1
    CONSUMERS: main_query
  main_query_explicit_joins:
    FROM: (SELECT ... FROM prefactored_sales JOIN cross_items ... WHERE d_week_seq = (SELECT d_week_seq FROM date_dim WHERE d_year=2000 AND d_moy=12 AND d_dom=12) GROUP BY ... HAVING SUM(...) > (SELECT average_sales FROM avg_sales)) AS this_year
           INNER JOIN
           (SELECT ... FROM prefactored_sales JOIN cross_items ... WHERE d_week_seq = (SELECT d_week_seq FROM date_dim WHERE d_year=1999 AND d_moy=12 AND d_dom=12) GROUP BY ... HAVING SUM(...) > (SELECT average_sales FROM avg_sales)) AS last_year
           ON this_year.i_brand_id = last_year.i_brand_id AND this_year.i_class_id = last_year.i_class_id AND this_year.i_category_id = last_year.i_category_id
    OUTPUT: ty_channel, ty_brand, ty_class, ty_category, ty_sales, ty_number_sales, ly_channel, ly_brand, ly_class, ly_category, ly_sales, ly_number_sales
    EXPECTED_ROWS: 55
    CONSUMERS: final output
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply pre-filtering of date_dim and item into CTEs, convert all comma joins to explicit JOIN syntax.
- pg_date_cte_explicit_join: Isolate date_dim filter into filtered_dates CTE, use explicit JOINs.
- early_filter_decorrelate: Push item and date filters early into CTEs; ignore decorrelation aspect (no correlated subqueries).
HAZARD_FLAGS:
- filtered_dates CTE may be inlined, losing materialization benefit.
- prefactored_sales CTE could become large (~100K rows) and block parallelism.

=== WORKER 2 BRIEFING ===

STRATEGY: scan_consolidation_pivot
TARGET_LOGICAL_TREE:
  cross_items -> avg_sales -> combined_years -> pivot_aggregation -> final_join
NODE_CONTRACTS:
  cross_items:
    FROM: (original INTERSECT structure unchanged)
    OUTPUT: ss_item_sk
    EXPECTED_ROWS: 4,735
    CONSUMERS: combined_years
  avg_sales:
    FROM: (original UNION ALL structure unchanged)
    OUTPUT: average_sales
    EXPECTED_ROWS: 1
    CONSUMERS: combined_years
  combined_years:
    FROM: store_sales 
          JOIN item ON ss_item_sk = i_item_sk 
          JOIN date_dim ON ss_sold_date_sk = d_date_sk 
          JOIN cross_items ON ss_item_sk = cross_items.ss_item_sk
    WHERE: i_category IN ('Electronics', 'Shoes', 'Sports') 
           AND i_manager_id BETWEEN 42 AND 51 
           AND ss_wholesale_cost BETWEEN 76 AND 96
           AND d_year IN (1999, 2000)
           AND d_moy = 12 
           AND d_dom = 12
    OUTPUT: i_brand_id, i_class_id, i_category_id, 
            d_year,
            ss_quantity * ss_list_price AS sales_amount,
            ss_quantity,
            ss_list_price,
            d_week_seq
    EXPECTED_ROWS: ~1K (estimate)
    CONSUMERS: pivot_aggregation
  pivot_aggregation:
    FROM: combined_years
    GROUP BY: i_brand_id, i_class_id, i_category_id, d_year
    HAVING: SUM(ss_quantity * ss_list_price) > (SELECT average_sales FROM avg_sales)
    OUTPUT: i_brand_id, i_class_id, i_category_id, 
            d_year,
            SUM(ss_quantity * ss_list_price) AS sales,
            COUNT(*) AS number_sales
    EXPECTED_ROWS: ~100
    CONSUMERS: final_join
  final_join:
    FROM: (SELECT 'store' AS channel, * FROM pivot_aggregation WHERE d_year = 2000) AS this_year
          INNER JOIN
          (SELECT 'store' AS channel, * FROM pivot_aggregation WHERE d_year = 1999) AS last_year
          USING (i_brand_id, i_class_id, i_category_id)
    OUTPUT: this_year.channel AS ty_channel, this_year.i_brand_id AS ty_brand, ... (all 12 columns)
    EXPECTED_ROWS: 55
    CONSUMERS: final output
EXAMPLES: single_pass_aggregation, scan_consolidation_pivot
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Combine both year scans into one with d_year filter, then pivot using CASE; ignore channel aggregation (only store channel here).
- scan_consolidation_pivot: Use GROUP BY with d_year to compute aggregates per year, then pivot via self-join; ensure HAVING clause references avg_sales correctly.
HAZARD_FLAGS:
- Must preserve week_seq correlation: the original uses d_week_seq from a specific date (1999-12-12, 2000-12-12). Our combined scan filters d_moy=12 AND d_dom=12, which is equivalent but must be verified.
- Pivoting via self-join may duplicate the avg_sales subquery evaluation.

=== WORKER 3 BRIEFING ===

STRATEGY: self_join_elimination
TARGET_LOGICAL_TREE:
  cross_items -> avg_sales -> base_aggregation -> year_split -> final_join
NODE_CONTRACTS:
  cross_items:
    FROM: (original INTERSECT structure)
    OUTPUT: ss_item_sk
    EXPECTED_ROWS: 4,735
    CONSUMERS: base_aggregation
  avg_sales:
    FROM: (original UNION ALL structure)
    OUTPUT: average_sales
    EXPECTED_ROWS: 1
    CONSUMERS: year_split
  base_aggregation:
    FROM: store_sales 
          JOIN item ON ss_item_sk = i_item_sk 
          JOIN date_dim ON ss_sold_date_sk = d_date_sk 
          JOIN cross_items ON ss_item_sk = cross_items.ss_item_sk
    WHERE: i_category IN ('Electronics', 'Shoes', 'Sports') 
           AND i_manager_id BETWEEN 42 AND 51 
           AND ss_wholesale_cost BETWEEN 76 AND 96
           AND d_year IN (1999, 2000)
    OUTPUT: i_brand_id, i_class_id, i_category_id, 
            d_year,
            d_week_seq,
            ss_quantity * ss_list_price AS sales_amount,
            ss_quantity,
            ss_list_price
    EXPECTED_ROWS: ~10K (estimate)
    CONSUMERS: year_split
  year_split:
    FROM: base_aggregation
    GROUP BY: i_brand_id, i_class_id, i_category_id, d_year, d_week_seq
    HAVING: SUM(ss_quantity * ss_list_price) > (SELECT average_sales FROM avg_sales)
    OUTPUT: i_brand_id, i_class_id, i_category_id, 
            d_year,
            d_week_seq,
            SUM(ss_quantity * ss_list_price) AS sales,
            COUNT(*) AS number_sales
    EXPECTED_ROWS: ~200
    CONSUMERS: final_join
  final_join:
    FROM: (SELECT 'store' AS channel, * FROM year_split WHERE d_year = 2000 AND d_week_seq = (SELECT d_week_seq FROM date_dim WHERE d_year=2000 AND d_moy=12 AND d_dom=12)) AS this_year
          INNER JOIN
          (SELECT 'store' AS channel, * FROM year_split WHERE d_year = 1999 AND d_week_seq = (SELECT d_week_seq FROM date_dim WHERE d_year=1999 AND d_moy=12 AND d_dom=12)) AS last_year
          USING (i_brand_id, i_class_id, i_category_id)
    OUTPUT: this_year.channel AS ty_channel, this_year.i_brand_id AS ty_brand, ... (all 12 columns)
    EXPECTED_ROWS: 55
    CONSUMERS: final output
EXAMPLES: pg_self_join_decomposition, shared_dimension_multi_channel
EXAMPLE_ADAPTATION:
- pg_self_join_decomposition: Materialize the base store_sales+item+date_dim scan once in base_aggregation CTE, then derive both year aggregates from it.
- shared_dimension_multi_channel: Not applicable (only store channel). Ignore multi-channel aspect.
HAZARD_FLAGS:
- The week_seq subquery must be evaluated after aggregation, which may be less efficient than pushing it into the base scan.
- base_aggregation CTE may be large (~10K rows) and materialization overhead could outweigh benefit.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: intersect_to_exists_materialized
TARGET_LOGICAL_TREE:
  filtered_dates -> filtered_items -> store_branch -> catalog_branch -> web_branch -> cross_items_exists -> avg_sales -> main_query
NODE_CONTRACTS:
  filtered_dates:
    FROM: date_dim
    WHERE: d_year BETWEEN 1999 AND 2001
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 365
    CONSUMERS: store_branch, catalog_branch, web_branch, avg_sales
  filtered_items:
    FROM: item
    WHERE: i_category IN ('Electronics', 'Shoes', 'Sports') AND i_manager_id BETWEEN 42 AND 51
    OUTPUT: i_item_sk, i_brand_id, i_class_id, i_category_id
    EXPECTED_ROWS: 4,750
    CONSUMERS: store_branch, catalog_branch, web_branch, cross_items_exists, main_query
  store_branch:
    FROM: store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_items ON ss_item_sk = i_item_sk
    WHERE: ss_wholesale_cost BETWEEN 76 AND 96
    OUTPUT: i_brand_id, i_class_id, i_category_id
    EXPECTED_ROWS: ~60K
    CONSUMERS: cross_items_exists
  catalog_branch:
    FROM: catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN filtered_items ON cs_item_sk = i_item_sk
    WHERE: cs_wholesale_cost BETWEEN 76 AND 96
    OUTPUT: i_brand_id, i_class_id, i_category_id
    EXPECTED_ROWS: ~60K
    CONSUMERS: cross_items_exists
  web_branch:
    FROM: web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_items ON ws_item_sk = i_item_sk
    WHERE: ws_wholesale_cost BETWEEN 76 AND 96
    OUTPUT: i_brand_id, i_class_id, i_category_id
    EXPECTED_ROWS: ~840K
    CONSUMERS: cross_items_exists
  cross_items_exists:
    FROM: filtered_items AS i
    WHERE: EXISTS (SELECT 1 FROM store_branch s WHERE s.i_brand_id = i.i_brand_id AND s.i_class_id = i.i_class_id AND s.i_category_id = i.i_category_id)
      AND EXISTS (SELECT 1 FROM catalog_branch c WHERE c.i_brand_id = i.i_brand_id AND c.i_class_id = i.i_class_id AND c.i_category_id = i.i_category_id)
      AND EXISTS (SELECT 1 FROM web_branch w WHERE w.i_brand_id = i.i_brand_id AND w.i_class_id = i.i_class_id AND w.i_category_id = i.i_category_id)
    OUTPUT: i_item_sk AS ss_item_sk
    EXPECTED_ROWS: 4,735
    CONSUMERS: main_query
  avg_sales:
    FROM: (store_sales UNION ALL catalog_sales UNION ALL web_sales) JOIN filtered_dates ... (as original but with filtered_dates)
    OUTPUT: average_sales
    EXPECTED_ROWS: 1
    CONSUMERS: main_query
  main_query:
    FROM: (original this_year subquery using cross_items_exists) AS this_year
          INNER JOIN
          (original last_year subquery using cross_items_exists) AS last_year
          USING (i_brand_id, i_class_id, i_category_id)
    OUTPUT: all 12 columns
    EXPECTED_ROWS: 55
    CONSUMERS: final output
EXAMPLES: intersect_to_exists, pg_dimension_prefetch_star
EXAMPLE_ADAPTATION:
- intersect_to_exists: Replace INTERSECT with EXISTS subqueries; ensure each branch is pre-materialized as CTE to avoid repeated scans.
- pg_dimension_prefetch_star: Apply dimension pre-filtering CTEs; use explicit JOINs in branches.
HAZARD_FLAGS:
- EXISTS may force nested loop semi-joins instead of hash semi-joins, potentially slower.
- Materializing three large branches (store_branch, catalog_branch, web_branch) could increase memory usage.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: The query has INTERSECT, which matches the intersect_to_exists pattern. The regression warning about EXISTS conversion applies, but we mitigate by pre-materializing branches and using filtered dimensions.
EXPLORATION_TYPE: novel_combination (combining intersect_to_exists with dimension prefetching and materialization)