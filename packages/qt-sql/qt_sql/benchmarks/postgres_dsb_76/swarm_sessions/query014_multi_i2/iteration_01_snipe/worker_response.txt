<reasoning>
The primary bottleneck is the `cross_items` CTE, which uses an INTERSECT over three large fact table scans (store_sales, catalog_sales, web_sales) with complex filters. The INTERSECT operation is expensive and materializes large intermediate results. The original execution plan shows 4.7 seconds spent on this CTE.

The key optimization angle is to replace INTERSECT with a more efficient approach. Instead of computing three separate sets and intersecting them, we can compute a single aggregated count of distinct channels per item (brand, class, category). This reduces the number of fact table scans and avoids materializing large intermediate sets.

We can pre-filter the fact tables by date and wholesale_cost, join with filtered items, and then aggregate by brand/class/category and channel. Then, we can count distinct channels per group and filter for groups with all three channels. This is semantically equivalent to the original INTERSECT but more efficient because it uses a single aggregation pass.

Additionally, we can convert all comma joins to explicit JOIN syntax, which improves PostgreSQL's optimizer estimates and join ordering.

We also combine the two year subqueries into a single aggregated CTE that computes sales for both target weeks in one pass, reducing redundant scanning and aggregation.

Finally, we add SET LOCAL configuration to increase work_mem for the large hash aggregates and disable nested loops where hash joins are more efficient.
</reasoning>

## Part 1: Modified Logic Tree

```
[+] week_seq
    |- d_week_seq for 1999-12-12
    |- d_week_seq for 2000-12-12

[~] cross_items
    [-] INTERSECT over three subqueries
    [+] Single aggregation counting distinct channels per brand/class/category
        |- Pre-filtered store_sales branch
        |- Pre-filtered catalog_sales branch
        |- Pre-filtered web_sales branch
        |- Aggregate by brand/class/category, count distinct channels
        |- Filter for count = 3
    [+] Join with filtered_items to get item_sk

[=] avg_sales (unchanged except comma→JOIN)

[~] store_sales_aggregated
    [-] Separate subqueries for 1999 and 2000
    [+] Single aggregation grouping by d_year, i_brand_id, i_class_id, i_category_id
        |- Filter by cross_items (item_sk)
        |- Filter by week_seq (both weeks)
        |- Filter by item category and manager_id
        |- Filter by wholesale_cost
        |- Aggregate sales and count
        |- HAVING using avg_sales threshold

[~] main_query
    [-] Join of two separate year subqueries
    [+] Join of two filtered subsets from store_sales_aggregated (1999 vs 2000)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "intersect_to_aggregate", "description": "Replace INTERSECT with channel-counting aggregation", "applied_to": ["cross_items"]},
    {"id": "R2", "type": "comma_to_explicit_join", "description": "Convert all comma joins to explicit JOIN syntax", "applied_to": ["cross_items", "avg_sales", "store_sales_aggregated"]},
    {"id": "R3", "type": "single_pass_aggregation", "description": "Combine 1999 and 2000 week aggregations into one pass", "applied_to": ["store_sales_aggregated"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "week_seq": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT (SELECT d_week_seq FROM date_dim WHERE d_year = 1999 AND d_moy = 12 AND d_dom = 12) AS week_seq_1999, (SELECT d_week_seq FROM date_dim WHERE d_year = 2000 AND d_moy = 12 AND d_dom = 12) AS week_seq_2000",
        "interfaces": {"outputs": ["week_seq_1999", "week_seq_2000"], "consumes": []}
      },
      "filtered_items": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_brand_id, i_class_id, i_category_id FROM item WHERE i_category IN ('Electronics', 'Shoes', 'Sports') AND i_manager_id BETWEEN 42 AND 51",
        "interfaces": {"outputs": ["i_item_sk", "i_brand_id", "i_class_id", "i_category_id"], "consumes": []}
      },
      "cross_items": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk AS ss_item_sk FROM (SELECT i_brand_id, i_class_id, i_category_id FROM (SELECT i_brand_id, i_class_id, i_category_id, 'store' AS channel FROM store_sales JOIN filtered_items ON ss_item_sk = i_item_sk JOIN date_dim ON ss_sold_date_sk = d_date_sk WHERE d_year BETWEEN 1999 AND 1999 + 2 AND ss_wholesale_cost BETWEEN 76 AND 96 UNION ALL SELECT i_brand_id, i_class_id, i_category_id, 'catalog' AS channel FROM catalog_sales JOIN filtered_items ON cs_item_sk = i_item_sk JOIN date_dim ON cs_sold_date_sk = d_date_sk WHERE d_year BETWEEN 1999 AND 1999 + 2 AND cs_wholesale_cost BETWEEN 76 AND 96 UNION ALL SELECT i_brand_id, i_class_id, i_category_id, 'web' AS channel FROM web_sales JOIN filtered_items ON ws_item_sk = i_item_sk JOIN date_dim ON ws_sold_date_sk = d_date_sk WHERE d_year BETWEEN 1999 AND 1999 + 2 AND ws_wholesale_cost BETWEEN 76 AND 96) AS channel_sales GROUP BY i_brand_id, i_class_id, i_category_id HAVING COUNT(DISTINCT channel) = 3) AS ci JOIN filtered_items ON ci.i_brand_id = filtered_items.i_brand_id AND ci.i_class_id = filtered_items.i_class_id AND ci.i_category_id = filtered_items.i_category_id",
        "interfaces": {"outputs": ["ss_item_sk"], "consumes": ["filtered_items"]}
      },
      "avg_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT AVG(quantity * list_price) AS average_sales FROM (SELECT ss_quantity AS quantity, ss_list_price AS list_price FROM store_sales JOIN date_dim ON ss_sold_date_sk = d_date_sk WHERE d_year BETWEEN 1999 AND 1999 + 2 AND ss_wholesale_cost BETWEEN 76 AND 96 UNION ALL SELECT cs_quantity AS quantity, cs_list_price AS list_price FROM catalog_sales JOIN date_dim ON cs_sold_date_sk = d_date_sk WHERE d_year BETWEEN 1999 AND 1999 + 2 AND cs_wholesale_cost BETWEEN 76 AND 96 UNION ALL SELECT ws_quantity AS quantity, ws_list_price AS list_price FROM web_sales JOIN date_dim ON ws_sold_date_sk = d_date_sk WHERE ws_wholesale_cost BETWEEN 76 AND 96 AND d_year BETWEEN 1999 AND 1999 + 2) AS x",
        "interfaces": {"outputs": ["average_sales"], "consumes": []}
      },
      "store_sales_aggregated": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_year, i_brand_id, i_class_id, i_category_id, SUM(ss_quantity * ss_list_price) AS sales, COUNT(*) AS number_sales FROM store_sales JOIN filtered_items ON ss_item_sk = i_item_sk JOIN date_dim ON ss_sold_date_sk = d_date_sk CROSS JOIN week_seq WHERE ss_item_sk IN (SELECT ss_item_sk FROM cross_items) AND d_week_seq IN (week_seq_1999, week_seq_2000) AND i_category IN ('Electronics', 'Shoes', 'Sports') AND i_manager_id BETWEEN 42 AND 51 AND ss_wholesale_cost BETWEEN 76 AND 96 GROUP BY d_year, i_brand_id, i_class_id, i_category_id HAVING SUM(ss_quantity * ss_list_price) > (SELECT average_sales FROM avg_sales)",
        "interfaces": {"outputs": ["d_year", "i_brand_id", "i_class_id", "i_category_id", "sales", "number_sales"], "consumes": ["week_seq", "filtered_items", "cross_items", "avg_sales"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT 'store' AS ty_channel, ty.i_brand_id AS ty_brand, ty.i_class_id AS ty_class, ty.i_category_id AS ty_category, ty.sales AS ty_sales, ty.number_sales AS ty_number_sales, 'store' AS ly_channel, ly.i_brand_id AS ly_brand, ly.i_class_id AS ly_class, ly.i_category_id AS ly_category, ly.sales AS ly_sales, ly.number_sales AS ly_number_sales FROM (SELECT * FROM store_sales_aggregated WHERE d_year = 2000) ty JOIN (SELECT * FROM store_sales_aggregated WHERE d_year = 1999) ly ON ty.i_brand_id = ly.i_brand_id AND ty.i_class_id = ly.i_class_id AND ty.i_category_id = ly.i_category_id ORDER BY ty_channel, ty_brand, ty_class, ty_category LIMIT 100",
        "interfaces": {"outputs": ["ty_channel", "ty_brand", "ty_class", "ty_category", "ty_sales", "ty_number_sales", "ly_channel", "ly_brand", "ly_class", "ly_category", "ly_sales", "ly_number_sales"], "consumes": ["store_sales_aggregated"]}
      }
    },
    "reconstruction_order": ["week_seq", "filtered_items", "cross_items", "avg_sales", "store_sales_aggregated", "main_query"],
    "assembly_template": "WITH week_seq AS ({week_seq}), filtered_items AS ({filtered_items}), cross_items AS ({cross_items}), avg_sales AS ({avg_sales}), store_sales_aggregated AS ({store_sales_aggregated}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL enable_nestloop = off", "SET LOCAL work_mem = '256MB'", "SET LOCAL hash_mem_multiplier = 2.0"],
  "validation_checks": []
}
```

Changes: Replaced expensive INTERSECT with channel-counting aggregation, converted comma joins to explicit JOINs, and combined 1999/2000 week aggregations into a single pass.
Expected speedup: ≥2.0x due to reduced intermediate result sizes and more efficient join planning.