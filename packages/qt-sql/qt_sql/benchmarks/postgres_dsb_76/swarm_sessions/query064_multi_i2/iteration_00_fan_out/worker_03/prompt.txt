You are a SQL rewrite engine for PostgreSQL v16.11-0ubuntu0.24.04.1). Follow the Target Logical Tree structure below. Your job is to write correct, executable SQL for each node — not to decide whether to restructure. Preserve exact semantic equivalence (same rows, same columns, same ordering). Preserve defensive guards: if the original uses CASE WHEN x > 0 THEN y/x END around a division, keep it — even when a WHERE clause makes the zero case unreachable. Guards prevent silent breakage if filters change upstream. Strip benchmark comments (-- start query, -- end query) from your output.

## Semantic Contract (MUST preserve)

Compare year-over-year sales performance (2000 vs 2001) for products sold through stores with specific promotional channels (email, TV, radio) to customers with certain demographics (single, advanced/4yr degree) in selected states, filtering items by wholesale and current price ranges. All joins are INNER (intersection) requiring matches on all sides. Aggregates are COUNT(*) and SUMs only, which are grouping-insensitive to duplicates. Critical filter dependencies: cd1.cd_marital_status <> cd2.cd_marital_status must be preserved after any pre-filtering or restructuring.

## Target Logical Tree + Node Contracts

Build your rewrite following this CTE structure. Each node's OUTPUT list is exhaustive — your SQL must produce exactly those columns.

TARGET_LOGICAL_TREE:
pref_all_dims -> filtered_cs_ui -> fact_probe -> cross_sales_agg -> main_self_join
NODE_CONTRACTS:
  pref_all_dims:
    FROM: promotion p, customer_address ad2, customer_demographics cd1, customer_demographics cd2, date_dim d1, date_dim d2, date_dim d3, store, customer, household_demographics hd1, household_demographics hd2, income_band ib1, income_band ib2, item, customer_address ad1
    WHERE: 
      p.p_channel_email = 'Y' AND p.p_channel_tv = 'Y' AND p.p_channel_radio = 'Y'
      AND ad2.ca_state IN ('KS','OH','VA')
      AND cd1.cd_marital_status IN ('S','S','S') AND cd1.cd_education_status IN ('Advanced Degree','4 yr Degree','4 yr Degree')
      AND cd2.cd_marital_status IN ('S','S','S') AND cd2.cd_education_status IN ('Advanced Degree','4 yr Degree','4 yr Degree')
      AND i_current_price BETWEEN 77 AND 87
    JOIN: (minimal joins needed to connect dimensions: e.g., hd1.hd_income_band_sk = ib1.ib_income_band_sk, hd2.hd_income_band_sk = ib2.ib_income_band_sk)
    OUTPUT: p_promo_sk, ad2.ca_address_sk, cd1.cd_demo_sk, cd2.cd_demo_sk, d1.d_date_sk, d2.d_date_sk, d3.d_date_sk, s_store_sk, c_customer_sk, hd1.hd_demo_sk, hd2.hd_demo_sk, i_item_sk, ad1.ca_address_sk, d1.d_year, d2.d_year, d3.d_year, s_store_name, s_zip, ad1.ca_street_number, ad1.ca_street_name, ad1.ca_city, ad1.ca_zip, ad2.ca_street_number, ad2.ca_street_name, ad2.ca_city, ad2.ca_zip, i_product_name
    EXPECTED_ROWS: Very small (highly selective intersection)
    CONSUMERS: fact_probe
  filtered_cs_ui: (same as Worker 1)
  fact_probe:
    FROM: store_sales
      JOIN store_returns ON ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number
      JOIN filtered_cs_ui ON ss_item_sk = filtered_cs_ui.cs_item_sk
      JOIN pref_all_dims ON 
        ss_promo_sk = p_promo_sk AND
        ss_sold_date_sk = d1.d_date_sk AND
        ss_store_sk = s_store_sk AND
        ss_customer_sk = c_customer_sk AND
        ss_cdemo_sk = cd1.cd_demo_sk AND
        ss_hdemo_sk = hd1.hd_demo_sk AND
        ss_addr_sk = ad1.ca_address_sk AND
        ss_item_sk = i_item_sk AND
        c_current_cdemo_sk = cd2.cd_demo_sk AND
        c_current_hdemo_sk = hd2.hd_demo_sk AND
        c_current_addr_sk = ad2.ca_address_sk AND
        c_first_sales_date_sk = d2.d_date_sk AND
        c_first_shipto_date_sk = d3.d_date_sk
    WHERE: ss_wholesale_cost BETWEEN 76 AND 96 AND cd1.cd_marital_status <> cd2.cd_marital_status
    OUTPUT: (same as Worker 1 fact_join output)
    EXPECTED_ROWS: ~1,211
    CONSUMERS: cross_sales_agg
  cross_sales_agg: (same as Worker 1)

NODE_CONTRACTS:
pref_all_dims:
    FROM: promotion p, customer_address ad2, customer_demographics cd1, customer_demographics cd2, date_dim d1, date_dim d2, date_dim d3, store, customer, household_demographics hd1, household_demographics hd2, income_band ib1, income_band ib2, item, customer_address ad1
    WHERE: 
      p.p_channel_email = 'Y' AND p.p_channel_tv = 'Y' AND p.p_channel_radio = 'Y'
      AND ad2.ca_state IN ('KS','OH','VA')
      AND cd1.cd_marital_status IN ('S','S','S') AND cd1.cd_education_status IN ('Advanced Degree','4 yr Degree','4 yr Degree')
      AND cd2.cd_marital_status IN ('S','S','S') AND cd2.cd_education_status IN ('Advanced Degree','4 yr Degree','4 yr Degree')
      AND i_current_price BETWEEN 77 AND 87
    JOIN: (minimal joins needed to connect dimensions: e.g., hd1.hd_income_band_sk = ib1.ib_income_band_sk, hd2.hd_income_band_sk = ib2.ib_income_band_sk)
    OUTPUT: p_promo_sk, ad2.ca_address_sk, cd1.cd_demo_sk, cd2.cd_demo_sk, d1.d_date_sk, d2.d_date_sk, d3.d_date_sk, s_store_sk, c_customer_sk, hd1.hd_demo_sk, hd2.hd_demo_sk, i_item_sk, ad1.ca_address_sk, d1.d_year, d2.d_year, d3.d_year, s_store_name, s_zip, ad1.ca_street_number, ad1.ca_street_name, ad1.ca_city, ad1.ca_zip, ad2.ca_street_number, ad2.ca_street_name, ad2.ca_city, ad2.ca_zip, i_product_name
    EXPECTED_ROWS: Very small (highly selective intersection)
    CONSUMERS: fact_probe
  filtered_cs_ui: (same as Worker 1)
  fact_probe:
    FROM: store_sales
      JOIN store_returns ON ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number
      JOIN filtered_cs_ui ON ss_item_sk = filtered_cs_ui.cs_item_sk
      JOIN pref_all_dims ON 
        ss_promo_sk = p_promo_sk AND
        ss_sold_date_sk = d1.d_date_sk AND
        ss_store_sk = s_store_sk AND
        ss_customer_sk = c_customer_sk AND
        ss_cdemo_sk = cd1.cd_demo_sk AND
        ss_hdemo_sk = hd1.hd_demo_sk AND
        ss_addr_sk = ad1.ca_address_sk AND
        ss_item_sk = i_item_sk AND
        c_current_cdemo_sk = cd2.cd_demo_sk AND
        c_current_hdemo_sk = hd2.hd_demo_sk AND
        c_current_addr_sk = ad2.ca_address_sk AND
        c_first_sales_date_sk = d2.d_date_sk AND
        c_first_shipto_date_sk = d3.d_date_sk
    WHERE: ss_wholesale_cost BETWEEN 76 AND 96 AND cd1.cd_marital_status <> cd2.cd_marital_status
    OUTPUT: (same as Worker 1 fact_join output)
    EXPECTED_ROWS: ~1,211
    CONSUMERS: cross_sales_agg
  cross_sales_agg: (same as Worker 1)

## Hazard Flags (avoid these specific risks)

- Large dimension CTE may become expensive to materialize if joins aren't selective
- Must maintain all join conditions between dimensions in pref_all_dims CTE
- Risk of Cartesian product if dimension joins are not properly constrained

## Regression Warnings (observed failures on similar queries)

None applicable.

## Constraints (analyst-filtered for this query)

- COMPLETE_OUTPUT: Must preserve all 22 output columns exactly as named in original SELECT
- CTE_COLUMN_COMPLETENESS: cross_sales CTE must include all columns referenced by main query self-join (item_sk, store_name, store_zip, syear, cnt, s1, s2, s3)
- LITERAL_PRESERVATION: Must preserve exact literal values: cs_wholesale_cost BETWEEN 76 AND 96, i_current_price between 77 and 77 + 10, p_channel_* = 'Y', ad2.ca_state in ('KS','OH','VA'), cd*_marital_status in ('S','S','S'), cd*_education_status in ('Advanced Degree', '4 yr Degree', '4 yr Degree'), cs1.syear = 2000, cs2.syear = 2000 + 1
- SEMANTIC_EQUIVALENCE: Must return same rows and ordering (ORDER BY cs1.product_name, cs1.store_name, cs2.cnt, cs1.s1, cs2.s1)
- COMMA_JOIN_WEAKNESS: cross_sales uses comma-separated implicit joins (lines 31-48), confirmed by EXPLAIN showing optimizer reorders joins
- CROSS_CTE_PREDICATE_BLINDNESS: Year filters (cs1.syear=2000, cs2.syear=2001) applied AFTER cross_sales CTE materialization, missing pushdown opportunity

## Example Adaptation Notes

For each example: what to apply to your rewrite, and what to ignore.

- pg_materialized_dimension_fact_prefilter: Apply pre-filtering of ALL dimension tables into a single CTE; ignore the fact table pre-filtering (cs_ui already does that)
- star_join_prefetch: Apply star-join pattern with dimension prefetching; ensure all dimension keys are included in CTE output
- dimension_cte_isolate: Apply dimension isolation into CTE; combine multiple dimensions into single CTE for efficiency

## Reference Examples

Pattern reference only — do not copy table/column names or literals.

### 1. pg_materialized_dimension_fact_prefilter (2.68x)

**Principle:** Staged Reduction for Non-Equi Joins: when queries have expensive non-equi joins, reduce BOTH dimension and fact table sizes via MATERIALIZED CTEs before the join. Combined selectivity dramatically cuts the search space for inequality predicates.

**BEFORE (slow):**
```sql
select  i_item_desc
      ,w_warehouse_name
      ,d1.d_week_seq
      ,sum(case when p_promo_sk is null then 1 else 0 end) no_promo
      ,sum(case when p_promo_sk is not null then 1 else 0 end) promo
      ,count(*) total_cnt
from catalog_sales
join inventory on (cs_item_sk = inv_item_sk)
join warehouse on (w_warehouse_sk=inv_warehouse_sk)
join item on (i_item_sk = cs_item_sk)
join customer_demographics on (cs_bill_cdemo_sk = cd_demo_sk)
join household_demographics on (cs_bill_hdemo_sk = hd_demo_sk)
join date_dim d1 on (cs_sold_date_sk = d1.d_date_sk)
join date_dim d2 on (inv_date_sk = d2.d_date_sk)
join date_dim d3 on (cs_ship_date_sk = d3.d_date_sk)
left outer join promotion on (cs_promo_sk=p_promo_sk)
left outer join catalog_returns on (cr_item_sk = cs_item_sk and cr_order_number = cs_order_number)
where d1.d_week_seq = d2.d_week_seq
  and inv_quantity_on_hand < cs_quantity
  and d3.d_date > d1.d_date + interval '3 day'
  and hd_buy_potential = '501-1000'
  and d1.d_year = 1998
  and cd_marital_status = 'M'
  and cd_dep_count between 9 and 11
  and i_category IN ('Home', 'Men', 'Music')
  and cs_wholesale_cost BETWEEN 34 AND 54
group by i_item_desc,w_warehouse_name,d1.d_week_seq
order by total_cnt desc, i_item_desc, w_warehouse_name, d_week_seq
limit 100;
```

**AFTER (fast):**
[filtered_date]:
```sql
SELECT d_date_sk, d_date, d_week_seq FROM date_dim WHERE d_year = 1998
```
[filtered_item]:
```sql
SELECT i_item_sk, i_item_desc FROM item WHERE i_category IN ('Home', 'Men', 'Music')
```
[filtered_cd]:
```sql
SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'M' AND cd_dep_count BETWEEN 9 AND 11
```
[filtered_hd]:
```sql
SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '501-1000'
```
[cs_filtered]:
```sql
SELECT cs_item_sk, cs_bill_cdemo_sk, cs_bill_hdemo_sk, cs_sold_date_sk, cs_ship_date_sk, cs_promo_sk, cs_quantity, cs_wholesale_cost, cs_order_number FROM catalog_sales WHERE cs_wholesale_cost BETWEEN 34 AND 54
```
[main_query]:
```sql
SELECT i.i_item_desc, w.w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p.p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN p.p_promo_sk IS NOT NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM cs_filtered cs JOIN inventory inv ON cs.cs_item_sk = inv.inv_item_sk JOIN warehouse w ON w.w_warehouse_sk = inv.inv_warehouse_sk JOIN filtered_item i ON i.i_item_sk = cs.cs_item_sk JOIN filtered_cd cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk JOIN filtered_hd hd ON cs.cs_bill_hdemo_sk = hd.hd_demo_sk JOIN filtered_date d1 ON cs.cs_sold_date_sk = d1.d_date_sk JOIN date_dim d2 ON inv.inv_date_sk = d2.d_date_sk JOIN date_dim d3 ON cs.cs_ship_date_sk = d3.d_date_sk LEFT OUTER JOIN promotion p ON cs.cs_promo_sk = p.p_promo_sk LEFT OUTER JOIN catalog_returns cr ON cr.cr_item_sk = cs.cs_item_sk AND cr.cr_order_number = cs.cs_order_number WHERE d1.d_week_seq = d2.d_week_seq AND inv.inv_quantity_on_hand < cs.cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 day' GROUP BY i.i_item_desc, w.w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i.i_item_desc, w.w_warehouse_name, d1.d_week_seq LIMIT 100
```

## Original SQL

```sql
with cs_ui as
 (select cs_item_sk
        ,sum(cs_ext_list_price) as sale,sum(cr_refunded_cash+cr_reversed_charge+cr_store_credit) as refund
  from catalog_sales
      ,catalog_returns
  where cs_item_sk = cr_item_sk
    and cs_order_number = cr_order_number
    and cs_wholesale_cost BETWEEN 76 AND 96
   group by cs_item_sk
  having sum(cs_ext_list_price)>2*sum(cr_refunded_cash+cr_reversed_charge+cr_store_credit)),
cross_sales as
 (select i_product_name product_name
     ,i_item_sk item_sk
     ,s_store_name store_name
     ,s_zip store_zip
     ,ad1.ca_street_number b_street_number
     ,ad1.ca_street_name b_street_name
     ,ad1.ca_city b_city
     ,ad1.ca_zip b_zip
     ,ad2.ca_street_number c_street_number
     ,ad2.ca_street_name c_street_name
     ,ad2.ca_city c_city
     ,ad2.ca_zip c_zip
     ,d1.d_year as syear
     ,d2.d_year as fsyear
     ,d3.d_year s2year
     ,count(*) cnt
     ,sum(ss_wholesale_cost) s1
     ,sum(ss_list_price) s2
     ,sum(ss_coupon_amt) s3
  FROM   store_sales
        ,store_returns
        ,cs_ui
        ,date_dim d1
        ,date_dim d2
        ,date_dim d3
        ,store
        ,customer
        ,customer_demographics cd1
        ,customer_demographics cd2
        ,promotion
        ,household_demographics hd1
        ,household_demographics hd2
        ,customer_address ad1
        ,customer_address ad2
        ,income_band ib1
        ,income_band ib2
        ,item
  WHERE  ss_store_sk = s_store_sk AND
         ss_sold_date_sk = d1.d_date_sk AND
         ss_customer_sk = c_customer_sk AND
         ss_cdemo_sk= cd1.cd_demo_sk AND
         ss_hdemo_sk = hd1.hd_demo_sk AND
         ss_addr_sk = ad1.ca_address_sk and
         ss_item_sk = i_item_sk and
         ss_item_sk = sr_item_sk and
         ss_ticket_number = sr_ticket_number and
         ss_item_sk = cs_ui.cs_item_sk and
         c_current_cdemo_sk = cd2.cd_demo_sk AND
         c_current_hdemo_sk = hd2.hd_demo_sk AND
         c_current_addr_sk = ad2.ca_address_sk and
         c_first_sales_date_sk = d2.d_date_sk and
         c_first_shipto_date_sk = d3.d_date_sk and
         ss_promo_sk = p_promo_sk and
         hd1.hd_income_band_sk = ib1.ib_income_band_sk and
         hd2.hd_income_band_sk = ib2.ib_income_band_sk and
         cd1.cd_marital_status <> cd2.cd_marital_status and
         i_current_price between 77 and 77 + 10
         and p_channel_email = 'Y'
         and p_channel_tv = 'Y'
         and p_channel_radio = 'Y'
         and ad2.ca_state in ('KS','OH','VA')
         and ss_wholesale_cost BETWEEN 76 AND 96
         and cd1.cd_marital_status in ('S', 'S', 'S')
         and cd1.cd_education_status in ('Advanced Degree', '4 yr Degree', '4 yr Degree')
         and cd2.cd_marital_status in ('S', 'S', 'S')
         and cd2.cd_education_status in ('Advanced Degree', '4 yr Degree', '4 yr Degree')
group by i_product_name
       ,i_item_sk
       ,s_store_name
       ,s_zip
       ,ad1.ca_street_number
       ,ad1.ca_street_name
       ,ad1.ca_city
       ,ad1.ca_zip
       ,ad2.ca_street_number
       ,ad2.ca_street_name
       ,ad2.ca_city
       ,ad2.ca_zip
       ,d1.d_year
       ,d2.d_year
       ,d3.d_year
)
select cs1.product_name
     ,cs1.store_name
     ,cs1.store_zip
     ,cs1.b_street_number
     ,cs1.b_street_name
     ,cs1.b_city
     ,cs1.b_zip
     ,cs1.c_street_number
     ,cs1.c_street_name
     ,cs1.c_city
     ,cs1.c_zip
     ,cs1.syear
     ,cs1.cnt
     ,cs1.s1 as s11
     ,cs1.s2 as s21
     ,cs1.s3 as s31
     ,cs2.s1 as s12
     ,cs2.s2 as s22
     ,cs2.s3 as s32
     ,cs2.syear
     ,cs2.cnt
from cross_sales cs1,cross_sales cs2
where cs1.item_sk=cs2.item_sk and
     cs1.syear = 2000 and
     cs2.syear = 2000 + 1 and
     cs2.cnt <= cs1.cnt and
     cs1.store_name = cs2.store_name and
     cs1.store_zip = cs2.store_zip
order by cs1.product_name
       ,cs1.store_name
       ,cs2.cnt
       ,cs1.s1
       ,cs2.s1
;
```

## Rewrite Checklist (must pass before final SQL)

- Follow every node in `TARGET_LOGICAL_TREE` and produce each `NODE_CONTRACT` output column exactly.
- Keep all semantic invariants from `Semantic Contract` and `Constraints` (including join/null behavior).
- Preserve all literals and the exact final output schema/order.
- Apply `Hazard Flags` and `Regression Warnings` as hard guards against known failure modes.

## Original Query Structure

This is the current query structure. All nodes are `[=]` (unchanged). Your modified Logic Tree below should show which nodes you changed.

```
QUERY: (single statement)
├── [CTE] cs_ui  [=]  Cost: 29%  Rows: ~2.2M
│   ├── SCAN (catalog_sales, catalog_returns (join))
│   ├── JOIN (cs_item_sk = cr_item_sk)
│   ├── JOIN (cs_order_number = cr_order_number)
│   ├── FILTER (cs_wholesale_cost BETWEEN 76 AND 96)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (cs_item_sk, sale, refund)
├── [CTE] cross_sales  [=]  Cost: 27%  Rows: ~157K
│   ├── SCAN (store_sales, store_returns (join), cs_ui (join), date_dim AS d1 (join), date_dim AS d2 (join), date_dim AS d3 (join), store (join), customer (join), customer_demographics AS cd1 (join), customer_demographics AS cd2 (join), promotion (join), household_demographics AS hd1 (join), household_demographics AS hd2 (join), customer_address AS ad1 (join), customer_address AS ad2 (join), income_band AS ib1 (join), income_band AS ib2 (join), item (join))
│   ├── JOIN (ss_store_sk = s_store_sk)
│   ├── JOIN (ss_sold_date_sk = d1.d_date_sk)
│   ├── JOIN (+16 more)
│   ├── FILTER (cd1.cd_marital_status <> cd2.cd_marital_status)
│   ├── FILTER (i_current_price BETWEEN 77 AND 77 + 10)
│   ├── FILTER (+9 more)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (product_name, item_sk, store_name, store_zip, b_street_number, b_street_name, b_city, b_zip, ...)
└── [MAIN] main_query  [=]  Cost: 42%
    ├── SCAN (cross_sales AS cs1 (join), cross_sales AS cs2 (join))
    ├── JOIN (cs1.item_sk = cs2.item_sk)
    ├── JOIN (cs1.store_name = cs2.store_name)
    ├── JOIN (+1 more)
    ├── FILTER (cs1.syear = 2000)
    ├── FILTER (cs2.syear = 2000 + 1)
    ├── FILTER (+1 more)
    ├── AGG (GROUP BY)
    ├── SORT (cs1.product_name ASC, cs1.store_name ASC, cs2.cnt ASC, cs1.s1 ASC, cs2.s1 ASC)
    └── OUTPUT (product_name, store_name, store_zip, b_street_number, b_street_name, b_city, b_zip, c_street_number, ...)
```

## Output Format

Your response has **two parts** in order:

### Part 1: Modified Logic Tree

Show what changed using change markers. Generate the tree BEFORE writing SQL.

Change markers:
- `[+]` — New component added
- `[-]` — Component removed
- `[~]` — Component modified (describe what changed)
- `[=]` — Unchanged (no children needed)
- `[!]` — Structural change (e.g. CTE → subquery)

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "<dialect>",
  "rewrite_rules": [
    {"id": "R1", "type": "<transform_name>", "description": "<what changed>", "applied_to": ["<component_id>"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "<cte_name>": {
        "type": "cte",
        "change": "modified",
        "sql": "<complete SQL for this CTE body>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<upstream_id>"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "<final SELECT>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<cte_name>"]}
      }
    },
    "reconstruction_order": ["<cte_name>", "main_query"],
    "assembly_template": "WITH <cte_name> AS ({<cte_name>}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '512MB'"],
  "validation_checks": []
}
```

### Rules
- **Tree first, always.** Generate the Logic Tree before writing any SQL
- **One component at a time.** When writing SQL for component X, treat others as opaque interfaces
- **No ellipsis.** Every `sql` value must be complete, executable SQL
- **Frozen blocks are copy-paste.** Large CASE-WHEN lookups must be verbatim
- **Validate interfaces.** Verify every `consumes` reference exists in upstream `outputs`
- Only include components you **changed or added** — set unchanged components to `"change": "unchanged"` with `"sql": ""`
- `main_query` output columns must match the Column Completeness Contract above
- `runtime_config`: SET LOCAL commands for PostgreSQL. Omit or use empty array if not needed
- `reconstruction_order`: topological order of components for assembly

After the JSON, explain the mechanism:

```
Changes: <1-2 sentences: what structural change + the expected mechanism>
Expected speedup: <estimate>
```

Now output your Logic Tree and Component Payload JSON: