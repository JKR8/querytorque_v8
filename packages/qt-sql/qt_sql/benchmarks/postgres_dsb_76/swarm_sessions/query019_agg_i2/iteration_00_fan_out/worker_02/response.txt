## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~125K
    ├── [~] CTE: filtered_fact (replaces multi-table FROM)
    │   ├── SCAN store_sales
    │   ├── JOIN date_dim (INNER, d_date_sk = ss_sold_date_sk + filters)
    │   ├── JOIN item (INNER, ss_item_sk = i_item_sk + filter)
    │   └── JOIN customer (INNER, ss_customer_sk = c_customer_sk + filter)
    ├── [~] CTE: early_aggregation (GROUP BY with address/store keys)
    │   ├── FROM filtered_fact
    │   └── AGG (SUM(ss_ext_sales_price) AS ext_price)
    ├── [~] CTE: late_zip_join (delayed address/store joins)
    │   ├── FROM early_aggregation
    │   ├── JOIN customer_address (INNER, c_current_addr_sk = ca_address_sk + filter)
    │   ├── JOIN store (INNER, ss_store_sk = s_store_sk)
    │   └── FILTER (substring(ca_zip,1,5) <> substring(s_zip,1,5))
    ├── [=] AGG (GROUP BY i_brand, i_brand_id, i_manufact_id, i_manufact)
    ├── [=] SORT (ext_price DESC, i_brand ASC, i_brand_id ASC, i_manufact_id ASC, i_manufact ASC)
    └── [=] OUTPUT (brand_id, brand, i_manufact_id, i_manufact, ext_price)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "dimension_cte_isolate",
      "description": "Isolate fact+dimension filtering into CTE before aggregating and joining less selective dimensions",
      "applied_to": ["filtered_fact", "early_aggregation", "late_zip_join"]
    },
    {
      "id": "R2", 
      "type": "pg_self_join_decomposition",
      "description": "Aggregate before expensive non-equality join to reduce row count for zip comparison",
      "applied_to": ["early_aggregation", "late_zip_join"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_fact": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_ext_sales_price, i_brand_id, i_brand, i_manufact_id, i_manufact, c_current_addr_sk, ss_store_sk FROM store_sales INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_year = 1999 AND d_moy = 2 INNER JOIN item ON ss_item_sk = i_item_sk AND i_category = 'Shoes' INNER JOIN customer ON ss_customer_sk = c_customer_sk AND c_birth_month = 2 WHERE ss_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {
          "outputs": ["ss_ext_sales_price", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "c_current_addr_sk", "ss_store_sk"],
          "consumes": []
        }
      },
      "early_aggregation": {
        "type": "cte", 
        "change": "added",
        "sql": "SELECT i_brand_id, i_brand, i_manufact_id, i_manufact, c_current_addr_sk, ss_store_sk, SUM(ss_ext_sales_price) AS ext_price FROM filtered_fact GROUP BY i_brand_id, i_brand, i_manufact_id, i_manufact, c_current_addr_sk, ss_store_sk",
        "interfaces": {
          "outputs": ["i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "c_current_addr_sk", "ss_store_sk", "ext_price"],
          "consumes": ["filtered_fact"]
        }
      },
      "late_zip_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT agg.i_brand_id, agg.i_brand, agg.i_manufact_id, agg.i_manufact, agg.ext_price FROM early_aggregation agg INNER JOIN customer_address ON agg.c_current_addr_sk = ca_address_sk AND ca_state = 'KS' INNER JOIN store ON agg.ss_store_sk = s_store_sk WHERE substring(ca_zip,1,5) <> substring(s_zip,1,5)",
        "interfaces": {
          "outputs": ["i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "ext_price"],
          "consumes": ["early_aggregation"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, i_manufact_id, i_manufact, SUM(ext_price) AS ext_price FROM late_zip_join GROUP BY i_brand, i_brand_id, i_manufact_id, i_manufact ORDER BY ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact LIMIT 100",
        "interfaces": {
          "outputs": ["brand_id", "brand", "i_manufact_id", "i_manufact", "ext_price"],
          "consumes": ["late_zip_join"]
        }
      }
    },
    "reconstruction_order": ["filtered_fact", "early_aggregation", "late_zip_join", "main_query"],
    "assembly_template": "WITH filtered_fact AS ({filtered_fact}), early_aggregation AS ({early_aggregation}), late_zip_join AS ({late_zip_join}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '64MB'",
    "SET LOCAL max_parallel_workers_per_gather = 2",
    "SET LOCAL from_collapse_limit = 1",
    "SET LOCAL join_collapse_limit = 1"
  ],
  "validation_checks": []
}
```

**Changes**: Restructured original multi-table FROM into a CTE pipeline that filters fact and high-selectivity dimensions early, aggregates before the expensive zip comparison, and delays low-selectivity dimension joins until after aggregation. This reduces the row count before the substring inequality comparison.

**Expected speedup**: ~1.3-2x due to reduced rows processed through the non-equality zip filter and better join ordering predictability. The CTE structure prevents planner from reordering joins incorrectly while allowing parallel aggregation on smaller intermediate results. The runtime config prevents planner from flattening CTEs and preserves the intended join order.