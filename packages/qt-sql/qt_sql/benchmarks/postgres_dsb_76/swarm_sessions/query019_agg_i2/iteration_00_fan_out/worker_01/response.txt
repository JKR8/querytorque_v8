## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ≤100
    ├── WITH CTE block  [+]
    │   ├── filtered_date (CTE)  [+]
    │   │   └── SCAN date_dim (filter: d_year=1999 AND d_moy=2)
    │   ├── filtered_item (CTE)  [+]
    │   │   └── SCAN item (filter: i_category='Shoes')
    │   ├── filtered_customer (CTE)  [+]
    │   │   └── SCAN customer (filter: c_birth_month=2)
    │   ├── filtered_store (CTE)  [+]
    │   │   └── SCAN store
    │   ├── filtered_address (CTE)  [+]
    │   │   └── SCAN customer_address (filter: ca_state='KS')
    │   └── fact_prejoin (CTE)  [+]
    │       ├── JOIN store_sales → filtered_date (ss_sold_date_sk = d_date_sk)
    │       ├── JOIN → filtered_item (ss_item_sk = i_item_sk)
    │       ├── JOIN → filtered_customer (ss_customer_sk = c_customer_sk)
    │       ├── JOIN → filtered_store (ss_store_sk = s_store_sk)
    │       ├── JOIN → filtered_address (c_current_addr_sk = ca_address_sk)
    │       ├── FILTER (ss_wholesale_cost BETWEEN 76 AND 96)
    │       └── FILTER (substring(ca_zip,1,5) <> substring(s_zip,1,5))
    ├── AGG (GROUP BY i_brand, i_brand_id, i_manufact_id, i_manufact)
    ├── SORT (ext_price DESC, i_brand ASC, i_brand_id ASC, i_manufact_id ASC, i_manufact ASC)
    └── OUTPUT (brand_id, brand, i_manufact_id, i_manufact, ext_price)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "multi_dimension_prefetch",
      "description": "Extracted all dimension filters into separate CTEs to create small hash tables before main join",
      "applied_to": ["filtered_date", "filtered_item", "filtered_customer", "filtered_store", "filtered_address"]
    },
    {
      "id": "R2",
      "type": "explicit_join_syntax",
      "description": "Converted comma-separated implicit joins to explicit INNER JOIN syntax",
      "applied_to": ["fact_prejoin"]
    },
    {
      "id": "R3",
      "type": "non_equi_join_early_filter",
      "description": "Moved zip substring inequality into fact_prejoin WHERE clause after all dimension joins",
      "applied_to": ["fact_prejoin"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy = 2",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk, i_brand_id, i_brand, i_manufact_id, i_manufact FROM item WHERE i_category = 'Shoes'",
        "interfaces": {"outputs": ["i_item_sk", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact"], "consumes": []}
      },
      "filtered_customer": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c_customer_sk, c_current_addr_sk FROM customer WHERE c_birth_month = 2",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": []}
      },
      "filtered_store": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk, s_zip FROM store",
        "interfaces": {"outputs": ["s_store_sk", "s_zip"], "consumes": []}
      },
      "filtered_address": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ca_address_sk, ca_zip FROM customer_address WHERE ca_state = 'KS'",
        "interfaces": {"outputs": ["ca_address_sk", "ca_zip"], "consumes": []}
      },
      "fact_prejoin": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i.i_brand_id, i.i_brand, i.i_manufact_id, i.i_manufact, ss.ss_ext_sales_price FROM store_sales ss INNER JOIN filtered_date d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN filtered_item i ON ss.ss_item_sk = i.i_item_sk INNER JOIN filtered_customer c ON ss.ss_customer_sk = c.c_customer_sk INNER JOIN filtered_store s ON ss.ss_store_sk = s.s_store_sk INNER JOIN filtered_address a ON c.c_current_addr_sk = a.ca_address_sk WHERE ss.ss_wholesale_cost BETWEEN 76 AND 96 AND substring(a.ca_zip,1,5) <> substring(s.s_zip,1,5)",
        "interfaces": {"outputs": ["i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "ss_ext_sales_price"], "consumes": ["filtered_date", "filtered_item", "filtered_customer", "filtered_store", "filtered_address"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, i_manufact_id, i_manufact, SUM(ss_ext_sales_price) AS ext_price FROM fact_prejoin GROUP BY i_brand, i_brand_id, i_manufact_id, i_manufact ORDER BY ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact LIMIT 100",
        "interfaces": {"outputs": ["brand_id", "brand", "i_manufact_id", "i_manufact", "ext_price"], "consumes": ["fact_prejoin"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_item", "filtered_customer", "filtered_store", "filtered_address", "fact_prejoin", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_item AS ({filtered_item}), filtered_customer AS ({filtered_customer}), filtered_store AS ({filtered_store}), filtered_address AS ({filtered_address}), fact_prejoin AS ({fact_prejoin}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL join_collapse_limit = 1",
    "SET LOCAL from_collapse_limit = 1",
    "SET LOCAL work_mem = '16MB'",
    "SET LOCAL enable_seqscan = off",
    "SET LOCAL enable_nestloop = off"
  ],
  "validation_checks": []
}
```

**Changes**: Restructured query into CTEs that pre-filter each dimension table, then join in a controlled order via explicit JOIN syntax. This isolates selective filters early and provides the optimizer with accurate cardinality estimates for each small dimension set.

**Expected speedup**: 3.2x (based on pg_dimension_prefetch_star pattern, with additional benefit from join order control)