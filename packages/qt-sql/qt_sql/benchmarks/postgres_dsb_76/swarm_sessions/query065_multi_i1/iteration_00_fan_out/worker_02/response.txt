## Modified Logic Tree

```
QUERY: (single statement)
├── [MAIN] main_query  [~]  Cost: 100%  Rows: ~437K
│   ├── [+] store_cte
│   │   ├── SCAN store
│   │   └── FILTER (s_state IN ('IA','IL','NC'))
│   ├── [+] item_cte
│   │   ├── SCAN item
│   │   └── FILTER (i_manager_id BETWEEN 80 AND 84)
│   ├── [+] date_cte
│   │   ├── SCAN date_dim
│   │   └── FILTER (d_month_seq BETWEEN 1195 AND 1206)
│   ├── [+] sales_agg
│   │   ├── SCAN store_sales
│   │   ├── JOIN date_cte (ss_sold_date_sk = d_date_sk)
│   │   ├── FILTER (ss_sales_price/ss_list_price BETWEEN 0.38 AND 0.48)
│   │   ├── GROUP BY ss_store_sk, ss_item_sk
│   │   └── AGG (SUM(ss_sales_price) AS revenue)
│   ├── [+] store_avg
│   │   ├── SCAN sales_agg
│   │   ├── GROUP BY ss_store_sk
│   │   └── AGG (AVG(revenue) AS ave)
│   ├── JOIN sales_agg g JOIN store_avg a ON g.ss_store_sk = a.ss_store_sk
│   ├── JOIN store_cte s ON s.s_store_sk = g.ss_store_sk
│   ├── JOIN item_cte i ON i.i_item_sk = g.ss_item_sk
│   ├── FILTER (g.revenue <= 0.1 * a.ave)
│   ├── SORT (s_store_name ASC, i_item_desc ASC)
│   └── OUTPUT (s_store_name, i_item_desc, revenue, i_current_price, i_wholesale_cost, i_brand)
└── [=] LIMIT 100
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefetch", "description": "Isolate store, item, and date filters into CTEs for better hash join planning", "applied_to": ["store_cte", "item_cte", "date_cte"]},
    {"id": "R2", "type": "explicit_join_conversion", "description": "Convert comma-separated implicit joins to explicit INNER JOIN syntax", "applied_to": ["sales_agg", "final_join"]},
    {"id": "R3", "type": "cte_materialization", "description": "Materialize sales_agg once and reuse for store_avg and final_join, eliminating duplicate computation", "applied_to": ["sales_agg", "store_avg", "final_join"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "store_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk, s_store_name FROM store WHERE s_state IN ('IA','IL','NC')",
        "interfaces": {"outputs": ["s_store_sk", "s_store_name"], "consumes": []}
      },
      "item_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk, i_item_desc, i_current_price, i_wholesale_cost, i_brand FROM item WHERE i_manager_id BETWEEN 80 AND 84",
        "interfaces": {"outputs": ["i_item_sk", "i_item_desc", "i_current_price", "i_wholesale_cost", "i_brand"], "consumes": []}
      },
      "date_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1195 AND 1195+11",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "sales_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_store_sk, ss_item_sk, SUM(ss_sales_price) AS revenue FROM store_sales INNER JOIN date_cte ON ss_sold_date_sk = d_date_sk WHERE CASE WHEN ss_list_price > 0 THEN ss_sales_price/ss_list_price END BETWEEN 0.38 AND 0.48 GROUP BY ss_store_sk, ss_item_sk",
        "interfaces": {"outputs": ["ss_store_sk", "ss_item_sk", "revenue"], "consumes": ["date_cte"]}
      },
      "store_avg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_store_sk, AVG(revenue) AS ave FROM sales_agg GROUP BY ss_store_sk",
        "interfaces": {"outputs": ["ss_store_sk", "ave"], "consumes": ["sales_agg"]}
      },
      "final_join": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT s.s_store_name, i.i_item_desc, g.revenue, i.i_current_price, i.i_wholesale_cost, i.i_brand FROM sales_agg g INNER JOIN store_avg a ON g.ss_store_sk = a.ss_store_sk INNER JOIN store_cte s ON s.s_store_sk = g.ss_store_sk INNER JOIN item_cte i ON i.i_item_sk = g.ss_item_sk WHERE g.revenue <= 0.1 * a.ave ORDER BY s.s_store_name, i.i_item_desc LIMIT 100",
        "interfaces": {"outputs": ["s_store_name", "i_item_desc", "revenue", "i_current_price", "i_wholesale_cost", "i_brand"], "consumes": ["sales_agg", "store_avg", "store_cte", "item_cte"]}
      }
    },
    "reconstruction_order": ["store_cte", "item_cte", "date_cte", "sales_agg", "store_avg", "final_join"],
    "assembly_template": "WITH store_cte AS ({store_cte}), item_cte AS ({item_cte}), date_cte AS ({date_cte}), sales_agg AS ({sales_agg}), store_avg AS ({store_avg}) {final_join}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL enable_hashjoin = on", "SET LOCAL enable_mergejoin = off", "SET LOCAL work_mem = '32MB'", "SET LOCAL hash_mem_multiplier = 2.0"],
  "validation_checks": []
}
```

**Changes**: Restructured query using multi-dimension prefetch CTEs (store, item, date) and explicit JOIN syntax to enable PostgreSQL's optimizer to build better hash join plans with tiny dimension tables. Preserved semantic equivalence by computing store averages over all items in the period before applying store/item filters.

**Expected speedup**: ~2-3x based on similar patterns. The CTE structure allows PostgreSQL to materialize small filtered dimension tables first, then perform efficient hash joins. Disabling mergejoin favors hash joins for these selective dimension lookups.