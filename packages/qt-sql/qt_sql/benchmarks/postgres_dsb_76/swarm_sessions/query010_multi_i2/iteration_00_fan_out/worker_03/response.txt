## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 99%  Rows: ≤100
    ├── [~] STRUCTURE: Converted to explicit CTE-based flow per Target Logical Tree
    ├── CTE: customer_base  [+]
    │   ├── SCAN (customer AS c) + INNER JOIN (customer_address AS ca, customer_demographics AS cd)
    │   ├── FILTER (ca.ca_county IN (...), c.c_birth_month IN (4,5), ...)
    │   └── OUTPUT (c_customer_sk + 8 demographic columns)
    ├── CTE: store_exists  [+]
    │   ├── SCAN (store_sales AS ss) + INNER JOIN (date_dim AS d, item AS i)
    │   ├── FILTER (d.d_year=1999, d.d_moy BETWEEN 5-8, i.i_category IN (...), ss.ss_sales_price/ss.ss_list_price BETWEEN 0.65-0.75)
    │   ├── SEMI-JOIN: EXISTS (customer_base cb ON cb.c_customer_sk = ss.ss_customer_sk)
    │   └── OUTPUT (ss.ss_customer_sk)
    ├── CTE: web_exists  [+]
    │   ├── SCAN (web_sales AS ws) + INNER JOIN (date_dim AS d, item AS i)
    │   ├── FILTER (d.d_year=1999, d.d_moy BETWEEN 5-8, i.i_category IN (...), ws.ws_sales_price/ws.ws_list_price BETWEEN 0.65-0.75)
    │   └── OUTPUT (ws.ws_bill_customer_sk)
    ├── CTE: catalog_exists  [+]
    │   ├── SCAN (catalog_sales AS cs) + INNER JOIN (date_dim AS d, item AS i)
    │   ├── FILTER (d.d_year=1999, d.d_moy BETWEEN 5-8, i.i_category IN (...), cs.cs_sales_price/cs.cs_list_price BETWEEN 0.65-0.75)
    │   └── OUTPUT (cs.cs_ship_customer_sk)
    ├── SCAN (customer_base AS cb)
    ├── FILTER (EXISTS store_exists OR EXISTS web_exists OR EXISTS catalog_exists)  [~]  
    ├── AGG (GROUP BY 8 demographic columns)
    ├── AGGREGATE (COUNT(*) x6)
    ├── SORT (8-column ORDER BY)
    └── OUTPUT (14 columns exactly as original)
```

**Change markers:**
- `[+]` — Added all CTEs per Target Logical Tree
- `[~]` — Modified main query structure to use CTEs and preserve EXISTS semi-joins

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "explicit_join_conversion",
      "description": "Convert comma-separated joins to explicit INNER JOIN syntax in customer_base CTE",
      "applied_to": ["customer_base"]
    },
    {
      "id": "R2", 
      "type": "cte_logical_decomposition",
      "description": "Decompose query into logical CTEs per Target Logical Tree: customer_base, store_exists, web_exists, catalog_exists, final_aggregation",
      "applied_to": ["main_query"]
    },
    {
      "id": "R3",
      "type": "preserve_exists_semijoins",
      "description": "Maintain EXISTS semi-join structure instead of converting to IN, preventing materialization of full subquery results",
      "applied_to": ["store_exists", "web_exists", "catalog_exists", "main_query"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "customer_base": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c.c_customer_sk, cd.cd_gender, cd.cd_marital_status, cd.cd_education_status, cd.cd_purchase_estimate, cd.cd_credit_rating, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM customer c INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk INNER JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk WHERE ca.ca_county IN ('Alameda County', 'Lexington city', 'Pender County', 'Petroleum County', 'Walworth County') AND c.c_birth_month IN (4, 5) AND cd.cd_marital_status IN ('U', 'S', 'U') AND cd.cd_education_status IN ('College', 'Secondary', 'College') AND cd.cd_gender = 'M'",
        "interfaces": {
          "outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"],
          "consumes": []
        }
      },
      "store_exists": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT ss.ss_customer_sk FROM store_sales ss INNER JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN item i ON ss.ss_item_sk = i.i_item_sk WHERE d.d_year = 1999 AND d.d_moy BETWEEN 5 AND 8 AND i.i_category IN ('Children', 'Home', 'Women') AND i.i_manager_id BETWEEN 91 AND 100 AND ss.ss_sales_price / ss.ss_list_price BETWEEN 0.65 AND 0.75 AND EXISTS (SELECT 1 FROM customer_base cb WHERE cb.c_customer_sk = ss.ss_customer_sk)",
        "interfaces": {
          "outputs": ["ss_customer_sk"],
          "consumes": ["customer_base"]
        }
      },
      "web_exists": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT ws.ws_bill_customer_sk FROM web_sales ws INNER JOIN date_dim d ON ws.ws_sold_date_sk = d.d_date_sk INNER JOIN item i ON ws.ws_item_sk = i.i_item_sk WHERE d.d_year = 1999 AND d.d_moy BETWEEN 5 AND 8 AND i.i_category IN ('Children', 'Home', 'Women') AND i.i_manager_id BETWEEN 91 AND 100 AND ws.ws_sales_price / ws.ws_list_price BETWEEN 0.65 AND 0.75",
        "interfaces": {
          "outputs": ["ws_bill_customer_sk"],
          "consumes": []
        }
      },
      "catalog_exists": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs.cs_ship_customer_sk FROM catalog_sales cs INNER JOIN date_dim d ON cs.cs_sold_date_sk = d.d_date_sk INNER JOIN item i ON cs.cs_item_sk = i.i_item_sk WHERE d.d_year = 1999 AND d.d_moy BETWEEN 5 AND 8 AND i.i_category IN ('Children', 'Home', 'Women') AND i.i_manager_id BETWEEN 91 AND 100 AND cs.cs_sales_price / cs.cs_list_price BETWEEN 0.65 AND 0.75",
        "interfaces": {
          "outputs": ["cs_ship_customer_sk"],
          "consumes": []
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3, cd_dep_count, COUNT(*) AS cnt4, cd_dep_employed_count, COUNT(*) AS cnt5, cd_dep_college_count, COUNT(*) AS cnt6 FROM customer_base cb WHERE EXISTS (SELECT 1 FROM store_exists se WHERE se.ss_customer_sk = cb.c_customer_sk) OR EXISTS (SELECT 1 FROM web_exists we WHERE we.ws_bill_customer_sk = cb.c_customer_sk) OR EXISTS (SELECT 1 FROM catalog_exists ce WHERE ce.cs_ship_customer_sk = cb.c_customer_sk) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating, cd_dep_count, cd_dep_employed_count, cd_dep_college_count ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100",
        "interfaces": {
          "outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3", "cd_dep_count", "cnt4", "cd_dep_employed_count", "cnt5", "cd_dep_college_count", "cnt6"],
          "consumes": ["customer_base", "store_exists", "web_exists", "catalog_exists"]
        }
      }
    },
    "reconstruction_order": ["customer_base", "store_exists", "web_exists", "catalog_exists", "main_query"],
    "assembly_template": "WITH customer_base AS ({customer_base}), store_exists AS ({store_exists}), web_exists AS ({web_exists}), catalog_exists AS ({catalog_exists}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '16MB'", "SET LOCAL enable_hashjoin = on", "SET LOCAL enable_nestloop = off", "SET LOCAL enable_mergejoin = off", "SET LOCAL max_parallel_workers_per_gather = 2"],
  "validation_checks": []
}
```

**Changes:** Restructured query into logical CTEs per Target Logical Tree while preserving EXISTS semi-joins and explicit INNER JOIN syntax. The rewrite maintains exact semantic equivalence with defensive division guards and all literal values.

**Expected speedup:** ~2x from better join planning and explicit CTE structure that allows optimizer to create optimal hash join plans with small dimension tables (customer_base). The CTEs are not materialized (default PostgreSQL behavior), preserving parallelism.

**Runtime config rationale:**
- `work_mem = '16MB'`: Supports hash aggregates for grouping 8 demographic columns on ≤100 rows
- `enable_hashjoin = on`: Essential for hash joins between small customer_base and fact tables
- `enable_nestloop = off`: Prevents expensive nested loops on large fact tables
- `enable_mergejoin = off`: Hash joins preferred for this selective filter pattern
- `max_parallel_workers_per_gather = 2`: Allows parallel scans on large fact tables while staying within 8-worker system limit