## Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_item [~] NEW: pre‑filtered item dimension
├── [CTE] filtered_date [~] NEW: pre‑filtered date dimension for Jan 1998
├── [CTE] filtered_customer [~] NEW: pre‑filtered customer dimension
├── [CTE] union_facts [~] NEW: UNION ALL of catalog/web sales with wholesale cost filter
├── [CTE] my_customers [~] MODIFIED: now joins filtered CTEs with explicit JOIN syntax
├── [CTE] my_revenue [~] MODIFIED: uses filtered_date CTE for d_month_seq subqueries and explicit JOINs
├── [CTE] segments [=] unchanged
└── [MAIN] main_query [=] unchanged
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefetch", "description": "Pre‑filter all selective dimensions (item, date_dim, customer) into CTEs before joining with facts", "applied_to": ["filtered_item", "filtered_date", "filtered_customer"]},
    {"id": "R2", "type": "explicit_join_conversion", "description": "Replace comma‑separated joins in my_customers and my_revenue with explicit JOIN syntax", "applied_to": ["my_customers", "my_revenue"]},
    {"id": "R3", "type": "union_fact_extraction", "description": "Extract UNION ALL of catalog_sales/web_sales with wholesale_cost filter into separate CTE", "applied_to": ["union_facts"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_category, i_class FROM item WHERE i_category = 'Electronics' AND i_class = 'personal'",
        "interfaces": {"outputs": ["i_item_sk", "i_category", "i_class"], "consumes": []}
      },
      "filtered_date": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_year, d_moy FROM date_dim WHERE d_year = 1998 AND d_moy = 1",
        "interfaces": {"outputs": ["d_date_sk", "d_year", "d_moy"], "consumes": []}
      },
      "filtered_customer": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_customer_sk, c_current_addr_sk, c_birth_year FROM customer WHERE c_birth_year BETWEEN 1928 AND 1941",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk", "c_birth_year"], "consumes": []}
      },
      "union_facts": {
        "type": "cte",
        "change": "modified",
        "sql": "(SELECT cs_sold_date_sk AS sold_date_sk, cs_bill_customer_sk AS customer_sk, cs_item_sk AS item_sk FROM catalog_sales WHERE cs_wholesale_cost BETWEEN 35 AND 65 UNION ALL SELECT ws_sold_date_sk AS sold_date_sk, ws_bill_customer_sk AS customer_sk, ws_item_sk AS item_sk FROM web_sales WHERE ws_wholesale_cost BETWEEN 35 AND 65)",
        "interfaces": {"outputs": ["sold_date_sk", "customer_sk", "item_sk"], "consumes": []}
      },
      "my_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT filtered_customer.c_customer_sk, filtered_customer.c_current_addr_sk FROM filtered_date INNER JOIN union_facts ON union_facts.sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_item ON union_facts.item_sk = filtered_item.i_item_sk INNER JOIN filtered_customer ON union_facts.customer_sk = filtered_customer.c_customer_sk",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": ["filtered_date", "union_facts", "filtered_item", "filtered_customer"]}
      },
      "my_revenue": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT my_customers.c_customer_sk, SUM(ss_ext_sales_price) AS revenue FROM my_customers INNER JOIN store_sales ON my_customers.c_customer_sk = store_sales.ss_customer_sk INNER JOIN customer_address ON my_customers.c_current_addr_sk = customer_address.ca_address_sk INNER JOIN store ON (customer_address.ca_county = store.s_county AND customer_address.ca_state = store.s_state) INNER JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk WHERE store_sales.ss_wholesale_cost BETWEEN 35 AND 65 AND store.s_state IN ('AR','CO','IA','IL','KY','NC','NM','NY','PA','TX') AND date_dim.d_month_seq BETWEEN (SELECT DISTINCT d_month_seq+1 FROM filtered_date) AND (SELECT DISTINCT d_month_seq+3 FROM filtered_date) GROUP BY my_customers.c_customer_sk",
        "interfaces": {"outputs": ["c_customer_sk", "revenue"], "consumes": ["my_customers"]}
      },
      "segments": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["segment"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT segment, COUNT(*) AS num_customers, segment*50 AS segment_base FROM segments GROUP BY segment ORDER BY segment, num_customers LIMIT 100",
        "interfaces": {"outputs": ["segment", "num_customers", "segment_base"], "consumes": ["segments"]}
      }
    },
    "reconstruction_order": ["filtered_item", "filtered_date", "filtered_customer", "union_facts", "my_customers", "my_revenue", "segments", "main_query"],
    "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_date AS ({filtered_date}), filtered_customer AS ({filtered_customer}), union_facts AS ({union_facts}), my_customers AS ({my_customers}), my_revenue AS ({my_revenue}), segments AS (SELECT CAST((revenue/50) AS INTEGER) AS segment FROM my_revenue) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '32MB'", "SET LOCAL hash_mem_multiplier = 2.0", "SET LOCAL max_parallel_workers_per_gather = 2"],
  "validation_checks": []
}
```

**Changes**: Pre‑filtered all three dimension tables (item, date_dim, customer) into CTEs before joining with fact tables, extracted the UNION ALL of catalog/web sales into a separate CTE, and converted all comma‑separated joins to explicit INNER JOIN syntax. The expected mechanism is that PostgreSQL's optimizer can now build hash tables from the small dimension CTEs (1,454, 10, and ~403 rows) and perform efficient hash joins with the fact tables.

**Expected speedup**: 2-3x due to better cardinality estimates, elimination of repeated dimension table scans, and explicit join ordering enabling hash join optimization.