## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_dimensions  [+]  New CTE replacing the combined dimension filter
│   ├── CROSS JOIN (item × date_filter × customer_filter)
│   ├── FILTER (i_category = 'Electronics', i_class = 'personal')
│   └── OUTPUT (i_item_sk, d_date_sk, c_customer_sk, c_current_addr_sk)
├── [CTE] catalog_facts        [+]  New CTE for catalog sales branch
│   ├── INNER JOIN (filtered_dimensions → catalog_sales)
│   ├── FILTER (cs_wholesale_cost BETWEEN 35 AND 65)
│   └── OUTPUT (c_customer_sk, c_current_addr_sk)
├── [CTE] web_facts            [+]  New CTE for web sales branch
│   ├── INNER JOIN (filtered_dimensions → web_sales)
│   ├── FILTER (ws_wholesale_cost BETWEEN 35 AND 65)
│   └── OUTPUT (c_customer_sk, c_current_addr_sk)
├── [CTE] union_all            [+]  New CTE unifying both channels
│   ├── UNION ALL (catalog_facts, web_facts)
│   └── OUTPUT (c_customer_sk, c_current_addr_sk)
├── [CTE] my_customers         [~]  Modified: now selects DISTINCT from union_all
│   ├── SCAN (union_all)
│   └── OUTPUT (c_customer_sk, c_current_addr_sk)
├── [CTE] my_revenue           [=]  Unchanged
├── [CTE] segments             [=]  Unchanged
└── [MAIN] main_query          [=]  Unchanged
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "shared_dimension_materialization", "description": "Materialize filtered dimension keys once for both fact table branches", "applied_to": ["filtered_dimensions"]},
    {"id": "R2", "type": "channel_split", "description": "Split UNION ALL into separate CTEs that share the dimension lookup", "applied_to": ["catalog_facts", "web_facts", "union_all"]},
    {"id": "R3", "type": "cte_decomposition", "description": "Replace original my_customers complex join with scan of pre-filtered union", "applied_to": ["my_customers"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dimensions": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i.i_item_sk, df.d_date_sk, cf.c_customer_sk, cf.c_current_addr_sk FROM item i CROSS JOIN (SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 1) df CROSS JOIN (SELECT c_customer_sk, c_current_addr_sk FROM customer WHERE c_birth_year BETWEEN 1928 AND 1941) cf WHERE i.i_category = 'Electronics' AND i.i_class = 'personal'",
        "interfaces": {"outputs": ["i_item_sk", "d_date_sk", "c_customer_sk", "c_current_addr_sk"], "consumes": []}
      },
      "catalog_facts": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT fd.c_customer_sk, fd.c_current_addr_sk FROM filtered_dimensions fd INNER JOIN catalog_sales cs ON fd.i_item_sk = cs.cs_item_sk AND fd.d_date_sk = cs.cs_sold_date_sk AND fd.c_customer_sk = cs.cs_bill_customer_sk WHERE cs.cs_wholesale_cost BETWEEN 35 AND 65",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": ["filtered_dimensions"]}
      },
      "web_facts": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT fd.c_customer_sk, fd.c_current_addr_sk FROM filtered_dimensions fd INNER JOIN web_sales ws ON fd.i_item_sk = ws.ws_item_sk AND fd.d_date_sk = ws.ws_sold_date_sk AND fd.c_customer_sk = ws.ws_bill_customer_sk WHERE ws.ws_wholesale_cost BETWEEN 35 AND 65",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": ["filtered_dimensions"]}
      },
      "union_all": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c_customer_sk, c_current_addr_sk FROM catalog_facts UNION ALL SELECT c_customer_sk, c_current_addr_sk FROM web_facts",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": ["catalog_facts", "web_facts"]}
      },
      "my_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT c_customer_sk, c_current_addr_sk FROM union_all",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": ["union_all"]}
      },
      "my_revenue": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["c_customer_sk", "revenue"], "consumes": ["my_customers"]}
      },
      "segments": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["segment"], "consumes": ["my_revenue"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["segment", "num_customers", "segment_base"], "consumes": ["segments"]}
      }
    },
    "reconstruction_order": ["filtered_dimensions", "catalog_facts", "web_facts", "union_all", "my_customers", "my_revenue", "segments", "main_query"],
    "assembly_template": "WITH filtered_dimensions AS ({filtered_dimensions}), catalog_facts AS ({catalog_facts}), web_facts AS ({web_facts}), union_all AS ({union_all}), my_customers AS ({my_customers}), my_revenue AS ({my_revenue}), segments AS ({segments}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '32MB'",
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL enable_seqscan = off"
  ],
  "validation_checks": []
}
```

**Changes:** Materialized dimension lookups into a shared CTE, split UNION ALL into separate channel CTEs, and simplified my_customers to scan the pre-filtered union. This prevents redundant scans of item, date_dim, and customer.

**Expected speedup:** 2-3x from eliminating redundant dimension table scans and allowing better join order optimization. The filtered_dimensions CTE (5.9M rows) will be materialized once, avoiding repeated computation. Runtime config disables nested loops and seqscan to encourage indexed joins on the large intermediate result.