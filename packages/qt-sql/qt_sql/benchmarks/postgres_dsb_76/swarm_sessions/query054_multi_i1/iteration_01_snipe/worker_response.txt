## Modified Logic Tree

```
[~] main_query
    [~] WITH my_customers
        [-] Original comma-join pattern
        [+] Explicit JOIN syntax with pre-filtered dimensions
        [+] Strategic CTE materialization for reuse
    [~] WITH my_revenue  
        [-] Comma-join pattern and correlated subqueries
        [+] Explicit JOIN syntax
        [+] Pre-computed date_range CTE
    [=] WITH segments (unchanged)
    [=] Final aggregation (unchanged)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "comma_join_to_explicit", "description": "Convert all comma-joins to explicit JOIN syntax for better PostgreSQL optimization", "applied_to": ["my_customers", "my_revenue"]},
    {"id": "R2", "type": "date_cte_isolate", "description": "Pre-compute date range values to avoid correlated subqueries", "applied_to": ["date_range"]},
    {"id": "R3", "type": "dimension_prefilter", "description": "Filter selective dimensions (item, date_dim, customer) before joining with large fact tables", "applied_to": ["filtered_item", "filtered_date", "filtered_customer"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_item": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk FROM item WHERE i_category = 'Electronics' AND i_class = 'personal'",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 1",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_customer": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_customer_sk, c_current_addr_sk FROM customer WHERE c_birth_year BETWEEN 1928 AND 1941",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": []}
      },
      "cs_or_ws_sales": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cs_sold_date_sk AS sold_date_sk, cs_bill_customer_sk AS customer_sk, cs_item_sk AS item_sk FROM catalog_sales WHERE cs_wholesale_cost BETWEEN 35 AND 65 UNION ALL SELECT ws_sold_date_sk AS sold_date_sk, ws_bill_customer_sk AS customer_sk, ws_item_sk AS item_sk FROM web_sales WHERE ws_wholesale_cost BETWEEN 35 AND 65",
        "interfaces": {"outputs": ["sold_date_sk", "customer_sk", "item_sk"], "consumes": []}
      },
      "my_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT fc.c_customer_sk, fc.c_current_addr_sk FROM cs_or_ws_sales sales JOIN filtered_date fd ON sales.sold_date_sk = fd.d_date_sk JOIN filtered_item fi ON sales.item_sk = fi.i_item_sk JOIN filtered_customer fc ON sales.customer_sk = fc.c_customer_sk",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": ["cs_or_ws_sales", "filtered_date", "filtered_item", "filtered_customer"]}
      },
      "date_range": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_month_seq + 1 AS month_start, d_month_seq + 3 AS month_end FROM date_dim WHERE d_year = 1998 AND d_moy = 1 LIMIT 1",
        "interfaces": {"outputs": ["month_start", "month_end"], "consumes": []}
      },
      "my_revenue": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT mc.c_customer_sk, SUM(ss_ext_sales_price) AS revenue FROM my_customers mc JOIN store_sales ss ON mc.c_customer_sk = ss.ss_customer_sk JOIN customer_address ca ON mc.c_current_addr_sk = ca.ca_address_sk JOIN store s ON ca.ca_county = s.s_county AND ca.ca_state = s.s_state JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk WHERE ss.ss_wholesale_cost BETWEEN 35 AND 65 AND s.s_state IN ('AR','CO','IA','IL','KY','NC','NM','NY','PA','TX') AND d.d_month_seq BETWEEN (SELECT month_start FROM date_range) AND (SELECT month_end FROM date_range) GROUP BY mc.c_customer_sk",
        "interfaces": {"outputs": ["c_customer_sk", "revenue"], "consumes": ["my_customers", "date_range"]}
      },
      "segments": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["segment"], "consumes": ["my_revenue"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT segment, COUNT(*) AS num_customers, segment * 50 AS segment_base FROM segments GROUP BY segment ORDER BY segment, num_customers LIMIT 100",
        "interfaces": {"outputs": ["segment", "num_customers", "segment_base"], "consumes": ["segments"]}
      }
    },
    "reconstruction_order": ["filtered_item", "filtered_date", "filtered_customer", "cs_or_ws_sales", "my_customers", "date_range", "my_revenue", "segments", "main_query"],
    "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_date AS ({filtered_date}), filtered_customer AS ({filtered_customer}), cs_or_ws_sales AS ({cs_or_ws_sales}), my_customers AS ({my_customers}), date_range AS ({date_range}), my_revenue AS ({my_revenue}), segments AS ({segments}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL enable_seqscan = off", "SET LOCAL max_parallel_workers_per_gather = 2", "SET LOCAL work_mem = '32MB'"],
  "validation_checks": []
}
```

**Changes**: Converted all comma-joins to explicit JOIN syntax (PostgreSQL weakness), pre-filtered selective dimensions into CTEs, and pre-computed date range to avoid correlated subqueries. This enables better join reordering and eliminates PostgreSQL's comma-join cost model penalty.

**Expected speedup**: 2.2x - 2.5x. The original query already runs in 116ms with efficient parallel execution. The main bottleneck was PostgreSQL's weaker optimization of comma-joins. By converting to explicit JOINs, we allow the optimizer to reorder joins more effectively and use better join algorithms. The pre-filtered dimension CTEs provide small hash tables for efficient hash joins, and the date_range CTE eliminates repeated correlated subquery execution.