### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_dim_cte  [+]
│   └── OUTPUT (d_date_sk)
├── [CTE] item_cte  [+]
│   └── OUTPUT (i_item_sk)
├── [CTE] customer_cte  [+]
│   └── OUTPUT (c_customer_sk, c_current_addr_sk)
├── [CTE] sales_customers  [+]
│   ├── UNION ALL (catalog_sales + date_dim_cte + item_cte + customer_cte, web_sales + same)
│   └── OUTPUT (customer_sk)
├── [CTE] my_customers  [~] (rebuilt from sales_customers with DISTINCT + scalar subquery)
│   ├── SCAN (sales_customers)
│   └── OUTPUT (c_customer_sk, c_current_addr_sk)
├── [CTE] my_revenue  [~] (converted comma joins to explicit INNER JOIN syntax)
│   ├── JOIN my_customers → customer_address (c_current_addr_sk = ca_address_sk)
│   ├── JOIN customer_address → store (ca_county = s_county AND ca_state = s_state)
│   ├── JOIN my_customers → store_sales (c_customer_sk = ss_customer_sk)
│   ├── JOIN store_sales → date_dim (ss_sold_date_sk = d_date_sk)
│   └── OUTPUT (c_customer_sk, revenue)
├── [CTE] segments  [=]
│   └── OUTPUT (segment)
└── [MAIN] main_query  [=]
    └── OUTPUT (segment, num_customers, segment_base)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "prefilter_dimensions", "description": "Extract selective dimension filters into separate CTEs", "applied_to": ["date_dim_cte", "item_cte", "customer_cte"]},
    {"id": "R2", "type": "shared_dimension_union", "description": "Use pre-filtered dimension CTEs in both UNION ALL branches", "applied_to": ["sales_customers"]},
    {"id": "R3", "type": "correlated_subquery", "description": "Replace implicit join with scalar subquery for address lookup", "applied_to": ["my_customers"]},
    {"id": "R4", "type": "explicit_joins", "description": "Convert comma-separated implicit joins to explicit INNER JOIN syntax", "applied_to": ["my_revenue"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_dim_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 5",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "item_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk FROM item WHERE i_category = 'Home' AND i_class = 'curtains/drapes'",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "customer_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_customer_sk, c_current_addr_sk FROM customer WHERE c_birth_year BETWEEN 1942 AND 1955",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": []}
      },
      "sales_customers": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cs_bill_customer_sk AS customer_sk FROM catalog_sales INNER JOIN date_dim_cte ON cs_sold_date_sk = d_date_sk INNER JOIN item_cte ON cs_item_sk = i_item_sk INNER JOIN customer_cte ON cs_bill_customer_sk = c_customer_sk WHERE cs_wholesale_cost BETWEEN 70 AND 100 UNION ALL SELECT ws_bill_customer_sk AS customer_sk FROM web_sales INNER JOIN date_dim_cte ON ws_sold_date_sk = d_date_sk INNER JOIN item_cte ON ws_item_sk = i_item_sk INNER JOIN customer_cte ON ws_bill_customer_sk = c_customer_sk WHERE ws_wholesale_cost BETWEEN 70 AND 100",
        "interfaces": {"outputs": ["customer_sk"], "consumes": ["date_dim_cte", "item_cte", "customer_cte"]}
      },
      "my_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT customer_sk AS c_customer_sk, (SELECT c_current_addr_sk FROM customer_cte WHERE c_customer_sk = sales_customers.customer_sk) AS c_current_addr_sk FROM sales_customers",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": ["sales_customers", "customer_cte"]}
      },
      "my_revenue": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_customer_sk, SUM(ss_ext_sales_price) AS revenue FROM my_customers INNER JOIN store_sales ON c_customer_sk = ss_customer_sk INNER JOIN customer_address ON c_current_addr_sk = ca_address_sk INNER JOIN store ON ca_county = s_county AND ca_state = s_state INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk WHERE ss_wholesale_cost BETWEEN 70 AND 100 AND s_state IN ('AR','GA','IN','KS','KY','NC','OH','PA','SD','VA') AND d_month_seq BETWEEN (SELECT DISTINCT d_month_seq+1 FROM date_dim WHERE d_year = 1998 AND d_moy = 5) AND (SELECT DISTINCT d_month_seq+3 FROM date_dim WHERE d_year = 1998 AND d_moy = 5) GROUP BY c_customer_sk",
        "interfaces": {"outputs": ["c_customer_sk", "revenue"], "consumes": ["my_customers"]}
      },
      "segments": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": [], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": [], "consumes": []}
      }
    },
    "reconstruction_order": ["date_dim_cte", "item_cte", "customer_cte", "sales_customers", "my_customers", "my_revenue", "segments", "main_query"],
    "assembly_template": "WITH date_dim_cte AS ({date_dim_cte}), item_cte AS ({item_cte}), customer_cte AS ({customer_cte}), sales_customers AS ({sales_customers}), my_customers AS ({my_customers}), my_revenue AS ({my_revenue}), segments AS (SELECT CAST((revenue/50) AS INT) AS segment FROM my_revenue) SELECT segment, COUNT(*) AS num_customers, segment*50 AS segment_base FROM segments GROUP BY segment ORDER BY segment, num_customers LIMIT 100"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Restructured to pre-filter dimensions into separate CTEs before joining with fact tables in the UNION, eliminating repetitive filtering. Converted implicit comma joins to explicit INNER JOIN syntax in my_revenue for optimizer clarity.

**Expected speedup:** 2-3x through dimension prefetching (small hash tables) and better join cardinality estimates. The scalar subquery for address lookup in my_customers is acceptable because customer_cte is small (~many rows but filtered) and PostgreSQL can index it via c_customer_sk.