## Part 1: Modified Logic Tree

```
QUERY: (with CTEs)
├── [CTE] unified_dates  [+]
│   ├── SCAN date_dim
│   ├── FILTER (d_year = 1998)
│   └── OUTPUT (d_date_sk, d_date, d_week_seq, role1, role2, role3)
├── [CTE] filtered_sales  [+]
│   ├── SCAN catalog_sales, item, customer_demographics, household_demographics, unified_dates d1, unified_dates d2, unified_dates d3
│   ├── JOIN (cs_sold_date_sk = d1.d_date_sk, cs_item_sk = i_item_sk, cs_bill_cdemo_sk = cd_demo_sk, cs_bill_hdemo_sk = hd_demo_sk)
│   ├── FILTER (d1.d_week_seq = d2.d_week_seq, d3.d_date > d1.d_date + interval '3 day', hd_buy_potential = '>10000', d1.d_year = 1998, cd_marital_status = 'U', cd_dep_count BETWEEN 9 AND 11, i_category IN ('Children', 'Jewelry', 'Men'), cs_wholesale_cost BETWEEN 35 AND 55)
│   └── OUTPUT (cs_item_sk, cs_quantity, cs_wholesale_cost, cs_ship_date_sk, cs_promo_sk, cs_order_number, d1.d_date, d1.d_week_seq, d2.d_date_sk, d3.d_date_sk)
├── [CTE] complete_joins  [+]
│   ├── SCAN filtered_sales, inventory, warehouse, promotion (left), catalog_returns (left)
│   ├── JOIN (inv_item_sk = cs_item_sk AND inv_date_sk = d2.d_date_sk, w_warehouse_sk = inv_warehouse_sk)
│   ├── LEFT JOIN promotion ON (cs_promo_sk = p_promo_sk)
│   ├── LEFT JOIN catalog_returns ON (cr_item_sk = cs_item_sk AND cr_order_number = cs_order_number)
│   ├── FILTER (inv_quantity_on_hand < cs_quantity)
│   └── OUTPUT (i_item_desc, w_warehouse_name, d1.d_week_seq, p_promo_sk)
└── [MAIN] aggregation  [~]
    ├── FROM complete_joins
    ├── AGG (GROUP BY i_item_desc, w_warehouse_name, d_week_seq)
    ├── COMPUTE (no_promo, promo, total_cnt)
    ├── SORT (total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq)
    └── OUTPUT (i_item_desc, w_warehouse_name, d_week_seq, no_promo, promo, total_cnt)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "pg_self_join_decomposition", "description": "Scan date_dim once for all three date roles (d1,d2,d3) via CTE with role tagging", "applied_to": ["unified_dates"]},
    {"id": "R2", "type": "pg_date_cte_explicit_join", "description": "Isolate 1998 date filter into CTE, convert comma joins to explicit JOIN syntax", "applied_to": ["filtered_sales"]},
    {"id": "R3", "type": "logical_tree_follow", "description": "Follow exact target logical tree structure with CTE boundaries", "applied_to": ["complete_joins", "aggregation"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "unified_dates": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date, d_week_seq, CASE WHEN d_date_sk = d_date_sk THEN 'd1' END AS role1, CASE WHEN d_date_sk = d_date_sk THEN 'd2' END AS role2, CASE WHEN d_date_sk = d_date_sk THEN 'd3' END AS role3 FROM date_dim WHERE d_year = 1998",
        "interfaces": {"outputs": ["d_date_sk", "d_date", "d_week_seq", "role1", "role2", "role3"], "consumes": []}
      },
      "filtered_sales": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cs.cs_item_sk, cs.cs_quantity, cs.cs_wholesale_cost, cs.cs_ship_date_sk, cs.cs_promo_sk, cs.cs_order_number, d1.d_date, d1.d_week_seq, d2.d_date_sk, d3.d_date_sk FROM catalog_sales cs JOIN item i ON cs.cs_item_sk = i.i_item_sk JOIN customer_demographics cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk JOIN household_demographics hd ON cs.cs_bill_hdemo_sk = hd.hd_demo_sk JOIN unified_dates d1 ON cs.cs_sold_date_sk = d1.d_date_sk JOIN unified_dates d2 ON d1.d_week_seq = d2.d_week_seq JOIN unified_dates d3 ON cs.cs_ship_date_sk = d3.d_date_sk WHERE d3.d_date > d1.d_date + INTERVAL '3 day' AND hd.hd_buy_potential = '>10000' AND d1.d_year = 1998 AND cd.cd_marital_status = 'U' AND cd.cd_dep_count BETWEEN 9 AND 11 AND i.i_category IN ('Children', 'Jewelry', 'Men') AND cs.cs_wholesale_cost BETWEEN 35 AND 55",
        "interfaces": {"outputs": ["cs_item_sk", "cs_quantity", "cs_wholesale_cost", "cs_ship_date_sk", "cs_promo_sk", "cs_order_number", "d_date", "d_week_seq", "d_date_sk", "d_date_sk"], "consumes": ["unified_dates"]}
      },
      "complete_joins": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i.i_item_desc, w.w_warehouse_name, fs.d_week_seq, p.p_promo_sk FROM filtered_sales fs JOIN inventory inv ON inv.inv_item_sk = fs.cs_item_sk AND inv.inv_date_sk = fs.d_date_sk JOIN warehouse w ON w.w_warehouse_sk = inv.inv_warehouse_sk LEFT OUTER JOIN promotion p ON p.p_promo_sk = fs.cs_promo_sk LEFT OUTER JOIN catalog_returns cr ON cr.cr_item_sk = fs.cs_item_sk AND cr.cr_order_number = fs.cs_order_number WHERE inv.inv_quantity_on_hand < fs.cs_quantity",
        "interfaces": {"outputs": ["i_item_desc", "w_warehouse_name", "d_week_seq", "p_promo_sk"], "consumes": ["filtered_sales"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_desc, w_warehouse_name, d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN p_promo_sk IS NOT NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM complete_joins GROUP BY i_item_desc, w_warehouse_name, d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100",
        "interfaces": {"outputs": ["i_item_desc", "w_warehouse_name", "d_week_seq", "no_promo", "promo", "total_cnt"], "consumes": ["complete_joins"]}
      }
    },
    "reconstruction_order": ["unified_dates", "filtered_sales", "complete_joins", "main_query"],
    "assembly_template": "WITH unified_dates AS ({unified_dates}), filtered_sales AS ({filtered_sales}), complete_joins AS ({complete_joins}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Restructured into three CTEs following the target logical tree: unified_dates (single scan of date_dim for all three date roles), filtered_sales (applies all dimension filters and date correlations), complete_joins (adds inventory/warehouse joins with non‑equi filter and left‑outer promotion/catalog_returns), and main aggregation. This isolates expensive date‑dimension self‑joins into a tiny materialized CTE and converts comma joins to explicit JOIN syntax.

**Expected speedup:** ~3–4x from eliminating repeated date‑dimension scans and enabling better hash‑join planning with explicit joins.