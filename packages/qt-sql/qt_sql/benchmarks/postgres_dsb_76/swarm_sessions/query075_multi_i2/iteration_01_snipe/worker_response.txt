## Logic Tree Changes

```
[+] filtered_item: CTE with item columns for category='Children'
[+] filtered_date: CTE with date_dim for years 1998,1999
[~] all_sales_details: CTE that unions all three channel CTEs with INNER joins to returns (instead of LEFT)
[+] aggregated_sales: CTE that aggregates by item attributes and computes conditional sums for 1998 and 1999
[~] main_query: SELECT with hardcoded years and computed differences, no self-join
[-] Original UNION changed to UNION ALL
[-] Removed self-join on all_sales CTE
```

## Component Payload

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "union_to_union_all",
      "description": "Changed UNION to UNION ALL since channels are disjoint, avoiding duplicate elimination cost",
      "applied_to": ["all_sales_details"]
    },
    {
      "id": "R2",
      "type": "left_to_inner_join",
      "description": "Changed LEFT JOIN to INNER JOIN on returns tables because WHERE clause filters on returns.reason_sk, making it effectively INNER",
      "applied_to": ["all_sales_details"]
    },
    {
      "id": "R3",
      "type": "conditional_aggregation_self_join_elimination",
      "description": "Replaced self-join on aggregated data with conditional aggregation to get both years in one pass",
      "applied_to": ["aggregated_sales", "main_query"]
    },
    {
      "id": "R4",
      "type": "dimension_prefilter_cte",
      "description": "Created CTEs for filtered item and date_dim to reduce join sizes early",
      "applied_to": ["filtered_item", "filtered_date"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_item": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT i_item_sk, i_brand_id, i_class_id, i_category_id, i_manufact_id FROM item WHERE i_category = 'Children'",
          "interfaces": {
            "outputs": ["i_item_sk", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id"],
            "consumes": []
          }
        },
        "filtered_date": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year IN (1998, 1999)",
          "interfaces": {
            "outputs": ["d_date_sk", "d_year"],
            "consumes": []
          }
        },
        "all_sales_details": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id, sales_cnt, sales_amt FROM (SELECT d.d_year, i.i_brand_id, i.i_class_id, i.i_category_id, i.i_manufact_id, cs.cs_quantity - COALESCE(cr.cr_return_quantity, 0) AS sales_cnt, cs.cs_ext_sales_price - COALESCE(cr.cr_return_amount, 0.0) AS sales_amt FROM catalog_sales cs JOIN filtered_item i ON cs.cs_item_sk = i.i_item_sk JOIN filtered_date d ON cs.cs_sold_date_sk = d.d_date_sk JOIN catalog_returns cr ON cs.cs_order_number = cr.cr_order_number AND cs.cs_item_sk = cr.cr_item_sk WHERE cs.cs_sales_price / cs.cs_list_price BETWEEN 69 * 0.01 AND 89 * 0.01 AND cr.cr_reason_sk IN (8, 18, 20, 23, 41) UNION ALL SELECT d.d_year, i.i_brand_id, i.i_class_id, i.i_category_id, i.i_manufact_id, ss.ss_quantity - COALESCE(sr.sr_return_quantity, 0) AS sales_cnt, ss.ss_ext_sales_price - COALESCE(sr.sr_return_amt, 0.0) AS sales_amt FROM store_sales ss JOIN filtered_item i ON ss.ss_item_sk = i.i_item_sk JOIN filtered_date d ON ss.ss_sold_date_sk = d.d_date_sk JOIN store_returns sr ON ss.ss_ticket_number = sr.sr_ticket_number AND ss.ss_item_sk = sr.sr_item_sk WHERE ss.ss_sales_price / ss.ss_list_price BETWEEN 69 * 0.01 AND 89 * 0.01 AND sr.sr_reason_sk IN (8, 18, 20, 23, 41) UNION ALL SELECT d.d_year, i.i_brand_id, i.i_class_id, i.i_category_id, i.i_manufact_id, ws.ws_quantity - COALESCE(wr.wr_return_quantity, 0) AS sales_cnt, ws.ws_ext_sales_price - COALESCE(wr.wr_return_amt, 0.0) AS sales_amt FROM web_sales ws JOIN filtered_item i ON ws.ws_item_sk = i.i_item_sk JOIN filtered_date d ON ws.ws_sold_date_sk = d.d_date_sk JOIN web_returns wr ON ws.ws_order_number = wr.wr_order_number AND ws.ws_item_sk = wr.wr_item_sk WHERE ws.ws_sales_price / ws.ws_list_price BETWEEN 69 * 0.01 AND 89 * 0.01 AND wr.wr_reason_sk IN (8, 18, 20, 23, 41)) AS t",
          "interfaces": {
            "outputs": ["d_year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "sales_cnt", "sales_amt"],
            "consumes": ["filtered_item", "filtered_date"]
          }
        },
        "aggregated_sales": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT i_brand_id, i_class_id, i_category_id, i_manufact_id, SUM(CASE WHEN d_year = 1998 THEN sales_cnt ELSE 0 END) AS prev_yr_cnt, SUM(CASE WHEN d_year = 1999 THEN sales_cnt ELSE 0 END) AS curr_yr_cnt, SUM(CASE WHEN d_year = 1998 THEN sales_amt ELSE 0 END) AS prev_yr_amt, SUM(CASE WHEN d_year = 1999 THEN sales_amt ELSE 0 END) AS curr_yr_amt FROM all_sales_details GROUP BY i_brand_id, i_class_id, i_category_id, i_manufact_id HAVING SUM(CASE WHEN d_year = 1998 THEN sales_cnt ELSE 0 END) > 0 AND CAST(SUM(CASE WHEN d_year = 1999 THEN sales_cnt ELSE 0 END) AS DECIMAL(17,2)) / CAST(SUM(CASE WHEN d_year = 1998 THEN sales_cnt ELSE 0 END) AS DECIMAL(17,2)) < 0.9",
          "interfaces": {
            "outputs": ["i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "prev_yr_cnt", "curr_yr_cnt", "prev_yr_amt", "curr_yr_amt"],
            "consumes": ["all_sales_details"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT 1998 AS prev_year, 1999 AS year, i_brand_id, i_class_id, i_category_id, i_manufact_id, prev_yr_cnt AS prev_yr_cnt, curr_yr_cnt AS curr_yr_cnt, curr_yr_cnt - prev_yr_cnt AS sales_cnt_diff, curr_yr_amt - prev_yr_amt AS sales_amt_diff FROM aggregated_sales ORDER BY sales_cnt_diff, sales_amt_diff LIMIT 100",
          "interfaces": {
            "outputs": ["prev_year", "year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "prev_yr_cnt", "curr_yr_cnt", "sales_cnt_diff", "sales_amt_diff"],
            "consumes": ["aggregated_sales"]
          }
        }
      },
      "reconstruction_order": ["filtered_item", "filtered_date", "all_sales_details", "aggregated_sales", "main_query"],
      "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_date AS ({filtered_date}), all_sales_details AS ({all_sales_details}), aggregated_sales AS ({aggregated_sales}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL work_mem = '32MB'"
  ],
  "validation_checks": []
}
```

## Explanation

**Changes**: The rewrite eliminates the expensive self-join by using conditional aggregation to compute both year's metrics in a single pass. It also converts LEFT JOINs to INNER JOINs (safe due to WHERE filters) and UNION to UNION ALL. Dimension tables are pre-filtered into CTEs to create small hash tables.

**Expected speedup**: 2.5-3.0x. The main gains come from: (1) eliminating the self-join and its associated sort/join cost, (2) avoiding duplicate elimination in UNION, (3) reducing nested loop joins via early dimension filtering, and (4) reducing the number of aggregation passes from three (one per channel) to one.