## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_item  [+]  (pre-filtered item dimension)
├── [CTE] filtered_ca    [+]  (pre-filtered customer_address dimension)
├── [CTE] prefactored_store_sales  [+]  (store_sales with explicit joins to pre-filtered dims)
├── [CTE] ss_agg         [+]  (aggregated store sales by county/quarter/year)
├── [CTE] prefactored_web_sales    [+]  (web_sales with explicit joins to pre-filtered dims)
├── [CTE] ws_agg         [+]  (aggregated web sales by county/quarter/year)
└── [MAIN] main_query    [~]  (same self-joins, now consumes ss_agg/ws_agg instead of ss/ws)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "dimension_prefetch",
      "description": "Pre-filter selective dimensions (item, customer_address) into tiny hash tables",
      "applied_to": ["filtered_item", "filtered_ca"]
    },
    {
      "id": "R2",
      "type": "explicit_join_conversion",
      "description": "Convert comma-separated joins to explicit INNER JOIN syntax",
      "applied_to": ["prefactored_store_sales", "prefactored_web_sales"]
    },
    {
      "id": "R3",
      "type": "cte_decomposition",
      "description": "Decompose original ss/ws CTEs into logical building blocks per target tree",
      "applied_to": ["prefactored_store_sales", "ss_agg", "prefactored_web_sales", "ws_agg"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk FROM item WHERE i_color IN ('navajo', 'orchid') AND i_manager_id BETWEEN 8 AND 27",
        "interfaces": {
          "outputs": ["i_item_sk"],
          "consumes": []
        }
      },
      "filtered_ca": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_address_sk, ca_county FROM customer_address WHERE ca_state IN ('IA', 'IL')",
        "interfaces": {
          "outputs": ["ca_address_sk", "ca_county"],
          "consumes": []
        }
      },
      "prefactored_store_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_county, d_qoy, d_year, ss_ext_sales_price FROM store_sales INNER JOIN filtered_item ON ss_item_sk = filtered_item.i_item_sk INNER JOIN filtered_ca ON ss_addr_sk = filtered_ca.ca_address_sk INNER JOIN date_dim ON ss_sold_date_sk = date_dim.d_date_sk WHERE ss_list_price BETWEEN 86 AND 100 AND date_dim.d_year = 1998 AND date_dim.d_qoy IN (1, 2, 3)",
        "interfaces": {
          "outputs": ["ca_county", "d_qoy", "d_year", "ss_ext_sales_price"],
          "consumes": ["filtered_item", "filtered_ca"]
        }
      },
      "ss_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_county, d_qoy, d_year, SUM(ss_ext_sales_price) AS store_sales FROM prefactored_store_sales GROUP BY ca_county, d_qoy, d_year",
        "interfaces": {
          "outputs": ["ca_county", "d_qoy", "d_year", "store_sales"],
          "consumes": ["prefactored_store_sales"]
        }
      },
      "prefactored_web_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_county, d_qoy, d_year, ws_ext_sales_price FROM web_sales INNER JOIN filtered_item ON ws_item_sk = filtered_item.i_item_sk INNER JOIN filtered_ca ON ws_bill_addr_sk = filtered_ca.ca_address_sk INNER JOIN date_dim ON ws_sold_date_sk = date_dim.d_date_sk WHERE ws_list_price BETWEEN 86 AND 100 AND date_dim.d_year = 1998 AND date_dim.d_qoy IN (1, 2, 3)",
        "interfaces": {
          "outputs": ["ca_county", "d_qoy", "d_year", "ws_ext_sales_price"],
          "consumes": ["filtered_item", "filtered_ca"]
        }
      },
      "ws_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_county, d_qoy, d_year, SUM(ws_ext_sales_price) AS web_sales FROM prefactored_web_sales GROUP BY ca_county, d_qoy, d_year",
        "interfaces": {
          "outputs": ["ca_county", "d_qoy", "d_year", "web_sales"],
          "consumes": ["prefactored_web_sales"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT ss1.ca_county, ss1.d_year, ws2.web_sales / ws1.web_sales AS web_q1_q2_increase, ss2.store_sales / ss1.store_sales AS store_q1_q2_increase, ws3.web_sales / ws2.web_sales AS web_q2_q3_increase, ss3.store_sales / ss2.store_sales AS store_q2_q3_increase FROM ss_agg AS ss1, ss_agg AS ss2, ss_agg AS ss3, ws_agg AS ws1, ws_agg AS ws2, ws_agg AS ws3 WHERE ss1.d_qoy = 1 AND ss1.d_year = 1998 AND ss1.ca_county = ss2.ca_county AND ss2.d_qoy = 2 AND ss2.d_year = 1998 AND ss2.ca_county = ss3.ca_county AND ss3.d_qoy = 3 AND ss3.d_year = 1998 AND ss1.ca_county = ws1.ca_county AND ws1.d_qoy = 1 AND ws1.d_year = 1998 AND ws1.ca_county = ws2.ca_county AND ws2.d_qoy = 2 AND ws2.d_year = 1998 AND ws1.ca_county = ws3.ca_county AND ws3.d_qoy = 3 AND ws3.d_year = 1998 AND CASE WHEN ws1.web_sales > 0 THEN ws2.web_sales / ws1.web_sales ELSE NULL END > CASE WHEN ss1.store_sales > 0 THEN ss2.store_sales / ss1.store_sales ELSE NULL END AND CASE WHEN ws2.web_sales > 0 THEN ws3.web_sales / ws2.web_sales ELSE NULL END > CASE WHEN ss2.store_sales > 0 THEN ss3.store_sales / ss2.store_sales ELSE NULL END ORDER BY ss1.d_year",
        "interfaces": {
          "outputs": ["ca_county", "d_year", "web_q1_q2_increase", "store_q1_q2_increase", "web_q2_q3_increase", "store_q2_q3_increase"],
          "consumes": ["ss_agg", "ws_agg"]
        }
      }
    },
    "reconstruction_order": ["filtered_item", "filtered_ca", "prefactored_store_sales", "ss_agg", "prefactored_web_sales", "ws_agg", "main_query"],
    "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_ca AS ({filtered_ca}), prefactored_store_sales AS ({prefactored_store_sales}), ss_agg AS ({ss_agg}), prefactored_web_sales AS ({prefactored_web_sales}), ws_agg AS ({ws_agg}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '512MB'",
    "SET LOCAL effective_cache_size = '4GB'"
  ],
  "validation_checks": []
}
```

**Changes:** Pre-filtered selective dimensions (item, customer_address) into tiny hash table CTEs, converted comma joins to explicit INNER JOINs, and decomposed the original ss/ws CTEs into logical building blocks per the target tree. This enables PostgreSQL's optimizer to make better cardinality estimates and choose optimal hash join plans.

**Expected speedup:** 2-3× due to reduced dimension table scanning, better join ordering, and explicit join syntax enabling hash joins with tiny probe tables. The work_mem increase supports the hash aggregates and hash joins on the pre-filtered data.