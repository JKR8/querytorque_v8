### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Structural change: Decorrelated CTE pipeline
    ├── CTE filtered_date  [+]  Cost: 0%  Rows: 31
    │   └── SCAN date_dim
    │       └── FILTER (d_year = 1999 AND d_moy BETWEEN 3 AND 5)
    ├── CTE store_customers  [+]  Cost: 0%  Rows: <165K
    │   └── JOIN (store_sales ⋈ filtered_date ON ss_sold_date_sk = d_date_sk)
    │       └── FILTER (ss_list_price BETWEEN 52 AND 141)
    ├── CTE web_customers  [+]  Cost: 0%  Rows: unknown
    │   └── JOIN (web_sales ⋈ filtered_date ON ws_sold_date_sk = d_date_sk)
    │       └── FILTER (ws_list_price BETWEEN 52 AND 141)
    ├── CTE catalog_customers  [+]  Cost: 0%  Rows: unknown
    │   └── JOIN (catalog_sales ⋈ filtered_date ON cs_sold_date_sk = d_date_sk)
    │       └── FILTER (cs_list_price BETWEEN 52 AND 141)
    ├── CTE filtered_address  [+]  Cost: 0%  Rows: 9,018
    │   └── SCAN customer_address
    │       └── FILTER (ca_state IN ('GA','KY','SD'))
    ├── CTE filtered_demo  [+]  Cost: 0%  Rows: selective
    │   └── SCAN customer_demographics
    │       └── FILTER (cd_marital_status IN ('D','W','U') AND cd_education_status IN ('Primary','College'))
    ├── CTE customer_base  [+]  Cost: 0%  Rows: 18,000
    │   └── JOIN (customer ⋈ filtered_address ON c_current_addr_sk = ca_address_sk)
    │       └── JOIN (⋈ filtered_demo ON c_current_cdemo_sk = cd_demo_sk)
    ├── CTE channel_joins  [+]  Cost: 0%  Rows: 18,000
    │   └── LEFT JOIN (customer_base ⟕ store_customers ON c_customer_sk = ss_customer_sk)
    │       └── LEFT JOIN (⟕ web_customers ON c_customer_sk = ws_bill_customer_sk)
    │           └── LEFT JOIN (⟕ catalog_customers ON c_customer_sk = cs_ship_customer_sk)
    ├── CTE filter  [+]  Cost: 0%  Rows: 914
    │   └── FILTER (has_store IS NOT NULL AND has_web IS NULL AND has_catalog IS NULL)
    ├── AGG (GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating)
    │   └── AGGREGATE (COUNT(*) AS cnt1, COUNT(*) AS cnt2, COUNT(*) AS cnt3)
    ├── SORT (cd_gender ASC, cd_marital_status ASC, cd_education_status ASC, cd_purchase_estimate ASC, cd_credit_rating ASC)
    └── OUTPUT (cd_gender, cd_marital_status, cd_education_status, cnt1, cd_purchase_estimate, cnt2, cd_credit_rating, cnt3)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "decorrelate_exists_to_cte",
      "description": "Replace correlated EXISTS subqueries with pre-computed distinct customer sets per channel, using filtered_date CTE for date filtering",
      "applied_to": ["store_customers", "web_customers", "catalog_customers"]
    },
    {
      "id": "R2",
      "type": "staged_reduction",
      "description": "Push address and demographic filters into separate CTEs before joining to customer, reducing base rows early",
      "applied_to": ["filtered_address", "filtered_demo", "customer_base"]
    },
    {
      "id": "R3",
      "type": "left_join_null_check",
      "description": "Convert EXISTS/NOT EXISTS to LEFT JOIN + NULL checks to preserve hash anti-join capability (avoid NOT IN with NULLs)",
      "applied_to": ["channel_joins", "filter"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy BETWEEN 3 AND 5",
        "interfaces": {
          "outputs": ["d_date_sk"],
          "consumes": []
        }
      },
      "store_customers": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT ss_customer_sk FROM store_sales JOIN filtered_date ON ss_sold_date_sk = filtered_date.d_date_sk WHERE ss_list_price BETWEEN 52 AND 141",
        "interfaces": {
          "outputs": ["ss_customer_sk"],
          "consumes": ["filtered_date"]
        }
      },
      "web_customers": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN filtered_date ON ws_sold_date_sk = filtered_date.d_date_sk WHERE ws_list_price BETWEEN 52 AND 141",
        "interfaces": {
          "outputs": ["ws_bill_customer_sk"],
          "consumes": ["filtered_date"]
        }
      },
      "catalog_customers": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales JOIN filtered_date ON cs_sold_date_sk = filtered_date.d_date_sk WHERE cs_list_price BETWEEN 52 AND 141",
        "interfaces": {
          "outputs": ["cs_ship_customer_sk"],
          "consumes": ["filtered_date"]
        }
      },
      "filtered_address": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('GA','KY','SD')",
        "interfaces": {
          "outputs": ["ca_address_sk"],
          "consumes": []
        }
      },
      "filtered_demo": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating FROM customer_demographics WHERE cd_marital_status IN ('D','W','U') AND cd_education_status IN ('Primary','College')",
        "interfaces": {
          "outputs": ["cd_demo_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"],
          "consumes": []
        }
      },
      "customer_base": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, filtered_demo.cd_gender, filtered_demo.cd_marital_status, filtered_demo.cd_education_status, filtered_demo.cd_purchase_estimate, filtered_demo.cd_credit_rating FROM customer c JOIN filtered_address ON c.c_current_addr_sk = filtered_address.ca_address_sk JOIN filtered_demo ON c.c_current_cdemo_sk = filtered_demo.cd_demo_sk",
        "interfaces": {
          "outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"],
          "consumes": ["filtered_address", "filtered_demo"]
        }
      },
      "channel_joins": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT customer_base.*, store_customers.ss_customer_sk AS has_store, web_customers.ws_bill_customer_sk AS has_web, catalog_customers.cs_ship_customer_sk AS has_catalog FROM customer_base LEFT JOIN store_customers ON customer_base.c_customer_sk = store_customers.ss_customer_sk LEFT JOIN web_customers ON customer_base.c_customer_sk = web_customers.ws_bill_customer_sk LEFT JOIN catalog_customers ON customer_base.c_customer_sk = catalog_customers.cs_ship_customer_sk",
        "interfaces": {
          "outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating", "has_store", "has_web", "has_catalog"],
          "consumes": ["customer_base", "store_customers", "web_customers", "catalog_customers"]
        }
      },
      "filter": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_customer_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating FROM channel_joins WHERE has_store IS NOT NULL AND has_web IS NULL AND has_catalog IS NULL",
        "interfaces": {
          "outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"],
          "consumes": ["channel_joins"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM filter GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100",
        "interfaces": {
          "outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"],
          "consumes": ["filter"]
        }
      }
    },
    "reconstruction_order": ["filtered_date", "store_customers", "web_customers", "catalog_customers", "filtered_address", "filtered_demo", "customer_base", "channel_joins", "filter", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), store_customers AS ({store_customers}), web_customers AS ({web_customers}), catalog_customers AS ({catalog_customers}), filtered_address AS ({filtered_address}), filtered_demo AS ({filtered_demo}), customer_base AS ({customer_base}), channel_joins AS ({channel_joins}), filter AS ({filter}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Replaced correlated EXISTS/NOT EXISTS subqueries with staged CTEs that pre-compute distinct customer sets per channel, then use LEFT JOIN + NULL checks for anti‑join semantics. This decorrelates the query and allows hash joins.

**Expected speedup:** 2-4× due to elimination of nested‑loop anti‑joins and early reduction of fact tables via filtered_date and price filters.