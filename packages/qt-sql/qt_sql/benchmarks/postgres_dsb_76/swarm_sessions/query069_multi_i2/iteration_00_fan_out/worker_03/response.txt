## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ~500K
    ├── WITH filtered_address AS (CTE)  [+]
    ├── WITH filtered_demo AS (CTE)  [+]
    ├── WITH filtered_date AS (CTE)  [+]
    ├── WITH customer_base AS (CTE)  [+]
    ├── WITH store_sales_filtered AS (CTE)  [+]
    ├── WITH store_join AS (CTE)  [+]
    ├── WITH web_sales_filtered AS (CTE)  [+]
    ├── WITH web_anti_join AS (CTE)  [+]
    ├── WITH catalog_sales_filtered AS (CTE)  [+]
    ├── WITH catalog_anti_join AS (CTE)  [+]
    ├── [~] SCAN (catalog_anti_join CTE)
    ├── [~] AGG (GROUP BY same 5 columns)
    ├── [=] SORT (cd_gender ASC, cd_marital_status ASC, cd_education_status ASC, cd_purchase_estimate ASC, cd_credit_rating ASC)
    └── [=] OUTPUT (cd_gender, cd_marital_status, cd_education_status, cnt1, cd_purchase_estimate, cnt2, cd_credit_rating, cnt3)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "exists_restructuring", "description": "Convert EXISTS to INNER JOIN, NOT EXISTS to LEFT JOIN + NULL anti-join", "applied_to": ["store_join", "web_anti_join", "catalog_anti_join"]},
    {"id": "R2", "type": "shared_materialization", "description": "Materialize filtered dimension and fact tables once as CTEs to avoid repeated scans", "applied_to": ["filtered_address", "filtered_demo", "filtered_date", "store_sales_filtered", "web_sales_filtered", "catalog_sales_filtered"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_address": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('GA', 'KY', 'SD')",
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "filtered_demo": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating FROM customer_demographics WHERE cd_marital_status IN ('D', 'W', 'U') AND cd_education_status IN ('Primary', 'College')",
        "interfaces": {"outputs": ["cd_demo_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": []}
      },
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy BETWEEN 3 AND 5",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "customer_base": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, fd.cd_gender, fd.cd_marital_status, fd.cd_education_status, fd.cd_purchase_estimate, fd.cd_credit_rating FROM customer c INNER JOIN filtered_address fa ON c.c_current_addr_sk = fa.ca_address_sk INNER JOIN filtered_demo fd ON c.c_current_cdemo_sk = fd.cd_demo_sk",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["filtered_address", "filtered_demo"]}
      },
      "store_sales_filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_customer_sk FROM store_sales INNER JOIN filtered_date fd ON ss_sold_date_sk = fd.d_date_sk WHERE ss_list_price BETWEEN 52 AND 141",
        "interfaces": {"outputs": ["ss_customer_sk"], "consumes": ["filtered_date"]}
      },
      "store_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cb.* FROM customer_base cb INNER JOIN store_sales_filtered ssf ON cb.c_customer_sk = ssf.ss_customer_sk",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["customer_base", "store_sales_filtered"]}
      },
      "web_sales_filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ws_bill_customer_sk FROM web_sales INNER JOIN filtered_date fd ON ws_sold_date_sk = fd.d_date_sk WHERE ws_list_price BETWEEN 52 AND 141",
        "interfaces": {"outputs": ["ws_bill_customer_sk"], "consumes": ["filtered_date"]}
      },
      "web_anti_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT sj.* FROM store_join sj LEFT JOIN web_sales_filtered wsf ON sj.c_customer_sk = wsf.ws_bill_customer_sk WHERE wsf.ws_bill_customer_sk IS NULL",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["store_join", "web_sales_filtered"]}
      },
      "catalog_sales_filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cs_ship_customer_sk FROM catalog_sales INNER JOIN filtered_date fd ON cs_sold_date_sk = fd.d_date_sk WHERE cs_list_price BETWEEN 52 AND 141",
        "interfaces": {"outputs": ["cs_ship_customer_sk"], "consumes": ["filtered_date"]}
      },
      "catalog_anti_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT waj.* FROM web_anti_join waj LEFT JOIN catalog_sales_filtered csf ON waj.c_customer_sk = csf.cs_ship_customer_sk WHERE csf.cs_ship_customer_sk IS NULL",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["web_anti_join", "catalog_sales_filtered"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM catalog_anti_join GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"], "consumes": ["catalog_anti_join"]}
      }
    },
    "reconstruction_order": ["filtered_address", "filtered_demo", "filtered_date", "customer_base", "store_sales_filtered", "store_join", "web_sales_filtered", "web_anti_join", "catalog_sales_filtered", "catalog_anti_join", "main_query"],
    "assembly_template": "WITH filtered_address AS ({filtered_address}), filtered_demo AS ({filtered_demo}), filtered_date AS ({filtered_date}), customer_base AS ({customer_base}), store_sales_filtered AS ({store_sales_filtered}), store_join AS ({store_join}), web_sales_filtered AS ({web_sales_filtered}), web_anti_join AS ({web_anti_join}), catalog_sales_filtered AS ({catalog_sales_filtered}), catalog_anti_join AS ({catalog_anti_join}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Converted comma-joins and correlated EXISTS/NOT EXISTS subqueries to explicit CTE-based join/anti-join structure. The mechanism decomposes the query into materialized filtered dimension and fact tables, then chains INNER JOIN for positive filter (EXISTS) and LEFT JOIN + NULL for negative filters (NOT EXISTS).

**Expected speedup**: 3-5x due to elimination of correlated subquery nested loops, reduction of repeated dimension/fact table scans via CTE materialization, and enabling hash anti-joins.