## Part 1: Modified Logic Tree

```
[~] filtered_date_cte
  |- Changed from original WHERE clause to CTE
  |- Materialized for single scan across three fact tables

[+] store_customers_cte
  |- Pre-filtered store_sales with date and price conditions
  |- Distinct customer keys only (ss_customer_sk)

[+] web_customers_cte  
  |- Pre-filtered web_sales with date and price conditions
  |- Distinct customer keys only (ws_bill_customer_sk)

[+] catalog_customers_cte
  |- Pre-filtered catalog_sales with date and price conditions
  |- Distinct customer keys only (cs_ship_customer_sk)

[+] customer_base_cte
  |- Filtered customer, address, demographics join
  |- Explicit JOIN syntax (converted from comma-joins)
  |- Includes all required demographic columns for final output

[~] main_query
  |- Changed from correlated subqueries to explicit anti-joins
  |- Uses CTEs for dimension pre-filtering
  |- Hash anti-joins with distinct customer sets
  |- Preserves original grouping and ordering
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "date_cte_isolate", "description": "Materialize date dimension filter once for reuse across three fact tables", "applied_to": ["filtered_date_cte"]},
    {"id": "R2", "type": "explicit_join_conversion", "description": "Convert comma-joins to explicit JOIN...ON syntax for better optimizer cardinality estimation", "applied_to": ["customer_base_cte"]},
    {"id": "R3", "type": "decorrelation_preaggregation", "description": "Pre-aggregate fact tables to distinct customer keys before anti-joins, eliminating nested-loop correlations", "applied_to": ["store_customers_cte", "web_customers_cte", "catalog_customers_cte"]},
    {"id": "R4", "type": "hash_anti_join_restructure", "description": "Replace correlated NOT EXISTS with hash anti-joins using pre-aggregated customer sets", "applied_to": ["main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy BETWEEN 3 AND 5",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_customers_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT ss_customer_sk FROM store_sales JOIN filtered_date_cte ON ss_sold_date_sk = d_date_sk WHERE ss_list_price BETWEEN 52 AND 141",
        "interfaces": {"outputs": ["ss_customer_sk"], "consumes": ["filtered_date_cte"]}
      },
      "web_customers_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN filtered_date_cte ON ws_sold_date_sk = d_date_sk WHERE ws_list_price BETWEEN 52 AND 141",
        "interfaces": {"outputs": ["ws_bill_customer_sk"], "consumes": ["filtered_date_cte"]}
      },
      "catalog_customers_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales JOIN filtered_date_cte ON cs_sold_date_sk = d_date_sk WHERE cs_list_price BETWEEN 52 AND 141",
        "interfaces": {"outputs": ["cs_ship_customer_sk"], "consumes": ["filtered_date_cte"]}
      },
      "customer_base_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, cd.cd_gender, cd.cd_marital_status, cd.cd_education_status, cd.cd_purchase_estimate, cd.cd_credit_rating FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk WHERE ca.ca_state IN ('GA','KY','SD') AND cd.cd_marital_status IN ('D','W','U') AND cd.cd_education_status IN ('Primary','College')",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer_base_cte cb JOIN store_customers_cte sc ON cb.c_customer_sk = sc.ss_customer_sk LEFT JOIN web_customers_cte wc ON cb.c_customer_sk = wc.ws_bill_customer_sk LEFT JOIN catalog_customers_cte cc ON cb.c_customer_sk = cc.cs_ship_customer_sk WHERE wc.ws_bill_customer_sk IS NULL AND cc.cs_ship_customer_sk IS NULL GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"], "consumes": ["customer_base_cte", "store_customers_cte", "web_customers_cte", "catalog_customers_cte"]}
      }
    },
    "reconstruction_order": ["filtered_date_cte", "store_customers_cte", "web_customers_cte", "catalog_customers_cte", "customer_base_cte", "main_query"],
    "assembly_template": "WITH filtered_date_cte AS ({filtered_date_cte}), store_customers_cte AS ({store_customers_cte}), web_customers_cte AS ({web_customers_cte}), catalog_customers_cte AS ({catalog_customers_cte}), customer_base_cte AS ({customer_base_cte}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '256MB'",
    "SET LOCAL hash_mem_multiplier = 2.0",
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL jit = off"
  ],
  "validation_checks": []
}
```

**Changes**: Converted comma-joins to explicit JOIN syntax and replaced correlated subqueries with hash anti-joins using pre-aggregated customer sets. Materialized date filter once and pre-filtered all dimensions before joins.

**Expected speedup**: 2.5–3.0x by eliminating nested-loop anti-joins (dominant bottleneck in original) and enabling parallel hash joins with reduced probe sizes.

---

**Mechanism**: 
1. **Date CTE materialization** eliminates three identical date_dim scans (92 rows × 3 scans → 1 scan)
2. **Explicit JOIN syntax** unlocks PostgreSQL's advanced join reordering and cost estimation for the customer-address-demographics chain
3. **Pre-aggregation of fact tables** to distinct customer keys reduces anti-join probe sizes from ~90K/214K rows to ~76K/49K rows
4. **Hash anti-joins** replace nested-loop anti-joins, reducing complexity from O(N×M) to O(N+M)
5. **Runtime configuration** ensures hash operations stay in memory and disables expensive nested-loop plans

**Defensive guards preserved**: All literals identical, CASE guards not present in this query, aggregation semantics identical (COUNT(*) over same filtered rows).