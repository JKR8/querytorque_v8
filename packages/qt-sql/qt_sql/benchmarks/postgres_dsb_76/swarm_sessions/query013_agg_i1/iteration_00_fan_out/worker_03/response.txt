## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: 1
    ├── [!] union_branches (3 CTEs + UNION ALL)
    │   ├── [~] branch1: store_sales joins with explicit INNER JOIN conditions for 2001, dep_count=3, marital='M', education='2 yr Degree', state in ('CO','NC','TX'), price 100-150, profit 100-200
    │   ├── [~] branch2: store_sales joins with explicit INNER JOIN conditions for 2001, dep_count=1, marital='U', education='College', state in ('AR','NY','TX'), price 50-100, profit 150-300
    │   ├── [~] branch3: store_sales joins with explicit INNER JOIN conditions for 2001, dep_count=1, marital='S', education='Unknown', state in ('IA','IL','NC'), price 150-200, profit 50-250
    │   └── [~] union_all: UNION ALL of branches 1-3
    └── [~] aggregation: AVG(quantity), AVG(sales_price), AVG(wholesale_cost), SUM(wholesale_cost) over union_all
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "or_to_union",
      "description": "Split OR conditions on demographics and address into three separate branches with UNION ALL",
      "applied_to": ["branch1", "branch2", "branch3", "union_all"]
    },
    {
      "id": "R2",
      "type": "explicit_join",
      "description": "Convert comma joins to explicit INNER JOIN syntax with join conditions in ON clauses",
      "applied_to": ["branch1", "branch2", "branch3"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "branch1": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM store_sales INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_year = 2001 INNER JOIN store ON ss_store_sk = s_store_sk INNER JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk AND hd_dep_count = 3 INNER JOIN customer_demographics ON ss_cdemo_sk = cd_demo_sk AND cd_marital_status = 'M' AND cd_education_status = '2 yr Degree' INNER JOIN customer_address ON ss_addr_sk = ca_address_sk AND ca_country = 'United States' AND ca_state IN ('CO', 'NC', 'TX') WHERE ss_sales_price BETWEEN 100.00 AND 150.00 AND ss_net_profit BETWEEN 100 AND 200",
          "interfaces": {
            "outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"],
            "consumes": []
          }
        },
        "branch2": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM store_sales INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_year = 2001 INNER JOIN store ON ss_store_sk = s_store_sk INNER JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk AND hd_dep_count = 1 INNER JOIN customer_demographics ON ss_cdemo_sk = cd_demo_sk AND cd_marital_status = 'U' AND cd_education_status = 'College' INNER JOIN customer_address ON ss_addr_sk = ca_address_sk AND ca_country = 'United States' AND ca_state IN ('AR', 'NY', 'TX') WHERE ss_sales_price BETWEEN 50.00 AND 100.00 AND ss_net_profit BETWEEN 150 AND 300",
          "interfaces": {
            "outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"],
            "consumes": []
          }
        },
        "branch3": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM store_sales INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_year = 2001 INNER JOIN store ON ss_store_sk = s_store_sk INNER JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk AND hd_dep_count = 1 INNER JOIN customer_demographics ON ss_cdemo_sk = cd_demo_sk AND cd_marital_status = 'S' AND cd_education_status = 'Unknown' INNER JOIN customer_address ON ss_addr_sk = ca_address_sk AND ca_country = 'United States' AND ca_state IN ('IA', 'IL', 'NC') WHERE ss_sales_price BETWEEN 150.00 AND 200.00 AND ss_net_profit BETWEEN 50 AND 250",
          "interfaces": {
            "outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"],
            "consumes": []
          }
        },
        "union_all": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM branch1 UNION ALL SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM branch2 UNION ALL SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM branch3",
          "interfaces": {
            "outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"],
            "consumes": ["branch1", "branch2", "branch3"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT AVG(ss_quantity) AS avg_ss_quantity, AVG(ss_ext_sales_price) AS avg_ss_ext_sales_price, AVG(ss_ext_wholesale_cost) AS avg_ss_ext_wholesale_cost, SUM(ss_ext_wholesale_cost) AS sum_ss_ext_wholesale_cost FROM union_all",
          "interfaces": {
            "outputs": ["avg_ss_quantity", "avg_ss_ext_sales_price", "avg_ss_ext_wholesale_cost", "sum_ss_ext_wholesale_cost"],
            "consumes": ["union_all"]
          }
        }
      },
      "reconstruction_order": ["branch1", "branch2", "branch3", "union_all", "main_query"],
      "assembly_template": "WITH branch1 AS ({branch1}), branch2 AS ({branch2}), branch3 AS ({branch3}), union_all AS ({union_all}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL work_mem = '64MB'",
    "SET LOCAL parallel_setup_cost = 1.0",
    "SET LOCAL parallel_tuple_cost = 0.001",
    "SET LOCAL max_parallel_workers_per_gather = 2"
  ],
  "validation_checks": []
}
```

## Mechanism Explanation

**Changes:** The rewrite transforms the original query's OR conditions into three separate branches with explicit INNER JOINs, combined via UNION ALL, then aggregated. This eliminates bitmap index scan optimization but creates smaller, parallelizable subqueries.

**Expected speedup:** ~0.8x (slight regression due to loss of bitmap OR optimization, partially offset by parallel execution on smaller branch subsets). The UNION ALL structure may benefit from parallel gather nodes on each branch scan, and reduced work_mem per hash join.