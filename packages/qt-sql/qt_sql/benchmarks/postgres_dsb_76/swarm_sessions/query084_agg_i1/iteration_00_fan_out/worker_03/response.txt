### Part 1: Modified Logic Tree
```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~500K
    ├── [!] CTE filtered_core
    │   ├── SCAN (customer, customer_address, household_demographics, income_band)
    │   ├── JOIN (c_current_addr_sk = ca_address_sk)
    │   ├── JOIN (c_current_hdemo_sk = hd_demo_sk)
    │   ├── JOIN (hd_income_band_sk = ib_income_band_sk)
    │   ├── FILTER (ca_city = 'Jackson')
    │   └── FILTER (ib_lower_bound >= 23567 AND ib_upper_bound <= 73567)
    ├── [!] CTE store_returns_join
    │   ├── SCAN (filtered_core, store_returns)
    │   └── JOIN (sr_cdemo_sk = c_current_cdemo_sk)
    ├── [!] CTE customer_demographics_lookup
    │   ├── SCAN (store_returns_join, customer_demographics)
    │   └── JOIN (sr_cdemo_sk = cd_demo_sk)
    ├── [=] SORT (c_customer_id ASC)
    └── [=] OUTPUT (customer_id, customername)
```

### Part 2: Component Payload JSON
```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Isolate dimension filters (customer_address city, income_band) early in CTE to reduce cardinality", "applied_to": ["filtered_core"]},
    {"id": "R2", "type": "late_attribute_binding", "description": "Defer customer_demographics join until after store_returns join since its columns aren't used for filtering", "applied_to": ["customer_demographics_lookup"]},
    {"id": "R3", "type": "explicit_join_structure", "description": "Replace comma-separated implicit joins with explicit JOIN syntax for clarity and optimizer predictability", "applied_to": ["filtered_core", "store_returns_join", "customer_demographics_lookup"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_core": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT customer.c_customer_id, customer.c_first_name, customer.c_last_name, customer.c_current_cdemo_sk FROM customer INNER JOIN customer_address ON customer.c_current_addr_sk = customer_address.ca_address_sk INNER JOIN household_demographics ON customer.c_current_hdemo_sk = household_demographics.hd_demo_sk INNER JOIN income_band ON household_demographics.hd_income_band_sk = income_band.ib_income_band_sk WHERE customer_address.ca_city = 'Jackson' AND income_band.ib_lower_bound >= 23567 AND income_band.ib_upper_bound <= 23567 + 50000",
        "interfaces": {"outputs": ["c_customer_id", "c_first_name", "c_last_name", "c_current_cdemo_sk"], "consumes": []}
      },
      "store_returns_join": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT filtered_core.c_customer_id, filtered_core.c_first_name, filtered_core.c_last_name, store_returns.sr_cdemo_sk FROM filtered_core INNER JOIN store_returns ON store_returns.sr_cdemo_sk = filtered_core.c_current_cdemo_sk",
        "interfaces": {"outputs": ["c_customer_id", "c_first_name", "c_last_name", "sr_cdemo_sk"], "consumes": ["filtered_core"]}
      },
      "customer_demographics_lookup": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT store_returns_join.c_customer_id, store_returns_join.c_first_name, store_returns_join.c_last_name FROM store_returns_join INNER JOIN customer_demographics ON store_returns_join.sr_cdemo_sk = customer_demographics.cd_demo_sk",
        "interfaces": {"outputs": ["c_customer_id", "c_first_name", "c_last_name"], "consumes": ["store_returns_join"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_customer_id AS customer_id, (COALESCE(c_last_name, '') || ', ' || COALESCE(c_first_name, '')) AS customername FROM customer_demographics_lookup ORDER BY c_customer_id LIMIT 100",
        "interfaces": {"outputs": ["customer_id", "customername"], "consumes": ["customer_demographics_lookup"]}
      }
    },
    "reconstruction_order": ["filtered_core", "store_returns_join", "customer_demographics_lookup", "main_query"],
    "assembly_template": "WITH filtered_core AS (${filtered_core}), store_returns_join AS (${store_returns_join}), customer_demographics_lookup AS (${customer_demographics_lookup}) ${main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Restructured into three CTEs following the target logical tree - first isolating customers in Jackson with income band filters, then joining store_returns via demographic key, finally joining customer_demographics only to enforce referential integrity.  
**Expected speedup:** ~2-3x from early cardinality reduction and better join order control.