<reasoning>
CLASSIFY:
This is a star-join aggregation query with late dimension filtering (filters on customer_demographics, date_dim, store, item). It's a classic star schema: store_sales fact table joined to four dimension tables with equality joins, filtered on dimension attributes, then aggregated with ROLLUP. No correlated subqueries, no UNION, no self-joins, no window functions.

EXPLAIN PLAN ANALYSIS:
- Total time: 8.9ms (already fast). Planning: 2.1ms.
- Execution flow: Gather (parallel) → Nested Loop chain → Sort → Aggregate → Limit.
- Key observations:
  1. Nested Loop joins dominate (4 levels). This is because dimension tables are tiny after filtering: date_dim returns 122 rows, store returns ~1 row (filtered from 102), item and customer_demographics return tiny sets via index scans.
  2. The fact table store_sales is scanned via Index Only Scan in the innermost loop, using index on (ss_sold_date_sk, ss_store_sk). This is efficient for point lookups.
  3. Row counts drop sharply at dimension filters: date_dim (122 rows), store (~1 row), item (small), customer_demographics (small). The nested loop then probes store_sales with these keys.
  4. No repeated scans of the same table; each base table scanned once.
  5. The optimizer already pushes predicates into scans (Index Cond, Filter). No CTEs to split.
  6. The plan uses parallelism (Gather with 2 workers).

BOTTLENECK IDENTIFICATION:
The query is join-bound with nested loops. While each loop is fast (0.0ms in inner loops), the nested loop structure with 4 levels may become a bottleneck with larger data. The current runtime is 8.9ms, which is low, but we can attempt to restructure for better scalability.

GAP MATCHING:
1. COMMA_JOIN_WEAKNESS: Yes. Query uses comma-separated implicit joins (FROM store_sales, customer_demographics, date_dim, store, item). PostgreSQL's cardinality estimation can be worse with comma joins. Opportunity: Convert to explicit JOINs with pre-filtered CTEs.
2. CORRELATED_SUBQUERY_PARALYSIS: No correlated subqueries.
3. CROSS_CTE_PREDICATE_BLINDNESS: No repeated fact scans.
4. NON_EQUI_JOIN_INPUT_BLINDNESS: No non-equi joins.
5. Other gaps: The optimizer uses nested loops because dimension tables are tiny. However, the EXPLAIN shows "Rows Removed by Filter: 102" on store table (seq scan). Could use index on s_state.

AGGREGATION TRAP CHECK:
Aggregates are AVG (ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price). AVG is duplicate-sensitive but grouping-insensitive. The ROLLUP adds subtotals. Any restructuring must preserve exact group membership (i_item_id, s_state) and not introduce duplicates.

TRANSFORM SELECTION:
Given the fast baseline, we need diverse strategies that could help in similar but larger scenarios:
1. **star_join_prefetch**: Pre-filter all dimensions into CTEs, then join with fact table. Attacks COMMA_JOIN_WEAKNESS.
2. **global_predicate_pushdown**: Explicit JOINs with predicate pushdown. Minimal change baseline.
3. **late_attribute_binding**: Defer non-filter dimension joins after aggregation where possible. Here, customer_demographics and date_dim are used only for filtering (not in SELECT/GROUP BY). Could filter fact table via EXISTS subquery or semi-join, then join dimensions for display? But s_state and i_item_id are in GROUP BY, so store and item must be joined before aggregation.
4. **scan_consolidation_pivot**: Not applicable (no multiple scans).
For Worker 4 (exploration): Try a novel combination: pre-filter dimensions into CTEs, then use LATERAL join to fetch fact rows in a single pass.

LOGICAL TREE DESIGN:
For star_join_prefetch: CTEs for filtered date_dim, store, item, customer_demographics → join with store_sales → aggregate.
For explicit JOINs: Same joins but with explicit syntax.
For late_attribute_binding: Filter store_sales via EXISTS with dimension keys where dimensions satisfy filters, then join dimensions for display columns (but s_state and i_item_id are needed early for GROUP BY). Actually, store and item must be joined before GROUP BY because their columns are in GROUP BY. customer_demographics and date_dim could be filtered via EXISTS.
For exploration: Use LATERAL join to combine dimension filtering and fact table probe in one pass.

Check column completeness: Each CTE must output all columns needed downstream: join keys and any columns used in SELECT, WHERE, GROUP BY.
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
Compute average sales metrics for sports items sold in Iowa stores in 2002 to female, married, primary‑education customers, broken down by item and state with rollup subtotals. All joins are INNER (equality on foreign keys). AVG aggregates are duplicate‑sensitive but grouping‑insensitive; any rewrite must preserve the exact set of store_sales rows contributing to each (i_item_id, s_state) group. The s_state=‘IA’ and i_category=‘Sports’ filters are independent of other dimensions and must remain applied to their respective tables.

BOTTLENECK_DIAGNOSIS:
Join‑bound nested‑loop execution (4 levels) probing a large fact table via index lookup. Cardinality flow: date_dim → 122 rows, store → ~1 row, then index probe on store_sales returns few rows per combination, then filtered item and customer_demographics via index. The optimizer already pushes all predicates into base‑table scans and chooses nested loops because dimension result sets are tiny. Logical‑tree cost percentages are misleading—the actual runtime is dominated by nested‑loop iteration overhead, not scan I/O.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output i_item_id, s_state, g_state, agg1, agg2, agg3, agg4 in original order.
- CTE_COLUMN_COMPLETENESS: Any CTE must include all columns referenced downstream: join keys (ss_sold_date_sk, ss_store_sk, ss_item_sk, ss_cdemo_sk) and grouping columns (i_item_id, s_state).
- LITERAL_PRESERVATION: Must preserve exact literals: 'F', 'M', 'Primary', 2002, 'IA', 'Sports'.
- SEMANTIC_EQUIVALENCE: Must return same rows, grouping, and ordering.
- COMMA_JOIN_WEAKNESS: Query uses comma‑separated joins; EXPLAIN shows nested‑loop plan that may benefit from explicit JOINs with pre‑filtered CTEs.

REGRESSION_WARNINGS:
None applicable.

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  filtered_date → filtered_store → filtered_item → filtered_cdemo → prefact → joined → aggregated → sorted_limited
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_year = 2002
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 122
    CONSUMERS: prefact
  filtered_store:
    FROM: store
    WHERE: s_state = 'IA'
    OUTPUT: s_store_sk, s_state
    EXPECTED_ROWS: ~1
    CONSUMERS: prefact
  filtered_item:
    FROM: item
    WHERE: i_category = 'Sports'
    OUTPUT: i_item_sk, i_item_id
    EXPECTED_ROWS: small
    CONSUMERS: prefact
  filtered_cdemo:
    FROM: customer_demographics
    WHERE: cd_gender = 'F' AND cd_marital_status = 'M' AND cd_education_status = 'Primary'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: small
    CONSUMERS: prefact
  prefact:
    FROM: store_sales
    JOIN: INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk
          INNER JOIN filtered_store ON ss_store_sk = s_store_sk
          INNER JOIN filtered_item ON ss_item_sk = i_item_sk
          INNER JOIN filtered_cdemo ON ss_cdemo_sk = cd_demo_sk
    OUTPUT: i_item_id, s_state, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    EXPECTED_ROWS: ~few
    CONSUMERS: aggregated
  aggregated:
    FROM: prefact
    GROUP BY: ROLLUP (i_item_id, s_state)
    AGGREGATE: AVG(ss_quantity), AVG(ss_list_price), AVG(ss_coupon_amt), AVG(ss_sales_price)
    OUTPUT: i_item_id, s_state, GROUPING(s_state) AS g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: ≤100 (due to limit)
    CONSUMERS: sorted_limited
  sorted_limited:
    FROM: aggregated
    ORDER BY: i_item_id, s_state
    LIMIT: 100
    OUTPUT: i_item_id, s_state, g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: 100
    CONSUMERS: final
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join, pg_materialized_dimension_fact_prefilter
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply pre‑filtering of all dimension tables into CTEs and explicit JOINs; ignore the UNION aspect (not present here).
- pg_date_cte_explicit_join: Use CTE for date_dim filter and explicit JOIN syntax; ignore promotion table reference.
- pg_materialized_dimension_fact_prefilter: Use MATERIALIZED on dimension CTEs to force early filtering; ignore the non‑equi join aspect.
HAZARD_FLAGS:
- CTE materialization may block parallelism (Gather node disappears).
- Overhead of multiple CTEs may exceed benefit for tiny dimension sets.

=== WORKER 2 BRIEFING ===

STRATEGY: global_predicate_pushdown
TARGET_LOGICAL_TREE:
  joined → aggregated → sorted_limited
NODE_CONTRACTS:
  joined:
    FROM: store_sales
         INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk
         INNER JOIN store ON ss_store_sk = s_store_sk
         INNER JOIN item ON ss_item_sk = i_item_sk
         INNER JOIN customer_demographics ON ss_cdemo_sk = cd_demo_sk
    WHERE: cd_gender = 'F' AND cd_marital_status = 'M' AND cd_education_status = 'Primary'
           AND d_year = 2002 AND s_state = 'IA' AND i_category = 'Sports'
    OUTPUT: i_item_id, s_state, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    EXPECTED_ROWS: ~few
    CONSUMERS: aggregated
  aggregated:
    FROM: joined
    GROUP BY: ROLLUP (i_item_id, s_state)
    AGGREGATE: AVG(ss_quantity), AVG(ss_list_price), AVG(ss_coupon_amt), AVG(ss_sales_price)
    OUTPUT: i_item_id, s_state, GROUPING(s_state) AS g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: ≤100
    CONSUMERS: sorted_limited
  sorted_limited:
    FROM: aggregated
    ORDER BY: i_item_id, s_state
    LIMIT: 100
    OUTPUT: i_item_id, s_state, g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: 100
    CONSUMERS: final
EXAMPLES: early_filter_decorrelate, pushdown
EXAMPLE_ADAPTATION:
- early_filter_decorrelate: Apply predicate pushdown into JOIN ON clauses or WHERE; ignore decorrelation (no subqueries).
- pushdown: Push filters directly into JOIN conditions; ignore the CTE aspect.
HAZARD_FLAGS:
- Minimal change; may not improve over optimizer's already good predicate pushdown.
- Explicit JOIN order may differ from optimizer's chosen order.

=== WORKER 3 BRIEFING ===

STRATEGY: late_attribute_binding
TARGET_LOGICAL_TREE:
  fact_filtered → joined_store_item → aggregated → sorted_limited
NODE_CONTRACTS:
  fact_filtered:
    FROM: store_sales
    WHERE: EXISTS (SELECT 1 FROM date_dim WHERE d_date_sk = store_sales.ss_sold_date_sk AND d_year = 2002)
           AND EXISTS (SELECT 1 FROM customer_demographics WHERE cd_demo_sk = store_sales.ss_cdemo_sk AND cd_gender = 'F' AND cd_marital_status = 'M' AND cd_education_status = 'Primary')
    OUTPUT: ss_item_sk, ss_store_sk, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    EXPECTED_ROWS: unknown (filtered by EXISTS)
    CONSUMERS: joined_store_item
  joined_store_item:
    FROM: fact_filtered
         INNER JOIN store ON ss_store_sk = s_store_sk AND s_state = 'IA'
         INNER JOIN item ON ss_item_sk = i_item_sk AND i_category = 'Sports'
    OUTPUT: i_item_id, s_state, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    EXPECTED_ROWS: ~few
    CONSUMERS: aggregated
  aggregated:
    FROM: joined_store_item
    GROUP BY: ROLLUP (i_item_id, s_state)
    AGGREGATE: AVG(ss_quantity), AVG(ss_list_price), AVG(ss_coupon_amt), AVG(ss_sales_price)
    OUTPUT: i_item_id, s_state, GROUPING(s_state) AS g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: ≤100
    CONSUMERS: sorted_limited
  sorted_limited:
    FROM: aggregated
    ORDER BY: i_item_id, s_state
    LIMIT: 100
    OUTPUT: i_item_id, s_state, g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: 100
    CONSUMERS: final
EXAMPLES: late_attribute_binding, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- late_attribute_binding: Use EXISTS to filter fact rows by dimensions not needed in SELECT, then join required dimensions; ignore the attribute deferral (all dimensions are needed for filtering here).
- early_filter_decorrelate: Push dimension filters into EXISTS subqueries; ignore the CTE materialization.
HAZARD_FLAGS:
- EXISTS may be less efficient than joins for large fact tables.
- May prevent index‑only scans on store_sales if columns needed are not in index.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: lateral_dimension_probe
TARGET_LOGICAL_TREE:
  dim_combos → lateral_fact → aggregated → sorted_limited
NODE_CONTRACTS:
  dim_combos:
    FROM: (SELECT d_date_sk FROM date_dim WHERE d_year = 2002) d
         CROSS JOIN (SELECT s_store_sk, s_state FROM store WHERE s_state = 'IA') s
         CROSS JOIN (SELECT i_item_sk, i_item_id FROM item WHERE i_category = 'Sports') i
         CROSS JOIN (SELECT cd_demo_sk FROM customer_demographics WHERE cd_gender = 'F' AND cd_marital_status = 'M' AND cd_education_status = 'Primary') c
    OUTPUT: d_date_sk, s_store_sk, s_state, i_item_sk, i_item_id, cd_demo_sk
    EXPECTED_ROWS: 122 * 1 * small * small (still small)
    CONSUMERS: lateral_fact
  lateral_fact:
    FROM: dim_combos,
          LATERAL (SELECT ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
                   FROM store_sales
                   WHERE ss_sold_date_sk = d_date_sk
                     AND ss_store_sk = s_store_sk
                     AND ss_item_sk = i_item_sk
                     AND ss_cdemo_sk = cd_demo_sk) f
    OUTPUT: i_item_id, s_state, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    EXPECTED_ROWS: ~few
    CONSUMERS: aggregated
  aggregated:
    FROM: lateral_fact
    GROUP BY: ROLLUP (i_item_id, s_state)
    AGGREGATE: AVG(ss_quantity), AVG(ss_list_price), AVG(ss_coupon_amt), AVG(ss_sales_price)
    OUTPUT: i_item_id, s_state, GROUPING(s_state) AS g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: ≤100
    CONSUMERS: sorted_limited
  sorted_limited:
    FROM: aggregated
    ORDER BY: i_item_id, s_state
    LIMIT: 100
    OUTPUT: i_item_id, s_state, g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: 100
    CONSUMERS: final
EXAMPLES: pg_self_join_decomposition, inline_decorrelate_materialized
EXAMPLE_ADAPTATION:
- pg_self_join_decomposition: Materialize dimension combinations once and probe fact table; ignore the self‑join aspect.
- inline_decorrelate_materialized: Use LATERAL to decorrelate fact table lookup; ignore the scalar subquery aspect.
HAZARD_FLAGS:
- LATERAL may force nested loops and block other join orders.
- Cross join of four CTEs could produce large Cartesian product if filters are not selective.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: novel_combination