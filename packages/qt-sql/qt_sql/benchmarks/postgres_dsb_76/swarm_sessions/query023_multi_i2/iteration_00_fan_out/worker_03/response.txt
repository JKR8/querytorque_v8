## Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_filtered [+] New dimension filter isolation
├── [CTE] item_filtered [+] New dimension filter isolation
├── [CTE] frequent_ss_items [~] Now uses explicit JOINs with dimension CTEs
│   ├── SCAN (store_sales)
│   ├── JOIN date_filtered (explicit INNER JOIN)
│   ├── JOIN item_filtered (explicit INNER JOIN)
│   └── FILTER (moved to dimension CTEs)
├── [CTE] max_store_sales [~] Now uses explicit JOINs with date_filtered
│   ├── SCAN (store_sales)
│   ├── JOIN date_filtered (explicit INNER JOIN)
│   ├── JOIN customer (explicit INNER JOIN)
│   └── FILTER (d_year moved to date_filtered)
├── [CTE] best_ss_customer [~] Now uses explicit JOIN
│   ├── SCAN (store_sales)
│   ├── JOIN customer (explicit INNER JOIN)
│   └── FILTER (correlated subquery unchanged)
└── [MAIN] main_query [~] Explicit JOINs for date_dim, same UNION ALL structure
    ├── SCAN (catalog_sales)
    ├── JOIN date_dim (explicit INNER JOIN)
    ├── SCAN (web_sales)
    └── JOIN date_dim (explicit INNER JOIN)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_isolation", "description": "Extract selective date and item filters into separate CTEs", "applied_to": ["date_filtered", "item_filtered"]},
    {"id": "R2", "type": "explicit_join_conversion", "description": "Convert comma-separated joins to explicit INNER JOIN syntax", "applied_to": ["frequent_ss_items", "max_store_sales", "best_ss_customer", "main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "item_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_desc FROM item WHERE i_manager_id BETWEEN 44 AND 63 AND i_category IN ('Men', 'Music', 'Sports')",
        "interfaces": {"outputs": ["i_item_sk", "i_item_desc"], "consumes": []}
      },
      "frequent_ss_items": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT SUBSTRING(if.i_item_desc FROM 1 FOR 30) AS itemdesc, ss.ss_item_sk AS item_sk, df.d_date AS solddate, COUNT(*) AS cnt FROM store_sales ss INNER JOIN date_filtered df ON ss.ss_sold_date_sk = df.d_date_sk INNER JOIN item_filtered if ON ss.ss_item_sk = if.i_item_sk GROUP BY SUBSTRING(if.i_item_desc FROM 1 FOR 30), ss.ss_item_sk, df.d_date HAVING COUNT(*) > 4",
        "interfaces": {"outputs": ["itemdesc", "item_sk", "solddate", "cnt"], "consumes": ["date_filtered", "item_filtered"]}
      },
      "max_store_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT MAX(csales) AS tpcds_cmax FROM (SELECT c.c_customer_sk, SUM(ss.ss_quantity * ss.ss_sales_price) AS csales FROM store_sales ss INNER JOIN date_filtered df ON ss.ss_sold_date_sk = df.d_date_sk INNER JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk WHERE ss.ss_wholesale_cost BETWEEN 26 AND 36 GROUP BY c.c_customer_sk) tmp1",
        "interfaces": {"outputs": ["tpcds_cmax"], "consumes": ["date_filtered"]}
      },
      "best_ss_customer": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c.c_customer_sk, SUM(ss.ss_quantity * ss.ss_sales_price) AS ssales FROM store_sales ss INNER JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk WHERE c.c_birth_year BETWEEN 1987 AND 1993 GROUP BY c.c_customer_sk HAVING SUM(ss.ss_quantity * ss.ss_sales_price) > (95/100.0) * (SELECT tpcds_cmax FROM max_store_sales)",
        "interfaces": {"outputs": ["c_customer_sk", "ssales"], "consumes": ["max_store_sales"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT SUM(sales) FROM (SELECT cs.cs_quantity * cs.cs_list_price AS sales FROM catalog_sales cs INNER JOIN date_dim d ON cs.cs_sold_date_sk = d.d_date_sk WHERE d.d_year = 1999 AND d.d_moy = 5 AND cs.cs_item_sk IN (SELECT item_sk FROM frequent_ss_items) AND cs.cs_bill_customer_sk IN (SELECT c_customer_sk FROM best_ss_customer) AND cs.cs_wholesale_cost BETWEEN 26 AND 36 UNION ALL SELECT ws.ws_quantity * ws.ws_list_price AS sales FROM web_sales ws INNER JOIN date_dim d ON ws.ws_sold_date_sk = d.d_date_sk WHERE d.d_year = 1999 AND d.d_moy = 5 AND ws.ws_item_sk IN (SELECT item_sk FROM frequent_ss_items) AND ws.ws_bill_customer_sk IN (SELECT c_customer_sk FROM best_ss_customer) AND ws.ws_wholesale_cost BETWEEN 26 AND 36) tmp2 LIMIT 100",
        "interfaces": {"outputs": ["sum"], "consumes": ["frequent_ss_items", "best_ss_customer"]}
      }
    },
    "reconstruction_order": ["date_filtered", "item_filtered", "frequent_ss_items", "max_store_sales", "best_ss_customer", "main_query"],
    "assembly_template": "WITH date_filtered AS ({date_filtered}), item_filtered AS ({item_filtered}), frequent_ss_items AS ({frequent_ss_items}), max_store_sales AS ({max_store_sales}), best_ss_customer AS ({best_ss_customer}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL max_parallel_workers_per_gather = 4", "SET LOCAL work_mem = '256MB'"],
  "validation_checks": []
}
```

**Changes**: Isolated highly selective dimension filters (date_dim.year=1999, item.manager_id/category) into separate CTEs, converting all comma-separated joins to explicit INNER JOIN syntax. This creates small hash tables for dimension lookups and improves PostgreSQL's join planning accuracy.

**Expected speedup**: ~2.28x (similar to pg_date_cte_explicit_join pattern) due to better hash join planning with tiny dimension CTEs and explicit join syntax eliminating comma-join cardinality estimation issues.