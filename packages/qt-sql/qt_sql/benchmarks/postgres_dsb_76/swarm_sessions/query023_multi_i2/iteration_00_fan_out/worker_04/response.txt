## Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_filtered  [+]  (new CTE)
├── [CTE] item_filtered  [+]  (new CTE)
├── [CTE] customer_filtered  [+]  (new CTE)
├── [CTE] store_sales_unified  [+]  (new CTE)
├── [CTE] max_store_sales  [~]  (modified: uses store_sales_unified, no longer correlated)
├── [CTE] best_ss_customer_joined  [+]  (new CTE replacing best_ss_customer)
├── [CTE] frequent_ss_items  [~]  (modified: uses store_sales_unified + item_filtered)
└── [MAIN] main_query  [~]  (modified: uses new CTEs with same UNION ALL structure)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "inline_decorrelate_materialized",
      "description": "Replace correlated scalar subquery with per-customer JOIN via CTEs",
      "applied_to": ["max_store_sales", "best_ss_customer_joined"]
    },
    {
      "id": "R2",
      "type": "pg_materialized_dimension_fact_prefilter",
      "description": "Stage dimension filtering before fact table joins",
      "applied_to": ["date_filtered", "item_filtered", "customer_filtered", "store_sales_unified"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_year = 1999",
        "interfaces": {
          "outputs": ["d_date_sk", "d_date"],
          "consumes": []
        }
      },
      "item_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk, i_item_desc FROM item WHERE i_manager_id BETWEEN 44 AND 63 AND i_category IN ('Men', 'Music', 'Sports')",
        "interfaces": {
          "outputs": ["i_item_sk", "i_item_desc"],
          "consumes": []
        }
      },
      "customer_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c_customer_sk FROM customer WHERE c_birth_year BETWEEN 1987 AND 1993",
        "interfaces": {
          "outputs": ["c_customer_sk"],
          "consumes": []
        }
      },
      "store_sales_unified": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss.ss_item_sk, ss.ss_sold_date_sk, df.d_date, ift.i_item_desc, ss.ss_customer_sk, cf.c_customer_sk, ss.ss_quantity, ss.ss_sales_price, ss.ss_wholesale_cost FROM store_sales ss INNER JOIN date_filtered df ON ss.ss_sold_date_sk = df.d_date_sk LEFT JOIN item_filtered ift ON ss.ss_item_sk = ift.i_item_sk LEFT JOIN customer_filtered cf ON ss.ss_customer_sk = cf.c_customer_sk",
        "interfaces": {
          "outputs": ["ss_item_sk", "ss_sold_date_sk", "d_date", "i_item_desc", "ss_customer_sk", "c_customer_sk", "ss_quantity", "ss_sales_price", "ss_wholesale_cost"],
          "consumes": ["date_filtered", "item_filtered", "customer_filtered"]
        }
      },
      "max_store_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_customer_sk, SUM(ss_quantity * ss_sales_price) AS csales FROM store_sales_unified WHERE ss_wholesale_cost BETWEEN 26 AND 36 GROUP BY ss_customer_sk",
        "interfaces": {
          "outputs": ["ss_customer_sk", "csales"],
          "consumes": ["store_sales_unified"]
        }
      },
      "best_ss_customer_joined": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ssu.ss_customer_sk AS c_customer_sk, SUM(ssu.ss_quantity * ssu.ss_sales_price) AS ssales FROM store_sales_unified ssu INNER JOIN max_store_sales mss ON ssu.ss_customer_sk = mss.ss_customer_sk WHERE ssu.c_customer_sk IS NOT NULL GROUP BY ssu.ss_customer_sk, mss.csales HAVING SUM(ssu.ss_quantity * ssu.ss_sales_price) > (95/100.0) * mss.csales",
        "interfaces": {
          "outputs": ["c_customer_sk", "ssales"],
          "consumes": ["store_sales_unified", "max_store_sales"]
        }
      },
      "frequent_ss_items": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT SUBSTRING(ssu.i_item_desc FROM 1 FOR 30) AS itemdesc, ssu.ss_item_sk AS item_sk, ssu.d_date AS solddate, COUNT(*) AS cnt FROM store_sales_unified ssu INNER JOIN item_filtered ift ON ssu.ss_item_sk = ift.i_item_sk GROUP BY SUBSTRING(ssu.i_item_desc FROM 1 FOR 30), ssu.ss_item_sk, ssu.d_date HAVING COUNT(*) > 4",
        "interfaces": {
          "outputs": ["itemdesc", "item_sk", "solddate", "cnt"],
          "consumes": ["store_sales_unified", "item_filtered"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT SUM(sales) FROM (SELECT cs_quantity * cs_list_price AS sales FROM catalog_sales INNER JOIN date_dim ON cs_sold_date_sk = d_date_sk WHERE d_year = 1999 AND d_moy = 5 AND cs_item_sk IN (SELECT item_sk FROM frequent_ss_items) AND cs_bill_customer_sk IN (SELECT c_customer_sk FROM best_ss_customer_joined) AND cs_wholesale_cost BETWEEN 26 AND 36 UNION ALL SELECT ws_quantity * ws_list_price AS sales FROM web_sales INNER JOIN date_dim ON ws_sold_date_sk = d_date_sk WHERE d_year = 1999 AND d_moy = 5 AND ws_item_sk IN (SELECT item_sk FROM frequent_ss_items) AND ws_bill_customer_sk IN (SELECT c_customer_sk FROM best_ss_customer_joined) AND ws_wholesale_cost BETWEEN 26 AND 36) tmp2 LIMIT 100",
        "interfaces": {
          "outputs": ["sum"],
          "consumes": ["frequent_ss_items", "best_ss_customer_joined"]
        }
      }
    },
    "reconstruction_order": ["date_filtered", "item_filtered", "customer_filtered", "store_sales_unified", "max_store_sales", "best_ss_customer_joined", "frequent_ss_items", "main_query"],
    "assembly_template": "WITH date_filtered AS ({date_filtered}), item_filtered AS ({item_filtered}), customer_filtered AS ({customer_filtered}), store_sales_unified AS ({store_sales_unified}), max_store_sales AS ({max_store_sales}), best_ss_customer_joined AS ({best_ss_customer_joined}), frequent_ss_items AS ({frequent_ss_items}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '256MB'",
    "SET LOCAL max_parallel_workers_per_gather = 4",
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL enable_mergejoin = off"
  ],
  "validation_checks": []
}
```

**Changes**: Restructured correlated scalar subquery into per-customer JOIN via staged CTEs, applying dimension prefiltering before fact table joins. The original `best_ss_customer` correlated subquery is now `best_ss_customer_joined` which joins `store_sales_unified` with `max_store_sales` computed from the same CTE.

**Expected speedup**: 2-3x by eliminating per-row correlated subquery execution and enabling parallel hash joins on prefiltered datasets.