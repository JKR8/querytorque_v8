## Part 1: Modified Logic Tree
```
QUERY: (single statement)
├── [CTE] filtered_date_dim [~]  Cost: 1%  Rows: ~365
│   └── SCAN (date_dim) with filter (d_year = 2002)
├── [CTE] filtered_item [~]  Cost: 1%  Rows: ~500
│   └── SCAN (item) with filter (i_category IN ('Jewelry', 'Men') AND i_manager_id BETWEEN 81 AND 100)
├── [CTE] filtered_warehouse [~]  Cost: 1%  Rows: ~5
│   └── SCAN (warehouse)
├── [CTE] prejoined_inventory [~]  Cost: 30%  Rows: ~50K
│   ├── SCAN (inventory) with filter (inv_quantity_on_hand BETWEEN 0 AND 200)
│   ├── JOIN (INNER filtered_date_dim ON inv_date_sk = d_date_sk)
│   ├── JOIN (INNER filtered_item ON inv_item_sk = i_item_sk)
│   └── JOIN (INNER filtered_warehouse ON inv_warehouse_sk = w_warehouse_sk)
├── [CTE] monthly_agg [~]  Cost: 10%  Rows: ~1K
│   ├── SCAN (prejoined_inventory)
│   └── AGG (GROUP BY w_warehouse_sk, w_warehouse_name, i_item_sk, d_moy)
│       └── AGGREGATE (STDDEV_SAMP(inv_quantity_on_hand), AVG(inv_quantity_on_hand))
├── [CTE] inv_cte [~]  Cost: 5%  Rows: ~100
│   ├── SCAN (monthly_agg)
│   └── FILTER (CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1)
└── [MAIN] main_query [=]  Cost: 50%  Rows: ~10
    ├── SELF-JOIN (inv_cte AS inv1, inv_cte AS inv2) ON (inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk)
    ├── FILTER (inv1.d_moy = 2 AND inv2.d_moy = 2+1)
    ├── SORT (inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov, inv2.d_moy, inv2.mean, inv2.cov)
    └── OUTPUT (10 columns as specified)
```

**Change markers:**
- `[~]` All CTEs changed: Converted from original comma-joined subquery to explicit CTE structure with dimension prefetching
- `[=]` Main query unchanged in structure (same join conditions and ordering)

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "multi_dimension_prefetch",
      "description": "Pre-filter selective dimension tables (date_dim, item, warehouse) into separate CTEs with explicit JOIN syntax",
      "applied_to": ["filtered_date_dim", "filtered_item", "filtered_warehouse", "prejoined_inventory"]
    },
    {
      "id": "R2", 
      "type": "explicit_join_conversion",
      "description": "Replace comma-separated implicit joins with explicit INNER JOIN ON syntax",
      "applied_to": ["prejoined_inventory"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date_dim": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_moy FROM date_dim WHERE d_year = 2002",
        "interfaces": {"outputs": ["d_date_sk", "d_moy"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Jewelry', 'Men') AND i_manager_id BETWEEN 81 AND 100",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "filtered_warehouse": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT w_warehouse_sk, w_warehouse_name FROM warehouse",
        "interfaces": {"outputs": ["w_warehouse_sk", "w_warehouse_name"], "consumes": []}
      },
      "prejoined_inventory": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT w_warehouse_sk, w_warehouse_name, i_item_sk, d_moy, inv_quantity_on_hand FROM inventory INNER JOIN filtered_date_dim ON inv_date_sk = d_date_sk INNER JOIN filtered_item ON inv_item_sk = i_item_sk INNER JOIN filtered_warehouse ON inv_warehouse_sk = w_warehouse_sk WHERE inv_quantity_on_hand BETWEEN 0 AND 200",
        "interfaces": {"outputs": ["w_warehouse_sk", "w_warehouse_name", "i_item_sk", "d_moy", "inv_quantity_on_hand"], "consumes": ["filtered_date_dim", "filtered_item", "filtered_warehouse"]}
      },
      "monthly_agg": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT w_warehouse_sk, w_warehouse_name, i_item_sk, d_moy, STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean FROM prejoined_inventory GROUP BY w_warehouse_sk, w_warehouse_name, i_item_sk, d_moy",
        "interfaces": {"outputs": ["w_warehouse_sk", "w_warehouse_name", "i_item_sk", "d_moy", "stdev", "mean"], "consumes": ["prejoined_inventory"]}
      },
      "inv_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT w_warehouse_sk, w_warehouse_name, i_item_sk, d_moy, stdev, mean, CASE mean WHEN 0 THEN NULL ELSE stdev / mean END AS cov FROM monthly_agg WHERE CASE mean WHEN 0 THEN 0 ELSE stdev / mean END > 1",
        "interfaces": {"outputs": ["w_warehouse_sk", "w_warehouse_name", "i_item_sk", "d_moy", "stdev", "mean", "cov"], "consumes": ["monthly_agg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["inv1.w_warehouse_sk", "inv1.i_item_sk", "inv1.d_moy", "inv1.mean", "inv1.cov", "inv2.w_warehouse_sk", "inv2.i_item_sk", "inv2.d_moy", "inv2.mean", "inv2.cov"], "consumes": ["inv_cte"]}
      }
    },
    "reconstruction_order": ["filtered_date_dim", "filtered_item", "filtered_warehouse", "prejoined_inventory", "monthly_agg", "inv_cte", "main_query"],
    "assembly_template": "WITH filtered_date_dim AS ({filtered_date_dim}), filtered_item AS ({filtered_item}), filtered_warehouse AS ({filtered_warehouse}), prejoined_inventory AS ({prejoined_inventory}), monthly_agg AS ({monthly_agg}), inv_cte AS ({inv_cte}) SELECT inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov, inv2.w_warehouse_sk, inv2.i_item_sk, inv2.d_moy, inv2.mean, inv2.cov FROM inv_cte inv1, inv_cte inv2 WHERE inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk AND inv1.d_moy = 2 AND inv2.d_moy = 2+1 ORDER BY inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov, inv2.d_moy, inv2.mean, inv2.cov"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Converted original comma-joined query to explicit CTE structure with dimension prefetching (filtered_date_dim, filtered_item, filtered_warehouse), then explicit INNER JOINs in prejoined_inventory. This preserves semantic equivalence while enabling PostgreSQL's optimizer to create better hash join plans with pre-materialized small dimension results.

**Expected speedup:** ~2-3x from dimension prefetching (reducing probe table sizes) and explicit join syntax (better cardinality estimates). The main benefit comes from isolating selective filters (date_dim 365 rows, item ~500 rows, warehouse ~5 rows) before joining with the large inventory table.