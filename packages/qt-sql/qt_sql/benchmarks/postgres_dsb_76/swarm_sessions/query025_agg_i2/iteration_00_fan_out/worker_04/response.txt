## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~218K
    ├── [~] CTE filtered_d1: date_dim scan with early filter (d_moy=2, d_year=2000)
    ├── [~] CTE filtered_d2: date_dim scan with early filter (d_moy BETWEEN 2-4, d_year=2000)
    ├── [~] CTE filtered_d3: date_dim scan with early filter (d_moy BETWEEN 2-4, d_year=2000)
    ├── [~] CTE store_sales_lateral: LATERAL join between filtered_d1 → store_sales → store → item
    ├── [~] CTE store_returns_lateral: LATERAL join between store_sales_lateral → store_returns (correlated + filtered_d2)
    ├── [~] CTE catalog_sales_lateral: LATERAL join between store_returns_lateral → catalog_sales (correlated + filtered_d3)
    ├── [=] AGG (GROUP BY)
    ├── [=] SORT (i_item_id ASC, i_item_desc ASC, s_store_id ASC, s_store_name ASC)
    └── [=] OUTPUT (i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_profit, store_returns_loss, catalog_sales_profit)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16.11",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter_decorrelate", "description": "Push date_dim filters into separate CTEs before joins", "applied_to": ["filtered_d1", "filtered_d2", "filtered_d3"]},
    {"id": "R2", "type": "inline_decorrelate_materialized", "description": "Replace comma joins with explicit LATERAL joins using pre-filtered date CTEs", "applied_to": ["store_sales_lateral", "store_returns_lateral", "catalog_sales_lateral"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_d1": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 2 AND d_year = 2000",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_d2": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 2 AND 4 AND d_year = 2000",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_d3": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 2 AND 4 AND d_year = 2000",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_sales_lateral": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT store_sales.ss_item_sk, store_sales.ss_customer_sk, store_sales.ss_ticket_number, store_sales.ss_store_sk, store_sales.ss_net_profit, i_item_id, i_item_desc, s_store_id, s_store_name FROM filtered_d1 JOIN LATERAL (SELECT ss_item_sk, ss_customer_sk, ss_ticket_number, ss_store_sk, ss_net_profit FROM store_sales WHERE ss_sold_date_sk = filtered_d1.d_date_sk) AS store_sales ON TRUE JOIN store ON s_store_sk = store_sales.ss_store_sk JOIN item ON i_item_sk = store_sales.ss_item_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_customer_sk", "ss_ticket_number", "ss_store_sk", "ss_net_profit", "i_item_id", "i_item_desc", "s_store_id", "s_store_name"], "consumes": ["filtered_d1"]}
      },
      "store_returns_lateral": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT store_sales_lateral.*, store_returns.sr_net_loss FROM store_sales_lateral JOIN LATERAL (SELECT sr_net_loss FROM store_returns WHERE sr_customer_sk = store_sales_lateral.ss_customer_sk AND sr_item_sk = store_sales_lateral.ss_item_sk AND sr_ticket_number = store_sales_lateral.ss_ticket_number AND sr_returned_date_sk IN (SELECT d_date_sk FROM filtered_d2)) AS store_returns ON TRUE",
        "interfaces": {"outputs": ["ss_item_sk", "ss_customer_sk", "ss_ticket_number", "ss_store_sk", "ss_net_profit", "i_item_id", "i_item_desc", "s_store_id", "s_store_name", "sr_net_loss"], "consumes": ["store_sales_lateral", "filtered_d2"]}
      },
      "catalog_sales_lateral": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, ss_net_profit, sr_net_loss, cs_net_profit FROM store_returns_lateral JOIN LATERAL (SELECT cs_net_profit FROM catalog_sales WHERE cs_bill_customer_sk = store_returns_lateral.ss_customer_sk AND cs_item_sk = store_returns_lateral.ss_item_sk AND cs_sold_date_sk IN (SELECT d_date_sk FROM filtered_d3)) AS catalog_sales ON TRUE",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "ss_net_profit", "sr_net_loss", "cs_net_profit"], "consumes": ["store_returns_lateral", "filtered_d3"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, STDDEV_SAMP(ss_net_profit) AS store_sales_profit, STDDEV_SAMP(sr_net_loss) AS store_returns_loss, STDDEV_SAMP(cs_net_profit) AS catalog_sales_profit FROM catalog_sales_lateral GROUP BY i_item_id, i_item_desc, s_store_id, s_store_name ORDER BY i_item_id, i_item_desc, s_store_id, s_store_name LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_profit", "store_returns_loss", "catalog_sales_profit"], "consumes": ["catalog_sales_lateral"]}
      }
    },
    "reconstruction_order": ["filtered_d1", "filtered_d2", "filtered_d3", "store_sales_lateral", "store_returns_lateral", "catalog_sales_lateral", "main_query"],
    "assembly_template": "WITH filtered_d1 AS ({filtered_d1}), filtered_d2 AS ({filtered_d2}), filtered_d3 AS ({filtered_d3}), store_sales_lateral AS ({store_sales_lateral}), store_returns_lateral AS ({store_returns_lateral}), catalog_sales_lateral AS ({catalog_sales_lateral}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL work_mem = '32MB'"
  ],
  "validation_checks": []
}
```

**Changes**: Replaced comma joins with explicit LATERAL joins anchored to pre-filtered date CTEs, forcing join order (d1→store_sales→store→item→store_returns→catalog_sales). This ensures each date dimension is filtered once and cardinalities are fixed before probing fact tables.

**Expected speedup**: 1.5-2× due to reduced nested-loop ambiguity and early date filtering, though LATERAL may add overhead if row counts are high. Hash joins are enforced to prevent nested loops.