### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~17K
    ├── [~] dim_keys_cte  [MATERIALIZED CTE replacing implicit dimension cartesian product]
    │   ├── SCAN date_dim (filtered: d_month_seq BETWEEN 1192 AND 1192 + 23)
    │   ├── SCAN warehouse (filtered: w_gmt_offset = -5)
    │   ├── SCAN ship_mode (filtered: sm_type = 'EXPRESS')
    │   └── SCAN call_center (filtered: cc_class = 'small')
    ├── [~] fact_join_cte  [INNER JOIN with dim_keys_cte instead of comma joins]
    │   ├── SCAN catalog_sales (filtered: cs_list_price BETWEEN 86 AND 115)
    │   └── JOIN (cs_ship_date_sk = d_date_sk, cs_warehouse_sk = w_warehouse_sk, 
    │             cs_ship_mode_sk = sm_ship_mode_sk, cs_call_center_sk = cc_call_center_sk)
    ├── [=] AGG (GROUP BY)
    ├── [=] SORT (SUBSTRING(w_warehouse_name FROM 1 FOR 20) ASC, sm_type ASC, cc_name ASC)
    └── [=] OUTPUT
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "pg_dimension_prefetch_star", "description": "Prefilter selective dimensions into materialized CTE to create small hash table", "applied_to": ["dim_keys_cte"]},
    {"id": "R2", "type": "pg_materialized_dimension_fact_prefilter", "description": "Materialize dimension CTE to avoid repeated scans and enable better join planning", "applied_to": ["dim_keys_cte"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "dim_keys_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, w_warehouse_sk, w_warehouse_name, sm_ship_mode_sk, sm_type, cc_call_center_sk, cc_name FROM (SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1192 AND 1192 + 23) date_dim, (SELECT w_warehouse_sk, w_warehouse_name FROM warehouse WHERE w_gmt_offset = -5) warehouse, (SELECT sm_ship_mode_sk, sm_type FROM ship_mode WHERE sm_type = 'EXPRESS') ship_mode, (SELECT cc_call_center_sk, cc_name FROM call_center WHERE cc_class = 'small') call_center",
        "interfaces": {"outputs": ["d_date_sk", "w_warehouse_sk", "w_warehouse_name", "sm_ship_mode_sk", "sm_type", "cc_call_center_sk", "cc_name"], "consumes": []}
      },
      "fact_join_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs.cs_ship_date_sk, cs.cs_sold_date_sk, dk.w_warehouse_name, dk.sm_type, dk.cc_name FROM catalog_sales cs INNER JOIN dim_keys_cte dk ON cs.cs_ship_date_sk = dk.d_date_sk AND cs.cs_warehouse_sk = dk.w_warehouse_sk AND cs.cs_ship_mode_sk = dk.sm_ship_mode_sk AND cs.cs_call_center_sk = dk.cc_call_center_sk WHERE cs.cs_list_price BETWEEN 86 AND 115",
        "interfaces": {"outputs": ["cs_ship_date_sk", "cs_sold_date_sk", "w_warehouse_name", "sm_type", "cc_name"], "consumes": ["dim_keys_cte"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT substring(w_warehouse_name,1,20) AS wh_name_sub, sm_type, cc_name, sum(CASE WHEN (cs_ship_date_sk - cs_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS \"30 days\", sum(CASE WHEN (cs_ship_date_sk - cs_sold_date_sk > 30 AND cs_ship_date_sk - cs_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS \"31-60 days\", sum(CASE WHEN (cs_ship_date_sk - cs_sold_date_sk > 60 AND cs_ship_date_sk - cs_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS \"61-90 days\", sum(CASE WHEN (cs_ship_date_sk - cs_sold_date_sk > 90 AND cs_ship_date_sk - cs_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS \"91-120 days\", sum(CASE WHEN (cs_ship_date_sk - cs_sold_date_sk > 120) THEN 1 ELSE 0 END) AS \">120 days\" FROM fact_join_cte GROUP BY substring(w_warehouse_name,1,20), sm_type, cc_name ORDER BY substring(w_warehouse_name,1,20), sm_type, cc_name LIMIT 100",
        "interfaces": {"outputs": ["wh_name_sub", "sm_type", "cc_name", "30 days", "31-60 days", "61-90 days", "91-120 days", ">120 days"], "consumes": ["fact_join_cte"]}
      }
    },
    "reconstruction_order": ["dim_keys_cte", "fact_join_cte", "main_query"],
    "assembly_template": "WITH dim_keys_cte AS (MATERIALIZED {dim_keys_cte}), fact_join_cte AS ({fact_join_cte}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Pre-filtered all selective dimensions into a single materialized CTE (dim_keys_cte) that computes the Cartesian product upfront, then explicitly INNER JOINs with the fact table using equi-joins. This eliminates the comma-join weakness where PostgreSQL scans dimensions repeatedly in nested loops.

**Expected speedup:** 2-3x by eliminating repeated dimension scans (2,193 loops per dimension in original) and enabling hash join planning on the materialized dimension keys. The materialized CTE with ~5,856 rows creates a small hash table that can be joined efficiently with the filtered fact rows.