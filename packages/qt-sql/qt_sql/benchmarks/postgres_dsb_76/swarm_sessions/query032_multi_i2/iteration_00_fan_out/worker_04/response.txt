## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [!] main_query  [~]  Cost: 100%  Rows: ~1K
    ├── [!] WITH main_explicit AS (CTE)
    │   ├── [~] SCAN (item INNER JOIN catalog_sales INNER JOIN date_dim)  -- comma → explicit JOIN
    │   ├── [=] JOIN (i_item_sk = cs_item_sk)
    │   ├── [=] JOIN (d_date_sk = cs_sold_date_sk)
    │   ├── [=] FILTER ((i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71))
    │   ├── [=] FILTER (d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY')
    │   ├── [=] FILTER (cs_ext_discount_amt > correlated subquery)
    │   └── [=] OUTPUT (cs_ext_discount_amt)
    └── [!] final_aggregation (CTE)
        ├── [!] FROM main_explicit
        ├── [~] AGGREGATE (SUM(cs_ext_discount_amt) AS "excess discount amount")
        ├── [=] SORT (SUM(cs_ext_discount_amt) ASC)
        ├── [=] LIMIT 100
        └── [=] OUTPUT ("excess discount amount")
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "comma_to_explicit_join", "description": "Convert comma joins to explicit INNER JOIN syntax in main query and subquery", "applied_to": ["main_explicit", "correlated_subquery"]},
    {"id": "R2", "type": "cte_encapsulation", "description": "Wrap logical steps as explicit CTEs per target tree", "applied_to": ["main_explicit", "final_aggregation"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "main_explicit": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs_ext_discount_amt FROM item INNER JOIN catalog_sales ON i_item_sk = cs_item_sk INNER JOIN date_dim ON d_date_sk = cs_sold_date_sk WHERE (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND cs_ext_discount_amt > (SELECT 1.3 * AVG(cs_ext_discount_amt) FROM catalog_sales cs2 INNER JOIN date_dim dd2 ON cs2.cs_sold_date_sk = dd2.d_date_sk WHERE cs2.cs_item_sk = item.i_item_sk AND dd2.d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND cs2.cs_list_price BETWEEN 115 AND 144 AND cs2.cs_sales_price / cs2.cs_list_price BETWEEN 0.21 AND 0.41)",
        "interfaces": {"outputs": ["cs_ext_discount_amt"], "consumes": []}
      },
      "final_aggregation": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\" FROM main_explicit ORDER BY SUM(cs_ext_discount_amt) LIMIT 100",
        "interfaces": {"outputs": ["excess discount amount"], "consumes": ["main_explicit"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "WITH main_explicit AS (SELECT cs_ext_discount_amt FROM item INNER JOIN catalog_sales ON i_item_sk = cs_item_sk INNER JOIN date_dim ON d_date_sk = cs_sold_date_sk WHERE (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND cs_ext_discount_amt > (SELECT 1.3 * AVG(cs_ext_discount_amt) FROM catalog_sales cs2 INNER JOIN date_dim dd2 ON cs2.cs_sold_date_sk = dd2.d_date_sk WHERE cs2.cs_item_sk = item.i_item_sk AND dd2.d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND cs2.cs_list_price BETWEEN 115 AND 144 AND cs2.cs_sales_price / cs2.cs_list_price BETWEEN 0.21 AND 0.41)), final_aggregation AS (SELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\" FROM main_explicit ORDER BY SUM(cs_ext_discount_amt) LIMIT 100) SELECT \"excess discount amount\" FROM final_aggregation",
        "interfaces": {"outputs": ["excess discount amount"], "consumes": ["final_aggregation"]}
      }
    },
    "reconstruction_order": ["main_explicit", "final_aggregation", "main_query"],
    "assembly_template": "WITH main_explicit AS ({main_explicit}), final_aggregation AS ({final_aggregation}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '512MB'", "SET LOCAL random_page_cost = 2.5"],
  "validation_checks": []
}
```

**Changes:** Converted comma joins to explicit INNER JOIN syntax and encapsulated logical steps as CTEs per target tree, preserving all original semantics including the correlated subquery and OR condition.

**Expected speedup:** Minimal (0.9-1.1x) - mainly provides cleaner structure for future optimization. The SET LOCAL changes anticipate hash joins and index scans: higher work_mem for the large outer hash join (item × catalog_sales × date_dim) and lower random_page_cost because the outer date_dim scan will be selective via d_date range index.