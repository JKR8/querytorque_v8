## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K
    ├── [CTE] filtered_dates  [+]
    │   ├── SCAN date_dim
    │   └── FILTER (d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY')
    ├── [CTE] filtered_items  [+]
    │   ├── SCAN item
    │   └── FILTER (i_manufact_id IN (184,307,365,560,681) OR i_manager_id BETWEEN 42 AND 71)
    ├── [CTE] main_explicit_join  [+]
    │   ├── HASH JOIN (INNER) filtered_items ↔ catalog_sales ON i_item_sk = cs_item_sk
    │   ├── HASH JOIN (INNER) ↔ filtered_dates ON cs_sold_date_sk = d_date_sk
    │   ├── FILTER (cs_ext_discount_amt > correlated_subquery)
    │   └── CORRELATED SUBQUERY
    │       ├── HASH JOIN (INNER) catalog_sales cs2 ↔ filtered_dates fd2
    │       ├── FILTER (cs2.cs_item_sk = filtered_items.i_item_sk)
    │       ├── FILTER (cs2.cs_list_price BETWEEN 115 AND 144)
    │       └── FILTER (cs2.cs_sales_price / cs2.cs_list_price BETWEEN 21*0.01 AND 41*0.01)
    └── [AGGREGATE] final_aggregation  [~]
        ├── SCAN main_explicit_join
        ├── AGGREGATE (SUM(cs_ext_discount_amt))
        ├── SORT (SUM(cs_ext_discount_amt) ASC)
        └── LIMIT 100
```

**Structural changes:**
- Added `filtered_dates` CTE to pre-filter date_dim (90 rows)
- Added `filtered_items` CTE to pre-filter item (thousands of rows)
- Converted comma joins to explicit INNER JOIN syntax
- Preserved correlated subquery but now uses filtered_dates CTE (aliased as fd2)
- Kept all original literals, division guards, and OR condition unchanged

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "dimension_prefilter_cte",
      "description": "Materialize selective date and item filters into CTEs before joining",
      "applied_to": ["filtered_dates", "filtered_items"]
    },
    {
      "id": "R2",
      "type": "explicit_join_syntax",
      "description": "Convert comma joins to explicit INNER JOIN syntax for better cardinality estimation",
      "applied_to": ["main_explicit_join"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_dates": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY'",
          "interfaces": {
            "outputs": ["d_date_sk", "d_date"],
            "consumes": []
          }
        },
        "filtered_items": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT i_item_sk, i_manufact_id, i_manager_id FROM item WHERE i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71",
          "interfaces": {
            "outputs": ["i_item_sk", "i_manufact_id", "i_manager_id"],
            "consumes": []
          }
        },
        "main_explicit_join": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT cs_ext_discount_amt FROM filtered_items INNER JOIN catalog_sales ON filtered_items.i_item_sk = catalog_sales.cs_item_sk INNER JOIN filtered_dates ON catalog_sales.cs_sold_date_sk = filtered_dates.d_date_sk WHERE catalog_sales.cs_ext_discount_amt > (SELECT 1.3 * AVG(cs2.cs_ext_discount_amt) FROM catalog_sales cs2 INNER JOIN filtered_dates fd2 ON cs2.cs_sold_date_sk = fd2.d_date_sk WHERE cs2.cs_item_sk = filtered_items.i_item_sk AND cs2.cs_list_price BETWEEN 115 AND 144 AND cs2.cs_sales_price / cs2.cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01)",
          "interfaces": {
            "outputs": ["cs_ext_discount_amt"],
            "consumes": ["filtered_dates", "filtered_items"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\" FROM main_explicit_join ORDER BY SUM(cs_ext_discount_amt) LIMIT 100",
          "interfaces": {
            "outputs": ["excess discount amount"],
            "consumes": ["main_explicit_join"]
          }
        }
      },
      "reconstruction_order": ["filtered_dates", "filtered_items", "main_explicit_join", "main_query"],
      "assembly_template": "WITH filtered_dates AS ({filtered_dates}), filtered_items AS ({filtered_items}), main_explicit_join AS ({main_explicit_join}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL enable_mergejoin = off",
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL work_mem = '64MB'",
    "SET LOCAL hash_mem_multiplier = 2.0",
    "SET LOCAL random_page_cost = 1.5"
  ],
  "validation_checks": []
}
```

**Mechanism:** The rewrite pre-filters date_dim and item into small CTEs, then performs explicit hash joins instead of comma joins. This reduces the hash table build cost and gives PostgreSQL better cardinality estimates. The correlated subquery remains but now joins with the tiny filtered_dates CTE (90 rows) instead of the full date_dim table.

**Expected speedup:** ~2-3x due to reduced hash table sizes and better join planning. The biggest gains come from building hash tables from 90-date rows instead of full date_dim, and thousands of items instead of full item table.