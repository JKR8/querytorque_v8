## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  (CTE-based pipeline replaces correlated subquery)
    ├── CTE filtered_dates  [+]
    │   ├── SCAN date_dim
    │   └── FILTER (d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY')
    ├── CTE filtered_items  [+]
    │   ├── SCAN item
    │   └── FILTER (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71)
    ├── CTE consolidated_scan  [+]
    │   ├── JOIN (catalog_sales INNER JOIN filtered_dates ON cs_sold_date_sk = d_date_sk)
    │   ├── JOIN (catalog_sales INNER JOIN filtered_items ON cs_item_sk = i_item_sk)
    │   └── PROJECT (CASE WHEN cs_list_price BETWEEN 115 AND 144 AND cs_sales_price/cs_list_price BETWEEN 0.21 AND 0.41 THEN cs_ext_discount_amt END)
    ├── CTE pivot_filter  [+]
    │   ├── WINDOW (PARTITION BY cs_item_sk, AVG(subq_discount_amt))
    │   ├── CALCULATE (threshold = 1.3 * AVG(subq_discount_amt))
    │   └── FILTER (cs_ext_discount_amt > threshold)
    └── FINAL_AGGREGATION  [~]
        ├── AGGREGATE (SUM(cs_ext_discount_amt))
        ├── SORT (SUM(cs_ext_discount_amt))
        └── LIMIT 100
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "correlated_subquery_to_window", "description": "Replace correlated subquery with CASE and window AVG", "applied_to": ["consolidated_scan", "pivot_filter"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY'",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "filtered_items": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk, i_manufact_id, i_manager_id FROM item WHERE i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71",
        "interfaces": {"outputs": ["i_item_sk", "i_manufact_id", "i_manager_id"], "consumes": []}
      },
      "consolidated_scan": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cs.cs_item_sk, cs.cs_ext_discount_amt, CASE WHEN cs.cs_list_price BETWEEN 115 AND 144 AND cs.cs_sales_price / cs.cs_list_price BETWEEN 0.21 AND 0.41 THEN cs.cs_ext_discount_amt END AS subq_discount_amt FROM catalog_sales cs INNER JOIN filtered_dates fd ON cs.cs_sold_date_sk = fd.d_date_sk INNER JOIN filtered_items fi ON cs.cs_item_sk = fi.i_item_sk WHERE (cs.cs_list_price BETWEEN 115 AND 144 AND cs.cs_sales_price / cs.cs_list_price BETWEEN 0.21 AND 0.41) OR (1=1)",
        "interfaces": {"outputs": ["cs_item_sk", "cs_ext_discount_amt", "subq_discount_amt"], "consumes": ["filtered_dates", "filtered_items"]}
      },
      "pivot_filter": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cs_ext_discount_amt FROM (SELECT cs_ext_discount_amt, 1.3 * AVG(subq_discount_amt) OVER (PARTITION BY cs_item_sk) AS threshold FROM consolidated_scan) t WHERE cs_ext_discount_amt > threshold",
        "interfaces": {"outputs": ["cs_ext_discount_amt"], "consumes": ["consolidated_scan"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\" FROM pivot_filter ORDER BY SUM(cs_ext_discount_amt) LIMIT 100",
        "interfaces": {"outputs": ["excess discount amount"], "consumes": ["pivot_filter"]}
      }
    },
    "reconstruction_order": ["filtered_dates", "filtered_items", "consolidated_scan", "pivot_filter", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), filtered_items AS ({filtered_items}), consolidated_scan AS ({consolidated_scan}), pivot_filter AS ({pivot_filter}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '64MB'", "SET LOCAL enable_hashjoin = off", "SET LOCAL enable_nestloop = off", "SET LOCAL max_parallel_workers_per_gather = 2"],
  "validation_checks": []
}
```

**Changes**: Replaced correlated subquery with single-pass window aggregation using CASE to isolate subquery rows, preserving exact AVG semantics and date filter application.

**Expected speedup**: ~3-5x by eliminating per-row subquery execution while maintaining semantic equivalence.