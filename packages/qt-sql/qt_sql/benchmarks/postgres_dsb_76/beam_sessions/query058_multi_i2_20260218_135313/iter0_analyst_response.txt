{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The plan shows three independent CTE branches scanning large fact tables (store_sales, catalog_sales, web_sales) with nested loops and late filtering on date_dim. The dominant hotspot is store_sales branch (2799 ms, 77% of total), with severe cardinality underestimation (est=16 vs actual=972 rows). Repeated date_dim scans and comma joins block predicate pushdown and efficient join ordering.",
    "reasoning_trace": [
      "Store_sales branch dominates runtime (2799 ms), catalog_sales 573 ms, web_sales 259 ms.",
      "Cardinality estimation error: Sort node estimated 16 rows, actual 972 rows (Q-error ~60).",
      "Each CTE repeats identical date_dim subquery (d_month_seq lookup) causing redundant work.",
      "Comma-join syntax prevents optimal join reordering; nested loops multiply dimension table scans.",
      "No correlated scalar subqueries present; plan shows decorrelated hash joins for date condition."
    ],
    "cost_spine": ["Nested Loop (store_sales)", "Hash Join (date_dim)", "Sort", "Aggregate", "Merge Join (final)"],
    "hotspots": [
      {
        "op": "Nested Loop (store_sales branch)",
        "why": "Dominant fact table scan with nested loops to item/customer, amplified by late date filtering",
        "evidence": "rows=27168 time=466 ms, followed by 8766 nested loops to item and customer"
      },
      {
        "op": "Sort (store_sales branch)",
        "why": "Severe cardinality underestimation leads to under-provisioned sort memory",
        "evidence": "est=16 rows, act=972 rows, time=1400 ms"
      },
      {
        "op": "Hash Join (date_dim subquery)",
        "why": "Repeated identical date range computation across three CTEs",
        "evidence": "Three separate hash joins on date_dim with same d_month_seq filter"
      }
    ],
    "do_not_do": [
      "Avoid OR-to-UNION transforms (no OR predicates in plan)",
      "Do not decorrelate already-decorrelated date subqueries",
      "Do not duplicate heavy CTE bodies for each channel",
      "Avoid materializing simple EXISTS paths (none exist)"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "target": "Extract shared date_dim filter into a single CTE returning d_date_sk for the target month_seq, then reference this CTE in all three channel CTEs via join instead of subquery.",
      "dag_target_hint": "Replace date_dim subquery in ss_items, cs_items, ws_items with JOIN to date_range_cte.",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_month_seq = (select d_month_seq from date_dim where d_date = '2001-06-06')"],
        "output_must_preserve": ["All original fact table rows matching date condition"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Three hash joins on date_dim collapse to one CTE scan; date filter applied once; nested loops may reduce.",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate", "replace_from"],
      "rank_rationale": "Primary hotspot mitigation — eliminates redundant date_dim scans across all three branches.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p02",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre-filter date_dim, item, and customer into separate CTEs with selective predicates, then join them with store_sales using explicit JOIN syntax.",
      "dag_target_hint": "Rewrite ss_items CTE to use explicit JOINs on pre-filtered dimension CTEs.",
      "node_contract": {
        "from_must_include": ["store_sales", "item", "date_dim", "customer"],
        "where_must_preserve": ["ss_list_price BETWEEN 168 AND 197", "i_manager_id BETWEEN 42 AND 71", "c_birth_year BETWEEN 1985 AND 1991"],
        "output_must_preserve": ["i_item_id", "c_birth_year", "sum(ss_ext_sales_price)"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.78,
      "expected_explain_delta": "Nested loops replaced by hash joins with tiny dimension CTEs; store_sales scan filtered earlier.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "convert_comma_to_join"],
      "rank_rationale": "Targets primary hotspot — reduces nested loop amplification by prefetching selective dimensions.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p03",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate store_sales by ss_item_sk and ss_customer_sk within date range before joining with item and customer dimensions.",
      "dag_target_hint": "Change ss_items CTE to aggregate store_sales first, then join to filtered dimensions.",
      "node_contract": {
        "from_must_include": ["store_sales"],
        "where_must_preserve": ["ss_list_price BETWEEN 168 AND 197", "ss_sold_date_sk IN date_range_keys"],
        "output_must_preserve": ["Grouping keys compatible with item.i_item_sk and customer.c_customer_sk"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Pre-aggregating fact table before joining dimensions may reduce rows entering nested loops.",
      "confidence": 0.65,
      "expected_explain_delta": "Aggregate moves below joins; input to nested loops reduces from thousands to hundreds.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Exploration — aims to reduce nested loop input volume in primary hotspot.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p04",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize the filtered store_sales + date_dim join once as a CTE, then derive aggregates for ss_items from it.",
      "dag_target_hint": "Create a base CTE with store_sales joined to date_range, then compute aggregates.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim"],
        "where_must_preserve": ["ss_list_price BETWEEN 168 AND 197", "date condition"],
        "output_must_preserve": ["ss_item_sk", "ss_customer_sk", "ss_ext_sales_price"]
      },
      "gates_checked": ["G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Materializing the fact-date join may improve cardinality estimates and reduce repeated computation.",
      "confidence": 0.55,
      "expected_explain_delta": "Materialized CTE provides stable row count; downstream sorts may become more efficient.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Exploration — addresses cardinality estimation error in sort node via materialization.",
      "recommended_examples": ["pg_self_join_decomposition"],
      "gold_example_id": ""
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate in plan; PostgreSQL BitmapOr already optimal for indexed OR."
    },
    {
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "reason": "Previous attempt failed (speedup=0.00x); plan shows date subquery already decorrelated via hash join."
    },
    {
      "transform_id": "date_cte_explicit_join",
      "family": "A",
      "reason": "Previous attempt failed (speedup=0.00x); but shared_dimension_multi_channel is a more targeted variant."
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "No LEFT JOIN followed by WHERE filter in query; all joins are inner."
    },
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated scalar aggregate subqueries; date condition uses IN with already-decorrelated subquery."
    },
    {
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "reason": "Designed for non-equi joins; final join has non-equi conditions but not the primary bottleneck."
    }
  ]
}