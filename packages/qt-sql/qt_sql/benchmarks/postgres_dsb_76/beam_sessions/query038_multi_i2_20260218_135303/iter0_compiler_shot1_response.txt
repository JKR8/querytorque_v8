[
  {
    "plan_id": "compile_p1",
    "dialect": "postgres",
    "confidence": 0.7,
    "based_on": "",
    "strategy": "Replace INTERSECT with EXISTS correlated subqueries, using store_sales branch as driver, to avoid materializing three large distinct sets and performing expensive set intersection.",
    "hypothesis": "Primary hotspot is SetOp materialization of three large distinct result sets. EXISTS rewrite avoids full distinct materialization for catalog_sales and web_sales branches, correlating on projected columns (c_last_name, c_first_name, d_date). This eliminates the SetOp operator entirely.",
    "expected_explain_delta": "SetOp disappears; nested-loop joins with EXISTS subqueries replace three distinct materializations.",
    "target_ir": "Replace INTERSECT with EXISTS, keep explicit JOINs, maintain distinct on driver branch only.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["store_sales_set"],
          "outputs": ["*"],
          "changed": true,
          "sql": "WITH store_sales_set AS (\n    SELECT DISTINCT customer.c_last_name, customer.c_first_name, date_dim.d_date\n    FROM store_sales\n    JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n    JOIN customer ON store_sales.ss_customer_sk = customer.c_customer_sk\n    WHERE date_dim.d_month_seq BETWEEN 1207 AND 1207 + 11\n      AND customer.c_birth_month IN (2, 3, 4, 10)\n      AND store_sales.ss_list_price BETWEEN 241 AND 300\n      AND store_sales.ss_wholesale_cost BETWEEN 76 AND 96\n)\nSELECT COUNT(*)\nFROM store_sales_set s\nWHERE EXISTS (\n    SELECT 1\n    FROM catalog_sales\n    JOIN date_dim d2 ON catalog_sales.cs_sold_date_sk = d2.d_date_sk\n    JOIN customer c2 ON catalog_sales.cs_bill_customer_sk = c2.c_customer_sk\n    WHERE d2.d_month_seq BETWEEN 1207 AND 1207 + 11\n      AND c2.c_birth_month IN (2, 3, 4, 10)\n      AND catalog_sales.cs_list_price BETWEEN 241 AND 300\n      AND catalog_sales.cs_wholesale_cost BETWEEN 76 AND 96\n      AND c2.c_last_name = s.c_last_name\n      AND c2.c_first_name = s.c_first_name\n      AND d2.d_date = s.d_date\n)\nAND EXISTS (\n    SELECT 1\n    FROM web_sales\n    JOIN date_dim d3 ON web_sales.ws_sold_date_sk = d3.d_date_sk\n    JOIN customer c3 ON web_sales.ws_bill_customer_sk = c3.c_customer_sk\n    WHERE d3.d_month_seq BETWEEN 1207 AND 1207 + 11\n      AND c3.c_birth_month IN (2, 3, 4, 10)\n      AND web_sales.ws_list_price BETWEEN 241 AND 300\n      AND web_sales.ws_wholesale_cost BETWEEN 76 AND 96\n      AND c3.c_last_name = s.c_last_name\n      AND c3.c_first_name = s.c_first_name\n      AND d3.d_date = s.d_date\n)\nLIMIT 100;"
        },
        {
          "node_id": "store_sales_set",
          "parent_node_id": "final_select",
          "sources": ["store_sales", "date_dim", "customer"],
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "changed": true,
          "sql": "SELECT DISTINCT customer.c_last_name, customer.c_first_name, date_dim.d_date\nFROM store_sales\nJOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\nJOIN customer ON store_sales.ss_customer_sk = customer.c_customer_sk\nWHERE date_dim.d_month_seq BETWEEN 1207 AND 1207 + 11\n  AND customer.c_birth_month IN (2, 3, 4, 10)\n  AND store_sales.ss_list_price BETWEEN 241 AND 300\n  AND store_sales.ss_wholesale_cost BETWEEN 76 AND 96"
        }
      ]
    }
  },
  {
    "plan_id": "compile_p2",
    "dialect": "postgres",
    "confidence": 0.65,
    "based_on": "",
    "strategy": "Replace INTERSECT with UNION ALL + GROUP BY, computing distinct per branch then counting triples appearing in all three branches.",
    "hypothesis": "SetOp materialization is the dominant cost. Union-all of distinct branch results followed by aggregation (HAVING COUNT(*) = 3) avoids expensive set intersection operator and may allow hash aggregation.",
    "expected_explain_delta": "SetOp replaced by Union All and HashAggregate; three distinct operations remain but no intersect materialization.",
    "target_ir": "Replace INTERSECT with UNION ALL and outer aggregation, keep explicit JOINs.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": [],
          "outputs": ["*"],
          "changed": true,
          "sql": "SELECT COUNT(*)\nFROM (\n    SELECT c_last_name, c_first_name, d_date\n    FROM (\n        SELECT DISTINCT customer.c_last_name, customer.c_first_name, date_dim.d_date\n        FROM store_sales\n        JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n        JOIN customer ON store_sales.ss_customer_sk = customer.c_customer_sk\n        WHERE date_dim.d_month_seq BETWEEN 1207 AND 1207 + 11\n          AND customer.c_birth_month IN (2, 3, 4, 10)\n          AND store_sales.ss_list_price BETWEEN 241 AND 300\n          AND store_sales.ss_wholesale_cost BETWEEN 76 AND 96\n        UNION ALL\n        SELECT DISTINCT customer.c_last_name, customer.c_first_name, date_dim.d_date\n        FROM catalog_sales\n        JOIN date_dim ON catalog_sales.cs_sold_date_sk = date_dim.d_date_sk\n        JOIN customer ON catalog_sales.cs_bill_customer_sk = customer.c_customer_sk\n        WHERE date_dim.d_month_seq BETWEEN 1207 AND 1207 + 11\n          AND customer.c_birth_month IN (2, 3, 4, 10)\n          AND catalog_sales.cs_list_price BETWEEN 241 AND 300\n          AND catalog_sales.cs_wholesale_cost BETWEEN 76 AND 96\n        UNION ALL\n        SELECT DISTINCT customer.c_last_name, customer.c_first_name, date_dim.d_date\n        FROM web_sales\n        JOIN date_dim ON web_sales.ws_sold_date_sk = date_dim.d_date_sk\n        JOIN customer ON web_sales.ws_bill_customer_sk = customer.c_customer_sk\n        WHERE date_dim.d_month_seq BETWEEN 1207 AND 1207 + 11\n          AND customer.c_birth_month IN (2, 3, 4, 10)\n          AND web_sales.ws_list_price BETWEEN 241 AND 300\n          AND web_sales.ws_wholesale_cost BETWEEN 76 AND 96\n    ) t\n    GROUP BY c_last_name, c_first_name, d_date\n    HAVING COUNT(*) = 3\n) hot_cust\nLIMIT 100;"
        }
      ]
    }
  }
]