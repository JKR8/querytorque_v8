[
  {
    "plan_id": "snipe_p1",
    "dialect": "postgres",
    "confidence": 0.85,
    "based_on": "p02,p01",
    "strategy": "Explicit JOINs + date range isolation",
    "hypothesis": "Original comma joins cause poor row estimates. Materializing filtered d1/d2 and using explicit JOIN syntax will enable better join ordering. The d2 BETWEEN condition is a non-equi join bottleneck that benefits from precomputation.",
    "target_ir": "CTEs for date ranges + explicit JOINs",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "WITH d1_cte AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_year = 2000),\nd2_cte AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN (SELECT MIN(d_date) FROM d1_cte) AND (SELECT MAX(d_date) + INTERVAL '90 day' FROM d1_cte))\nSELECT c_customer_sk, c_first_name, c_last_name, COUNT(*) AS cnt\nFROM store_sales ss\nJOIN store_returns sr ON ss.ss_ticket_number = sr.sr_ticket_number AND ss.ss_item_sk = sr.sr_item_sk\nJOIN web_sales ws ON ss.ss_customer_sk = ws.ws_bill_customer_sk AND sr.sr_item_sk = ws.ws_item_sk\nJOIN d1_cte d1 ON sr.sr_returned_date_sk = d1.d_date_sk\nJOIN d2_cte d2 ON ws.ws_sold_date_sk = d2.d_date_sk\nJOIN item i ON i.i_item_sk = ss.ss_item_sk\nJOIN customer c ON ss.ss_customer_sk = c.c_customer_sk\nJOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk\nJOIN household_demographics hd ON c.c_current_hdemo_sk = hd.hd_demo_sk\nWHERE i.i_category IN ('Children', 'Home', 'Women')\n  AND ca.ca_state IN ('AR', 'GA', 'IN', 'KY', 'VA')\n  AND hd.hd_income_band_sk BETWEEN 8 AND 14\n  AND hd.hd_buy_potential = '501-1000'\n  AND ss.ss_sales_price / ss.ss_list_price BETWEEN 76 * 0.01 AND 96 * 0.01\nGROUP BY c_customer_sk, c_first_name, c_last_name\nORDER BY cnt;"
        }
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "postgres",
    "confidence": 0.75,
    "based_on": "p03,p06",
    "strategy": "Dimension prefiltering + fact reduction",
    "hypothesis": "Late filtering of store_returns amplifies rows. Pre-joining selective dimensions (d1, item, hd) with store_returns in CTEs reduces intermediate rows before joining with store_sales. Avoids comma join weakness while reducing nested loop input.",
    "target_ir": "Filtered dimension CTEs + pre-joined facts",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "WITH filtered_dims AS (\n  SELECT d1.d_date_sk, i.i_item_sk, hd.hd_demo_sk\n  FROM date_dim d1, item i, household_demographics hd\n  WHERE d1.d_year = 2000\n    AND i.i_category IN ('Children', 'Home', 'Women')\n    AND hd.hd_income_band_sk BETWEEN 8 AND 14\n    AND hd.hd_buy_potential = '501-1000'\n), \nprejoined_returns AS (\n  SELECT sr.sr_ticket_number, sr.sr_item_sk, sr.sr_returned_date_sk\n  FROM store_returns sr\n  JOIN filtered_dims fd ON sr.sr_returned_date_sk = fd.d_date_sk AND sr.sr_item_sk = fd.i_item_sk\n)\nSELECT c.c_customer_sk, c.c_first_name, c.c_last_name, COUNT(*) AS cnt\nFROM store_sales ss\nJOIN prejoined_returns pr ON ss.ss_ticket_number = pr.sr_ticket_number AND ss.ss_item_sk = pr.sr_item_sk\nJOIN web_sales ws ON ss.ss_customer_sk = ws.ws_bill_customer_sk AND pr.sr_item_sk = ws.ws_item_sk\nJOIN date_dim d2 ON ws.ws_sold_date_sk = d2.d_date_sk\nJOIN customer c ON ss.ss_customer_sk = c.c_customer_sk\nJOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk\nJOIN filtered_dims fd ON c.c_current_hdemo_sk = fd.hd_demo_sk\nWHERE ca.ca_state IN ('AR', 'GA', 'IN', 'KY', 'VA')\n  AND d2.d_date BETWEEN (SELECT MIN(d_date) FROM filtered_dims) AND (SELECT MIN(d_date) + INTERVAL '90 day' FROM filtered_dims)\n  AND ss.ss_sales_price / ss.ss_list_price BETWEEN 76 * 0.01 AND 96 * 0.01\nGROUP BY c.c_customer_sk, c.c_first_name, c.c_last_name\nORDER BY cnt;"
        }
      }
    ]
  }
]