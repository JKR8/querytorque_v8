### Analysis & Dispatch Strategy

**Hypothesis:** The query has three correlated subqueries (one EXISTS and two NOT EXISTS) scanning large fact tables (store_sales, web_sales, catalog_sales) with identical date filters. PostgreSQL likely executes these as nested loops, re-scanning fact tables per customer row. Decorrelating these subqueries (Family B) into pre-materialized CTEs should replace per-row re-execution with single-pass joins. Additionally, comma-joins in the main query may cause poor cardinality estimates (exploiting `COMMA_JOIN_WEAKNESS`).

**Cost Spine & Hotspots:**  
- **Primary Hotspot:** Correlated subqueries re-executing for each customer row (nested loops)  
- **Secondary Hotspot:** Comma-join syntax limiting join-order optimization  
- **Evidence:** Correlated EXISTS/NOT EXISTS patterns with identical date filters across large fact tables  

**Probe Selection Rationale:**  
- Importance ★★ (medium) → **10 probes** (within 8–12 range)  
- Early Stop: `false` (multiple clear optimization opportunities)  
- Equivalence Tier: `exact` (deterministic query with stable row identity)  
- Exploration Probes: 2 (portability candidates targeting secondary hotspots)  

---

### Dispatch JSON

```json
{
  "dispatch": {
    "dialect": "postgres",
    "importance_stars": 2,
    "probe_count": 10,
    "early_stop": false,
    "equivalence_tier": "exact",
    "hypothesis": "Correlated EXISTS/NOT EXISTS subqueries cause nested-loop re-execution per customer row. Decorrelation (Family B) should replace per-row scans with pre-materialized joins. Comma-joins may cause poor cardinality estimates.",
    "reasoning_trace": [
      "Correlated subqueries on store_sales/web_sales/catalog_sales with identical date filters",
      "Nested-loop execution likely amplifies work (loops = customer count × 3)",
      "Comma-join syntax limits optimizer join reordering"
    ],
    "cost_spine": ["Nested Loop (EXISTS) → Nested Loop (NOT EXISTS) → Nested Loop (NOT EXISTS)"],
    "hotspots": [
      {"op": "Correlated Subqueries", "why": "Per-row re-execution of fact table scans", "evidence": "3 identical date filters; large fact tables (store_sales, etc.)"}
    ],
    "do_not_do": ["or_to_union (bitmap-or regression)", "inline_decorrelate_materialized (simple EXISTS contraindicated)"]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "status",
    "speedup",
    "expected_explain_delta",
    "ops_used",
    "confidence",
    "exploration",
    "failure_reason",
    "target"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Replace EXISTS(store_sales) with CTE: pre-materialize distinct customer keys from store_sales + date_dim filter (d_year=2002, d_moy 10-12, ss_list_price 80-169). Join as semi-join.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim"],
        "where_must_preserve": ["ss_sold_date_sk = d_date_sk", "d_year=2002", "d_moy BETWEEN 10 AND 12", "ss_list_price BETWEEN 80 AND 169"],
        "output_must_preserve": ["cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating", "cnt1", "cnt2", "cnt3"]
      },
      "gates_checked": ["no_or_to_union:PASS", "not_simple_exists:PASS"],
      "exploration": false,
      "confidence": 0.9,
      "expected_explain_delta": "Nested Loop → Hash Semi Join; single store_sales scan",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate"]
    },
    {
      "probe_id": "p02",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Replace NOT EXISTS(web_sales) with CTE: pre-materialize distinct customer keys from web_sales + date filter. Join as anti-join (LEFT JOIN ... IS NULL).",
      "node_contract": {
        "from_must_include": ["web_sales", "date_dim"],
        "where_must_preserve": ["ws_sold_date_sk = d_date_sk", "d_year=2002", "d_moy BETWEEN 10 AND 12", "ws_list_price BETWEEN 80 AND 169"],
        "output_must_preserve": ["original SELECT columns and aggregation semantics"]
      },
      "gates_checked": ["no_or_to_union:PASS", "not_simple_exists:PASS"],
      "exploration": false,
      "confidence": 0.9,
      "expected_explain_delta": "Nested Loop → Hash Anti Join; single web_sales scan"
    },
    {
      "probe_id": "p03",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Replace NOT EXISTS(catalog_sales) with CTE: pre-materialize distinct customer keys from catalog_sales + date filter. Join as anti-join.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim"],
        "where_must_preserve": ["cs_sold_date_sk = d_date_sk", "d_year=2002", "d_moy BETWEEN 10 AND 12", "cs_list_price BETWEEN 80 AND 169"],
        "output_must_preserve": ["original SELECT columns and aggregation semantics"]
      },
      "gates_checked": ["no_or_to_union:PASS", "not_simple_exists:PASS"],
      "exploration": false,
      "confidence": 0.9,
      "expected_explain_delta": "Nested Loop → Hash Anti Join; single catalog_sales scan"
    },
    {
      "probe_id": "p04",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Convert comma-joins to explicit INNER JOIN syntax. Isolate date_dim filter into CTE for reuse.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "customer_demographics"],
        "where_must_preserve": ["c.c_current_addr_sk = ca.ca_address_sk", "cd_demo_sk = c.c_current_cdemo_sk", "ca_state IN ('CO','NC','TX')"],
        "output_must_preserve": ["all original columns and grouping logic"]
      },
      "gates_checked": ["comma_join_weakness:EXPLOIT"],
      "exploration": false,
      "confidence": 0.85,
      "expected_explain_delta": "Comma-join → Explicit JOIN; better cardinality estimates"
    },
    {
      "probe_id": "p05",
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "target": "Create shared date_dim CTE (d_date_sk) for d_year=2002/d_moy 10-12. Reuse in all sales subquery CTEs.",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_year=2002", "d_moy BETWEEN 10 AND 12"],
        "output_must_preserve": ["join conditions on *_sold_date_sk"]
      },
      "gates_checked": ["cte_materialization_fence:CAUTION"],
      "exploration": true,
      "exploration_hypothesis": "Avoid redundant date_dim scans; runtime profile allows CTEs for reusable selective filters.",
      "confidence": 0.7,
      "expected_explain_delta": "3 date_dim scans → 1 CTE scan"
    },
    {
      "probe_id": "p06",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Pre-filter customer_demographics into CTE (cd_demo_sk) with cd_marital_status IN ('S','M','U') AND cd_education_status IN ('Primary','College').",
      "node_contract": {
        "from_must_include": ["customer_demographics"],
        "where_must_preserve": ["cd_marital_status IN ('S','M','U')", "cd_education_status IN ('Primary','College')"],
        "output_must_preserve": ["cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"]
      },
      "gates_checked": ["cte_materialization_fence:CAUTION"],
      "exploration": true,
      "exploration_hypothesis": "Small dimension table; CTE materialization may accelerate joins despite PostgreSQL's index scan strength.",
      "confidence": 0.6,
      "expected_explain_delta": "Dimension scan → tiny hash table probe"
    },
    {
      "probe_id": "p07",
      "transform_id": "composite_decorrelate_union",
      "family": "B",
      "target": "Consolidate sales channel checks: single CTE returning customer keys with flags for store/web/catalog sales. Replace EXISTS/NOT EXISTS with flag checks.",
      "node_contract": {
        "from_must_include": ["store_sales", "web_sales", "catalog_sales", "date_dim"],
        "where_must_preserve": ["date filters and price ranges"],
        "output_must_preserve": ["customer existence conditions"]
      },
      "gates_checked": ["correlated_subquery_paralysis:EXPLOIT"],
      "exploration": true,
      "exploration_hypothesis": "Single fact-table scan per channel may outperform per-row subqueries; portability candidate validated for similar DuckDB patterns.",
      "confidence": 0.65,
      "expected_explain_delta": "3 nested loops → 3 CTE scans + flag joins"
    },
    {
      "probe_id": "p08",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize base customer set (c_customer_sk + demographics) before sales checks to avoid recomputing joins.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "customer_demographics"],
        "where_must_preserve": ["state/demographic filters and join conditions"],
        "output_must_preserve": ["all grouping columns"]
      },
      "gates_checked": ["cte_materialization_fence:CAUTION"],
      "exploration": false,
      "confidence": 0.8,
      "expected_explain_delta": "Repeated join computation → single materialization"
    },
    {
      "probe_id": "p09",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Push COUNT() aggregation into customer CTE to reduce rows before joining with sales flags.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "customer_demographics"],
        "where_must_preserve": ["state/demographic filters"],
        "output_must_preserve": ["GROUP BY keys and aggregation semantics"]
      },
      "gates_checked": ["aggregate_below_join_blindness:CAUTION"],
      "exploration": false,
      "confidence": 0.75,
      "expected_explain_delta": "Aggregation after joins → aggregation before joins"
    },
    {
      "probe_id": "p10",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Pre-join filtered customer CTE with sales flag CTEs using MATERIALIZED keyword to enforce execution fencing.",
      "node_contract": {
        "from_must_include": ["customer CTE", "store_sales CTE", "web_sales CTE", "catalog_sales CTE"],
        "where_must_preserve": ["flag check logic"],
        "output_must_preserve": ["final result set"]
      },
      "gates_checked": ["cte_materialization_fence:EXPLOIT"],
      "exploration": false,
      "confidence": 0.85,
      "expected_explain_delta": "Pipeline joins → staged hash joins with MATERIALIZED CTEs"
    }
  ],
  "dropped": [
    {"transform_id": "or_to_union", "reason": "Regression registry: bitmap-or capable"},
    {"transform_id": "sf_sk_pushdown_multi_fact", "reason": "Snowflake-specific; contraindicated for PostgreSQL"}
  ]
}
```

**Key Decisions:**  
1. **Decorrelate First:** Probes p01–p03 directly attack the primary bottleneck (correlated subqueries) using PostgreSQL-native `early_filter_decorrelate`.  
2. **Exploration Probes:** p05 (shared date CTE) and p07 (composite decorrelation) target secondary hotspots with portability candidates, justified by plan evidence.  
3. **Guardrail Compliance:** Avoided `or_to_union` (bitmap-or regression) and `inline_decorrelate_materialized` (simple EXISTS contraindicated).  
4. **CTE Materialization:** Strategic use of `MATERIALIZED` (p10) aligns with PostgreSQL's strength in CTE fencing.  
5. **Join Topology:** Explicit JOIN syntax (p04) exploits `COMMA_JOIN_WEAKNESS`.  

Probes are ranked by impact: decorrelation → join optimization → aggregation pushdown → exploration. Workers receive precise operational instructions to ensure deterministic rewrites.