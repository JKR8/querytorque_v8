{
  "dispatch": {
    "dialect": "postgres",
    "importance_stars": 3,
    "probe_count": 14,
    "early_stop": false,
    "equivalence_tier": "exact",
    "hypothesis": "Plan shows nested loops dominate runtime (26s) with large row amplifications. EXISTS/NOT EXISTS subqueries cause correlated execution. Decorrelation (Family B) and dimension prefiltering (Family A) should reduce nested loops. Explicit joins (Family F) may improve cardinality estimates.",
    "reasoning_trace": [
      "Cost spine: Nested Loop (26s) → Materialize (9.7ms) → Nested Loop (5.6s)",
      "Hotspot: Correlated subqueries force re-execution; date_dim scans show selectivity but applied late",
      "Materialize nodes indicate CTE reuse opportunities; comma joins prevent optimal hash join planning"
    ],
    "cost_spine": ["Nested Loop (26018ms) → Aggregate → Limit"],
    "hotspots": [
      {"op": "Nested Loop", "why": "Correlated subquery execution", "evidence": "time=26018ms, rows=964"},
      {"op": "Materialize", "why": "Repeated fact table scans", "evidence": "catalog_sales rows=332456, time=568ms"}
    ],
    "do_not_do": ["or_to_union (bitmap-or capable)", "exists_to_in (PG semi-join efficient)"]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "status",
    "speedup",
    "expected_explain_delta",
    "ops_used",
    "confidence",
    "exploration",
    "failure_reason",
    "target"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Decorrelate store_sales EXISTS by creating CTE ss_customers: SELECT DISTINCT ss_customer_sk FROM store_sales JOIN date_dim WHERE d_year=2002 AND d_moy BETWEEN 10 AND 12 AND ss_list_price BETWEEN 80 AND 169. Replace EXISTS with INNER JOIN ss_customers ON c_customer_sk = ss_customer_sk.",
      "node_contract": {
        "from_must_include": ["customer c", "ss_customers"],
        "where_must_preserve": ["ca_state IN ('CO','NC','TX')", "cd_marital_status IN ('S','M','U')", "cd_education_status IN ('Primary','College')"],
        "output_must_preserve": ["cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating", "count(*) cnt1", "count(*) cnt2", "count(*) cnt3"]
      },
      "gates_checked": ["not_simple_exists:PASS", "no_double_scan:WATCH"],
      "exploration": false,
      "confidence": 0.92,
      "expected_explain_delta": "Replace Nested Loop with Hash Join to ss_customers CTE; eliminate correlated execution",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate"]
    },
    {
      "probe_id": "p02",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Decorrelate web_sales NOT EXISTS by creating CTE ws_customers: SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN date_dim WHERE conditions match subquery. Replace NOT EXISTS with LEFT ANTI JOIN.",
      "node_contract": {
        "from_must_include": ["customer c", "ws_customers"],
        "where_must_preserve": ["original NOT EXISTS logic as anti-join"],
        "output_must_preserve": ["all original columns and aggregates"]
      },
      "gates_checked": ["anti_join_safe:PASS"],
      "exploration": false,
      "confidence": 0.88,
      "expected_explain_delta": "Convert NOT EXISTS nested loop to hash anti-join",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate"]
    },
    {
      "probe_id": "p03",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Decorrelate catalog_sales NOT EXISTS similarly to p02 using CTE cs_customers with LEFT ANTI JOIN.",
      "node_contract": {
        "from_must_include": ["customer c", "cs_customers"],
        "where_must_preserve": ["original NOT EXISTS logic"],
        "output_must_preserve": ["original SELECT and GROUP BY columns"]
      },
      "gates_checked": ["anti_join_safe:PASS"],
      "exploration": false,
      "confidence": 0.88,
      "expected_explain_delta": "Eliminate correlated nested loop for catalog_sales",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate"]
    },
    {
      "probe_id": "p04",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Create filtered_date CTE: SELECT d_date_sk FROM date_dim WHERE d_year=2002 AND d_moy BETWEEN 10 AND 12. Replace all date_dim references in subqueries with this CTE.",
      "node_contract": {
        "from_must_include": ["filtered_date"],
        "where_must_preserve": ["ss_sold_date_sk = d_date_sk", "ws_sold_date_sk = d_date_sk", "cs_sold_date_sk = d_date_sk"],
        "output_must_preserve": ["all fact table join conditions"]
      },
      "gates_checked": ["small_dimension:PASS"],
      "exploration": false,
      "confidence": 0.85,
      "expected_explain_delta": "Reduce date_dim scans from 3 to 1; earlier filtering",
      "recommended_patch_ops": ["insert_cte", "replace_from"]
    },
    {
      "probe_id": "p05",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Create ca_filtered CTE: SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('CO','NC','TX'). Replace base table reference in main FROM.",
      "node_contract": {
        "from_must_include": ["ca_filtered"],
        "where_must_preserve": ["c.c_current_addr_sk = ca_address_sk"],
        "output_must_preserve": ["customer join conditions"]
      },
      "gates_checked": ["selective_filter:PASS"],
      "exploration": false,
      "confidence": 0.8,
      "expected_explain_delta": "Reduce customer_address scan rows from 11,220 to filtered set",
      "recommended_patch_ops": ["insert_cte", "replace_from"]
    },
    {
      "probe_id": "p06",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Convert comma joins to explicit INNER JOIN syntax: FROM customer c JOIN ca_filtered ON ... JOIN customer_demographics ON ...",
      "node_contract": {
        "from_must_include": ["explicit JOIN syntax"],
        "where_must_preserve": ["all original join conditions"],
        "output_must_preserve": ["original cardinality and columns"]
      },
      "gates_checked": ["comma_join_weakness:EXPLOIT"],
      "exploration": false,
      "confidence": 0.75,
      "expected_explain_delta": "Better join order choices; improved row estimates",
      "recommended_patch_ops": ["replace_from"]
    },
    {
      "probe_id": "p07",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Materialize store_sales subquery as CTE ss_filtered with all filters and joins. Reference in p01 decorrelation.",
      "node_contract": {
        "from_must_include": ["ss_filtered"],
        "where_must_preserve": ["original list_price and date filters"],
        "output_must_preserve": ["ss_customer_sk distinctness"]
      },
      "gates_checked": ["cte_reuse:PASS"],
      "exploration": false,
      "confidence": 0.78,
      "expected_explain_delta": "Avoid repeated store_sales scans in decorrelated CTEs",
      "recommended_patch_ops": ["insert_cte", "replace_expr_subtree"]
    },
    {
      "probe_id": "p08",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Combine all fact table CTEs (ss/ws/cs_customers) into single sales_customers CTE with channel markers. Use in main query with conditional anti-joins.",
      "node_contract": {
        "from_must_include": ["sales_customers"],
        "where_must_preserve": ["channel-specific anti-join logic"],
        "output_must_preserve": ["original NOT EXISTS semantics"]
      },
      "gates_checked": ["multi_reference_cte:PASS"],
      "exploration": true,
      "exploration_hypothesis": "PostgreSQL materializes CTEs by default; single CTE may outperform multiple decorrelated CTEs",
      "confidence": 0.65,
      "expected_explain_delta": "Single materialized CTE instead of multiple decorrelation CTEs",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate"]
    },
    {
      "probe_id": "p09",
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "target": "Create shared_filters CTE containing date + customer demographics filters. Reference in all channel subqueries.",
      "node_contract": {
        "from_must_include": ["shared_filters"],
        "where_must_preserve": ["all original filter logic"],
        "output_must_preserve": ["subquery result correctness"]
      },
      "gates_checked": ["cross_cte_blindness:WATCH"],
      "exploration": true,
      "exploration_hypothesis": "Shared CTE may reduce redundant dimension scans despite PG's cross-CTE predicate blindness risk",
      "confidence": 0.6,
      "expected_explain_delta": "Fewer dimension scans; potential for filter consolidation",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate"]
    },
    {
      "probe_id": "p10",
      "transform_id": "decorrelate",
      "family": "B",
      "target": "Convert NOT EXISTS clauses to NOT IN with precomputed keys: WHERE c_customer_sk NOT IN (SELECT ws_bill_customer_sk FROM ws_filtered)",
      "node_contract": {
        "from_must_include": ["ws_filtered", "cs_filtered"],
        "where_must_preserve": ["anti-join semantics"],
        "output_must_preserve": ["NULL handling equivalence"]
      },
      "gates_checked": ["null_safety:PASS"],
      "exploration": false,
      "confidence": 0.7,
      "expected_explain_delta": "Replace nested loops with hash subplan",
      "recommended_patch_ops": ["replace_where_predicate"]
    },
    {
      "probe_id": "p11",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Combine p04 and p06: use filtered_date CTE with explicit JOINs in all subqueries",
      "node_contract": {
        "from_must_include": ["filtered_date JOIN store_sales"],
        "where_must_preserve": ["explicit ON conditions"],
        "output_must_preserve": ["join semantics"]
      },
      "gates_checked": ["comma_join_weakness:EXPLOIT"],
      "exploration": false,
      "confidence": 0.82,
      "expected_explain_delta": "Hash joins with small dimension CTE instead of nested loops",
      "recommended_patch_ops": ["insert_cte", "replace_from"]
    },
    {
      "probe_id": "p12",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Stage customer reduction: CTE stage1 = customer+address join; stage2 = stage1 + demographics filter; use in main FROM",
      "node_contract": {
        "from_must_include": ["stage2"],
        "where_must_preserve": ["all original filters"],
        "output_must_preserve": ["join cardinality"]
      },
      "gates_checked": ["cte_materialization_fence:WATCH"],
      "exploration": false,
      "confidence": 0.75,
      "expected_explain_delta": "Reduce customer rows before subquery evaluation",
      "recommended_patch_ops": ["insert_cte", "replace_from"]
    },
    {
      "probe_id": "p13",
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "target": "Use MATERIALIZED CTEs for decorrelation: WITH ss_customers AS MATERIALIZED (...)",
      "node_contract": {
        "from_must_include": ["MATERIALIZED keyword"],
        "where_must_preserve": ["original decorrelation logic"],
        "output_must_preserve": ["result equivalence"]
      },
      "gates_checked": ["pg_version:CHECK"],
      "exploration": false,
      "confidence": 0.68,
      "expected_explain_delta": "Prevent PG from inlining CTEs back into correlated form",
      "recommended_patch_ops": ["modify_cte_spec"]
    },
    {
      "probe_id": "p14",
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "target": "Add date_sk BETWEEN filters to fact tables: WHERE ss_sold_date_sk BETWEEN min_sk AND max_sk (from filtered_date CTE)",
      "node_contract": {
        "from_must_include": ["filtered_date"],
        "where_must_preserve": ["BETWEEN condition on date_sk"],
        "output_must_preserve": ["result rows"]
      },
      "gates_checked": ["predicate_transitivity:WATCH"],
      "exploration": true,
      "exploration_hypothesis": "Explicit range may help index scans despite PG's transitive closure; portability candidate with low risk",
      "confidence": 0.55,
      "expected_explain_delta": "Tighter index scan ranges on fact tables",
      "recommended_patch_ops": ["replace_where_predicate"]
    }
  ],
  "dropped": [
    {"transform_id": "or_to_union", "family": "D", "reason": "regression registry: bitmap-or capable on PG"},
    {"transform_id": "aggregate_pushdown", "family": "C", "reason": "no aggregation below join opportunity"},
    {"transform_id": "intersect_to_exists", "family": "D", "reason": "no INTERSECT operations in query"}
  ]
}