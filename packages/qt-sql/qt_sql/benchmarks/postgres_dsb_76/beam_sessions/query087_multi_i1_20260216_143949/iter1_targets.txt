[
  {
    "target_id": "t1_comb",
    "family": "C+D",
    "transform": "distinct_pushdown_then_except_to_exists",
    "relevance_score": 0.95,
    "hypothesis": "Reduce fact table rows via DISTINCT pushdown before joins (C) and avoid materializing EXCEPT intermediates via NOT EXISTS rewrite (D). Targets expensive Sort (539 ms) and SetOp (1061 ms).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter",
      "pg_intersect_to_exists"
    ]
  },
  {
    "target_id": "t2_refine",
    "family": "C",
    "transform": "distinct_pushdown_corrected",
    "relevance_score": 0.9,
    "hypothesis": "Pre-aggregate fact tables on join keys to reduce input rows to Nested Loop (0-row scan in plan) and downstream Sort operators.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter"
    ]
  },
  {
    "target_id": "t3_rescue",
    "family": "D",
    "transform": "except_to_exists_corrected",
    "relevance_score": 0.85,
    "hypothesis": "Fix scoping in NOT EXISTS subqueries to eliminate SetOp materialization (1061 ms) while preserving semantics.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_intersect_to_exists"
    ]
  },
  {
    "target_id": "t4_novel",
    "family": "A+E",
    "transform": "prefilter_dimensions_materialize",
    "relevance_score": 0.8,
    "hypothesis": "Prefilter and reuse small dimensions (date_dim rows=182) via nested loops (not merge joins) to avoid sort backfire.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_date_cte_explicit_join",
      "multi_dimension_prefetch"
    ]
  }
]