{
  "dispatch": {
    "dialect": "postgres",
    "importance_stars": 3,
    "probe_count": 8,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Execution plan shows 20s Append node scanning all years of sales/returns data. Pushing d_year filters into UNION branches should reduce base data volume. Decorrelated CTEs and explicit joins may optimize dimension handling.",
    "reasoning_trace": [
      "Cost spine dominated by Append (20s) from unfiltered year scans in UNION branches",
      "Nested Loops show late date_dim filtering despite index scans",
      "Hash Joins on large returns tables indicate missing predicate pushdown",
      "CTE materialization fences prevent predicate absorption"
    ],
    "cost_spine": ["Append → Gather → Aggregate → Sort → Aggregate → Limit"],
    "hotspots": [
      {"op": "Append", "why": "Full-year scans of returns/sales tables", "evidence": "time=20652ms, rows=6763 (amplified from 7M+ base)"},
      {"op": "Hash Join", "why": "Unfiltered dimension joins", "evidence": "item scanned 3x (1187ms each), 260K+ returns rows"}
    ],
    "do_not_do": ["or_to_union (BITMAP_OR_SCAN strength)", "materialize_cte (CTE_MATERIALIZATION_FENCE gap)"]
  },
  "probe_summary_schema": [
    "probe_id", "transform_id", "family", "status", "speedup", "expected_explain_delta", "ops_used", 
    "confidence", "exploration", "failure_reason", "target"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Add 'AND d.d_year IN (1998,1999)' to WHERE clause in all 3 UNION branches",
      "node_contract": {
        "from_must_include": ["date_dim d"],
        "where_must_preserve": ["i_category='Children'", "price_ratio BETWEEN clauses", "reason_sk IN conditions"],
        "output_must_preserve": ["sales_cnt", "sales_amt", "all dimension keys"]
      },
      "gates_checked": ["no_registry_match:PASS"],
      "exploration": false,
      "confidence": 0.95,
      "expected_explain_delta": "Reduced rows in returns scans and earlier date_dim filtering"
    },
    {
      "probe_id": "p02",
      "transform_id": "inner_join_conversion",
      "family": "F",
      "target": "Convert all LEFT JOINs to INNER JOINs and move sr/cr/wr_reason_sk filters to ON clauses",
      "node_contract": {
        "from_must_include": ["store_returns", "catalog_returns", "web_returns"],
        "where_must_preserve": [],
        "output_must_preserve": ["COALESCE logic for return amounts"]
      },
      "gates_checked": ["no_null_dependent_logic:PASS"],
      "exploration": false,
      "confidence": 0.90,
      "expected_explain_delta": "Earlier returns filtering and join-type clarity"
    },
    {
      "probe_id": "p03",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Create filtered_item CTE (i_category='Children') and reuse in all 3 branches",
      "node_contract": {
        "from_must_include": ["item"],
        "where_must_preserve": ["i_category='Children'"],
        "output_must_preserve": ["i_item_sk", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id"]
      },
      "gates_checked": ["not_unfiltered_cte:PASS"],
      "exploration": true,
      "exploration_hypothesis": "PostgreSQL may better optimize hash builds with materialized CTE despite CROSS_CTE_PREDICATE_BLINDNESS gap",
      "confidence": 0.70,
      "expected_explain_delta": "Single item scan instead of 3, smaller hash tables"
    },
    {
      "probe_id": "p04",
      "transform_id": "date_cte_isolate",
      "family": "A",
      "target": "Create filtered_date CTE (d_year IN (1998,1999)) and reuse in all branches",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_year IN (1998,1999)"],
        "output_must_preserve": ["d_date_sk", "d_year"]
      },
      "gates_checked": ["not_unfiltered_cte:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Materialized CTE may enable index-only scans despite predicate blindness risk",
      "confidence": 0.65,
      "expected_explain_delta": "Eliminated redundant date_dim scans"
    },
    {
      "probe_id": "p05",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Convert comma-join 'FROM all_sales curr_yr, all_sales prev_yr' to explicit INNER JOIN",
      "node_contract": {
        "from_must_include": ["all_sales curr_yr", "all_sales prev_yr"],
        "where_must_preserve": ["curr_yr.i_brand_id=prev_yr.i_brand_id", "curr_yr.i_class_id=prev_yr.i_class_id", "curr_yr.i_category_id=prev_yr.i_category_id", "curr_yr.i_manufact_id=prev_yr.i_manufact_id"],
        "output_must_preserve": ["prev_yr_cnt", "curr_yr_cnt", "diff calculations"]
      },
      "gates_checked": ["no_comma_join_weakness:PASS"],
      "exploration": false,
      "confidence": 0.85,
      "expected_explain_delta": "Better join ordering for self-join"
    },
    {
      "probe_id": "p06",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize all_sales CTE with d_year filter before self-join",
      "node_contract": {
        "from_must_include": ["sales_detail"],
        "where_must_preserve": [],
        "output_must_preserve": ["GROUP BY keys", "SUM aggregates"]
      },
      "gates_checked": ["cte_materialization_fence:CAUTION"],
      "exploration": false,
      "confidence": 0.80,
      "expected_explain_delta": "Single materialization of filtered aggregates"
    },
    {
      "probe_id": "p07",
      "transform_id": "decorrelate",
      "family": "B",
      "target": "Decorrelate returns joins by pre-computing filtered returns as CTEs",
      "node_contract": {
        "from_must_include": ["store_returns", "catalog_returns", "web_returns"],
        "where_must_preserve": ["reason_sk IN conditions"],
        "output_must_preserve": ["return keys and quantities"]
      },
      "gates_checked": ["no_correlated_subquery_paralysis:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Pre-materialized returns sets may enable better hash joins despite CORRELATED_SUBQUERY_PARALYSIS gap",
      "confidence": 0.60,
      "expected_explain_delta": "Reduced nested loops in returns joins"
    },
    {
      "probe_id": "p08",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate sales at (item_sk, date_sk) level before joining to dimensions",
      "node_contract": {
        "from_must_include": ["store_sales", "catalog_sales", "web_sales"],
        "where_must_preserve": ["price_ratio conditions"],
        "output_must_preserve": ["sales quantities and amounts"]
      },
      "gates_checked": ["no_join_multiplicity_change:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Reduced row counts before dimension joins may compensate for AGGREGATE_BELOW_JOIN_BLINDNESS risk",
      "confidence": 0.55,
      "expected_explain_delta": "Smaller dimension join inputs"
    }
  ],
  "dropped": [
    {"transform_id": "or_to_union", "reason": "PostgreSQL BITMAP_OR_SCAN strength"},
    {"transform_id": "sf_sk_pushdown_union_all", "reason": "Snowflake-specific transform"}
  ]
}