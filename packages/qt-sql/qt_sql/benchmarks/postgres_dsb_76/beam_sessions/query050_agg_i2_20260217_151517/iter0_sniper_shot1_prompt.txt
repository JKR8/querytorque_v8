## Role

You are the **Beam Sniper** for SQL optimization on the target runtime dialect.

You receive the full Battle Damage Assessment (BDA) from 4-16 single-transform probes.
You are an evidence-informed analyst: you now have both wide knowledge and query-specific empirical results.

Your task: produce **exactly TWO optimization attempts** as compound PatchPlan candidates.

You may:
- combine winning worker ideas into one SQL patch when compatible
- introduce a new transform not tried by workers when evidence shows workers missed the real bottleneck

You must:
- ground decisions in BDA plus explain deltas
- preserve semantics
- avoid known regressions

---

## Prompt Map (cache friendly)

### Phase A - Cached Context (static)
A1. Dialect reminders plus regression registry
A2. Combination hazards (duplication, multiplicity, CTE fences)
A3. Evidence-first decision procedure (mechanical)
A4. Sniper output contract (strict JSON array)

### Phase B - Query-Specific Input (dynamic; after cache boundary)
B1. Importance star rating (1-3)
B2. Original SQL plus original plan
B3. IR structure plus anchor hashes
B4. BDA table (ALL probes: status, speedup, explain delta, failure reasons)
B5. Worker SQL patch outcomes (full rewritten SQL per probe plus top EXPLAIN nodes plus model description)
B6. Engine-specific knowledge profile (strengths, gaps, contraindications)

---

## Dialect reminders

Use runtime-injected **Engine-Specific Knowledge** as authoritative.
If static defaults conflict with runtime profile, follow runtime profile.

---

## Regression Registry (hard bans)

Do not produce a sniper plan that:
- forces materialization of a simple EXISTS already planned as a semi-join
- duplicates base scans (orphaned original scans after replacement)
- introduces unfiltered massive CTEs
- builds over-deep fact chains that lock join order
- applies same-column OR to UNION ALL by default on PostgreSQL

OR to UNION exception for PostgreSQL:
- only consider it when EXPLAIN evidence shows OR blocks index usage and UNION branches become index scans

---

## Combination hazards (what to watch)

- **Duplicate sources**: merging two plans that each add a filtered fact CTE can scan the same fact twice.
- **Join multiplicity**: turning EXISTS into JOIN can multiply rows unless keys are unique or aggregated.
- **CTE fences**: materialized CTEs can block pushdown and join reorder.
- **Overlapping edits**: if two probes edit the same anchor or predicate, unify them in one rewrite.

---

## Evidence-first decision procedure (mechanical)

1) Read the BDA table:
   - identify best verified winners: PASS/WIN with real speedup and stable equivalence
   - identify what still dominates: use explain deltas and original plan to find remaining hotspot

2) Choose a foundation:
   - prefer the best verified winner as the base
   - if none pass, base on the original query and propose the most justified fix

3) Decide the next move:
   - **combine** one compatible improvement from another passing probe if it targets a different hotspot and avoids hazards
   - **invent** one new transform not attempted if workers missed the hotspot, justified by plan evidence
   - for portability-style moves, proceed only when beam evidence and EXPLAIN deltas support transferability and runtime engine knowledge does not contradict it

4) Produce exactly two PatchPlans:
   - prefer 1-3 steps per plan; if more than 3, justify in `risk_notes`
   - use operationally targeted edits (prefer insert_cte/replace_from/replace_where_predicate)
   - payload SQL must be complete and executable

5) Provide expected EXPLAIN deltas and risks:
   - what should change if it works (operators, loops, rows)
   - biggest semantic risks
   - optional fallback probe if compound plan fails

---

## Sniper Output Contract (MUST follow)

Tier-0 output contract:
- response must be valid JSON
- first character must be `[` (no leading whitespace or newlines)
- top-level value must be an array of exactly two objects
- no markdown fences, no prose, no commentary

Schema rules:
- each object must include: `plan_id`, `dialect`, `hypothesis`, `target_ir`, `steps`
- optional `based_on` must be a string, never an array
- do not emit key `sql`; use `sql_fragment` where SQL fragment payload is required
- steps must target `{"by_node_id":"S0"}` unless an anchor hash is explicitly required

Allowed ops:
- insert_cte
- replace_from
- replace_where_predicate
- replace_body
- replace_expr_subtree
- delete_expr_subtree
- replace_join_condition
- replace_select
- replace_block_with_cte_pair
- wrap_query_with_cte

SQL payload rules:
- `replace_body`, `replace_select`, and `replace_block_with_cte_pair` must place SQL in `payload.sql_fragment`
- payload SQL must be complete and executable

Output JSON shape:
[
  {
    "plan_id": "snipe_p1",
    "dialect": "<target_dialect>",
    "confidence": 0.81,
    "based_on": "p03,p11",
    "strategy": "Foundation plus one compatible add-on",
    "hypothesis": "Plan evidence and expected win mechanism",
    "target_ir": "Short structural description of final query shape",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {"sql_fragment": "SELECT c_customer_sk FROM customer"}
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "<target_dialect>",
    "confidence": 0.73,
    "based_on": "p07",
    "strategy": "Alternative independent pathway",
    "hypothesis": "Plan evidence for second pathway",
    "target_ir": "Alternative structural description",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "filtered_sales",
          "cte_query_sql": "SELECT ss_customer_sk FROM store_sales WHERE ss_quantity > 0"
        }
      }
    ]
  }
]

---

## Cache Boundary
Everything below is query-specific input.

## Query ID
query050_agg_i2

## Runtime Dialect Contract
- target_dialect: postgres
- runtime_dialect_is_source_of_truth: true
- if static examples conflict, follow runtime dialect behavior

## Importance
- importance_stars: 3
- importance_label: ***

## Original SQL
```sql
select 
   s_store_name
  ,s_company_id
  ,s_street_number
  ,s_street_name
  ,s_street_type
  ,s_suite_number
  ,s_city
  ,s_county
  ,s_state
  ,s_zip
  ,sum(case when (sr_returned_date_sk - ss_sold_date_sk <= 30 ) then 1 else 0 end)  as "30 days"
  ,sum(case when (sr_returned_date_sk - ss_sold_date_sk > 30) and
                 (sr_returned_date_sk - ss_sold_date_sk <= 60) then 1 else 0 end )  as "31-60 days"
  ,sum(case when (sr_returned_date_sk - ss_sold_date_sk > 60) and
                 (sr_returned_date_sk - ss_sold_date_sk <= 90) then 1 else 0 end)  as "61-90 days"
  ,sum(case when (sr_returned_date_sk - ss_sold_date_sk > 90) and
                 (sr_returned_date_sk - ss_sold_date_sk <= 120) then 1 else 0 end)  as "91-120 days"
  ,sum(case when (sr_returned_date_sk - ss_sold_date_sk  > 120) then 1 else 0 end)  as ">120 days"
from
   store_sales
  ,store_returns
  ,store
  ,date_dim d1
  ,date_dim d2
where
    d2.d_year = 1999
and d2.d_moy  = 7
and ss_ticket_number = sr_ticket_number
and ss_item_sk = sr_item_sk
and ss_sold_date_sk   = d1.d_date_sk
and sr_returned_date_sk   = d2.d_date_sk
and ss_customer_sk = sr_customer_sk
and ss_store_sk = s_store_sk
and d1.d_date between (d2.d_date - interval '120 day')
               and d2.d_date
group by
   s_store_name
  ,s_company_id
  ,s_street_number
  ,s_street_name
  ,s_street_type
  ,s_suite_number
  ,s_city
  ,s_county
  ,s_state
  ,s_zip
order by s_store_name
        ,s_company_id
        ,s_street_number
        ,s_street_name
        ,s_street_type
        ,s_suite_number
        ,s_city
        ,s_county
        ,s_state
        ,s_zip
limit 100;
```

## Original Plan
```
Limit  (rows=30, time=100291.476)
  Aggregate  (rows=30, time=100291.469)
    Nested Loop  (rows=39154, time=100282.659)
      Gather Merge  (rows=81513, time=100229.297)
        Sort  (rows=40756, time=50441.332)
          Nested Loop  (rows=40756, time=50059.738)
            Nested Loop  (rows=41734, time=49944.136)
              Nested Loop  (rows=56294, time=17236.345)
                Index Scan on date_dim (d2)  (rows=16, time=396.628)
                Index Only Scan on store_returns  (rows=3632, time=1085.112)
              Index Only Scan on store_sales  (rows=1, time=0.58)
            Index Scan on store  (rows=1, time=0.002)
      Index Scan on date_dim (d1)  (rows=1, time=0.0)
```

## IR Structure + Anchor Hashes
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: store_sales, store_returns, store, date_dim d1, date_dim d2
    WHERE [444f6473896f7965]: d2.d_year = 1999 AND d2.d_moy = 7 AND ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_ite...
    GROUP BY: s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip
    ORDER BY: s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Schema / Index / Stats Context
- source: postgres
- referenced_tables: 4

| Table | Rows(est) | PK | Indexes |
|-------|-----------|----|---------|
| date_dim | 73049 | d_date_sk | date_dim_pkey, _dta_index_date_dim_6_661577395__k7_k4_k9_k1, _dta_index_date_dim_6_661577395__k7_k9_k1, _dta_index_date_dim_6_661577395__k1_k7_k9, _dta_index_date_dim_6_661577395__k7_k11_k1, _dta_index_date_dim_6_661577395__k9_k7_k1 |
| store | 102 | s_store_sk | store_pkey, _dta_index_store_6_885578193__k1_2_6, _dta_index_store_6_885578193__k25_k1 |
| store_returns | 7197499 | sr_item_sk, sr_ticket_number | store_returns_pkey, _dta_index_store_returns_6_1013578649__k1_3_4_10_20, _dta_index_store_returns_6_1013578649__k5_1_3_10_11, _dta_index_store_returns_6_1013578649__k1_3_4_10 |
| store_sales | 28806628 | ss_item_sk, ss_ticket_number | store_sales_pkey, _dta_index_store_sales_6_1333579789__k1_k23_k14_k6_k8_k5_k7_3_4, _dta_index_store_sales_6_1333579789__k1_k5_k8_k3_11_13_14_20, _dta_index_store_sales_6_1333579789__k1_k3_k10_k4_k8_9_16_23, _dta_index_store_sales_6_1333579789__k4_1_3_10_11_14, _dta_index_store_sales_6_1333579789__k1_k3_k10_k4_k8_23 |

## Engine-Specific Knowledge
## Dialect Profile (POSTGRES)

**Combined Intelligence Baseline**: Combined intelligence baseline from 53 validated DSB queries at SF5-SF10, plus regression registry outcomes. PostgreSQL has bitmap index scans, JIT compilation, and aggressive CTE materialization. Techniques that work on DuckDB often regress here.

### Optimizer Strengths (don't fight these)
- `BITMAP_OR_SCAN`: Avoid splitting OR conditions into UNION ALL by default. Only consider OR→UNION when EXPLAIN shows OR blocks index usage and UNION branches become index scans. 0.21x and 0.26x reg…
- `SEMI_JOIN_EXISTS`: NEVER convert EXISTS to IN/NOT IN or materialized CTEs. 0.50x, 0.75x observed. Note: NOT EXISTS anti-join decorrelation can still be valid when replacing large correlated anti patterns.
- `INNER_JOIN_REORDERING`: Don't restructure INNER JOIN orders. Focus on LEFT JOIN blocking or comma-join confusion.
- `INDEX_ONLY_SCAN`: Small dimension lookups (<10K rows) may not need CTEs.

### Known Gaps (exploit these)
- `COMMA_JOIN_WEAKNESS` [HIGH] detect: FROM t1, t2, t3 WHERE t1.key = t2.key (comma joins, no explicit JOIN). Poor row estimates in EXPLAIN. | action: Convert comma-joins to explicit JOIN...ON syntax. Best when combined with date_cte_isolate.
- `CORRELATED_SUBQUERY_PARALYSIS` [HIGH] detect: Nested loop in EXPLAIN, inner re-executes aggregate per outer row. SQL: WHERE col > (SELECT AGG FROM ... WHERE outer.key = inner.key). Hash… | action: Convert correlated WHERE to explicit CTE with GROUP BY + JOIN.
- `NON_EQUI_JOIN_INPUT_BLINDNESS` [HIGH] detect: Expensive non-equi join (BETWEEN, <, >) with large inputs on both sides. Neither side filtered. | action: Reduce fact table input size via filtered CTE before the non-equi join.
- `CTE_MATERIALIZATION_FENCE` [MEDIUM] detect: Large CTE + small post-filter. Multi-referenced CTE that blocks predicate pushdown. | action: Materialize STRATEGICALLY: only when CTE is expensive and reused. Avoid fencing single-use cases.
- `CROSS_CTE_PREDICATE_BLINDNESS` [MEDIUM] detect: Sequential scan on dimension table without index condition. Late filter after large scan/join. | action: Pre-filter into CTE definition. But be more cautious than on DuckDB.

## Dispatcher Hypothesis
Execution plan shows dominant Nested Loop (50s) and Gather Merge (50s) consuming 100s total. Late d1 range filtering and comma joins prevent early row reduction. Transform families A (filter push) and F (join topology) should isolate date dimensions and convert to explicit joins.

## Dispatcher Reasoning Trace
- Cost spine: Nested Loop (50s) → Gather Merge (50s) → Sort (50s)
- d2 scan yields 16 rows but amplifies to 58k store_returns rows
- d1 range condition applied late after expensive joins
- Comma joins prevent optimal join reordering (COMMA_JOIN_WEAKNESS gap)

## Equivalence Tier
- unordered

## Additional Intelligence
### AST Feature Detection

- **date_cte_explicit_join**: 100% match (AGG_SUM, BETWEEN, CASE_EXPR, DATE_DIM) (gap: COMMA_JOIN_WEAKNESS)  [SUPPORT: native_or_universal]
- **multi_dimension_prefetch**: 100% match (AGG_SUM, CASE_EXPR, DATE_DIM, GROUP_BY) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [SUPPORT: portability_candidate; engines=duckdb]
- **pg_self_join_decomposition**: 80% match (AGG_SUM, BETWEEN, DATE_DIM, GROUP_BY) (gap: CROSS_CTE_PREDICATE_BLINDNESS)  [SUPPORT: native_or_universal]
  Missing: AGG_AVG
- **early_filter**: 75% match (AGG_SUM, CASE_EXPR, GROUP_BY) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [SUPPORT: portability_candidate; engines=duckdb]
  Missing: LEFT_JOIN
- **inline_decorrelate_materialized**: 75% match (AGG_SUM, BETWEEN, DATE_DIM) (gap: CORRELATED_SUBQUERY_PARALYSIS)  [SUPPORT: native_or_universal]
  Missing: AGG_AVG


## Probe Summary
12 probes fired, 0 passed validation, 0 showed speedup.

## BDA Table (all probes)

| Probe | Transform | Family | Status | Speedup | Top EXPLAIN Nodes | Model Description | SQL Patch | Error/Notes |
|-------|-----------|--------|--------|---------|-------------------|-------------------|-----------|-------------|
| p08 | pg_self_join_decomposition | E | ERROR | - | - | Materialize store_sales + d1 join as CTE. Reuse in store_returns join. | p08 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p09 | inner_join_conversion | F | ERROR | - | - | Convert all comma joins to explicit INNER JOIN. Preserve ON conditions. | p09 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p03 | early_filter | A | ERROR | - | - | Prefilter store_sales via subquery: WHERE ss_sold_date_sk IN (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN (d2.d_date - '120 days') AND d2.d_date) | p03 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p11 | decorrelate | B | ERROR | - | - | Convert d1 range condition to CTE: SELECT d_date_sk FROM date_dim WHERE EXISTS (SELECT 1 FROM d2_cte WHERE d_date BETWEEN ...) | p11 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p05 | materialized_dimension_fact_prefilter | F | ERROR | - | - | Materialize d2_cte and filtered store_returns (sr_returned_date_sk IN d2_cte). Use in main FROM with explicit JOINs. | p05 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p02 | date_cte_explicit_join | F | ERROR | - | - | Materialize d2_cte (d_year=1999,d_moy=7). Convert comma joins to explicit JOIN syntax. Push d1 range condition into JOIN ON clause. | p02 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p04 | multi_dimension_prefetch | A | ERROR | - | - | Create d2_cte (d_year=1999,d_moy=7) and d1_cte (filtered by d2_cte date range). Pre-join CTEs with store_sales/returns in FROM clause. | p04 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p01 | dimension_prefetch_star | F | ERROR | - | - | Create d2_cte (d_year=1999,d_moy=7) and d1_cte (EXISTS join with d2_cte for d_date range). Replace comma joins with explicit INNER JOINs using CTEs. | p01 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p12 | single_pass_aggregation | C | ERROR | - | - | Consolidate all CASE expressions into single SUM with conditional flags. Preserve bucket logic. | p12 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p10 | sf_sk_pushdown_multi_fact | A | ERROR | - | - | Add ss_sold_date_sk BETWEEN min_d1 AND max_d1 to store_sales WHERE. Compute min/max from d2 date range. | p10 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p06 | aggregate_pushdown | C | ERROR | - | - | Pre-aggregate store_sales/store_returns by ss_store_sk before joining with store. Preserve date difference buckets in CASE. | p06 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p07 | channel_bitmap_aggregation | C | ERROR | - | - | Consolidate date buckets into single store_sales scan. Add flag column for date ranges in SELECT. | p07 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |

## Worker SQL Patches

### p08: pg_self_join_decomposition (ERROR, n/a)
```sql
WITH ss_d1_join AS (SELECT * FROM store_sales AS ss JOIN date_dim AS d1 ON ss.ss_sold_date_sk = d1.d_date_sk) SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales, store_returns, store, date_dim AS d1, date_dim AS d2 WHERE d2.d_year = 1999 AND d2.d_moy = 7 AND ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND ss_sold_date_sk = d1.d_date_sk AND sr_returned_date_sk = d2.d_date_sk AND ss_customer_sk = sr_customer_sk AND ss_store_sk = s_store_sk AND d1.d_date BETWEEN (d2.d_date - INTERVAL '120 DAY') AND d2.d_date GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p09: inner_join_conversion (ERROR, n/a)
```sql
SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales JOIN store_returns ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND ss_customer_sk = sr_customer_sk JOIN store ON ss_store_sk = s_store_sk JOIN date_dim AS d1 ON ss_sold_date_sk = d1.d_date_sk JOIN date_dim AS d2 ON sr_returned_date_sk = d2.d_date_sk WHERE d2.d_year = 1999 AND d2.d_moy = 7 AND ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND ss_sold_date_sk = d1.d_date_sk AND sr_returned_date_sk = d2.d_date_sk AND ss_customer_sk = sr_customer_sk AND ss_store_sk = s_store_sk AND d1.d_date BETWEEN (d2.d_date - INTERVAL '120 DAY') AND d2.d_date GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p03: early_filter (ERROR, n/a)
```sql
WITH valid_dates AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN (SELECT d_date - INTERVAL '120 DAY' FROM date_dim WHERE d_year = 1999 AND d_moy = 7) AND (SELECT d_date FROM date_dim WHERE d_year = 1999 AND d_moy = 7)) SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales JOIN valid_dates AS vd ON ss_sold_date_sk = vd.d_date_sk, store_returns, store, date_dim AS d1, date_dim AS d2 WHERE d2.d_year = 1999 AND d2.d_moy = 7 AND ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND sr_returned_date_sk = d2.d_date_sk AND ss_customer_sk = sr_customer_sk AND ss_store_sk = s_store_sk GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p11: decorrelate (ERROR, n/a)
```sql
WITH valid_dates AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN (SELECT d_date - INTERVAL '120 DAY' FROM date_dim WHERE d_year = 1999 AND d_moy = 7) AND (SELECT d_date FROM date_dim WHERE d_year = 1999 AND d_moy = 7)) SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales, store_returns, store, date_dim AS d1 JOIN valid_dates AS vd ON d1.d_date_sk = vd.d_date_sk, date_dim AS d2 WHERE d2.d_year = 1999 AND d2.d_moy = 7 AND ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND ss_sold_date_sk = d1.d_date_sk AND sr_returned_date_sk = d2.d_date_sk AND ss_customer_sk = sr_customer_sk AND ss_store_sk = s_store_sk GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p05: materialized_dimension_fact_prefilter (ERROR, n/a)
```sql
WITH d2_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy = 7), filtered_store_returns AS (SELECT sr_item_sk, sr_ticket_number, sr_customer_sk, sr_returned_date_sk, ss_sold_date_sk FROM store_returns AS sr JOIN d2_cte AS d2 ON sr.sr_returned_date_sk = d2.d_date_sk) SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales AS ss JOIN filtered_store_returns AS fsr ON ss.ss_item_sk = fsr.sr_item_sk AND ss.ss_ticket_number = fsr.sr_ticket_number AND ss.ss_customer_sk = fsr.sr_customer_sk JOIN store AS s ON ss.ss_store_sk = s.s_store_sk JOIN date_dim AS d1 ON ss.ss_sold_date_sk = d1.d_date_sk WHERE d2.d_year = 1999 AND d2.d_moy = 7 AND ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND ss_sold_date_sk = d1.d_date_sk AND sr_returned_date_sk = d2.d_date_sk AND ss_customer_sk = sr_customer_sk AND ss_store_sk = s_store_sk AND d1.d_date BETWEEN (d2.d_date - INTERVAL '120 DAY') AND d2.d_date GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p02: date_cte_explicit_join (ERROR, n/a)
```sql
WITH d2_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy = 7) SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales JOIN store_returns ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND ss_customer_sk = sr_customer_sk JOIN store ON ss_store_sk = s_store_sk JOIN date_dim AS d1 ON ss_sold_date_sk = d1.d_date_sk JOIN d2_cte ON sr_returned_date_sk = d2_cte.d_date_sk WHERE d1.d_date BETWEEN (d2_cte.d_date - INTERVAL '120 DAY') AND d2_cte.d_date GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p04: multi_dimension_prefetch (ERROR, n/a)
```sql
WITH d2_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy = 7), d1_cte AS (SELECT d_date_sk FROM date_dim AS d2 JOIN (SELECT d_date_sk, d_date FROM date_dim) AS d1 ON d1.d_date BETWEEN (d2.d_date - INTERVAL '120 DAY') AND d2.d_date JOIN d2_cte AS d2 ON d2.d_date_sk = d2.d_date_sk) SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales AS ss JOIN store_returns AS sr ON ss.ss_ticket_number = sr.sr_ticket_number AND ss.ss_item_sk = sr.sr_item_sk AND ss.ss_customer_sk = sr.sr_customer_sk JOIN store AS s ON ss.ss_store_sk = s.s_store_sk JOIN d1_cte AS d1 ON ss.ss_sold_date_sk = d1.d_date_sk JOIN d2_cte AS d2 ON sr.sr_returned_date_sk = d2.d_date_sk GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p01: dimension_prefetch_star (ERROR, n/a)
```sql
WITH d2_cte AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_year = 1999 AND d_moy = 7), d1_cte AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN (SELECT MIN(d_date) - INTERVAL '120 DAY' FROM d2_cte) AND (SELECT MAX(d_date) FROM d2_cte)) SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales JOIN store_returns ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND ss_customer_sk = sr_customer_sk JOIN store ON ss_store_sk = s_store_sk JOIN d1_cte ON ss_sold_date_sk = d1_cte.d_date_sk JOIN d2_cte ON sr_returned_date_sk = d2_cte.d_date_sk WHERE TRUE GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p12: single_pass_aggregation (ERROR, n/a)
```sql
SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales, store_returns, store, date_dim AS d1, date_dim AS d2 WHERE d2.d_year = 1999 AND d2.d_moy = 7 AND ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND ss_sold_date_sk = d1.d_date_sk AND sr_returned_date_sk = d2.d_date_sk AND ss_customer_sk = sr_customer_sk AND ss_store_sk = s_store_sk AND d1.d_date BETWEEN (d2.d_date - INTERVAL '120 DAY') AND d2.d_date GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p10: sf_sk_pushdown_multi_fact (ERROR, n/a)
```sql
SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales, store_returns, store, date_dim AS d1, date_dim AS d2 WHERE d2.d_year = 1999 AND d2.d_moy = 7 AND ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND ss_sold_date_sk = d1.d_date_sk AND sr_returned_date_sk = d2.d_date_sk AND ss_customer_sk = sr_customer_sk AND ss_store_sk = s_store_sk AND d1.d_date BETWEEN (d2.d_date - INTERVAL '120 DAY') AND d2.d_date AND ss_sold_date_sk BETWEEN (SELECT MIN(d_date_sk) FROM date_dim WHERE d_year = 1999 AND d_moy = 7) AND (SELECT MAX(d_date_sk) FROM date_dim WHERE d_year = 1999 AND d_moy = 7) GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p06: aggregate_pushdown (ERROR, n/a)
```sql
WITH aggregated_returns AS (SELECT ss_store_sk, sr_returned_date_sk, ss_sold_date_sk FROM store_sales JOIN store_returns ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk WHERE ss_customer_sk = sr_customer_sk) SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM aggregated_returns AS ar, store AS s, date_dim AS d1, date_dim AS d2 WHERE d2.d_year = 1999 AND d2.d_moy = 7 AND ar.ss_store_sk = s.s_store_sk AND ss_sold_date_sk = d1.d_date_sk AND sr_returned_date_sk = d2.d_date_sk AND d1.d_date BETWEEN (d2.d_date - INTERVAL '120 DAY') AND d2.d_date GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```

### p07: channel_bitmap_aggregation (ERROR, n/a)
```sql
SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS "30 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30) AND (sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS "31-60 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60) AND (sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS "61-90 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90) AND (sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS "91-120 days", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS ">120 days" FROM store_sales AS ss JOIN store_returns AS sr ON ss.ss_ticket_number = sr.sr_ticket_number AND ss.ss_item_sk = sr.sr_item_sk AND ss.ss_customer_sk = sr.sr_customer_sk JOIN store AS s ON ss.ss_store_sk = s.s_store_sk JOIN date_dim AS d1 ON ss.ss_sold_date_sk = d1.d_date_sk JOIN date_dim AS d2 ON sr.sr_returned_date_sk = d2.d_date_sk WHERE d2.d_year = 1999 AND d2.d_moy = 7 AND d1.d_date BETWEEN (d2.d_date - INTERVAL '120 DAY') AND d2.d_date GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100;
```
