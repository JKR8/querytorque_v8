### Step 1 — Compare EXPLAIN Plans

**Analysis of t1 (0.67x REGRESSION):**
- **Expensive new operators**:
  - `Aggregate  (rows=76612, time=307.467)` (store_sales DISTINCT) and `Aggregate  (rows=49355, time=139.996)` (catalog_sales DISTINCT) are new costly operations.
  - `Nested Loop  (rows=914, time=699.42)` is 2.2x slower than original `Hash Join (time=477.645)`.
- **Why backfired**: Materializing DISTINCT sales customers via CTEs added expensive aggregations. The LEFT JOIN approach converted efficient anti-joins into full sales table scans with post-aggregation, increasing intermediate rows (e.g., 487k store_sales rows vs original 164k).

**Analysis of t3 (0.75x REGRESSION):**
- **Expensive new operators**:
  - `Nested Loop  (rows=493555, time=227.05)` (store_sales) is 2.75x slower than original `Nested Loop (rows=164518, time=82.46)`.
  - `Hash Join  (rows=487842, time=266.511)` is 45% slower than original equivalent.
- **Why backfired**: Materializing date_range CTE broke index usage, causing larger nested loops. The explicit join reordering didn't reduce the core bottleneck (large sales table scans).

---

### Step 2 — Design Targets

**Primary Bottleneck**: Large nested loops on sales tables (`Nested Loop  (rows=164518, time=82.46)` for store_sales) due to repeated full scans during EXISTS checks.

**Target 1: Combination (A+E+B)**  
- **Family**: A+E+B  
- **Transform**: `early_filter_then_decorrelate`  
- **Target ID**: t6  
- **Relevance**: 0.95 (complements best ideas from history)  
- **Hypothesis**: Prefilter customers (A) reduces rows feeding sales scans. Materialize date_range (E) avoids repeated dim scans. Decorrelate (B) converts EXISTS to semijoins on precomputed sales sets, eliminating per-row re-execution. Targets `Nested Loop (rows=164518)` and `Hash Join (rows=18082)` from original.  
- **Target IR**:  
  - `insert_cte` for `filtered_customers` (customer + address + demographics filters)  
  - `insert_cte` for `date_range` (d_date_sk for 1999/moy 3-5)  
  - `delete_expr_subtree` EXISTS clauses  
  - `replace_from` with semijoins to precomputed sales sets  
- **Examples**: `pg_date_cte_explicit_join`, `shared_scan_decorrelate`, `multi_dimension_prefetch`

**Target 2: Refinement (A+E)**  
- **Family**: A+E  
- **Transform**: `filtered_customers_date_range`  
- **Target ID**: t7  
- **Relevance**: 0.90 (simpler, avoids decorrelation risks)  
- **Hypothesis**: Prefilter customers (A) reduces `Hash Join (rows=18082)`. Materialize date_range (E) cuts repeated `Index Only Scan on date_dim`. Targets most expensive remaining operator `Nested Loop (rows=164518)` by reducing input customers.  
- **Target IR**:  
  - `insert_cte` for `filtered_customers`  
  - `insert_cte` for `date_range`  
  - `replace_expr_subtree` date_dim scans in subqueries → CTE  
  - `replace_from` original tables → `filtered_customers`  
- **Examples**: `pg_date_cte_explicit_join`, `multi_dimension_prefetch`

**Target 3: Rescue (B)**  
- **Family**: B  
- **Transform**: `decorrelate_sales_semijoin`  
- **Target ID**: t8  
- **Relevance**: 0.85 (fixes t1's DISTINCT flaw)  
- **Hypothesis**: Decorrelate with semijoins instead of DISTINCT. Convert EXISTS to `WHERE c.c_customer_sk IN (SELECT ...)` using date_range CTE. Avoids t1's costly aggregates, targets `Nested Loop (rows=164518)`.  
- **Target IR**:  
  - `insert_cte` for `date_range`  
  - `replace_expr_subtree` EXISTS clauses with `IN (SELECT ...)`  
  - `delete_expr_subtree` redundant subquery joins  
- **Examples**: `pg_intersect_to_exists`, `shared_scan_decorrelate`

**Target 4: Novel (F)**  
- **Family**: F  
- **Transform**: `fact_tables_last_join`  
- **Target ID**: t9  
- **Relevance**: 0.80 (targets sales scan bottleneck)  
- **Hypothesis**: Push sales tables to last in join order. Use explicit `LEFT JOIN ... ON ... AND` with date filters to avoid nested loops. Targets `Nested Loop (rows=164518)` by delaying sales access until after customer filtering.  
- **Target IR**:  
  - `replace_from` comma joins → explicit `LEFT JOIN store_sales ON ... AND d_year=1999 ...`  
  - `replace_where_predicate` EXISTS clauses → `LEFT JOIN ... WHERE ... IS [NOT] NULL`  
- **Examples**: `pg_explicit_join_materialized`

---

### Final Targets (JSON)

```json
[
  {
    "family": "A+E+B",
    "transform": "early_filter_then_decorrelate",
    "target_id": "t6",
    "relevance_score": 0.95,
    "hypothesis": "Prefilter customers (A) reduces rows for sales scans. Materialize date_range (E) avoids repeated dim scans. Decorrelate (B) converts EXISTS to semijoins, eliminating per-row re-execution of sales scans (targets Nested Loop rows=164518).",
    "target_ir": "Insert CTE for filtered_customers (customer+address+demo filters). Insert CTE for date_range. Replace EXISTS clauses with semijoins to precomputed sales sets using date_range.",
    "recommended_examples": ["pg_date_cte_explicit_join", "shared_scan_decorrelate", "multi_dimension_prefetch"]
  },
  {
    "family": "A+E",
    "transform": "filtered_customers_date_range",
    "target_id": "t7",
    "relevance_score": 0.90,
    "hypothesis": "Prefilter customers (A) reduces Hash Join (rows=18082). Materialize date_range (E) cuts repeated date_dim scans. Targets Nested Loop (rows=164518) by reducing input customers.",
    "target_ir": "Insert CTE for filtered_customers. Insert CTE for date_range. Replace date_dim scans in subqueries with CTE reference. Replace FROM clause with filtered_customers CTE.",
    "recommended_examples": ["pg_date_cte_explicit_join", "multi_dimension_prefetch"]
  },
  {
    "family": "B",
    "transform": "decorrelate_sales_semijoin",
    "target_id": "t8",
    "relevance_score": 0.85,
    "hypothesis": "Decorrelate with IN-subqueries using date_range CTE. Avoids t1's costly DISTINCT aggregates while eliminating per-row re-scans of sales tables (targets Nested Loop rows=164518).",
    "target_ir": "Insert CTE for date_range. Replace EXISTS clauses with IN (SELECT ... FROM sales JOIN date_range).",
    "recommended_examples": ["pg_intersect_to_exists", "shared_scan_decorrelate"]
  },
  {
    "family": "F",
    "transform": "fact_tables_last_join",
    "target_id": "t9",
    "relevance_score": 0.80,
    "hypothesis": "Delay sales table access via explicit LEFT JOIN + date filters. Avoids early nested loops by processing sales last after customer filtering (targets Nested Loop rows=164518).",
    "target_ir": "Replace comma joins with explicit LEFT JOIN store_sales ON c_customer_sk=ss_customer_sk AND d_year=1999.... Convert EXISTS to WHERE ... IS [NOT] NULL.",
    "recommended_examples": ["pg_explicit_join_materialized"]
  }
]
```