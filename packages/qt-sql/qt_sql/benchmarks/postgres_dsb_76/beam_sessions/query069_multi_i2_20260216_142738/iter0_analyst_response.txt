### Analysis of Families

**Family A (Early Filtering)**: HIGH  
The main query filters dimension tables (`customer_address`, `customer_demographics`) late. Pushing state/status filters into CTEs early reduces rows before expensive anti-joins.

**Family B (Decorrelation)**: HIGH  
Correlated subqueries (`EXISTS`/`NOT EXISTS`) cause repeated scans of sales tables per customer row. Decorrelation via pre-aggregated CTEs eliminates per-row re-execution.

**Family C (Aggregation Pushdown)**: LOW  
GROUP BY keys are not a subset of join keys. Aggregation can't be pushed before joins since demographics depend on customer joins.

**Family D (Set Operations)**: LOW  
No `INTERSECT`/`UNION` operations. Anti-joins already use `NOT EXISTS` (optimal pattern).

**Family E (Materialization)**: HIGH  
`date_dim` is scanned 3× with identical filters. Materializing date keys once avoids redundant work.

**Family F (Join Transform)**: MEDIUM  
Implicit joins (`c, ca, cd`) could become explicit, but less critical than decorrelation/materialization.

**Chosen families**: [B, E, A]  
**Confidence**: High

### Optimization Targets

```json
[
  {
    "family": "B",
    "transform": "decorrelation",
    "target_id": "t1",
    "relevance_score": 0.98,
    "hypothesis": "Correlated subqueries re-scan sales tables per customer row. Precomputing customer sets for each channel via CTEs eliminates nested loops.",
    "target_ir": "S0 [SELECT]\n  CTE: store_customers (via Q1)\n    SELECT DISTINCT ss_customer_sk\n    FROM store_sales\n    JOIN date_dim ON ss_sold_date_sk = d_date_sk\n    WHERE d_year=1999 AND d_moy BETWEEN 3 AND 5\n      AND ss_list_price BETWEEN 52 AND 141\n  CTE: web_customers (via Q2)\n    SELECT DISTINCT ws_bill_customer_sk\n    FROM web_sales\n    JOIN date_dim ON ws_sold_date_sk = d_date_sk\n    WHERE d_year=1999 AND d_moy BETWEEN 3 AND 5\n      AND ws_list_price BETWEEN 52 AND 141\n  CTE: catalog_customers (via Q3)\n    SELECT DISTINCT cs_ship_customer_sk\n    FROM catalog_sales\n    JOIN date_dim ON cs_sold_date_sk = d_date_sk\n    WHERE d_year=1999 AND d_moy BETWEEN 3 AND 5\n      AND cs_list_price BETWEEN 52 AND 141\n  MAIN QUERY (via Q0)\n    FROM customer c\n    JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk\n    JOIN customer_demographics ON cd_demo_sk = c.c_current_cdemo_sk\n    JOIN store_customers sc ON c.c_customer_sk = sc.ss_customer_sk\n    LEFT JOIN web_customers wc ON c.c_customer_sk = wc.ws_bill_customer_sk\n    LEFT JOIN catalog_customers cc ON c.c_customer_sk = cc.cs_ship_customer_sk\n    WHERE ca_state IN ('GA','KY','SD')\n      AND cd_marital_status IN ('D','W','U')\n      AND cd_education_status IN ('Primary','College')\n      AND wc.ws_bill_customer_sk IS NULL\n      AND cc.cs_ship_customer_sk IS NULL\n    GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating\n    ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating",
    "recommended_examples": ["pg_shared_scan_decorrelate"]
  },
  {
    "family": "E",
    "transform": "date_materialization",
    "target_id": "t2",
    "relevance_score": 0.92,
    "hypothesis": "Identical date_dim scans repeated 3×. Materializing date keys first reduces redundant I/O and computation.",
    "target_ir": "S0 [SELECT]\n  CTE: date_filter (via Q0)\n    SELECT d_date_sk\n    FROM date_dim\n    WHERE d_year=1999 AND d_moy BETWEEN 3 AND 5\n  CTE: store_customers (via Q1)\n    SELECT DISTINCT ss_customer_sk\n    FROM store_sales\n    JOIN date_filter ON ss_sold_date_sk = d_date_sk\n    WHERE ss_list_price BETWEEN 52 AND 141\n  CTE: web_customers (via Q2)\n    SELECT DISTINCT ws_bill_customer_sk\n    FROM web_sales\n    JOIN date_filter ON ws_sold_date_sk = d_date_sk\n    WHERE ws_list_price BETWEEN 52 AND 141\n  CTE: catalog_customers (via Q3)\n    SELECT DISTINCT cs_ship_customer_sk\n    FROM catalog_sales\n    JOIN date_filter ON cs_sold_date_sk = d_date_sk\n    WHERE cs_list_price BETWEEN 52 AND 141\n  ... [MAIN QUERY same as t1]",
    "recommended_examples": ["multi_dimension_prefetch"]
  },
  {
    "family": "A",
    "transform": "dimension_prefilter",
    "target_id": "t3",
    "relevance_score": 0.85,
    "hypothesis": "State/status filters applied late. Pre-filtering dimensions in CTEs reduces rows before anti-joins.",
    "target_ir": "S0 [SELECT]\n  ... [date_filter CTE from t2]\n  CTE: addr_filter (via Q1)\n    SELECT ca_address_sk\n    FROM customer_address\n    WHERE ca_state IN ('GA','KY','SD')\n  CTE: demo_filter (via Q2)\n    SELECT cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating\n    FROM customer_demographics\n    WHERE cd_marital_status IN ('D','W','U')\n      AND cd_education_status IN ('Primary','College')\n  ... [store_customers, web_customers, catalog_customers CTEs from t2]\n  MAIN QUERY (via Q0)\n    FROM customer c\n    JOIN addr_filter af ON c.c_current_addr_sk = af.ca_address_sk\n    JOIN demo_filter df ON c.c_current_cdemo_sk = df.cd_demo_sk\n    JOIN store_customers sc ON c.c_customer_sk = sc.ss_customer_sk\n    LEFT JOIN ... [anti-joins same as t1]\n    GROUP BY df.cd_gender, df.cd_marital_status, df.cd_education_status, df.cd_purchase_estimate, df.cd_credit_rating\n    ORDER BY ... [same as original]",
    "recommended_examples": ["pg_date_cte_explicit_join"]
  }
]
```