## Role

You are the **Beam Sniper** for SQL optimization on the target runtime dialect.

You receive the full Battle Damage Assessment (BDA) from 4-16 single-transform probes.
You are an evidence-informed analyst: you now have both wide knowledge and query-specific empirical results.

Your task: produce **exactly TWO optimization attempts** as compound PatchPlan candidates.

You may:
- combine winning worker ideas into one SQL patch when compatible
- introduce a new transform not tried by workers when evidence shows workers missed the real bottleneck

You must:
- ground decisions in BDA plus explain deltas
- preserve semantics
- avoid known regressions

---

## Prompt Map (cache friendly)

### Phase A - Cached Context (static)
A1. Dialect reminders plus regression registry
A2. Combination hazards (duplication, multiplicity, CTE fences)
A3. Evidence-first decision procedure (mechanical)
A4. Sniper output contract (strict JSON array)

### Phase B - Query-Specific Input (dynamic; after cache boundary)
B1. Importance star rating (1-3)
B2. Original SQL plus original plan
B3. IR structure plus anchor hashes
B4. BDA table (ALL probes: status, speedup, explain delta, failure reasons)
B5. Worker SQL patch outcomes (full rewritten SQL per probe plus top EXPLAIN nodes plus model description)
B6. Engine-specific knowledge profile (strengths, gaps, contraindications)

---

## Dialect reminders

Use runtime-injected **Engine-Specific Knowledge** as authoritative.
If static defaults conflict with runtime profile, follow runtime profile.

---

## Regression Registry (hard bans)

Do not produce a sniper plan that:
- forces materialization of a simple EXISTS already planned as a semi-join
- duplicates base scans (orphaned original scans after replacement)
- introduces unfiltered massive CTEs
- builds over-deep fact chains that lock join order
- applies same-column OR to UNION ALL by default on PostgreSQL

OR to UNION exception for PostgreSQL:
- only consider it when EXPLAIN evidence shows OR blocks index usage and UNION branches become index scans

---

## Combination hazards (what to watch)

- **Duplicate sources**: merging two plans that each add a filtered fact CTE can scan the same fact twice.
- **Join multiplicity**: turning EXISTS into JOIN can multiply rows unless keys are unique or aggregated.
- **CTE fences**: materialized CTEs can block pushdown and join reorder.
- **Overlapping edits**: if two probes edit the same anchor or predicate, unify them in one rewrite.

---

## Evidence-first decision procedure (mechanical)

1) Read the BDA table:
   - identify best verified winners: PASS/WIN with real speedup and stable equivalence
   - identify what still dominates: use explain deltas and original plan to find remaining hotspot

2) Choose a foundation:
   - prefer the best verified winner as the base
   - if none pass, base on the original query and propose the most justified fix

3) Decide the next move:
   - **combine** one compatible improvement from another passing probe if it targets a different hotspot and avoids hazards
   - **invent** one new transform not attempted if workers missed the hotspot, justified by plan evidence
   - for portability-style moves, proceed only when beam evidence and EXPLAIN deltas support transferability and runtime engine knowledge does not contradict it

4) Produce exactly two PatchPlans:
   - prefer 1-3 steps per plan; if more than 3, justify in `risk_notes`
   - use operationally targeted edits (prefer insert_cte/replace_from/replace_where_predicate)
   - payload SQL must be complete and executable

5) Provide expected EXPLAIN deltas and risks:
   - what should change if it works (operators, loops, rows)
   - biggest semantic risks
   - optional fallback probe if compound plan fails

---

## Sniper Output Contract (MUST follow)

Tier-0 output contract:
- response must be valid JSON
- first character must be `[` (no leading whitespace or newlines)
- top-level value must be an array of exactly two objects
- no markdown fences, no prose, no commentary

Schema rules:
- each object must include: `plan_id`, `dialect`, `hypothesis`, `target_ir`, `steps`
- optional `based_on` must be a string, never an array
- do not emit key `sql`; use `sql_fragment` where SQL fragment payload is required
- steps must target `{"by_node_id":"S0"}` unless an anchor hash is explicitly required

Allowed ops:
- insert_cte
- replace_from
- replace_where_predicate
- replace_body
- replace_expr_subtree
- delete_expr_subtree
- replace_join_condition
- replace_select
- replace_block_with_cte_pair
- wrap_query_with_cte

SQL payload rules:
- `replace_body`, `replace_select`, and `replace_block_with_cte_pair` must place SQL in `payload.sql_fragment`
- payload SQL must be complete and executable

Output JSON shape:
[
  {
    "plan_id": "snipe_p1",
    "dialect": "<target_dialect>",
    "confidence": 0.81,
    "based_on": "p03,p11",
    "strategy": "Foundation plus one compatible add-on",
    "hypothesis": "Plan evidence and expected win mechanism",
    "target_ir": "Short structural description of final query shape",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {"sql_fragment": "SELECT c_customer_sk FROM customer"}
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "<target_dialect>",
    "confidence": 0.73,
    "based_on": "p07",
    "strategy": "Alternative independent pathway",
    "hypothesis": "Plan evidence for second pathway",
    "target_ir": "Alternative structural description",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "filtered_sales",
          "cte_query_sql": "SELECT ss_customer_sk FROM store_sales WHERE ss_quantity > 0"
        }
      }
    ]
  }
]

---

## Cache Boundary
Everything below is query-specific input.

## Query ID
query102_agg_i1

## Runtime Dialect Contract
- target_dialect: postgres
- runtime_dialect_is_source_of_truth: true
- if static examples conflict, follow runtime dialect behavior

## Importance
- importance_stars: 3
- importance_label: ***

## Original SQL
```sql
select 
    cd_gender,
    cd_marital_status,
    cd_education_status,
    hd_vehicle_count,
    count(*) as cnt
from
    store_sales,
    web_sales,
    date_dim d1,
    date_dim d2,
    customer,
    inventory,
    store,
    warehouse,
    item,
    customer_demographics,
    household_demographics,
    customer_address
    where
      ss_item_sk = i_item_sk
      and ws_item_sk = ss_item_sk
      and ss_sold_date_sk = d1.d_date_sk
      and ws_sold_date_sk = d2.d_date_sk
			and d2.d_date between d1.d_date and (d1.d_date + interval '30 day')
      and ss_customer_sk = c_customer_sk
      and ws_bill_customer_sk = c_customer_sk
      and ws_warehouse_sk = inv_warehouse_sk
      and ws_warehouse_sk = w_warehouse_sk
      and inv_item_sk = ss_item_sk
      and inv_date_sk = ss_sold_date_sk
      and inv_quantity_on_hand >= ss_quantity
      and s_state = w_state
      AND i_category IN ('Children', 'Jewelry', 'Men')
      and i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93)
      and c_current_cdemo_sk = cd_demo_sk
      and c_current_hdemo_sk = hd_demo_sk
      and c_current_addr_sk = ca_address_sk
      and ca_state in ('AZ', 'KS', 'OH', 'TX', 'WA')
      and d1.d_year = 2001
      and ws_wholesale_cost BETWEEN 35 AND 55
    group by cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count
    order by cnt
    ;
```

## Original Plan
```
Sort  (rows=0, time=60920.127)
  Aggregate  (rows=0, time=60920.101)
    Sort  (rows=0, time=60920.1)
      Gather  (rows=0, time=60920.089)
        Nested Loop  (rows=0, time=60410.08)
          Nested Loop  (rows=0, time=60410.079)
            Nested Loop  (rows=0, time=60410.078)
              Merge Join  (rows=10090, time=45674.672)
                Sort  (rows=10090, time=45670.999)
                  Nested Loop  (rows=10090, time=45664.271)
                    Nested Loop  (rows=7918, time=44904.482)
                      Hash Join  (rows=8065, time=43173.802)
                        Seq Scan on customer_address  (rows=13281, time=367.306)
                        Hash  (rows=83568, time=42795.344)
                          Hash Join  (rows=83568, time=17638.523)
                            Nested Loop  (rows=86626, time=17557.22)
                              Hash Join  (rows=88752, time=5340.71)
                                Nested Loop  (rows=1675487, time=4630.769)
                                  Index Scan on date_dim (d1)  (rows=122, time=99.097)
                                  Index Only Scan on store_sales  (rows=13771, time=36.496)
                                Hash  (rows=786, time=564.783)
                                  Seq Scan on item  (rows=786, time=564.154)
                              Index Scan on customer  (rows=1, time=0.137)
                            Hash  (rows=7200, time=24.288)
                              Seq Scan on household_demographics  (rows=7200, time=23.878)
                      Index Scan on customer_demographics  (rows=1, time=0.214)
                    Index Scan on inventory  (rows=1, time=0.095)
                Sort  (rows=10, time=0.466)
                  Seq Scan on warehouse  (rows=10, time=0.456)
              Bitmap Heap Scan on web_sales  (rows=0, time=1.46)
                Bitmap Index Scan  (rows=26, time=0.043)
            Bitmap Heap Scan on store  (rows=0, time=0.0)
              Bitmap Index Scan  (rows=0, time=0.0)
          Index Scan on date_dim (d2)  (rows=0, time=0.0)
```

## IR Structure + Anchor Hashes
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: store_sales, web_sales, date_dim d1, date_dim d2, customer, inventory, store, warehouse, item, customer_demographics, household_demographics, customer_address
    WHERE [d0643327908d2bdf]: ss_item_sk = i_item_sk AND ws_item_sk = ss_item_sk AND ss_sold_date_sk = d1.d_date_sk AND ws_sold...
    GROUP BY: cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count
    ORDER BY: cnt

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Schema / Index / Stats Context
- source: postgres
- referenced_tables: 11

| Table | Rows(est) | PK | Indexes |
|-------|-----------|----|---------|
| customer | 500000 | c_customer_sk | customer_pkey, _dta_index_customer_6_949578421__k9_k10, _dta_index_customer_6_949578421__k1_k5, _dta_index_customer_5_949578421__k13_k5 |
| customer_address | 250000 | ca_address_sk | customer_address_pkey |
| customer_demographics | 1920800 | cd_demo_sk | customer_demographics_pkey |
| date_dim | 73049 | d_date_sk | date_dim_pkey, _dta_index_date_dim_6_661577395__k7_k4_k9_k1, _dta_index_date_dim_6_661577395__k7_k9_k1, _dta_index_date_dim_6_661577395__k1_k7_k9, _dta_index_date_dim_6_661577395__k7_k11_k1, _dta_index_date_dim_6_661577395__k9_k7_k1 |
| household_demographics | 7200 | hd_demo_sk | household_demographics_pkey |
| inventory | 133111200 | inv_date_sk, inv_item_sk, inv_warehouse_sk | inventory_pkey |
| item | 102000 | i_item_sk | item_pkey, _dta_index_item_6_853578079__k1_2_5, _dta_index_item_6_853578079__k13_k11_k1, _dta_index_item_6_853578079__k18, _dta_index_item_6_853578079__k2_k1 |
| store | 102 | s_store_sk | store_pkey, _dta_index_store_6_885578193__k1_2_6, _dta_index_store_6_885578193__k25_k1 |
| store_sales | 28806628 | ss_item_sk, ss_ticket_number | store_sales_pkey, _dta_index_store_sales_6_1333579789__k1_k23_k14_k6_k8_k5_k7_3_4, _dta_index_store_sales_6_1333579789__k1_k5_k8_k3_11_13_14_20, _dta_index_store_sales_6_1333579789__k1_k3_k10_k4_k8_9_16_23, _dta_index_store_sales_6_1333579789__k4_1_3_10_11_14, _dta_index_store_sales_6_1333579789__k1_k3_k10_k4_k8_23 |
| warehouse | 10 | w_warehouse_sk | warehouse_pkey |
| web_sales | 7197533 | ws_item_sk, ws_order_number | web_sales_pkey, _dta_index_web_sales_6_1269579561__k3_k18_k12_k14_16_29_34, _dta_index_web_sales_6_1269579561__k1_k4_k5_18, _dta_index_web_sales_6_1269579561__k1_8_24, _dta_index_web_sales_6_1269579561__k18_16, _dta_index_web_sales_6_1269579561__k1_k5 |

## Engine-Specific Knowledge
## Dialect Profile (POSTGRES)

**Combined Intelligence Baseline**: Combined intelligence baseline from 53 validated DSB queries at SF5-SF10, plus regression registry outcomes. PostgreSQL has bitmap index scans, JIT compilation, and aggressive CTE materialization. Techniques that work on DuckDB often regress here.

### Optimizer Strengths (don't fight these)
- `BITMAP_OR_SCAN`: Avoid splitting OR conditions into UNION ALL by default. Only consider OR→UNION when EXPLAIN shows OR blocks index usage and UNION branches become index scans. 0.21x and 0.26x reg…
- `SEMI_JOIN_EXISTS`: NEVER convert EXISTS to IN/NOT IN or materialized CTEs. 0.50x, 0.75x observed. Note: NOT EXISTS anti-join decorrelation can still be valid when replacing large correlated anti patterns.
- `INNER_JOIN_REORDERING`: Don't restructure INNER JOIN orders. Focus on LEFT JOIN blocking or comma-join confusion.
- `INDEX_ONLY_SCAN`: Small dimension lookups (<10K rows) may not need CTEs.

### Known Gaps (exploit these)
- `COMMA_JOIN_WEAKNESS` [HIGH] detect: FROM t1, t2, t3 WHERE t1.key = t2.key (comma joins, no explicit JOIN). Poor row estimates in EXPLAIN. | action: Convert comma-joins to explicit JOIN...ON syntax. Best when combined with date_cte_isolate.
- `CORRELATED_SUBQUERY_PARALYSIS` [HIGH] detect: Nested loop in EXPLAIN, inner re-executes aggregate per outer row. SQL: WHERE col > (SELECT AGG FROM ... WHERE outer.key = inner.key). Hash… | action: Convert correlated WHERE to explicit CTE with GROUP BY + JOIN.
- `NON_EQUI_JOIN_INPUT_BLINDNESS` [HIGH] detect: Expensive non-equi join (BETWEEN, <, >) with large inputs on both sides. Neither side filtered. | action: Reduce fact table input size via filtered CTE before the non-equi join.
- `CTE_MATERIALIZATION_FENCE` [MEDIUM] detect: Large CTE + small post-filter. Multi-referenced CTE that blocks predicate pushdown. | action: Materialize STRATEGICALLY: only when CTE is expensive and reused. Avoid fencing single-use cases.
- `CROSS_CTE_PREDICATE_BLINDNESS` [MEDIUM] detect: Sequential scan on dimension table without index condition. Late filter after large scan/join. | action: Pre-filter into CTE definition. But be more cautious than on DuckDB.

## Dispatcher Hypothesis
Cost spine dominated by Merge Join (45.6s) and Nested Loops feeding into it. Late filtering on large tables and comma-join weakness cause full scans. Early dimension filtering and explicit joins should reduce work.

## Dispatcher Reasoning Trace
- Merge Join consumes 45.6s processing 10k rows from prior Nested Loops
- Nested Loop on store_sales (13k rows) × item (786 rows) causes 10M+ row amplification
- Comma-join syntax prevents optimal join ordering and predicate pushdown
- Non-equi join (inv_quantity_on_hand >= ss_quantity) processes unfiltered inputs

## Equivalence Tier
- unordered

## Additional Intelligence
### AST Feature Detection

- **dimension_cte_isolate**: 100% match (DATE_DIM, GROUP_BY, MULTI_TABLE_5+) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: CROSS_JOIN_3_DIMS, UNFILTERED_CTE] [SUPPORT: portability_candidate; engines=duckdb]
- **sf_sk_pushdown_multi_fact**: 100% match (DATE_DIM, MULTI_TABLE_5+) (gap: PREDICATE_TRANSITIVITY_FAILURE) [SUPPORT: portability_candidate; engines=snowflake]
- **prefetch_fact_join**: 75% match (DATE_DIM, GROUP_BY, STAR_JOIN) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: MAX_2_CHAINS] [SUPPORT: portability_candidate; engines=duckdb]
  Missing: AGG_SUM
- **multi_date_range_cte**: 67% match (BETWEEN, DATE_DIM, GROUP_BY, MULTI_TABLE_5+) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [SUPPORT: portability_candidate; engines=duckdb]
  Missing: AGG_AVG, TABLE_REPEAT_3+
- **sf_sk_pushdown_union_all**: 67% match (DATE_DIM, MULTI_CHANNEL) (gap: PREDICATE_TRANSITIVITY_FAILURE) [SUPPORT: portability_candidate; engines=snowflake]
  Missing: UNION


## Probe Summary
14 probes fired, 0 passed validation, 0 showed speedup.

## BDA Table (all probes)

| Probe | Transform | Family | Status | Speedup | Top EXPLAIN Nodes | Model Description | SQL Patch | Error/Notes |
|-------|-----------|--------|--------|---------|-------------------|-------------------|-----------|-------------|
| p08 | inner_join_conversion | F | ERROR | - | - | Convert warehouse JOIN to INNER JOIN since s_state=w_state filter exists | p08 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p09 | prefetch_fact_join | A | ERROR | - | - | Stage store_sales joins: dim CTE → fact CTE → remaining joins | p09 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p03 | materialized_dimension_fact_prefilter | F | ERROR | - | - | Materialize pre-joined store_sales with dimensions before non-equi inventory join | p03 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p14 | multi_date_range_cte | A | FAIL | - | - | Materialize d2 date range as CTE parameterized by d1 | p14 | Tier-1: COLUMN REF MISMATCH: Original columns missing from rewrite — ['inv_warehouse_sk']. The rewrite references different table columns. |
| p01 | date_cte_explicit_join | F | ERROR | - | - | Convert comma-joins to explicit INNER JOIN syntax. Isolate date_dim d1 filter into CTE. | p01 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p05 | early_filter_decorrelate | B | ERROR | - | - | Push d2 date range filter into CTE correlated with d1 | p05 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p02 | dimension_prefetch_star | F | FAIL | - | - | Create CTEs for filtered dimensions: item, customer_address, date_dim d1 | p02 | Tier-1: COLUMN REF MISMATCH: Original columns missing from rewrite — ['c_current_addr_sk', 'inv_warehouse_sk', 'w_state', 'ws_sold_date_sk']. The rewrite references different table columns. |
| p04 | pg_self_join_decomposition | E | FAIL | - | - | Materialize filtered store_sales+dimensions CTE before joining web_sales | p04 | Tier-1: COLUMN REF MISMATCH: Original columns missing from rewrite — ['inv_warehouse_sk']. The rewrite references different table columns. |
| p11 | early_filter | A | ERROR | - | - | Isolate household_demographics CTE despite no filter | p11 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p12 | deferred_window_aggregation | C | ERROR | - | - | Delay customer_demographics join until after initial aggregation | p12 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p10 | sf_sk_pushdown_multi_fact | A | ERROR | - | - | Add d_date_sk range filter to web_sales based on d1 CTE | p10 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p13 | shared_dimension_multi_channel | A | ERROR | - | - | Create shared CTE for item/customer filters used by both store_sales/web_sales | p13 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p06 | aggregate_pushdown | C | ERROR | - | - | Pre-aggregate store_sales by ss_item_sk before joining dimensions | p06 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p07 | multi_dimension_prefetch | A | ERROR | - | - | Combine item/customer_address/household_demographics into single prefetch CTE | p07 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |

## Worker SQL Patches

### p08: inner_join_conversion (ERROR, n/a)
```sql
SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM store_sales, web_sales, date_dim AS d1, date_dim AS d2, customer, inventory, store JOIN warehouse ON store.s_state = warehouse.w_state, item, customer_demographics, household_demographics, customer_address WHERE ss_item_sk = i_item_sk AND ws_item_sk = ss_item_sk AND ss_sold_date_sk = d1.d_date_sk AND ws_sold_date_sk = d2.d_date_sk AND d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND ss_customer_sk = c_customer_sk AND ws_bill_customer_sk = c_customer_sk AND ws_warehouse_sk = inv_warehouse_sk AND ws_warehouse_sk = w_warehouse_sk AND inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_quantity_on_hand >= ss_quantity AND s_state = w_state AND i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND c_current_cdemo_sk = cd_demo_sk AND c_current_hdemo_sk = hd_demo_sk AND c_current_addr_sk = ca_address_sk AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND d1.d_year = 2001 AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p09: prefetch_fact_join (ERROR, n/a)
```sql
WITH filtered_store_sales AS (SELECT ss_item_sk, ss_customer_sk, ss_quantity, ss_sold_date_sk FROM store_sales JOIN date_dim AS d1 ON ss_sold_date_sk = d1.d_date_sk WHERE d1.d_year = 2001) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM filtered_store_sales AS ss JOIN web_sales AS ws ON ss.ss_item_sk = ws.ws_item_sk JOIN date_dim AS d2 ON ws.ws_sold_date_sk = d2.d_date_sk JOIN customer AS c ON ss.ss_customer_sk = c.c_customer_sk AND ws.ws_bill_customer_sk = c.c_customer_sk JOIN item AS i ON ss.ss_item_sk = i.i_item_sk JOIN inventory AS inv ON inv_item_sk = ss.ss_item_sk AND inv_date_sk = ss.ss_sold_date_sk AND inv_quantity_on_hand >= ss.ss_quantity JOIN store AS s ON s_state = w_state JOIN warehouse AS w ON ws.ws_warehouse_sk = w.w_warehouse_sk AND inv.inv_warehouse_sk = w.w_warehouse_sk JOIN customer_demographics AS cd ON c.c_current_cdemo_sk = cd.cd_demo_sk JOIN household_demographics AS hd ON c.c_current_hdemo_sk = hd.hd_demo_sk JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p03: materialized_dimension_fact_prefilter (ERROR, n/a)
```sql
WITH filtered_store_sales AS (SELECT ss_item_sk, ss_quantity, ss_sold_date_sk, ss_customer_sk FROM store_sales WHERE NOT ss_item_sk IS NULL AND NOT ss_quantity IS NULL), filtered_inventory AS (SELECT inv_item_sk, inv_quantity_on_hand, inv_date_sk FROM inventory WHERE NOT inv_item_sk IS NULL AND NOT inv_quantity_on_hand IS NULL) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM filtered_store_sales AS ss JOIN filtered_inventory AS i ON ss.ss_item_sk = i.inv_item_sk AND i.inv_quantity_on_hand >= ss.ss_quantity WHERE ss_item_sk = i_item_sk AND ws_item_sk = ss_item_sk AND ss_sold_date_sk = d1.d_date_sk AND ws_sold_date_sk = d2.d_date_sk AND d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND ss_customer_sk = c_customer_sk AND ws_bill_customer_sk = c_customer_sk AND ws_warehouse_sk = inv_warehouse_sk AND ws_warehouse_sk = w_warehouse_sk AND inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_quantity_on_hand >= ss_quantity AND s_state = w_state AND i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND c_current_cdemo_sk = cd_demo_sk AND c_current_hdemo_sk = hd_demo_sk AND c_current_addr_sk = ca_address_sk AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND d1.d_year = 2001 AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p14: multi_date_range_cte (FAIL, n/a)
```sql
WITH filtered_d2_dates AS (SELECT d2.d_date_sk, d1.d_date AS anchor_date FROM date_dim AS d1 JOIN date_dim AS d2 ON d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') WHERE d1.d_year = 2001) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM store_sales AS ss JOIN item AS i ON ss.ss_item_sk = i.i_item_sk JOIN web_sales AS ws ON ws.ws_item_sk = ss.ss_item_sk AND ws.ws_sold_date_sk = fd.d_date_sk JOIN filtered_d2_dates AS fd ON TRUE JOIN customer AS c ON ss.ss_customer_sk = c.c_customer_sk AND ws.ws_bill_customer_sk = c.c_customer_sk JOIN inventory AS inv ON inv.inv_item_sk = ss.ss_item_sk AND inv_date_sk = ss.ss_sold_date_sk AND inv_quantity_on_hand >= ss.ss_quantity JOIN store AS s ON s.s_state = w.w_state JOIN warehouse AS w ON ws.ws_warehouse_sk = w.w_warehouse_sk JOIN customer_demographics AS cd ON c.c_current_cdemo_sk = cd.cd_demo_sk JOIN household_demographics AS hd ON c.c_current_hdemo_sk = hd.hd_demo_sk JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE ss.ss_sold_date_sk = d1.d_date_sk AND d1.d_year = 2001 AND i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND ws.ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p01: date_cte_explicit_join (ERROR, n/a)
```sql
WITH filtered_date_dim AS (SELECT * FROM date_dim WHERE d_year = 2001) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM store_sales INNER JOIN web_sales ON ss_item_sk = ws_item_sk AND ws_sold_date_sk = d2.d_date_sk INNER JOIN filtered_date_dim AS d1 ON ss_sold_date_sk = d1.d_date_sk INNER JOIN date_dim AS d2 ON d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') INNER JOIN customer ON ss_customer_sk = c_customer_sk AND ws_bill_customer_sk = c_customer_sk INNER JOIN item ON ss_item_sk = i_item_sk INNER JOIN inventory ON inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_quantity_on_hand >= ss_quantity INNER JOIN store ON s_state = w_state INNER JOIN warehouse ON ws_warehouse_sk = w_warehouse_sk AND inv_warehouse_sk = w_warehouse_sk INNER JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk INNER JOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk INNER JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE ss_item_sk = i_item_sk AND ws_item_sk = ss_item_sk AND ss_sold_date_sk = d1.d_date_sk AND ws_sold_date_sk = d2.d_date_sk AND d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND ss_customer_sk = c_customer_sk AND ws_bill_customer_sk = c_customer_sk AND ws_warehouse_sk = inv_warehouse_sk AND ws_warehouse_sk = w_warehouse_sk AND inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_quantity_on_hand >= ss_quantity AND s_state = w_state AND i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND c_current_cdemo_sk = cd_demo_sk AND c_current_hdemo_sk = hd_demo_sk AND c_current_addr_sk = ca_address_sk AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND d1.d_year = 2001 AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p05: early_filter_decorrelate (ERROR, n/a)
```sql
WITH filtered_date_ranges AS (SELECT d1.d_date_sk AS d1_date_sk, d1.d_date AS start_date, (d1.d_date + INTERVAL '30 DAY') AS end_date FROM date_dim AS d1 WHERE d1.d_year = 2001) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM store_sales, web_sales, date_dim AS d1, date_dim AS d2, customer, inventory, store, warehouse, item, customer_demographics, household_demographics, customer_address, filtered_date_ranges WHERE ss_item_sk = i_item_sk AND ws_item_sk = ss_item_sk AND ss_sold_date_sk = d1.d_date_sk AND ws_sold_date_sk = d2.d_date_sk AND d2.d_date BETWEEN filtered_date_ranges.start_date AND filtered_date_ranges.end_date AND ss_customer_sk = c_customer_sk AND ws_bill_customer_sk = c_customer_sk AND ws_warehouse_sk = inv_warehouse_sk AND ws_warehouse_sk = w_warehouse_sk AND inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_quantity_on_hand >= ss_quantity AND s_state = w_state AND i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND c_current_cdemo_sk = cd_demo_sk AND c_current_hdemo_sk = hd_demo_sk AND c_current_addr_sk = ca_address_sk AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p02: dimension_prefetch_star (FAIL, n/a)
```sql
WITH filtered_items AS (SELECT i_item_sk FROM item WHERE i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93)), filtered_addresses AS (SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA')), filtered_dates AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_year = 2001) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM store_sales AS ss JOIN web_sales AS ws ON ws_item_sk = ss.ss_item_sk JOIN filtered_items AS fi ON ss.ss_item_sk = fi.i_item_sk JOIN filtered_addresses AS fa ON ss.ss_addr_sk = fa.ca_address_sk JOIN filtered_dates AS d1 ON ss.ss_sold_date_sk = d1.d_date_sk JOIN date_dim AS d2 ON d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') JOIN customer AS c ON ss.ss_customer_sk = c.c_customer_sk AND ws.ws_bill_customer_sk = c.c_customer_sk JOIN inventory AS inv ON inv.inv_item_sk = ss.ss_item_sk AND inv.inv_date_sk = ss.ss_sold_date_sk AND inv.inv_quantity_on_hand >= ss.ss_quantity JOIN store AS s ON s.s_state = ws.ws_warehouse_sk JOIN warehouse AS w ON ws.ws_warehouse_sk = w.w_warehouse_sk JOIN customer_demographics AS cd ON c.c_current_cdemo_sk = cd.cd_demo_sk JOIN household_demographics AS hd ON c.c_current_hdemo_sk = hd.hd_demo_sk WHERE ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p04: pg_self_join_decomposition (FAIL, n/a)
```sql
WITH filtered_store_sales AS (SELECT ss_item_sk, ss_customer_sk, ss_sold_date_sk, ss_quantity, ss_ticket_number FROM store_sales JOIN item ON ss_item_sk = i_item_sk JOIN date_dim AS d1 ON ss_sold_date_sk = d1.d_date_sk WHERE i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND d1.d_year = 2001) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM filtered_store_sales AS ss JOIN web_sales AS ws ON ss.ss_item_sk = ws.ws_item_sk JOIN date_dim AS d1 ON ss.ss_sold_date_sk = d1.d_date_sk JOIN date_dim AS d2 ON ws.ws_sold_date_sk = d2.d_date_sk JOIN customer AS c ON ss.ss_customer_sk = c.c_customer_sk AND ws.ws_bill_customer_sk = c.c_customer_sk JOIN inventory AS inv ON ss.ss_item_sk = inv.inv_item_sk AND ss.ss_sold_date_sk = inv.inv_date_sk AND inv.inv_quantity_on_hand >= ss.ss_quantity JOIN store AS s ON s.s_state = w.w_state JOIN warehouse AS w ON ws.ws_warehouse_sk = w.w_warehouse_sk JOIN customer_demographics AS cd ON c.c_current_cdemo_sk = cd.cd_demo_sk JOIN household_demographics AS hd ON c.c_current_hdemo_sk = hd.hd_demo_sk JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p11: early_filter (ERROR, n/a)
```sql
WITH hd_filtered AS (SELECT hd_demo_sk, hd_vehicle_count FROM household_demographics) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM store_sales, web_sales, date_dim AS d1, date_dim AS d2, customer, inventory, store, warehouse, item, customer_demographics, hd_filtered, customer_address WHERE ss_item_sk = i_item_sk AND ws_item_sk = ss_item_sk AND ss_sold_date_sk = d1.d_date_sk AND ws_sold_date_sk = d2.d_date_sk AND d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND ss_customer_sk = c_customer_sk AND ws_bill_customer_sk = c_customer_sk AND ws_warehouse_sk = inv_warehouse_sk AND ws_warehouse_sk = w_warehouse_sk AND inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_quantity_on_hand >= ss_quantity AND s_state = w_state AND i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND c_current_cdemo_sk = cd_demo_sk AND c_current_hdemo_sk = hd_demo_sk AND c_current_addr_sk = ca_address_sk AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND d1.d_year = 2001 AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p12: deferred_window_aggregation (ERROR, n/a)
```sql
WITH pre_agg_sales AS (SELECT ss_customer_sk, ws_bill_customer_sk, COUNT(*) AS sale_count FROM store_sales, web_sales, date_dim AS d1, date_dim AS d2, item, inventory, store, warehouse WHERE ss_item_sk = i_item_sk AND ws_item_sk = ss_item_sk AND ss_sold_date_sk = d1.d_date_sk AND ws_sold_date_sk = d2.d_date_sk AND d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND ws_warehouse_sk = inv_warehouse_sk AND ws_warehouse_sk = w_warehouse_sk AND inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_quantity_on_hand >= ss_quantity AND s_state = w_state AND i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND d1.d_year = 2001 AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY ss_customer_sk, ws_bill_customer_sk) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM pre_agg_sales AS pas JOIN customer AS c ON pas.ss_customer_sk = c.c_customer_sk AND pas.ws_bill_customer_sk = c.c_customer_sk JOIN customer_address AS ca ON c.c_current_addr_sk = ca_address_sk JOIN household_demographics AS hd ON c.c_current_hdemo_sk = hd_demo_sk JOIN customer_demographics AS cd ON c.c_current_cdemo_sk = cd_demo_sk WHERE ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p10: sf_sk_pushdown_multi_fact (ERROR, n/a)
```sql
WITH valid_dates AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2001) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM store_sales, web_sales, valid_dates AS d1, valid_dates AS d2, customer, inventory, store, warehouse, item, customer_demographics, household_demographics, customer_address WHERE ss_item_sk = i_item_sk AND ws_item_sk = ss_item_sk AND ss_sold_date_sk = d1.d_date_sk AND ws_sold_date_sk = d2.d_date_sk AND d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND ss_customer_sk = c_customer_sk AND ws_bill_customer_sk = c_customer_sk AND ws_warehouse_sk = inv_warehouse_sk AND ws_warehouse_sk = w_warehouse_sk AND inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_quantity_on_hand >= ss_quantity AND s_state = w_state AND i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND c_current_cdemo_sk = cd_demo_sk AND c_current_hdemo_sk = hd_demo_sk AND c_current_addr_sk = ca_address_sk AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND d1.d_year = 2001 AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p13: shared_dimension_multi_channel (ERROR, n/a)
```sql
WITH shared_dimensions AS (SELECT i_item_sk, c_customer_sk FROM item, customer WHERE i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND c_current_addr_sk = ca_address_sk AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA')) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM store_sales, web_sales, date_dim AS d1, date_dim AS d2, inventory, store, warehouse, shared_dimensions, customer_demographics, household_demographics, customer_address WHERE ss_item_sk = i_item_sk AND ws_item_sk = ss_item_sk AND ss_sold_date_sk = d1.d_date_sk AND ws_sold_date_sk = d2.d_date_sk AND d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND ss_customer_sk = c_customer_sk AND ws_bill_customer_sk = c_customer_sk AND ws_warehouse_sk = inv_warehouse_sk AND ws_warehouse_sk = w_warehouse_sk AND inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_quantity_on_hand >= ss_quantity AND s_state = w_state AND c_current_cdemo_sk = cd_demo_sk AND c_current_hdemo_sk = hd_demo_sk AND c_current_addr_sk = ca_address_sk AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND d1.d_year = 2001 AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p06: aggregate_pushdown (ERROR, n/a)
```sql
WITH ss_agg AS (SELECT ss_item_sk, ss_customer_sk, ss_sold_date_sk, SUM(ss_quantity) AS total_quantity FROM store_sales GROUP BY ss_item_sk, ss_customer_sk, ss_sold_date_sk) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM ss_agg JOIN web_sales ON ss_agg.ss_item_sk = web_sales.ws_item_sk AND ss_agg.ss_customer_sk = web_sales.ws_bill_customer_sk AND ss_agg.ss_sold_date_sk = web_sales.ws_sold_date_sk JOIN date_dim AS d1 ON ss_agg.ss_sold_date_sk = d1.d_date_sk JOIN date_dim AS d2 ON web_sales.ws_sold_date_sk = d2.d_date_sk JOIN customer ON web_sales.ws_bill_customer_sk = customer.c_customer_sk JOIN inventory ON web_sales.ws_item_sk = inventory.inv_item_sk AND web_sales.ws_sold_date_sk = inventory.inv_date_sk JOIN store ON inventory.inv_warehouse_sk = store.s_store_sk JOIN warehouse ON web_sales.ws_warehouse_sk = warehouse.w_warehouse_sk JOIN item ON web_sales.ws_item_sk = item.i_item_sk JOIN customer_demographics ON customer.c_current_cdemo_sk = customer_demographics.cd_demo_sk JOIN household_demographics ON customer.c_current_hdemo_sk = household_demographics.hd_demo_sk JOIN customer_address ON customer.c_current_addr_sk = customer_address.ca_address_sk WHERE d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND inv_quantity_on_hand >= ss_agg.total_quantity AND s_state = warehouse.w_state AND i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93) AND ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA') AND d1.d_year = 2001 AND web_sales.ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```

### p07: multi_dimension_prefetch (ERROR, n/a)
```sql
WITH prefiltered_item AS (SELECT i_item_sk FROM item WHERE i_category IN ('Children', 'Jewelry', 'Men') AND i_manager_id IN (21, 22, 38, 39, 46, 47, 66, 67, 74, 93)), prefiltered_customer_address AS (SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('AZ', 'KS', 'OH', 'TX', 'WA')), prefiltered_household_demographics AS (SELECT hd_demo_sk FROM household_demographics) SELECT cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count, COUNT(*) AS cnt FROM store_sales, web_sales, date_dim AS d1, date_dim AS d2, customer, inventory, store, warehouse, prefiltered_item AS pi, prefiltered_customer_address AS pca, prefiltered_household_demographics AS phd, customer_demographics WHERE ss_item_sk = pi.i_item_sk AND ws_item_sk = ss_item_sk AND ss_sold_date_sk = d1.d_date_sk AND ws_sold_date_sk = d2.d_date_sk AND d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '30 DAY') AND ss_customer_sk = c_customer_sk AND ws_bill_customer_sk = c_customer_sk AND ws_warehouse_sk = inv_warehouse_sk AND ws_warehouse_sk = w_warehouse_sk AND inv_item_sk = ss_item_sk AND inv_date_sk = ss_sold_date_sk AND inv_quantity_on_hand >= ss_quantity AND s_state = w_state AND c_current_cdemo_sk = cd_demo_sk AND c_current_hdemo_sk = phd.hd_demo_sk AND c_current_addr_sk = pca.ca_address_sk AND d1.d_year = 2001 AND ws_wholesale_cost BETWEEN 35 AND 55 GROUP BY cd_gender, cd_marital_status, cd_education_status, hd_vehicle_count ORDER BY cnt;
```


## Shot 1 Results

| # | Family | Transform | Speedup | Status | Error |
|---|--------|-----------|---------|--------|-------|
| snipe_p1 | ? | unknown | - | ERROR | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| snipe_p2 | ? | unknown | - | ERROR | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |

### snipe_p1 Error:
Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context'

### snipe_p2 Error:
Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context'

## Shot 2 — Design 2 More Patch Plans

Build on shot 1 results:
1. Your first plan should refine or extend the best winner (or fix its remaining bottleneck)
2. Your second should try a different approach not yet attempted

If all shot 1 plans failed, diagnose why and try fundamentally different strategies.

Output exactly **2 patch plans** as a JSON array.

Tier-0 Output Contract (hard fail):
- response must be valid JSON
- first character must be `[` (no leading whitespace/newlines)
- top-level value must be an array of exactly 2 objects
- no markdown fences, prose, or commentary
- never emit key `sql`; use `sql_fragment` for SQL fragments

Required per plan:
- `plan_id`, `family`, `transform`, `hypothesis`, `target_ir`, `dialect`, `steps`
- optional: `based_on` as a string (use comma-separated IDs for multiple sources; never an array)
- `steps[]` item: `step_id`, `op`, `target`, optional `payload`
- `target.by_node_id` MUST be `"S0"` (use `by_anchor_hash` only when needed)

Allowed `op` values:
- `insert_cte`
- `replace_from`
- `replace_where_predicate`
- `replace_body`
- `replace_expr_subtree`
- `delete_expr_subtree`
- `replace_join_condition`
- `replace_select`
- `replace_block_with_cte_pair`
- `wrap_query_with_cte`

Semantic guards (MUST preserve):
- all WHERE/HAVING/ON logic
- all literals exactly
- columns/aliases/ORDER BY/LIMIT
- row count and semantics
- no orphaned CTEs or duplicated source scans after replacement

Rules:
- output exactly 2 plans
- each plan must use a different strategy (`family` + `transform`)
- payload SQL fragments must be complete/executable (no ellipsis)
- `replace_body`, `replace_select`, and `replace_block_with_cte_pair` must put SQL in `payload.sql_fragment`
- cite EXPLAIN evidence in `hypothesis`

Output ONLY JSON array.