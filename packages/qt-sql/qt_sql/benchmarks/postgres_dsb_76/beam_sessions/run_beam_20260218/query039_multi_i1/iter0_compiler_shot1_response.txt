[
  {
    "plan_id": "compile_p1",
    "dialect": "postgres",
    "confidence": 0.65,
    "based_on": "p01,p02",
    "strategy": "Push d_moy filter into CTE and convert comma joins to explicit INNER JOINs to reduce inventory scan volume before aggregation.",
    "hypothesis": "Original CTE computes aggregates for all months of 2002, then outer query filters d_moy=2 and d_moy=3. Adding d_moy IN (2,3) to CTE WHERE clause reduces inventory scan to only needed months while preserving semantics. Explicit joins may help optimizer.",
    "expected_explain_delta": "Parallel Seq Scan on inventory should process fewer rows; GroupAggregate input reduced from 98710 rows to ~2 months' data; Nested Loop with warehouse eliminated.",
    "target_ir": "Modify inv node to filter d_moy early and use explicit join syntax.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["inv"],
          "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov", "w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov"],
          "changed": false
        },
        {
          "node_id": "inv",
          "parent_node_id": "final_select",
          "sources": ["inventory", "item", "warehouse", "date_dim"],
          "outputs": ["w_warehouse_name", "w_warehouse_sk", "i_item_sk", "d_moy", "stdev", "mean", "cov"],
          "changed": true,
          "sql": "SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy, stdev, mean, CASE mean WHEN 0 THEN NULL ELSE stdev/mean END cov FROM (SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy, STDDEV_SAMP(inv_quantity_on_hand) stdev, AVG(inv_quantity_on_hand) mean FROM inventory INNER JOIN item ON inv_item_sk = i_item_sk INNER JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk INNER JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 2002 AND d_moy IN (2,3) AND i_category IN ('Jewelry', 'Men') AND i_manager_id BETWEEN 81 AND 100 AND inv_quantity_on_hand BETWEEN 0 AND 200 GROUP BY w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy) foo WHERE CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1"
        }
      ]
    }
  },
  {
    "plan_id": "compile_p2",
    "dialect": "postgres",
    "confidence": 0.55,
    "based_on": "p02",
    "strategy": "Split CTE into two separate CTEs (inv2 for d_moy=2, inv3 for d_moy=3) to compute aggregates only for needed months, avoiding materialization of full month set.",
    "hypothesis": "Self-join decomposition eliminates the need to compute and filter a large CTE for all months. Each CTE scans inventory only for its target month, reducing aggregate input and parallel scan volume.",
    "expected_explain_delta": "Two independent aggregation branches each with reduced inventory scan; final merge join on warehouse and item keys; elimination of Nested Loop amplification.",
    "target_ir": "Replace inv node with inv2 and inv3 nodes; update final_select to join them.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["inv2", "inv3"],
          "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov", "w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov"],
          "changed": true,
          "sql": "SELECT inv2.w_warehouse_sk, inv2.i_item_sk, inv2.d_moy, inv2.mean, inv2.cov, inv3.w_warehouse_sk, inv3.i_item_sk, inv3.d_moy, inv3.mean, inv3.cov FROM inv2, inv3 WHERE inv2.i_item_sk = inv3.i_item_sk AND inv2.w_warehouse_sk = inv3.w_warehouse_sk ORDER BY inv2.w_warehouse_sk, inv2.i_item_sk, inv2.d_moy, inv2.mean, inv2.cov, inv3.d_moy, inv3.mean, inv3.cov"
        },
        {
          "node_id": "inv2",
          "parent_node_id": "final_select",
          "sources": ["inventory", "item", "warehouse", "date_dim"],
          "outputs": ["w_warehouse_name", "w_warehouse_sk", "i_item_sk", "d_moy", "stdev", "mean", "cov"],
          "changed": true,
          "sql": "SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy, stdev, mean, CASE mean WHEN 0 THEN NULL ELSE stdev/mean END cov FROM (SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy, STDDEV_SAMP(inv_quantity_on_hand) stdev, AVG(inv_quantity_on_hand) mean FROM inventory INNER JOIN item ON inv_item_sk = i_item_sk INNER JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk INNER JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 2002 AND d_moy = 2 AND i_category IN ('Jewelry', 'Men') AND i_manager_id BETWEEN 81 AND 100 AND inv_quantity_on_hand BETWEEN 0 AND 200 GROUP BY w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy) foo WHERE CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1"
        },
        {
          "node_id": "inv3",
          "parent_node_id": "final_select",
          "sources": ["inventory", "item", "warehouse", "date_dim"],
          "outputs": ["w_warehouse_name", "w_warehouse_sk", "i_item_sk", "d_moy", "stdev", "mean", "cov"],
          "changed": true,
          "sql": "SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy, stdev, mean, CASE mean WHEN 0 THEN NULL ELSE stdev/mean END cov FROM (SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy, STDDEV_SAMP(inv_quantity_on_hand) stdev, AVG(inv_quantity_on_hand) mean FROM inventory INNER JOIN item ON inv_item_sk = i_item_sk INNER JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk INNER JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 2002 AND d_moy = 3 AND i_category IN ('Jewelry', 'Men') AND i_manager_id BETWEEN 81 AND 100 AND inv_quantity_on_hand BETWEEN 0 AND 200 GROUP BY w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy) foo WHERE CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1"
        }
      ]
    }
  }
]