[
  {
    "plan_id": "compile_safe_nochange",
    "dialect": "postgres",
    "confidence": 1.0,
    "based_on": "original",
    "strategy": "Preserve original plan due to regression evidence",
    "hypothesis": "All decorrelation attempts regressed (0.39x-0.78x). PostgreSQL's semi-join optimization already handles EXISTS efficiently. Any CTE/materialization breaks native optimization. Original plan uses BitmapOr for date_dim scans and semi-joins for EXISTS.",
    "expected_explain_delta": "No change. Keep nested-loop semi-joins and BitmapOr scans.",
    "target_ir": "Keep all nodes unchanged.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["customer", "customer_address", "customer_demographics", "store_sales", "date_dim", "web_sales", "date_dim", "catalog_sales", "date_dim"],
          "outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"],
          "changed": false
        }
      ]
    }
  },
  {
    "plan_id": "compile_explicit_join_only",
    "dialect": "postgres",
    "confidence": 0.3,
    "based_on": "p02",
    "strategy": "Convert comma joins to explicit JOIN syntax without CTE fences",
    "hypothesis": "Only safe cosmetic change: explicit joins may help optimizer see join graph more clearly while preserving PostgreSQL's semi-join optimization. Avoid CTE fences that caused regression in p02.",
    "expected_explain_delta": "Same plan shape but with explicit JOIN nodes; may improve cost estimation.",
    "target_ir": "Change final_select join syntax.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["customer", "customer_address", "customer_demographics"],
          "outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"],
          "changed": true,
          "sql": "select cd_gender, cd_marital_status, cd_education_status, count(*) cnt1, cd_purchase_estimate, count(*) cnt2, cd_credit_rating, count(*) cnt3 from customer c join customer_address ca on c.c_current_addr_sk = ca.ca_address_sk join customer_demographics on cd_demo_sk = c.c_current_cdemo_sk where ca_state in ('GA','KY','SD') and cd_marital_status in ('D', 'W', 'U') and cd_education_status in ('Primary', 'College') and exists (select * from store_sales, date_dim where c.c_customer_sk = ss_customer_sk and ss_sold_date_sk = d_date_sk and d_year = 1999 and d_moy between 3 and 3+2 and ss_list_price between 52 and 141) and (not exists (select * from web_sales, date_dim where c.c_customer_sk = ws_bill_customer_sk and ws_sold_date_sk = d_date_sk and d_year = 1999 and d_moy between 3 and 3+2 and ws_list_price between 52 and 141) and not exists (select * from catalog_sales, date_dim where c.c_customer_sk = cs_ship_customer_sk and cs_sold_date_sk = d_date_sk and d_year = 1999 and d_moy between 3 and 3+2 and cs_list_price between 52 and 141)) group by cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating order by cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating limit 100"
        }
      ]
    }
  }
]