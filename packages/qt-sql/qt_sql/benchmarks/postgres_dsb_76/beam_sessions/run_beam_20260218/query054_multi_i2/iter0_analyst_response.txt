{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Plan shows nested loops driving large fact-table scans (catalog_sales, web_sales, store_sales) with selective filters applied late. The comma-join style may block predicate pushdown and join reordering. Primary hotspot is the my_customers CTE (697ms) where UNION ALL of two large fact tables joins multiple dimensions via nested loops.",
    "reasoning_trace": [
      "Nested Loop on catalog_sales/web_sales Append drives 697ms before unique.",
      "Bitmask Index Scan on store_sales shows zero estimated rows (ZERO_EST) indicating poor statistics at CTE boundary.",
      "Comma-join syntax in both CTEs may limit optimizer's ability to reorder joins or push filters.",
      "No correlated subqueries present, but UNION ALL of two large fact tables repeated in nested loop."
    ],
    "cost_spine": ["Nested Loop", "Unique", "Nested Loop", "Append", "Index Scan on catalog_sales", "Index Scan on web_sales", "Bitmap Heap Scan on store_sales"],
    "hotspots": [
      {
        "op": "Unique (my_customers)",
        "why": "drives nested loops over UNION ALL of two large fact tables",
        "evidence": "time=697.414ms, rows=131 after filtering"
      },
      {
        "op": "Bitmap Heap Scan on store_sales",
        "why": "zero-row estimation (ZERO_EST) may cause poor plan choice",
        "evidence": "est=0 act=0, but scan is repeated in nested loop"
      },
      {
        "op": "Nested Loop with Append",
        "why": "repeated index scans on catalog_sales and web_sales",
        "evidence": "time=19.347ms for 23 rows, but repeated for each outer row"
      }
    ],
    "do_not_do": [
      "avoid OR-to-UNION split on same-column OR (PostgreSQL BitmapOr is optimal)",
      "avoid materializing EXISTS paths (none present)",
      "avoid duplicating heavy CTE bodies (my_customers is heavy)"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "date_cte_explicit_join",
      "family": "A",
      "target": "Convert comma joins to explicit INNER JOIN syntax and isolate date_dim filters into a CTE for my_customers and my_revenue CTEs, preserving all predicates.",
      "dag_target_hint": "Change my_customers and my_revenue node FROM clauses to explicit JOINs, add date_cte for d_moy=5 and d_year=1998.",
      "node_contract": {
        "from_must_include": ["date_dim", "item", "customer", "catalog_sales", "web_sales", "store_sales", "customer_address", "store"],
        "where_must_preserve": ["i_category='Home'", "i_class='curtains/drapes'", "c_birth_year BETWEEN 1942 AND 1955", "wholesale_cost BETWEEN 70 AND 100", "s_state in (...)", "ss_wholesale_cost BETWEEN 70 AND 100", "d_moy=5", "d_year=1998"],
        "output_must_preserve": ["c_customer_sk", "c_current_addr_sk", "revenue", "segment"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Comma joins become explicit hash joins, date_dim filter is pushed earlier, reducing rows entering nested loops.",
      "recommended_patch_ops": ["replace_from_comma_to_join", "insert_date_cte", "replace_where_predicates"],
      "rank_rationale": "Primary hotspot directly addressed: comma-join weakness blocks predicate pushdown and join reordering.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p02",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Prefilter all selective dimensions (date_dim, item, customer, customer_address, store) into separate CTEs and join explicitly, creating tiny hash tables before fact-table scans.",
      "dag_target_hint": "Replace my_customers CTE with chain of prefiltered dimension CTEs joined to catalog_sales and web_sales via UNION ALL.",
      "node_contract": {
        "from_must_include": ["date_dim", "item", "customer", "catalog_sales", "web_sales"],
        "where_must_preserve": ["i_category='Home'", "i_class='curtains/drapes'", "c_birth_year BETWEEN 1942 AND 1955", "wholesale_cost BETWEEN 70 AND 100", "d_moy=5", "d_year=1998"],
        "output_must_preserve": ["c_customer_sk", "c_current_addr_sk"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.78,
      "expected_explain_delta": "Dimension scans become tiny CTEs, fact-table scans reduce via early hash join, nested loops may become hash joins.",
      "recommended_patch_ops": ["insert_dimension_ctes", "replace_from_with_cte_joins", "replace_where_predicates"],
      "rank_rationale": "Secondary hotspot: dimension prefetch may reduce rows entering UNION ALL fact scans.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p03",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate store_sales by ss_customer_sk and ss_wholesale_cost filter before joining with my_customers, customer_address, store, and date_dim in my_revenue CTE.",
      "dag_target_hint": "Change my_revenue node to join pre-aggregated store_sales CTE instead of base table.",
      "node_contract": {
        "from_must_include": ["store_sales"],
        "where_must_preserve": ["ss_wholesale_cost BETWEEN 70 AND 100", "d_month_seq between subquery results"],
        "output_must_preserve": ["c_customer_sk", "revenue"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Pre-aggregating store_sales may reduce rows joined in my_revenue's nested loop, addressing zero-estimation issue.",
      "confidence": 0.65,
      "expected_explain_delta": "Bitmap Heap Scan replaced by scan of pre-aggregated CTE, reducing rows flowing into nested loop.",
      "recommended_patch_ops": ["insert_cte_preaggregate", "replace_from"],
      "rank_rationale": "Exploration targeting store_sales zero-estimation hotspot with aggregate pushdown.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p04",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize the my_customers CTE and reuse it in my_revenue to avoid recomputation of the expensive UNION ALL and dimension joins.",
      "dag_target_hint": "Add MATERIALIZED keyword to my_customers CTE definition.",
      "node_contract": {
        "from_must_include": ["my_customers"],
        "where_must_preserve": [],
        "output_must_preserve": ["c_customer_sk", "c_current_addr_sk"]
      },
      "gates_checked": ["G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Materializing my_customers may prevent repeated nested loops and improve cardinality estimates for downstream joins.",
      "confidence": 0.55,
      "expected_explain_delta": "my_customers subtree materialized once, nested loops may be replaced by hash joins with better estimates.",
      "recommended_patch_ops": ["add_materialized_keyword"],
      "rank_rationale": "Exploration targeting CTE materialization to improve estimation and reuse.",
      "recommended_examples": [],
      "gold_example_id": ""
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan; PostgreSQL BitmapOr handles indexed OR efficiently."
    },
    {
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "reason": "No correlated scalar subqueries present in SQL."
    },
    {
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "reason": "Non-native transform (Snowflake) with no strong evidence for PostgreSQL micro-partition pruning."
    }
  ]
}