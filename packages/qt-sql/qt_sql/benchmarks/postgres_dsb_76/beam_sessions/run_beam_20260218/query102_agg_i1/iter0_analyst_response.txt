{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The dominant cost is a Sort (12.2s) feeding a Merge Join (12.2s) on a 10k-row left side, which originates from a complex multi-table join with comma-syntax and a non-equi date range. The plan shows large under-estimation at the Merge Join (est=49, act=10k), indicating poor cardinality estimates from comma-join predicates and non-equi conditions. Early filtering and explicit join restructuring can reduce rows before the expensive sort and improve join ordering.",
    "reasoning_trace": [
      "Sort node consumes 12.2s (75% of total runtime) sorting 10090 rows for Merge Join.",
      "Merge Join left input is a Nested Loop chain with Hash Join (11.1s) and large row flow before sorting.",
      "Cardinality estimation error: Merge Join estimated 49 rows, actual 10090 rows (Q-error >200x).",
      "Non-equi join condition (d2.d_date BETWEEN d1.d_date AND d1.d_date + 30 days) appears late in plan.",
      "Query uses comma-join syntax which may hinder predicate pushdown and join reordering."
    ],
    "cost_spine": ["Sort", "Merge Join", "Nested Loop", "Hash Join", "Seq Scan on customer_address"],
    "hotspots": [
      {
        "op": "Sort",
        "why": "dominant time consumer, sorts 10090 rows for Merge Join",
        "evidence": "time=12212.346 ms"
      },
      {
        "op": "Merge Join",
        "why": "large row mismatch (est=49, act=10090) and waits for sort",
        "evidence": "time=12214.595 ms, rows=10090"
      },
      {
        "op": "Hash Join",
        "why": "feeds into sort with 8065 rows, under-estimated input",
        "evidence": "time=11057.45 ms, rows=8065"
      }
    ],
    "do_not_do": [
      "avoid OR to UNION ALL (no OR predicate in query)",
      "avoid duplicating large CTE bodies (previous attempt failed)",
      "avoid materializing EXISTS paths (none present)",
      "do not split same-column OR (none present)"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Create MATERIALIZED CTEs for selective dimensions (date_dim d1, item, customer_address, household_demographics) and pre-join with fact tables (store_sales, web_sales) to reduce rows before the non-equi date join and final Merge Join.",
      "dag_target_hint": "Replace final_select FROM clause with CTE chain: filtered_d1, filtered_item, filtered_ca, filtered_hd, prejoined_facts.",
      "node_contract": {
        "from_must_include": ["store_sales", "web_sales", "date_dim d1", "date_dim d2", "item", "customer_address", "household_demographics"],
        "where_must_preserve": ["d1.d_year = 2001", "i_category IN ('Children','Jewelry','Men')", "i_manager_id IN (21,22,38,39,46,47,66,67,74,93)", "ca_state IN ('AZ','KS','OH','TX','WA')", "d2.d_date BETWEEN d1.d_date AND (d1.d_date + interval '30 day')", "ws_wholesale_cost BETWEEN 35 AND 55"],
        "output_must_preserve": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "count(*) as cnt", "GROUP BY and ORDER BY semantics"]
      },
      "gates_checked": ["G_PG_NONEQUI_PRESENT:PASS", "G_PG_NONEQUI_CARDINALITY:PASS", "G_PG_NONEQUI_FILTER_QUALITY:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.78,
      "expected_explain_delta": "Sort and Merge Join disappear or shrink; plan shows earlier reduction via CTE scans and hash joins.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Targets primary hotspot (Sort/Merge Join) and non-equi join gap with strong gold example evidence.",
      "recommended_examples": ["pg_materialized_dimension_fact_prefilter"],
      "gold_example_id": "pg_materialized_dimension_fact_prefilter"
    },
    {
      "probe_id": "p02",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre-filter all selective dimensions into separate CTEs, convert comma joins to explicit JOIN syntax, and join CTEs in a star pattern to improve cardinality estimates and join order.",
      "dag_target_hint": "Change final_select FROM to explicit JOINs on pre‑filtered CTEs for date_dim, item, customer_address, household_demographics, customer_demographics, warehouse, store, inventory.",
      "node_contract": {
        "from_must_include": ["store_sales", "web_sales", "date_dim d1", "date_dim d2", "item", "customer_address", "household_demographics"],
        "where_must_preserve": ["d1.d_year = 2001", "i_category IN ('Children','Jewelry','Men')", "i_manager_id IN (21,22,38,39,46,47,66,67,74,93)", "ca_state IN ('AZ','KS','OH','TX','WA')", "d2.d_date BETWEEN d1.d_date AND (d1.d_date + interval '30 day')", "ws_wholesale_cost BETWEEN 35 AND 55"],
        "output_must_preserve": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "count(*) as cnt", "GROUP BY and ORDER BY semantics"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.72,
      "expected_explain_delta": "Comma joins become explicit joins; dimension CTEs are tiny; Merge Join may become Hash Join with smaller build side.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Addresses comma‑join weakness and secondary hotspot (Hash Join) with proven gold example.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p03",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Isolate date_dim filters into CTEs, convert comma joins to explicit JOINs, and push date‑range predicate earlier into the join graph.",
      "dag_target_hint": "Create CTEs for d1 and d2 with their filters, then join explicitly with store_sales and web_sales.",
      "node_contract": {
        "from_must_include": ["store_sales", "web_sales", "date_dim d1", "date_dim d2"],
        "where_must_preserve": ["d1.d_year = 2001", "d2.d_date BETWEEN d1.d_date AND (d1.d_date + interval '30 day')"],
        "output_must_preserve": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "count(*) as cnt", "GROUP BY and ORDER BY semantics"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.68,
      "expected_explain_delta": "Date dimension scans become CTE scans; explicit joins allow better join order; Sort input rows reduce.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Targets date‑range non‑equi join and comma‑join weakness with moderate gold example support.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p04",
      "transform_id": "multi_date_range_cte",
      "family": "A",
      "target": "Create separate CTEs for d1 and d2 with their respective filters, then join each CTE to its fact table (store_sales with d1, web_sales with d2) before the final join, to push date filters earlier.",
      "dag_target_hint": "Replace final_select FROM with CTEs: d1_filtered, d2_filtered, ss_with_d1, ws_with_d2, then join remaining dimensions.",
      "node_contract": {
        "from_must_include": ["store_sales", "web_sales", "date_dim d1", "date_dim d2"],
        "where_must_preserve": ["d1.d_year = 2001", "d2.d_date BETWEEN d1.d_date AND (d1.d_date + interval '30 day')"],
        "output_must_preserve": ["cd_gender", "cd_marital_status", "cd_education_status", "hd_vehicle_count", "count(*) as cnt", "GROUP BY and ORDER BY semantics"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:EXPLORATION", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Splitting date ranges into separate CTEs may allow earlier reduction of fact rows before the expensive sort and merge join, even though the transform is a portability candidate.",
      "confidence": 0.52,
      "expected_explain_delta": "Fact table scans reduce earlier; date filters apply before main join; Sort may see fewer rows.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Exploration probe targeting date‑range gap; lower confidence due to portability candidate status.",
      "recommended_examples": [],
      "gold_example_id": ""
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate in query; plan shows no OR‑related bottleneck."
    },
    {
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "reason": "Plan shows aggregate only at top; no evidence of aggregate‑below‑join opportunity; GROUP BY keys are from dimensions joined late."
    },
    {
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "reason": "Previous attempt failed (speedup=0.00x); avoid repeating failed strategy."
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "Previous attempt failed (speedup=0.00x); no LEFT JOIN in query to convert."
    },
    {
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "reason": "Engine‑specific (Snowflake) portability candidate; not native to PostgreSQL and no evidence of predicate‑transitivity failure in plan."
    }
  ]
}