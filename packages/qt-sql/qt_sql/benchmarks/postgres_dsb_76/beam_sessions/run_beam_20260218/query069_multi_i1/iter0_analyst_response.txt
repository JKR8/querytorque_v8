{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 2,
    "probe_count": 8,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Three correlated NOT EXISTS subqueries drive repeated nested-loop index scans on large fact tables (store_sales, web_sales, catalog_sales), each re-scanning date_dim. The primary hotspot is the outer Nested Loop (77.7s) amplifying 1105 outer rows into 310K inner rows. Secondary hotspots are the sequential scan on customer (1.2s) and hash joins with late filtering.",
    "reasoning_trace": [
      "Nested Loop (rows=1105, time=10971ms) drives three inner branches: one EXISTS (store_sales) and two NOT EXISTS (web_sales, catalog_sales).",
      "Each inner branch repeats an Index Only Scan on date_dim (31 rows) and an Index Scan on the fact table (rows 917 to 3614).",
      "Gather nodes show parallel execution, but nested loops limit parallelism; cardinality estimation error at Gather (est=5.7K, act=332K) indicates planner underestimates inner loop amplification.",
      "Sequential scan on customer (166K rows, 1.2s) feeds the outer loop; hash joins with customer_address and customer_demographics apply filters late.",
      "Previous winning attempt used `decorrelate` (34.45x speedup), confirming decorrelation is high-impact for this shape."
    ],
    "cost_spine": ["Seq Scan on customer", "Hash Join", "Nested Loop", "Nested Loop", "Aggregate", "Limit"],
    "hotspots": [
      {
        "op": "Nested Loop (outer)",
        "why": "Drives three correlated subquery branches, each repeating date_dim and fact-table scans.",
        "evidence": "rows=1105, time=10971ms, inner rows amplified to 310K+"
      },
      {
        "op": "Seq Scan on customer",
        "why": "Full table scan feeds outer loop; filters on customer_demographics and customer_address applied after join.",
        "evidence": "rows=166667, time=1205ms"
      },
      {
        "op": "Hash Join (customer + customer_address + customer_demographics)",
        "why": "Late application of state and demographic filters; rows out (1691) much smaller than rows in (166K).",
        "evidence": "rows=1691, time=3512ms"
      }
    ],
    "do_not_do": [
      "Do not split same-column OR predicates into UNION ALL (PostgreSQL BitmapOr is optimal).",
      "Do not materialize simple EXISTS subqueries that are already semi-joins.",
      "Avoid duplicating heavy CTE bodies; filter materialized output instead.",
      "Avoid converting comma joins to explicit JOIN if estimates are already stable and plan is efficient."
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Decorrelate the three EXISTS/NOT EXISTS subqueries by precomputing distinct customer keys for each channel (store, web, catalog) that meet the date and price filters, then join as anti/semi-joins. Pre-filter customer, customer_address, customer_demographics into a CTE to reduce outer rows.",
      "dag_target_hint": "Replace final_select FROM and WHERE with CTE joins; add CTEs for filtered_customers, store_customers, web_customers, catalog_customers.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "customer_demographics cd", "store_sales ss", "web_sales ws", "catalog_sales cs", "date_dim d"],
        "where_must_preserve": ["ca_state in ('CO','NC','TX')", "cd_marital_status in ('S','M','U')", "cd_education_status in ('Primary','College')", "d_year=2002", "d_moy between 10 and 12", "ss_list_price between 80 and 169", "ws_list_price between 80 and 169", "cs_list_price between 80 and 169"],
        "output_must_preserve": ["cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating", "count(*) per group", "ORDER BY and LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Nested Loop for subqueries replaced by Hash (Anti/Semi) Joins; date_dim scanned once per channel; outer row count reduced by early customer filtering.",
      "recommended_patch_ops": ["insert_cte_filtered_customers", "insert_cte_store_customers", "insert_cte_web_customers", "insert_cte_catalog_customers", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Primary hotspot — decorrelation directly targets the nested-loop amplification driving 77s runtime; previous win with decorrelate (34x).",
      "recommended_examples": ["pg_shared_scan_decorrelate", "early_filter_decorrelate"],
      "gold_example_id": "pg_shared_scan_decorrelate"
    },
    {
      "probe_id": "p02",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Isolate date_dim filter into a CTE returning d_date_sk for d_year=2002 and d_moy between 10 and 12; convert comma joins to explicit INNER JOIN syntax; join the date CTE with each fact table in separate CTEs to enable hash joins with tiny dimension.",
      "dag_target_hint": "Add date_range CTE; rewrite final_select FROM to use explicit JOINs between customer, customer_address, customer_demographics, and channel CTEs.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "customer_demographics cd", "date_range dr"],
        "where_must_preserve": ["ca_state in ('CO','NC','TX')", "cd_marital_status in ('S','M','U')", "cd_education_status in ('Primary','College')"],
        "output_must_preserve": ["All original output columns and aggregates", "ORDER BY and LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Explicit JOINs allow better join order optimization; date_dim scanned once; fact-table joins use small hash table from date_range CTE.",
      "recommended_patch_ops": ["insert_cte_date_range", "replace_from", "convert_comma_to_explicit_join"],
      "rank_rationale": "Secondary hotspot — comma-join weakness and repeated date_dim scans; explicit joins improve cardinality estimates.",
      "recommended_examples": ["pg_date_cte_explicit_join", "pg_explicit_join_materialized"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p03",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre-filter customer, customer_address, customer_demographics into a single CTE returning only c_customer_sk and required demographic columns, applying all dimension filters early. Then join this CTE with the fact channels.",
      "dag_target_hint": "Add filtered_customers CTE; replace original customer, customer_address, customer_demographics joins with CTE reference.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "customer_demographics cd"],
        "where_must_preserve": ["ca_state in ('CO','NC','TX')", "cd_marital_status in ('S','M','U')", "cd_education_status in ('Primary','College')"],
        "output_must_preserve": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.70,
      "expected_explain_delta": "Seq Scan on customer replaced by smaller CTE scan; hash join inputs reduced; outer loop row count drops.",
      "recommended_patch_ops": ["insert_cte_filtered_customers", "replace_from"],
      "rank_rationale": "Targets secondary hotspot (customer seq scan) and reduces rows feeding the outer nested loop.",
      "recommended_examples": ["pg_dimension_prefetch_star", "multi_dimension_prefetch"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p04",
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "target": "Use MATERIALIZED CTEs to precompute distinct customer keys for each channel, forcing PostgreSQL to materialize the small key sets and break correlation. Keep EXISTS/NOT EXISTS as anti/semi-joins but with precomputed key sets.",
      "dag_target_hint": "Add MATERIALIZED CTEs for store_customers, web_customers, catalog_customers; rewrite WHERE EXISTS clauses as joins to these CTEs.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "customer_demographics cd"],
        "where_must_preserve": ["ca_state in ('CO','NC','TX')", "cd_marital_status in ('S','M','U')", "cd_education_status in ('Primary','College')"],
        "output_must_preserve": ["All original output columns and aggregates", "ORDER BY and LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.80,
      "expected_explain_delta": "Correlated subqueries replaced by hash joins with materialized key sets; nested loops eliminated; date_dim scans reduced.",
      "recommended_patch_ops": ["insert_materialized_cte_store_keys", "insert_materialized_cte_web_keys", "insert_materialized_cte_catalog_keys", "replace_where_predicate"],
      "rank_rationale": "Alternative decorrelation mechanism using MATERIALIZED CTEs, which PostgreSQL cannot inline back to correlated form.",
      "recommended_examples": ["inline_decorrelate_materialized", "pg_shared_scan_decorrelate"],
      "gold_example_id": "inline_decorrelate_materialized"
    },
    {
      "probe_id": "p05",
      "transform_id": "channel_bitmap_aggregation",
      "family": "C",
      "target": "Consolidate the three fact-table scans into a single scan per fact table using UNION ALL and conditional aggregation to compute existence flags, then join once with customer. (Note: This is a portability candidate; use as exploration.)",
      "dag_target_hint": "Add sales_consolidated CTE that unions store_sales, web_sales, catalog_sales with channel flag; then aggregate by customer_sk to compute exists flags.",
      "node_contract": {
        "from_must_include": ["store_sales ss", "web_sales ws", "catalog_sales cs", "date_dim d"],
        "where_must_preserve": ["d_year=2002", "d_moy between 10 and 12", "list_price between 80 and 169 for each channel"],
        "output_must_preserve": ["Existence of at least one store_sales, absence of web_sales and catalog_sales per customer"]
      },
      "gates_checked": ["G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_EXISTS_INTERSECT_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Consolidating three fact scans into one pass may reduce I/O and improve parallelism, but may increase per-row cost; worth testing as exploration.",
      "confidence": 0.55,
      "expected_explain_delta": "Three separate index scans replaced by one scan per fact table (or union-all); aggregate computes flags; nested loops may become hash aggregates.",
      "recommended_patch_ops": ["insert_cte_sales_consolidated", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Exploration — targets repeated fact-table scans; if consolidation reduces I/O, could improve parallelism.",
      "recommended_examples": ["channel_bitmap_aggregation"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p06",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize the filtered customer–address–demographics join once as a CTE, then join it with precomputed channel key sets. Avoid recomputing the dimension join for each channel check.",
      "dag_target_hint": "Add filtered_customers CTE (materialized) and channel key CTEs; rewrite final_select to join these CTEs.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "customer_demographics cd"],
        "where_must_preserve": ["ca_state in ('CO','NC','TX')", "cd_marital_status in ('S','M','U')", "cd_education_status in ('Primary','College')"],
        "output_must_preserve": ["All original output columns and aggregates", "ORDER BY and LIMIT 100"]
      },
      "gates_checked": ["G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_EXISTS_INTERSECT_RISK:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.65,
      "expected_explain_delta": "Hash Join on customer/address/demographics computed once and materialized; outer loop row count reduced; channel joins use precomputed key sets.",
      "recommended_patch_ops": ["insert_cte_filtered_customers_materialized", "insert_cte_channel_keys", "replace_from"],
      "rank_rationale": "Targets repeated dimension joins; materialization may improve reuse and reduce hash build overhead.",
      "recommended_examples": ["pg_self_join_decomposition"],
      "gold_example_id": "pg_self_join_decomposition"
    },
    {
      "probe_id": "p07",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Stage reduction: create a CTE that pre-joins date_dim with each fact table, filtering on date and price, returning only customer_sk. Materialize these CTEs to create small hash tables for anti/semi-joins.",
      "dag_target_hint": "Add materialized CTEs for store_sales_filtered, web_sales_filtered, catalog_sales_filtered; join with filtered_customers CTE.",
      "node_contract": {
        "from_must_include": ["date_dim d", "store_sales ss", "web_sales ws", "catalog_sales cs"],
        "where_must_preserve": ["d_year=2002", "d_moy between 10 and 12", "list_price between 80 and 169"],
        "output_must_preserve": ["cs_ship_customer_sk", "ws_bill_customer_sk", "ss_customer_sk"]
      },
      "gates_checked": ["G_PG_NONEQUI_PRESENT:PASS", "G_PG_NONEQUI_CARDINALITY:PASS", "G_PG_NONEQUI_FILTER_QUALITY:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Materializing pre-joined fact–date results may create tiny hash tables for the anti/semi-joins, reducing nested-loop overhead.",
      "confidence": 0.60,
      "expected_explain_delta": "Index scans on fact tables replaced by CTE scans; nested loops become hash joins with small build side.",
      "recommended_patch_ops": ["insert_materialized_cte_store_filtered", "insert_materialized_cte_web_filtered", "insert_materialized_cte_catalog_filtered", "replace_from"],
      "rank_rationale": "Exploration — targets fact–date join amplification; materialization may improve join planning.",
      "recommended_examples": ["pg_materialized_dimension_fact_prefilter"],
      "gold_example_id": "pg_materialized_dimension_fact_prefilter"
    },
    {
      "probe_id": "p08",
      "transform_id": "intersect_to_exists",
      "family": "D",
      "target": "Convert the NOT EXISTS patterns to INTERSECT operations to see if PostgreSQL can optimize them better. (Note: This is exploratory; guardrail G_PG_CTE_EXISTS_INTERSECT_RISK warns of potential regression.)",
      "dag_target_hint": "Rewrite NOT EXISTS subqueries as INTERSECT between customer keys and channel keys; keep EXISTS as is.",
      "node_contract": {
        "from_must_include": ["customer c", "store_sales ss", "web_sales ws", "catalog_sales cs", "date_dim d"],
        "where_must_preserve": ["d_year=2002", "d_moy between 10 and 12", "list_price between 80 and 169"],
        "output_must_preserve": ["Same customer set as original NOT EXISTS logic"]
      },
      "gates_checked": ["G_PG_CTE_EXISTS_INTERSECT_RISK:PASS", "G_PG_EXISTS_PROTECTED:PASS"],
      "exploration": true,
      "exploration_hypothesis": "PostgreSQL may have better set-operation optimizations for INTERSECT than for correlated NOT EXISTS; worth testing as exploration.",
      "confidence": 0.45,
      "expected_explain_delta": "Nested Loop for NOT EXISTS replaced by Hash Intersect; may reduce loops but increase memory.",
      "recommended_patch_ops": ["replace_not_exists_with_intersect"],
      "rank_rationale": "Exploration — tests alternative set-operation path for NOT EXISTS; low confidence due to regression risk.",
      "recommended_examples": ["pg_intersect_to_exists"],
      "gold_example_id": "pg_intersect_to_exists"
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan; PostgreSQL BitmapOr handles indexed OR efficiently (guardrail G_PG_OR_INDEX_PROTECTED)."
    },
    {
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "reason": "Engine-specific to Snowflake; not applicable to PostgreSQL runtime dialect."
    },
    {
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "reason": "Engine-specific to Snowflake; not applicable to PostgreSQL runtime dialect."
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "No LEFT JOIN in query; transform not applicable."
    },
    {
      "transform_id": "deferred_window_aggregation",
      "family": "C",
      "reason": "No window functions in query; transform not applicable."
    }
  ]
}