[
  {
    "plan_id": "compile_p04",
    "dialect": "postgres",
    "confidence": 0.88,
    "based_on": "p04",
    "strategy": "Materialize filtered store_sales scans once, then join with explicit syntax.",
    "hypothesis": "Probe p04 (2.00x) proves the largest hotspot—repeated store_sales scans with late filtering—can be removed via CTE materialization. This rewrite prefilters both s1 and s2 copies of store_sales before the self‑join, eliminating the Merge Join and the cardinality mis‑estimation observed in the original plan.",
    "expected_explain_delta": "Merge Join and Sorts disappear; Nested Loop fan‑out reduced; two Index‑Only Scans on store_sales (filtered by ss_list_price) feed the CTEs, then hash joins proceed.",
    "target_ir": "Add filtered_s1, filtered_s2 CTE nodes; update final_select to use explicit joins.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["filtered_s1", "filtered_s2", "item", "item", "customer", "customer_address", "customer_demographics", "date_dim"],
          "outputs": ["i_item_sk", "i_item_sk", "cnt"],
          "changed": true,
          "sql": "SELECT item1.i_item_sk, item2.i_item_sk, COUNT(*) AS cnt FROM filtered_s1 s1 JOIN filtered_s2 s2 ON s1.ss_ticket_number = s2.ss_ticket_number JOIN item item1 ON s1.ss_item_sk = item1.i_item_sk JOIN item item2 ON s2.ss_item_sk = item2.i_item_sk JOIN customer c ON s1.ss_customer_sk = c.c_customer_sk JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk JOIN date_dim d ON d.d_date_sk = s1.ss_sold_date_sk WHERE item1.i_item_sk < item2.i_item_sk AND item1.i_category IN ('Electronics', 'Jewelry') AND item2.i_manager_id BETWEEN 81 AND 100 AND d.d_year BETWEEN 1998 AND 1998 + 1 AND cd.cd_marital_status = 'S' AND cd.cd_education_status = 'College' GROUP BY item1.i_item_sk, item2.i_item_sk ORDER BY cnt"
        },
        {
          "node_id": "filtered_s1",
          "parent_node_id": "final_select",
          "sources": ["store_sales"],
          "outputs": ["ss_item_sk", "ss_ticket_number", "ss_customer_sk", "ss_sold_date_sk"],
          "changed": true,
          "sql": "SELECT ss_item_sk, ss_ticket_number, ss_customer_sk, ss_sold_date_sk FROM store_sales WHERE ss_list_price BETWEEN 108 AND 122"
        },
        {
          "node_id": "filtered_s2",
          "parent_node_id": "final_select",
          "sources": ["store_sales"],
          "outputs": ["ss_item_sk", "ss_ticket_number"],
          "changed": true,
          "sql": "SELECT ss_item_sk, ss_ticket_number FROM store_sales WHERE ss_list_price BETWEEN 108 AND 122"
        }
      ]
    }
  },
  {
    "plan_id": "compile_hybrid",
    "dialect": "postgres",
    "confidence": 0.72,
    "based_on": "p01,p04",
    "strategy": "Combine date_dim CTE with filtered store_sales CTEs, full explicit‑join syntax.",
    "hypothesis": "Probes p01 (1.26x) and p04 (2.00x) show complementary strengths. This attempt merges both: a small date_dim CTE reduces early join cardinality, while filtered store_sales CTEs eliminate repeated scans. Explicit join syntax unlocks PostgreSQL’s inner‑join reordering.",
    "expected_explain_delta": "Merge Join removed; Nested Loop fan‑out reduced; date_dim CTE becomes a hash table; store_sales scans become two Index‑Only Scans with early list‑price filter.",
    "target_ir": "Add date_filtered, filtered_s1, filtered_s2 CTE nodes; update final_select with explicit joins.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["date_filtered", "filtered_s1", "filtered_s2", "item", "item", "customer", "customer_address", "customer_demographics"],
          "outputs": ["i_item_sk", "i_item_sk", "cnt"],
          "changed": true,
          "sql": "SELECT item1.i_item_sk, item2.i_item_sk, COUNT(*) AS cnt FROM date_filtered d JOIN filtered_s1 s1 ON d.d_date_sk = s1.ss_sold_date_sk JOIN filtered_s2 s2 ON s1.ss_ticket_number = s2.ss_ticket_number JOIN item item1 ON s1.ss_item_sk = item1.i_item_sk JOIN item item2 ON s2.ss_item_sk = item2.i_item_sk JOIN customer c ON s1.ss_customer_sk = c.c_customer_sk JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk WHERE item1.i_item_sk < item2.i_item_sk AND item1.i_category IN ('Electronics', 'Jewelry') AND item2.i_manager_id BETWEEN 81 AND 100 AND cd.cd_marital_status = 'S' AND cd.cd_education_status = 'College' GROUP BY item1.i_item_sk, item2.i_item_sk ORDER BY cnt"
        },
        {
          "node_id": "date_filtered",
          "parent_node_id": "final_select",
          "sources": ["date_dim"],
          "outputs": ["d_date_sk", "d_year"],
          "changed": true,
          "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year BETWEEN 1998 AND 1998 + 1"
        },
        {
          "node_id": "filtered_s1",
          "parent_node_id": "final_select",
          "sources": ["store_sales"],
          "outputs": ["ss_item_sk", "ss_ticket_number", "ss_customer_sk", "ss_sold_date_sk"],
          "changed": true,
          "sql": "SELECT ss_item_sk, ss_ticket_number, ss_customer_sk, ss_sold_date_sk FROM store_sales WHERE ss_list_price BETWEEN 108 AND 122"
        },
        {
          "node_id": "filtered_s2",
          "parent_node_id": "final_select",
          "sources": ["store_sales"],
          "outputs": ["ss_item_sk", "ss_ticket_number"],
          "changed": true,
          "sql": "SELECT ss_item_sk, ss_ticket_number FROM store_sales WHERE ss_list_price BETWEEN 108 AND 122"
        }
      ]
    }
  }
]