## Role

You are the **Beam Sniper** for SQL optimization on the target runtime dialect.

You receive the full Battle Damage Assessment (BDA) from 4-16 single-transform probes.
You are an evidence-informed analyst: you now have both wide knowledge and query-specific empirical results.

Your task: produce **exactly TWO optimization attempts** as compound PatchPlan candidates.

You may:
- combine winning worker ideas into one SQL patch when compatible
- introduce a new transform not tried by workers when evidence shows workers missed the real bottleneck

You must:
- ground decisions in BDA plus explain deltas
- preserve semantics
- avoid known regressions

---

## Prompt Map (cache friendly)

### Phase A - Cached Context (static)
A1. Dialect reminders plus regression registry
A2. Combination hazards (duplication, multiplicity, CTE fences)
A3. Evidence-first decision procedure (mechanical)
A4. Sniper output contract (strict JSON array)

### Phase B - Query-Specific Input (dynamic; after cache boundary)
B1. Importance star rating (1-3)
B2. Original SQL plus original plan
B3. IR structure plus anchor hashes
B4. BDA table (ALL probes: status, speedup, explain delta, failure reasons)
B5. Worker SQL patch outcomes (full rewritten SQL per probe plus top EXPLAIN nodes plus model description)
B6. Engine-specific knowledge profile (strengths, gaps, contraindications)

---

## Dialect reminders

Use runtime-injected **Engine-Specific Knowledge** as authoritative.
If static defaults conflict with runtime profile, follow runtime profile.

---

## Regression Registry (hard bans)

Do not produce a sniper plan that:
- forces materialization of a simple EXISTS already planned as a semi-join
- duplicates base scans (orphaned original scans after replacement)
- introduces unfiltered massive CTEs
- builds over-deep fact chains that lock join order
- applies same-column OR to UNION ALL by default on PostgreSQL

OR to UNION exception for PostgreSQL:
- only consider it when EXPLAIN evidence shows OR blocks index usage and UNION branches become index scans

---

## Combination hazards (what to watch)

- **Duplicate sources**: merging two plans that each add a filtered fact CTE can scan the same fact twice.
- **Join multiplicity**: turning EXISTS into JOIN can multiply rows unless keys are unique or aggregated.
- **CTE fences**: materialized CTEs can block pushdown and join reorder.
- **Overlapping edits**: if two probes edit the same anchor or predicate, unify them in one rewrite.

---

## Evidence-first decision procedure (mechanical)

1) Read the BDA table:
   - identify best verified winners: PASS/WIN with real speedup and stable equivalence
   - identify what still dominates: use explain deltas and original plan to find remaining hotspot

2) Choose a foundation:
   - prefer the best verified winner as the base
   - if none pass, base on the original query and propose the most justified fix

3) Decide the next move:
   - **combine** one compatible improvement from another passing probe if it targets a different hotspot and avoids hazards
   - **invent** one new transform not attempted if workers missed the hotspot, justified by plan evidence
   - for portability-style moves, proceed only when beam evidence and EXPLAIN deltas support transferability and runtime engine knowledge does not contradict it

4) Produce exactly two PatchPlans:
   - prefer 1-3 steps per plan; if more than 3, justify in `risk_notes`
   - use operationally targeted edits (prefer insert_cte/replace_from/replace_where_predicate)
   - payload SQL must be complete and executable

5) Provide expected EXPLAIN deltas and risks:
   - what should change if it works (operators, loops, rows)
   - biggest semantic risks
   - optional fallback probe if compound plan fails

---

## Sniper Output Contract (MUST follow)

Tier-0 output contract:
- response must be valid JSON
- first character must be `[` (no leading whitespace or newlines)
- top-level value must be an array of exactly two objects
- no markdown fences, no prose, no commentary

Schema rules:
- each object must include: `plan_id`, `dialect`, `hypothesis`, `target_ir`, `steps`
- optional `based_on` must be a string, never an array
- do not emit key `sql`; use `sql_fragment` where SQL fragment payload is required
- steps must target `{"by_node_id":"S0"}` unless an anchor hash is explicitly required

Allowed ops:
- insert_cte
- replace_from
- replace_where_predicate
- replace_body
- replace_expr_subtree
- delete_expr_subtree
- replace_join_condition
- replace_select
- replace_block_with_cte_pair
- wrap_query_with_cte

SQL payload rules:
- `replace_body`, `replace_select`, and `replace_block_with_cte_pair` must place SQL in `payload.sql_fragment`
- payload SQL must be complete and executable

Output JSON shape:
[
  {
    "plan_id": "snipe_p1",
    "dialect": "<target_dialect>",
    "confidence": 0.81,
    "based_on": "p03,p11",
    "strategy": "Foundation plus one compatible add-on",
    "hypothesis": "Plan evidence and expected win mechanism",
    "target_ir": "Short structural description of final query shape",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {"sql_fragment": "SELECT c_customer_sk FROM customer"}
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "<target_dialect>",
    "confidence": 0.73,
    "based_on": "p07",
    "strategy": "Alternative independent pathway",
    "hypothesis": "Plan evidence for second pathway",
    "target_ir": "Alternative structural description",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "filtered_sales",
          "cte_query_sql": "SELECT ss_customer_sk FROM store_sales WHERE ss_quantity > 0"
        }
      }
    ]
  }
]

---

## Cache Boundary
Everything below is query-specific input.

## Query ID
query072_agg_i2

## Runtime Dialect Contract
- target_dialect: postgres
- runtime_dialect_is_source_of_truth: true
- if static examples conflict, follow runtime dialect behavior

## Importance
- importance_stars: 3
- importance_label: ***

## Original SQL
```sql
select  i_item_desc
      ,w_warehouse_name
      ,d1.d_week_seq
      ,sum(case when p_promo_sk is null then 1 else 0 end) no_promo
      ,sum(case when p_promo_sk is not null then 1 else 0 end) promo
      ,count(*) total_cnt
from catalog_sales
join inventory on (cs_item_sk = inv_item_sk)
join warehouse on (w_warehouse_sk=inv_warehouse_sk)
join item on (i_item_sk = cs_item_sk)
join customer_demographics on (cs_bill_cdemo_sk = cd_demo_sk)
join household_demographics on (cs_bill_hdemo_sk = hd_demo_sk)
join date_dim d1 on (cs_sold_date_sk = d1.d_date_sk)
join date_dim d2 on (inv_date_sk = d2.d_date_sk)
join date_dim d3 on (cs_ship_date_sk = d3.d_date_sk)
left outer join promotion on (cs_promo_sk=p_promo_sk)
left outer join catalog_returns on (cr_item_sk = cs_item_sk and cr_order_number = cs_order_number)
where d1.d_week_seq = d2.d_week_seq
  and inv_quantity_on_hand < cs_quantity
  and d3.d_date > d1.d_date + interval '3 day'
  and hd_buy_potential = '>10000'
  and d1.d_year = 1999
  and cd_marital_status = 'S'
  and cd_dep_count between 9 and 11
  and i_category IN ('Men', 'Shoes', 'Sports')
  and cs_wholesale_cost BETWEEN 76 AND 96
group by i_item_desc,w_warehouse_name,d1.d_week_seq
order by total_cnt desc, i_item_desc, w_warehouse_name, d_week_seq
limit 100;
```

## Original Plan
```
Limit  (rows=0, time=5778.837)
  Sort  (rows=0, time=5761.575)
    Aggregate  (rows=0, time=5761.528)
      Nested Loop  (rows=0, time=5761.524)
        Nested Loop  (rows=0, time=5761.523)
          Gather Merge  (rows=0, time=5761.521)
            Sort  (rows=0, time=5744.886)
              Nested Loop  (rows=0, time=5744.87)
                Nested Loop  (rows=0, time=5744.869)
                  Nested Loop  (rows=0, time=5744.868)
                    Hash Join  (rows=0, time=5744.867)
                      Seq Scan on date_dim (d2)  (rows=0, time=0.0)
                      Hash  (rows=0, time=5744.786)
                        Nested Loop  (rows=0, time=3732.443)
                          Hash Join  (rows=23847, time=2678.755)
                            Nested Loop  (rows=113468, time=2655.744)
                              Index Scan on date_dim (d1)  (rows=182, time=78.72)
                              Index Scan on catalog_sales  (rows=622, time=14.054)
                            Hash  (rows=1200, time=4.462)
                              Seq Scan on household_demographics  (rows=1200, time=4.365)
                          Index Scan on customer_demographics  (rows=0, time=0.044)
                    Index Scan on inventory  (rows=0, time=0.0)
                  Seq Scan on warehouse  (rows=0, time=0.0)
                Index Scan on item  (rows=0, time=0.0)
          Index Scan on date_dim (d3)  (rows=0, time=0.0)
        Seq Scan on promotion  (rows=0, time=0.0)
```

## IR Structure + Anchor Hashes
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: catalog_sales, inventory, warehouse, item, customer_demographics, household_demographics, date_dim d1, date_dim d2, date_dim d3, promotion, catalog_returns
    WHERE [ece830e47c29a467]: d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < cs_quantity AND d3.d_date > d1.d_date + ...
    GROUP BY: i_item_desc, w_warehouse_name, d1.d_week_seq
    ORDER BY: total_cnt, i_item_desc, w_warehouse_name, d_week_seq

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Schema / Index / Stats Context
- source: postgres
- referenced_tables: 9

| Table | Rows(est) | PK | Indexes |
|-------|-----------|----|---------|
| catalog_returns | 2158290 | cr_item_sk, cr_order_number | catalog_returns_pkey |
| catalog_sales | 14397255 | cs_item_sk, cs_order_number | catalog_sales_pkey, _dta_index_catalog_sales_6_1301579675__k1_k16_k5_k4_3_6_18_19_2, _dta_index_catalog_sales_6_1301579675__k17_k6_k3_k5_k1_k16_12_1, _dta_index_catalog_sales_6_1301579675__k1_4_16_18_19_21_24, _dta_index_catalog_sales_6_1301579675__k3_k12_k14_k15_16_18, _dta_index_catalog_sales_6_1301579675__k1_k16_k4_18_34 |
| customer_demographics | 1920800 | cd_demo_sk | customer_demographics_pkey |
| date_dim | 73049 | d_date_sk | date_dim_pkey, _dta_index_date_dim_6_661577395__k7_k4_k9_k1, _dta_index_date_dim_6_661577395__k7_k9_k1, _dta_index_date_dim_6_661577395__k1_k7_k9, _dta_index_date_dim_6_661577395__k7_k11_k1, _dta_index_date_dim_6_661577395__k9_k7_k1 |
| household_demographics | 7200 | hd_demo_sk | household_demographics_pkey |
| inventory | 133111200 | inv_date_sk, inv_item_sk, inv_warehouse_sk | inventory_pkey |
| item | 102000 | i_item_sk | item_pkey, _dta_index_item_6_853578079__k1_2_5, _dta_index_item_6_853578079__k13_k11_k1, _dta_index_item_6_853578079__k18, _dta_index_item_6_853578079__k2_k1 |
| promotion | 500 | p_promo_sk | promotion_pkey |
| warehouse | 10 | w_warehouse_sk | warehouse_pkey |

## Engine-Specific Knowledge
## Dialect Profile (POSTGRES)

**Combined Intelligence Baseline**: Combined intelligence baseline from 53 validated DSB queries at SF5-SF10, plus regression registry outcomes. PostgreSQL has bitmap index scans, JIT compilation, and aggressive CTE materialization. Techniques that work on DuckDB often regress here.

### Optimizer Strengths (don't fight these)
- `BITMAP_OR_SCAN`: Avoid splitting OR conditions into UNION ALL by default. Only consider OR→UNION when EXPLAIN shows OR blocks index usage and UNION branches become index scans. 0.21x and 0.26x reg…
- `SEMI_JOIN_EXISTS`: NEVER convert EXISTS to IN/NOT IN or materialized CTEs. 0.50x, 0.75x observed. Note: NOT EXISTS anti-join decorrelation can still be valid when replacing large correlated anti patterns.
- `INNER_JOIN_REORDERING`: Don't restructure INNER JOIN orders. Focus on LEFT JOIN blocking or comma-join confusion.
- `INDEX_ONLY_SCAN`: Small dimension lookups (<10K rows) may not need CTEs.

### Known Gaps (exploit these)
- `COMMA_JOIN_WEAKNESS` [HIGH] detect: FROM t1, t2, t3 WHERE t1.key = t2.key (comma joins, no explicit JOIN). Poor row estimates in EXPLAIN. | action: Convert comma-joins to explicit JOIN...ON syntax. Best when combined with date_cte_isolate.
- `CORRELATED_SUBQUERY_PARALYSIS` [HIGH] detect: Nested loop in EXPLAIN, inner re-executes aggregate per outer row. SQL: WHERE col > (SELECT AGG FROM ... WHERE outer.key = inner.key). Hash… | action: Convert correlated WHERE to explicit CTE with GROUP BY + JOIN.
- `NON_EQUI_JOIN_INPUT_BLINDNESS` [HIGH] detect: Expensive non-equi join (BETWEEN, <, >) with large inputs on both sides. Neither side filtered. | action: Reduce fact table input size via filtered CTE before the non-equi join.
- `CTE_MATERIALIZATION_FENCE` [MEDIUM] detect: Large CTE + small post-filter. Multi-referenced CTE that blocks predicate pushdown. | action: Materialize STRATEGICALLY: only when CTE is expensive and reused. Avoid fencing single-use cases.
- `CROSS_CTE_PREDICATE_BLINDNESS` [MEDIUM] detect: Sequential scan on dimension table without index condition. Late filter after large scan/join. | action: Pre-filter into CTE definition. But be more cautious than on DuckDB.

## Dispatcher Hypothesis
Cost spine dominated by Nested Loop between date_dim d1 and catalog_sales (113k rows, 2.6s) and final aggregation/sort (5.7s). Late selectivity at d3 filter and non-equi inventory join suggest early filtering and staged reduction. Multiple selective dimension filters not fully leveraged.

## Dispatcher Reasoning Trace
- Nested Loop d1-catalog_sales produces 113k rows despite d1 index scan
- Hash Join with household_demographics consumes 2.6s despite small dimension
- Aggregation and Sort take 5.7s on reduced rowset
- Non-equi join (inv_quantity_on_hand < cs_quantity) may suffer from input blindness
- d2 scan shows 0ms but inventory join may be masked in timing

## Equivalence Tier
- unordered

## Additional Intelligence
### AST Feature Detection

- **materialized_dimension_fact_prefilter**: 100% match (AGG_COUNT, AGG_SUM, BETWEEN, CASE_EXPR) (gap: NON_EQUI_JOIN_INPUT_BLINDNESS)  [SUPPORT: native_or_universal]
- **date_cte_explicit_join**: 100% match (AGG_SUM, BETWEEN, CASE_EXPR, DATE_DIM) (gap: COMMA_JOIN_WEAKNESS)  [SUPPORT: native_or_universal]
- **early_filter**: 100% match (AGG_SUM, CASE_EXPR, GROUP_BY, LEFT_JOIN) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [SUPPORT: portability_candidate; engines=duckdb]
- **multi_dimension_prefetch**: 100% match (AGG_SUM, CASE_EXPR, DATE_DIM, GROUP_BY) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [SUPPORT: portability_candidate; engines=duckdb]
- **prefetch_fact_join**: 100% match (AGG_SUM, DATE_DIM, GROUP_BY, STAR_JOIN) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: MAX_2_CHAINS] [SUPPORT: portability_candidate; engines=duckdb]


## Probe Summary
12 probes fired, 0 passed validation, 0 showed speedup.

## BDA Table (all probes)

| Probe | Transform | Family | Status | Speedup | Top EXPLAIN Nodes | Model Description | SQL Patch | Error/Notes |
|-------|-----------|--------|--------|---------|-------------------|-------------------|-----------|-------------|
| p05 | prefetch_fact_join | A | ERROR | - | - | CTE chain: dims_cte = (hd_cte JOIN cd_cte), fact_cte = (catalog_sales JOIN dims_cte). Preserve all original JOIN conditions in staged reduction. | p05 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p08 | date_cte_isolate | A | ERROR | - | - | Materialize d1_cte (d_year=1999), d2_cte (unfiltered), d3_cte (unfiltered). Preserve date conditions in main WHERE clause. | p08 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p12 | inner_join_conversion | F | ERROR | - | - | Convert promotion LEFT JOIN to INNER JOIN + CTE. WHERE clause functionally makes it inner. Preserve promo count semantics. | p12 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p06 | aggregate_pushdown | C | ERROR | - | - | Push aggregation to after catalog_sales joins with d1/hd/cd/item. Group by surrogate keys (i_item_sk, w_warehouse_sk, d_date_sk). Preserve counts for later combination. | p06 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p04 | multi_date_range_cte | A | ERROR | - | - | Create filtered CTEs: d1_cte (d_year=1999), d2_cte (d_year=1999 via d_week_seq=d1), d3_cte (d_date>d1+3). Preserve date relationships in main JOIN. | p04 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p03 | date_cte_explicit_join | F | ERROR | - | - | Materialize d1_cte (d_year=1999), d2_cte (no filter), d3_cte (no filter). Use explicit JOIN syntax between date CTEs and main tables. | p03 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p01 | dimension_prefetch_star | F | ERROR | - | - | Create CTEs for all selective dimensions: hd_cte (hd_demo_sk), cd_cte (cd_demo_sk), i_cte (i_item_sk), d1_cte (d_date_sk). Preserve join conditions during reassembly. | p01 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p02 | materialized_dimension_fact_prefilter | F | ERROR | - | - | Create fact_cte = catalog_sales JOIN d1_cte. Create inv_cte = inventory JOIN d2_cte. Apply non-equi join (inv_quantity_on_hand < cs_quantity) between materialized CTEs. | p02 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p10 | multi_dimension_prefetch | A | ERROR | - | - | Combine hd/cd/i dimension filters into single CTE. Join with catalog_sales before other tables. Preserve join conditions. | p10 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p07 | early_filter | A | ERROR | - | - | Move all dimension filters (hd, cd, item, d1) into CTE definitions. Ensure filters execute before main joins. | p07 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p09 | dimension_cte_isolate | A | ERROR | - | - | Create CTEs for all dimensions: hd_cte, cd_cte, i_cte, w_cte, p_cte, d1_cte, d2_cte, d3_cte with base filters. Maintain original join relationships. | p09 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p11 | pg_self_join_decomposition | E | ERROR | - | - | Materialize filtered fact-dimension join (catalog_sales + d1 + hd + cd) as base_cte. Derive aggregates from single materialization. | p11 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |

## Worker SQL Patches

### p05: prefetch_fact_join (ERROR, n/a)
```sql
WITH filtered_dims AS (SELECT cd_demo_sk, hd_demo_sk FROM customer_demographics, household_demographics WHERE cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND hd_buy_potential = '>10000') SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales JOIN filtered_dims AS fd ON cs_bill_cdemo_sk = fd.cd_demo_sk AND cs_bill_hdemo_sk = fd.hd_demo_sk JOIN inventory ON cs_item_sk = inv_item_sk JOIN warehouse ON w_warehouse_sk = inv_warehouse_sk JOIN item ON i_item_sk = cs_item_sk JOIN date_dim AS d1 ON cs_sold_date_sk = d1.d_date_sk JOIN date_dim AS d2 ON inv_date_sk = d2.d_date_sk JOIN date_dim AS d3 ON cs_ship_date_sk = d3.d_date_sk LEFT OUTER JOIN promotion ON cs_promo_sk = p_promo_sk LEFT OUTER JOIN catalog_returns ON cr_item_sk = cs_item_sk AND cr_order_number = cs_order_number WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND hd_buy_potential = '>10000' AND d1.d_year = 1999 AND cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND i_category IN ('Men', 'Shoes', 'Sports') AND cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p08: date_cte_isolate (ERROR, n/a)
```sql
WITH d1_cte AS (SELECT * FROM date_dim WHERE d_year = 1999), d2_cte AS (SELECT * FROM date_dim), d3_cte AS (SELECT * FROM date_dim) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales JOIN inventory ON (cs_item_sk = inv_item_sk) JOIN warehouse ON (w_warehouse_sk = inv_warehouse_sk) JOIN item ON (i_item_sk = cs_item_sk) JOIN customer_demographics ON (cs_bill_cdemo_sk = cd_demo_sk) JOIN household_demographics ON (cs_bill_hdemo_sk = hd_demo_sk) JOIN d1_cte AS d1 ON (cs_sold_date_sk = d1.d_date_sk) JOIN d2_cte AS d2 ON (inv_date_sk = d2.d_date_sk) JOIN d3_cte AS d3 ON (cs_ship_date_sk = d3.d_date_sk) LEFT OUTER JOIN promotion ON (cs_promo_sk = p_promo_sk) LEFT OUTER JOIN catalog_returns ON (cr_item_sk = cs_item_sk AND cr_order_number = cs_order_number) WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND hd_buy_potential = '>10000' AND d1.d_year = 1999 AND cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND i_category IN ('Men', 'Shoes', 'Sports') AND cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p12: inner_join_conversion (ERROR, n/a)
```sql
WITH valid_promos AS (SELECT p_promo_sk FROM promotion WHERE NOT p_promo_sk IS NULL) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales JOIN inventory ON (cs_item_sk = inv_item_sk) JOIN warehouse ON (w_warehouse_sk = inv_warehouse_sk) JOIN item ON (i_item_sk = cs_item_sk) JOIN customer_demographics ON (cs_bill_cdemo_sk = cd_demo_sk) JOIN household_demographics ON (cs_bill_hdemo_sk = hd_demo_sk) JOIN date_dim AS d1 ON (cs_sold_date_sk = d1.d_date_sk) JOIN date_dim AS d2 ON (inv_date_sk = d2.d_date_sk) JOIN date_dim AS d3 ON (cs_ship_date_sk = d3.d_date_sk) INNER JOIN valid_promos ON (cs_promo_sk = valid_promos.p_promo_sk) LEFT OUTER JOIN catalog_returns ON (cr_item_sk = cs_item_sk AND cr_order_number = cs_order_number) WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND hd_buy_potential = '>10000' AND d1.d_year = 1999 AND cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND i_category IN ('Men', 'Shoes', 'Sports') AND cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p06: aggregate_pushdown (ERROR, n/a)
```sql
WITH agg_catalog_sales AS (SELECT cs_item_sk, cs_bill_warehouse_sk AS w_warehouse_sk, cs_sold_date_sk AS d_date_sk, SUM(cs_quantity) AS total_quantity, COUNT(*) AS cnt FROM catalog_sales GROUP BY cs_item_sk, cs_bill_warehouse_sk, cs_sold_date_sk) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM agg_catalog_sales AS acs JOIN inventory ON (acs.cs_item_sk = inv_item_sk AND acs.w_warehouse_sk = inv_warehouse_sk) JOIN warehouse AS w ON (acs.w_warehouse_sk = w.w_warehouse_sk) JOIN item AS i ON (acs.cs_item_sk = i.i_item_sk) JOIN customer_demographics AS cd ON (acs.cs_bill_cdemo_sk = cd.cd_demo_sk) JOIN household_demographics AS hd ON (acs.cs_bill_hdemo_sk = hd.hd_demo_sk) JOIN date_dim AS d1 ON (acs.d_date_sk = d1.d_date_sk) JOIN date_dim AS d2 ON (inv_date_sk = d2.d_date_sk) JOIN date_dim AS d3 ON (acs.cs_ship_date_sk = d3.d_date_sk) LEFT OUTER JOIN promotion AS p ON (acs.cs_promo_sk = p.p_promo_sk) LEFT OUTER JOIN catalog_returns AS cr ON (acs.cs_item_sk = cr.cr_item_sk AND acs.cs_order_number = cr.cr_order_number) WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < acs.total_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND hd_buy_potential = '>10000' AND d1.d_year = 1999 AND cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND i_category IN ('Men', 'Shoes', 'Sports') AND acs.cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p04: multi_date_range_cte (ERROR, n/a)
```sql
WITH d1_cte AS (SELECT d_date_sk, d_week_seq, d_date FROM date_dim WHERE d_year = 1999), d2_cte AS (SELECT d_date_sk, d_week_seq FROM date_dim WHERE d_year = 1999), d3_cte AS (SELECT d_date_sk, d_date FROM date_dim) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales JOIN inventory ON (cs_item_sk = inv_item_sk) JOIN warehouse ON (w_warehouse_sk = inv_warehouse_sk) JOIN item ON (i_item_sk = cs_item_sk) JOIN customer_demographics ON (cs_bill_cdemo_sk = cd_demo_sk) JOIN household_demographics ON (cs_bill_hdemo_sk = hd_demo_sk) JOIN d1_cte AS d1 ON (cs_sold_date_sk = d1.d_date_sk) JOIN d2_cte AS d2 ON (inv_date_sk = d2.d_date_sk) JOIN d3_cte AS d3 ON (cs_ship_date_sk = d3.d_date_sk) LEFT OUTER JOIN promotion ON (cs_promo_sk = p_promo_sk) LEFT OUTER JOIN catalog_returns ON (cr_item_sk = cs_item_sk AND cr_order_number = cs_order_number) WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND hd_buy_potential = '>10000' AND d1.d_year = 1999 AND cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND i_category IN ('Men', 'Shoes', 'Sports') AND cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p03: date_cte_explicit_join (ERROR, n/a)
```sql
WITH d1_cte AS (SELECT * FROM date_dim WHERE d_year = 1999), d2_cte AS (SELECT * FROM date_dim), d3_cte AS (SELECT * FROM date_dim) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales JOIN inventory ON (cs_item_sk = inv_item_sk) JOIN warehouse ON (w_warehouse_sk = inv_warehouse_sk) JOIN item ON (i_item_sk = cs_item_sk) JOIN customer_demographics ON (cs_bill_cdemo_sk = cd_demo_sk) JOIN household_demographics ON (cs_bill_hdemo_sk = hd_demo_sk) JOIN d1_cte AS d1 ON (cs_sold_date_sk = d1.d_date_sk) JOIN d2_cte AS d2 ON (inv_date_sk = d2.d_date_sk) JOIN d3_cte AS d3 ON (cs_ship_date_sk = d3.d_date_sk) LEFT OUTER JOIN promotion ON (cs_promo_sk = p_promo_sk) LEFT OUTER JOIN catalog_returns ON (cr_item_sk = cs_item_sk AND cr_order_number = cs_order_number) WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND hd_buy_potential = '>10000' AND cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND i_category IN ('Men', 'Shoes', 'Sports') AND cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p01: dimension_prefetch_star (ERROR, n/a)
```sql
WITH hd_cte AS (SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '>10000'), cd_cte AS (SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11), i_cte AS (SELECT i_item_sk, i_item_desc FROM item WHERE i_category IN ('Men', 'Shoes', 'Sports')), d1_cte AS (SELECT d_date_sk, d_week_seq FROM date_dim WHERE d_year = 1999) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales JOIN inventory ON (cs_item_sk = inv_item_sk) JOIN warehouse ON (w_warehouse_sk = inv_warehouse_sk) JOIN i_cte ON (i_item_sk = cs_item_sk) JOIN cd_cte ON (cs_bill_cdemo_sk = cd_demo_sk) JOIN hd_cte ON (cs_bill_hdemo_sk = hd_demo_sk) JOIN d1_cte AS d1 ON (cs_sold_date_sk = d1.d_date_sk) JOIN date_dim AS d2 ON (inv_date_sk = d2.d_date_sk) JOIN date_dim AS d3 ON (cs_ship_date_sk = d3.d_date_sk) LEFT OUTER JOIN promotion ON (cs_promo_sk = p_promo_sk) LEFT OUTER JOIN catalog_returns ON (cr_item_sk = cs_item_sk AND cr_order_number = cs_order_number) WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p02: materialized_dimension_fact_prefilter (ERROR, n/a)
```sql
WITH fact_cte AS (SELECT cs_item_sk, cs_order_number, cs_quantity, cs_wholesale_cost, cs_sold_date_sk, cs_ship_date_sk, cs_bill_cdemo_sk, cs_bill_hdemo_sk, cs_promo_sk FROM catalog_sales JOIN household_demographics ON (cs_bill_hdemo_sk = hd_demo_sk) JOIN customer_demographics ON (cs_bill_cdemo_sk = cd_demo_sk) WHERE hd_buy_potential = '>10000' AND cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND cs_wholesale_cost BETWEEN 76 AND 96), inv_cte AS (SELECT inv_item_sk, inv_warehouse_sk, inv_quantity_on_hand, inv_date_sk FROM inventory JOIN date_dim AS d2 ON (inv_date_sk = d2.d_date_sk)) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM fact_cte JOIN inv_cte ON (fact_cte.cs_item_sk = inv_cte.inv_item_sk AND inv_cte.inv_quantity_on_hand < fact_cte.cs_quantity) JOIN warehouse ON (w_warehouse_sk = inv_cte.inv_warehouse_sk) JOIN item ON (i_item_sk = fact_cte.cs_item_sk) JOIN date_dim AS d1 ON (fact_cte.cs_sold_date_sk = d1.d_date_sk) JOIN date_dim AS d3 ON (fact_cte.cs_ship_date_sk = d3.d_date_sk) LEFT OUTER JOIN promotion ON (fact_cte.cs_promo_sk = p_promo_sk) LEFT OUTER JOIN catalog_returns ON (cr_item_sk = fact_cte.cs_item_sk AND cr_order_number = fact_cte.cs_order_number) WHERE d1.d_week_seq = (SELECT d_week_seq FROM date_dim WHERE d_date_sk = inv_cte.inv_date_sk) AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND d1.d_year = 1999 AND i_category IN ('Men', 'Shoes', 'Sports') GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p10: multi_dimension_prefetch (ERROR, n/a)
```sql
WITH filtered_household_demographics AS (SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '>10000'), filtered_customer_demographics AS (SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11), filtered_item AS (SELECT i_item_sk FROM item WHERE i_category IN ('Men', 'Shoes', 'Sports')) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales AS cs JOIN filtered_household_demographics AS fhd ON cs.cs_bill_hdemo_sk = fhd.hd_demo_sk JOIN filtered_customer_demographics AS fcd ON cs.cs_bill_cdemo_sk = fcd.cd_demo_sk JOIN filtered_item AS fi ON cs.cs_item_sk = fi.i_item_sk JOIN inventory AS inv ON cs.cs_item_sk = inv.inv_item_sk JOIN warehouse AS w ON inv.inv_warehouse_sk = w.w_warehouse_sk JOIN date_dim AS d1 ON cs.cs_sold_date_sk = d1.d_date_sk JOIN date_dim AS d2 ON inv.inv_date_sk = d2.d_date_sk JOIN date_dim AS d3 ON cs.cs_ship_date_sk = d3.d_date_sk LEFT JOIN promotion AS p ON cs.cs_promo_sk = p.p_promo_sk LEFT JOIN catalog_returns AS cr ON cs.cs_item_sk = cr.cr_item_sk AND cs.cs_order_number = cr.cr_order_number WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND hd_buy_potential = '>10000' AND d1.d_year = 1999 AND cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND i_category IN ('Men', 'Shoes', 'Sports') AND cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p07: early_filter (ERROR, n/a)
```sql
WITH filtered_household_demographics AS (SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '>10000'), filtered_customer_demographics AS (SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11), filtered_item AS (SELECT i_item_sk FROM item WHERE i_category IN ('Men', 'Shoes', 'Sports')), filtered_d1_dates AS (SELECT d_date_sk, d_week_seq FROM date_dim WHERE d_year = 1999) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales JOIN inventory ON (cs_item_sk = inv_item_sk) JOIN warehouse ON (w_warehouse_sk = inv_warehouse_sk) JOIN filtered_item AS fi ON (fi.i_item_sk = cs_item_sk) JOIN filtered_customer_demographics AS fcd ON (cs_bill_cdemo_sk = fcd.cd_demo_sk) JOIN filtered_household_demographics AS fhd ON (cs_bill_hdemo_sk = fhd.hd_demo_sk) JOIN filtered_d1_dates AS d1 ON (cs_sold_date_sk = d1.d_date_sk) JOIN date_dim AS d2 ON (inv_date_sk = d2.d_date_sk) JOIN date_dim AS d3 ON (cs_ship_date_sk = d3.d_date_sk) LEFT OUTER JOIN promotion ON (cs_promo_sk = p_promo_sk) LEFT OUTER JOIN catalog_returns ON (cr_item_sk = cs_item_sk AND cr_order_number = cs_order_number) WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p09: dimension_cte_isolate (ERROR, n/a)
```sql
WITH hd_cte AS (SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '>10000'), cd_cte AS (SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11), i_cte AS (SELECT i_item_sk FROM item WHERE i_category IN ('Men', 'Shoes', 'Sports')), d1_cte AS (SELECT d_date_sk, d_week_seq, d_date FROM date_dim WHERE d_year = 1999), d2_cte AS (SELECT d_date_sk, d_week_seq FROM date_dim), d3_cte AS (SELECT d_date_sk, d_date FROM date_dim) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales AS cs JOIN inventory AS inv ON cs.cs_item_sk = inv.inv_item_sk AND inv.inv_quantity_on_hand < cs.cs_quantity JOIN warehouse AS w ON w.w_warehouse_sk = inv.inv_warehouse_sk JOIN i_cte AS i ON i.i_item_sk = cs.cs_item_sk JOIN cd_cte AS cd ON cd.cd_demo_sk = cs.cs_bill_cdemo_sk JOIN hd_cte AS hd ON hd.hd_demo_sk = cs.cs_bill_hdemo_sk JOIN d1_cte AS d1 ON d1.d_date_sk = cs.cs_sold_date_sk JOIN d2_cte AS d2 ON d2.d_date_sk = inv.inv_date_sk JOIN d3_cte AS d3 ON d3.d_date_sk = cs.cs_ship_date_sk LEFT JOIN promotion AS p ON cs.cs_promo_sk = p.p_promo_sk LEFT JOIN catalog_returns AS cr ON cr.cr_item_sk = cs.cs_item_sk AND cr.cr_order_number = cs.cs_order_number WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND hd_buy_potential = '>10000' AND d1.d_year = 1999 AND cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND i_category IN ('Men', 'Shoes', 'Sports') AND cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```

### p11: pg_self_join_decomposition (ERROR, n/a)
```sql
WITH filtered_sales AS (SELECT cs_item_sk, cs_order_number, cs_quantity, cs_wholesale_cost, cs_promo_sk, cs_sold_date_sk, d1.d_week_seq FROM catalog_sales JOIN date_dim AS d1 ON cs_sold_date_sk = d1.d_date_sk WHERE d1.d_year = 1999) SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM filtered_sales AS fs JOIN inventory ON (fs.cs_item_sk = inv_item_sk) JOIN warehouse ON (w_warehouse_sk = inv_warehouse_sk) JOIN item ON (i_item_sk = fs.cs_item_sk) JOIN customer_demographics ON (cs_bill_cdemo_sk = cd_demo_sk) JOIN household_demographics ON (cs_bill_hdemo_sk = hd_demo_sk) JOIN date_dim AS d2 ON (inv_date_sk = d2.d_date_sk) JOIN date_dim AS d3 ON (cs_ship_date_sk = d3.d_date_sk) LEFT OUTER JOIN promotion ON (fs.cs_promo_sk = p_promo_sk) LEFT OUTER JOIN catalog_returns ON (cr_item_sk = fs.cs_item_sk AND cr_order_number = fs.cs_order_number) WHERE d1.d_week_seq = d2.d_week_seq AND inv_quantity_on_hand < fs.cs_quantity AND d3.d_date > d1.d_date + INTERVAL '3 DAY' AND hd_buy_potential = '>10000' AND cd_marital_status = 'S' AND cd_dep_count BETWEEN 9 AND 11 AND i_category IN ('Men', 'Shoes', 'Sports') AND fs.cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100;
```
