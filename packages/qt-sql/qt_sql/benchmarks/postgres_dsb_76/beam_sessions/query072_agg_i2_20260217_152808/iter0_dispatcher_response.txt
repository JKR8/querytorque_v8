{
  "dispatch": {
    "dialect": "postgres",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Cost spine dominated by Nested Loop between date_dim d1 and catalog_sales (113k rows, 2.6s) and final aggregation/sort (5.7s). Late selectivity at d3 filter and non-equi inventory join suggest early filtering and staged reduction. Multiple selective dimension filters not fully leveraged.",
    "reasoning_trace": [
      "Nested Loop d1-catalog_sales produces 113k rows despite d1 index scan",
      "Hash Join with household_demographics consumes 2.6s despite small dimension",
      "Aggregation and Sort take 5.7s on reduced rowset",
      "Non-equi join (inv_quantity_on_hand < cs_quantity) may suffer from input blindness",
      "d2 scan shows 0ms but inventory join may be masked in timing"
    ],
    "cost_spine": [
      "Nested Loop (d1-catalog_sales) → Hash Join (household_demographics) → Aggregate → Sort"
    ],
    "hotspots": [
      {"op": "Nested Loop", "why": "Row amplification (182*622)", "evidence": "rows=113468, time=2655ms"},
      {"op": "Hash Join", "why": "Probes 113k rows", "evidence": "rows=23847, time=2678ms"},
      {"op": "Aggregate+Sort", "why": "Final processing", "evidence": "time=5761ms"}
    ],
    "do_not_do": [
      "or_to_union (no OR conditions)",
      "exists_to_in (no EXISTS)",
      "join_reorder (PG inner join strength)"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "status",
    "speedup",
    "expected_explain_delta",
    "ops_used",
    "confidence",
    "exploration",
    "failure_reason",
    "target"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Create CTEs for all selective dimensions: hd_cte (hd_demo_sk), cd_cte (cd_demo_sk), i_cte (i_item_sk), d1_cte (d_date_sk). Preserve join conditions during reassembly.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "inventory"],
        "where_must_preserve": ["hd_buy_potential='>10000'", "cd_marital_status='S'", "i_category IN ('Men','Shoes','Sports')", "d1.d_year=1999"],
        "output_must_preserve": ["no_promo", "promo", "total_cnt calculation semantics"]
      },
      "gates_checked": ["no_self_join:PASS", "no_set_ops:PASS"],
      "exploration": false,
      "confidence": 0.85,
      "expected_explain_delta": "Bitmap scans on dimension CTEs, earlier row reduction in catalog_sales join",
      "recommended_patch_ops": ["insert_cte", "replace_from"]
    },
    {
      "probe_id": "p02",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Create fact_cte = catalog_sales JOIN d1_cte. Create inv_cte = inventory JOIN d2_cte. Apply non-equi join (inv_quantity_on_hand < cs_quantity) between materialized CTEs.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "inventory"],
        "where_must_preserve": ["inv_quantity_on_hand < cs_quantity", "d1.d_week_seq = d2.d_week_seq"],
        "output_must_preserve": ["cs_quantity for non-equi comparison"]
      },
      "gates_checked": ["non_equi_join_present:PASS"],
      "exploration": false,
      "confidence": 0.8,
      "expected_explain_delta": "Hash Join between fact_cte and inv_cte replacing nested loop",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"]
    },
    {
      "probe_id": "p03",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Materialize d1_cte (d_year=1999), d2_cte (no filter), d3_cte (no filter). Use explicit JOIN syntax between date CTEs and main tables.",
      "node_contract": {
        "from_must_include": ["d1", "d2", "d3"],
        "where_must_preserve": ["d1.d_week_seq = d2.d_week_seq", "d3.d_date > d1.d_date + interval '3 day'"],
        "output_must_preserve": ["d1.d_week_seq in GROUP BY"]
      },
      "gates_checked": ["comma_join_weakness:WARN"],
      "exploration": false,
      "confidence": 0.75,
      "expected_explain_delta": "Materialized CTE scans, hash joins instead of nested loops",
      "recommended_patch_ops": ["insert_cte", "replace_join_condition"]
    },
    {
      "probe_id": "p04",
      "transform_id": "multi_date_range_cte",
      "family": "A",
      "target": "Create filtered CTEs: d1_cte (d_year=1999), d2_cte (d_year=1999 via d_week_seq=d1), d3_cte (d_date>d1+3). Preserve date relationships in main JOIN.",
      "node_contract": {
        "from_must_include": ["d1", "d2", "d3"],
        "where_must_preserve": ["d1.d_week_seq = d2.d_week_seq", "d3.d_date > d1.d_date + interval '3 day'"],
        "output_must_preserve": ["d1.d_week_seq"]
      },
      "gates_checked": ["cte_materialization_fence:WARN"],
      "exploration": true,
      "exploration_hypothesis": "PG may push filters into CTEs despite materialization fence. Date constraints reduce d2/d3 scans.",
      "confidence": 0.6,
      "expected_explain_delta": "Reduced rows in date_dim scans, earlier filter application",
      "recommended_patch_ops": ["insert_cte", "replace_from"]
    },
    {
      "probe_id": "p05",
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "target": "CTE chain: dims_cte = (hd_cte JOIN cd_cte), fact_cte = (catalog_sales JOIN dims_cte). Preserve all original JOIN conditions in staged reduction.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "household_demographics", "customer_demographics"],
        "where_must_preserve": ["cs_bill_hdemo_sk = hd_demo_sk", "cs_bill_cdemo_sk = cd_demo_sk"],
        "output_must_preserve": ["GROUP BY columns"]
      },
      "gates_checked": ["max_2_chains:WARN"],
      "exploration": true,
      "exploration_hypothesis": "DuckDB technique may transfer: combined dimension filtering before fact join reduces probe rows",
      "confidence": 0.55,
      "expected_explain_delta": "Earlier row reduction in catalog_sales, smaller hash tables",
      "recommended_patch_ops": ["insert_cte", "replace_from"]
    },
    {
      "probe_id": "p06",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Push aggregation to after catalog_sales joins with d1/hd/cd/item. Group by surrogate keys (i_item_sk, w_warehouse_sk, d_date_sk). Preserve counts for later combination.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "item", "date_dim d1"],
        "where_must_preserve": ["i_item_sk = cs_item_sk", "cs_sold_date_sk = d1.d_date_sk"],
        "output_must_preserve": ["no_promo", "promo", "total_cnt semantics"]
      },
      "gates_checked": ["aggregation_equivalence_rules:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Pre-aggregation on surrogate keys may reduce rows before expensive inventory join",
      "confidence": 0.7,
      "expected_explain_delta": "Aggregate node earlier in plan, reduced rows entering inventory join",
      "recommended_patch_ops": ["replace_body", "insert_cte"]
    },
    {
      "probe_id": "p07",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Move all dimension filters (hd, cd, item, d1) into CTE definitions. Ensure filters execute before main joins.",
      "node_contract": {
        "where_must_preserve": [
          "hd_buy_potential = '>10000'", 
          "cd_marital_status = 'S'", 
          "i_category IN ('Men','Shoes','Sports')", 
          "d1.d_year=1999"
        ]
      },
      "gates_checked": ["no_correlated_subquery:PASS"],
      "exploration": true,
      "exploration_hypothesis": "DuckDB technique: early dimension filtering may reduce fact scan despite PG's CTE fences",
      "confidence": 0.5,
      "expected_explain_delta": "Smaller dimension scans, predicate pushdown to indexes",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate"]
    },
    {
      "probe_id": "p08",
      "transform_id": "date_cte_isolate",
      "family": "A",
      "target": "Materialize d1_cte (d_year=1999), d2_cte (unfiltered), d3_cte (unfiltered). Preserve date conditions in main WHERE clause.",
      "node_contract": {
        "from_must_include": ["d1", "d2", "d3"],
        "where_must_preserve": ["d1.d_week_seq = d2.d_week_seq", "d3.d_date > d1.d_date + interval '3 day'"]
      },
      "gates_checked": ["cte_materialization_fence:WARN"],
      "exploration": true,
      "confidence": 0.6,
      "expected_explain_delta": "Materialized CTE scans, potential for hash joins",
      "recommended_patch_ops": ["insert_cte", "replace_from"]
    },
    {
      "probe_id": "p09",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Create CTEs for all dimensions: hd_cte, cd_cte, i_cte, w_cte, p_cte, d1_cte, d2_cte, d3_cte with base filters. Maintain original join relationships.",
      "node_contract": {
        "where_must_preserve": [
          "hd_buy_potential='>10000'", 
          "cd_marital_status='S'", 
          "i_category IN ('Men','Shoes','Sports')", 
          "d1.d_year=1999"
        ]
      },
      "gates_checked": ["no_self_join:PASS"],
      "exploration": true,
      "confidence": 0.55,
      "expected_explain_delta": "Multiple small CTE scans replacing dimension table accesses",
      "recommended_patch_ops": ["insert_cte", "replace_from"]
    },
    {
      "probe_id": "p10",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Combine hd/cd/i dimension filters into single CTE. Join with catalog_sales before other tables. Preserve join conditions.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "household_demographics", "customer_demographics", "item"],
        "where_must_preserve": [
          "cs_bill_hdemo_sk = hd_demo_sk", 
          "cs_bill_cdemo_sk = cd_demo_sk", 
          "i_item_sk = cs_item_sk"
        ]
      },
      "gates_checked": ["no_set_ops:PASS"],
      "exploration": true,
      "confidence": 0.5,
      "expected_explain_delta": "Combined dimension reduction before fact join, smaller intermediate results",
      "recommended_patch_ops": ["insert_cte", "replace_from"]
    },
    {
      "probe_id": "p11",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize filtered fact-dimension join (catalog_sales + d1 + hd + cd) as base_cte. Derive aggregates from single materialization.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim d1"],
        "where_must_preserve": ["cs_sold_date_sk = d1.d_date_sk", "d1.d_year=1999"]
      },
      "gates_checked": ["no_self_join:WARN"],
      "exploration": true,
      "exploration_hypothesis": "PG materialization may help despite no self-join: single scan of expensive join result",
      "confidence": 0.45,
      "expected_explain_delta": "CTE scan replacing repeated joins, reduced computation",
      "recommended_patch_ops": ["insert_cte", "replace_body"]
    },
    {
      "probe_id": "p12",
      "transform_id": "inner_join_conversion",
      "family": "F",
      "target": "Convert promotion LEFT JOIN to INNER JOIN + CTE. WHERE clause functionally makes it inner. Preserve promo count semantics.",
      "node_contract": {
        "from_must_include": ["promotion"],
        "where_must_preserve": ["sum(case when p_promo_sk is null then 1 else 0 end)"]
      },
      "gates_checked": ["left_join_filter_rigidity:PASS"],
      "exploration": true,
      "confidence": 0.7,
      "expected_explain_delta": "Inner join replacing left join, potential for better plan",
      "recommended_patch_ops": ["replace_join_type", "insert_cte"]
    }
  ],
  "dropped": [
    {"transform_id": "or_to_union", "reason": "No OR conditions in query"},
    {"transform_id": "exists_to_in", "reason": "No EXISTS subqueries in query"},
    {"transform_id": "decorrelate", "reason": "No correlated subqueries detected"}
  ]
}