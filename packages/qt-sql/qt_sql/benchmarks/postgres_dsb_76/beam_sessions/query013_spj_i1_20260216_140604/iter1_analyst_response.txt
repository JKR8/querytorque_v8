### Step 1 — Compare EXPLAIN Plans  
**All patches FAILED** - no winners to analyze. Proceeding directly to Step 2.

---

### Step 2 — Design Targets by Combining Strategies  
**Primary Bottleneck**:  
`Nested Loop (rows=168134, time=1782.541)` between `date_dim` and `store_sales` dominates runtime (79% of total). The loop scans `store_sales` 365 times (once per date) due to late filtering of dimension conditions.  

#### Target 1: Combination (A+D)  
**Family**: A + D  
**Transform**: `early_filter_then_or_to_union`  
**Target ID**: `t1`  
**Relevance**: 0.95  
**Hypothesis**: Break OR conditions into UNION ALL branches with pushed-down filters. Early filtering on `customer_demographics`/`household_demographics` reduces input rows to the nested loop. Targets `Nested Loop (rows=168134)` by isolating demographics filters per branch.  
**Target IR**: `S0:73f355482e5a7264` (WHERE clause)  
**Examples**: `pg_date_cte_explicit_join` (A), `pg_intersect_to_exists` (D)  

#### Target 2: Refinement (E)  
**Family**: E  
**Transform**: `dimension_prefetch`  
**Target ID**: `t2`  
**Relevance**: 0.90  
**Hypothesis**: Precompute filtered dimension keys (`household_demographics`, `customer_demographics`, `customer_address`) in CTEs. Reduces rows fed into `Hash Join (rows=18795)` by applying filters before joins.  
**Target IR**: `S0` (main SELECT)  
**Examples**: `multi_dimension_prefetch`  

#### Target 3: Rescue (F)  
**Family**: F  
**Transform**: `explicit_join_materialized`  
**Target ID**: `t3`  
**Relevance**: 0.85  
**Hypothesis**: Fix literal mismatch from prior F-family attempts. Prefilter all dimensions in CTEs (e.g., `date_dim`, `store`) and use explicit joins. Targets `Nested Loop (rows=168134)` by reducing `store_sales` scans via early date/year filtering.  
**Target IR**: `S0` (main SELECT)  
**Examples**: `pg_explicit_join_materialized`  

#### Target 4: Novel (C)  
**Family**: C  
**Transform**: `partial_aggregation_pushdown`  
**Target ID**: `t4`  
**Relevance**: 0.75  
**Hypothesis**: Push MIN(ss_quantity) aggregation into a CTE after filtering `date_dim` and `store_sales` but before joining dimensions. Reduces rows for downstream `Hash Join (rows=18795)`.  
**Target IR**: `S0` (main SELECT)  
**Examples**: `pg_materialized_dimension_fact_prefilter`  

---

### Final JSON Targets  
```json
[
  {
    "family": "A+D",
    "transform": "early_filter_then_or_to_union",
    "target_id": "t1",
    "relevance_score": 0.95,
    "hypothesis": "Break OR conditions into UNION ALL branches with pushed-down demographics filters to reduce input rows to the expensive Nested Loop (168K rows).",
    "target_ir": "S0:73f355482e5a7264",
    "recommended_examples": ["pg_date_cte_explicit_join", "pg_intersect_to_exists"]
  },
  {
    "family": "E",
    "transform": "dimension_prefetch",
    "target_id": "t2",
    "relevance_score": 0.90,
    "hypothesis": "Prefetch filtered keys for household_demographics, customer_demographics, and customer_address in CTEs to shrink input to Hash Join (18K rows).",
    "target_ir": "S0",
    "recommended_examples": ["multi_dimension_prefetch"]
  },
  {
    "family": "F",
    "transform": "explicit_join_materialized",
    "target_id": "t3",
    "relevance_score": 0.85,
    "hypothesis": "Rescue F-family approach: prefilter all dimensions in CTEs with explicit joins and correct literal values. Targets Nested Loop (168K rows) via early date/year filtering.",
    "target_ir": "S0",
    "recommended_examples": ["pg_explicit_join_materialized"]
  },
  {
    "family": "C",
    "transform": "partial_aggregation_pushdown",
    "target_id": "t4",
    "relevance_score": 0.75,
    "hypothesis": "Push MIN(ss_quantity) aggregation after filtering date_dim/store_sales but before joining dimensions to reduce Hash Join (18K rows) input size.",
    "target_ir": "S0",
    "recommended_examples": ["pg_materialized_dimension_fact_prefilter"]
  }
]
```