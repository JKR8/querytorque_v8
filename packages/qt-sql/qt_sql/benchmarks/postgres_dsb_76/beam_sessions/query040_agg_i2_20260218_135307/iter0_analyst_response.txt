{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Primary bottleneck is a comma-join preventing optimal join order, causing a row amplification (est=643, act=15K) at the Nested Loop between date_dim and catalog_sales. Secondary hotspot is a left join to catalog_returns that behaves as an inner join due to a WHERE filter, possibly locking join order. Converting to explicit joins and pre-filtering selective dimensions should reduce input rows early and allow better cost-based reordering.",
    "reasoning_trace": [
      "Nested Loop between date_dim (30 rows) and catalog_sales (497 rows) amplifies to 15172 rows, indicating poor join order due to comma-join rigidity.",
      "Left join to catalog_returns with cr_reason_sk=40 in WHERE clause effectively makes it an inner join, but planner may not reorder it optimally.",
      "Date_dim scan returns 30 rows; item filter (category='Shoes', manager_id between 42 and 81) and catalog_sales filter (wholesale_cost between 68 and 87) are selective but applied late in nested loop.",
      "Plan shows no correlated subqueries, set operations, or repeated scans, pruning families B, D, and E."
    ],
    "cost_spine": ["Seq Scan date_dim", "Index Scan catalog_sales", "Nested Loop (date_dim ↔ catalog_sales)", "Nested Loop (item)", "Nested Loop (catalog_returns)", "Nested Loop (warehouse)", "Sort", "Aggregate"],
    "hotspots": [
      {
        "op": "Nested Loop (date_dim ↔ catalog_sales)",
        "why": "row amplification from 30×497 to 15172 rows due to comma-join rigidity preventing optimal join order",
        "evidence": "est=643 rows, act=15172 rows, time=528ms"
      },
      {
        "op": "Left Join catalog_returns",
        "why": "left join with WHERE filter on right table behaves as inner join but may block join reordering",
        "evidence": "cr_reason_sk=40 filter in WHERE clause, index scan time=0.294ms"
      }
    ],
    "do_not_do": [
      "Avoid OR-to-UNION (PostgreSQL uses BitmapOr for indexed OR)",
      "Avoid materializing EXISTS (PostgreSQL semi-join optimization is effective)",
      "Avoid duplicating large CTE bodies",
      "Do not introduce CTE fences without reuse benefit"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Convert comma-joined tables to explicit INNER JOIN syntax and materialize filtered date_dim as a CTE to create a tiny hash table, enabling better join order flexibility.",
      "dag_target_hint": "Change final_select FROM clause to use explicit JOINs and add a date_filter CTE.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim", "item", "warehouse", "catalog_returns"],
        "where_must_preserve": ["d_date between (cast('2002-02-20' as date) - interval '30 day') and (cast('2002-02-20' as date) + interval '30 day')", "i_category = 'Shoes'", "i_manager_id between 42 and 81", "cs_wholesale_cost between 68 and 87", "cr_reason_sk = 40", "cs_warehouse_sk = w_warehouse_sk", "cs_sold_date_sk = d_date_sk", "i_item_sk = cs_item_sk"],
        "output_must_preserve": ["w_state", "i_item_id", "sales_before", "sales_after", "ORDER BY w_state, i_item_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Comma join replaced with explicit joins; date_dim scan becomes CTE scan; nested loop may switch to hash join with smaller build side.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "rewrite_join_syntax"],
      "rank_rationale": "Directly addresses primary hotspot (comma-join rigidity) with native PostgreSQL transform and strong gold example support.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p02",
      "transform_id": "inner_join_conversion",
      "family": "F",
      "target": "Convert LEFT JOIN catalog_returns to INNER JOIN because cr_reason_sk=40 in WHERE clause null-rejects outer rows, enabling join reorder and potentially better plan.",
      "dag_target_hint": "Change final_select LEFT JOIN to INNER JOIN and move cr_reason_sk=40 to ON clause or keep in WHERE.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "catalog_returns"],
        "where_must_preserve": ["cs_order_number = cr_order_number", "cs_item_sk = cr_item_sk", "cr_reason_sk = 40"],
        "output_must_preserve": ["All original output columns and aggregate logic"]
      },
      "gates_checked": ["no_correlated_subquery:PASS", "semantic_equivalence_check:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.80,
      "expected_explain_delta": "Left join replaced with inner join; planner may reorder join with catalog_returns earlier or choose different join algorithm.",
      "recommended_patch_ops": ["replace_left_join_with_inner", "adjust_predicate_placement"],
      "rank_rationale": "Addresses secondary hotspot (left join rigidity) with clear semantic equivalence and potential join-order improvement.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p03",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Pre-filter date_dim, item, and warehouse into separate CTEs to apply selective predicates before joining to catalog_sales, reducing rows entering the main join.",
      "dag_target_hint": "Add CTEs for filtered date_dim, item, warehouse; join them to catalog_sales in final_select.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim", "item", "warehouse"],
        "where_must_preserve": ["d_date between (cast('2002-02-20' as date) - interval '30 day') and (cast('2002-02-20' as date) + interval '30 day')", "i_category = 'Shoes'", "i_manager_id between 42 and 81", "cs_wholesale_cost between 68 and 87", "cs_warehouse_sk = w_warehouse_sk", "cs_sold_date_sk = d_date_sk", "i_item_sk = cs_item_sk"],
        "output_must_preserve": ["All original output columns and aggregation logic"]
      },
      "gates_checked": ["no_set_operations:PASS", "selective_dimension_filters:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Pre-filtering small dimensions into CTEs may allow planner to start join with smaller row sets, though PostgreSQL may already push filters; exploration tests CTE materialization benefit.",
      "confidence": 0.55,
      "expected_explain_delta": "Dimension scans become CTE scans; nested loop inputs may shrink; potential for hash join with tiny build side.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Exploration targeting early filtering (family A) to test if CTE materialization improves join order despite PostgreSQL's filter pushdown.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p04",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre-filter all selective dimensions (date_dim, item, warehouse) into CTEs and join them with catalog_sales using explicit JOIN syntax, combining early filtering with join-order flexibility.",
      "dag_target_hint": "Create CTEs for filtered date_dim, item, warehouse; rewrite final_select with explicit INNER JOINs between CTEs and catalog_sales.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim", "item", "warehouse"],
        "where_must_preserve": ["d_date between (cast('2002-02-20' as date) - interval '30 day') and (cast('2002-02-20' as date) + interval '30 day')", "i_category = 'Shoes'", "i_manager_id between 42 and 81", "cs_wholesale_cost between 68 and 87", "cs_warehouse_sk = w_warehouse_sk", "cs_sold_date_sk = d_date_sk", "i_item_sk = cs_item_sk"],
        "output_must_preserve": ["All original output columns and aggregation logic"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Combining dimension prefetching with explicit join syntax may outperform date_cte_explicit_join by reducing multiple dimension scans earlier.",
      "confidence": 0.60,
      "expected_explain_delta": "Multiple dimension CTE scans; explicit joins may allow hash joins with small build sides; possible elimination of nested loops.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "rewrite_join_syntax"],
      "rank_rationale": "Exploration combining early filtering (family A) with explicit join conversion (family F) to test multiplicative benefit.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    }
  ],
  "dropped": [
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated subqueries in plan or SQL."
    },
    {
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "reason": "No aggregation before join in plan; aggregate is final operation."
    },
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot; PostgreSQL BitmapOr handles indexed OR."
    },
    {
      "transform_id": "materialize_cte",
      "family": "E",
      "reason": "No repeated scans or subqueries in plan."
    },
    {
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "reason": "Snowflake-specific; not applicable to PostgreSQL runtime dialect."
    },
    {
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "reason": "No self-join pattern in query."
    }
  ]
}