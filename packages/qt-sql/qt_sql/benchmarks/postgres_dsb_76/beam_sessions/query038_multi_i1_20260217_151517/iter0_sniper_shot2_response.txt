[
  {
    "plan_id": "snipe_p1",
    "dialect": "postgres",
    "based_on": "p04,p08",
    "hypothesis": "Original plan shows 3x sequential scans on date_dim and nested loops amplifying work. Precompute filtered dimensions via CTEs to avoid repeated scans and convert comma-joins to explicit JOINs for better optimization. BDA shows workers failed due to testing issues, but EXPLAIN evidence supports COMMA_JOIN_WEAKNESS fix.",
    "target_ir": "Top-level CTEs for filtered_date/filtered_cust, explicit JOINs in all branches",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "WITH filtered_date AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1200 AND 1200 + 11), filtered_cust AS (SELECT c_customer_sk, c_first_name, c_last_name FROM customer WHERE c_birth_month IN (1, 2, 5, 12)) SELECT COUNT(*) FROM (SELECT DISTINCT c_last_name, c_first_name, d_date FROM store_sales JOIN filtered_date ON store_sales.ss_sold_date_sk = filtered_date.d_date_sk JOIN filtered_cust ON store_sales.ss_customer_sk = filtered_cust.c_customer_sk WHERE ss_list_price BETWEEN 193 AND 252 AND ss_wholesale_cost BETWEEN 35 AND 55 INTERSECT SELECT DISTINCT c_last_name, c_first_name, d_date FROM catalog_sales JOIN filtered_date ON catalog_sales.cs_sold_date_sk = filtered_date.d_date_sk JOIN filtered_cust ON catalog_sales.cs_bill_customer_sk = filtered_cust.c_customer_sk WHERE cs_list_price BETWEEN 193 AND 252 AND cs_wholesale_cost BETWEEN 35 AND 55 INTERSECT SELECT DISTINCT c_last_name, c_first_name, d_date FROM web_sales JOIN filtered_date ON web_sales.ws_sold_date_sk = filtered_date.d_date_sk JOIN filtered_cust ON web_sales.ws_bill_customer_sk = filtered_cust.c_customer_sk WHERE ws_list_price BETWEEN 193 AND 252 AND ws_wholesale_cost BETWEEN 35 AND 55) AS hot_cust LIMIT 100;"
        }
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "postgres",
    "based_on": "p07",
    "hypothesis": "Cost spine dominated by 3x distinct sorts. Materialize each channel's distinct set first to avoid repeated work. Pre-aggregation reduces input size before INTERSECT. EXPLAIN shows 115s spent on sorting/uniquing, CTEs isolate this work.",
    "target_ir": "Three materialized CTEs for channel aggregates, INTERSECT on precomputed results",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "WITH store_agg AS (SELECT DISTINCT c_last_name, c_first_name, d_date FROM store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk JOIN customer ON store_sales.ss_customer_sk = customer.c_customer_sk WHERE d_month_seq BETWEEN 1200 AND 1200 + 11 AND c_birth_month IN (1, 2, 5, 12) AND ss_list_price BETWEEN 193 AND 252 AND ss_wholesale_cost BETWEEN 35 AND 55), catalog_agg AS (SELECT DISTINCT c_last_name, c_first_name, d_date FROM catalog_sales JOIN date_dim ON catalog_sales.cs_sold_date_sk = date_dim.d_date_sk JOIN customer ON catalog_sales.cs_bill_customer_sk = customer.c_customer_sk WHERE d_month_seq BETWEEN 1200 AND 1200 + 11 AND c_birth_month IN (1, 2, 5, 12) AND cs_list_price BETWEEN 193 AND 252 AND cs_wholesale_cost BETWEEN 35 AND 55), web_agg AS (SELECT DISTINCT c_last_name, c_first_name, d_date FROM web_sales JOIN date_dim ON web_sales.ws_sold_date_sk = date_dim.d_date_sk JOIN customer ON web_sales.ws_bill_customer_sk = customer.c_customer_sk WHERE d_month_seq BETWEEN 1200 AND 1200 + 11 AND c_birth_month IN (1, 2, 5, 12) AND ws_list_price BETWEEN 193 AND 252 AND ws_wholesale_cost BETWEEN 35 AND 55) SELECT COUNT(*) FROM (SELECT * FROM store_agg INTERSECT SELECT * FROM catalog_agg INTERSECT SELECT * FROM web_agg) AS hot_cust LIMIT 100;"
        }
      }
    ]
  }
]