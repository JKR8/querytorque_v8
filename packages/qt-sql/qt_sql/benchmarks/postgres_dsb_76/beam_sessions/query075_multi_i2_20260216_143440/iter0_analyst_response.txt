```json
[
  {
    "family": "F",
    "transform": "self_join_to_window",
    "target_id": "t1",
    "relevance_score": 0.95,
    "hypothesis": "Self-join on the all_sales CTE forces full materialization and expensive join. Window functions avoid double CTE scan and reduce main query complexity.",
    "target_ir": "S0 [SELECT]\n  CTE: all_sales  (via CTE_Q_S0_all_sales) [unchanged]\n  MAIN QUERY (via Q_S0)\n    FROM: (\n        SELECT d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id, sales_cnt, sales_amt,\n               LAG(sales_cnt) OVER (PARTITION BY i_brand_id, i_class_id, i_category_id, i_manufact_id ORDER BY d_year) AS prev_yr_cnt,\n               LAG(sales_amt) OVER (PARTITION BY i_brand_id, i_class_id, i_category_id, i_manufact_id ORDER BY d_year) AS prev_yr_amt\n        FROM all_sales\n        WHERE d_year IN (1998, 1999)\n    ) t\n    WHERE: prev_yr_cnt > 0 AND (sales_cnt::DECIMAL(17,2)/prev_yr_cnt::DECIMAL(17,2)) < 0.9\n    ORDER BY: (sales_cnt - prev_yr_cnt), (sales_amt - prev_yr_amt)\n    LIMIT 100",
    "recommended_examples": ["pg_explicit_join_materialized"]
  },
  {
    "family": "D",
    "transform": "union_to_union_all",
    "target_id": "t2",
    "relevance_score": 0.85,
    "hypothesis": "UNION forces duplicate elimination before outer aggregation. UNION ALL is safe since final GROUP BY absorbs duplicates.",
    "target_ir": "S0 [SELECT]\n  CTE: all_sales  (via CTE_Q_S0_all_sales)\n    FROM: (subquery) sales_detail\n        [Part1: catalog_sales...]\n        UNION ALL\n        [Part2: store_sales...]\n        UNION ALL\n        [Part3: web_sales...]\n    GROUP BY: d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id",
    "recommended_examples": ["pg_intersect_to_exists"]
  },
  {
    "family": "E",
    "transform": "precompute_filtered_items",
    "target_id": "t3",
    "relevance_score": 0.75,
    "hypothesis": "Repeated scans of item table with same filter. Precomputed CTE avoids redundant work across sales channels.",
    "target_ir": "S0 [SELECT]\n  CTE: filtered_items AS (\n      SELECT i_item_sk, i_brand_id, i_class_id, i_category_id, i_manufact_id\n      FROM item\n      WHERE i_category='Children'\n  )\n  CTE: all_sales  (via CTE_Q_S0_all_sales)\n    FROM: (subquery) sales_detail\n        Part1: ... JOIN filtered_items ON i_item_sk=cs_item_sk ...\n        Part2: ... JOIN filtered_items ON i_item_sk=ss_item_sk ...\n        Part3: ... JOIN filtered_items ON i_item_sk=ws_item_sk ...\n    GROUP BY: ...",
    "recommended_examples": ["multi_dimension_prefetch"]
  },
  {
    "family": "A",
    "transform": "push_returns_filter",
    "target_id": "t4",
    "relevance_score": 0.70,
    "hypothesis": "Returns tables filtered late after large joins. Explicit INNER JOIN + early filter reduces intermediate rows.",
    "target_ir": "S0 [SELECT]\n  CTE: all_sales  (via CTE_Q_S0_all_sales)\n    FROM: (subquery) sales_detail\n        Part1 (catalog): ... JOIN catalog_returns ON (cs_order_number=cr_order_number AND cs_item_sk=cr_item_sk AND cr_reason_sk in (8,18,20,23,41)) ...\n        Part2 (store): ... JOIN store_returns ON (ss_ticket_number=sr_ticket_number AND ss_item_sk=sr_item_sk AND sr_reason_sk in (8,18,20,23,41)) ...\n        Part3 (web): ... JOIN web_returns ON (ws_order_number=wr_order_number AND ws_item_sk=wr_item_sk AND wr_reason_sk in (8,18,20,23,41)) ...\n    GROUP BY: ...",
    "recommended_examples": ["pg_date_cte_explicit_join"]
  }
]
```

## Analysis
**Family A (Early Filtering)**: HIGH  
Returns tables (catalog/store/web_returns) are large and filtered late after joins. Pushing `reason_sk` filters into JOIN conditions reduces intermediate rows.

**Family B (Decorrelation)**: LOW  
No correlated subqueries present. All joins are standard left/inner joins without per-row re-execution.

**Family C (Aggregation Pushdown)**: LOW  
GROUP BY keys (item attributes + year) don't align with join keys (item_sk/date_sk). Pre-aggregation would require per-order granularity.

**Family D (Set Operations)**: HIGH  
UNION forces duplicate elimination before outer aggregation. Changing to UNION ALL avoids unnecessary deduplication.

**Family E (Materialization)**: MEDIUM  
`item` table scanned 3x with identical filter. Precomputed CTE avoids redundant work, though Memoize in plan mitigates impact.

**Family F (Join Transform)**: HIGH  
Self-join on CTE causes full materialization and expensive Nested Loop. Window functions collapse to single scan.

**Chosen families**: F, D, E, A  
**Confidence**: High  
Rationale: Main bottleneck is CTE self-join (Family F) and UNION overhead (Family D). Secondary gains from item reuse (E) and returns filtering (A).