[
  {
    "target_id": "t1",
    "family": "A+B",
    "transform": "early_filter_then_decorrelate",
    "relevance_score": 0.95,
    "hypothesis": "Pre-filter customers (county/demographics/birth month) before decorrelating sales subqueries to reduce the input rows (135,401) to the expensive Nested Loop on store_sales.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_date_cte_explicit_join",
      "pg_shared_scan_decorrelate"
    ]
  },
  {
    "target_id": "t2",
    "family": "F",
    "transform": "explicit_join_materialized",
    "relevance_score": 0.85,
    "hypothesis": "Convert comma joins to explicit INNER JOIN and enforce optimal join order (customer \u2192 address/demographics first) to push county/demographic filters earlier and avoid cross joins.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_explicit_join_materialized"
    ]
  },
  {
    "target_id": "t3",
    "family": "B+E",
    "transform": "decorrelate_without_union",
    "relevance_score": 0.8,
    "hypothesis": "Retain date/item prefetching but replace the UNION in web/catalog sales with two EXISTS clauses to eliminate the costly Unique (573ms) and Sort (573ms) operators.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_shared_scan_decorrelate",
      "multi_dimension_prefetch"
    ]
  },
  {
    "target_id": "t4",
    "family": "C",
    "transform": "demographics_early_aggregate",
    "relevance_score": 0.75,
    "hypothesis": "Aggregate customer demographics before joining with sales to reduce rows fed into subqueries, targeting the expensive Aggregate (1,690 rows, 1,998ms).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter"
    ]
  }
]