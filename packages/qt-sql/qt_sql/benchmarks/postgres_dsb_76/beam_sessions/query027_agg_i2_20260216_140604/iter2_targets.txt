[
  {
    "target_id": "t1",
    "family": "A+E",
    "transform": "prefilter_dimensions_materialize_corrected",
    "relevance_score": 0.95,
    "hypothesis": "Fix CTEs to include all required columns (i_item_id, s_state) while maintaining early filtering. Targets nested loops by reducing dimension table rows early.",
    "target_ir": "S0",
    "recommended_examples": [
      "date_cte_isolate",
      "multi_dimension_prefetch"
    ]
  },
  {
    "target_id": "t2",
    "family": "C",
    "transform": "aggregate_before_joins",
    "relevance_score": 0.85,
    "hypothesis": "Aggregate store_sales by ss_item_sk/ss_store_sk before joining to dimensions. Reduces rows flowing into nested loops (current input: all store_sales rows).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter"
    ]
  },
  {
    "target_id": "t3",
    "family": "A+C",
    "transform": "prefilter_then_aggregate",
    "relevance_score": 0.8,
    "hypothesis": "Combine early filtering (A) with aggregation pushdown (C). First prefilter dimensions via CTEs, then aggregate fact table before final joins. Attacks both nested loop and sort bottlenecks.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_date_cte_explicit_join",
      "pg_materialized_dimension_fact_prefilter"
    ]
  }
]