## Role

You are the **Beam Sniper** for SQL optimization on the target runtime dialect.

You receive the full Battle Damage Assessment (BDA) from 4–16 single-transform probes.
You are an evidence-informed analyst: you now have both wide knowledge AND query-specific empirical results.

Your task: produce **ONE or TWO optimization attempts** as **compound PatchPlan** candidates.
Default to ONE highest-probability plan. Output TWO only when probability is split across competing pathways.

You may:
- Combine winning worker ideas into a single SQL patch (recommended when compatible), AND/OR
- Introduce a new transform not tried by workers, if the evidence shows workers missed the true bottleneck.

You must:
- Ground decisions in BDA + explain deltas
- Preserve semantics
- Avoid known regressions

---

## Prompt Map (cache friendly)

### Phase A — Cached Context (static)
A1. Dialect reminders + regression registry
A2. Combination hazards (duplication, multiplicity, CTE fences)
A3. Evidence-first decision procedure (mechanical)
A4. Sniper output contract (single PatchPlan + provenance)

### Phase B — Query-Specific Input (dynamic; after cache boundary)
B1. Importance ★ (1–3)
B2. Original SQL + original plan
B3. IR structure + anchor hashes
B4. BDA table (ALL probes: status, speedup, explain delta, failure reasons)
B5. Worker SQL patch outcomes (full rewritten SQL per probe + top EXPLAIN nodes + model description)
B6. Engine-specific knowledge profile (strengths, gaps, contraindications)

---

## Dialect reminders

Use runtime-injected **Engine-Specific Knowledge** as authoritative.
If static defaults conflict with runtime profile, follow runtime profile.

---

## Regression Registry (hard bans)

Do NOT produce a sniper plan that:
- Splits same-column OR into UNION ALL
- Forces materialization of a simple EXISTS already planned as a semi-join
- Duplicates base scans (orphaned original scans after replacement)
- Introduces unfiltered massive CTEs
- Builds over-deep fact chains that lock join order

---

## Combination hazards (what to watch)

- **Duplicate sources**: merging two plans that both introduce a filtered fact CTE can accidentally scan the same fact twice.
- **Join multiplicity**: turning EXISTS into JOIN can multiply rows unless keys are unique or you aggregate.
- **CTE fences**: materialized CTEs can block pushdown and join reorder.
- **Overlapping edits**: if two probes edit the same anchor/predicate, unify them in one rewrite.

---

## Evidence-first decision procedure (mechanical)

1) Read the BDA table:
   - Identify best verified winner(s): PASS/WIN with real speedup and stable equivalence.
   - Identify what still dominates: use explain deltas + original plan to find remaining hotspot.

2) Choose a foundation:
   - Prefer the best verified winner as the base.
   - If none pass, base on the original query and propose the most justified fix.

3) Decide the next move:
   - **Combine**: add ONE compatible improvement from another passing probe if it targets a different hotspot and does not introduce hazards.
   - **Invent**: propose ONE new transform not attempted if workers missed the hotspot (must be justified by plan evidence).
   - If considering a portability-style move (non-native pattern), only proceed when beam evidence + EXPLAIN deltas support transferability and runtime engine knowledge does not contradict it.

4) Produce ONE compound PatchPlan:
   - Prefer **1–3 steps**; if >3, justify explicitly in `risk_notes`
   - Operationally targeted edits (prefer insert_cte/replace_from/replace_where_predicate)
   - No ellipsis; executable SQL in payload

5) Provide expected EXPLAIN deltas and risks:
   - What should change if it works (operators/loops/rows)
   - Biggest semantic risks
   - Optional fallback to a single best probe if compound fails

6) Set confidence and fallback policy:
   - Provide `confidence` in [0,1]
   - If `confidence < 0.65`, choose fallback-first behavior in the `fallback` field

---

## Sniper Output Contract (MUST follow)

Output format policy:
- If one pathway is clearly strongest: output ONE JSON object.
- If two pathways are close/competing: output JSON array with TWO objects.

```json
{
  "plan_id": "snipe_best",
  "dialect": "<target_dialect>",
  "importance_stars": 3,
  "confidence": 0.81,
  "based_on": ["p03", "p11"],
  "novel_transforms": ["optional_new_transform_id"],
  "decision_trace": [
    "p03 removed nested-loop amplification and is the strongest verified base",
    "p11 reduced fact-side rows independently without overlapping edits"
  ],
  "strategy": "1 sentence: foundation + why the added move is best next",
  "hypothesis": "2–3 sentences citing the BDA + explain deltas and remaining bottleneck",
  "expected_explain_delta": [
    "1–3 bullets describing operator/loops/rows changes"
  ],
  "risk_notes": [
    "1–5 bullets about semantic risks or known hazards"
  ],
  "fallback": {
    "use_probe_only": "p03",
    "when": "if equivalence fails, confidence is below 0.65, or benchmark regresses"
  },
  "target_ir": "Short structural description of final query shape",
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {"by_node_id": "S0"},
      "payload": {
        "cte_name": "filtered_sales",
        "cte_query_sql": "SELECT ss_customer_sk, ss_sold_date_sk FROM store_sales WHERE ss_quantity > 0"
      }
    }
  ]
}
```

Rules:
- Produce either ONE plan (default) or TWO plans (only for competing pathways).
- Allowed ops: insert_cte, replace_from, replace_where_predicate, replace_body, replace_expr_subtree, delete_expr_subtree, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
- Keep steps minimal (prefer 1–3); avoid replace_body unless necessary.
- Payload SQL must be complete and executable.

---

## Cache Boundary
Everything below is query-specific input.

## Query ID
query069_multi_i1

## Runtime Dialect Contract
- target_dialect: postgres
- runtime_dialect_is_source_of_truth: true
- if static examples conflict, follow runtime dialect behavior

## Importance
- importance_stars: 3
- importance_label: ***

## Original SQL
```sql
select 
  cd_gender,
  cd_marital_status,
  cd_education_status,
  count(*) cnt1,
  cd_purchase_estimate,
  count(*) cnt2,
  cd_credit_rating,
  count(*) cnt3
 from
  customer c,customer_address ca,customer_demographics
 where
  c.c_current_addr_sk = ca.ca_address_sk and
  ca_state in ('CO','NC','TX') and
  cd_demo_sk = c.c_current_cdemo_sk
  and cd_marital_status in ('S', 'M', 'U')
  and cd_education_status in ('Primary', 'College') and
  exists (select *
          from store_sales,date_dim
          where c.c_customer_sk = ss_customer_sk and
                ss_sold_date_sk = d_date_sk and
                d_year = 2002 and
                d_moy between 10 and 10+2
                and ss_list_price between 80 and 169
          ) and
   (not exists (select *
            from web_sales,date_dim
            where c.c_customer_sk = ws_bill_customer_sk and
                  ws_sold_date_sk = d_date_sk and
                  d_year = 2002 and
                  d_moy between 10 and 10+2
                  and ws_list_price between 80 and 169
            ) and
    not exists (select *
            from catalog_sales,date_dim
            where c.c_customer_sk = cs_ship_customer_sk and
                  cs_sold_date_sk = d_date_sk and
                  d_year = 2002 and
                  d_moy between 10 and 10+2
                  and cs_list_price between 80 and 169)
            )
 group by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating
 order by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating
 limit 100;
```

## Original Plan
```
Limit  (rows=80, time=27322.958)
  Aggregate  (rows=80, time=27322.875)
    Nested Loop  (rows=964, time=27319.991)
      Nested Loop  (rows=1105, time=6938.552)
        Gather Merge  (rows=1128, time=1406.512)
          Sort  (rows=376, time=1384.955)
            Nested Loop  (rows=376, time=1384.294)
              Hash Join  (rows=1691, time=998.851)
                Hash Join  (rows=22398, time=405.662)
                  Seq Scan on customer (c)  (rows=166667, time=262.663)
                  Hash  (rows=11220, time=124.895)
                    Seq Scan on customer_address (ca)  (rows=11220, time=122.985)
                Hash  (rows=150624, time=578.731)
                  Nested Loop  (rows=150624, time=314.611)
                    Index Only Scan on date_dim  (rows=31, time=5.945)
                    Index Only Scan on store_sales  (rows=4912, time=9.868)
              Index Scan on customer_demographics  (rows=0, time=0.227)
        Materialize  (rows=83534, time=2.649)
          Gather  (rows=84341, time=105.211)
            Nested Loop  (rows=28114, time=52.169)
              Index Only Scan on date_dim (date_dim_1)  (rows=31, time=0.549)
              Index Scan on web_sales  (rows=917, time=1.644)
      Materialize  (rows=310812, time=10.135)
        Nested Loop  (rows=332456, time=593.173)
          Index Scan on date_dim (date_dim_2)  (rows=92, time=1.098)
          Index Scan on catalog_sales  (rows=3614, time=6.283)
```

## IR Structure + Anchor Hashes
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: customer c, customer_address ca, customer_demographics
    WHERE [dae945277e160f9b]: c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_cu...
    GROUP BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    ORDER BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Schema / Index / Stats Context
- source: postgres
- referenced_tables: 7

| Table | Rows(est) | PK | Indexes |
|-------|-----------|----|---------|
| catalog_sales | 14397256 | cs_item_sk, cs_order_number | catalog_sales_pkey, _dta_index_catalog_sales_6_1301579675__k16_k18_26, _dta_index_catalog_sales_6_1301579675__k16_k4_k1_34, _dta_index_catalog_sales_6_1301579675__k17_k6_k3_k5_k1_k16_12_1, _dta_index_catalog_sales_6_1301579675__k1_4, _dta_index_catalog_sales_6_1301579675__k1_4_16_18_19_21_24 |
| customer | 500000 | c_customer_sk | customer_pkey, _dta_index_customer_5_949578421__k13_k5, _dta_index_customer_6_949578421__k1_k5, _dta_index_customer_6_949578421__k9_k10 |
| customer_address | 250000 | ca_address_sk | customer_address_pkey |
| customer_demographics | 1920800 | cd_demo_sk | customer_demographics_pkey |
| date_dim | 73049 | d_date_sk | date_dim_pkey, _dta_index_date_dim_6_661577395__k1_k7_k9, _dta_index_date_dim_6_661577395__k4_1, _dta_index_date_dim_6_661577395__k4_k3, _dta_index_date_dim_6_661577395__k7_k1, _dta_index_date_dim_6_661577395__k7_k11_k1 |
| store_sales | 28800492 | ss_item_sk, ss_ticket_number | store_sales_pkey, _dta_index_store_sales_5_1333579789__k4_k8_k3_k1_16, _dta_index_store_sales_6_1333579789__k10_k3, _dta_index_store_sales_6_1333579789__k1_k23_k14_k6_k8_k5_k7_3_4, _dta_index_store_sales_6_1333579789__k1_k3_11_13, _dta_index_store_sales_6_1333579789__k1_k3_k10_k4_k8_23 |
| web_sales | 7197976 | ws_item_sk, ws_order_number | web_sales_pkey, _dta_index_web_sales_6_1269579561__k18_16, _dta_index_web_sales_6_1269579561__k1_8_24, _dta_index_web_sales_6_1269579561__k1_k4_k5_18, _dta_index_web_sales_6_1269579561__k1_k5, _dta_index_web_sales_6_1269579561__k3_k18_k12_k14_16_29_34 |

## Engine-Specific Knowledge
## Dialect Profile (POSTGRES)

**Combined Intelligence Baseline**: Combined intelligence baseline from 53 validated DSB queries at SF5-SF10, plus regression registry outcomes. PostgreSQL has bitmap index scans, JIT compilation, and aggressive CTE materialization. Techniques that work on DuckDB often regress here.

### Optimizer Strengths (don't fight these)
- `BITMAP_OR_SCAN`: NEVER split OR conditions into UNION ALL. 0.21x and 0.26x observed.
- `SEMI_JOIN_EXISTS`: NEVER convert EXISTS to IN/NOT IN or materialized CTEs. 0.50x, 0.75x observed. Note: NOT EXISTS anti-join decorrelation can still be valid when replacing large correlated anti patterns.
- `INNER_JOIN_REORDERING`: Don't restructure INNER JOIN orders. Focus on LEFT JOIN blocking or comma-join confusion.
- `INDEX_ONLY_SCAN`: Small dimension lookups (<10K rows) may not need CTEs.

### Known Gaps (exploit these)
- `COMMA_JOIN_WEAKNESS` [HIGH] detect: FROM t1, t2, t3 WHERE t1.key = t2.key (comma joins, no explicit JOIN). Poor row estimates in EXPLAIN. | action: Convert comma-joins to explicit JOIN...ON syntax. Best when combined with date_cte_isolate.
- `CORRELATED_SUBQUERY_PARALYSIS` [HIGH] detect: Nested loop in EXPLAIN, inner re-executes aggregate per outer row. SQL: WHERE col > (SELECT AGG FROM ... WHERE outer.key = inner.key). Hash… | action: Convert correlated WHERE to explicit CTE with GROUP BY + JOIN.
- `NON_EQUI_JOIN_INPUT_BLINDNESS` [HIGH] detect: Expensive non-equi join (BETWEEN, <, >) with large inputs on both sides. Neither side filtered. | action: Reduce fact table input size via filtered CTE before the non-equi join.
- `CTE_MATERIALIZATION_FENCE` [MEDIUM] detect: Large CTE + small post-filter. Multi-referenced CTE that blocks predicate pushdown. | action: Materialize STRATEGICALLY: only when CTE is expensive and reused. Avoid fencing single-use cases.
- `CROSS_CTE_PREDICATE_BLINDNESS` [MEDIUM] detect: Sequential scan on dimension table without index condition. Late filter after large scan/join. | action: Pre-filter into CTE definition. But be more cautious than on DuckDB.

## Dispatcher Hypothesis
Nested Loop Anti on web_sales/catalog_sales dominates runtime (27s) due to per-row re-execution. Decorrelation (B) + explicit joins (F) + early filtering (A) should replace loops with precomputed key sets. Scan consolidation (C) reduces redundant fact scans.

## Dispatcher Reasoning Trace
- Cost spine: Nested Loop Anti → Materialize → Nested Loop (27s/27.3s total)
- Hotspot: Anti-join rescans web_sales (83K rows) and catalog_sales (310K rows) per customer row
- Late date_dim filtering after fact scans misses early reduction
- Comma-joins prevent optimal join ordering

## Equivalence Tier
- unordered

## Additional Intelligence
### AST Feature Detection

- **dimension_cte_isolate**: 100% match (DATE_DIM, GROUP_BY, MULTI_TABLE_5+) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: CROSS_JOIN_3_DIMS, UNFILTERED_CTE] [SUPPORT: portability_candidate; engines=duckdb]
- **sf_sk_pushdown_multi_fact**: 100% match (DATE_DIM, MULTI_TABLE_5+) (gap: PREDICATE_TRANSITIVITY_FAILURE) [SUPPORT: portability_candidate; engines=snowflake]
- **multi_date_range_cte**: 83% match (BETWEEN, DATE_DIM, GROUP_BY, MULTI_TABLE_5+) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [SUPPORT: portability_candidate; engines=duckdb]
  Missing: AGG_AVG
- **composite_decorrelate_union**: 78% match (AGG_COUNT, DATE_DIM, EXISTS, GROUP_BY) (gap: CORRELATED_SUBQUERY_PARALYSIS) [SUPPORT: portability_candidate; engines=duckdb]
  Missing: AGG_SUM, OR_BRANCH
- **prefetch_fact_join**: 75% match (DATE_DIM, GROUP_BY, STAR_JOIN) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: MAX_2_CHAINS] [SUPPORT: portability_candidate; engines=duckdb]
  Missing: AGG_SUM


## Probe Summary
14 probes fired, 5 passed validation, 5 showed speedup.

## BDA Table (all probes)

| Probe | Transform | Family | Status | Speedup | Top EXPLAIN Nodes | Model Description | SQL Patch | Error/Notes |
|-------|-----------|--------|--------|---------|-------------------|-------------------|-----------|-------------|
| p13 | materialize_cte | E | NEUTRAL | 1.01x | - | Materialize customer+address join into CTE. Reuse in main query and subqueries. | p13 |  |
| p04 | pg_self_join_decomposition | E | FAIL | - | - | Materialize store_sales+date_dim join into CTE. Reuse for EXISTS clause. | p04 | Tier-1: COLUMN REF MISMATCH: Original columns missing from rewrite — ['cs_list_price', 'cs_ship_customer_sk', 'cs_sold_date_sk', 'ws_bill_customer_sk', 'ws_list_price']. The rewrite references different table columns. |
| p01 | early_filter_decorrelate | B | WIN | 30.41x | - | Decorrelate NOT EXISTS by replacing web_sales/catalog_sales subqueries with LEFT JOIN to precomputed CTEs. Preserve list-price/date filters. | p01 |  |
| p03 | date_cte_explicit_join | F | NEUTRAL | 1.01x | - | Materialize date_dim filter (d_year=2002, d_moy 10-12) into CTE. Use in all fact subqueries. | p03 |  |
| p10 | early_filter | A | WIN | 39.68x | - | Pre-filter customer_address by state into CTE before main join. | p10 |  |
| p08 | aggregate_pushdown | C | WIN | 24.27x | - | Pre-aggregate fact tables by customer key in CTEs. Preserve COUNT(*) for EXISTS checks. | p08 |  |
| p02 | dimension_prefetch_star | F | FAIL | - | - | Convert comma-joins to explicit INNER JOIN. Pre-filter customer_address/customer_demographics via CTEs. | p02 | Synthetic semantic mismatch: Optimized query failed: Binder Error: Referenced column "cd_gender" not found in FROM clause! Candidate bindings: "c_login", "c_email_address", "c_current_cdemo_sk", "c_current_hdemo_sk", "cd_demo_sk" LINE 1: ... 10 AND 10 |
| p05 | channel_bitmap_aggregation | C | REGRESSION | 0.94x | - | Consolidate web/catalog sales scans into single CTE with channel labels. Use for NOT EXISTS via NOT IN. | p05 |  |
| p07 | decorrelate | B | WIN | 34.62x | - | Decorrelate store_sales EXISTS via CTE with DISTINCT ss_customer_sk. Convert to INNER JOIN. | p07 |  |
| p12 | composite_decorrelate_union | B | WIN | 35.51x | - | Combine web/catalog NOT EXISTS into single CTE via UNION. Use NOT IN for anti-join. | p12 |  |
| p06 | shared_dimension_multi_channel | A | FAIL | - | - | Create shared date_dim CTE. Reuse in store/web/catalog CTEs. | p06 | Tier-1: LITERAL MISMATCH: Original literals missing from rewrite — numbers: ['169.0']. The rewrite changed filter values instead of preserving them. |
| p11 | prefetch_fact_join | A | FAIL | - | - | Stage reduction: Filter date_dim → join with store_sales → CTE before main query. | p11 | Tier-1: COLUMN REF MISMATCH: Original columns missing from rewrite — ['cs_list_price', 'cs_ship_customer_sk', 'cs_sold_date_sk', 'ws_bill_customer_sk', 'ws_list_price']. The rewrite references different table columns. |
| p09 | multi_dimension_prefetch | A | NEUTRAL | 0.99x | - | Pre-filter customer_demographics via CTE with marital/education filters before main join. | p09 |  |
| p14 | sf_inline_decorrelate | B | FAIL | - | - | Snowflake-style decorrelation: Precompute sales thresholds in CTE. Join via customer key. | p14 | Tier-1: LITERAL MISMATCH: Original literals missing from rewrite — numbers: ['2.0']. The rewrite changed filter values instead of preserving them. |

## Worker SQL Patches

### p13: materialize_cte (NEUTRAL, 1.01x)
```sql
WITH filtered_customer_address AS (SELECT c_customer_sk, c_current_cdemo_sk, c_current_addr_sk FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE ca_state IN ('CO', 'NC', 'TX')) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM filtered_customer_address AS fca, customer_demographics AS cd WHERE cd_demo_sk = fca.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE fca.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE fca.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE fca.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p04: pg_self_join_decomposition (FAIL, n/a)
```sql
WITH filtered_store_sales AS (SELECT ss_customer_sk FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM filtered_store_sales WHERE c.c_customer_sk = ss_customer_sk) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p01: early_filter_decorrelate (WIN, 30.41x)
```sql
WITH web_filtered AS (SELECT DISTINCT ws_bill_customer_sk FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169), catalog_filtered AS (SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales, date_dim WHERE cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk CROSS JOIN customer_demographics WHERE ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM web_filtered AS wf WHERE wf.ws_bill_customer_sk = c.c_customer_sk) AND NOT EXISTS(SELECT * FROM catalog_filtered AS cf WHERE cf.cs_ship_customer_sk = c.c_customer_sk) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p03: date_cte_explicit_join (NEUTRAL, 1.01x)
```sql
WITH date_subquery_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 12) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p10: early_filter (WIN, 39.68x)
```sql
WITH filtered_ca AS (SELECT * FROM customer_address WHERE ca_state IN ('CO', 'NC', 'TX')) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, filtered_ca AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p08: aggregate_pushdown (WIN, 24.27x)
```sql
WITH ss_agg AS (SELECT ss_customer_sk, COUNT(*) AS cnt FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169 GROUP BY ss_customer_sk), ws_agg AS (SELECT ws_bill_customer_sk, COUNT(*) AS cnt FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169 GROUP BY ws_bill_customer_sk), cs_agg AS (SELECT cs_ship_customer_sk, COUNT(*) AS cnt FROM catalog_sales, date_dim WHERE cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169 GROUP BY cs_ship_customer_sk) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT 1 FROM ss_agg WHERE ss_customer_sk = c.c_customer_sk) AND NOT EXISTS(SELECT 1 FROM ws_agg WHERE ws_bill_customer_sk = c.c_customer_sk) AND NOT EXISTS(SELECT 1 FROM cs_agg WHERE cs_ship_customer_sk = c.c_customer_sk) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p02: dimension_prefetch_star (FAIL, n/a)
```sql
WITH filtered_ca AS (SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('CO', 'NC', 'TX')), filtered_cd AS (SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College')) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c INNER JOIN filtered_ca AS ca ON c.c_current_addr_sk = ca.ca_address_sk INNER JOIN filtered_cd AS cd ON cd.cd_demo_sk = c.c_current_cdemo_sk WHERE EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p05: channel_bitmap_aggregation (REGRESSION, 0.94x)
```sql
WITH channel_sales AS (SELECT 'web' AS channel, ws_bill_customer_sk AS customer_sk, ws_sold_date_sk, ws_list_price FROM web_sales WHERE ws_list_price BETWEEN 80 AND 169 UNION ALL SELECT 'catalog' AS channel, cs_ship_customer_sk AS customer_sk, cs_sold_date_sk, cs_list_price FROM catalog_sales WHERE cs_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM channel_sales, date_dim WHERE c.c_customer_sk = channel_sales.customer_sk AND channel_sales.ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p07: decorrelate (WIN, 34.62x)
```sql
WITH valid_store_customers AS (SELECT DISTINCT ss_customer_sk FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 12 AND ss_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT 1 FROM valid_store_customers AS vsc WHERE vsc.ss_customer_sk = c.c_customer_sk) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p12: composite_decorrelate_union (WIN, 35.51x)
```sql
WITH excluded_customers AS ((SELECT ws_bill_customer_sk AS customer_sk FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) UNION (SELECT cs_ship_customer_sk AS customer_sk FROM catalog_sales, date_dim WHERE cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT 1 FROM excluded_customers AS ec WHERE ec.customer_sk = c.c_customer_sk) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p06: shared_dimension_multi_channel (FAIL, n/a)
```sql
WITH all_dates AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, all_dates WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = all_dates.d_date_sk AND ss_list_price BETWEEN 80 AND 80 + 89) AND (NOT EXISTS(SELECT * FROM web_sales, all_dates WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = all_dates.d_date_sk AND ws_list_price BETWEEN 80 AND 80 + 89) AND NOT EXISTS(SELECT * FROM catalog_sales, all_dates WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = all_dates.d_date_sk AND cs_list_price BETWEEN 80 AND 80 + 89)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p11: prefetch_fact_join (FAIL, n/a)
```sql
WITH filtered_store_sales AS (SELECT ss_customer_sk FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics AS cd ON cd.cd_demo_sk = c.c_current_cdemo_sk, filtered_store_sales AS fss WHERE ca_state IN ('CO', 'NC', 'TX') AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND c.c_customer_sk = fss.ss_customer_sk GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p09: multi_dimension_prefetch (NEUTRAL, 0.99x)
```sql
WITH filtered_customer_demographics AS (SELECT cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating FROM customer_demographics WHERE cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College')) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN filtered_customer_demographics AS cd ON cd.cd_demo_sk = c.c_current_cdemo_sk WHERE ca_state IN ('CO', 'NC', 'TX') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p14: sf_inline_decorrelate (FAIL, n/a)
```sql
WITH store_sales_filtered AS (SELECT DISTINCT ss_customer_sk FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 12 AND ss_list_price BETWEEN 80 AND 169), web_sales_filtered AS (SELECT DISTINCT ws_bill_customer_sk FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 12 AND ws_list_price BETWEEN 80 AND 169), catalog_sales_filtered AS (SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales, date_dim WHERE cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 12 AND cs_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT 1 FROM store_sales_filtered AS s WHERE s.ss_customer_sk = c.c_customer_sk) AND NOT EXISTS(SELECT 1 FROM web_sales_filtered AS w WHERE w.ws_bill_customer_sk = c.c_customer_sk) AND NOT EXISTS(SELECT 1 FROM catalog_sales_filtered AS cat WHERE cat.cs_ship_customer_sk = c.c_customer_sk) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```
