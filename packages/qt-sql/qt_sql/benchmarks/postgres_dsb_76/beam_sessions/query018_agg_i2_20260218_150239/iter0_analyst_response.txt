{  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The plan shows a series of nested loops with a large row flow (45K rows) from the date_dim–catalog_sales join, but the fact table scan (catalog_sales) is filtered only after joining with date_dim. Comma‑join syntax may prevent optimal join reordering and early predicate pushdown. Converting to explicit joins and pre‑filtering selective dimensions can reduce the fact‑table scan volume before the dominant join work.",
    "reasoning_trace": [
      "Nested Loop between date_dim (122 rows) and catalog_sales (371 rows) produces 45K rows before other filters apply.",
      "Plan uses comma‑join syntax with all predicates in WHERE; PostgreSQL’s optimizer may not reorder joins effectively in this form.",
      "All dimension tables (item, customer, customer_demographics, customer_address) are scanned via index but appear late in the join chain.",
      "Aggregate operates on a single row after joins, but the large intermediate row flow suggests early reduction could help."
    ],
    "cost_spine": ["Nested Loop (date_dim–catalog_sales)", "Nested Loop (item)", "Nested Loop (customer)", "Nested Loop (customer_demographics)", "Nested Loop (customer_address)", "Aggregate", "Sort", "Limit"],
    "hotspots": [
      {
        "op": "Nested Loop (date_dim–catalog_sales)",
        "why": "largest row amplification (45K rows) and time (1643 ms) before selective dimension filters",
        "evidence": "rows=45193 time=1643.125 ms"
      },
      {
        "op": "Aggregate",
        "why": "operates after all joins; early aggregation could reduce join input",
        "evidence": "rows_in=1 (post‑join) time=3855.346 ms"
      }
    ],
    "do_not_do": [
      "avoid OR‑to‑UNION split (PostgreSQL uses BitmapOr for indexed OR)",
      "avoid materializing EXISTS paths (plan shows no correlated subqueries)",
      "avoid duplicating large CTE bodies",
      "do not push non‑equi join transforms (no non‑equi join in query)"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Convert comma joins to explicit INNER JOIN syntax and isolate date_dim filter (d_year=1999) into a CTE to create a tiny hash table for the fact‑table probe.",
      "dag_target_hint": "Replace final_select FROM clause with explicit JOINs and add date_cte as a pre‑filtered dimension source.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim", "item", "customer", "customer_demographics", "customer_address"],
        "where_must_preserve": ["d_year=1999", "cd_gender='F'", "cd_education_status='4 yr Degree'", "c_birth_month=12", "ca_state IN ('AR','IN','VA')", "cs_wholesale_cost BETWEEN 5 AND 10", "i_category='Music'"],
        "output_must_preserve": ["all original output columns, GROUP BY ROLLUP, ORDER BY, LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.82,
      "expected_explain_delta": "Comma joins become explicit hash joins; date_dim scan reduces to 122 rows and is materialized once; fact‑table scan may prune partitions earlier.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Targets primary hotspot — comma‑join weakness and large fact‑table scan; gold example shows 2.28x speedup.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p02",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre‑filter all selective dimensions (date_dim, customer_demographics, customer, customer_address, item) into separate CTEs, then join them with catalog_sales using explicit JOIN syntax.",
      "dag_target_hint": "Replace final_select FROM clause with a chain of explicit joins on pre‑filtered CTEs.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim", "item", "customer", "customer_demographics", "customer_address"],
        "where_must_preserve": ["d_year=1999", "cd_gender='F'", "cd_education_status='4 yr Degree'", "c_birth_month=12", "ca_state IN ('AR','IN','VA')", "cs_wholesale_cost BETWEEN 5 AND 10", "i_category='Music'"],
        "output_must_preserve": ["all original output columns, GROUP BY ROLLUP, ORDER BY, LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.78,
      "expected_explain_delta": "Each dimension CTE becomes a tiny hash table; fact‑table scan sees compounded selectivity; nested loops may convert to hash joins.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Addresses primary hotspot with a stronger multi‑dimension prefetch; gold example shows 3.32x speedup.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p03",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Push selective dimension filters (date_dim, customer_demographics, customer, customer_address, item) into CTEs and join them with catalog_sales using explicit JOINs, preserving the original WHERE predicates.",
      "dag_target_hint": "Replace final_select FROM clause with explicit joins on pre‑filtered CTEs; keep all original filters.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim", "item", "customer", "customer_demographics", "customer_address"],
        "where_must_preserve": ["d_year=1999", "cd_gender='F'", "cd_education_status='4 yr Degree'", "c_birth_month=12", "ca_state IN ('AR','IN','VA')", "cs_wholesale_cost BETWEEN 5 AND 10", "i_category='Music'"],
        "output_must_preserve": ["all original output columns, GROUP BY ROLLUP, ORDER BY, LIMIT 100"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:WARN", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Portability candidate from DuckDB; may still benefit PostgreSQL by forcing early filter application and explicit join syntax.",
      "confidence": 0.55,
      "expected_explain_delta": "Dimension scans become CTE materializations; fact‑table scan rows drop due to earlier compound selectivity.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Exploration — tests early‑filtering family (A) which is underrepresented; uses portability candidate with plausible mechanism.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p04",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre‑aggregate catalog_sales by cs_item_sk and cs_bill_customer_sk (join keys) before joining with dimensions, then compute the final ROLLUP on dimension columns.",
      "dag_target_hint": "Insert a CTE that aggregates catalog_sales by the two join keys; modify final_select to join this CTE with dimensions and then apply the ROLLUP.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "item", "customer", "customer_address"],
        "where_must_preserve": ["d_year=1999", "cd_gender='F'", "cd_education_status='4 yr Degree'", "c_birth_month=12", "ca_state IN ('AR','IN','VA')", "cs_wholesale_cost BETWEEN 5 AND 10", "i_category='Music'"],
        "output_must_preserve": ["all original output columns, GROUP BY ROLLUP semantics, ORDER BY, LIMIT 100"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:AVG", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Aggregate pushdown may reduce rows entering the multi‑way join, but group‑by keys are from dimensions, requiring careful key compatibility.",
      "confidence": 0.48,
      "expected_explain_delta": "Aggregate node moves earlier; join input rows reduce from millions to thousands; final ROLLUP operates on pre‑aggregated set.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_group_by"],
      "rank_rationale": "Exploration — tests aggregation family (C) on a secondary hotspot; portability candidate with moderate risk.",
      "recommended_examples": [],
      "gold_example_id": ""
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan; PostgreSQL uses BitmapOr for indexed OR, and guard G_PG_OR_INDEX_PROTECTED blocks this transform."
    },
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated subqueries in the query; plan shows no nested loops from correlation."
    },
    {
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "reason": "Query has no self‑join pattern; transform requires repeated scans of the same table with different filters."
    },
    {
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "reason": "No non‑equi join in the query; transform targets NON_EQUI_JOIN_INPUT_BLINDNESS gap."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT or set‑operation in the query."
    }
  ]
}