[
  {
    "target_id": "t1",
    "family": "C+A",
    "transform": "preagg_store_returns_early_dates",
    "relevance_score": 0.97,
    "hypothesis": "Pre-aggregate store_returns by (sr_customer_sk, sr_item_sk, sr_ticket_number) before joining to store_sales/catalog_sales. Combine with CTE-based date filters to reduce input rows to the expensive nested loop (originally 329K rows).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter",
      "pg_date_cte_explicit_join"
    ]
  },
  {
    "target_id": "t2",
    "family": "C",
    "transform": "preagg_store_returns_and_catalog_sales",
    "relevance_score": 0.9,
    "hypothesis": "Pre-aggregate store_returns AND catalog_sales independently before joining. This minimizes row counts earlier in the plan (especially for the 329K-row nested loop) while preserving MAX() semantics.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter"
    ]
  },
  {
    "target_id": "t3",
    "family": "E+F",
    "transform": "prefetch_with_forced_join_order",
    "relevance_score": 0.85,
    "hypothesis": "Fix t2_rescue's regression by: (1) Keeping date CTEs, (2) Enforcing join order: date_dim \u2192 store_sales \u2192 store_returns \u2192 catalog_sales, (3) Using explicit JOIN syntax. Targets the original 329K-row nested loop by ensuring index scans drive joins.",
    "target_ir": "S0",
    "recommended_examples": [
      "multi_dimension_prefetch",
      "pg_explicit_join_materialized"
    ]
  },
  {
    "target_id": "t4",
    "family": "A",
    "transform": "early_filter_store_sales_join",
    "relevance_score": 0.8,
    "hypothesis": "Push date filters into CTEs and force store_sales to join before store_returns. Reduces input to the expensive nested loop by leveraging d1's high selectivity (rows=10 in original plan) earlier.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_date_cte_explicit_join"
    ]
  }
]