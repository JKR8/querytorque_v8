## Analysis of Optimization Families

**Family A (Early Filtering)**: MEDIUM  
The query applies dimension table filters (date_dim, customer_address, web_site) after joins. Pushing these filters into dedicated CTEs could reduce join cardinality early. However, dimension tables are small (date_dim=30 rows, web_site=22 rows), so gains may be limited.

**Family B (Decorrelation)**: HIGH  
The correlated EXISTS subquery forces a nested loop (1185 iterations) over web_sales. This is the primary bottleneck. Decorrelation via precomputed sets eliminates per-row re-execution.

**Family C (Aggregation Pushdown)**: LOW  
No aggregations exist before the final SELECT. The single-row result can't benefit from early aggregation.

**Family D (Set Operations)**: LOW  
No INTERSECT/UNION operations are present. The EXISTS/NOT EXISTS patterns are already handled as semi/anti joins.

**Family E (Materialization)**: MEDIUM  
The same web_sales scan is reused in the EXISTS subquery. Materializing filtered web_sales rows could benefit both main and decorrelated CTEs, but web_sales size may limit gains.

**Family F (Join Transform)**: MEDIUM  
Implicit comma joins could be converted to explicit INNER JOINs for better predicate pushdown. Join order (web_sales → date_dim → customer_address) is already optimal.

**Chosen families**: [B, E, F]  
**Confidence**: High (B), Medium (E/F)  
Primary bottleneck is correlated subquery (Family B). Secondary opportunities: materialize filtered web_sales (Family E) and explicit joins (Family F).

---

## Optimization Targets

```json
[
  {
    "family": "B",
    "transform": "decorrelate_exists",
    "target_id": "t1",
    "relevance_score": 0.98,
    "hypothesis": "Correlated EXISTS subquery forces nested loop over web_sales (1185 iterations). Precomputing multi-warehouse orders as a set eliminates per-row rescans.",
    "target_ir": "S0 [SELECT]\n  CTE: multi_warehouse_orders  (via Q1)\n    FROM: web_sales\n    GROUP BY: ws_order_number\n    HAVING: COUNT(DISTINCT ws_warehouse_sk) > 1\n  MAIN QUERY (via Q0)\n    FROM: web_sales ws1\n      INNER JOIN date_dim ON ws1.ws_ship_date_sk = d_date_sk\n      INNER JOIN customer_address ON ws1.ws_ship_addr_sk = ca_address_sk\n      INNER JOIN web_site ON ws1.ws_web_site_sk = web_site_sk\n      INNER JOIN multi_warehouse_orders m ON ws1.ws_order_number = m.ws_order_number\n    WHERE: d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY'\n      AND ca_state IN ('MO','MT','OK','SC','TX','WI')\n      AND web_gmt_offset >= -5\n      AND ws1.ws_list_price BETWEEN 253 AND 282\n      AND NOT EXISTS (SELECT * FROM web_returns wr1 WHERE ws1.ws_order_number = wr1.wr_order_number AND wr1.wr_reason_sk IN (8,18,20,23,41))\n    ORDER BY: COUNT(DISTINCT ws_order_number)",
    "recommended_examples": ["pg_shared_scan_decorrelate"]
  },
  {
    "family": "E",
    "transform": "prefilter_materialize",
    "target_id": "t2",
    "relevance_score": 0.65,
    "hypothesis": "Repeated web_sales scans (main query + decorrelation CTE) can share a materialized prefiltered version. Date/list_price filters reduce base dataset.",
    "target_ir": "S0 [SELECT]\n  CTE: prefiltered_sales  (via Q1)\n    FROM: web_sales\n      INNER JOIN date_dim ON ws_ship_date_sk = d_date_sk\n    WHERE: d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY'\n      AND ws_list_price BETWEEN 253 AND 282\n  CTE: multi_warehouse_orders  (via Q2)\n    FROM: prefiltered_sales\n    GROUP BY: ws_order_number\n    HAVING: COUNT(DISTINCT ws_warehouse_sk) > 1\n  MAIN QUERY (via Q0)\n    FROM: prefiltered_sales ws1\n      INNER JOIN customer_address ON ws1.ws_ship_addr_sk = ca_address_sk\n      INNER JOIN web_site ON ws1.ws_web_site_sk = web_site_sk\n      INNER JOIN multi_warehouse_orders m ON ws1.ws_order_number = m.ws_order_number\n    WHERE: ca_state IN ('MO','MT','OK','SC','TX','WI')\n      AND web_gmt_offset >= -5\n      AND NOT EXISTS (SELECT * FROM web_returns wr1 WHERE ws1.ws_order_number = wr1.wr_order_number AND wr1.wr_reason_sk IN (8,18,20,23,41))\n    ORDER BY: COUNT(DISTINCT ws_order_number)",
    "recommended_examples": ["multi_dimension_prefetch"]
  },
  {
    "family": "F",
    "transform": "explicit_join_syntax",
    "target_id": "t3",
    "relevance_score": 0.5,
    "hypothesis": "Implicit comma joins hinder predicate pushdown clarity. Explicit INNER JOIN syntax improves optimizer control.",
    "target_ir": "S0 [SELECT]\n  MAIN QUERY (via Q0)\n    FROM: web_sales ws1\n      INNER JOIN date_dim ON ws1.ws_ship_date_sk = d_date_sk\n      INNER JOIN customer_address ON ws1.ws_ship_addr_sk = ca_address_sk\n      INNER JOIN web_site ON ws1.ws_web_site_sk = web_site_sk\n    WHERE: d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY'\n      AND ca_state IN ('MO','MT','OK','SC','TX','WI')\n      AND web_gmt_offset >= -5\n      AND ws1.ws_list_price BETWEEN 253 AND 282\n      AND EXISTS (SELECT * FROM web_sales ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)\n      AND NOT EXISTS (SELECT * FROM web_returns wr1 WHERE ws1.ws_order_number = wr1.wr_order_number AND wr1.wr_reason_sk IN (8,18,20,23,41))\n    ORDER BY: COUNT(DISTINCT ws_order_number)",
    "recommended_examples": ["pg_explicit_join_materialized"]
  }
]
```