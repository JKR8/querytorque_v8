[
  {
    "plan_id": "snipe_p1",
    "dialect": "postgres",
    "confidence": 0.85,
    "based_on": "p01+p02",
    "strategy": "Combine decorrelation with explicit join syntax",
    "hypothesis": "BDA shows all decorrelation attempts failed validation, but engine knowledge confirms correlated subquery paralysis is the primary bottleneck. Combine p01's decorrelation with p02's explicit JOIN syntax to avoid comma-join weakness. Expected EXPLAIN delta: Replace nested loop with hash join on threshold CTE, reduce row estimates in join planning.",
    "target_ir": "Materialized threshold CTE + explicit JOINs + preserved OR condition",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "item_threshold",
          "cte_query_sql": "SELECT cs_item_sk, 1.3 * AVG(cs_ext_discount_amt) AS threshold FROM catalog_sales JOIN date_dim ON cs_sold_date_sk = d_date_sk WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01 GROUP BY cs_item_sk"
        }
      },
      {
        "step_id": "s2",
        "op": "replace_from",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "catalog_sales JOIN item ON i_item_sk = cs_item_sk JOIN date_dim ON d_date_sk = cs_sold_date_sk JOIN item_threshold ON catalog_sales.cs_item_sk = item_threshold.cs_item_sk"
        }
      },
      {
        "step_id": "s3",
        "op": "replace_where_predicate",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "(i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND cs_ext_discount_amt > item_threshold.threshold"
        }
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "postgres",
    "confidence": 0.7,
    "based_on": "p05+p10",
    "strategy": "Shared scan decomposition with OR preservation",
    "hypothesis": "p05 failed due to literal mismatch but shared scan pattern avoids subquery re-execution. Preserve OR condition instead of splitting (per PostgreSQL BITMAP_OR_SCAN strength). Expected EXPLAIN delta: Single fact scan for main/subquery logic, bitmap OR on item filters.",
    "target_ir": "Shared sales CTE + preserved OR condition + explicit threshold join",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "sales_base",
          "cte_query_sql": "SELECT cs_item_sk, cs_sold_date_sk, cs_ext_discount_amt FROM catalog_sales JOIN date_dim ON cs_sold_date_sk = d_date_sk WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY'"
        }
      },
      {
        "step_id": "s2",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "SELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\" FROM sales_base sb JOIN item i ON sb.cs_item_sk = i.i_item_sk WHERE (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND cs_ext_discount_amt > (SELECT 1.3 * AVG(cs_ext_discount_amt) FROM sales_base sb2 WHERE sb2.cs_item_sk = i.i_item_sk AND cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01) ORDER BY SUM(cs_ext_discount_amt) LIMIT 100"
        }
      }
    ]
  }
]