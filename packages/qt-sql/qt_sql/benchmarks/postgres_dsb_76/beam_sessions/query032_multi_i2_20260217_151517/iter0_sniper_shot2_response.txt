[
  {
    "plan_id": "snipe_p1",
    "dialect": "postgres",
    "based_on": "p01,p02",
    "strategy": "Decorrelation via materialized CTE + explicit JOINs",
    "hypothesis": "Original query suffers from correlated subquery re-execution per row (nested loop). Precomputing threshold per item via CTE avoids re-execution. Explicit JOINs improve planner estimates.",
    "target_ir": "Main query with two CTEs (date_range, item_threshold) and explicit JOINs replacing comma joins",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "date_range",
          "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY'"
        }
      },
      {
        "step_id": "s2",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "item_threshold",
          "cte_query_sql": "SELECT cs_item_sk, 1.3 * AVG(cs_ext_discount_amt) AS threshold FROM catalog_sales JOIN date_range ON cs_sold_date_sk = d_date_sk WHERE cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01 GROUP BY cs_item_sk"
        }
      },
      {
        "step_id": "s3",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "SELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\" FROM catalog_sales JOIN item ON cs_item_sk = i_item_sk JOIN date_range ON cs_sold_date_sk = d_date_sk JOIN item_threshold ON catalog_sales.cs_item_sk = item_threshold.cs_item_sk WHERE (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND cs_ext_discount_amt > threshold ORDER BY SUM(cs_ext_discount_amt) LIMIT 100"
        }
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "postgres",
    "based_on": "p03,p07",
    "strategy": "Dimension prefetch + threshold decorrelation",
    "hypothesis": "Prefiltering dimensions reduces join cardinality early. Computing threshold against prefiltered items avoids processing irrelevant rows in subquery.",
    "target_ir": "Main query with three CTEs (filtered_item, date_range, item_threshold) joining prefiltered dimensions",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "filtered_item",
          "cte_query_sql": "SELECT i_item_sk FROM item WHERE i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71"
        }
      },
      {
        "step_id": "s2",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "date_range",
          "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY'"
        }
      },
      {
        "step_id": "s3",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "item_threshold",
          "cte_query_sql": "SELECT cs.cs_item_sk, 1.3 * AVG(cs_ext_discount_amt) AS threshold FROM catalog_sales cs JOIN date_range dr ON cs_sold_date_sk = dr.d_date_sk JOIN filtered_item fi ON cs_item_sk = fi.i_item_sk WHERE cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01 GROUP BY cs.cs_item_sk"
        }
      },
      {
        "step_id": "s4",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "SELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\" FROM catalog_sales cs JOIN filtered_item fi ON cs.cs_item_sk = fi.i_item_sk JOIN date_range dr ON cs.cs_sold_date_sk = dr.d_date_sk JOIN item_threshold it ON cs.cs_item_sk = it.cs_item_sk WHERE cs_ext_discount_amt > threshold ORDER BY SUM(cs_ext_discount_amt) LIMIT 100"
        }
      }
    ]
  }
]