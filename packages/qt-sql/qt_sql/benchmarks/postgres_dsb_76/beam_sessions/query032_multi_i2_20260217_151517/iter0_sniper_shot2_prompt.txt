## Role

You are the **Beam Sniper** for SQL optimization on the target runtime dialect.

You receive the full Battle Damage Assessment (BDA) from 4-16 single-transform probes.
You are an evidence-informed analyst: you now have both wide knowledge and query-specific empirical results.

Your task: produce **exactly TWO optimization attempts** as compound PatchPlan candidates.

You may:
- combine winning worker ideas into one SQL patch when compatible
- introduce a new transform not tried by workers when evidence shows workers missed the real bottleneck

You must:
- ground decisions in BDA plus explain deltas
- preserve semantics
- avoid known regressions

---

## Prompt Map (cache friendly)

### Phase A - Cached Context (static)
A1. Dialect reminders plus regression registry
A2. Combination hazards (duplication, multiplicity, CTE fences)
A3. Evidence-first decision procedure (mechanical)
A4. Sniper output contract (strict JSON array)

### Phase B - Query-Specific Input (dynamic; after cache boundary)
B1. Importance star rating (1-3)
B2. Original SQL plus original plan
B3. IR structure plus anchor hashes
B4. BDA table (ALL probes: status, speedup, explain delta, failure reasons)
B5. Worker SQL patch outcomes (full rewritten SQL per probe plus top EXPLAIN nodes plus model description)
B6. Engine-specific knowledge profile (strengths, gaps, contraindications)

---

## Dialect reminders

Use runtime-injected **Engine-Specific Knowledge** as authoritative.
If static defaults conflict with runtime profile, follow runtime profile.

---

## Regression Registry (hard bans)

Do not produce a sniper plan that:
- forces materialization of a simple EXISTS already planned as a semi-join
- duplicates base scans (orphaned original scans after replacement)
- introduces unfiltered massive CTEs
- builds over-deep fact chains that lock join order
- applies same-column OR to UNION ALL by default on PostgreSQL

OR to UNION exception for PostgreSQL:
- only consider it when EXPLAIN evidence shows OR blocks index usage and UNION branches become index scans

---

## Combination hazards (what to watch)

- **Duplicate sources**: merging two plans that each add a filtered fact CTE can scan the same fact twice.
- **Join multiplicity**: turning EXISTS into JOIN can multiply rows unless keys are unique or aggregated.
- **CTE fences**: materialized CTEs can block pushdown and join reorder.
- **Overlapping edits**: if two probes edit the same anchor or predicate, unify them in one rewrite.

---

## Evidence-first decision procedure (mechanical)

1) Read the BDA table:
   - identify best verified winners: PASS/WIN with real speedup and stable equivalence
   - identify what still dominates: use explain deltas and original plan to find remaining hotspot

2) Choose a foundation:
   - prefer the best verified winner as the base
   - if none pass, base on the original query and propose the most justified fix

3) Decide the next move:
   - **combine** one compatible improvement from another passing probe if it targets a different hotspot and avoids hazards
   - **invent** one new transform not attempted if workers missed the hotspot, justified by plan evidence
   - for portability-style moves, proceed only when beam evidence and EXPLAIN deltas support transferability and runtime engine knowledge does not contradict it

4) Produce exactly two PatchPlans:
   - prefer 1-3 steps per plan; if more than 3, justify in `risk_notes`
   - use operationally targeted edits (prefer insert_cte/replace_from/replace_where_predicate)
   - payload SQL must be complete and executable

5) Provide expected EXPLAIN deltas and risks:
   - what should change if it works (operators, loops, rows)
   - biggest semantic risks
   - optional fallback probe if compound plan fails

---

## Sniper Output Contract (MUST follow)

Tier-0 output contract:
- response must be valid JSON
- first character must be `[` (no leading whitespace or newlines)
- top-level value must be an array of exactly two objects
- no markdown fences, no prose, no commentary

Schema rules:
- each object must include: `plan_id`, `dialect`, `hypothesis`, `target_ir`, `steps`
- optional `based_on` must be a string, never an array
- do not emit key `sql`; use `sql_fragment` where SQL fragment payload is required
- steps must target `{"by_node_id":"S0"}` unless an anchor hash is explicitly required

Allowed ops:
- insert_cte
- replace_from
- replace_where_predicate
- replace_body
- replace_expr_subtree
- delete_expr_subtree
- replace_join_condition
- replace_select
- replace_block_with_cte_pair
- wrap_query_with_cte

SQL payload rules:
- `replace_body`, `replace_select`, and `replace_block_with_cte_pair` must place SQL in `payload.sql_fragment`
- payload SQL must be complete and executable

Output JSON shape:
[
  {
    "plan_id": "snipe_p1",
    "dialect": "<target_dialect>",
    "confidence": 0.81,
    "based_on": "p03,p11",
    "strategy": "Foundation plus one compatible add-on",
    "hypothesis": "Plan evidence and expected win mechanism",
    "target_ir": "Short structural description of final query shape",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {"sql_fragment": "SELECT c_customer_sk FROM customer"}
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "<target_dialect>",
    "confidence": 0.73,
    "based_on": "p07",
    "strategy": "Alternative independent pathway",
    "hypothesis": "Plan evidence for second pathway",
    "target_ir": "Alternative structural description",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "filtered_sales",
          "cte_query_sql": "SELECT ss_customer_sk FROM store_sales WHERE ss_quantity > 0"
        }
      }
    ]
  }
]

---

## Cache Boundary
Everything below is query-specific input.

## Query ID
query032_multi_i2

## Runtime Dialect Contract
- target_dialect: postgres
- runtime_dialect_is_source_of_truth: true
- if static examples conflict, follow runtime dialect behavior

## Importance
- importance_stars: 2
- importance_label: **

## Original SQL
```sql
select  sum(cs_ext_discount_amt)  as "excess discount amount"
from
   catalog_sales
   ,item
   ,date_dim
where
(i_manufact_id in (184, 307, 365, 560, 681)
or i_manager_id BETWEEN 42 and 71)
and i_item_sk = cs_item_sk
and d_date between '2001-02-23' and
        cast('2001-02-23' as date) + interval '90 day'
and d_date_sk = cs_sold_date_sk
and cs_ext_discount_amt
     > (
         select
            1.3 * avg(cs_ext_discount_amt)
         from
            catalog_sales
           ,date_dim
         where
              cs_item_sk = i_item_sk
          and d_date between '2001-02-23' and
                             cast('2001-02-23' as date) + interval '90 day'
          and d_date_sk = cs_sold_date_sk
          and cs_list_price between 115 and 144
          and cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01
      )
order by sum(cs_ext_discount_amt)
limit 100;
```

## Original Plan
```
Unknown  (rows=?, time=?)
```

## IR Structure + Anchor Hashes
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: catalog_sales, item, date_dim
    WHERE [46ed3cc4a4ef22ce]: (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND i_item_sk = cs...
    ORDER BY: SUM(cs_ext_discount_amt)

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Schema / Index / Stats Context
- source: postgres
- referenced_tables: 3

| Table | Rows(est) | PK | Indexes |
|-------|-----------|----|---------|
| catalog_sales | 14397255 | cs_item_sk, cs_order_number | catalog_sales_pkey, _dta_index_catalog_sales_6_1301579675__k1_k16_k5_k4_3_6_18_19_2, _dta_index_catalog_sales_6_1301579675__k17_k6_k3_k5_k1_k16_12_1, _dta_index_catalog_sales_6_1301579675__k1_4_16_18_19_21_24, _dta_index_catalog_sales_6_1301579675__k3_k12_k14_k15_16_18, _dta_index_catalog_sales_6_1301579675__k1_k16_k4_18_34 |
| date_dim | 73049 | d_date_sk | date_dim_pkey, _dta_index_date_dim_6_661577395__k7_k4_k9_k1, _dta_index_date_dim_6_661577395__k7_k9_k1, _dta_index_date_dim_6_661577395__k1_k7_k9, _dta_index_date_dim_6_661577395__k7_k11_k1, _dta_index_date_dim_6_661577395__k9_k7_k1 |
| item | 102000 | i_item_sk | item_pkey, _dta_index_item_6_853578079__k1_2_5, _dta_index_item_6_853578079__k13_k11_k1, _dta_index_item_6_853578079__k18, _dta_index_item_6_853578079__k2_k1 |

## Engine-Specific Knowledge
## Dialect Profile (POSTGRES)

**Combined Intelligence Baseline**: Combined intelligence baseline from 53 validated DSB queries at SF5-SF10, plus regression registry outcomes. PostgreSQL has bitmap index scans, JIT compilation, and aggressive CTE materialization. Techniques that work on DuckDB often regress here.

### Optimizer Strengths (don't fight these)
- `BITMAP_OR_SCAN`: Avoid splitting OR conditions into UNION ALL by default. Only consider OR→UNION when EXPLAIN shows OR blocks index usage and UNION branches become index scans. 0.21x and 0.26x reg…
- `SEMI_JOIN_EXISTS`: NEVER convert EXISTS to IN/NOT IN or materialized CTEs. 0.50x, 0.75x observed. Note: NOT EXISTS anti-join decorrelation can still be valid when replacing large correlated anti patterns.
- `INNER_JOIN_REORDERING`: Don't restructure INNER JOIN orders. Focus on LEFT JOIN blocking or comma-join confusion.
- `INDEX_ONLY_SCAN`: Small dimension lookups (<10K rows) may not need CTEs.

### Known Gaps (exploit these)
- `COMMA_JOIN_WEAKNESS` [HIGH] detect: FROM t1, t2, t3 WHERE t1.key = t2.key (comma joins, no explicit JOIN). Poor row estimates in EXPLAIN. | action: Convert comma-joins to explicit JOIN...ON syntax. Best when combined with date_cte_isolate.
- `CORRELATED_SUBQUERY_PARALYSIS` [HIGH] detect: Nested loop in EXPLAIN, inner re-executes aggregate per outer row. SQL: WHERE col > (SELECT AGG FROM ... WHERE outer.key = inner.key). Hash… | action: Convert correlated WHERE to explicit CTE with GROUP BY + JOIN.
- `NON_EQUI_JOIN_INPUT_BLINDNESS` [HIGH] detect: Expensive non-equi join (BETWEEN, <, >) with large inputs on both sides. Neither side filtered. | action: Reduce fact table input size via filtered CTE before the non-equi join.
- `CTE_MATERIALIZATION_FENCE` [MEDIUM] detect: Large CTE + small post-filter. Multi-referenced CTE that blocks predicate pushdown. | action: Materialize STRATEGICALLY: only when CTE is expensive and reused. Avoid fencing single-use cases.
- `CROSS_CTE_PREDICATE_BLINDNESS` [MEDIUM] detect: Sequential scan on dimension table without index condition. Late filter after large scan/join. | action: Pre-filter into CTE definition. But be more cautious than on DuckDB.

## Dispatcher Hypothesis
Dominant bottleneck is correlated subquery re-execution per row causing nested loop amplification. Secondary hotspots include comma-join planning weakness and late selectivity on item filters. Family B (Decorrelation) and F (Join Topology) should reduce row amplification and improve join planning.

## Dispatcher Reasoning Trace
- Correlated subquery in WHERE clause re-executes per outer row (evidence: scalar aggregate with outer reference cs_item_sk)
- Comma-join syntax prevents optimal join ordering (evidence: FROM t1,t2,t3 pattern)
- OR condition on different columns (i_manufact_id/i_manager_id) may prevent index usage

## Equivalence Tier
- unordered

## Additional Intelligence
### AST Feature Detection

- **inline_decorrelate_materialized**: 100% match (AGG_AVG, AGG_SUM, BETWEEN, DATE_DIM) (gap: CORRELATED_SUBQUERY_PARALYSIS)  [SUPPORT: native_or_universal]
- **sf_inline_decorrelate**: 100% match (AGG_AVG, CORRELATED_SUB, DATE_DIM, SCALAR_AGG_SUB) (gap: CORRELATED_SUBQUERY_PARALYSIS) [SUPPORT: portability_candidate; engines=snowflake]
- **pg_self_join_decomposition**: 80% match (AGG_AVG, AGG_SUM, BETWEEN, DATE_DIM) (gap: CROSS_CTE_PREDICATE_BLINDNESS)  [SUPPORT: native_or_universal]
  Missing: GROUP_BY
- **or_to_union**: 75% match (AGG_SUM, DATE_DIM, OR_BRANCH) (gap: CROSS_COLUMN_OR_DECOMPOSITION) [CAUTION: MAX_3_BRANCHES, SAME_COL_OR] [SUPPORT: portability_candidate; engines=duckdb]
  Missing: GROUP_BY
- **decorrelate**: 67% match (AGG_AVG, AGG_SUM, CORRELATED_SUB, DATE_DIM) (gap: CORRELATED_SUBQUERY_PARALYSIS) [CAUTION: MISSING_FILTER, ALREADY_DECORRELATED] [SUPPORT: portability_candidate; engines=duckdb]
  Missing: CTE, GROUP_BY


## Probe Summary
10 probes fired, 0 passed validation, 0 showed speedup.

## BDA Table (all probes)

| Probe | Transform | Family | Status | Speedup | Top EXPLAIN Nodes | Model Description | SQL Patch | Error/Notes |
|-------|-----------|--------|--------|---------|-------------------|-------------------|-----------|-------------|
| p02 | date_cte_explicit_join | F | ERROR | - | - | 1) Create date_range CTE with d_date_sk WHERE d_date BETWEEN... 2) Replace comma joins with explicit JOIN syntax | p02 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p03 | dimension_prefetch_star | F | ERROR | - | - | Create prefiltered CTEs for both dimensions: 1) date_range CTE 2) filtered_item CTE (i_manufact_id/i_manager_id filters) before joining with catalog_sales | p03 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p08 | prefetch_fact_join | A | ERROR | - | - | Staged CTE chain: 1) date_range 2) prefiltered_item 3) fact_prejoin (cs joins date_range) before main logic | p08 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p07 | multi_dimension_prefetch | A | ERROR | - | - | Prefilter both dimensions into CTEs before any fact joins (DuckDB pattern adapted for PG) | p07 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p05 | pg_self_join_decomposition | E | FAIL | - | - | Create shared sales_base CTE with cs_item_sk, cs_sold_date_sk, cs_ext_discount_amt for both main query and subquery logic | p05 | Tier-1: LITERAL MISMATCH: Original literals missing from rewrite — numbers: ['1.3']. The rewrite changed filter values instead of preserving them. |
| p06 | or_to_union | D | FAIL | - | - | Split item OR condition into UNION ALL branches: 1) i_manufact_id IN (...) 2) i_manager_id BETWEEN... | - | Failed to parse/apply PatchPlan |
| p04 | early_filter_decorrelate | B | ERROR | - | - | Combine p01+p03: 1) Prefilter both dimensions into CTEs 2) Compute decorrelated threshold from prefiltered data | p04 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p01 | inline_decorrelate_materialized | B | ERROR | - | - | Replace correlated subquery with MATERIALIZED CTEs: 1) date_range CTE for date filters 2) item_threshold CTE computing 1.3*avg(cs_ext_discount_amt) per i_item_sk 3) JOIN threshold CTE in main WHERE | p01 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p10 | self_join_decomposition | F | ERROR | - | - | Split OR condition by creating separate item CTEs: 1) by_manufact 2) by_manager then UNION before join | p10 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p09 | sf_shared_scan_decorrelate | B | ERROR | - | - | Snowflake pattern: 1) shared_sales CTE with date join 2) threshold CTE from shared_sales 3) main query uses shared_sales | p09 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |

## Worker SQL Patches

### p02: date_cte_explicit_join (ERROR, n/a)
```sql
WITH date_range AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY') SELECT SUM(cs_ext_discount_amt) AS "excess discount amount" FROM catalog_sales AS cs JOIN item AS i ON i.i_item_sk = cs.cs_item_sk JOIN date_range AS d ON d.d_date_sk = cs.cs_sold_date_sk WHERE (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND i_item_sk = cs_item_sk AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND d_date_sk = cs_sold_date_sk AND cs_ext_discount_amt > (SELECT 1.3 * AVG(cs_ext_discount_amt) FROM catalog_sales, date_dim WHERE cs_item_sk = i_item_sk AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND d_date_sk = cs_sold_date_sk AND cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01) ORDER BY SUM(cs_ext_discount_amt) LIMIT 100;
```

### p03: dimension_prefetch_star (ERROR, n/a)
```sql
WITH filtered_item AS (SELECT i_item_sk FROM item WHERE i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71), date_range AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY') SELECT SUM(cs_ext_discount_amt) AS "excess discount amount" FROM catalog_sales AS cs JOIN filtered_item AS fi ON cs.cs_item_sk = fi.i_item_sk JOIN date_range AS dr ON cs.cs_sold_date_sk = dr.d_date_sk WHERE (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND i_item_sk = cs_item_sk AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND d_date_sk = cs_sold_date_sk AND cs_ext_discount_amt > (SELECT 1.3 * AVG(cs_ext_discount_amt) FROM catalog_sales, date_dim WHERE cs_item_sk = i_item_sk AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND d_date_sk = cs_sold_date_sk AND cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01) ORDER BY SUM(cs_ext_discount_amt) LIMIT 100;
```

### p08: prefetch_fact_join (ERROR, n/a)
```sql
WITH sale_dates AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY'), filtered_catalog_sales AS (SELECT * FROM catalog_sales JOIN sale_dates ON d_date_sk = cs_sold_date_sk) SELECT SUM(cs_ext_discount_amt) AS "excess discount amount" FROM filtered_catalog_sales, item, date_dim WHERE (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND i_item_sk = cs_item_sk AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND d_date_sk = cs_sold_date_sk AND cs_ext_discount_amt > (SELECT 1.3 * AVG(cs_ext_discount_amt) FROM catalog_sales, date_dim WHERE cs_item_sk = i_item_sk AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND d_date_sk = cs_sold_date_sk AND cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01) ORDER BY SUM(cs_ext_discount_amt) LIMIT 100;
```

### p07: multi_dimension_prefetch (ERROR, n/a)
```sql
WITH prefiltered_item AS (SELECT i_item_sk FROM item WHERE i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71), prefiltered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY') SELECT SUM(cs_ext_discount_amt) AS "excess discount amount" FROM catalog_sales AS cs JOIN prefiltered_item AS pi ON cs.cs_item_sk = pi.i_item_sk JOIN prefiltered_dates AS pd ON cs.cs_sold_date_sk = pd.d_date_sk WHERE cs.cs_ext_discount_amt > (SELECT 1.3 * AVG(cs2.cs_ext_discount_amt) FROM catalog_sales AS cs2, date_dim AS dd WHERE cs2.cs_item_sk = pi.i_item_sk AND dd.d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND dd.d_date_sk = cs2.cs_sold_date_sk AND cs2.cs_list_price BETWEEN 115 AND 144 AND cs2.cs_sales_price / cs2.cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01) ORDER BY SUM(cs_ext_discount_amt) LIMIT 100;
```

### p05: pg_self_join_decomposition (FAIL, n/a)
```sql
WITH sales_base AS (SELECT cs_item_sk, cs_sold_date_sk, cs_ext_discount_amt FROM catalog_sales WHERE cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01) SELECT SUM(cs_ext_discount_amt) AS "excess discount amount" FROM sales_base AS sb JOIN item AS i ON sb.cs_item_sk = i.i_item_sk JOIN date_dim AS d ON sb.cs_sold_date_sk = d.d_date_sk WHERE (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' ORDER BY SUM(cs_ext_discount_amt) LIMIT 100;
```

### p04: early_filter_decorrelate (ERROR, n/a)
```sql
WITH threshold_cte AS (SELECT 1.3 * AVG(cs_ext_discount_amt) AS threshold FROM catalog_sales AS cs JOIN date_dim AS d ON d.d_date_sk = cs.cs_sold_date_sk WHERE d.d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND cs.cs_list_price BETWEEN 115 AND 144 AND cs.cs_sales_price / cs.cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01), filtered_item AS (SELECT i_item_sk FROM item WHERE i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71), date_range AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY') SELECT SUM(cs_ext_discount_amt) AS "excess discount amount" FROM catalog_sales AS cs JOIN filtered_item AS fi ON cs.cs_item_sk = fi.i_item_sk JOIN date_range AS dr ON cs.cs_sold_date_sk = dr.d_date_sk JOIN threshold_cte AS t ON cs.cs_ext_discount_amt > t.threshold WHERE TRUE ORDER BY SUM(cs_ext_discount_amt) LIMIT 100;
```

### p01: inline_decorrelate_materialized (ERROR, n/a)
```sql
WITH date_range AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY'), item_threshold AS (SELECT cs_item_sk, 1.3 * AVG(cs_ext_discount_amt) AS threshold FROM catalog_sales AS cs JOIN date_range AS dr ON cs.cs_sold_date_sk = dr.d_date_sk WHERE cs.cs_list_price BETWEEN 115 AND 144 AND cs.cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01 GROUP BY cs_item_sk) SELECT SUM(cs_ext_discount_amt) AS "excess discount amount" FROM catalog_sales AS cs JOIN item AS i ON cs.cs_item_sk = i.i_item_sk JOIN date_range AS dr ON cs.cs_sold_date_sk = dr.d_date_sk JOIN item_threshold AS it ON cs.cs_item_sk = it.cs_item_sk WHERE (i.i_manufact_id IN (184, 307, 365, 560, 681) OR i.i_manager_id BETWEEN 42 AND 71) AND cs.cs_ext_discount_amt > it.threshold ORDER BY SUM(cs_ext_discount_amt) LIMIT 100;
```

### p10: self_join_decomposition (ERROR, n/a)
```sql
WITH item_by_manufact AS (SELECT i_item_sk FROM item WHERE i_manufact_id IN (184, 307, 365, 560, 681)), item_by_manager AS (SELECT i_item_sk FROM item WHERE i_manager_id BETWEEN 42 AND 71) SELECT SUM(cs_ext_discount_amt) AS "excess discount amount" FROM catalog_sales JOIN (SELECT i_item_sk FROM item_by_manufact UNION SELECT i_item_sk FROM item_by_manager) AS i ON i.i_item_sk = cs_item_sk JOIN date_dim ON d_date_sk = cs_sold_date_sk WHERE (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71) AND i_item_sk = cs_item_sk AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND d_date_sk = cs_sold_date_sk AND cs_ext_discount_amt > (SELECT 1.3 * AVG(cs_ext_discount_amt) FROM catalog_sales, date_dim WHERE cs_item_sk = i_item_sk AND d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND d_date_sk = cs_sold_date_sk AND cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01) ORDER BY SUM(cs_ext_discount_amt) LIMIT 100;
```

### p09: sf_shared_scan_decorrelate (ERROR, n/a)
```sql
WITH shared_sales AS (SELECT cs_item_sk, cs_ext_discount_amt FROM catalog_sales JOIN date_dim ON d_date_sk = cs_sold_date_sk WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY' AND cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 21 * 0.01 AND 41 * 0.01), threshold AS (SELECT cs_item_sk, 1.3 * AVG(cs_ext_discount_amt) AS threshold_value FROM shared_sales GROUP BY cs_item_sk) SELECT SUM(cs_ext_discount_amt) AS "excess discount amount" FROM catalog_sales AS cs JOIN item AS i ON i.i_item_sk = cs.cs_item_sk JOIN date_dim AS dd ON dd.d_date_sk = cs.cs_sold_date_sk JOIN threshold AS t ON t.cs_item_sk = cs.cs_item_sk WHERE (i.i_manufact_id IN (184, 307, 365, 560, 681) OR i.i_manager_id BETWEEN 42 AND 71) AND cs.cs_ext_discount_amt > t.threshold_value ORDER BY SUM(cs_ext_discount_amt) LIMIT 100;
```


## Shot 1 Results

| # | Family | Transform | Speedup | Status | Error |
|---|--------|-----------|---------|--------|-------|
| snipe_p1 | ? | unknown | - | FAIL | Step s2 failed: replace_from requires from_sql |
| snipe_p2 | ? | unknown | - | ERROR | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |

### snipe_p1 Error:
Step s2 failed: replace_from requires from_sql

### snipe_p2 Error:
Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context'

## Shot 2 — Design 2 More Patch Plans

Build on shot 1 results:
1. Your first plan should refine or extend the best winner (or fix its remaining bottleneck)
2. Your second should try a different approach not yet attempted

If all shot 1 plans failed, diagnose why and try fundamentally different strategies.

Output exactly **2 patch plans** as a JSON array.

Tier-0 Output Contract (hard fail):
- response must be valid JSON
- first character must be `[` (no leading whitespace/newlines)
- top-level value must be an array of exactly 2 objects
- no markdown fences, prose, or commentary
- never emit key `sql`; use `sql_fragment` for SQL fragments

Required per plan:
- `plan_id`, `family`, `transform`, `hypothesis`, `target_ir`, `dialect`, `steps`
- optional: `based_on` as a string (use comma-separated IDs for multiple sources; never an array)
- `steps[]` item: `step_id`, `op`, `target`, optional `payload`
- `target.by_node_id` MUST be `"S0"` (use `by_anchor_hash` only when needed)

Allowed `op` values:
- `insert_cte`
- `replace_from`
- `replace_where_predicate`
- `replace_body`
- `replace_expr_subtree`
- `delete_expr_subtree`
- `replace_join_condition`
- `replace_select`
- `replace_block_with_cte_pair`
- `wrap_query_with_cte`

Semantic guards (MUST preserve):
- all WHERE/HAVING/ON logic
- all literals exactly
- columns/aliases/ORDER BY/LIMIT
- row count and semantics
- no orphaned CTEs or duplicated source scans after replacement

Rules:
- output exactly 2 plans
- each plan must use a different strategy (`family` + `transform`)
- payload SQL fragments must be complete/executable (no ellipsis)
- `replace_body`, `replace_select`, and `replace_block_with_cte_pair` must put SQL in `payload.sql_fragment`
- cite EXPLAIN evidence in `hypothesis`

Output ONLY JSON array.