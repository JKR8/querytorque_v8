[
  {
    "target_id": "t1",
    "family": "E+F",
    "transform": "prefetch_dates_fixed_join",
    "relevance_score": 0.95,
    "hypothesis": "Fix ambiguous column in prefetched date CTEs and use explicit joins to reduce Gather Merge (66K rows) and Sort (33K rows) costs by enabling better join order and eliminating repeated date scans.",
    "target_ir": "S0",
    "recommended_examples": [
      "multi_dimension_prefetch",
      "pg_explicit_join_materialized"
    ]
  },
  {
    "target_id": "t2",
    "family": "C+E",
    "transform": "agg_store_sk_prefetch",
    "relevance_score": 0.9,
    "hypothesis": "Prefetch date pairs and pre-aggregate facts by ss_store_sk before joining to store. Targets 34K-row Nested Loop (2045 ms) by minimizing rows before dimension joins.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter",
      "multi_dimension_prefetch"
    ]
  },
  {
    "target_id": "t3",
    "family": "A+F",
    "transform": "early_date_join_explicit",
    "relevance_score": 0.85,
    "hypothesis": "Force early d1-d2 join with explicit INNER JOIN and pushed date filters. Targets late-applied d1 filter in top-level Nested Loop (0-time in plan but likely misestimated).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_date_cte_explicit_join",
      "pg_explicit_join_materialized"
    ]
  },
  {
    "target_id": "t4",
    "family": "C",
    "transform": "partial_agg_store_key",
    "relevance_score": 0.8,
    "hypothesis": "Pre-aggregate facts by ss_store_sk before store join to reduce 52K-row Aggregate input. Uses store key as proxy for store attributes to avoid early bloating.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter"
    ]
  }
]