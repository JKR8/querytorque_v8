[
  {
    "target_id": "S0",
    "family": "A+C",
    "transform": "early_filter_agg_pushdown",
    "relevance_score": 0.95,
    "hypothesis": "Push date filters into CTE (A) and pre-aggregate sales/returns by store key + date buckets (C) before joining to store. Reduces Gather Merge input from 66K to ~72 rows.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_date_cte_explicit_join",
      "pg_materialized_dimension_fact_prefilter"
    ]
  },
  {
    "target_id": "S0",
    "family": "E",
    "transform": "prefetch_dates",
    "relevance_score": 0.9,
    "hypothesis": "Materialize d2_dates (16 rows) and reuse for d1 bounds. Avoids repeated date_dim scans and reduces input to Nested Loop (46K rows).",
    "target_ir": "S0",
    "recommended_examples": [
      "multi_dimension_prefetch"
    ]
  },
  {
    "target_id": "S0",
    "family": "F",
    "transform": "explicit_join_no_materialize",
    "relevance_score": 0.85,
    "hypothesis": "Convert to explicit joins without CTE materialization. Preserves parallel execution (Gather Merge) and avoids t1's 52K-row sort.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_explicit_join_materialized"
    ]
  },
  {
    "target_id": "S0",
    "family": "C",
    "transform": "agg_store_key",
    "relevance_score": 0.8,
    "hypothesis": "Aggregate by store key + date buckets before joining to store. Cuts Gather Merge input from 66K to 72 rows (stores).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter"
    ]
  }
]