## Role

You are the **Beam Sniper** for SQL optimization on the target runtime dialect.

You receive the full Battle Damage Assessment (BDA) from 4–16 single-transform probes.
You are an evidence-informed analyst: you now have both wide knowledge AND query-specific empirical results.

Your task: produce **ONE or TWO optimization attempts** as **compound PatchPlan** candidates.
Default to ONE highest-probability plan. Output TWO only when probability is split across competing pathways.

You may:
- Combine winning worker ideas into a single SQL patch (recommended when compatible), AND/OR
- Introduce a new transform not tried by workers, if the evidence shows workers missed the true bottleneck.

You must:
- Ground decisions in BDA + explain deltas
- Preserve semantics
- Avoid known regressions

---

## Prompt Map (cache friendly)

### Phase A — Cached Context (static)
A1. Dialect reminders + regression registry
A2. Combination hazards (duplication, multiplicity, CTE fences)
A3. Evidence-first decision procedure (mechanical)
A4. Sniper output contract (single PatchPlan + provenance)

### Phase B — Query-Specific Input (dynamic; after cache boundary)
B1. Importance ★ (1–3)
B2. Original SQL + original plan
B3. IR structure + anchor hashes
B4. BDA table (ALL probes: status, speedup, explain delta, failure reasons)
B5. Worker SQL patch outcomes (full rewritten SQL per probe + top EXPLAIN nodes + model description)
B6. Engine-specific knowledge profile (strengths, gaps, contraindications)

---

## Dialect reminders

Use runtime-injected **Engine-Specific Knowledge** as authoritative.
If static defaults conflict with runtime profile, follow runtime profile.

---

## Regression Registry (hard bans)

Do NOT produce a sniper plan that:
- Splits same-column OR into UNION ALL
- Forces materialization of a simple EXISTS already planned as a semi-join
- Duplicates base scans (orphaned original scans after replacement)
- Introduces unfiltered massive CTEs
- Builds over-deep fact chains that lock join order

---

## Combination hazards (what to watch)

- **Duplicate sources**: merging two plans that both introduce a filtered fact CTE can accidentally scan the same fact twice.
- **Join multiplicity**: turning EXISTS into JOIN can multiply rows unless keys are unique or you aggregate.
- **CTE fences**: materialized CTEs can block pushdown and join reorder.
- **Overlapping edits**: if two probes edit the same anchor/predicate, unify them in one rewrite.

---

## Evidence-first decision procedure (mechanical)

1) Read the BDA table:
   - Identify best verified winner(s): PASS/WIN with real speedup and stable equivalence.
   - Identify what still dominates: use explain deltas + original plan to find remaining hotspot.

2) Choose a foundation:
   - Prefer the best verified winner as the base.
   - If none pass, base on the original query and propose the most justified fix.

3) Decide the next move:
   - **Combine**: add ONE compatible improvement from another passing probe if it targets a different hotspot and does not introduce hazards.
   - **Invent**: propose ONE new transform not attempted if workers missed the hotspot (must be justified by plan evidence).
   - If considering a portability-style move (non-native pattern), only proceed when beam evidence + EXPLAIN deltas support transferability and runtime engine knowledge does not contradict it.

4) Produce ONE compound PatchPlan:
   - Prefer **1–3 steps**; if >3, justify explicitly in `risk_notes`
   - Operationally targeted edits (prefer insert_cte/replace_from/replace_where_predicate)
   - No ellipsis; executable SQL in payload

5) Provide expected EXPLAIN deltas and risks:
   - What should change if it works (operators/loops/rows)
   - Biggest semantic risks
   - Optional fallback to a single best probe if compound fails

6) Set confidence and fallback policy:
   - Provide `confidence` in [0,1]
   - If `confidence < 0.65`, choose fallback-first behavior in the `fallback` field

---

## Sniper Output Contract (MUST follow)

Output format policy:
- If one pathway is clearly strongest: output ONE JSON object.
- If two pathways are close/competing: output JSON array with TWO objects.

```json
{
  "plan_id": "snipe_best",
  "dialect": "<target_dialect>",
  "importance_stars": 3,
  "confidence": 0.81,
  "based_on": ["p03", "p11"],
  "novel_transforms": ["optional_new_transform_id"],
  "decision_trace": [
    "p03 removed nested-loop amplification and is the strongest verified base",
    "p11 reduced fact-side rows independently without overlapping edits"
  ],
  "strategy": "1 sentence: foundation + why the added move is best next",
  "hypothesis": "2–3 sentences citing the BDA + explain deltas and remaining bottleneck",
  "expected_explain_delta": [
    "1–3 bullets describing operator/loops/rows changes"
  ],
  "risk_notes": [
    "1–5 bullets about semantic risks or known hazards"
  ],
  "fallback": {
    "use_probe_only": "p03",
    "when": "if equivalence fails, confidence is below 0.65, or benchmark regresses"
  },
  "target_ir": "Short structural description of final query shape",
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {"by_node_id": "S0"},
      "payload": {
        "cte_name": "filtered_sales",
        "cte_query_sql": "SELECT ss_customer_sk, ss_sold_date_sk FROM store_sales WHERE ss_quantity > 0"
      }
    }
  ]
}
```

Rules:
- Produce either ONE plan (default) or TWO plans (only for competing pathways).
- Allowed ops: insert_cte, replace_from, replace_where_predicate, replace_body, replace_expr_subtree, delete_expr_subtree, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
- Keep steps minimal (prefer 1–3); avoid replace_body unless necessary.
- Payload SQL must be complete and executable.

---

## Cache Boundary
Everything below is query-specific input.

## Query ID
query069_multi_i1

## Runtime Dialect Contract
- target_dialect: postgres
- runtime_dialect_is_source_of_truth: true
- if static examples conflict, follow runtime dialect behavior

## Importance
- importance_stars: 3
- importance_label: ***

## Original SQL
```sql
select 
  cd_gender,
  cd_marital_status,
  cd_education_status,
  count(*) cnt1,
  cd_purchase_estimate,
  count(*) cnt2,
  cd_credit_rating,
  count(*) cnt3
 from
  customer c,customer_address ca,customer_demographics
 where
  c.c_current_addr_sk = ca.ca_address_sk and
  ca_state in ('CO','NC','TX') and
  cd_demo_sk = c.c_current_cdemo_sk
  and cd_marital_status in ('S', 'M', 'U')
  and cd_education_status in ('Primary', 'College') and
  exists (select *
          from store_sales,date_dim
          where c.c_customer_sk = ss_customer_sk and
                ss_sold_date_sk = d_date_sk and
                d_year = 2002 and
                d_moy between 10 and 10+2
                and ss_list_price between 80 and 169
          ) and
   (not exists (select *
            from web_sales,date_dim
            where c.c_customer_sk = ws_bill_customer_sk and
                  ws_sold_date_sk = d_date_sk and
                  d_year = 2002 and
                  d_moy between 10 and 10+2
                  and ws_list_price between 80 and 169
            ) and
    not exists (select *
            from catalog_sales,date_dim
            where c.c_customer_sk = cs_ship_customer_sk and
                  cs_sold_date_sk = d_date_sk and
                  d_year = 2002 and
                  d_moy between 10 and 10+2
                  and cs_list_price between 80 and 169)
            )
 group by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating
 order by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating
 limit 100;
```

## Original Plan
```
Limit  (rows=80, time=25653.146)
  Aggregate  (rows=80, time=25653.062)
    Nested Loop  (rows=964, time=25649.498)
      Nested Loop  (rows=1105, time=5733.329)
        Gather Merge  (rows=1128, time=247.326)
          Sort  (rows=376, time=231.325)
            Nested Loop  (rows=376, time=230.867)
              Hash Join  (rows=1691, time=221.158)
                Hash Join  (rows=22398, time=34.91)
                  Seq Scan on customer (c)  (rows=166667, time=12.221)
                  Hash  (rows=11220, time=10.524)
                    Seq Scan on customer_address (ca)  (rows=11220, time=9.478)
                Hash  (rows=150624, time=173.551)
                  Nested Loop  (rows=150624, time=70.017)
                    Index Only Scan on date_dim  (rows=31, time=0.523)
                    Index Only Scan on store_sales  (rows=4912, time=2.078)
              Index Scan on customer_demographics  (rows=0, time=0.006)
        Materialize  (rows=83518, time=2.6)
          Gather  (rows=84341, time=43.207)
            Nested Loop  (rows=28114, time=19.003)
              Index Only Scan on date_dim (date_dim_1)  (rows=31, time=0.412)
              Index Scan on web_sales  (rows=917, time=0.569)
      Materialize  (rows=310812, time=9.689)
        Nested Loop  (rows=332456, time=197.405)
          Index Scan on date_dim (date_dim_2)  (rows=92, time=0.071)
          Index Scan on catalog_sales  (rows=3614, time=2.003)
```

## IR Structure + Anchor Hashes
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: customer c, customer_address ca, customer_demographics
    WHERE [dae945277e160f9b]: c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_cu...
    GROUP BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    ORDER BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Schema / Index / Stats Context
- source: postgres
- referenced_tables: 7

| Table | Rows(est) | PK | Indexes |
|-------|-----------|----|---------|
| catalog_sales | 14397256 | cs_item_sk, cs_order_number | catalog_sales_pkey, _dta_index_catalog_sales_6_1301579675__k16_k18_26, _dta_index_catalog_sales_6_1301579675__k16_k4_k1_34, _dta_index_catalog_sales_6_1301579675__k17_k6_k3_k5_k1_k16_12_1, _dta_index_catalog_sales_6_1301579675__k1_4, _dta_index_catalog_sales_6_1301579675__k1_4_16_18_19_21_24 |
| customer | 500000 | c_customer_sk | customer_pkey, _dta_index_customer_5_949578421__k13_k5, _dta_index_customer_6_949578421__k1_k5, _dta_index_customer_6_949578421__k9_k10 |
| customer_address | 250000 | ca_address_sk | customer_address_pkey |
| customer_demographics | 1920800 | cd_demo_sk | customer_demographics_pkey |
| date_dim | 73049 | d_date_sk | date_dim_pkey, _dta_index_date_dim_6_661577395__k1_k7_k9, _dta_index_date_dim_6_661577395__k4_1, _dta_index_date_dim_6_661577395__k4_k3, _dta_index_date_dim_6_661577395__k7_k1, _dta_index_date_dim_6_661577395__k7_k11_k1 |
| store_sales | 28800492 | ss_item_sk, ss_ticket_number | store_sales_pkey, _dta_index_store_sales_5_1333579789__k4_k8_k3_k1_16, _dta_index_store_sales_6_1333579789__k10_k3, _dta_index_store_sales_6_1333579789__k1_k23_k14_k6_k8_k5_k7_3_4, _dta_index_store_sales_6_1333579789__k1_k3_11_13, _dta_index_store_sales_6_1333579789__k1_k3_k10_k4_k8_23 |
| web_sales | 7197976 | ws_item_sk, ws_order_number | web_sales_pkey, _dta_index_web_sales_6_1269579561__k18_16, _dta_index_web_sales_6_1269579561__k1_8_24, _dta_index_web_sales_6_1269579561__k1_k4_k5_18, _dta_index_web_sales_6_1269579561__k1_k5, _dta_index_web_sales_6_1269579561__k3_k18_k12_k14_16_29_34 |

## Engine-Specific Knowledge
## Dialect Profile (POSTGRES)

**Combined Intelligence Baseline**: Combined intelligence baseline from 53 validated DSB queries at SF5-SF10, plus regression registry outcomes. PostgreSQL has bitmap index scans, JIT compilation, and aggressive CTE materialization. Techniques that work on DuckDB often regress here.

### Optimizer Strengths (don't fight these)
- `BITMAP_OR_SCAN`: NEVER split OR conditions into UNION ALL. 0.21x and 0.26x observed.
- `SEMI_JOIN_EXISTS`: NEVER convert EXISTS to IN/NOT IN or materialized CTEs. 0.50x, 0.75x observed. Note: NOT EXISTS anti-join decorrelation can still be valid when replacing large correlated anti patterns.
- `INNER_JOIN_REORDERING`: Don't restructure INNER JOIN orders. Focus on LEFT JOIN blocking or comma-join confusion.
- `INDEX_ONLY_SCAN`: Small dimension lookups (<10K rows) may not need CTEs.

### Known Gaps (exploit these)
- `COMMA_JOIN_WEAKNESS` [HIGH] detect: FROM t1, t2, t3 WHERE t1.key = t2.key (comma joins, no explicit JOIN). Poor row estimates in EXPLAIN. | action: Convert comma-joins to explicit JOIN...ON syntax. Best when combined with date_cte_isolate.
- `CORRELATED_SUBQUERY_PARALYSIS` [HIGH] detect: Nested loop in EXPLAIN, inner re-executes aggregate per outer row. SQL: WHERE col > (SELECT AGG FROM ... WHERE outer.key = inner.key). Hash… | action: Convert correlated WHERE to explicit CTE with GROUP BY + JOIN.
- `NON_EQUI_JOIN_INPUT_BLINDNESS` [HIGH] detect: Expensive non-equi join (BETWEEN, <, >) with large inputs on both sides. Neither side filtered. | action: Reduce fact table input size via filtered CTE before the non-equi join.
- `CTE_MATERIALIZATION_FENCE` [MEDIUM] detect: Large CTE + small post-filter. Multi-referenced CTE that blocks predicate pushdown. | action: Materialize STRATEGICALLY: only when CTE is expensive and reused. Avoid fencing single-use cases.
- `CROSS_CTE_PREDICATE_BLINDNESS` [MEDIUM] detect: Sequential scan on dimension table without index condition. Late filter after large scan/join. | action: Pre-filter into CTE definition. But be more cautious than on DuckDB.

## Dispatcher Hypothesis
Nested loop anti-join on NOT EXISTS subqueries dominates runtime (25s) due to per-row re-execution. Correlated subquery paralysis and comma-join syntax prevent efficient set operations. Decorrelation + dimension isolation should convert nested loops to single-pass hash joins.

## Dispatcher Reasoning Trace
- Cost spine: Nested Loop (25.6s) → Nested Loop Anti (materializing 310K rows)
- Amplification: 1105 outer loops for NOT EXISTS subqueries
- Late filtering: date_dim scans occur after fact table joins

## Equivalence Tier
- exact

## Additional Intelligence
### AST Feature Detection

- **dimension_cte_isolate**: 100% match (DATE_DIM, GROUP_BY, MULTI_TABLE_5+) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: CROSS_JOIN_3_DIMS, UNFILTERED_CTE] [SUPPORT: portability_candidate; engines=duckdb]
- **sf_sk_pushdown_multi_fact**: 100% match (DATE_DIM, MULTI_TABLE_5+) (gap: PREDICATE_TRANSITIVITY_FAILURE) [SUPPORT: portability_candidate; engines=snowflake]
- **multi_date_range_cte**: 83% match (BETWEEN, DATE_DIM, GROUP_BY, MULTI_TABLE_5+) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [SUPPORT: portability_candidate; engines=duckdb]
  Missing: AGG_AVG
- **composite_decorrelate_union**: 78% match (AGG_COUNT, DATE_DIM, EXISTS, GROUP_BY) (gap: CORRELATED_SUBQUERY_PARALYSIS) [SUPPORT: portability_candidate; engines=duckdb]
  Missing: AGG_SUM, OR_BRANCH
- **prefetch_fact_join**: 75% match (DATE_DIM, GROUP_BY, STAR_JOIN) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: MAX_2_CHAINS] [SUPPORT: portability_candidate; engines=duckdb]
  Missing: AGG_SUM


## Probe Summary
14 probes fired, 1 passed validation, 1 showed speedup.

## BDA Table (all probes)

| Probe | Transform | Family | Status | Speedup | Top EXPLAIN Nodes | Model Description | SQL Patch | Error/Notes |
|-------|-----------|--------|--------|---------|-------------------|-------------------|-----------|-------------|
| p05 | date_cte_explicit_join | F | NEUTRAL | 0.99x | - | Convert comma joins to explicit INNER JOIN syntax: FROM customer c INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk INNER JOIN customer_demographics cd ON cd_demo_sk = c.c_current_cdemo_sk | p05 |  |
| p04 | pg_self_join_decomposition | E | NEUTRAL | 0.98x | - | Materialize filtered date_dim as CTE date_range: SELECT d_date_sk FROM date_dim WHERE d_year=2002 AND d_moy BETWEEN 10-12 | p04 |  |
| p02 | early_filter_decorrelate | B | FAIL | - | - | Decorrelate web_sales NOT EXISTS via CTE web_customers: SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN date_dim WHERE d_year=2002 AND d_moy BETWEEN 10-12 AND ws_list_price BETWEEN 80-169 | p02 | Row count: orig=80, patch=0 |
| p06 | dimension_prefetch_star | F | FAIL | - | - | Pre-filter customer_address into CTE filtered_ca: SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('CO','NC','TX') | p06 | Synthetic semantic mismatch: Optimized query failed: Binder Error: Referenced table "ca" not found! Candidate tables: "c", "customer_demographics" LINE 1: ...ress_sk, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN (' |
| p07 | dimension_prefetch_star | F | FAIL | - | - | Pre-filter customer_demographics into CTE filtered_cd: SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status IN ('S','M','U') AND cd_education_status IN ('Primary','College') | p07 | Synthetic semantic mismatch: Optimized query failed: Binder Error: Referenced column "cd_marital_status" not found in FROM clause! Candidate bindings: "c_email_address", "ca_address_id", "c_last_review_date_sk", "c_last_name", "c_salutation" LINE 1: .. |
| p10 | shared_dimension_multi_channel | A | NEUTRAL | 0.99x | - | Reuse date_range CTE in all sales channel CTEs (p01-p03) | p10 |  |
| p03 | early_filter_decorrelate | B | FAIL | - | - | Decorrelate catalog_sales NOT EXISTS via CTE catalog_customers: SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales JOIN date_dim WHERE d_year=2002 AND d_moy BETWEEN 10-12 AND cs_list_price BETWEEN 80-169 | p03 | Row count: orig=80, patch=0 |
| p08 | materialize_cte | E | FAIL | - | - | Combine customer + filtered_ca + filtered_cd into CTE base_customers: SELECT c_customer_sk, c_current_cdemo_sk FROM customer JOIN filtered_ca JOIN filtered_cd | p08 | Synthetic semantic mismatch: Optimized query failed: Binder Error: Referenced column "cd_gender" not found in FROM clause! Candidate bindings: "c_current_cdemo_sk", "c_customer_sk" LINE 1: ... 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP |
| p12 | decorrelate | B | WIN | 34.45x | - | Convert store_sales EXISTS to LEFT JOIN ... WHERE IS NOT NULL | p12 |  |
| p13 | aggregate_pushdown | C | FAIL | - | - | Pre-aggregate customer counts in base_customers CTE before sales joins | p13 | Tier-1: LITERAL MISMATCH: Original literals missing from rewrite — numbers: ['10.0', '169.0', '2.0', '2002.0', '80.0']. The rewrite changed filter values instead of preserving them. |
| p09 | composite_decorrelate_union | B | REGRESSION | 0.16x | - | Combine all sales channel checks into single CTE: SELECT ss_customer_sk AS cust_key, 'store' AS channel FROM store_sales JOIN date_range UNION ALL ... | p09 |  |
| p01 | early_filter_decorrelate | B | FAIL | - | - | Decorrelate store_sales EXISTS by creating CTE store_customers: SELECT DISTINCT ss_customer_sk FROM store_sales JOIN date_dim WHERE d_year=2002 AND d_moy BETWEEN 10-12 AND ss_list_price BETWEEN 80-169 | p01 | Tier-1: COLUMN REF MISMATCH: Original columns missing from rewrite — ['cs_list_price', 'cs_ship_customer_sk', 'cs_sold_date_sk', 'ws_bill_customer_sk', 'ws_list_price']. The rewrite references different table columns. |
| p11 | sf_sk_pushdown_multi_fact | A | FAIL | - | - | Add date_sk BETWEEN to store_sales CTE: WHERE ss_sold_date_sk BETWEEN (SELECT MIN(d_date_sk) FROM date_range) AND (SELECT MAX(d_date_sk) FROM date_range | p11 | Synthetic semantic mismatch: Optimized query failed: Binder Error: Referenced column "ss_list_price" not found in FROM clause! Candidate bindings: "c_first_shipto_date_sk", "ca_location_type", "c_last_name", "c_birth_year", "c_customer_id" LINE 1: ...e |
| p14 | channel_bitmap_aggregation | C | FAIL | - | - | Consolidate sales channel checks via CASE: MAX(CASE WHEN channel='store' THEN 1 END) AS has_store_sale | p14 | Synthetic semantic mismatch: Optimized query failed: Binder Error: Referenced table "sc" not found! Candidate tables: "customer_demographics" LINE 1: ..._channels AS sc WHERE sc.customer_sk = c.c_customer_sk AND sc.has_web_sale = 2) AND NOT EXISTS(SELE |

## Worker SQL Patches

### p05: date_cte_explicit_join (NEUTRAL, 0.99x)
```sql
SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c INNER JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk INNER JOIN customer_demographics AS cd ON cd_demo_sk = c.c_current_cdemo_sk WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p04: pg_self_join_decomposition (NEUTRAL, 0.98x)
```sql
WITH date_range AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 12) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p02: early_filter_decorrelate (FAIL, n/a)
```sql
WITH web_customers AS (SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN date_dim ON ws_sold_date_sk = d_date_sk WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169) AND NOT c.c_customer_sk IN (SELECT ws_bill_customer_sk FROM web_customers) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p06: dimension_prefetch_star (FAIL, n/a)
```sql
WITH filtered_ca AS (SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('CO', 'NC', 'TX')) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c JOIN filtered_ca ON c.c_current_addr_sk = filtered_ca.ca_address_sk, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p07: dimension_prefetch_star (FAIL, n/a)
```sql
WITH filtered_cd AS (SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College')) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN filtered_cd AS cd ON cd.cd_demo_sk = c.c_current_cdemo_sk WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p10: shared_dimension_multi_channel (NEUTRAL, 0.99x)
```sql
WITH date_range AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 12) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics AS cd ON cd.cd_demo_sk = c.c_current_cdemo_sk WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p03: early_filter_decorrelate (FAIL, n/a)
```sql
WITH catalog_customers AS (SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales JOIN date_dim ON cs_sold_date_sk = d_date_sk WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT c.c_customer_sk IN (SELECT cs_ship_customer_sk FROM catalog_customers) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p08: materialize_cte (FAIL, n/a)
```sql
WITH base_customers AS (SELECT c.c_customer_sk, c.c_current_cdemo_sk FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics AS cd ON cd.cd_demo_sk = c.c_current_cdemo_sk WHERE ca.ca_state IN ('CO', 'NC', 'TX') AND cd.cd_marital_status IN ('S', 'M', 'U') AND cd.cd_education_status IN ('Primary', 'College')) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM base_customers AS c WHERE EXISTS(SELECT * FROM store_sales, date_dim WHERE c.c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p12: decorrelate (WIN, 34.45x)
```sql
WITH valid_store_sales AS (SELECT DISTINCT ss_customer_sk FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT 1 FROM valid_store_sales AS vss WHERE c.c_customer_sk = vss.ss_customer_sk) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p13: aggregate_pushdown (FAIL, n/a)
```sql
WITH base_customers AS (SELECT c_customer_sk, cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE ca_state IN ('CO', 'NC', 'TX')) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM base_customers AS bc, customer_demographics AS cd WHERE cd_demo_sk = bc.cd_demo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p09: composite_decorrelate_union (REGRESSION, 0.16x)
```sql
WITH unified_sales_channels AS (SELECT ss_customer_sk AS cust_key, 'store' AS channel FROM store_sales JOIN date_dim ON ss_sold_date_sk = d_date_sk WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169 UNION ALL SELECT ws_bill_customer_sk AS cust_key, 'web' AS channel FROM web_sales JOIN date_dim ON ws_sold_date_sk = d_date_sk WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169 UNION ALL SELECT cs_ship_customer_sk AS cust_key, 'catalog' AS channel FROM catalog_sales JOIN date_dim ON cs_sold_date_sk = d_date_sk WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT 1 FROM unified_sales_channels AS u WHERE u.cust_key = c.c_customer_sk AND u.channel = 'store') AND NOT EXISTS(SELECT 1 FROM unified_sales_channels AS u WHERE u.cust_key = c.c_customer_sk AND u.channel = 'web') AND NOT EXISTS(SELECT 1 FROM unified_sales_channels AS u WHERE u.cust_key = c.c_customer_sk AND u.channel = 'catalog') GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p01: early_filter_decorrelate (FAIL, n/a)
```sql
WITH store_customers AS (SELECT DISTINCT ss_customer_sk FROM store_sales JOIN date_dim ON ss_sold_date_sk = d_date_sk WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT 1 FROM store_customers WHERE ss_customer_sk = c.c_customer_sk) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p11: sf_sk_pushdown_multi_fact (FAIL, n/a)
```sql
WITH filtered_store_sales AS (SELECT ss_customer_sk, ss_sold_date_sk FROM store_sales WHERE ss_sold_date_sk BETWEEN (SELECT MIN(d_date_sk) FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2) AND (SELECT MAX(d_date_sk) FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2)) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT * FROM filtered_store_sales AS fss, date_dim WHERE fss.ss_customer_sk = c.c_customer_sk AND fss.ss_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ss_list_price BETWEEN 80 AND 169) AND (NOT EXISTS(SELECT * FROM web_sales, date_dim WHERE c.c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND ws_list_price BETWEEN 80 AND 169) AND NOT EXISTS(SELECT * FROM catalog_sales, date_dim WHERE c.c_customer_sk = cs_ship_customer_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2002 AND d_moy BETWEEN 10 AND 10 + 2 AND cs_list_price BETWEEN 80 AND 169)) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```

### p14: channel_bitmap_aggregation (FAIL, n/a)
```sql
WITH sales_channels AS (SELECT ss_customer_sk AS customer_sk, 1 AS has_store_sale FROM store_sales WHERE ss_list_price BETWEEN 80 AND 169 AND ss_sold_date_sk IN (SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 12) UNION ALL SELECT ws_bill_customer_sk AS customer_sk, 2 AS has_web_sale FROM web_sales WHERE ws_list_price BETWEEN 80 AND 169 AND ws_sold_date_sk IN (SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 12) UNION ALL SELECT cs_ship_customer_sk AS customer_sk, 3 AS has_catalog_sale FROM catalog_sales WHERE cs_list_price BETWEEN 80 AND 169 AND cs_sold_date_sk IN (SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 12)) SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM customer AS c, customer_address AS ca, customer_demographics WHERE c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_current_cdemo_sk AND cd_marital_status IN ('S', 'M', 'U') AND cd_education_status IN ('Primary', 'College') AND EXISTS(SELECT 1 FROM sales_channels AS sc WHERE sc.customer_sk = c.c_customer_sk AND sc.has_store_sale = 1) AND NOT EXISTS(SELECT 1 FROM sales_channels AS sc WHERE sc.customer_sk = c.c_customer_sk AND sc.has_web_sale = 2) AND NOT EXISTS(SELECT 1 FROM sales_channels AS sc WHERE sc.customer_sk = c.c_customer_sk AND sc.has_catalog_sale = 3) GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100;
```


## Shot 1 Results

| # | Family | Transform | Speedup | Status | Error |
|---|--------|-----------|---------|--------|-------|

## Shot 2 — Design Highest-Probability Patch Plan(s)

Build on shot 1 results:
1. Start from the strongest verified evidence in the BDA table.
2. Refine the best winner OR produce one justified novel move for the remaining hotspot.

If all shot 1 plans failed, diagnose why and produce one fundamentally different plan.

Output policy:
- If one pathway is clearly strongest: output ONE JSON object.
- If two pathways are close/competing: output JSON array with TWO objects.

Follow the sniper contract in the base prompt.