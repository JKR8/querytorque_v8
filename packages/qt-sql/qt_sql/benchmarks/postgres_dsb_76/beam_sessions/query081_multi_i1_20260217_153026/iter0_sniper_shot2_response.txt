[
  {
    "plan_id": "snipe_p1",
    "dialect": "postgres",
    "confidence": 0.8,
    "based_on": "p01,p02",
    "strategy": "Decorrelate subquery and convert comma-joins to explicit joins",
    "hypothesis": "Correlated subquery causes repeated aggregate execution. Comma-joins lead to poor row estimates. Decorrelation via CTE and explicit joins should reduce nested loops and improve plan.",
    "target_ir": "Two CTEs: customer_total_return (with explicit joins) and state_avg. Main query with explicit joins and state_avg join.",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {
          "by_node_id": "S0"
        },
        "payload": {
          "sql_fragment": "WITH customer_total_return AS (SELECT cr_returning_customer_sk AS ctr_customer_sk, ca_state AS ctr_state, SUM(cr_return_amt_inc_tax) AS ctr_total_return FROM catalog_returns INNER JOIN date_dim ON cr_returned_date_sk = d_date_sk INNER JOIN customer_address ON cr_returning_addr_sk = ca_address_sk WHERE d_year = 2000 GROUP BY cr_returning_customer_sk, ca_state), state_avg AS (SELECT ctr_state, AVG(ctr_total_return) * 1.2 AS threshold FROM customer_total_return GROUP BY ctr_state) SELECT c_customer_id, c_salutation, c_first_name, c_last_name, ca_street_number, ca_street_name, ca_street_type, ca_suite_number, ca_city, ca_county, ca_state, ca_zip, ca_country, ca_gmt_offset, ca_location_type, ctr_total_return FROM customer_total_return ctr1 INNER JOIN customer_address ON ca_address_sk = c_current_addr_sk INNER JOIN customer ON ctr1.ctr_customer_sk = c_customer_sk INNER JOIN state_avg ON ctr1.ctr_state = state_avg.ctr_state WHERE ctr1.ctr_total_return > state_avg.threshold AND ca_state = 'IA' ORDER BY c_customer_id, c_salutation, c_first_name, c_last_name, ca_street_number, ca_street_name, ca_street_type, ca_suite_number, ca_city, ca_county, ca_state, ca_zip, ca_country, ca_gmt_offset, ca_location_type, ctr_total_return LIMIT 100;"
        }
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "postgres",
    "confidence": 0.75,
    "based_on": "p01,p03",
    "strategy": "Decorrelate subquery, prefilter customer_address, and use explicit joins",
    "hypothesis": "Decorrelate the subquery and prefilter the dimension table (customer_address) to reduce rows early. Explicit joins to help optimizer.",
    "target_ir": "Three CTEs: customer_total_return, state_avg, and filtered_ca. Main query with explicit joins to filtered_ca and state_avg.",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {
          "by_node_id": "S0"
        },
        "payload": {
          "sql_fragment": "WITH customer_total_return AS (SELECT cr_returning_customer_sk AS ctr_customer_sk, ca_state AS ctr_state, SUM(cr_return_amt_inc_tax) AS ctr_total_return FROM catalog_returns INNER JOIN date_dim ON cr_returned_date_sk = d_date_sk INNER JOIN customer_address ON cr_returning_addr_sk = ca_address_sk WHERE d_year = 2000 GROUP BY cr_returning_customer_sk, ca_state), state_avg AS (SELECT ctr_state, AVG(ctr_total_return) * 1.2 AS threshold FROM customer_total_return GROUP BY ctr_state), filtered_ca AS (SELECT * FROM customer_address WHERE ca_state = 'IA') SELECT c_customer_id, c_salutation, c_first_name, c_last_name, ca_street_number, ca_street_name, ca_street_type, ca_suite_number, ca_city, ca_county, ca_state, ca_zip, ca_country, ca_gmt_offset, ca_location_type, ctr_total_return FROM customer_total_return ctr1 INNER JOIN filtered_ca ON ca_address_sk = c_current_addr_sk INNER JOIN customer ON ctr1.ctr_customer_sk = c_customer_sk INNER JOIN state_avg ON ctr1.ctr_state = state_avg.ctr_state WHERE ctr1.ctr_total_return > state_avg.threshold ORDER BY c_customer_id, c_salutation, c_first_name, c_last_name, ca_street_number, ca_street_name, ca_street_type, ca_suite_number, ca_city, ca_county, ca_state, ca_zip, ca_country, ca_gmt_offset, ca_location_type, ctr_total_return LIMIT 100;"
        }
      }
    ]
  }
]