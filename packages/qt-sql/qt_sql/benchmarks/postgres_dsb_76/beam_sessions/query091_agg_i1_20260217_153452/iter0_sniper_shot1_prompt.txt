## Role

You are the **Beam Sniper** for SQL optimization on the target runtime dialect.

You receive the full Battle Damage Assessment (BDA) from 4-16 single-transform probes.
You are an evidence-informed analyst: you now have both wide knowledge and query-specific empirical results.

Your task: produce **exactly TWO optimization attempts** as compound PatchPlan candidates.

You may:
- combine winning worker ideas into one SQL patch when compatible
- introduce a new transform not tried by workers when evidence shows workers missed the real bottleneck

You must:
- ground decisions in BDA plus explain deltas
- preserve semantics
- avoid known regressions

---

## Prompt Map (cache friendly)

### Phase A - Cached Context (static)
A1. Dialect reminders plus regression registry
A2. Combination hazards (duplication, multiplicity, CTE fences)
A3. Evidence-first decision procedure (mechanical)
A4. Sniper output contract (strict JSON array)

### Phase B - Query-Specific Input (dynamic; after cache boundary)
B1. Importance star rating (1-3)
B2. Original SQL plus original plan
B3. IR structure plus anchor hashes
B4. BDA table (ALL probes: status, speedup, explain delta, failure reasons)
B5. Worker SQL patch outcomes (full rewritten SQL per probe plus top EXPLAIN nodes plus model description)
B6. Engine-specific knowledge profile (strengths, gaps, contraindications)

---

## Dialect reminders

Use runtime-injected **Engine-Specific Knowledge** as authoritative.
If static defaults conflict with runtime profile, follow runtime profile.

---

## Regression Registry (hard bans)

Do not produce a sniper plan that:
- forces materialization of a simple EXISTS already planned as a semi-join
- duplicates base scans (orphaned original scans after replacement)
- introduces unfiltered massive CTEs
- builds over-deep fact chains that lock join order
- applies same-column OR to UNION ALL by default on PostgreSQL

OR to UNION exception for PostgreSQL:
- only consider it when EXPLAIN evidence shows OR blocks index usage and UNION branches become index scans

---

## Combination hazards (what to watch)

- **Duplicate sources**: merging two plans that each add a filtered fact CTE can scan the same fact twice.
- **Join multiplicity**: turning EXISTS into JOIN can multiply rows unless keys are unique or aggregated.
- **CTE fences**: materialized CTEs can block pushdown and join reorder.
- **Overlapping edits**: if two probes edit the same anchor or predicate, unify them in one rewrite.

---

## Evidence-first decision procedure (mechanical)

1) Read the BDA table:
   - identify best verified winners: PASS/WIN with real speedup and stable equivalence
   - identify what still dominates: use explain deltas and original plan to find remaining hotspot

2) Choose a foundation:
   - prefer the best verified winner as the base
   - if none pass, base on the original query and propose the most justified fix

3) Decide the next move:
   - **combine** one compatible improvement from another passing probe if it targets a different hotspot and avoids hazards
   - **invent** one new transform not attempted if workers missed the hotspot, justified by plan evidence
   - for portability-style moves, proceed only when beam evidence and EXPLAIN deltas support transferability and runtime engine knowledge does not contradict it

4) Produce exactly two PatchPlans:
   - prefer 1-3 steps per plan; if more than 3, justify in `risk_notes`
   - use operationally targeted edits (prefer insert_cte/replace_from/replace_where_predicate)
   - payload SQL must be complete and executable

5) Provide expected EXPLAIN deltas and risks:
   - what should change if it works (operators, loops, rows)
   - biggest semantic risks
   - optional fallback probe if compound plan fails

---

## Sniper Output Contract (MUST follow)

Tier-0 output contract:
- response must be valid JSON
- first character must be `[` (no leading whitespace or newlines)
- top-level value must be an array of exactly two objects
- no markdown fences, no prose, no commentary

Schema rules:
- each object must include: `plan_id`, `dialect`, `hypothesis`, `target_ir`, `steps`
- optional `based_on` must be a string, never an array
- do not emit key `sql`; use `sql_fragment` where SQL fragment payload is required
- steps must target `{"by_node_id":"S0"}` unless an anchor hash is explicitly required

Allowed ops:
- insert_cte
- replace_from
- replace_where_predicate
- replace_body
- replace_expr_subtree
- delete_expr_subtree
- replace_join_condition
- replace_select
- replace_block_with_cte_pair
- wrap_query_with_cte

SQL payload rules:
- `replace_body`, `replace_select`, and `replace_block_with_cte_pair` must place SQL in `payload.sql_fragment`
- payload SQL must be complete and executable

Output JSON shape:
[
  {
    "plan_id": "snipe_p1",
    "dialect": "<target_dialect>",
    "confidence": 0.81,
    "based_on": "p03,p11",
    "strategy": "Foundation plus one compatible add-on",
    "hypothesis": "Plan evidence and expected win mechanism",
    "target_ir": "Short structural description of final query shape",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {"sql_fragment": "SELECT c_customer_sk FROM customer"}
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "<target_dialect>",
    "confidence": 0.73,
    "based_on": "p07",
    "strategy": "Alternative independent pathway",
    "hypothesis": "Plan evidence for second pathway",
    "target_ir": "Alternative structural description",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "filtered_sales",
          "cte_query_sql": "SELECT ss_customer_sk FROM store_sales WHERE ss_quantity > 0"
        }
      }
    ]
  }
]

---

## Cache Boundary
Everything below is query-specific input.

## Query ID
query091_agg_i1

## Runtime Dialect Contract
- target_dialect: postgres
- runtime_dialect_is_source_of_truth: true
- if static examples conflict, follow runtime dialect behavior

## Importance
- importance_stars: 3
- importance_label: ***

## Original SQL
```sql
select  
        cc_call_center_id Call_Center,
        cc_name Call_Center_Name,
        cc_manager Manager,
        sum(cr_net_loss) Returns_Loss
from
        call_center,
        catalog_returns,
        date_dim,
        customer,
        customer_address,
        customer_demographics,
        household_demographics
where
        cr_call_center_sk       = cc_call_center_sk
and     cr_returned_date_sk     = d_date_sk
and     cr_returning_customer_sk= c_customer_sk
and     cd_demo_sk              = c_current_cdemo_sk
and     hd_demo_sk              = c_current_hdemo_sk
and     ca_address_sk           = c_current_addr_sk
and     d_year                  = 1998 
and     d_moy                   = 2
and     ( (cd_marital_status       = 'M' and cd_education_status     = 'Unknown')
        or(cd_marital_status       = 'W' and cd_education_status     = 'Advanced Degree'))
and     hd_buy_potential like '1001-5000%'
and     ca_gmt_offset           = -7
group by cc_call_center_id,cc_name,cc_manager,cd_marital_status,cd_education_status
order by sum(cr_net_loss) desc;
```

## Original Plan
```
Sort  (rows=0, time=2244.771)
  Aggregate  (rows=0, time=2244.759)
    Sort  (rows=0, time=2244.758)
      Gather  (rows=0, time=2244.745)
        Nested Loop  (rows=0, time=2227.452)
          Nested Loop  (rows=3, time=2225.709)
            Nested Loop  (rows=40, time=2215.593)
              Nested Loop  (rows=300, time=2211.124)
                Hash Join  (rows=304, time=2176.251)
                  Hash Join  (rows=312, time=2175.895)
                    Seq Scan on catalog_returns  (rows=719420, time=2141.099)
                    Hash  (rows=28, time=0.591)
                      Index Only Scan on date_dim  (rows=28, time=0.585)
                  Hash  (rows=24, time=0.2)
                    Seq Scan on call_center  (rows=24, time=0.193)
                Index Scan on customer  (rows=1, time=0.114)
              Index Scan on household_demographics  (rows=0, time=0.014)
            Index Scan on customer_address  (rows=0, time=0.25)
          Index Scan on customer_demographics  (rows=0, time=0.579)
```

## IR Structure + Anchor Hashes
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: call_center, catalog_returns, date_dim, customer, customer_address, customer_demographics, household_demographics
    WHERE [ac46b9a793b959c6]: cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_custom...
    GROUP BY: cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status
    ORDER BY: SUM(cr_net_loss)

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Schema / Index / Stats Context
- source: postgres
- referenced_tables: 7

| Table | Rows(est) | PK | Indexes |
|-------|-----------|----|---------|
| call_center | 24 | cc_call_center_sk | call_center_pkey |
| catalog_returns | 2158290 | cr_item_sk, cr_order_number | catalog_returns_pkey |
| customer | 500000 | c_customer_sk | customer_pkey, _dta_index_customer_6_949578421__k9_k10, _dta_index_customer_6_949578421__k1_k5, _dta_index_customer_5_949578421__k13_k5 |
| customer_address | 250000 | ca_address_sk | customer_address_pkey |
| customer_demographics | 1920800 | cd_demo_sk | customer_demographics_pkey |
| date_dim | 73049 | d_date_sk | date_dim_pkey, _dta_index_date_dim_6_661577395__k7_k4_k9_k1, _dta_index_date_dim_6_661577395__k7_k9_k1, _dta_index_date_dim_6_661577395__k1_k7_k9, _dta_index_date_dim_6_661577395__k7_k11_k1, _dta_index_date_dim_6_661577395__k9_k7_k1 |
| household_demographics | 7200 | hd_demo_sk | household_demographics_pkey |

## Engine-Specific Knowledge
## Dialect Profile (POSTGRES)

**Combined Intelligence Baseline**: Combined intelligence baseline from 53 validated DSB queries at SF5-SF10, plus regression registry outcomes. PostgreSQL has bitmap index scans, JIT compilation, and aggressive CTE materialization. Techniques that work on DuckDB often regress here.

### Optimizer Strengths (don't fight these)
- `BITMAP_OR_SCAN`: Avoid splitting OR conditions into UNION ALL by default. Only consider OR→UNION when EXPLAIN shows OR blocks index usage and UNION branches become index scans. 0.21x and 0.26x reg…
- `SEMI_JOIN_EXISTS`: NEVER convert EXISTS to IN/NOT IN or materialized CTEs. 0.50x, 0.75x observed. Note: NOT EXISTS anti-join decorrelation can still be valid when replacing large correlated anti patterns.
- `INNER_JOIN_REORDERING`: Don't restructure INNER JOIN orders. Focus on LEFT JOIN blocking or comma-join confusion.
- `INDEX_ONLY_SCAN`: Small dimension lookups (<10K rows) may not need CTEs.

### Known Gaps (exploit these)
- `COMMA_JOIN_WEAKNESS` [HIGH] detect: FROM t1, t2, t3 WHERE t1.key = t2.key (comma joins, no explicit JOIN). Poor row estimates in EXPLAIN. | action: Convert comma-joins to explicit JOIN...ON syntax. Best when combined with date_cte_isolate.
- `CORRELATED_SUBQUERY_PARALYSIS` [HIGH] detect: Nested loop in EXPLAIN, inner re-executes aggregate per outer row. SQL: WHERE col > (SELECT AGG FROM ... WHERE outer.key = inner.key). Hash… | action: Convert correlated WHERE to explicit CTE with GROUP BY + JOIN.
- `NON_EQUI_JOIN_INPUT_BLINDNESS` [HIGH] detect: Expensive non-equi join (BETWEEN, <, >) with large inputs on both sides. Neither side filtered. | action: Reduce fact table input size via filtered CTE before the non-equi join.
- `CTE_MATERIALIZATION_FENCE` [MEDIUM] detect: Large CTE + small post-filter. Multi-referenced CTE that blocks predicate pushdown. | action: Materialize STRATEGICALLY: only when CTE is expensive and reused. Avoid fencing single-use cases.
- `CROSS_CTE_PREDICATE_BLINDNESS` [MEDIUM] detect: Sequential scan on dimension table without index condition. Late filter after large scan/join. | action: Pre-filter into CTE definition. But be more cautious than on DuckDB.

## Dispatcher Hypothesis
Cost spine dominated by sequential scan on catalog_returns (719K rows) followed by nested loops. Late filtering on customer dimensions causes row amplification. Early dimension isolation and explicit join conversion should reduce fact table scans and enable better join planning.

## Dispatcher Reasoning Trace
- Sequential scan on catalog_returns (719K rows) consumes 95% of plan time
- Nested loops amplify small row counts (300→40→3) with late dimension filters
- OR condition on customer_demographics may block efficient index usage
- Comma joins prevent optimal join ordering estimates

## Equivalence Tier
- exact

## Additional Intelligence
### AST Feature Detection

- **or_to_union**: 100% match (AGG_SUM, DATE_DIM, GROUP_BY, OR_BRANCH) (gap: CROSS_COLUMN_OR_DECOMPOSITION) [CAUTION: MAX_3_BRANCHES, SAME_COL_OR] [SUPPORT: portability_candidate; engines=duckdb]
- **prefetch_fact_join**: 100% match (AGG_SUM, DATE_DIM, GROUP_BY, STAR_JOIN) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: MAX_2_CHAINS] [SUPPORT: portability_candidate; engines=duckdb]
- **dimension_cte_isolate**: 100% match (DATE_DIM, GROUP_BY, MULTI_TABLE_5+) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: CROSS_JOIN_3_DIMS, UNFILTERED_CTE] [SUPPORT: portability_candidate; engines=duckdb]
- **sf_sk_pushdown_multi_fact**: 100% match (DATE_DIM, MULTI_TABLE_5+) (gap: PREDICATE_TRANSITIVITY_FAILURE) [SUPPORT: portability_candidate; engines=snowflake]
- **multi_dimension_prefetch**: 75% match (AGG_SUM, DATE_DIM, GROUP_BY) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [SUPPORT: portability_candidate; engines=duckdb]
  Missing: CASE_EXPR


## Probe Summary
14 probes fired, 0 passed validation, 0 showed speedup.

## BDA Table (all probes)

| Probe | Transform | Family | Status | Speedup | Top EXPLAIN Nodes | Model Description | SQL Patch | Error/Notes |
|-------|-----------|--------|--------|---------|-------------------|-------------------|-----------|-------------|
| p10 | materialize_cte | E | ERROR | - | - | Materialize customer_address: WITH ca_cte AS (SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -7) | p10 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p01 | inner_join_conversion | F | ERROR | - | - | Convert comma joins to explicit INNER JOIN syntax in FROM clause | p01 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p14 | early_filter | A | ERROR | - | - | Push household_demographics filter into CTE: WITH hd_cte AS (...WHERE hd_buy_potential LIKE '1001-5000%') | p14 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p11 | date_cte_explicit_join | F | ERROR | - | - | Combine date_cte with explicit joins: WITH date_cte AS (...) THEN INNER JOIN date_cte ON ... | p11 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p13 | early_filter | A | ERROR | - | - | Push customer_demographics filter into CTE definition: WITH cd_cte AS (...WHERE (M/Unknown) OR (W/Advanced Degree)) | p13 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p09 | materialize_cte | E | ERROR | - | - | Materialize household_demographics: WITH hd_cte AS (SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential LIKE '1001-5000%') | p09 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p02 | date_cte_isolate | A | ERROR | - | - | Extract date_dim filter into CTE: WITH date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year=1998 AND d_moy=2) | p02 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p04 | prefetch_fact_join | A | ERROR | - | - | Staged CTE chain: 1) date_cte, 2) customer_set, 3) JOIN catalog_returns ON date/customer keys | p04 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p08 | materialize_cte | E | ERROR | - | - | Materialize customer_demographics filter: WITH cd_cte AS (SELECT cd_demo_sk FROM customer_demographics WHERE (M/Unknown) OR (W/Advanced Degree)) | p08 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p03 | dimension_cte_isolate | A | ERROR | - | - | Create customer_set CTE with filtered customer keys: WITH customer_set AS (SELECT c_customer_sk FROM customer JOIN customer_address... WHERE conditions) | p03 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p07 | aggregate_pushdown | C | ERROR | - | - | Pre-aggregate catalog_returns: WITH agg_cr AS (SELECT cr_call_center_sk, cr_returning_customer_sk, SUM(cr_net_loss) AS loss... GROUP BY 1,2) | p07 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p05 | multi_dimension_prefetch | A | ERROR | - | - | Create CTEs for all dimensions: date_cte, cc_cte, customer_set, then JOIN catalog_returns | p05 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p06 | or_to_union | D | ERROR | - | - | Split OR condition into UNION ALL branches: (M/Unknown) UNION ALL (W/Advanced Degree) | p06 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p12 | dimension_prefetch_star | F | ERROR | - | - | All dimensions in CTEs + explicit star-join: date_cte, cc_cte, customer_set, ca_cte, cd_cte, hd_cte JOIN catalog_returns | p12 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |

## Worker SQL Patches

### p10: materialize_cte (ERROR, n/a)
```sql
WITH ca_cte AS (SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -7) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM call_center AS cc JOIN catalog_returns AS cr ON cr.cr_call_center_sk = cc.cc_call_center_sk JOIN date_dim AS dd ON cr.cr_returned_date_sk = dd.d_date_sk JOIN customer AS c ON cr.cr_returning_customer_sk = c.c_customer_sk JOIN ca_cte AS ca ON ca.ca_address_sk = c.c_current_addr_sk JOIN customer_demographics AS cd ON cd.cd_demo_sk = c.c_current_cdemo_sk JOIN household_demographics AS hd ON hd.hd_demo_sk = c.c_current_hdemo_sk WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND d_year = 1998 AND d_moy = 2 AND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p01: inner_join_conversion (ERROR, n/a)
```sql
SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM call_center AS cc INNER JOIN catalog_returns AS cr ON cc_call_center_sk = cr_call_center_sk INNER JOIN date_dim AS d ON cr_returned_date_sk = d_date_sk INNER JOIN customer AS c ON cr_returning_customer_sk = c_customer_sk INNER JOIN customer_demographics AS cd ON cd_demo_sk = c_current_cdemo_sk INNER JOIN household_demographics AS hd ON hd_demo_sk = c_current_hdemo_sk INNER JOIN customer_address AS ca ON ca_address_sk = c_current_addr_sk WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND d_year = 1998 AND d_moy = 2 AND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p14: early_filter (ERROR, n/a)
```sql
WITH hd_cte AS (SELECT * FROM household_demographics WHERE hd_buy_potential LIKE '1001-5000%') SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM call_center, catalog_returns, date_dim, customer, customer_address, customer_demographics, household_demographics WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND d_year = 1998 AND d_moy = 2 AND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) AND ca_gmt_offset = -7 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p11: date_cte_explicit_join (ERROR, n/a)
```sql
WITH date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 2) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM call_center JOIN catalog_returns ON cr_call_center_sk = cc_call_center_sk JOIN date_cte ON cr_returned_date_sk = date_cte.d_date_sk JOIN customer ON cr_returning_customer_sk = c_customer_sk JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk JOIN household_demographics ON hd_demo_sk = c_current_hdemo_sk JOIN customer_address ON ca_address_sk = c_current_addr_sk WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND d_year = 1998 AND d_moy = 2 AND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p13: early_filter (ERROR, n/a)
```sql
WITH cd_cte AS (SELECT * FROM customer_demographics WHERE (cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM call_center, catalog_returns, date_dim, customer, customer_address, customer_demographics, household_demographics WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND d_year = 1998 AND d_moy = 2 AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p09: materialize_cte (ERROR, n/a)
```sql
WITH hd_cte AS (SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential LIKE '1001-5000%') SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM call_center, catalog_returns, date_dim, customer, customer_address, customer_demographics, hd_cte WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND d_year = 1998 AND d_moy = 2 AND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) AND ca_gmt_offset = -7 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p02: date_cte_isolate (ERROR, n/a)
```sql
WITH date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 2) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM call_center, catalog_returns, customer, customer_address, customer_demographics, household_demographics, date_cte WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = date_cte.d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p04: prefetch_fact_join (ERROR, n/a)
```sql
WITH date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 2) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM call_center, catalog_returns, date_cte, customer, customer_address, customer_demographics, household_demographics WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = date_cte.d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p08: materialize_cte (ERROR, n/a)
```sql
WITH cd_cte AS (SELECT cd_demo_sk FROM customer_demographics WHERE (cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM call_center, catalog_returns, date_dim, customer, customer_address, cd_cte, household_demographics WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND d_year = 1998 AND d_moy = 2 AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p03: dimension_cte_isolate (ERROR, n/a)
```sql
WITH customer_set AS (SELECT c_customer_sk FROM customer JOIN customer_address ON ca_address_sk = c_current_addr_sk JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk JOIN household_demographics ON hd_demo_sk = c_current_hdemo_sk WHERE (cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree') AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM call_center JOIN catalog_returns ON cr_call_center_sk = cc_call_center_sk JOIN date_dim ON cr_returned_date_sk = d_date_sk JOIN customer_set ON cr_returning_customer_sk = customer_set.c_customer_sk WHERE d_year = 1998 AND d_moy = 2 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p07: aggregate_pushdown (ERROR, n/a)
```sql
WITH agg_cr AS (SELECT cr_call_center_sk, cr_returning_customer_sk, SUM(cr_net_loss) AS loss FROM catalog_returns GROUP BY cr_call_center_sk, cr_returning_customer_sk) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(loss) AS Returns_Loss FROM call_center JOIN agg_cr ON cc_call_center_sk = cr_call_center_sk JOIN date_dim ON cr_returned_date_sk = d_date_sk JOIN customer ON cr_returning_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk JOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND d_year = 1998 AND d_moy = 2 AND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')) AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7 GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p05: multi_dimension_prefetch (ERROR, n/a)
```sql
WITH date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 2), cc_cte AS (SELECT cc_call_center_sk FROM call_center), customer_set AS (SELECT c_customer_sk FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics AS cd ON c.c_current_cdemo_sk = cd.cd_demo_sk JOIN household_demographics AS hd ON c.c_current_hdemo_sk = hd.hd_demo_sk WHERE (cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree') AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM catalog_returns AS cr JOIN date_cte AS d ON cr.cr_returned_date_sk = d.d_date_sk JOIN cc_cte AS cc ON cr.cr_call_center_sk = cc.cc_call_center_sk JOIN customer_set AS cs ON cr.cr_returning_customer_sk = cs.c_customer_sk WHERE TRUE GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p06: or_to_union (ERROR, n/a)
```sql
WITH demographic_branch_1 AS (SELECT cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status, cr_net_loss FROM call_center, catalog_returns, date_dim, customer, customer_address, customer_demographics, household_demographics WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND d_year = 1998 AND d_moy = 2 AND cd_marital_status = 'M' AND cd_education_status = 'Unknown' AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM (SELECT cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status, cr_net_loss FROM demographic_branch_1 UNION ALL SELECT cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status, cr_net_loss FROM call_center, catalog_returns, date_dim, customer, customer_address, customer_demographics, household_demographics WHERE cr_call_center_sk = cc_call_center_sk AND cr_returned_date_sk = d_date_sk AND cr_returning_customer_sk = c_customer_sk AND cd_demo_sk = c_current_cdemo_sk AND hd_demo_sk = c_current_hdemo_sk AND ca_address_sk = c_current_addr_sk AND d_year = 1998 AND d_moy = 2 AND cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree' AND hd_buy_potential LIKE '1001-5000%' AND ca_gmt_offset = -7) AS combined_results GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```

### p12: dimension_prefetch_star (ERROR, n/a)
```sql
WITH date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year = 1998 AND d_moy = 2), cd_cte AS (SELECT cd_demo_sk FROM customer_demographics WHERE (cd_marital_status = 'M' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree')), hd_cte AS (SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential LIKE '1001-5000%'), ca_cte AS (SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -7), customer_set AS (SELECT c_customer_sk, c_current_cdemo_sk, c_current_hdemo_sk, c_current_addr_sk FROM customer WHERE NOT c_current_addr_sk IS NULL), cc_cte AS (SELECT cc_call_center_sk, cc_call_center_id, cc_name, cc_manager FROM call_center) SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, SUM(cr_net_loss) AS Returns_Loss FROM catalog_returns AS cr JOIN date_cte AS d ON cr.cr_returned_date_sk = d.d_date_sk JOIN customer_set AS c ON cr.cr_returning_customer_sk = c.c_customer_sk JOIN cd_cte AS cd ON cd.cd_demo_sk = c.c_current_cdemo_sk JOIN hd_cte AS hd ON hd.hd_demo_sk = c.c_current_hdemo_sk JOIN ca_cte AS ca ON ca.ca_address_sk = c.c_current_addr_sk JOIN cc_cte AS cc ON cr.cr_call_center_sk = cc.cc_call_center_sk WHERE TRUE GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status ORDER BY SUM(cr_net_loss) DESC;
```
