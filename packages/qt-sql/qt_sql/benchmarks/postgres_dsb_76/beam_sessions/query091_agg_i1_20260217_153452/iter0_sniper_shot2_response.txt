[
  {
    "plan_id": "snipe_p1",
    "dialect": "postgres",
    "family": "F",
    "transform": "explicit_join_conversion",
    "confidence": 0.85,
    "based_on": "p01",
    "hypothesis": "Original plan shows comma joins causing poor row estimates. Converting to explicit JOINs enables better join order optimization. EXPLAIN shows nested loops amplifying small row counts due to late filtering - explicit joins help push filters earlier.",
    "target_ir": "Explicit INNER JOIN structure with preserved join conditions",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_from",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "catalog_returns\nINNER JOIN call_center ON cr_call_center_sk = cc_call_center_sk\nINNER JOIN date_dim ON cr_returned_date_sk = d_date_sk\nINNER JOIN customer ON cr_returning_customer_sk = c_customer_sk\nINNER JOIN customer_address ON ca_address_sk = c_current_addr_sk\nINNER JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk\nINNER JOIN household_demographics ON hd_demo_sk = c_current_hdemo_sk"
        }
      },
      {
        "step_id": "s2",
        "op": "replace_where_predicate",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "d_year = 1998\nAND d_moy = 2\nAND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown')\nOR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree'))\nAND hd_buy_potential LIKE '1001-5000%'\nAND ca_gmt_offset = -7"
        }
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "postgres",
    "family": "A",
    "transform": "dimension_prefilter",
    "confidence": 0.75,
    "based_on": "p03,p13,p14",
    "hypothesis": "Nested loops in original plan show late filtering of dimensions. Prefiltering customer/demographics into CTE reduces fact table joins. EXPLAIN shows sequential scan on catalog_returns (719K rows) - early reduction prevents row amplification.",
    "target_ir": "CTE-prefiltered customer/demographics joined to fact tables",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "filtered_customers",
          "cte_query_sql": "SELECT c_customer_sk, cd_marital_status, cd_education_status\nFROM customer\nJOIN customer_address ON c_current_addr_sk = ca_address_sk\nJOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk\nJOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk\nWHERE ca_gmt_offset = -7\nAND hd_buy_potential LIKE '1001-5000%'\nAND ((cd_marital_status = 'M' AND cd_education_status = 'Unknown')\nOR (cd_marital_status = 'W' AND cd_education_status = 'Advanced Degree'))"
        }
      },
      {
        "step_id": "s2",
        "op": "replace_from",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "call_center\nJOIN catalog_returns ON cr_call_center_sk = cc_call_center_sk\nJOIN date_dim ON cr_returned_date_sk = d_date_sk\nJOIN filtered_customers ON cr_returning_customer_sk = c_customer_sk"
        }
      },
      {
        "step_id": "s3",
        "op": "replace_where_predicate",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "d_year = 1998\nAND d_moy = 2"
        }
      }
    ]
  }
]