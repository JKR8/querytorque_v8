{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The plan is dominated by a Gather Merge (parallel sort) of 27K rows from a nested loop join chain. The non-equi join condition between date_dim aliases (d1, d2) and comma-separated join syntax likely cause poor cardinality estimates and row amplification before aggregation. Early filtering of dimensions and explicit join conversion can reduce input to the sort and enable better join ordering.",
    "reasoning_trace": [
      "Gather Merge consumes 17.4 seconds sorting 27K rows from nested loop chain.",
      "Nested loop joins two date_dim aliases with a non-equi range condition (d1.d_date between d2.d_date - interval '120 day' and d2.d_date).",
      "Comma-separated join syntax may block optimizer from reordering joins effectively.",
      "Store_returns and store_sales are large fact tables; early reduction via dimension pre-filtering is plausible."
    ],
    "cost_spine": ["Nested Loop", "Gather Merge", "Aggregate", "Limit"],
    "hotspots": [
      {
        "op": "Gather Merge",
        "why": "parallel sort of 27K rows from nested loop chain",
        "evidence": "time=17449.309 ms, rows=81513"
      },
      {
        "op": "Nested Loop (d1-d2 non-equi join)",
        "why": "row amplification due to range condition and comma join",
        "evidence": "rows=39154, time=17502.676 ms"
      }
    ],
    "do_not_do": [
      "avoid OR-to-UNION split (PostgreSQL uses BitmapOr for indexed OR)",
      "avoid materializing EXISTS paths (PostgreSQL semi-join optimization is strong)",
      "avoid duplicating large CTE bodies"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "date_cte_explicit_join",
      "family": "A",
      "target": "Isolate date_dim filters into CTEs, convert comma joins to explicit JOINs, and push the non-equi join condition into the JOIN ON clause.",
      "dag_target_hint": "Change final_select FROM clause to use CTEs for d1 and d2 and explicit JOIN syntax.",
      "node_contract": {
        "from_must_include": ["store_sales", "store_returns", "store", "date_dim d1", "date_dim d2"],
        "where_must_preserve": ["d2.d_year = 1999", "d2.d_moy = 7", "ss_ticket_number = sr_ticket_number", "ss_item_sk = sr_item_sk", "ss_sold_date_sk = d1.d_date_sk", "sr_returned_date_sk = d2.d_date_sk", "ss_customer_sk = sr_customer_sk", "ss_store_sk = s_store_sk", "d1.d_date between (d2.d_date - interval '120 day') and d2.d_date"],
        "output_must_preserve": ["all original output columns", "GROUP BY and ORDER BY columns", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_NONEQUI_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Replace nested loops with hash joins, reduce rows passed to sort, eliminate Gather Merge.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Primary hotspot: addresses comma join weakness and non-equi join directly with native PostgreSQL transform.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p02",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre-filter all dimension tables (date_dim d1, date_dim d2, store) into CTEs and then join with fact tables using explicit JOINs.",
      "dag_target_hint": "Change final_select FROM clause to use CTEs for dimensions and explicit JOINs.",
      "node_contract": {
        "from_must_include": ["store_sales", "store_returns", "store", "date_dim d1", "date_dim d2"],
        "where_must_preserve": ["d2.d_year = 1999", "d2.d_moy = 7", "ss_ticket_number = sr_ticket_number", "ss_item_sk = sr_item_sk", "ss_sold_date_sk = d1.d_date_sk", "sr_returned_date_sk = d2.d_date_sk", "ss_customer_sk = sr_customer_sk", "ss_store_sk = s_store_sk", "d1.d_date between (d2.d_date - interval '120 day') and d2.d_date"],
        "output_must_preserve": ["all original output columns", "GROUP BY and ORDER BY columns", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_NONEQUI_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.82,
      "expected_explain_delta": "Reduce dimension table scans and use hash joins, reducing rows to sort.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Secondary hotspot: targets same comma join weakness with multi-dimension prefetch, native PostgreSQL.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p03",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Materialize filtered dimension rows and pre-filter fact rows before the non-equi join.",
      "dag_target_hint": "Change final_select to use CTEs for filtered dimensions and facts, then join.",
      "node_contract": {
        "from_must_include": ["store_sales", "store_returns", "store", "date_dim d1", "date_dim d2"],
        "where_must_preserve": ["d2.d_year = 1999", "d2.d_moy = 7", "ss_ticket_number = sr_ticket_number", "ss_item_sk = sr_item_sk", "ss_sold_date_sk = d1.d_date_sk", "sr_returned_date_sk = d2.d_date_sk", "ss_customer_sk = sr_customer_sk", "ss_store_sk = s_store_sk", "d1.d_date between (d2.d_date - interval '120 day') and d2.d_date"],
        "output_must_preserve": ["all original output columns", "GROUP BY and ORDER BY columns", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_NONEQUI_PRESENT:PASS", "G_PG_NONEQUI_CARDINALITY:PASS", "G_PG_NONEQUI_FILTER_QUALITY:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.78,
      "expected_explain_delta": "Reduce input sizes to the non-equi join, leading to fewer rows and faster sort.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Targets non-equi join bottleneck directly with strong gold example evidence.",
      "recommended_examples": ["pg_materialized_dimension_fact_prefilter"],
      "gold_example_id": "pg_materialized_dimension_fact_prefilter"
    },
    {
      "probe_id": "p04",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre-filter multiple dimension tables (date_dim d1, date_dim d2, store) into CTEs and then join with fact tables.",
      "dag_target_hint": "Change final_select FROM clause to use CTEs for dimensions.",
      "node_contract": {
        "from_must_include": ["store_sales", "store_returns", "store", "date_dim d1", "date_dim d2"],
        "where_must_preserve": ["d2.d_year = 1999", "d2.d_moy = 7", "ss_ticket_number = sr_ticket_number", "ss_item_sk = sr_item_sk", "ss_sold_date_sk = d1.d_date_sk", "sr_returned_date_sk = d2.d_date_sk", "ss_customer_sk = sr_customer_sk", "ss_store_sk = s_store_sk", "d1.d_date between (d2.d_date - interval '120 day') and d2.d_date"],
        "output_must_preserve": ["all original output columns", "GROUP BY and ORDER BY columns", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_NONEQUI_PRESENT:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:REQUIRE_MANUAL_REVIEW"],
      "exploration": true,
      "exploration_hypothesis": "Portability candidate from DuckDB; may improve predicate pushdown and join order in PostgreSQL despite being non-native.",
      "confidence": 0.55,
      "expected_explain_delta": "Reduce dimension table scans and use hash joins, reducing rows to sort.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Exploration: portability candidate targeting same multi-dimension pattern, lower confidence due to engine mismatch.",
      "recommended_examples": ["multi_dimension_prefetch"]
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan evidence; PostgreSQL uses BitmapOr for indexed OR."
    },
    {
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "reason": "No correlated scalar subquery in SQL or plan evidence."
    },
    {
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "reason": "Previous attempt_1 failed with this transform; plan shows no repeated scans of same CTE."
    },
    {
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "reason": "Aggregate is final operation after all joins; no intermediate aggregate pushdown opportunity evident."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No set operations (INTERSECT) in query."
    }
  ]
}