[  {
    "plan_id": "compile_p1",
    "dialect": "postgres",
    "confidence": 0.85,
    "based_on": "p12,p01",
    "strategy": "Replace INTERSECT with EXISTS semi‑joins and pre‑filter date_dim/item to avoid full materialization.",
    "hypothesis": "Probe p12 (57.17x) shows converting INTERSECT to EXISTS with pre‑filtered dimensions eliminates the largest hotspot (25s cross_items). This pathway preserves semantics while removing expensive set‑operation materialization.",
    "expected_explain_delta": "INTERSECT operators replaced by EXISTS semi‑joins; date_dim and item filters pushed into early CTEs; reduced input rows to fact‑table joins.",
    "target_ir": "Rewrite cross_items node to use EXISTS with pre‑filtered date_dim and item; leave avg_sales and final_select unchanged.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["store_sales", "item", "date_dim", "avg_sales", "cross_items"],
          "outputs": ["ty_channel", "ty_brand", "ty_class", "ty_category", "ty_sales", "ty_number_sales", "ly_channel", "ly_brand", "ly_class", "ly_category", "ly_sales", "ly_number_sales"],
          "changed": false
        },
        {
          "node_id": "avg_sales",
          "parent_node_id": "final_select",
          "sources": ["web_sales", "date_dim", "store_sales", "catalog_sales"],
          "outputs": ["average_sales"],
          "changed": false
        },
        {
          "node_id": "cross_items",
          "parent_node_id": "final_select",
          "sources": ["item", "web_sales", "date_dim", "store_sales", "catalog_sales"],
          "outputs": ["ss_item_sk"],
          "changed": true,
          "sql": "WITH date_filter AS (SELECT d_date_sk FROM date_dim WHERE d_year BETWEEN 1999 AND 1999 + 2), channel_store AS (SELECT iss.i_item_sk, iss.i_brand_id, iss.i_class_id, iss.i_category_id FROM store_sales ss JOIN item iss ON ss.ss_item_sk = iss.i_item_sk JOIN date_filter df ON ss.ss_sold_date_sk = df.d_date_sk WHERE iss.i_category IN ('Electronics', 'Shoes', 'Sports') AND iss.i_manager_id BETWEEN 42 AND 51 AND ss.ss_wholesale_cost BETWEEN 76 AND 96), channel_catalog AS (SELECT ics.i_item_sk, ics.i_brand_id, ics.i_class_id, ics.i_category_id FROM catalog_sales cs JOIN item ics ON cs.cs_item_sk = ics.i_item_sk JOIN date_filter df ON cs.cs_sold_date_sk = df.d_date_sk WHERE ics.i_category IN ('Electronics', 'Shoes', 'Sports') AND ics.i_manager_id BETWEEN 42 AND 51 AND cs.cs_wholesale_cost BETWEEN 76 AND 96), channel_web AS (SELECT iws.i_item_sk, iws.i_brand_id, iws.i_class_id, iws.i_category_id FROM web_sales ws JOIN item iws ON ws.ws_item_sk = iws.i_item_sk JOIN date_filter df ON ws.ws_sold_date_sk = df.d_date_sk WHERE iws.i_category IN ('Electronics', 'Shoes', 'Sports') AND iws.i_manager_id BETWEEN 42 AND 51 AND ws.ws_wholesale_cost BETWEEN 76 AND 96) SELECT i.i_item_sk AS ss_item_sk FROM item i WHERE i.i_category IN ('Electronics', 'Shoes', 'Sports') AND i.i_manager_id BETWEEN 42 AND 51 AND EXISTS (SELECT 1 FROM channel_store cs WHERE cs.i_brand_id = i.i_brand_id AND cs.i_class_id = i.i_class_id AND cs.i_category_id = i.i_category_id) AND EXISTS (SELECT 1 FROM channel_catalog cc WHERE cc.i_brand_id = i.i_brand_id AND cc.i_class_id = i.i_class_id AND cc.i_category_id = i.i_category_id) AND EXISTS (SELECT 1 FROM channel_web cw WHERE cw.i_brand_id = i.i_brand_id AND cw.i_class_id = i.i_class_id AND cw.i_category_id = i.i_category_id)"
        }
      ]
    }
  },
  {
    "plan_id": "compile_p2",
    "dialect": "postgres",
    "confidence": 0.80,
    "based_on": "p11,p07",
    "strategy": "Convert comma joins to explicit INNER JOIN, materialize CTEs for reuse, and decorrelate d_week_seq subqueries.",
    "hypothesis": "Probe p11 (19.65x) demonstrates that explicit joins with MATERIALIZED CTEs improve cardinality estimation and enable better join reordering. Adding decorrelation from p07 (30.69x) removes repeated scalar subquery execution.",
    "expected_explain_delta": "Comma joins become explicit INNER JOINs; cross_items and avg_sales are materialized; d_week_seq subqueries are pre‑computed; nested‑loop correlation removed.",
    "target_ir": "Restructure final_select into this_year/last_year CTEs with explicit joins; add materialized date‑key CTEs; keep cross_items and avg_sales as materialized CTEs.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["this_year", "last_year"],
          "outputs": ["ty_channel", "ty_brand", "ty_class", "ty_category", "ty_sales", "ty_number_sales", "ly_channel", "ly_brand", "ly_class", "ly_category", "ly_sales", "ly_number_sales"],
          "changed": true,
          "sql": "SELECT this_year.channel ty_channel, this_year.i_brand_id ty_brand, this_year.i_class_id ty_class, this_year.i_category_id ty_category, this_year.sales ty_sales, this_year.number_sales ty_number_sales, last_year.channel ly_channel, last_year.i_brand_id ly_brand, last_year.i_class_id ly_class, last_year.i_category_id ly_category, last_year.sales ly_sales, last_year.number_sales ly_number_sales FROM this_year INNER JOIN last_year ON this_year.i_brand_id = last_year.i_brand_id AND this_year.i_class_id = last_year.i_class_id AND this_year.i_category_id = last_year.i_category_id ORDER BY this_year.channel, this_year.i_brand_id, this_year.i_class_id, this_year.i_category_id LIMIT 100"
        },
        {
          "node_id": "this_year",
          "parent_node_id": "final_select",
          "sources": ["store_sales", "item", "date_dim", "cross_items", "avg_sales", "d_week_seq_2000"],
          "outputs": ["channel", "i_brand_id", "i_class_id", "i_category_id", "sales", "number_sales"],
          "changed": true,
          "sql": "SELECT 'store' channel, i.i_brand_id, i.i_class_id, i.i_category_id, sum(ss.ss_quantity * ss.ss_list_price) sales, count(*) number_sales FROM store_sales ss INNER JOIN item i ON ss.ss_item_sk = i.i_item_sk INNER JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk WHERE ss.ss_item_sk IN (SELECT ss_item_sk FROM cross_items) AND d.d_week_seq = (SELECT d_week_seq FROM d_week_seq_2000) AND i.i_category IN ('Electronics', 'Shoes', 'Sports') AND i.i_manager_id BETWEEN 42 AND 51 AND ss.ss_wholesale_cost BETWEEN 76 AND 96 GROUP BY i.i_brand_id, i.i_class_id, i.i_category_id HAVING sum(ss.ss_quantity * ss.ss_list_price) > (SELECT average_sales FROM avg_sales)"
        },
        {
          "node_id": "last_year",
          "parent_node_id": "final_select",
          "sources": ["store_sales", "item", "date_dim", "cross_items", "avg_sales", "d_week_seq_1999"],
          "outputs": ["channel", "i_brand_id", "i_class_id", "i_category_id", "sales", "number_sales"],
          "changed": true,
          "sql": "SELECT 'store' channel, i.i_brand_id, i.i_class_id, i.i_category_id, sum(ss.ss_quantity * ss.ss_list_price) sales, count(*) number_sales FROM store_sales ss INNER JOIN item i ON ss.ss_item_sk = i.i_item_sk INNER JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk