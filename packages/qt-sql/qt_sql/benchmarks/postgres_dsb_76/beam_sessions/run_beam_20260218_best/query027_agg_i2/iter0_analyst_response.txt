{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Nested loops dominate runtime (2672ms) due to repeated index scans on store_sales (0 rows, 21.936ms per scan) driven by outer date_dim (122 rows) and store (1 row). The plan shows zero rows flowing through joins, indicating a cardinality estimation failure (est=536, act=0) and potential predicate misapplication. Early filtering of dimensions into materialized CTEs may reduce nested loop iterations and enable better join planning.",
    "reasoning_trace": [
      "Primary hotspot: Nested Loop with inner Index Only Scan on store_sales (time=21.936ms, repeated ~122 times).",
      "Cardinality estimation error: Nested Loop node estimated 536 rows but actual is 0, indicating poor selectivity propagation.",
      "Plan shows zero rows from fact table despite selective dimension filters, suggesting join order or predicate pushdown failure.",
      "All dimension scans are fast (date_dim 0.598ms, store 0.017ms) but drive expensive nested loops."
    ],
    "cost_spine": ["Nested Loop", "Nested Loop", "Index Only Scan on store_sales", "Aggregate", "Sort", "Limit"],
    "hotspots": [
      {
        "op": "Nested Loop (store_sales path)",
        "why": "Repeated index scans on large fact table driven by outer dimension rows.",
        "evidence": "time=21.954ms for 0 rows, inner scan repeated ~122 times (date_dim rows * store rows)."
      },
      {
        "op": "Cardinality estimation at Nested Loop",
        "why": "Poor row estimates (est=536, act=0) may cause suboptimal join method selection.",
        "evidence": "Q-Error direction ZERO_EST at JOIN locus."
      }
    ],
    "do_not_do": [
      "or_to_union transform (PostgreSQL BitmapOr handles indexed OR well)",
      "decorrelate transforms (no correlated subqueries in SQL)",
      "duplicate heavy CTE bodies (respect G_PG_CTE_DUPLICATION_BLOCK)",
      "materialize EXISTS paths (no EXISTS in query)"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre-filter all selective dimensions (date_dim, store, item, customer_demographics) into MATERIALIZED CTEs, then join with store_sales using explicit JOIN syntax. Convert comma joins to INNER JOIN ON.",
      "dag_target_hint": "Replace final_select FROM clause with CTE references and explicit joins.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim", "store", "item", "customer_demographics"],
        "where_must_preserve": ["d_year = 1999", "s_state = 'OH'", "i_category = 'Music'", "cd_gender = 'M'", "cd_marital_status = 'W'", "cd_education_status = 'Secondary'"],
        "output_must_preserve": ["i_item_id", "s_state", "g_state", "agg1", "agg2", "agg3", "agg4", "GROUP BY ROLLUP", "ORDER BY", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS", "G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Nested Loop replaced by Hash Joins, Index Only Scan on store_sales becomes a single scan with early filter pushdown, row estimates improve.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Primary hotspot coverage: addresses nested loop amplification by pre-filtering dimensions and enabling explicit join planning.",
      "recommended_examples": ["pg_dimension_prefetch_star", "pg_explicit_join_materialized"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p02",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Materialize filtered date_dim into a CTE, convert comma joins to explicit INNER JOIN ON, and join with store_sales early to reduce nested loop iterations.",
      "dag_target_hint": "Change final_select FROM clause to use date_cte and explicit joins.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim", "store", "item", "customer_demographics"],
        "where_must_preserve": ["d_year = 1999", "s_state = 'OH'", "i_category = 'Music'", "cd_gender = 'M'", "cd_marital_status = 'W'", "cd_education_status = 'Secondary'"],
        "output_must_preserve": ["i_item_id", "s_state", "g_state", "agg1", "agg2", "agg3", "agg4", "GROUP BY ROLLUP", "ORDER BY", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.70,
      "expected_explain_delta": "Nested Loop on date_dim path replaced by Hash Join, reduced iterations of store_sales scan.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Secondary hotspot coverage: focuses on date_dim as driver of nested loops, explicit join syntax may improve cardinality estimates.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p03",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre-filter date_dim, store, item, customer_demographics into separate CTEs, then join all CTEs with store_sales in a single FROM clause using comma joins (preserving original join style).",
      "dag_target_hint": "Replace final_select FROM clause with CTE references and original comma-join pattern.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim", "store", "item", "customer_demographics"],
        "where_must_preserve": ["d_year = 1999", "s_state = 'OH'", "i_category = 'Music'", "cd_gender = 'M'", "cd_marital_status = 'W'", "cd_education_status = 'Secondary'"],
        "output_must_preserve": ["i_item_id", "s_state", "g_state", "agg1", "agg2", "agg3", "agg4", "GROUP BY ROLLUP", "ORDER BY", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:WARN", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Pre-filtering all dimensions into CTEs while keeping comma joins may improve predicate pushdown and reduce nested loop iterations without changing join syntax.",
      "confidence": 0.55,
      "expected_explain_delta": "Nested Loop inner scans reduced, dimension CTEs materialized once, better row estimates for store_sales join.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Exploration: tests if pre-filtering dimensions alone (without explicit join syntax) is sufficient to fix nested loop.",
      "recommended_examples": ["multi_dimension_prefetch"],
      "gold_example_id": "multi_dimension_prefetch"
    },
    {
      "probe_id": "p04",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize the join of store_sales with all filtered dimensions into a single CTE, then compute aggregates and rollup from that CTE. This forces materialization of the reduced fact set.",
      "dag_target_hint": "Replace entire final_select with a CTE containing the filtered join, then aggregate.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim", "store", "item", "customer_demographics"],
        "where_must_preserve": ["d_year = 1999", "s_state = 'OH'", "i_category = 'Music'", "cd_gender = 'M'", "cd_marital_status = 'W'", "cd_education_status = 'Secondary'"],
        "output_must_preserve": ["i_item_id", "s_state", "g_state", "agg1", "agg2", "agg3", "agg4", "GROUP BY ROLLUP", "ORDER BY", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_EXISTS_INTERSECT_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Materializing the filtered join result may bypass nested loop planning issues and provide stable input to aggregation, though may reduce parallelism.",
      "confidence": 0.50,
      "expected_explain_delta": "Nested Loops replaced by Hash Joins inside CTE, CTE Scan followed by Aggregate, possible loss of parallelism.",
      "recommended_patch_ops": ["insert_cte", "replace_entire_query"],
      "rank_rationale": "Exploration: tests if materialization fence improves cardinality estimates and join planning for this specific zero-row intermediate result.",
      "recommended_examples": ["pg_self_join_decomposition"],
      "gold_example_id": "pg_self_join_decomposition"
    }
  ],
  "dropped": [
    {
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "reason": "No evidence of aggregate after large join in plan; previous attempt failed. Grouping keys (i_item_id, s_state) require dimension columns, preventing safe pushdown below joins."
    },
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate in SQL; PostgreSQL BitmapOr handles indexed OR well (regression guard)."
    },
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated subqueries in SQL; plan shows no nested loops from correlation."
    },
    {
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "reason": "Engine-specific to Snowflake, not native to PostgreSQL runtime dialect."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT operations in SQL."
    }
  ]
}