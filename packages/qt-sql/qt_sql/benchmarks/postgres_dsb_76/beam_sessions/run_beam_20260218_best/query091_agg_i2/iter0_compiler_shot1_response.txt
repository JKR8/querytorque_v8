[
  {
    "plan_id": "compile_p1",
    "dialect": "postgres",
    "hypothesis": "All workers regressed. Residual gap: primary scan of 719k catalog_returns rows remains unaddressed. Original plan nests loops after large hash join, applying selective filters late. Hypothesis: push customer‑dimension filters early into a pre‑filtered CTE, then join to catalog_returns via returning_customer_sk index to reduce fact‑table probe rows.",
    "target_ir": "Add filtered_customer CTE to apply OR predicate and dimension filters before joining to catalog_returns.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["filtered_customer", "catalog_returns", "date_dim", "call_center"],
          "outputs": ["Call_Center", "Call_Center_Name", "Manager", "Returns_Loss"],
          "changed": true,
          "sql": "WITH filtered_customer AS (\n  SELECT \n    c.c_customer_sk,\n    cd.cd_marital_status,\n    cd.cd_education_status\n  FROM customer c\n  JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk\n  JOIN household_demographics hd ON c.c_current_hdemo_sk = hd.hd_demo_sk\n  JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk\n  WHERE \n    hd.hd_buy_potential LIKE '>10000%'\n    AND ca.ca_gmt_offset = -6\n    AND ( (cd.cd_marital_status = 'M' AND cd.cd_education_status = 'Unknown')\n          OR (cd.cd_marital_status = 'W' AND cd.cd_education_status = 'Advanced Degree') )\n)\nSELECT \n  cc.cc_call_center_id AS Call_Center,\n  cc.cc_name AS Call_Center_Name,\n  cc.cc_manager AS Manager,\n  SUM(cr.cr_net_loss) AS Returns_Loss\nFROM \n  filtered_customer fc\n  JOIN catalog_returns cr ON fc.c_customer_sk = cr.cr_returning_customer_sk\n  JOIN date_dim d ON cr.cr_returned_date_sk = d.d_date_sk\n  JOIN call_center cc ON cr.cr_call_center_sk = cc.cc_call_center_sk\nWHERE \n  d.d_year = 2001\n  AND d.d_moy = 12\nGROUP BY \n  cc.cc_call_center_id, \n  cc.cc_name, \n  cc.cc_manager,\n  fc.cd_marital_status,\n  fc.cd_education_status\nORDER BY \n  SUM(cr.cr_net_loss) DESC"
        },
        {
          "node_id": "filtered_customer",
          "parent_node_id": "final_select",
          "sources": ["customer", "customer_demographics", "household_demographics", "customer_address"],
          "outputs": ["c_customer_sk", "cd_marital_status", "cd_education_status"],
          "changed": true,
          "sql": "SELECT \n    c.c_customer_sk,\n    cd.cd_marital_status,\n    cd.cd_education_status\n  FROM customer c\n  JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk\n  JOIN household_demographics hd ON c.c_current_hdemo_sk = hd.hd_demo_sk\n  JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk\n  WHERE \n    hd.hd_buy_potential LIKE '>10000%'\n    AND ca.ca_gmt_offset = -6\n    AND ( (cd.cd_marital_status = 'M' AND cd.cd_education_status = 'Unknown')\n          OR (cd.cd_marital_status = 'W' AND cd.cd_education_status = 'Advanced Degree') )"
        }
      ]
    },
    "confidence": 0.5,
    "based_on": "p01,p02",
    "strategy": "Early dimension filtering via CTE to reduce fact-table probe rows before joining.",
    "expected_explain_delta": "Seq Scan on catalog_returns replaced with an Index Scan on cr_returning_customer_sk, nested loops on customer/customer_demographics eliminated, early hash join on filtered dimensions."
  },
  {
    "plan_id": "compile_p2",
    "dialect": "postgres",
    "hypothesis": "Residual gap remains: 719k catalog_returns scan. Worker p04 attempted explicit‑join cleanup but regressed. Second pathway: keep comma‑join shape but add LATERAL join to push customer‑dimension filters before fact‑table join, using PostgreSQL’s ability to correlate the lateral subquery.",
    "target_ir": "Use LATERAL subquery to filter customer dimensions and join directly to catalog_returns.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["call_center", "catalog_returns", "date_dim", "customer_lateral"],
          "outputs": ["Call_Center", "Call_Center_Name", "Manager", "Returns_Loss"],
          "changed": true,
          "sql": "SELECT \n  cc.cc_call_center_id AS Call_Center,\n  cc.cc_name AS Call_Center_Name,\n  cc.cc_manager AS Manager,\n  SUM(cr.cr_net_loss) AS Returns_Loss\nFROM \n  call_center cc,\n  catalog_returns cr,\n  date_dim d,\n  LATERAL (\n    SELECT \n      c.c_customer_sk,\n      cd.cd_marital_status,\n      cd.cd_education_status\n    FROM \n      customer c\n      JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk\n      JOIN household_demographics hd ON c.c_current_hdemo_sk = hd.hd_demo_sk\n      JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk\n    WHERE \n      cr.cr_returning_customer_sk = c.c_customer_sk\n      AND hd.hd_buy_potential LIKE '>10000%'\n      AND ca.ca_gmt_offset = -6\n      AND ( (cd.cd_marital_status = 'M' AND cd.cd_education_status = 'Unknown')\n            OR (cd.cd_marital_status = 'W' AND cd.cd_education_status = 'Advanced Degree') )\n  ) fc\nWHERE \n  cr.cr_call_center_sk = cc.cc_call_center_sk\n  AND cr.cr_returned_date_sk = d.d_date_sk\n  AND d.d_year = 2001\n  AND d.d_moy = 12\nGROUP BY \n  cc.cc_call_center_id, \n  cc.cc_name, \n  cc.cc_manager,\n  fc.cd_marital_status,\n  fc.cd_education_status\nORDER BY \n  SUM(cr.cr_net_loss) DESC"
        }
      ]
    },
    "confidence": 0.4,
    "based_on": "p04",
    "strategy": "LATERAL join to correlate dimension filters with fact table, preserving comma‑join structure but enabling early filter push.",
    "expected_explain_delta": "Nested Loop with LATERAL subplan, allowing index scan on catalog_returns.cr_returning_customer_sk and early elimination of filtered dimension rows."
  }
]