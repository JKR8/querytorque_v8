{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The query is dominated by a correlated scalar subquery re-executing 2,902 times (CTE Scan ctr1 rows) against a materialized CTE (ctr2 rows=2,394), causing a nested loop with 6.95M row re-scans. The primary bottleneck is the correlated subquery in the WHERE clause comparing ctr_total_return to a per-store average. Secondary hotspots include the initial CTE materialization (store_returns scan) and late application of dimension filters.",
    "reasoning_trace": [
      "Correlated subquery (Aggregate over ctr2) is executed 2,902 times (CTE Scan ctr1 rows) with each iteration scanning 2,394 rows (CTE Scan ctr2), total ~6.95M row rescans.",
      "Plan shows Nested Loop with correlated SubPlan (est=1, act=2,902) — classic CORRELATED_SUBQUERY_PARALYSIS pattern.",
      "Initial CTE customer_total_return materializes 2,902 rows from store_returns (7.2M rows) with selective date_dim filter (d_year=2000).",
      "Dimension filters (store.s_state IN, customer_demographics filters) are applied late after the expensive correlated loop.",
      "No OR predicates or set operations present; all joins are inner equi-joins."
    ],
    "cost_spine": ["CTE Scan (ctr1)", "Nested Loop (correlated subquery)", "Aggregate (subquery)", "CTE Scan (ctr2)", "Nested Loop (main joins)"],
    "hotspots": [
      {
        "op": "Nested Loop (correlated subquery)",
        "why": "Correlated scalar aggregate re-executes per outer row (2,902 iterations)",
        "evidence": "rows=2902 time=262783.827ms (99.8% of total)"
      },
      {
        "op": "CTE Scan (ctr1)",
        "why": "Materialized CTE with 2,902 rows drives correlated loop",
        "evidence": "rows=2902 time=262448.563ms"
      },
      {
        "op": "CTE customer_total_return materialization",
        "why": "Initial aggregation scans 7.2M row store_returns table",
        "evidence": "store_returns scan with date_dim filter, rows=2902 output"
      }
    ],
    "do_not_do": [
      "Avoid OR-to-UNION transforms (no OR predicates in plan)",
      "Avoid materializing EXISTS paths (no EXISTS in query)",
      "Avoid duplicating heavy CTE bodies (CTE already materialized)",
      "Do not split same-column indexed OR predicates (none present)"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "target": "Decompose correlated scalar subquery into 3 MATERIALIZED CTEs: (1) pre-filtered store_returns with date_dim, (2) per-store_sk average threshold (avg(ctr_total_return)*1.2), (3) main query joining threshold CTE via store_sk.",
      "dag_target_hint": "Replace final_select WHERE subquery with JOIN to threshold_cte.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["ctr1.ctr_reason_sk BETWEEN 17 AND 20", "s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.95,
      "expected_explain_delta": "Correlated Nested Loop disappears; replaced by Hash Join between ctr1 and threshold CTE; single scan of store_returns for threshold computation.",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate", "replace_from"],
      "rank_rationale": "Primary hotspot — directly addresses correlated subquery paralysis with native PostgreSQL transform.",
      "recommended_examples": ["pg_shared_scan_decorrelate", "inline_decorrelate_materialized"],
      "gold_example_id": "pg_shared_scan_decorrelate"
    },
    {
      "probe_id": "p02",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Push dimension filters into CTE definitions before materialization, and decorrelate subquery by pre-computing thresholds in separate CTE with early filtering.",
      "dag_target_hint": "Modify customer_total_return CTE to include store.s_state filter and customer_demographics filters earlier.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["ctr1.ctr_reason_sk BETWEEN 17 AND 20", "s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Correlated loop removed; dimension filters applied earlier reducing rows into main join; threshold CTE computed once.",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate", "replace_from"],
      "rank_rationale": "Alternative decorrelation approach with early filtering, targets same primary hotspot.",
      "recommended_examples": ["early_filter_decorrelate"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p03",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize the store_returns + date_dim scan once as a CTE, then derive both ctr1 and ctr2 aggregates from the same materialized result to avoid re-scanning store_returns.",
      "dag_target_hint": "Replace customer_total_return CTE with a materialized base CTE, then compute ctr1 and ctr2 aggregates from it.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity between 115 and 174"],
        "output_must_preserve": ["sr_customer_sk", "sr_store_sk", "sr_reason_sk", "SR_RETURN_AMT_INC_TAX"]
      },
      "gates_checked": ["G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_EXISTS_INTERSECT_RISK:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Single materialized scan of store_returns; two aggregate CTEs read from same materialization; reduces I/O.",
      "recommended_patch_ops": ["insert_cte", "replace_cte_definition"],
      "rank_rationale": "Addresses CTE materialization hotspot by sharing scan; reduces store_returns I/O.",
      "recommended_examples": ["pg_self_join_decomposition"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p04",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Convert comma-separated joins to explicit JOIN syntax and isolate selective date_dim filter into a tiny CTE to create small hash table for store_returns probe.",
      "dag_target_hint": "Change customer_total_return CTE from comma join to explicit INNER JOIN and pre-filter date_dim.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["sr_returned_date_sk = d_date_sk", "d_year = 2000", "sr_return_amt / sr_return_quantity between 115 and 174"],
        "output_must_preserve": ["sr_customer_sk", "sr_store_sk", "sr_reason_sk", "SR_RETURN_AMT_INC_TAX"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.70,
      "expected_explain_delta": "Explicit join enables better hash join planning; date_dim CTE reduces rows early.",
      "recommended_patch_ops": ["replace_from", "insert_cte"],
      "rank_rationale": "Addresses comma join weakness and early filtering; secondary hotspot.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p05",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre-filter all selective dimensions (store, customer, customer_demographics) into separate CTEs before joining with fact CTEs, using explicit JOIN syntax.",
      "dag_target_hint": "Wrap store, customer, customer_demographics filters into CTEs and join explicitly in final_select.",
      "node_contract": {
        "from_must_include": ["store", "customer", "customer_demographics"],
        "where_must_preserve": ["s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.65,
      "expected_explain_delta": "Dimension CTEs become tiny hash tables; main join cardinality drops significantly.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Targets secondary hotspot of late dimension filters; uses explicit join improvement.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p05",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Stage reduction via MATERIALIZED CTEs for both dimension filters and fact table before the non-equi join (ctr_total_return > threshold).",
      "dag_target_hint": "Create MATERIALIZED CTEs for filtered dimensions and pre-aggregated store_returns, then join with threshold CTE.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["ctr1.ctr_reason_sk BETWEEN 17 AND 20", "s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_NONEQUI_PRESENT:PASS", "G_PG_NONEQUI_CARDINALITY:PASS", "G_PG_NONEQUI_FILTER_QUALITY:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Non-equi join (>) between ctr_total_return and precomputed threshold may benefit from staged reduction of both sides.",
      "confidence": 0.60,
      "expected_explain_delta": "Both sides of non-equi join are pre-reduced via MATERIALIZED CTEs, cutting search space.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Exploration — tests non-equi join input reduction pattern.",
      "recommended_examples": ["pg_materialized_dimension_fact_prefilter"],
      "gold_example_id": "pg_materialized_dimension_fact_prefilter"
    },
    {
      "probe_id": "p06",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate store_returns by customer_sk, store_sk, reason_sk before joining with date_dim, pushing aggregation below the date join.",
      "dag_target_hint": "Modify customer_total_return CTE to aggregate store_returns first, then join with filtered date_dim.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity between 115 and 174"],
        "output_must_preserve": ["sr_customer_sk", "sr_store_sk", "sr_reason_sk", "sum(SR_RETURN_AMT_INC_TAX)"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Aggregation after join may amplify rows; pushing aggregation before date join could reduce intermediate rows.",
      "confidence": 0.55,
      "expected_explain_delta": "Aggregate node moves below join; fewer rows flow into date_dim join.",
      "recommended_patch_ops": ["replace_cte_definition"],
      "rank_rationale": "Exploration — tests aggregation pushdown family on initial CTE materialization.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p07",
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "target": "Build a CTE chain: first CTE filters date_dim, second CTE pre-joins filtered date keys with store_returns, third CTE aggregates, staging progressive reduction.",
      "dag_target_hint": "Replace customer_total_return CTE with a chain of CTEs: date_filter -> fact_join -> aggregate.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity between 115 and 174"],
        "output_must_preserve": ["sr_customer_sk", "sr_store_sk", "sr_reason_sk", "sum(SR_RETURN_AMT_INC_TAX)"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Staged join pipeline may allow better predicate pushdown and reduce rows earlier.",
      "confidence": 0.50,
      "expected_explain_delta": "Multiple CTEs with explicit joins; date filter applied before store_returns scan.",
      "recommended_patch_ops": ["insert_cte", "replace_cte_definition"],
      "rank_rationale": "Exploration — tests early filtering family with staged CTE chain.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p08",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Pre-filter store, customer, customer_demographics into separate CTEs returning only surrogate keys before joining with fact CTEs.",
      "dag_target_hint": "Create CTEs for store_filtered, customer_filtered, cd_filtered with only key columns.",
      "node_contract": {
        "from_must_include": ["store", "customer", "customer_demographics"],
        "where_must_preserve": ["s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["s_store_sk", "c_customer_sk", "cd_demo_sk"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Tiny dimension hash tables may improve join planning and reduce probe cost.",
      "confidence": 0.50,
      "expected_explain_delta": "Dimension CTEs become tiny; hash joins use small build side.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Exploration — alternative early filtering approach focusing on dimension isolation.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p09",
      "transform_id": "single_pass_aggregation",
      "family": "C",
      "target": "Consolidate the two aggregates (customer_total_return CTE and subquery threshold) into a single CTE that computes both per-store aggregates in one pass over store_returns.",
      "dag_target_hint": "Create a single CTE that groups by store_sk and returns both sum(SR_RETURN_AMT_INC_TAX) and avg(ctr_total_return)*1.2.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity between 115 and 174"],
        "output_must_preserve": ["sr_store_sk", "total_return_sum", "store_avg_threshold"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Single pass over store_returns could compute both aggregates, eliminating separate CTE scan for threshold.",
      "confidence": 0.55,
      "expected_explain_delta": "One aggregate CTE instead of two; eliminates separate scan of ctr2.",
      "recommended_patch_ops": ["insert_cte", "replace_cte_definition"],
      "rank_rationale": "Exploration — tests single-pass aggregation to reduce redundant scans.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p10",
      "transform_id": "channel_bitmap_aggregation",
      "family": "C",
      "target": "Consolidate store_returns scan with conditional aggregation for both the main CTE and threshold computation using CASE expressions.",
      "dag_target_hint": "Modify customer_total_return CTE to include CASE for threshold calculation in same aggregation.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity between 115 and 174"],
        "output_must_preserve": ["sr_customer_sk", "sr_store_sk", "sr_reason_sk", "SR_RETURN_AMT_INC_TAX"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Conditional aggregation within a single scan could compute multiple metrics, reducing I/O.",
      "confidence": 0.45,
      "expected_explain_delta": "Single scan with conditional aggregates; threshold computed alongside per-group sums.",
      "recommended_patch_ops": ["replace_cte_definition"],
      "rank_rationale": "Exploration — tests consolidation of multiple aggregates into one scan.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p11",
      "transform_id": "deferred_window_aggregation",
      "family": "C",
      "target": "Delay aggregation until after dimension joins, using window functions or subqueries to compute per-store averages after rows are reduced.",
      "dag_target_hint": "Move aggregation out of CTE into final query, computing averages over reduced row set.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["ctr1.ctr_reason_sk BETWEEN 17 AND 20", "s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Aggregating after joins may reduce work if joins are highly selective.",
      "confidence": 0.40,
      "expected_explain_delta": "Aggregation moves to final query; CTE becomes a simple scan.",
      "recommended_patch_ops": ["replace_cte_definition", "replace_select"],
      "rank_rationale": "Exploration — tests deferred aggregation family.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p12",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Explicitly materialize the customer_total_return CTE with MATERIALIZED keyword to ensure PostgreSQL materializes it once, preventing inlining that might hinder decorrelation.",
      "dag_target_hint": "Add MATERIALIZED keyword to customer_total_return CTE definition.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity between 115 and 174"],
        "output_must_preserve": ["sr_customer_sk", "sr_store_sk", "sr_reason_sk", "sum(SR_RETURN_AMT_INC_TAX)"]
      },
      "gates_checked": ["G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_EXISTS_INTERSECT_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Explicit materialization may help decorrelation transforms by preventing inlining of CTE back into correlated form.",
      "confidence": 0.40,
      "expected_explain_delta": "CTE becomes a materialization fence; may improve decorrelation effectiveness.",
      "recommended_patch_ops": ["add_keyword"],
      "rank_rationale": "Exploration — tests materialization fence control for decorrelation.",
      "recommended_examples": [],
      "gold_example_id": ""
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan evidence; PostgreSQL BitmapOr handles indexed OR well."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT operations in query."
    },
    {
      "transform_id": "union_cte_split",
      "family": "D",
      "reason": "No UNION or repeated CTE scans with different filters."
    },
    {
      "transform_id": "rollup_to_union_windowing",
      "family": "D",
      "reason": "No ROLLUP or hierarchy aggregation in query."
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "All joins are already inner equi-joins; no LEFT JOIN with NULL filter."
    },
    {
      "transform_id": "self_join_decomposition",
      "family": "F",
      "reason": "No self-join of same CTE with different filters."
    },
    {
      "transform_id": "multi_date_range_cte",
      "family": "A",
      "reason": "Date dimension joined only once with single filter (d_year=2000)."
    },
    {
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "reason": "No multiple channel CTEs with shared dimension filters."
    },
    {
      "transform_id": "composite_decorrelate_union",
      "family": "B",
      "reason": "Only one correlated subquery; no multiple EXISTS to combine."
    },
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "Transform is portability_candidate for duckdb; prefer native PostgreSQL transforms (inline_decorrelate_materialized, early_filter_decorrelate)."
    },
    {
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "reason": "Transform is portability_candidate for Snowflake; not native to PostgreSQL."
    },
    {
      "transform_id": "sf_shared_scan_decorrelate",
      "family": "B",
      "reason": "Transform is portability_candidate for Snowflake; not native to PostgreSQL."
    },
    {
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "reason": "Transform is portability_candidate for Snowflake; not applicable to PostgreSQL."
    },
    {
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "reason": "Transform is portability_candidate for Snowflake; not applicable to PostgreSQL."
    }
  ]
}