{
  "probe_id": "scout_001",
  "transform_id": "materialized_dimension_fact_prefilter",
  "family": "F",
  "status": "success",
  "dialect": "postgresql",
  "hypothesis": "Materializing a CTE that pre-filters catalog_sales with selective dimension joins reduces rows before the expensive sort and aggregation. This addresses the Nested Loop pathology where catalog_sales is scanned 30 times.",
  "reasoning_trace": [
    "Nested Loop between date_dim (30 rows) and catalog_sales dominates runtime; pre-filtering catalog_sales early should reduce inner loop iterations.",
    "Explicit JOIN syntax enables better join reordering and cardinality estimation versus comma joins.",
    "Materialized CTE encapsulates selective dimension filters, allowing reuse and reducing fact table probe size."
  ],
  "target_ir": "Introduce a MATERIALIZED CTE named `filtered_sales` that joins catalog_sales with date_dim, item, and warehouse using inner joins. The final query joins this CTE with catalog_returns and performs aggregation.",
  "verification": {
    "executable": true,
    "no_missing_tables": true,
    "alias_consistent": true,
    "no_orphan_scans": true,
    "semantics_preserved": true,
    "null_semantics_safe": true,
    "ctes_selective_or_na": true
  },
  "tree": {
    "root_node_id": "final_select",
    "nodes": [
      {
        "node_id": "final_select",
        "parent_node_id": null,
        "sources": ["filtered_sales", "catalog_returns", "warehouse", "item"],
        "outputs": ["w_state", "i_item_id", "sales_before", "sales_after"],
        "changed": true,
        "sql": "SELECT w.w_state, i.i_item_id, SUM(CASE WHEN (CAST(d.d_date AS DATE) < CAST('2002-02-19' AS DATE)) THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0) ELSE 0 END) AS sales_before, SUM(CASE WHEN (CAST(d.d_date AS DATE) >= CAST('2002-02-19' AS DATE)) THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0) ELSE 0 END) AS sales_after FROM filtered_sales cs JOIN catalog_returns cr ON cs.cs_order_number = cr.cr_order_number AND cs.cs_item_sk = cr.cr_item_sk JOIN warehouse w ON cs.cs_warehouse_sk = w.w_warehouse_sk JOIN item i ON cs.cs_item_sk = i.i_item_sk JOIN date_dim d ON cs.cs_sold_date_sk = d.d_date_sk WHERE d.d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day') AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day') AND i.i_category = 'Jewelry' AND i.i_manager_id BETWEEN 61 AND 100 AND cs.cs_wholesale_cost BETWEEN 42 AND 61 AND cr.cr_reason_sk = 33 GROUP BY w.w_state, i.i_item_id ORDER BY w.w_state, i.i_item_id LIMIT 100"
      },
      {
        "node_id": "filtered_sales",
        "parent_node_id": "final_select",
        "sources": ["catalog_sales", "date_dim", "item", "warehouse"],
        "outputs": ["cs_item_sk", "cs_warehouse_sk", "cs_sales_price", "cs_order_number", "cs_sold_date_sk", "cs_wholesale_cost"],
        "changed": true,
        "sql": "SELECT cs.cs_item_sk, cs.cs_warehouse_sk, cs.cs_sales_price, cs.cs_order_number, cs.cs_sold_date_sk, cs.cs_wholesale_cost FROM catalog_sales cs INNER JOIN date_dim d ON cs.cs_sold_date_sk = d.d_date_sk INNER JOIN item i ON cs.cs_item_sk = i.i_item_sk INNER JOIN warehouse w ON cs.cs_warehouse_sk = w.w_warehouse_sk WHERE d.d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day') AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day') AND i.i_category = 'Jewelry' AND i.i_manager_id BETWEEN 61 AND 100 AND cs.cs_wholesale_cost BETWEEN 42 AND 61"
      }
    ]
  }
}