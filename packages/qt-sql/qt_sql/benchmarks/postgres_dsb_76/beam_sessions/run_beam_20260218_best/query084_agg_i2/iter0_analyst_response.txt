{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Sequential scan on customer (500k rows) dominates runtime because the selective filter on customer_address (city) is applied after the scan. Pre-filtering customer_address and income_band into CTEs and converting comma joins to explicit joins may enable a more efficient join order and index usage.",
    "reasoning_trace": [
      "Seq Scan on customer takes 467 ms, 33% of total time.",
      "Hash Join between customer and customer_address takes 683 ms, 46% of total time.",
      "Plan uses comma joins, which may limit optimizer's ability to reorder joins.",
      "Index Only Scan on store_returns has high Q-error (est=26, act=5), indicating cardinality misestimation."
    ],
    "cost_spine": ["Seq Scan on customer", "Hash Join (customer and customer_address)", "Nested Loop (household_demographics)", "Hash Join (income_band)", "Nested Loop (customer_demographics)", "Nested Loop (store_returns)"],
    "hotspots": [
      {
        "op": "Seq Scan on customer",
        "why": "full table scan of 500k rows",
        "evidence": "time=467.346 ms"
      },
      {
        "op": "Hash Join (customer and customer_address)",
        "why": "large join with 166k rows from customer and 99 rows from address",
        "evidence": "time=682.751 ms"
      },
      {
        "op": "Index Only Scan on store_returns",
        "why": "cardinality misestimation (est=26, act=5) may cause suboptimal nested loop",
        "evidence": "Q-error direction=OVER_EST, locus=SCAN"
      }
    ],
    "do_not_do": [
      "avoid OR to UNION because no OR predicates in query",
      "avoid duplicating heavy CTE bodies (G_PG_CTE_DUPLICATION_STOP)",
      "avoid materializing EXISTS paths (G_PG_EXISTS_PROTECTED)"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Pre-filter customer_address by ca_city and income_band by range into CTEs, then join with customer using explicit JOIN syntax.",
      "dag_target_hint": "Replace final_select FROM clause with CTEs and explicit joins.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "income_band ib", "household_demographics hd"],
        "where_must_preserve": ["ca_city = 'Mount Vernon'", "ib_lower_bound >= 40374", "ib_upper_bound <= 40374 + 50000", "c_current_addr_sk = ca_address_sk", "ib_income_band_sk = hd_income_band_sk"],
        "output_must_preserve": ["c_customer_id", "coalesce(c_last_name,'') || ', ' || coalesce(c_first_name,'') as customername", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Pre-filtering dimensions into CTEs may reduce rows scanned from customer and improve join order.",
      "confidence": 0.55,
      "expected_explain_delta": "Seq Scan on customer replaced by Index Scan using c_current_addr_sk; Hash Join replaced by Nested Loop with small dimension CTEs.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "convert_comma_to_explicit_join"],
      "rank_rationale": "Targets primary hotspot (customer scan) by pre-filtering dimensions.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p02",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Filter customer_address and income_band first, then join with customer, using explicit JOIN syntax and preserving all original predicates.",
      "dag_target_hint": "Replace final_select FROM clause with filtered dimension subqueries and explicit joins.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "income_band ib", "household_demographics hd"],
        "where_must_preserve": ["ca_city = 'Mount Vernon'", "ib_lower_bound >= 40374", "ib_upper_bound <= 40374 + 50000", "c_current_addr_sk = ca_address_sk", "ib_income_band_sk = hd_income_band_sk"],
        "output_must_preserve": ["c_customer_id", "coalesce(c_last_name,'') || ', ' || coalesce(c_first_name,'') as customername", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Early filtering of dimensions may enable better join order and reduce customer scan rows.",
      "confidence": 0.5,
      "expected_explain_delta": "Seq Scan on customer replaced by Index Scan; Hash Join replaced by Nested Loop with small inner tables.",
      "recommended_patch_ops": ["replace_from", "convert_comma_to_explicit_join"],
      "rank_rationale": "Alternative early-filtering approach to probe p01, testing different join shape.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p03",
      "transform_id": "explicit_join_materialized",
      "family": "F",
      "target": "Convert comma joins to explicit INNER JOINs and materialize filtered customer_address and income_band in CTEs to create tiny hash tables.",
      "dag_target_hint": "Replace final_select FROM clause with CTEs and explicit INNER JOINs.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "income_band ib", "household_demographics hd"],
        "where_must_preserve": ["ca_city = 'Mount Vernon'", "ib_lower_bound >= 40374", "ib_upper_bound <= 40374 + 50000", "c_current_addr_sk = ca_address_sk", "ib_income_band_sk = hd_income_band_sk"],
        "output_must_preserve": ["c_customer_id", "coalesce(c_last_name,'') || ', ' || coalesce(c_first_name,'') as customername", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.7,
      "expected_explain_delta": "Hash Join replaced by Nested Loop with small materialized dimension CTEs; better cardinality estimates.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "convert_comma_to_explicit_join"],
      "rank_rationale": "Gold example pattern with high historical speedup (8.56x) for comma-join weakness.",
      "recommended_examples": ["pg_explicit_join_materialized"],
      "gold_example_id": "pg_explicit_join_materialized"
    },
    {
      "probe_id": "p04",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre-filter all selective dimensions (customer_address, income_band, household_demographics) into CTEs before joining with customer, using explicit JOIN syntax.",
      "dag_target_hint": "Replace final_select FROM clause with multiple CTEs and explicit joins.",
      "node_contract": {
        "from_must_include": ["customer c", "customer_address ca", "income_band ib", "household_demographics hd"],
        "where_must_preserve": ["ca_city = 'Mount Vernon'", "ib_lower_bound >= 40374", "ib_upper_bound <= 40374 + 50000", "c_current_addr_sk = ca_address_sk", "ib_income_band_sk = hd_income_band_sk"],
        "output_must_preserve": ["c_customer_id", "coalesce(c_last_name,'') || ', ' || coalesce(c_first_name,'') as customername", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.65,
      "expected_explain_delta": "Multiple dimension CTEs reduce customer scan rows; Hash Join replaced by Nested Loop.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "convert_comma_to_explicit_join"],
      "rank_rationale": "Targets primary hotspot with multi-dimension prefetch, a proven pattern for PostgreSQL.",
      "recommended_examples": ["multi_dimension_prefetch"],
      "gold_example_id": "multi_dimension_prefetch"
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate in query; guardrail G_PG_OR_INDEX_PROTECTED advises against default OR-to-UNION."
    },
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated subqueries in query; plan shows no nested loops from correlation."
    },
    {
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "reason": "No GROUP BY or aggregation in query; plan shows no aggregate operators."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT or set operations in query."
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "No LEFT JOIN in query; all joins are inner equi-joins."
    },
    {
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "reason": "Previous optimization attempt failed (speedup=0.00x)."
    },
    {
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "reason": "Previous optimization attempt failed (speedup=0.00x)."
    },
    {
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "reason": "Previous optimization attempt failed (speedup=0.00x)."
    }
  ]
}