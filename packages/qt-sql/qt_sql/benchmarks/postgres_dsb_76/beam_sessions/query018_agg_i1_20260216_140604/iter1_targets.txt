[
  {
    "target_id": "t1",
    "family": "A+F",
    "transform": "early_filter_explicit_join",
    "relevance_score": 0.95,
    "hypothesis": "Pushing filters into CTEs (A) and using explicit joins (F) reduces the Nested Loop (12,994 rows) by restricting catalog_sales scans early.",
    "target_ir": "S0: replace_from + replace_where_predicate",
    "recommended_examples": [
      "pg_date_cte_explicit_join",
      "pg_explicit_join_materialized"
    ]
  },
  {
    "target_id": "t2",
    "family": "A+E",
    "transform": "prefetch_customer_address",
    "relevance_score": 0.9,
    "hypothesis": "Materializing filtered customer+address joins (E) on top of early filtering (A) reduces the Nested Loop (rows=0 for customer) by pre-joining dimensions.",
    "target_ir": "S0: insert_cte (customer_address_prejoin) + replace_from",
    "recommended_examples": [
      "multi_dimension_prefetch",
      "pg_date_cte_explicit_join"
    ]
  },
  {
    "target_id": "t3",
    "family": "C",
    "transform": "preaggregate_fact",
    "relevance_score": 0.85,
    "hypothesis": "Aggregating catalog_sales by foreign keys before joining dimensions reduces input to the expensive Aggregate operator (rows=5).",
    "target_ir": "S0: insert_cte (preagg_cs) + replace_from",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter"
    ]
  },
  {
    "target_id": "t4",
    "family": "F+B",
    "transform": "decorrelate_demographics",
    "relevance_score": 0.8,
    "hypothesis": "Decorrelating customer_demographics (B) with explicit joins (F) avoids per-row scans (Index Scan on customer_demographics, time=0.047 ms/row).",
    "target_ir": "S0: replace_where_predicate (cd_gender/status) + replace_from",
    "recommended_examples": [
      "pg_shared_scan_decorrelate",
      "pg_explicit_join_materialized"
    ]
  }
]