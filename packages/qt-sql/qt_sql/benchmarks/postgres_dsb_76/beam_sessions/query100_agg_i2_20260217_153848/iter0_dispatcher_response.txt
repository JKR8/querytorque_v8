{
  "dispatch": {
    "dialect": "postgres",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Execution plan shows nested loops dominating runtime (48.9s) with high row amplification from store_sales scans. Late selectivity at customer_demographics (0 rows) and item2 (0 rows) indicates early filtering opportunities. Comma-joins prevent optimal join ordering.",
    "reasoning_trace": [
      "Cost spine: Nested Loop (48.9s) → Nested Loop (48.9s) → Nested Loop (48.3s) → Nested Loop (46.7s)",
      "Row amplification: 24.8M rows from date_dim→store_sales join despite selective date filter",
      "Late filtering: customer_demographics filter applied after large fact-dimension join",
      "Comma-join weakness prevents predicate pushdown and optimal join ordering"
    ],
    "cost_spine": [
      "Nested Loop → Nested Loop → Nested Loop → Nested Loop → Merge Join"
    ],
    "hotspots": [
      {
        "op": "Nested Loop",
        "why": "Row amplification from store_sales scans",
        "evidence": "time=48985.894ms, rows=279"
      },
      {
        "op": "Merge Join",
        "why": "Large sort operations (24.8M rows)",
        "evidence": "time=10093.138ms, rows=85310"
      }
    ],
    "do_not_do": [
      "or_to_union",
      "intersect_to_exists"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "status",
    "speedup",
    "expected_explain_delta",
    "ops_used",
    "confidence",
    "exploration",
    "failure_reason",
    "target"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Replace comma joins with explicit INNER JOINs. Create CTEs for: filtered_date (d_date_sk), filtered_cd (cd_demo_sk), filtered_item1 (i_item_sk), filtered_item2 (i_item_sk). Preserve join conditions in ON clauses.",
      "node_contract": {
        "from_must_include": [
          "store_sales s1",
          "store_sales s2",
          "filtered_item1",
          "filtered_item2"
        ],
        "where_must_preserve": [
          "s1.ss_ticket_number = s2.ss_ticket_number",
          "s1.ss_item_sk = filtered_item1.i_item_sk",
          "s2.ss_item_sk = filtered_item2.i_item_sk",
          "s1.ss_list_price BETWEEN 115 AND 129",
          "s2.ss_list_price BETWEEN 115 AND 129",
          "filtered_item1.i_item_sk < filtered_item2.i_item_sk"
        ],
        "output_must_preserve": [
          "filtered_item1.i_item_sk",
          "filtered_item2.i_item_sk",
          "COUNT(*) AS cnt"
        ]
      },
      "gates_checked": [
        "comma_join_weakness:PASS",
        "cte_materialization_fence:PASS"
      ],
      "exploration": false,
      "confidence": 0.85,
      "expected_explain_delta": "Merge Join replaced by Hash Join, reduced sort operations",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ]
    },
    {
      "probe_id": "p02",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Create date_cte CTE with d_date_sk. Convert date_dim join to explicit INNER JOIN with CTE. Preserve date filter in CTE definition.",
      "node_contract": {
        "from_must_include": [
          "date_cte"
        ],
        "where_must_preserve": [
          "s1.ss_sold_date_sk = date_cte.d_date_sk"
        ],
        "output_must_preserve": [
          "d_year BETWEEN condition"
        ]
      },
      "gates_checked": [
        "comma_join_weakness:PASS"
      ],
      "exploration": false,
      "confidence": 0.8,
      "expected_explain_delta": "Earlier date filter application, reduced store_sales rows",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_where_predicate"
      ]
    },
    {
      "probe_id": "p03",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Create sales_cte MATERIALIZED with ss_ticket_number, ss_item_sk. Self-join sales_cte as s1/s2 in main query. Preserve list price filters in CTE.",
      "node_contract": {
        "from_must_include": [
          "sales_cte s1",
          "sales_cte s2"
        ],
        "where_must_preserve": [
          "s1.ss_ticket_number = s2.ss_ticket_number",
          "s1.ss_list_price BETWEEN 115 AND 129",
          "s2.ss_list_price BETWEEN 115 AND 129"
        ],
        "output_must_preserve": [
          "ss_item_sk joins to item tables"
        ]
      },
      "gates_checked": [
        "cte_materialization_fence:PASS"
      ],
      "exploration": false,
      "confidence": 0.9,
      "expected_explain_delta": "Eliminated duplicate store_sales scans, reduced nested loops",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ]
    },
    {
      "probe_id": "p04",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Create prefiltered_sales CTE MATERIALIZED joining store_sales→date_cte→customer→filtered_cd. Preserve all dimension joins and filters in CTE.",
      "node_contract": {
        "from_must_include": [
          "prefiltered_sales s1",
          "prefiltered_sales s2"
        ],
        "where_must_preserve": [
          "s1.ss_ticket_number = s2.ss_ticket_number"
        ],
        "output_must_preserve": [
          "ss_item_sk joins to item tables"
        ]
      },
      "gates_checked": [
        "cte_materialization_fence:PASS"
      ],
      "exploration": false,
      "confidence": 0.75,
      "expected_explain_delta": "Customer/demographics filters applied before main join, reduced row counts",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ]
    },
    {
      "probe_id": "p05",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Create cd_cte with cd_demo_sk (filtered). Replace customer_demographics table with cd_cte. Preserve marital/education filters in CTE definition.",
      "node_contract": {
        "from_must_include": [
          "cd_cte"
        ],
        "where_must_preserve": [
          "c_current_cdemo_sk = cd_cte.cd_demo_sk"
        ],
        "output_must_preserve": [
          "cd_marital_status='D'",
          "cd_education_status='College'"
        ]
      },
      "gates_checked": [
        "cross_cte_predicate_blindness:CAUTION"
      ],
      "exploration": true,
      "exploration_hypothesis": "Runtime evidence shows 0 rows after cd filter - CTE materialization may enable hash join",
      "confidence": 0.7,
      "expected_explain_delta": "Earlier customer_demographics filter, reduced nested loop iterations",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ]
    },
    {
      "probe_id": "p06",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Create item1_cte with i_item_sk (filtered by category). Replace item1 table with CTE. Preserve category filter in CTE definition.",
      "node_contract": {
        "from_must_include": [
          "item1_cte"
        ],
        "where_must_preserve": [
          "s1.ss_item_sk = item1_cte.i_item_sk"
        ],
        "output_must_preserve": [
          "i_category IN ('Electronics','Men')"
        ]
      },
      "gates_checked": [
        "cross_cte_predicate_blindness:CAUTION"
      ],
      "exploration": true,
      "exploration_hypothesis": "Plan shows late item filtering - CTE may enable index-only scan",
      "confidence": 0.65,
      "expected_explain_delta": "Reduced rows before store_sales join",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ]
    },
    {
      "probe_id": "p07",
      "transform_id": "self_join_decomposition",
      "family": "F",
      "target": "Create item1_cte and item2_cte MATERIALIZED. Replace item joins with CTEs. Preserve all item filters in CTE definitions.",
      "node_contract": {
        "from_must_include": [
          "item1_cte",
          "item2_cte"
        ],
        "where_must_preserve": [
          "item1_cte.i_item_sk < item2_cte.i_item_sk"
        ],
        "output_must_preserve": [
          "i_category IN filter",
          "i_manager_id BETWEEN filter"
        ]
      },
      "gates_checked": [
        "non_equi_join_input_blindness:PASS"
      ],
      "exploration": false,
      "confidence": 0.8,
      "expected_explain_delta": "Materialized CTEs for inequality join inputs, reduced nested loop cardinality",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ]
    },
    {
      "probe_id": "p08",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Create sales_agg CTE grouping by ss_ticket_number, ss_item_sk. Replace store_sales with aggregated CTE. Preserve list price filters in CTE.",
      "node_contract": {
        "from_must_include": [
          "sales_agg s1",
          "sales_agg s2"
        ],
        "where_must_preserve": [
          "s1.ss_ticket_number = s2.ss_ticket_number"
        ],
        "output_must_preserve": [
          "COUNT(*) aggregation semantics"
        ]
      },
      "gates_checked": [
        "aggregate_below_join_blindness:CAUTION"
      ],
      "exploration": true,
      "exploration_hypothesis": "High rowcount in store_sales scans - early aggregation may reduce join costs",
      "confidence": 0.6,
      "expected_explain_delta": "Reduced rows before self-join, eliminated redundant scans",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ]
    },
    {
      "probe_id": "p09",
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "target": "Create stage1 CTE joining filtered_date→store_sales. Stage2 joins stage1→customer→filtered_cd. Preserve all dimension filters in CTEs.",
      "node_contract": {
        "from_must_include": [
          "stage2 s1",
          "stage2 s2"
        ],
        "where_must_preserve": [
          "s1.ss_ticket_number = s2.ss_ticket_number"
        ],
        "output_must_preserve": [
          "All dimension join conditions"
        ]
      },
      "gates_checked": [
        "cross_cte_predicate_blindness:CAUTION"
      ],
      "exploration": true,
      "exploration_hypothesis": "Staged reduction may compound selectivity benefits before self-join",
      "confidence": 0.55,
      "expected_explain_delta": "Progressive row reduction in EXPLAIN plan",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ]
    },
    {
      "probe_id": "p10",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Create dim_cte MATERIALIZED joining customer→customer_address→filtered_cd. Replace dimension tables with CTE. Preserve all dimension filters in CTE.",
      "node_contract": {
        "from_must_include": [
          "dim_cte"
        ],
        "where_must_preserve": [
          "s1.ss_customer_sk = dim_cte.c_customer_sk"
        ],
        "output_must_preserve": [
          "cd_marital_status='D'",
          "cd_education_status='College'"
        ]
      },
      "gates_checked": [
        "cross_cte_predicate_blindness:CAUTION"
      ],
      "exploration": true,
      "exploration_hypothesis": "Combined dimension filtering may create single efficient hash join",
      "confidence": 0.5,
      "expected_explain_delta": "Single dimension join instead of nested loops",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ]
    },
    {
      "probe_id": "p11",
      "transform_id": "inner_join_conversion",
      "family": "F",
      "target": "Convert comma joins to explicit INNER JOIN syntax. Preserve all original join conditions in ON clauses.",
      "node_contract": {
        "from_must_include": [
          "store_sales s1 INNER JOIN store_sales s2 ON s1.ss_ticket_number = s2.ss_ticket_number"
        ],
        "where_must_preserve": [
          "All original WHERE conditions except join predicates"
        ],
        "output_must_preserve": [
          "All join semantics"
        ]
      },
      "gates_checked": [
        "comma_join_weakness:PASS"
      ],
      "exploration": false,
      "confidence": 0.75,
      "expected_explain_delta": "Improved join order in EXPLAIN, better hash join utilization",
      "recommended_patch_ops": [
        "replace_from"
      ]
    },
    {
      "probe_id": "p12",
      "transform_id": "channel_bitmap_aggregation",
      "family": "C",
      "target": "Create sales_combined CTE with CASE labels for s1/s2. Perform conditional aggregation. Preserve list price filters in CTE.",
      "node_contract": {
        "from_must_include": [
          "sales_combined"
        ],
        "where_must_preserve": [
          "ss_list_price BETWEEN 115 AND 129"
        ],
        "output_must_preserve": [
          "COUNT(*) aggregation logic",
          "Item pair grouping"
        ]
      },
      "gates_checked": [
        "redundant_scan_elimination:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Single store_sales scan may outperform two separate scans",
      "confidence": 0.45,
      "expected_explain_delta": "Single store_sales scan instead of two, eliminated self-join",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_body"
      ]
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR conditions in query"
    },
    {
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "reason": "Snowflake-specific transform contraindicated for PostgreSQL"
    },
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated subqueries in query"
    }
  ]
}