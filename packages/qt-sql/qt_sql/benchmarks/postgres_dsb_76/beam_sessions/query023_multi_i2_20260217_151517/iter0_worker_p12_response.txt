{
  "probe_id": "p01",
  "transform_id": "single_pass_aggregation",
  "family": "C",
  "dialect": "postgres",
  "hypothesis": "Consolidate multiple scans of store_sales into a single pass with conditional aggregation to reduce redundant subquery execution.",
  "reasoning_trace": [
    "best_ss_customer and max_store_sales both scan store_sales with overlapping filters",
    "PostgreSQL re-executes correlated subqueries per row, causing high cost in best_ss_customer (70.4s)",
    "A single CTE with CASE-based aggregation can compute both aggregates in one scan"
  ],
  "target_ir": "Single store_sales CTE with CASE-based aggregation; best_ss_customer and max_store_sales replaced by projections from that CTE",
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {"by_node_id": "S0"},
      "payload": {
        "cte_name": "store_sales_aggregates",
        "cte_query_sql": "SELECT c_customer_sk, SUM(CASE WHEN c_birth_year BETWEEN 1987 AND 1993 THEN ss_quantity * ss_sales_price ELSE 0 END) AS ssales, SUM(ss_quantity * ss_sales_price) AS csales FROM store_sales, customer WHERE ss_customer_sk = c_customer_sk AND ss_wholesale_cost BETWEEN 26 AND 36 GROUP BY c_customer_sk"
      }
    },
    {
      "step_id": "s2",
      "op": "replace_body",
      "target": {"by_node_id": "CTE_Q_S0_max_store_sales"},
      "payload": {
        "sql_fragment": "SELECT MAX(csales) tpcds_cmax FROM store_sales_aggregates"
      }
    },
    {
      "step_id": "s3",
      "op": "replace_body",
      "target": {"by_node_id": "CTE_Q_S0_best_ss_customer"},
      "payload": {
        "sql_fragment": "SELECT c_customer_sk, ssales FROM store_sales_aggregates WHERE ssales > (95/100.0) * (SELECT tpcds_cmax FROM max_store_sales)"
      }
    }
  ]
}