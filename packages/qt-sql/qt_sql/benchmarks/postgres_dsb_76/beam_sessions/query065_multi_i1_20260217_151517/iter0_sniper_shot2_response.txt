[
  {
    "plan_id": "snipe_p1",
    "family": "E",
    "transform": "pg_self_join_decomposition",
    "dialect": "postgres",
    "confidence": 0.85,
    "based_on": "p01,p07",
    "hypothesis": "Original shows duplicate IndexOnlyScans on store_sales/date_dim (19.7s+13.6s). Materializing base sales CTE avoids redundant scans. Explicit JOIN syntax addresses comma-join weakness. Prefiltered dimensions reduce late-filter costs.",
    "target_ir": "CTE chain: 1) date_filter 2) store_sales_revenue 3) store_avg_revenue 4-5) filtered dimensions. Explicit JOINs with pushed-down filters.",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "WITH date_filter AS (SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1195 AND 1195 + 11), store_sales_revenue AS (SELECT ss_store_sk, ss_item_sk, SUM(ss_sales_price) AS revenue FROM store_sales JOIN date_filter ON ss_sold_date_sk = d_date_sk WHERE ss_sales_price / ss_list_price BETWEEN 38 * 0.01 AND 48 * 0.01 GROUP BY ss_store_sk, ss_item_sk), store_avg_revenue AS (SELECT ss_store_sk, AVG(revenue) AS ave FROM store_sales_revenue GROUP BY ss_store_sk), filtered_store AS (SELECT s_store_sk, s_store_name FROM store WHERE s_state IN ('IA','IL','NC')), filtered_item AS (SELECT i_item_sk, i_item_desc, i_current_price, i_wholesale_cost, i_brand FROM item WHERE i_manager_id BETWEEN 80 AND 84) SELECT s.s_store_name, i.i_item_desc, sc.revenue, i.i_current_price, i.i_wholesale_cost, i.i_brand FROM filtered_store s JOIN store_avg_revenue sb ON s.s_store_sk = sb.ss_store_sk JOIN store_sales_revenue sc ON sb.ss_store_sk = sc.ss_store_sk JOIN filtered_item i ON i.i_item_sk = sc.ss_item_sk WHERE sc.revenue <= 0.1 * sb.ave ORDER BY s.s_store_name, i.i_item_desc LIMIT 100;"
        }
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "family": "F",
    "transform": "dimension_prefetch_explicit_join",
    "dialect": "postgres",
    "confidence": 0.78,
    "based_on": "p02,p03",
    "hypothesis": "Late store/item filters cause full scans (0.04s->14.9s in plan). Prefiltering dimensions avoids large scans. Explicit JOIN syntax resolves comma-join weakness. Single base sales CTE prevents redundant scans.",
    "target_ir": "CTEs: 1) filtered_date 2) filtered_store 3) filtered_item 4) base_sales. Explicit INNER JOINs with dimension filters pushed into CTEs.",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "WITH filtered_date AS (SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1195 AND 1195 + 11), filtered_store AS (SELECT s_store_sk, s_store_name FROM store WHERE s_state IN ('IA','IL','NC')), filtered_item AS (SELECT i_item_sk, i_item_desc, i_current_price, i_wholesale_cost, i_brand FROM item WHERE i_manager_id BETWEEN 80 AND 84), base_sales AS (SELECT ss_store_sk, ss_item_sk, SUM(ss_sales_price) AS revenue FROM store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk WHERE ss_sales_price / ss_list_price BETWEEN 38 * 0.01 AND 48 * 0.01 GROUP BY ss_store_sk, ss_item_sk) SELECT s.s_store_name, i.i_item_desc, sc.revenue, i.i_current_price, i.i_wholesale_cost, i.i_brand FROM filtered_store s INNER JOIN (SELECT ss_store_sk, AVG(revenue) AS ave FROM base_sales GROUP BY ss_store_sk) sb ON s.s_store_sk = sb.ss_store_sk INNER JOIN base_sales sc ON sb.ss_store_sk = sc.ss_store_sk INNER JOIN filtered_item i ON i.i_item_sk = sc.ss_item_sk WHERE sc.revenue <= 0.1 * sb.ave ORDER BY s.s_store_name, i.i_item_desc LIMIT 100;"
        }
      }
    ]
  }
]