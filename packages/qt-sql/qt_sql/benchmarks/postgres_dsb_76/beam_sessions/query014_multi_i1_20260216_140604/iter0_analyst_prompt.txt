## Role

You are a SQL optimization analyst. Your task is to analyze this query, identify the primary bottleneck, and design structural optimization targets.

For each target, describe the STRUCTURAL SHAPE of the optimized query using an IR node map (CTE names, FROM tables, WHERE conditions, GROUP BY, ORDER BY). A separate code-generation worker will convert your targets into executable patch plans.

Identify the primary bottleneck. Only provide secondary targets if they are distinct and high-confidence. **Quality > Quantity.**

## Query: query014_multi_i1

**Dialect**: POSTGRES

```sql
with  cross_items as
 (select i_item_sk ss_item_sk
 from item,
 (select iss.i_brand_id brand_id
     ,iss.i_class_id class_id
     ,iss.i_category_id category_id
 from store_sales
     ,item iss
     ,date_dim d1
 where ss_item_sk = iss.i_item_sk
   and ss_sold_date_sk = d1.d_date_sk
   and d1.d_year between 1999 AND 1999 + 2
   and i_category IN ('Electronics', 'Jewelry', 'Men')
   and i_manager_id BETWEEN 91 and 100
   and ss_wholesale_cost BETWEEN 35 AND 55
intersect
 select ics.i_brand_id
     ,ics.i_class_id
     ,ics.i_category_id
 from catalog_sales
     ,item ics
     ,date_dim d2
 where cs_item_sk = ics.i_item_sk
   and cs_sold_date_sk = d2.d_date_sk
   and d2.d_year between 1999 AND 1999 + 2
   and i_category IN ('Electronics', 'Jewelry', 'Men')
   and i_manager_id BETWEEN 91 and 100
   and cs_wholesale_cost BETWEEN 35 AND 55
intersect
 select iws.i_brand_id
     ,iws.i_class_id
     ,iws.i_category_id
 from web_sales
     ,item iws
     ,date_dim d3
 where ws_item_sk = iws.i_item_sk
   and ws_sold_date_sk = d3.d_date_sk
   and ws_wholesale_cost BETWEEN 35 AND 55
   and d3.d_year between 1999 AND 1999 + 2) x
 where i_brand_id = brand_id
      and i_class_id = class_id
      and i_category_id = category_id
      and i_category IN ('Electronics', 'Jewelry', 'Men')
      and i_manager_id BETWEEN 91 and 100
),
 avg_sales as
(select avg(quantity*list_price) average_sales
  from (select ss_quantity quantity
             ,ss_list_price list_price
       from store_sales
           ,date_dim
       where ss_sold_date_sk = d_date_sk
         and d_year between 1999 and 1999 + 2
         and ss_wholesale_cost BETWEEN 35 AND 55
       union all
       select cs_quantity quantity
             ,cs_list_price list_price
       from catalog_sales
           ,date_dim
       where cs_sold_date_sk = d_date_sk
         and d_year between 1999 and 1999 + 2
         and cs_wholesale_cost BETWEEN 35 AND 55
       union all
       select ws_quantity quantity
             ,ws_list_price list_price
       from web_sales
           ,date_dim
       where ws_sold_date_sk = d_date_sk
        and ws_wholesale_cost BETWEEN 35 AND 55
         and d_year between 1999 and 1999 + 2) x)
  select  this_year.channel ty_channel
                           ,this_year.i_brand_id ty_brand
                           ,this_year.i_class_id ty_class
                           ,this_year.i_category_id ty_category
                           ,this_year.sales ty_sales
                           ,this_year.number_sales ty_number_sales
                           ,last_year.channel ly_channel
                           ,last_year.i_brand_id ly_brand
                           ,last_year.i_class_id ly_class
                           ,last_year.i_category_id ly_category
                           ,last_year.sales ly_sales
                           ,last_year.number_sales ly_number_sales
 from
 (select 'store' channel, i_brand_id,i_class_id,i_category_id
        ,sum(ss_quantity*ss_list_price) sales, count(*) number_sales
 from store_sales
     ,item
     ,date_dim
 where ss_item_sk in (select ss_item_sk from cross_items)
   and ss_item_sk = i_item_sk
   and ss_sold_date_sk = d_date_sk
   and d_week_seq = (select d_week_seq
                     from date_dim
                     where d_year = 1999 + 1
                       and d_moy = 12
                       and d_dom = 20)
   and i_category IN ('Electronics', 'Jewelry', 'Men')
   and i_manager_id BETWEEN 91 and 100
   and ss_wholesale_cost BETWEEN 35 AND 55
 group by i_brand_id,i_class_id,i_category_id
 having sum(ss_quantity*ss_list_price) > (select average_sales from avg_sales)) this_year,
 (select 'store' channel, i_brand_id,i_class_id
        ,i_category_id, sum(ss_quantity*ss_list_price) sales, count(*) number_sales
 from store_sales
     ,item
     ,date_dim
 where ss_item_sk in (select ss_item_sk from cross_items)
   and ss_item_sk = i_item_sk
   and ss_sold_date_sk = d_date_sk
   and d_week_seq = (select d_week_seq
                     from date_dim
                     where d_year = 1999
                       and d_moy = 12
                       and d_dom = 20)
   and i_category IN ('Electronics', 'Jewelry', 'Men')
   and ss_wholesale_cost BETWEEN 35 AND 55
   and i_manager_id BETWEEN 91 and 100
group by i_brand_id,i_class_id,i_category_id
 having sum(ss_quantity*ss_list_price) > (select average_sales from avg_sales)) last_year
 where this_year.i_brand_id= last_year.i_brand_id
   and this_year.i_class_id = last_year.i_class_id
   and this_year.i_category_id = last_year.i_category_id
 order by this_year.channel, this_year.i_brand_id, this_year.i_class_id, this_year.i_category_id
 limit 100;
```


## Current Execution Plan

```
Limit  (rows=47, time=15315.356)
  Hash Join  (rows=2664, time=7083.621)
    Seq Scan on item (item_2)  (rows=2682, time=21.924)
    Hash  (rows=381, time=7061.158)
      Subquery Scan (x)  (rows=383, time=7061.124)
        SetOp  (rows=383, time=7061.102)
          Append  (rows=384091, time=7028.743)
            Result  (rows=383, time=6243.647)
              SetOp  (rows=383, time=6243.626)
                Append  (rows=210813, time=6197.809)
                  Subquery Scan (*SELECT* 2)  (rows=14587, time=3830.833)
                    Gather  (rows=14587, time=3826.772)
                      Nested Loop  (rows=14587, time=3823.308)
                        Nested Loop  (rows=1119537, time=2199.238)
                          Index Only Scan on date_dim (d2)  (rows=1096, time=3.636)
                          Index Scan on catalog_sales  (rows=1021, time=1.938)
                        Memoize  (rows=0, time=0.001)
                          Index Scan on item (ics)  (rows=0, time=0.011)
                  Subquery Scan (*SELECT* 1)  (rows=196226, time=2354.844)
                    Gather  (rows=196226, time=2339.823)
                      Nested Loop  (rows=65409, time=1884.96)
                        Nested Loop  (rows=1292829, time=1050.418)
                          Index Only Scan on date_dim (d1)  (rows=365, time=0.921)
                          Index Only Scan on store_sales (store_sales_2)  (rows=3539, time=2.707)
                        Memoize  (rows=0, time=0.001)
                          Index Scan on item (iss)  (rows=0, time=0.005)
            Subquery Scan (*SELECT* 3)  (rows=383708, time=767.825)
              Gather  (rows=383708, time=739.746)
                Nested Loop  (rows=127903, time=578.753)
                  Nested Loop  (rows=127903, time=319.266)
                    Index Only Scan on date_dim (d3)  (rows=365, time=0.755)
                    Index Scan on web_sales  (rows=350, time=0.85)
                  Index Scan on item (iws)  (rows=1, time=0.002)
  Aggregate  (rows=1, time=2245.591)
    Gather  (rows=3, time=2245.581)
      Aggregate  (rows=1, time=1935.158)
        Append  (rows=1793911, time=1717.83)
          Nested Loop  (rows=1292829, time=899.416)
            Index Only Scan on date_dim (date_dim_2)  (rows=365, time=0.737)
            Index Only Scan on store_sales (store_sales_3)  (rows=3539, time=2.309)
          Nested Loop  (rows=559768, time=692.16)
            Index Only Scan on date_dim (date_dim_3)  (rows=548, time=1.13)
            Index Scan on catalog_sales (catalog_sales_1)  (rows=1021, time=1.206)
          Nested Loop  (rows=383708, time=873.554)
            Index Only Scan on date_dim (date_dim_4)  (rows=1096, time=1.695)
            Index Scan on web_sales (web_sales_1)  (rows=350, time=0.774)
  Sort  (rows=47, time=15315.197)
    Nested Loop  (rows=47, time=15315.135)
      Aggregate  (rows=151, time=12453.186)
        Index Scan on date_dim (date_dim_5)  (rows=1, time=0.024)
        CTE Scan (avg_sales)  (rows=1, time=2245.566)
        Sort  (rows=2621, time=10207.217)
          Nested Loop  (rows=2621, time=10206.098)
            Nested Loop  (rows=272575, time=9989.51)
              Nested Loop  (rows=2664, time=7107.408)
                Aggregate  (rows=2664, time=7085.971)
                  CTE Scan (cross_items)  (rows=2664, time=7083.882)
                Index Scan on item  (rows=1, time=0.007)
              Bitmap Heap Scan on store_sales  (rows=102, time=1.072)
                Bitmap Index Scan  (rows=422, time=0.034)
            Index Scan on date_dim  (rows=0, time=0.001)
      Aggregate  (rows=66, time=18.952)
        Index Scan on date_dim (date_dim_6)  (rows=1, time=0.017)
        CTE Scan (avg_sales_1)  (rows=1, time=0.001)
        Sort  (rows=695, time=18.838)
          Nested Loop  (rows=778, time=2841.541)
            Nested Loop  (rows=272575, time=2632.705)
              Nested Loop  (rows=2664, time=21.451)
                Aggregate  (rows=2664, time=1.758)
                  CTE Scan (cross_items_1)  (rows=2664, time=0.087)
                Index Scan on item (item_1)  (rows=1, time=0.007)
              Bitmap Heap Scan on store_sales (store_sales_1)  (rows=102, time=0.971)
                Bitmap Index Scan  (rows=422, time=0.028)
            Index Scan on date_dim (date_dim_1)  (rows=0, time=0.001)
```


## IR Structure (for patch targeting)

```
S0 [SELECT]
  CTE: cross_items  (via CTE_Q_S0_cross_items)
    FROM: item, (subquery) x
    WHERE [60fb583c222ff2dd]: i_brand_id = brand_id AND i_class_id = class_id AND i_category_id = category_id AND i_category IN...
  CTE: avg_sales  (via CTE_Q_S0_avg_sales)
    FROM: (subquery) x
  MAIN QUERY (via Q_S0)
    FROM: (subquery) this_year, (subquery) last_year
    WHERE [0351671740d55a99]: this_year.i_brand_id = last_year.i_brand_id AND this_year.i_class_id = last_year.i_class_id AND t...
    ORDER BY: this_year.channel, this_year.i_brand_id, this_year.i_class_id, this_year.i_category_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**Note**: Use `by_node_id` (e.g., "S0") and `by_anchor_hash` (16-char hex) from map above to target patch operations.


## Optimization Families

Review the 6 families below. Each has a proven gold example.

Choose up to **4 most relevant families** for this query based on:
- Query structure (CTEs, subqueries, joins, aggregations, set operations)
- Execution plan signals (WHERE placement, repeated scans, correlated subqueries)
- Problem signature (cardinality estimation errors, loops vs sets, filter ordering)



### Family A: Early Filtering (Predicate Pushback)
**Description**: Push small filters into CTEs early, reduce row count before expensive operations
**Speedup Range**: 1.3–4.0x (~35% of all wins)
**Use When**:
  1. Late WHERE filters on dimension tables
  2. Cascading CTEs with filters applied downstream
  3. Expensive joins after filters could be pushed earlier

**Gold Example**: `pg_date_cte_explicit_join` (2.28x)



### Family B: Decorrelation (Sets Over Loops)
**Description**: Convert correlated subqueries to standalone CTEs with GROUP BY, eliminate per-row re-execution
**Speedup Range**: 2.4–2.9x (~15% of all wins)
**Use When**:
  1. Correlated subqueries in WHERE clause
  2. Scalar aggregates computed per outer row
  3. DELIM_SCAN in execution plan (indicates correlation)

**Gold Example**: `pg_shared_scan_decorrelate` (8043.91x (timeout rescue))



### Family C: Aggregation Pushdown (Minimize Rows Touched)
**Description**: Aggregate before expensive joins when GROUP BY keys ⊇ join keys, reduce intermediate sizes
**Speedup Range**: 1.3–15.3x (~5% of all wins (high variance))
**Use When**:
  1. GROUP BY happens after large joins
  2. GROUP BY keys are subset of join keys
  3. Intermediate result size >> final result size

**Gold Example**: `pg_materialized_dimension_fact_prefilter` (12.07x (V2 DSB SF10, was 2.68x in V1))



### Family D: Set Operation Optimization (Sets Over Loops)
**Description**: Replace INTERSECT/UNION-based patterns with EXISTS/NOT EXISTS, avoid full materialization
**Speedup Range**: 1.7–2.7x (~8% of all wins)
**Use When**:
  1. INTERSECT patterns between large sets
  2. UNION ALL with duplicate elimination
  3. Set operations materializing full intermediate results

**Gold Example**: `pg_intersect_to_exists` (1.78x)



### Family E: Materialization / Prefetch (Don't Repeat Work)
**Description**: Extract repeated scans or pre-compute intermediate results for reuse across multiple consumers
**Speedup Range**: 1.3–6.2x (~18% of all wins)
**Use When**:
  1. Repeated scans of same table with different filters
  2. Dimension filters applied independently multiple times
  3. CTE referenced multiple times with implicit re-evaluation

**Gold Example**: `multi_dimension_prefetch` (2.71x)



### Family F: Join Transform (Right Shape First)
**Description**: Restructure join topology: convert comma joins to explicit INNER JOIN, optimize join order, eliminate self-joins via single-pass aggregation
**Speedup Range**: 1.8–8.6x (~19% of all wins)
**Use When**:
  1. Comma-separated joins (implicit cross joins) in FROM clause
  2. Self-joins scanning same table multiple times
  3. Dimension-fact join order suboptimal for predicate pushdown

**Gold Example**: `pg_explicit_join_materialized` (8.56x)



## Worker Routing

Your targets will be routed to specialized workers:
- **W1 "Reducer"** (Families A, D): Cardinality reduction — early filtering, set operations
- **W2 "Unnester"** (Families B, C): Decorrelation, aggregation pushdown
- **W3 "Builder"** (Families F, E): Join restructuring, materialization/prefetch
- **W4 "Wildcard"** (Dynamic): Deep specialist — your **#1 target** gets maximum effort

The highest-relevance target always goes to W4. Design diverse targets across worker roles for maximum coverage.


## Your Task

Analyze this query against the 6 families above.

Identify the **primary bottleneck**. Only provide secondary targets if they are distinct and high-confidence. Quality > Quantity.

For each target (1 to 4):
1. Describe the bottleneck hypothesis
2. Design a TARGET IR node map showing what the optimized query SHOULD look like
3. Score relevance (0.0–1.0)
4. Recommend which gold example(s) a code-generation worker should use as reference


**Output format**:

```json
[
  {
    "family": "B",
    "transform": "shared_scan_decorrelate",
    "target_id": "t1",
    "relevance_score": 0.95,
    "hypothesis": "Correlated scalar subquery re-scans web_sales per row. Shared-scan variant: inner=outer table with same date filter.",
    "target_ir": "S0 [SELECT]\n  CTE: common_scan  (via Q1)\n    FROM: web_sales, date_dim\n    WHERE: d_date BETWEEN ... AND d_date_sk = ws_sold_date_sk\n  CTE: thresholds  (via Q2)\n    FROM: common_scan\n    GROUP BY: ws_item_sk\n  MAIN QUERY (via Q0)\n    FROM: common_scan cs, item, thresholds t\n    WHERE: i_manufact_id = 320 AND ... AND cs.ws_ext_discount_amt > t.threshold\n    ORDER BY: sum(ws_ext_discount_amt)",
    "recommended_examples": ["sf_shared_scan_decorrelate"]
  }
]
```

**Rules**:
- target_ir must follow the IR node map format (same as Section 4)
- target_ir describes the STRUCTURAL SHAPE of the optimized query (CTE names, FROM tables, WHERE conditions, GROUP BY, ORDER BY)
- recommended_examples: list gold example IDs the worker should use as reference patch template
- Each target should represent a DIFFERENT optimization strategy
- Rank by relevance_score (highest first)
- Output up to 4 targets

After JSON, provide analysis:

## Analysis
For each available family, explain relevance (HIGH / MEDIUM / LOW) in 1-2 sentences.
**Chosen families**: [list]
**Confidence**: High/Medium/Low
