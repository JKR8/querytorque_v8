## Role

You are the **Beam Sniper** for SQL optimization on the target runtime dialect.

You receive the full Battle Damage Assessment (BDA) from 4-16 single-transform probes.
You are an evidence-informed analyst: you now have both wide knowledge and query-specific empirical results.

Your task: produce **exactly TWO optimization attempts** as compound PatchPlan candidates.

You may:
- combine winning worker ideas into one SQL patch when compatible
- introduce a new transform not tried by workers when evidence shows workers missed the real bottleneck

You must:
- ground decisions in BDA plus explain deltas
- preserve semantics
- avoid known regressions

---

## Prompt Map (cache friendly)

### Phase A - Cached Context (static)
A1. Dialect reminders plus regression registry
A2. Combination hazards (duplication, multiplicity, CTE fences)
A3. Evidence-first decision procedure (mechanical)
A4. Sniper output contract (strict JSON array)

### Phase B - Query-Specific Input (dynamic; after cache boundary)
B1. Importance star rating (1-3)
B2. Original SQL plus original plan
B3. IR structure plus anchor hashes
B4. BDA table (ALL probes: status, speedup, explain delta, failure reasons)
B5. Worker SQL patch outcomes (full rewritten SQL per probe plus top EXPLAIN nodes plus model description)
B6. Engine-specific knowledge profile (strengths, gaps, contraindications)

---

## Dialect reminders

Use runtime-injected **Engine-Specific Knowledge** as authoritative.
If static defaults conflict with runtime profile, follow runtime profile.

---

## Regression Registry (hard bans)

Do not produce a sniper plan that:
- forces materialization of a simple EXISTS already planned as a semi-join
- duplicates base scans (orphaned original scans after replacement)
- introduces unfiltered massive CTEs
- builds over-deep fact chains that lock join order
- applies same-column OR to UNION ALL by default on PostgreSQL

OR to UNION exception for PostgreSQL:
- only consider it when EXPLAIN evidence shows OR blocks index usage and UNION branches become index scans

---

## Combination hazards (what to watch)

- **Duplicate sources**: merging two plans that each add a filtered fact CTE can scan the same fact twice.
- **Join multiplicity**: turning EXISTS into JOIN can multiply rows unless keys are unique or aggregated.
- **CTE fences**: materialized CTEs can block pushdown and join reorder.
- **Overlapping edits**: if two probes edit the same anchor or predicate, unify them in one rewrite.

---

## Evidence-first decision procedure (mechanical)

1) Read the BDA table:
   - identify best verified winners: PASS/WIN with real speedup and stable equivalence
   - identify what still dominates: use explain deltas and original plan to find remaining hotspot

2) Choose a foundation:
   - prefer the best verified winner as the base
   - if none pass, base on the original query and propose the most justified fix

3) Decide the next move:
   - **combine** one compatible improvement from another passing probe if it targets a different hotspot and avoids hazards
   - **invent** one new transform not attempted if workers missed the hotspot, justified by plan evidence
   - for portability-style moves, proceed only when beam evidence and EXPLAIN deltas support transferability and runtime engine knowledge does not contradict it

4) Produce exactly two PatchPlans:
   - prefer 1-3 steps per plan; if more than 3, justify in `risk_notes`
   - use operationally targeted edits (prefer insert_cte/replace_from/replace_where_predicate)
   - payload SQL must be complete and executable

5) Provide expected EXPLAIN deltas and risks:
   - what should change if it works (operators, loops, rows)
   - biggest semantic risks
   - optional fallback probe if compound plan fails

---

## Sniper Output Contract (MUST follow)

Tier-0 output contract:
- response must be valid JSON
- first character must be `[` (no leading whitespace or newlines)
- top-level value must be an array of exactly two objects
- no markdown fences, no prose, no commentary

Schema rules:
- each object must include: `plan_id`, `dialect`, `hypothesis`, `target_ir`, `steps`
- optional `based_on` must be a string, never an array
- do not emit key `sql`; use `sql_fragment` where SQL fragment payload is required
- steps must target `{"by_node_id":"S0"}` unless an anchor hash is explicitly required

Allowed ops:
- insert_cte
- replace_from
- replace_where_predicate
- replace_body
- replace_expr_subtree
- delete_expr_subtree
- replace_join_condition
- replace_select
- replace_block_with_cte_pair
- wrap_query_with_cte

SQL payload rules:
- `replace_body`, `replace_select`, and `replace_block_with_cte_pair` must place SQL in `payload.sql_fragment`
- payload SQL must be complete and executable

Output JSON shape:
[
  {
    "plan_id": "snipe_p1",
    "dialect": "<target_dialect>",
    "confidence": 0.81,
    "based_on": "p03,p11",
    "strategy": "Foundation plus one compatible add-on",
    "hypothesis": "Plan evidence and expected win mechanism",
    "target_ir": "Short structural description of final query shape",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {"sql_fragment": "SELECT c_customer_sk FROM customer"}
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "<target_dialect>",
    "confidence": 0.73,
    "based_on": "p07",
    "strategy": "Alternative independent pathway",
    "hypothesis": "Plan evidence for second pathway",
    "target_ir": "Alternative structural description",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "filtered_sales",
          "cte_query_sql": "SELECT ss_customer_sk FROM store_sales WHERE ss_quantity > 0"
        }
      }
    ]
  }
]

---

## Cache Boundary
Everything below is query-specific input.

## Query ID
query094_multi_i2

## Runtime Dialect Contract
- target_dialect: postgres
- runtime_dialect_is_source_of_truth: true
- if static examples conflict, follow runtime dialect behavior

## Importance
- importance_stars: 3
- importance_label: ***

## Original SQL
```sql
select 
   count(distinct ws_order_number) as "order count"
  ,sum(ws_ext_ship_cost) as "total shipping cost"
  ,sum(ws_net_profit) as "total net profit"
from
   web_sales ws1
  ,date_dim
  ,customer_address
  ,web_site
where
    d_date between '1999-10-01' and
           cast('1999-10-01' as date) + interval '60 day'
and ws1.ws_ship_date_sk = d_date_sk
and ws1.ws_ship_addr_sk = ca_address_sk
and ca_state in ('MO','MT','OK'
            ,'SC' ,'TX' ,'WI')
and ws1.ws_web_site_sk = web_site_sk
and web_gmt_offset >= -5
and ws1.ws_list_price between 253 and 282
and exists (select *
            from web_sales ws2
            where ws1.ws_order_number = ws2.ws_order_number
              and ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)
and not exists(select *
               from web_returns wr1
               where ws1.ws_order_number = wr1.wr_order_number
               and wr1.wr_reason_sk in (8, 18, 20, 23, 41)
               )
order by count(distinct ws_order_number)
limit 100;
```

## Original Plan
```
Limit  (rows=1, time=14088.269)
  Sort  (rows=1, time=14063.757)
    Aggregate  (rows=1, time=14063.706)
      Sort  (rows=1185, time=14063.601)
        Nested Loop  (rows=1185, time=14063.44)
          Gather  (rows=1672, time=14061.526)
            Nested Loop  (rows=557, time=13327.516)
              Nested Loop  (rows=557, time=13152.433)
                Hash Join  (rows=2820, time=12979.03)
                  Seq Scan on web_returns (wr1)  (rows=51578, time=1330.315)
                  Hash  (rows=3710, time=11638.12)
                    Nested Loop  (rows=3710, time=5813.535)
                      Seq Scan on date_dim  (rows=20, time=93.817)
                      Index Scan on web_sales (ws1)  (rows=182, time=281.17)
                Index Scan on customer_address  (rows=0, time=0.061)
              Index Only Scan on web_sales (ws2)  (rows=1, time=0.313)
          Materialize  (rows=19, time=0.001)
            Seq Scan on web_site  (rows=22, time=0.435)
```

## IR Structure + Anchor Hashes
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: web_sales ws1, date_dim, customer_address, web_site
    WHERE [7fc853016d94f2a4]: d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ws1.ws_ship_da...
    ORDER BY: COUNT(DISTINCT ws_order_number)

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Schema / Index / Stats Context
- source: postgres
- referenced_tables: 5

| Table | Rows(est) | PK | Indexes |
|-------|-----------|----|---------|
| customer_address | 250000 | ca_address_sk | customer_address_pkey |
| date_dim | 73049 | d_date_sk | date_dim_pkey, _dta_index_date_dim_6_661577395__k7_k4_k9_k1, _dta_index_date_dim_6_661577395__k7_k9_k1, _dta_index_date_dim_6_661577395__k1_k7_k9, _dta_index_date_dim_6_661577395__k7_k11_k1, _dta_index_date_dim_6_661577395__k9_k7_k1 |
| web_returns | 1440354 | wr_item_sk, wr_order_number | web_returns_pkey |
| web_sales | 7197533 | ws_item_sk, ws_order_number | web_sales_pkey, _dta_index_web_sales_6_1269579561__k3_k18_k12_k14_16_29_34, _dta_index_web_sales_6_1269579561__k1_k4_k5_18, _dta_index_web_sales_6_1269579561__k1_8_24, _dta_index_web_sales_6_1269579561__k18_16, _dta_index_web_sales_6_1269579561__k1_k5 |
| web_site | 42 | web_site_sk | web_site_pkey |

## Engine-Specific Knowledge
## Dialect Profile (POSTGRES)

**Combined Intelligence Baseline**: Combined intelligence baseline from 53 validated DSB queries at SF5-SF10, plus regression registry outcomes. PostgreSQL has bitmap index scans, JIT compilation, and aggressive CTE materialization. Techniques that work on DuckDB often regress here.

### Optimizer Strengths (don't fight these)
- `BITMAP_OR_SCAN`: Avoid splitting OR conditions into UNION ALL by default. Only consider OR→UNION when EXPLAIN shows OR blocks index usage and UNION branches become index scans. 0.21x and 0.26x reg…
- `SEMI_JOIN_EXISTS`: NEVER convert EXISTS to IN/NOT IN or materialized CTEs. 0.50x, 0.75x observed. Note: NOT EXISTS anti-join decorrelation can still be valid when replacing large correlated anti patterns.
- `INNER_JOIN_REORDERING`: Don't restructure INNER JOIN orders. Focus on LEFT JOIN blocking or comma-join confusion.
- `INDEX_ONLY_SCAN`: Small dimension lookups (<10K rows) may not need CTEs.

### Known Gaps (exploit these)
- `COMMA_JOIN_WEAKNESS` [HIGH] detect: FROM t1, t2, t3 WHERE t1.key = t2.key (comma joins, no explicit JOIN). Poor row estimates in EXPLAIN. | action: Convert comma-joins to explicit JOIN...ON syntax. Best when combined with date_cte_isolate.
- `CORRELATED_SUBQUERY_PARALYSIS` [HIGH] detect: Nested loop in EXPLAIN, inner re-executes aggregate per outer row. SQL: WHERE col > (SELECT AGG FROM ... WHERE outer.key = inner.key). Hash… | action: Convert correlated WHERE to explicit CTE with GROUP BY + JOIN.
- `NON_EQUI_JOIN_INPUT_BLINDNESS` [HIGH] detect: Expensive non-equi join (BETWEEN, <, >) with large inputs on both sides. Neither side filtered. | action: Reduce fact table input size via filtered CTE before the non-equi join.
- `CTE_MATERIALIZATION_FENCE` [MEDIUM] detect: Large CTE + small post-filter. Multi-referenced CTE that blocks predicate pushdown. | action: Materialize STRATEGICALLY: only when CTE is expensive and reused. Avoid fencing single-use cases.
- `CROSS_CTE_PREDICATE_BLINDNESS` [MEDIUM] detect: Sequential scan on dimension table without index condition. Late filter after large scan/join. | action: Pre-filter into CTE definition. But be more cautious than on DuckDB.

## Dispatcher Hypothesis
Cost spine dominated by Hash Join (12979 ms) and Nested Loop with 20 iterations (5813 ms). Correlated EXISTS/NOT EXISTS subqueries cause inefficient nested loops. Transform families B (decorrelation) and F (explicit joins + prefetching) should reduce work by precomputing sets and improving join planning.

## Dispatcher Reasoning Trace
- Hash Join consumes 92% of total time with 51k web_returns rows
- Nested Loop executes web_sales index scan 20 times (date_dim rows)
- Correlated subqueries force re-execution; decorrelation should convert to set operations
- Comma joins prevent optimal join ordering; explicit syntax required for PG optimizer

## Equivalence Tier
- exact

## Additional Intelligence
### AST Feature Detection

- **sf_sk_pushdown_multi_fact**: 100% match (DATE_DIM, MULTI_TABLE_5+) (gap: PREDICATE_TRANSITIVITY_FAILURE) [SUPPORT: portability_candidate; engines=snowflake]
- **materialize_cte**: 80% match (AGG_COUNT, AGG_SUM, BETWEEN, DATE_DIM) [SUPPORT: portability_candidate; engines=duckdb]
  Missing: CTE
- **inline_decorrelate_materialized**: 75% match (AGG_SUM, BETWEEN, DATE_DIM) (gap: CORRELATED_SUBQUERY_PARALYSIS)  [SUPPORT: native_or_universal]
  Missing: AGG_AVG
- **prefetch_fact_join**: 75% match (AGG_SUM, DATE_DIM, STAR_JOIN) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: MAX_2_CHAINS] [SUPPORT: portability_candidate; engines=duckdb]
  Missing: GROUP_BY
- **composite_decorrelate_union**: 67% match (AGG_COUNT, AGG_SUM, DATE_DIM, EXISTS) (gap: CORRELATED_SUBQUERY_PARALYSIS) [SUPPORT: portability_candidate; engines=duckdb]
  Missing: GROUP_BY, OR_BRANCH, TABLE_REPEAT_3+


## Probe Summary
12 probes fired, 0 passed validation, 0 showed speedup.

## BDA Table (all probes)

| Probe | Transform | Family | Status | Speedup | Top EXPLAIN Nodes | Model Description | SQL Patch | Error/Notes |
|-------|-----------|--------|--------|---------|-------------------|-------------------|-----------|-------------|
| p08 | date_cte_isolate | A | ERROR | - | - | Create filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE ...). Replace date_dim in FROM with filtered_dates | p08 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p03 | date_cte_explicit_join | F | ERROR | - | - | Create date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY'), then convert comma joins to INNER JOIN date_cte ON ws1.ws_ship_date_sk = date_cte.d_date_sk | p03 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p01 | early_filter_decorrelate | B | ERROR | - | - | Replace EXISTS subquery with CTE: WITH multi_warehouse AS (SELECT ws_order_number FROM web_sales GROUP BY ws_order_number HAVING COUNT(DISTINCT ws_warehouse_sk) > 1) THEN JOIN multi_warehouse ON ws1.ws_order_number = multi_warehouse.ws_order_number | p01 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p11 | decorrelate | B | ERROR | - | - | Minimal decorrelation: Create problem_orders AS (SELECT DISTINCT wr_order_number FROM web_returns WHERE wr_reason_sk IN (8,18,20,23,41)) without additional filters | p11 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p04 | dimension_prefetch_star | F | ERROR | - | - | Create ca_prefilter AS (SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('MO','MT','OK','SC','TX','WI')), site_prefilter AS (SELECT web_site_sk FROM web_site WHERE web_gmt_offset >= -5). Convert joins to INNER JOIN ca_prefilter ON ws1.ws_ship_addr_sk = ca_prefilter.ca_address_sk INNER JOIN site_prefilter ON ws1.ws_web_site_sk = site_prefilter.web_site_sk | p04 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p02 | early_filter_decorrelate | B | ERROR | - | - | Replace NOT EXISTS with CTE: WITH problem_returns AS (SELECT wr_order_number FROM web_returns WHERE wr_reason_sk IN (8,18,20,23,41) GROUP BY wr_order_number) THEN LEFT JOIN problem_returns ON ws1.ws_order_number = problem_returns.wr_order_number WHERE wr_order_number IS NULL | p02 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p10 | decorrelate | B | FAIL | - | - | Minimal decorrelation: Create warehouse_pairs AS (SELECT DISTINCT ws_order_number FROM web_sales ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk) without early filtering | p10 | Tier-1: LITERAL MISMATCH: Original literals missing from rewrite — numbers: ['18.0', '20.0', '23.0', '41.0', '8.0']. The rewrite changed filter values instead of preserving them. |
| p05 | pg_self_join_decomposition | E | ERROR | - | - | Create ws_base AS (SELECT ws_order_number, ws_warehouse_sk, ws_ext_ship_cost, ws_net_profit FROM web_sales WHERE ws_list_price BETWEEN 253 AND 282). Replace all ws1 references with ws_base and update EXISTS subquery to use ws_base | p05 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p06 | prefetch_fact_join | A | ERROR | - | - | Stage reduction: 1) date_cte (as p03), 2) ws_prefilter AS (SELECT * FROM web_sales INNER JOIN date_cte ON ws_ship_date_sk=d_date_sk WHERE ws_list_price BETWEEN 253 AND 282), 3) Join ws_prefilter with other dimensions | p06 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p07 | aggregate_pushdown | C | FAIL | - | - | Create ws_agg AS (SELECT ws_order_number, SUM(ws_ext_ship_cost) AS ship_cost, SUM(ws_net_profit) AS profit, MAX(ws_warehouse_sk) AS warehouse_sk FROM web_sales WHERE ... GROUP BY ws_order_number). Replace original ws1 with ws_agg in main FROM | p07 | Tier-1: LITERAL MISMATCH: Original literals missing from rewrite — numbers: ['18.0', '20.0', '23.0', '41.0', '8.0']. The rewrite changed filter values instead of preserving them. |
| p09 | composite_decorrelate_union | B | ERROR | - | - | Combine p01/p02 into single CTE: order_flags AS (SELECT o.ws_order_number, EXISTS(SELECT 1 FROM web_sales w WHERE w.ws_order_number=o.ws_order_number AND w.ws_warehouse_sk <> o.ws_warehouse_sk) AS multi_wh, EXISTS(SELECT 1 FROM web_returns ...) AS has_return FROM web_sales o). Then filter WHERE multi_wh=true AND has_return=false | p09 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p12 | single_pass_aggregation | C | ERROR | - | - | Consolidate aggregations: Create order_summary AS (SELECT ws_order_number, COUNT(DISTINCT ws_warehouse_sk) > 1 AS multi_wh, SUM(ws_ext_ship_cost) AS ship_cost, SUM(ws_net_profit) AS profit FROM web_sales ... GROUP BY ws_order_number). Replace main query with join to order_summary | p12 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |

## Worker SQL Patches

### p08: date_cte_isolate (ERROR, n/a)
```sql
WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY') SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM web_sales AS ws1 JOIN filtered_dates AS fd ON ws1.ws_ship_date_sk = fd.d_date_sk, customer_address, web_site WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND ws1.ws_web_site_sk = web_site_sk AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 AND EXISTS(SELECT * FROM web_sales AS ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk) AND NOT EXISTS(SELECT * FROM web_returns AS wr1 WHERE ws1.ws_order_number = wr1.wr_order_number AND wr1.wr_reason_sk IN (8, 18, 20, 23, 41)) ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p03: date_cte_explicit_join (ERROR, n/a)
```sql
WITH date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY') SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM web_sales AS ws1 INNER JOIN date_cte ON ws1.ws_ship_date_sk = date_cte.d_date_sk INNER JOIN customer_address ON ws1.ws_ship_addr_sk = customer_address.ca_address_sk INNER JOIN web_site ON ws1.ws_web_site_sk = web_site.web_site_sk WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND ws1.ws_web_site_sk = web_site_sk AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 AND EXISTS(SELECT * FROM web_sales AS ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk) AND NOT EXISTS(SELECT * FROM web_returns AS wr1 WHERE ws1.ws_order_number = wr1.wr_order_number AND wr1.wr_reason_sk IN (8, 18, 20, 23, 41)) ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p01: early_filter_decorrelate (ERROR, n/a)
```sql
WITH multi_warehouse AS (SELECT ws_order_number FROM web_sales GROUP BY ws_order_number HAVING COUNT(DISTINCT ws_warehouse_sk) > 1) SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM web_sales AS ws1, date_dim, customer_address, web_site WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND ws1.ws_web_site_sk = web_site_sk AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 AND ws1.ws_order_number IN (SELECT ws_order_number FROM multi_warehouse) AND NOT EXISTS(SELECT * FROM web_returns AS wr1 WHERE ws1.ws_order_number = wr1.wr_order_number AND wr1.wr_reason_sk IN (8, 18, 20, 23, 41)) ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p11: decorrelate (ERROR, n/a)
```sql
WITH problem_orders AS (SELECT DISTINCT wr_order_number FROM web_returns WHERE wr_reason_sk IN (8, 18, 20, 23, 41)) SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM web_sales AS ws1, date_dim, customer_address, web_site WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND ws1.ws_web_site_sk = web_site_sk AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 AND EXISTS(SELECT * FROM web_sales AS ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk) AND NOT EXISTS(SELECT 1 FROM problem_orders AS po WHERE ws1.ws_order_number = po.wr_order_number) ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p04: dimension_prefetch_star (ERROR, n/a)
```sql
WITH ca_prefilter AS (SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI')), site_prefilter AS (SELECT web_site_sk FROM web_site WHERE web_gmt_offset >= -5) SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM web_sales AS ws1 JOIN date_dim ON ws1.ws_ship_date_sk = d_date_sk JOIN ca_prefilter ON ws1.ws_ship_addr_sk = ca_prefilter.ca_address_sk JOIN site_prefilter ON ws1.ws_web_site_sk = site_prefilter.web_site_sk WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND ws1.ws_web_site_sk = web_site_sk AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 AND EXISTS(SELECT * FROM web_sales AS ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk) AND NOT EXISTS(SELECT * FROM web_returns AS wr1 WHERE ws1.ws_order_number = wr1.wr_order_number AND wr1.wr_reason_sk IN (8, 18, 20, 23, 41)) ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p02: early_filter_decorrelate (ERROR, n/a)
```sql
WITH problem_returns AS (SELECT wr_order_number FROM web_returns WHERE wr_reason_sk IN (8, 18, 20, 23, 41) GROUP BY wr_order_number) SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM web_sales AS ws1, date_dim, customer_address, web_site WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND ws1.ws_web_site_sk = web_site_sk AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 AND EXISTS(SELECT * FROM web_sales AS ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk) AND problem_returns.wr_order_number IS NULL ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p10: decorrelate (FAIL, n/a)
```sql
WITH warehouse_pairs AS (SELECT DISTINCT ws_order_number FROM web_sales AS ws2 WHERE EXISTS(SELECT 1 FROM web_sales AS ws3 WHERE ws2.ws_order_number = ws3.ws_order_number AND ws2.ws_warehouse_sk <> ws3.ws_warehouse_sk)) SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM web_sales AS ws1 JOIN date_dim ON ws1.ws_ship_date_sk = d_date_sk JOIN customer_address ON ws1.ws_ship_addr_sk = ca_address_sk JOIN web_site ON ws1.ws_web_site_sk = web_site_sk JOIN warehouse_pairs AS wp ON wp.ws_order_number = ws1.ws_order_number WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p05: pg_self_join_decomposition (ERROR, n/a)
```sql
WITH ws_base AS (SELECT ws_order_number, ws_warehouse_sk, ws_ext_ship_cost, ws_net_profit FROM web_sales WHERE ws_list_price BETWEEN 253 AND 282) SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM ws_base AS ws1, date_dim, customer_address, web_site WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND ws1.ws_web_site_sk = web_site_sk AND web_gmt_offset >= -5 AND EXISTS(SELECT * FROM ws_base AS ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk) AND NOT EXISTS(SELECT * FROM web_returns AS wr1 WHERE ws1.ws_order_number = wr1.wr_order_number AND wr1.wr_reason_sk IN (8, 18, 20, 23, 41)) ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p06: prefetch_fact_join (ERROR, n/a)
```sql
WITH date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY'), ws_prefilter AS (SELECT * FROM web_sales AS ws INNER JOIN date_cte AS dd ON ws.ws_ship_date_sk = dd.d_date_sk WHERE ws.ws_list_price BETWEEN 253 AND 282) SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM ws_prefilter AS ws1, customer_address, web_site WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND ws1.ws_web_site_sk = web_site_sk AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 AND EXISTS(SELECT * FROM web_sales AS ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk) AND NOT EXISTS(SELECT * FROM web_returns AS wr1 WHERE ws1.ws_order_number = wr1.wr_order_number AND wr1.wr_reason_sk IN (8, 18, 20, 23, 41)) ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p07: aggregate_pushdown (FAIL, n/a)
```sql
WITH ws_agg AS (SELECT ws_order_number, SUM(ws_ext_ship_cost) AS ship_cost, SUM(ws_net_profit) AS profit, MAX(ws_warehouse_sk) AS warehouse_sk FROM web_sales WHERE ws_list_price BETWEEN 253 AND 282 GROUP BY ws_order_number) SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM ws_agg JOIN date_dim ON ws_agg.ws_order_number = ws1.ws_order_number AND ws1.ws_ship_date_sk = d_date_sk JOIN customer_address ON ws1.ws_ship_addr_sk = ca_address_sk JOIN web_site ON ws1.ws_web_site_sk = web_site_sk WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p09: composite_decorrelate_union (ERROR, n/a)
```sql
WITH order_flags AS (SELECT o.ws_order_number, EXISTS(SELECT 1 FROM web_sales AS w WHERE w.ws_order_number = o.ws_order_number AND w.ws_warehouse_sk <> o.ws_warehouse_sk) AS multi_wh, NOT EXISTS(SELECT 1 FROM web_returns AS wr1 WHERE wr1.wr_order_number = o.ws_order_number AND wr1.wr_reason_sk IN (8, 18, 20, 23, 41)) AS has_return FROM web_sales AS o) SELECT COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit" FROM web_sales AS ws1 JOIN date_dim ON ws1.ws_ship_date_sk = d_date_sk JOIN customer_address ON ws1.ws_ship_addr_sk = ca_address_sk JOIN web_site ON ws1.ws_web_site_sk = web_site_sk JOIN order_flags AS OF ON ws1.ws_order_number = OF.ws_order_number WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 AND OF.multi_wh = TRUE AND OF.has_return = FALSE ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;
```

### p12: single_pass_aggregation (ERROR, n/a)
```sql
WITH order_summary AS (SELECT ws_order_number, COUNT(DISTINCT ws_warehouse_sk) > 1 AS multi_wh, SUM(ws_ext_ship_cost) AS ship_cost, SUM(ws_net_profit) AS profit FROM web_sales GROUP BY ws_order_number) SELECT COUNT(DISTINCT os.ws_order_number) AS "order count", SUM(os.ship_cost) AS "total shipping cost", SUM(os.profit) AS "total net profit" FROM order_summary AS os JOIN web_sales AS ws1 ON os.ws_order_number = ws1.ws_order_number JOIN date_dim AS dd ON ws1.ws_ship_date_sk = dd.d_date_sk JOIN customer_address AS ca ON ws1.ws_ship_addr_sk = ca.ca_address_sk JOIN web_site AS w ON ws1.ws_web_site_sk = w.web_site_sk WHERE dd.d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ca.ca_state IN ('MO', 'MT', 'OK', 'SC', 'TX', 'WI') AND w.web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 AND os.multi_wh = TRUE AND NOT EXISTS(SELECT 1 FROM web_returns AS wr1 WHERE os.ws_order_number = wr1.wr_order_number AND wr1.wr_reason_sk IN (8, 18, 20, 23, 41)) ORDER BY COUNT(DISTINCT os.ws_order_number) LIMIT 100;
```
