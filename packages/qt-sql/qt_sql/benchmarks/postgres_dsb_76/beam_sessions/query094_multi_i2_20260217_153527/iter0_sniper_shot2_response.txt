[
  {
    "plan_id": "snipe_p1",
    "dialect": "postgres",
    "confidence": 0.85,
    "based_on": "p02,p03",
    "strategy": "Explicit joins + NOT EXISTS decorrelation",
    "hypothesis": "Original comma joins prevent optimal planning. NOT EXISTS causes nested loop. Convert to explicit joins and replace NOT EXISTS with anti-join CTE while preserving EXISTS as native semi-join per PostgreSQL strengths.",
    "target_ir": "Explicit INNER JOINs with LEFT JOIN to problem_orders CTE; NOT EXISTS replaced by IS NULL check",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "problem_orders",
          "cte_query_sql": "SELECT wr_order_number FROM web_returns WHERE wr_reason_sk IN (8,18,20,23,41)"
        }
      },
      {
        "step_id": "s2",
        "op": "replace_from",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "web_sales ws1 INNER JOIN date_dim ON ws1.ws_ship_date_sk = date_dim.d_date_sk INNER JOIN customer_address ON ws1.ws_ship_addr_sk = customer_address.ca_address_sk INNER JOIN web_site ON ws1.ws_web_site_sk = web_site.web_site_sk LEFT JOIN problem_orders po ON ws1.ws_order_number = po.wr_order_number"
        }
      },
      {
        "step_id": "s3",
        "op": "replace_where_predicate",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY' AND ca_state IN ('MO','MT','OK','SC','TX','WI') AND web_gmt_offset >= -5 AND ws1.ws_list_price BETWEEN 253 AND 282 AND EXISTS (SELECT * FROM web_sales ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk) AND po.wr_order_number IS NULL"
        }
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "postgres",
    "confidence": 0.75,
    "based_on": "p01,p06,p12",
    "strategy": "Full decorrelation with filtered fact CTE",
    "hypothesis": "Nested loops from correlated subqueries dominate runtime. Precompute filtered fact set and convert both EXISTS/NOT EXISTS to explicit joins. Isolate date scan to reduce fact rows early.",
    "target_ir": "CTE chain: date_cte → ws_prefilter → multi_warehouse/problem_orders; explicit anti-join and semi-join in main query",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "WITH date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '1999-10-01' AND CAST('1999-10-01' AS DATE) + INTERVAL '60 DAY'), ws_prefilter AS (SELECT ws1.* FROM web_sales ws1 INNER JOIN date_cte ON ws1.ws_ship_date_sk = date_cte.d_date_sk WHERE ws1.ws_list_price BETWEEN 253 AND 282), multi_warehouse AS (SELECT ws_order_number FROM web_sales GROUP BY ws_order_number HAVING COUNT(DISTINCT ws_warehouse_sk) > 1), problem_orders AS (SELECT wr_order_number FROM web_returns WHERE wr_reason_sk IN (8,18,20,23,41)) SELECT COUNT(DISTINCT ws1.ws_order_number) AS \"order count\", SUM(ws1.ws_ext_ship_cost) AS \"total shipping cost\", SUM(ws1.ws_net_profit) AS \"total net profit\" FROM ws_prefilter ws1 INNER JOIN customer_address ON ws1.ws_ship_addr_sk = customer_address.ca_address_sk INNER JOIN web_site ON ws1.ws_web_site_sk = web_site.web_site_sk INNER JOIN multi_warehouse mw ON ws1.ws_order_number = mw.ws_order_number LEFT JOIN problem_orders po ON ws1.ws_order_number = po.wr_order_number WHERE customer_address.ca_state IN ('MO','MT','OK','SC','TX','WI') AND web_site.web_gmt_offset >= -5 AND po.wr_order_number IS NULL ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100"
        }
      }
    ]
  }
]