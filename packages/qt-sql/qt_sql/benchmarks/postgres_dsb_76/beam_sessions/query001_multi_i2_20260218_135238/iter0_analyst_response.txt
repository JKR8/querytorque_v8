{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The plan shows a severe correlated subquery bottleneck: the CTE ctr1 (2,902 rows) drives a nested loop that re-executes the correlated aggregate subquery 2,902 times, each scanning CTE ctr2 (2,394 rows). This 2,902 × 2,394 amplification (≈6.9M row touches) dominates the 262-second runtime. Secondary hotspots include the comma-join pattern in the CTE and late application of selective dimension filters.",
    "reasoning_trace": [
      "Primary hotspot: nested loop on CTE scan ctr1 (2,902 rows) with correlated subquery re-execution per row.",
      "Correlated subquery scans CTE ctr2 (2,394 rows) and aggregates to 1 row each iteration → 2,902 × 2,394 = ~6.9M row touches.",
      "CTE definition uses comma join (store_returns, date_dim) which may block predicate pushdown and optimal join planning.",
      "Dimension tables (store, customer, customer_demographics) have selective filters but are joined late after the expensive correlated loop.",
      "Plan shows severe cardinality misestimation at CTE scan: estimated 1 row, actual 2,902 rows (Q-error 2,902)."
    ],
    "cost_spine": ["Nested Loop (correlated subquery)", "CTE Scan ctr1", "CTE Scan ctr2", "Aggregate (per-row)", "Nested Loop (dimension joins)"],
    "hotspots": [
      {
        "op": "Nested Loop (correlated subquery)",
        "why": "Correlated aggregate subquery re-executes 2,902 times, scanning 2,394 rows each iteration.",
        "evidence": "rows=2,902, time=262,448 ms (99.9% of total runtime)"
      },
      {
        "op": "CTE definition (comma join)",
        "why": "Comma join may block predicate pushdown and optimal join ordering for store_returns + date_dim.",
        "evidence": "Comma-join pattern present, no explicit JOIN syntax"
      },
      {
        "op": "Dimension joins (store, customer, customer_demographics)",
        "why": "Selective filters applied late after expensive correlated loop, missing early reduction opportunity.",
        "evidence": "Filters: s_state IN ('IA','KY','NE'), cd_marital_status IN ('S','S'), cd_education_status IN ('4 yr Degree','4 yr Degree'), cd_gender='M', c_birth_month=4, c_birth_year BETWEEN 1987 AND 1993"
      }
    ],
    "do_not_do": [
      "Do not split OR conditions into UNION ALL (PostgreSQL BitmapOr is optimal)",
      "Do not materialize EXISTS paths (preserve semi-join optimization)",
      "Do not duplicate the CTE body to push filters inward",
      "Avoid same-column OR to UNION ALL decomposition"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "target": "Decompose correlated scalar subquery into 3 MATERIALIZED CTEs: (1) pre-filter date_dim for d_year=2000, (2) compute store_returns aggregates with early date filter, (3) compute per-store average threshold. Then join threshold CTE in main query.",
      "dag_target_hint": "Replace correlated subquery with precomputed per-store average CTE joined on ctr_store_sk.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year=2000", "sr_return_amt/sr_return_quantity BETWEEN 115 AND 174"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_store_sk", "ctr_reason_sk", "ctr_total_return", "GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.95,
      "expected_explain_delta": "Correlated nested loop disappears; replaced by hash join between ctr1 and precomputed per-store average CTE.",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate", "replace_from"],
      "rank_rationale": "Direct attack on primary hotspot — eliminates 2,902× re-execution of correlated aggregate.",
      "recommended_examples": ["pg_shared_scan_decorrelate", "inline_decorrelate_materialized"],
      "gold_example_id": "pg_shared_scan_decorrelate"
    },
    {
      "probe_id": "p02",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Push dimension filters into CTE definitions before materialization, and decorrelate correlated subquery by precomputing thresholds in separate CTEs.",
      "dag_target_hint": "Create filtered dimension CTEs for store, customer, customer_demographics; compute per-store average from filtered fact data.",
      "node_contract": {
        "from_must_include": ["store", "customer", "customer_demographics"],
        "where_must_preserve": ["s_state IN ('IA','KY','NE')", "cd_marital_status IN ('S','S')", "cd_education_status IN ('4 yr Degree','4 yr Degree')", "cd_gender='M'", "c_birth_month=4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Dimension filters applied early, reducing rows entering correlated subquery; decorrelation removes nested loop.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Combines early filtering with decorrelation — addresses both primary hotspot and late filter application.",
      "recommended_examples": ["early_filter_decorrelate"],
      "gold_example_id": "early_filter_decorrelate"
    },
    {
      "probe_id": "p03",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Materialize selective date_dim filter into a CTE and convert comma join to explicit JOIN syntax in the customer_total_return CTE definition.",
      "dag_target_hint": "Change CTE definition from 'store_returns, date_dim WHERE ...' to 'store_returns JOIN date_dim_cte ON sr_returned_date_sk = d_date_sk'.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year=2000", "sr_return_amt/sr_return_quantity BETWEEN 115 AND 174"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_store_sk", "ctr_reason_sk", "ctr_total_return", "GROUP BY keys"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.80,
      "expected_explain_delta": "Explicit join enables better hash join planning; date filter pushed into tiny CTE.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Addresses comma-join weakness in CTE definition — may improve join order and predicate pushdown.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.80,
      "expected_explain_delta": "Explicit join enables better hash join planning; date filter pushed into tiny CTE.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Addresses comma-join weakness in CTE definition — may improve join order and predicate pushdown.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p04",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre-filter all selective dimensions (store, customer, customer_demographics) into CTEs before joining with the fact-derived CTE, using explicit JOIN syntax.",
      "dag_target_hint": "Create CTEs for filtered store, customer, customer_demographics; join them with customer_total_return using explicit INNER JOIN.",
      "node_contract": {
        "from_must_include": ["store", "customer", "customer_demographics"],
        "where_must_preserve": ["s_state IN ('IA','KY','NE')", "cd_marital_status IN ('S','S')", "cd_education_status IN ('4 yr Degree','4 yr Degree')", "cd_gender='M'", "c_birth_month=4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Dimension filters applied early via CTEs; explicit joins replace comma joins; reduced rows flow into main query.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Targets secondary hotspot — early dimension filtering and explicit join conversion.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p04",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre-filter all selective dimensions (store, customer, customer_demographics) into separate CTEs, then join them with the fact-derived CTE using explicit JOIN syntax.",
      "dag_target_hint": "Create CTEs for filtered store, customer, customer_demographics; rewrite main FROM clause as explicit joins between these CTEs and customer_total_return.",
      "node_contract": {
        "from_must_include": ["store", "customer", "customer_demographics"],
        "where_must_preserve": ["s_state IN ('IA','KY','NE')", "cd_marital_status IN ('S','S')", "cd_education_status IN ('4 yr Degree','4 yr Degree')", "cd_gender='M'", "c_birth_month=4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.78,
      "expected_explain_delta": "Tiny dimension CTEs build small hash tables; explicit join order improves cardinality estimates and join planning.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Multi-dimension prefetch variant — more aggressive early filtering than single-dimension CTE.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p05",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize the store_returns + date_dim join once as a CTE, then derive both ctr1 and the per-store average from the same materialized result, avoiding duplicate scans.",
      "dag_target_hint": "Create a base CTE with store_returns joined to date_dim (filtered), then define ctr1 and ctr2 as aggregates on that base CTE.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year=2000", "sr_return_amt/sr_return_quantity BETWEEN 115 AND 174"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_store_sk", "ctr_reason_sk", "ctr_total_return", "GROUP BY keys"]
      },
      "gates_checked": ["G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_EXISTS_INTERSECT_RISK:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.70,
      "expected_explain_delta": "Single materialized scan of store_returns+date_dim; both ctr1 and ctr2 derived from same CTE; correlated subquery becomes join between two aggregates of same source.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Shared materialization approach — reduces fact table scans and enables decorrelation via self-join on aggregated CTE.",
      "recommended_examples": ["pg_self_join_decomposition"],
      "gold_example_id": "pg_self_join_decomposition"
    },
    {
      "probe_id": "p06",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Stage reduction for the non-equi join (ctr_total_return > avg*1.2): pre-filter dimensions, pre-aggregate fact data, then compute threshold and join in a single pass.",
      "dag_target_hint": "Create CTE chain: filtered dimensions → pre-aggregated fact data → per-store average threshold → final join.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["d_year=2000", "sr_return_amt/sr_return_quantity BETWEEN 115 AND 174", "s_state IN ('IA','KY','NE')", "cd_marital_status IN ('S','S')", "cd_education_status IN ('4 yr Degree','4 yr Degree')", "cd_gender='M'", "c_birth_month=4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_NONEQUI_PRESENT:PASS", "G_PG_NONEQUI_CARDINALITY:PASS", "G_PG_NONEQUI_FILTER_QUALITY:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.72,
      "expected_explain_delta": "Non-equi join inputs dramatically reduced by early filtering; single-pass computation of threshold.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Targets non-equi join bottleneck with staged reduction — complements decorrelation.",
      "recommended_examples": ["pg_materialized_dimension_fact_prefilter"],
      "gold_example_id": "pg_materialized_dimension_fact_prefilter"
    },
    {
      "probe_id": "p07",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate store_returns by sr_customer_sk, sr_store_sk, sr_reason_sk before joining with date_dim, reducing rows early.",
      "dag_target_hint": "Change customer_total_return CTE to aggregate store_returns first, then join to date_dim on sr_returned_date_sk = d_date_sk.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year=2000", "sr_return_amt/sr_return_quantity BETWEEN 115 AND 174"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_store_sk", "ctr_reason_sk", "ctr_total_return", "GROUP BY keys"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Aggregating fact table before joining dimension may reduce rows flowing into the CTE, though date filter must still be applied correctly.",
      "confidence": 0.60,
      "expected_explain_delta": "Fewer rows join with date_dim; CTE result size may shrink.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Exploration — tests aggregation pushdown below join with date_dim.",
      "rank_rationale": "Exploration — tests if aggregate pushdown reduces CTE size before decorrelation.",
      "recommended_examples": ["aggregate_pushdown"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p08",
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "target": "Build a CTE chain: filter date_dim → join with store_returns → aggregate → then join with filtered dimensions.",
      "dag_target_hint": "Stage joins: date_dim CTE → store_returns join → aggregate → then join store, customer, customer_demographics CTEs.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["d_year=2000", "sr_return_amt/sr_return_quantity BETWEEN 115 AND 174", "s_state IN ('IA','KY','NE')", "cd_marital_status IN ('S','S')", "cd_education_status IN ('4 yr Degree','4 yr Degree')", "cd_gender='M'", "c_birth_month=4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Staged join pipeline may improve predicate pushdown and reduce intermediate result sizes, though may introduce materialization fences.",
      "confidence": 0.55,
      "expected_explain_delta": "Progressive reduction in each CTE stage; explicit join ordering.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Exploration — tests staged reduction pipeline for multi-join query.",
      "recommended_examples": ["prefetch_fact_join"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p09",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre-filter all dimension tables (date_dim, store, customer, customer_demographics) into separate CTEs before any fact table join.",
      "dag_target_hint": "Create CTEs for each dimension with their respective filters, then join them with store_returns in a single CTE.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["d_year=2000", "sr_return_amt/sr_return_quantity BETWEEN 115 AND 174", "s_state IN ('IA','KY','NE')", "cd_marital_status IN ('S','S')", "cd_education_status IN ('4 yr Degree','4 yr Degree')", "cd_gender='M'", "c_birth_month=4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS", "G_PG_CROSS_CTE_PREDICATE_BLINDNESS", "support": "portability_candidate", "engines": "duckdb"],
      "exploration": true,
      "exploration_hypothesis": "Multi-dimension prefetch may compound selectivity and drastically reduce fact table rows, but portability candidate for DuckDB; test on PostgreSQL.",
      "confidence": 0.50,
      "expected_explain_delta": "Tiny dimension CTEs; fact table join only matches rows satisfying all dimension filters early.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Exploration — portability candidate; tests if multi-dimension prefetch works on PostgreSQL.",
      "recommended_examples": ["multi_dimension_prefetch"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p10",
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "target": "Extract shared dimension filters (date_dim, store, customer, customer_demographics) into a single CTE that returns surrogate keys, then join with store_returns.",
      "dag_target_hint": "Create a CTE that joins all filtered dimensions and returns their keys; then join with store_returns on those keys.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["d_year=2000", "sr_return_amt/sr_return_quantity BETWEEN 115 AND 174", "s_state IN ('IA','KY','NE')", "cd_marital_status IN ('S','S')", "cd_education_status IN ('4 yr Degree','4 yr Degree')", "cd_gender='M'", "c_birth_month=4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Shared dimension extraction may reduce redundant dimension scans, but may create a larger CTE than individual prefetch.",
      "confidence": 0.48,
      "expected_explain_delta": "Single dimension CTE with all keys; fact table join reduced by combined selectivity.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_syntax"],
      "rank_rationale": "Exploration — variant of multi-dimension prefetch with shared CTE.",
      "recommended_examples": ["shared_dimension_multi_channel"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p11",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Force materialization of the customer_total_return CTE with MATERIALIZED keyword to avoid repeated scans in correlated subquery.",
      "dag_target_hint": "Add MATERIALIZED keyword to CTE definition to ensure it is materialized once.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year=2000", "sr_return_amt/sr_return_quantity BETWEEN 115 AND 174"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_store_sk", "ctr_reason_sk", "ctr_total_return", "GROUP BY keys"]
      },
      "gates_checked": ["G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_EXISTS_INTERSECT_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Materializing the CTE may reduce repeated scanning, but does not address the correlated execution pattern.",
      "confidence": 0.45,
      "expected_explain_delta": "CTE materialized once; correlated subquery still re-executes but scans materialized CTE instead of underlying tables.",
      "recommended_patch_ops": ["add_materialized_keyword"],
      "rank_rationale": "Exploration — low-risk probe to test if materialization alone helps.",
      "recommended_examples": ["materialize_cte"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p12",
      "transform_id": "inner_join_conversion",
      "family": "F",
      "target": "Convert comma joins in main query to explicit INNER JOIN syntax, preserving all predicates.",
      "dag_target_hint": "Change FROM clause from 'customer_total_return ctr1, store, customer, customer_demographics' to explicit JOINs with ON conditions.",
      "node_contract": {
        "from_must_include": ["customer_total_return ctr1", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["ctr1.ctr_total_return > (subquery)", "ctr1.ctr_reason_sk BETWEEN 17 AND 20", "s_store_sk = ctr1.ctr_store_sk", "s_state IN ('IA','KY','NE')", "ctr1.ctr_customer_sk = c_customer_sk", "c_current_cdemo_sk = cd_demo_sk", "cd_marital_status IN ('S','S')", "cd_education_status IN ('4 yr Degree','4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Explicit join syntax may improve join ordering and predicate pushdown in the main query.",
      "confidence": 0.65,
      "expected_explain_delta": "Explicit JOINs replace comma joins; planner may choose better join order.",
      "recommended_patch_ops": ["replace_from", "replace_join_syntax"],
      "rank_rationale": "Exploration — low-risk syntax change that may unlock better planning.",
      "recommended_examples": ["pg_explicit_join_materialized"],
      "gold_example_id": "pg_explicit_join_materialized"
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan; PostgreSQL BitmapOr handles indexed OR efficiently."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT operation in query."
    },
    {
      "transform_id": "union_cte_split",
      "family": "D",
      "reason": "No UNION or repeated CTE scans with different filters."
    },
    {
      "transform_id": "rollup_to_union_windowing",
      "family": "D",
      "reason": "No GROUP BY ROLLUP in query."
    },
    {
      "transform_id": "channel_bitmap_aggregation",
      "family": "C",
      "reason": "No repeated scans of same fact table with different time/channel buckets."
    },
    {
      "transform_id": "single_pass_aggregation",
      "family": "C",
      "reason": "No multiple scalar subqueries on same table to consolidate."
    },
    {
      "transform_id": "deferred_window_aggregation",
      "family": "C",
      "reason": "No window functions in query."
    },
    {
      "transform_id": "composite_decorrelate_union",
      "family": "B",
      "reason": "No multiple correlated EXISTS sharing common filters."
    },
    {
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "reason": "Snowflake-specific transform; PostgreSQL native alternatives available."
    },
    {
      "transform_id": "sf_shared_scan_decorrelate",
      "family": "B",
      "reason": "Snowflake-specific transform; PostgreSQL native alternatives available."
    },
    {
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "reason": "Snowflake-specific transform for micro-partition pruning."
    },
    {
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "reason": "Snowflake-specific transform for UNION ALL branches."
    },
    {
      "transform_id": "self_join_decomposition",
      "family": "F",
      "reason": "No CTE self-join with different filter values."
    }
  ]
}