{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Dominant hotspot is correlated scalar subquery (CTE ctr1 > AVG(ctr2) per store) forcing nested-loop re-execution of aggregate over materialized CTE (rows=2902 * 2394). Secondary hotspot is comma-join shaping preventing dimension pre‑filter pushdown, resulting in late filter application after large join. Misestimation (est=1, act=2,902) at CTE scan indicates planner cannot see per‑store groups before final join.",
    "reasoning_trace": [
      "CTE Scan (ctr1) cost spine dominates time (262,448 ms).",
      "Correlated subquery plan shows Aggregate (rows=1) under CTE Scan, indicating per‑row re‑execution of CTE ctr2.",
      "Comma joins in CTE and main query block early dimension filter pushdown (date_dim, store, customer, customer_demographics).",
      "Estimation q‑error >2900 at CTE scan suggests planner lacks visibility into CTE's grouped cardinality.",
      "No nested loops on fact scans; indexes used for small dimension lookups."
    ],
    "cost_spine": [
      "CTE Scan (ctr1)",
      "Aggregate (subquery per ctr1 row)",
      "Nested Loop (ctr1 × store × customer × customer_demographics)"
    ],
    "hotspots": [
      {
        "op": "CTE Scan (ctr1) with nested subquery",
        "why": "correlated scalar aggregate forces per‑store re‑scan of CTE ctr2",
        "evidence": "time=262448 ms, rows=2902, sub‑plan rows=2394 repeated"
      },
      {
        "op": "Nested Loop (main join)",
        "why": "comma‑join shape prevents dimension filter pushdown, leading to late selectivity",
        "evidence": "rows=242 after store join, rows=6 after customer join"
      },
      {
        "op": "CTE definition (store_returns × date_dim)",
        "why": "fact‑dimension join with filters may benefit from explicit join + pre‑filter CTE",
        "evidence": "Index Only Scan on date_dim (122 rows), Index Scan on store_returns (255 rows)"
      }
    ],
    "do_not_do": [
      "Do not split OR predicates into UNION ALL (no OR in query).",
      "Do not materialize EXISTS (no EXISTS in query).",
      "Do not duplicate large CTE bodies (CTE already materialized).",
      "Do not convert correlated subquery if plan already shows decorrelated hash join (plan shows nested loop)."
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "target": "De‑correlate scalar subquery by pre‑computing per‑store average in a separate MATERIALIZED CTE, then join CTE ctr1 with that CTE via ctr_store_sk.",
      "dag_target_hint": "Replace correlated subquery with CTE store_avg that computes AVG(ctr_total_return)*1.2 per ctr_store_sk, then join ctr1 to store_avg.",
      "node_contract": {
        "from_must_include": ["customer_total_return ctr1", "store s", "customer c", "customer_demographics cd"],
        "where_must_preserve": ["ctr1.ctr_reason_sk BETWEEN 17 AND 20", "s.s_state IN ('IA', 'KY', 'NE')", "cd.cd_marital_status IN ('S', 'S')", "cd.cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd.cd_gender = 'M'", "c.c_birth_month = 4", "c.c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.92,
      "expected_explain_delta": "Nested loop subplan replaced by hash join between ctr1 and store_avg CTE; per‑store aggregate computed once.",
      "recommended_patch_ops": ["insert_cte_store_avg", "replace_where_predicate", "replace_from_join"],
      "rank_rationale": "Directly addresses primary hotspot (correlated subquery) with PostgreSQL‑native decorrelation pattern.",
      "recommended_examples": ["pg_shared_scan_decorrelate"],
      "gold_example_id": "pg_shared_scan_decorrelate"
    },
    {
      "probe_id": "p02",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Convert comma joins in CTE definition and main query to explicit INNER JOIN syntax, and push date_dim filter early via a pre‑filtered date CTE.",
      "dag_target_hint": "Change CTE definition from `store_returns, date_dim` to `store_returns INNER JOIN date_dim ON sr_returned_date_sk = d_date_sk`. Also convert main FROM list to explicit JOINs.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity BETWEEN 115 AND 174", "ctr1.ctr_reason_sk BETWEEN 17 AND 20", "s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_store_sk", "ctr_reason_sk", "ctr_total_return", "c_customer_id"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Explicit joins allow better join order decisions; date filter pushed before join.",
      "recommended_patch_ops": ["replace_comma_join_with_inner_join", "create_date_cte", "rewrite_cte_definition"],
      "rank_rationale": "Targets comma‑join weakness; early date filter reduces CTE rows.",
      "recommended_examples": ["pg_date_cte_explicit_join", "pg_explicit_join_materialized"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p03",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre‑filter all selective dimension tables (date_dim, store, customer, customer_demographics) into separate MATERIALIZED CTEs, then join them with CTE ctr1 via explicit JOIN syntax.",
      "dag_target_hint": "Create CTEs for filtered date_dim, store, customer, customer_demographics; then join CTE ctr1 with these CTEs using explicit INNER JOIN.",
      "node_contract": {
        "from_must_include": ["customer_total_return ctr1"],
        "where_must_preserve": ["ctr1.ctr_reason_sk BETWEEN 17 AND 20", "s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.80,
      "expected_explain_delta": "Dimension filters applied before main join; CTE ctr1 joins with tiny pre‑filtered dimension CTEs.",
      "recommended_patch_ops": ["create_dimension_ctes", "replace_from_with_cte_joins"],
      "rank_rationale": "Addresses secondary hotspot (late filter) and comma‑join weakness; leverages PostgreSQL materialization for small dimension sets.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p04",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Combine early dimension filtering with decorrelation: create CTEs for filtered date_dim, store, customer, customer_demographics, then decorrelate the subquery using pre‑computed store averages.",
      "dag_target_hint": "Push dimension filters into CTE definitions; compute store_avg from filtered CTE; join ctr1 with store_avg and dimension CTEs.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity BETWEEN 115 AND 174", "ctr1.ctr_reason_sk BETWEEN 17 AND 20", "s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.88,
      "expected_explain_delta": "Correlated subquery removed; dimension filters applied early; join order improved.",
      "recommended_patch_ops": ["create_filtered_dimension_ctes", "insert_store_avg_cte", "replace_from_join_structure"],
      "rank_rationale": "Combines two high‑impact families (A and B) to attack both primary and secondary hotspots.",
      "recommended_examples": ["early_filter_decorrelate"],
      "gold_example_id": "early_filter_decorrelate"
    },
    {
      "probe_id": "p05",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize the CTE once, then compute store‑level averages from the same materialized CTE to avoid re‑scanning the base tables.",
      "dag_target_hint": "Keep CTE customer_total_return as MATERIALIZED; create a second CTE store_avg that reads from customer_total_return and groups by ctr_store_sk; join ctr1 with store_avg.",
      "node_contract": {
        "from_must_include": ["customer_total_return ctr1"],
        "where_must_preserve": ["ctr1.ctr_reason_sk BETWEEN 17 AND 20"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_EXISTS_INTERSECT_RISK:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "CTE scanned once; store_avg derived from materialized CTE, eliminating repeated base table scans.",
      "recommended_patch_ops": ["add_materialized_hint", "create_store_avg_cte_from_ctr", "replace_subquery_with_cte_join"],
      "rank_rationale": "Uses PostgreSQL CTE materialization to avoid repeated fact‑dimension joins in subquery.",
      "recommended_examples": ["pg_self_join_decomposition"],
      "gold_example_id": "pg_self_join_decomposition"
    },
    {
      "probe_id": "p06",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Stage reduction: create MATERIALIZED CTEs for filtered date_dim and store_returns (pre‑joined), then compute per‑store aggregates, then join with filtered customer and demographics.",
      "dag_target_hint": "Build a CTE chain: filtered date_dim → filtered store_returns → aggregated customer_total_return → store_avg → final join.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity BETWEEN 115 AND 174"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_store_sk", "ctr_reason_sk", "ctr_total_return"]
      },
      "gates_checked": ["G_PG_NONEQUI_PRESENT:PASS", "G_PG_NONEQUI_CARDINALITY:PASS", "G_PG_NONEQUI_FILTER_QUALITY:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.78,
      "expected_explain_delta": "Fact‑dimension join pre‑materialized; store‑level aggregate computed from reduced set; final join with tiny dimension CTEs.",
      "recommended_patch_ops": ["create_fact_dimension_cte", "create_store_avg_cte", "replace_main_query_with_cte_chain"],
      "rank_rationale": "Gold example family F; pre‑filters fact table before aggregation and join.",
      "recommended_examples": ["pg_materialized_dimension_fact_prefilter"],
      "gold_example_id": "pg_materialized_dimension_fact_prefilter"
    },
    {
      "probe_id": "p07",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Push aggregation below the dimension join: compute store‑level averages directly from store_returns and date_dim, before joining with customer and reason dimensions.",
      "dag_target_hint": "Create CTE store_avg_raw that groups store_returns by store_sk and date filter, then join with customer_total_return and other dimensions.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity BETWEEN 115 AND 174"],
        "output_must_preserve": ["AVG(ctr_total_return)*1.2 per store_sk"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Planner may not push aggregate below join due to CTE fence; manual pushdown could reduce rows before customer/reason join.",
      "confidence": 0.65,
      "expected_explain_delta": "Store‑level aggregate computed earlier, reducing rows flowing into correlated subquery.",
      "recommended_patch_ops": ["insert_store_avg_raw_cte", "rewrite_subquery_to_use_raw_avg"],
      "rank_rationale": "Exploration of family C; may reduce work if planner fails to push aggregate through CTE.",
      "recommended_examples": ["aggregate_pushdown"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p08",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Pre‑filter dimension tables (date_dim, store, customer, customer_demographics) into CTEs before any join, using explicit JOIN syntax.",
      "dag_target_hint": "Create CTEs for each dimension with their respective filters; join them sequentially with CTE ctr1.",
      "node_contract": {
        "from_must_include": ["date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["d_year = 2000", "s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["all original dimension keys"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Early dimension filtering may improve join order and reduce rows early, even though dimensions are small.",
      "confidence": 0.60,
      "expected_explain_delta": "Dimension CTEs become tiny hash tables; join order may shift to broadcast small dimensions early.",
      "recommended_patch_ops": ["create_dimension_ctes", "replace_comma_joins_with_explicit_joins"],
      "rank_rationale": "Exploration of family A; simple early filter pushdown may help planner.",
      "recommended_examples": ["early_filter"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p09",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre‑filter all dimensions into a single CTE that joins date_dim, store, customer, customer_demographics, producing a composite key set before joining with CTE ctr1.",
      "dag_target_hint": "Create CTE dim_combo that joins all filtered dimensions; then join dim_combo with CTE ctr1 on surrogate keys.",
      "node_contract": {
        "from_must_include": ["date_dim", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["d_year = 2000", "s_state IN ('IA', 'KY', 'NE')", "cd_marital_status IN ('S', 'S')", "cd_education_status IN ('4 yr Degree', '4 yr Degree')", "cd_gender = 'M'", "c_birth_month = 4", "c_birth_year BETWEEN 1987 AND 1993"],
        "output_must_preserve": ["composite key set for join with ctr1"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Combining dimension filters into one CTE may allow better cardinality estimation and join ordering.",
      "confidence": 0.55,
      "expected_explain_delta": "Single dimension CTE reduces join complexity; planner may choose more efficient join order.",
      "recommended_patch_ops": ["create_combined_dimension_cte", "replace_multiple_dimension_joins_with_one"],
      "rank_rationale": "Exploration of family A; multi‑dimension prefetch may improve join planning.",
      "recommended_examples": ["multi_dimension_prefetch"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p10",
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "target": "Stage dimension filtering and fact join in a CTE chain: filter date_dim, join with store_returns, then aggregate, then join with other dimensions.",
      "dag_target_hint": "Create CTE fact_filtered that joins date_dim and store_returns with filters, then aggregate, then join with store, customer, demographics.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity BETWEEN 115 AND 174"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_store_sk", "ctr_reason_sk", "ctr_total_return"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Staged join pipeline may reduce fact table scan rows earlier, though indexes already limit date_dim rows.",
      "confidence": 0.50,
      "expected_explain_delta": "Fact join performed early with filtered date_dim; aggregation before remaining dimension joins.",
      "recommended_patch_ops": ["create_fact_filtered_cte", "rewrite_cte_chain"],
      "rank_rationale": "Exploration of family A; may reduce fact scan volume further.",
      "recommended_examples": ["prefetch_fact_join"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p11",
      "transform_id": "decorrelate",
      "family": "B",
      "target": "De‑correlate using portable pattern: compute store averages in a separate CTE without MATERIALIZED hint, relying on planner to flatten.",
      "dag_target_hint": "Create CTE store_avg as SELECT ctr_store_sk, AVG(ctr_total_return)*1.2 AS avg_val FROM customer_total_return GROUP BY ctr_store_sk; join ctr1 with store_avg.",
      "node_contract": {
        "from_must_include": ["customer_total_return ctr1"],
        "where_must_preserve": ["ctr1.ctr_reason_sk BETWEEN 17 AND 20"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Portable decorrelation may still work, but PostgreSQL may inline CTE and re‑correlate; worth testing as exploration.",
      "confidence": 0.45,
      "expected_explain_delta": "Correlated subquery replaced by join; CTE may be inlined, leading to decorrelated hash join.",
      "recommended_patch_ops": ["insert_store_avg_cte", "replace_subquery_with_cte_join"],
      "rank_rationale": "Exploration of portable decorrelation; lower confidence due to PostgreSQL CTE inlining behavior.",
      "recommended_examples": ["decorrelate"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p12",
      "transform_id": "sf_shared_scan_decorrelate",
      "family": "B",
      "target": "Snowflake‑style shared‑scan decorrelation: create a single CTE that computes both per‑(customer,store,reason) aggregates and per‑store averages in one pass, then self‑join.",
      "dag_target_hint": "Create CTE customer_store_reason_agg as SELECT sr_customer_sk, sr_store_sk, sr_reason_sk, SUM(...) AS ctr_total_return, AVG(SUM(...)) OVER (PARTITION BY sr_store_sk) AS store_avg FROM store_returns, date_dim WHERE ... GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk; then filter ctr_total_return > store_avg*1.2.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "sr_return_amt / sr_return_quantity BETWEEN 115 AND 174"],
        "output_must_preserve": ["c_customer_id", "ORDER BY c_customer_id", "LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Single‑pass aggregation with window function may avoid CTE materialization and correlated subquery entirely.",
      "confidence": 0.40,
      "expected_explain_delta": "Correlated subquery eliminated; single CTE with window aggregate; join replaced by filter on window function.",
      "recommended_patch_ops": ["create_window_aggregate_cte", "replace_where_with_window_filter"],
      "rank_rationale": "Exploration of portable shared‑scan pattern; lower confidence due to PostgreSQL window performance versus materialized CTE.",
      "recommended_examples": ["sf_shared_scan_decorrelate"],
      "gold_example_id": ""
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate in query; plan does not show OR‑related bottleneck."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT or set operations in query."
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "No LEFT JOIN with WHERE filter on right table; all joins are inner."
    },
    {
      "transform_id": "union_cte_split",
      "family": "D",
      "reason": "No UNION or repeated CTE scans with different filters."
    },
    {
      "transform_id": "materialize_cte",
      "family": "E",
      "reason": "CTE is already materialized by default in PostgreSQL; adding MATERIALIZED keyword is redundant."
    },
    {
      "transform_id": "single_pass_aggregation",
      "family": "C",
      "reason": "No multiple scalar subqueries scanning same table; only one correlated aggregate."
    },
    {
      "transform_id": "channel_bitmap_aggregation",
      "family": "C",
      "reason": "No repeated fact scans across different channels/buckets."
    },
    {
      "transform_id": "deferred_window_aggregation",
      "family": "C",
      "reason": "No window functions in query."
    },
    {
      "transform_id": "composite_decorrelate_union",
      "family": "B",
      "reason": "No multiple correlated EXISTS; only one correlated scalar aggregate."
    },
    {
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "reason": "Snowflake‑specific; PostgreSQL native inline_decorrelate_materialized is preferred."
    },
    {
      "transform_id": "self_join_decomposition",
      "family": "F",
      "reason": "No self‑join with different filter values; CTE is joined with itself but via correlated subquery, not self‑join."
    },
    {
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "reason": "Snowflake‑specific micro‑partition pruning; not applicable to PostgreSQL."
    },
    {
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "reason": "Snowflake‑specific; no UNION ALL in query."
    },
    {
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "reason": "No multiple channel CTEs with shared dimension filters."
    },
    {
      "transform_id": "multi_date_range_cte",
      "family": "A",
      "reason": "No multiple date ranges or repeated date_dim joins."
    },
    {
      "transform_id": "date_cte_isolate",
      "family": "A",
      "reason": "date_dim is already small and indexed; early filter may not yield significant gain."
    },
    {
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "reason": "Similar to early_filter; dropped in favor of more comprehensive dimension_prefetch_star."
    },
    {
      "transform_id": "rollup_to_union_windowing",
      "family": "D",
      "reason": "No GROUP BY ROLLUP in query."
    },
    {
      "transform_id": "multi_intersect_exists_cte",
      "family": "D",
      "reason": "No INTERSECT or multiple EXISTS."
    }
  ]
}