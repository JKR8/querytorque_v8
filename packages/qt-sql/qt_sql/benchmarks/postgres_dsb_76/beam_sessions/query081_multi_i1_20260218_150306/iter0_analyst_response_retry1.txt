```json
{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Correlated subquery re-executes per row of CTE scan (SubPlan 2), scanning 10,502 rows repeatedly with nested loop amplification. Plan shows zero-row estimation at sequential scan (est=899K, act=0), indicating cross-CTE boundary statistics blindness. Primary bottleneck is correlated scalar aggregate subquery; secondary hotspot is comma-join topology blocking predicate pushdown.",
    "reasoning_trace": [
      "SubPlan 2 (correlated aggregate) re-executes for each row of ctr1 CTE scan (10,502 rows)",
      "Zero-row estimation at parallel seq scan on catalog_returns indicates cross-CTE boundary statistics failure",
      "CTE materialization fence prevents predicate pushdown between correlated subquery and main filter",
      "Comma-join pattern in CTE definition may inhibit optimal join ordering",
      "Plan cost spine: Nested Loop (SubPlan) → CTE Scan → Nested Loop (Hash Join) → Sort → Limit"
    ],
    "cost_spine": ["Nested Loop (SubPlan)", "CTE Scan", "Nested Loop (Hash Join)", "Sort", "Limit"],
    "hotspots": [
      {
        "op": "SubPlan 2 (correlated aggregate)",
        "why": "Re-executes per outer CTE row; CTE scan blocks statistics propagation",
        "evidence": "cost=236.43 per execution × 10,502 rows = ~2.5M cost amplification"
      },
      {
        "op": "CTE Scan on customer_total_return ctr1",
        "why": "Materialization fence prevents predicate pushdown; correlated filter applied late",
        "evidence": "Filter: (ctr_total_return > (SubPlan 2)) after materialization"
      },
      {
        "op": "Parallel Seq Scan on catalog_returns",
        "why": "Zero-row estimation indicates statistics boundary failure",
        "evidence": "est=899300, act=0 (zero estimation)"
      }
    ],
    "do_not_do": [
      "OR-to-UNION transform (PostgreSQL uses BitmapOr for indexed OR)",
      "Materialize simple EXISTS paths (PostgreSQL semi-join optimization)",
      "Duplicate CTE bodies with >5 table joins (G_PG_CTE_DUPLICATION_BLOCK guard)",
      "Aggressive decorrelation on multi-fact shape (previous attempt 2 failed)"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "target": "Decompose correlated scalar subquery into 3 MATERIALIZED CTEs: (1) pre-filtered date_dim, (2) fact+dimension base data, (3) per-state aggregate thresholds, then JOIN threshold CTE instead of correlated subquery.",
      "dag_target_hint": "Replace final_select WHERE filter with CTE join on ctr_state.",
      "node_contract": {
        "from_must_include": ["customer_total_return ctr1", "customer_address", "customer"],
        "where_must_preserve": ["ctr1.ctr_total_return > state_avg.ctr_avg * 1.2", "ca_state = 'IA'", "ca_address_sk = c_current_addr_sk", "ctr1.ctr_customer_sk = c_customer_sk"],
        "output_must_preserve": ["all original output columns and ORDER BY/LIMIT"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.89,
      "expected_explain_delta": "SubPlan disappears; CTE scan filter replaced with hash join to precomputed state averages.",
      "recommended_patch_ops": ["create_cte_state_avg", "create_cte_base_data", "replace_where_with_join", "add_materialized_hint"],
      "rank_rationale": "Directly addresses primary correlated subquery hotspot with PostgreSQL-native MATERIALIZED CTE pattern.",
      "recommended_examples": ["pg_shared_scan_decorrelate", "inline_decorrelate_materialized"],
      "gold_example_id": "pg_shared_scan_decorrelate"
    },
    {
      "probe_id": "p02",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Push date_dim filter into CTE definition and decorrelate by pre-computing per-state average in separate CTE, then join with main CTE using state key.",
      "dag_target_hint": "Modify customer_total_return CTE definition and add state_avg CTE.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["cr_returned_date_sk = d_date_sk", "d_year = 2000", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return grouping"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_FACT_COUNT:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Correlated subquery replaced with CTE join; early date filter reduces CTE size.",
      "recommended_patch_ops": ["split_cte_state_avg", "decorrelate_filter", "replace_subquery_with_join"],
      "rank_rationale": "Combines early filtering with decorrelation; previous attempt 1 included this transform but may have had implementation issues.",
      "recommended_examples": ["early_filter_decorrelate"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p03",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Split self-join pattern (CTE scanned twice with correlation) into separate specialized CTEs: one for base data, one for state aggregates, using MATERIALIZED hints to prevent re-inlining.",
      "dag_target_hint": "Create ctr_base and ctr_state_avg CTEs, then join in final_select.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "join predicates unchanged"],
        "output_must_preserve": ["Same grouping keys and aggregates for both CTEs"]
      },
      "gates_checked": ["G_PG_CTE_REUSE_REQUIRED:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_EXISTS_INTERSECT_RISK:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.68,
      "expected_explain_delta": "CTE self-join replaced with two separate materialized CTEs; correlation eliminated.",
      "recommended_patch_ops": ["create_cte_base", "create_cte_state_agg", "replace_self_join_with_cte_join"],
      "rank_rationale": "Addresses CTE materialization fence that blocks statistics; uses PostgreSQL MATERIALIZED optimization.",
      "recommended_examples": ["pg_explicit_join_materialized"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p04",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Isolate date_dim filter into MATERIALIZED CTE and convert comma joins to explicit JOIN syntax in CTE definition.",
      "dag_target_hint": "Change customer_total_return CTE FROM clause to explicit JOINs.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "join conditions preserved"],
        "output_must_preserve": ["Same columns and aggregates"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.72,
      "expected_explain_delta": "Comma joins become explicit JOINs; date filter isolated in CTE for better cardinality estimates.",
      "recommended_patch_ops": ["create_date_cte", "replace_comma_with_join", "add_materialized_hint"],
      "rank_rationale": "Addresses comma-join weakness and statistics boundary; previous attempt 1 included this transform.",
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p05",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre-filter selective dimensions (date_dim year=2000, customer_address state='IA') into MATERIALIZED CTEs before main CTE aggregation, using explicit JOIN syntax.",
      "dag_target_hint": "Create date_filtered and ca_filtered CTEs, join in customer_total_return CTE.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "ca_state = 'IA' for final filter"],
        "output_must_preserve": ["All original columns for downstream joins"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:MANUAL_REVIEW"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.65,
      "expected_explain_delta": "Explicit JOINs with pre-filtered dimension CTEs improve cardinality estimates and reduce early join work.",
      "recommended_patch_ops": ["create_dimension_ctes", "replace_comma_with_join", "push_filters_into_ctes"],
      "rank_rationale": "Multi-dimension prefetch with explicit joins; gold example shows 3.32x speedup.",
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p06",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate catalog_returns by (cr_returning_customer_sk, ca_state) before joining with date_dim and customer_address in CTE definition.",
      "dag_target_hint": "Modify customer_total_return CTE to aggregate fact table first, then join dimensions.",
      "node_contract": {
        "from_must_include": ["catalog_returns"],
        "where_must_preserve": ["Group by cr_returning_customer_sk, ca_state", "Sum of cr_return_amt_inc_tax"],
        "output_must_preserve": ["Same aggregate result for downstream correlation"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Early aggregation reduces rows before dimension joins, but may interfere with date filter selectivity.",
      "confidence": 0.55,
      "expected_explain_delta": "GroupAggregate moves earlier in plan; dimension joins work with pre-aggregated keys.",
      "recommended_patch_ops": ["rewrite_cte_aggregation_order", "verify_join_key_preservation"],
      "rank_rationale": "Exploration: family C not yet tried; may reduce CTE size before correlated subquery execution.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p07",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Create MATERIALIZED CTE with date_dim filter and catalog_returns join, then compute per-state aggregates from that CTE to break correlation.",
      "dag_target_hint": "Replace original CTE with two CTEs: filtered_base and state_aggregates.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk"],
        "output_must_preserve": ["All columns needed for customer_address join and state aggregation"]
      },
      "gates_checked": ["G_PG_NONEQUI_PRESENT:SKIP", "G_PG_NONEQUI_CARDINALITY:PASS", "G_PG_CTE_DUPLICATION_BLOCK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Staged reduction via materialized CTE may provide better statistics for planner despite no non-equi join.",
      "confidence": 0.60,
      "expected_explain_delta": "Single materialized CTE replaces original CTE; correlation broken via separate aggregate CTE.",
      "recommended_patch_ops": ["create_materialized_base_cte", "create_aggregate_cte", "replace_original_cte"],
      "rank_rationale": "Exploration: gold example shows 12.07x speedup; applies to CTE boundary statistics issue.",
      "recommended_examples": ["pg_materialized_dimension_fact_prefilter"],
      "gold_example_id": "pg_materialized_dimension_fact_prefilter"
    },
    {
      "probe_id": "p08",
      "transform_id": "decorrelate",
      "family": "B",
      "target": "Convert correlated subquery to standalone CTE with GROUP BY ctr_state, then JOIN with main CTE using ctr_state key.",
      "dag_target_hint": "Create state_avg CTE computing AVG(ctr_total_return) per state, join in final_select.",
      "node_contract": {
        "from_must_include": ["customer_total_return ctr2"],
        "where_must_preserve": ["Group by ctr_state", "AVG(ctr_total_return)*1.2 calculation"],
        "output_must_preserve": ["Join condition ctr1.ctr_state = state_avg.ctr_state"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Portable decorrelation approach may work where PostgreSQL-specific transforms failed.",
      "confidence": 0.50,
      "expected_explain_delta": "Correlated subquery replaced with independent CTE and hash join.",
      "recommended_patch_ops": ["create_state_avg_cte", "replace_subquery_with_join", "verify_multiplicity"],
      "rank_rationale": "Exploration: portable version of decorrelation; previous attempt 2 failed but may succeed with different implementation.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p09",
      "transform_id": "sf_shared_scan_decorrelate",
      "family": "B",
      "target": "Shared-scan variant: decompose correlated scalar subquery into shared CTE for base data and separate CTE for per-state thresholds.",
      "dag_target_hint": "Create shared_base CTE with all needed columns, then derive state aggregates from it.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "join predicates"],
        "output_must_preserve": ["All columns needed for both main and threshold calculations"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_FACT_COUNT:PASS", "portability_candidate:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Snowflake pattern may translate to PostgreSQL via CTE materialization; gold example shows massive speedup.",
      "confidence": 0.45,
      "expected_explain_delta": "Single shared scan replaces duplicated CTE scans; correlation eliminated via CTE derivation.",
      "recommended_patch_ops": ["create_shared_scan_cte", "derive_state_aggregates", "replace_subquery_with_cte_join"],
      "rank_rationale": "Exploration: high-impact gold example (8043x) but Snowflake-specific; test PostgreSQL translation.",
      "recommended_examples": ["pg_shared_scan_decorrelate"],
      "gold_example_id": "pg_shared_scan_decorrelate"
    },
    {
      "probe_id": "p10",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Isolate date_dim and customer_address filters into separate MATERIALIZED CTEs before joining with catalog_returns.",
      "dag_target_hint": "Create date_2000 and ca_all CTEs, join in customer_total_return CTE.",
      "node_contract": {
        "from_must_include": ["date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "no filter on customer_address in CTE"],
        "output_must_preserve": ["Surrogate keys for joins with fact table"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SETOP_RISK:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Early dimension isolation may improve join cardinality estimates and enable better pushdown.",
      "confidence": 0.48,
      "expected_explain_delta": "Dimension CTEs materialized as tiny hash tables; comma joins become explicit joins.",
      "recommended_patch_ops": ["create_dimension_ctes", "replace_comma_with_join", "add_materialized_hint"],
      "rank_rationale": "Exploration: family A underrepresented; addresses comma-join weakness with early filtering.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p11",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre-filter both date_dim (year=2000) and customer_address (state='IA') into separate CTEs, then join with catalog_returns in CTE definition.",
      "dag_target_hint": "Create date_filtered and ca_ia CTEs, join with catalog_returns using explicit JOIN syntax.",
      "node_contract": {
        "from_must_include": ["date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "ca_state = 'IA'"],
        "output_must_preserve": ["Surrogate keys for fact table joins"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:MANUAL_REVIEW"],
      "exploration": true,
      "exploration_hypothesis": "Multi-dimension prefetch may reduce fact table scan rows through combined selectivity.",
      "confidence": 0.42,
      "expected_explain_delta": "Two dimension CTEs create small hash tables; fact scan reduced by early join filtering.",
      "recommended_patch_ops": ["create_date_cte", "create_ca_cte", "rewrite_cte_with_prefetch"],
      "rank_rationale": "Exploration: family A variant; attempts to address zero-row estimation issue via early filtering.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p12",
      "transform_id": "self_join_decomposition",
      "family": "F",
      "target": "Split CTE into specialized versions: ctr_base with all data, ctr_ia filtered for state='IA', and compute state averages from ctr_base.",
      "dag_target_hint": "Create two CTEs with different filters, join in final_select without correlation.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "separate filters for IA vs all states"],
        "output_must_preserve": ["Same schema across CTEs for join compatibility"]
      },
      "gates_checked": ["G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Self-join decomposition may break correlation by materializing separate CTEs for different filter contexts.",
      "confidence": 0.40,
      "expected_explain_delta": "CTE self-join eliminated; each CTE materialized with specific filter set.",
      "recommended_patch_ops": ["create_specialized_ctes", "replace_correlation_with_cte_join", "verify_multiplicity"],
      "rank_rationale": "Exploration: secondary hotspot coverage; family F variant targeting CTE scan pattern.",
      "recommended_examples": [],
      "gold_example_id": ""
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate in query; PostgreSQL BitmapOr guard prohibits default OR-to-UNION."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT operation in query; transform not applicable."
    },
    {
      "transform_id": "union_cte_split",
      "family": "D",
      "reason": "No UNION operations in query; transform not applicable."
    },
    {
      "transform_id": "channel_bitmap_aggregation",
      "family": "C",
      "reason": "No repeated fact table scans with different channel filters; single catalog_returns scan."
    },
    {
      "transform_id": "single_pass_aggregation",
      "family": "C",
      "reason": "No multiple scalar subqueries on same table; single correlated aggregate."
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "No LEFT JOIN in query; all joins are INNER/comma joins."
    },
    {
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "reason": "Snowflake-specific transform; no BETWEEN predicate pattern in query."
    },
    {
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "reason": "Snowflake-specific transform; no UNION ALL branches in query."
    },
    {
      "transform_id": "composite_decorrelate_union",
      "family": "B",
      "reason": "No multiple correlated EXISTS patterns; single correlated aggregate."
    }
  ]
}
```