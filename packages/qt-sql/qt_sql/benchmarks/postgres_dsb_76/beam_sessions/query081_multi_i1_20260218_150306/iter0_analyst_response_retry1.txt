{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The plan's dominant hotspot is a correlated scalar subquery (SubPlan 2) re-executing for each of 3501 outer rows, causing O(n²) behavior. Secondary hotspots include a large sequential scan on catalog_returns and comma-join patterns that may block predicate pushdown and optimal join ordering.",
    "reasoning_trace": [
      "SubPlan 2 (correlated aggregate) scans CTE ctr2 3501 times, each scanning 53 rows, total ~185k rows vs. outer CTE scan of 3501 rows.",
      "Parallel Seq Scan on catalog_returns scans 899k rows (est) with zero rows filtered after join (ZERO_EST mismatch).",
      "CTE customer_total_return uses comma joins (catalog_returns, date_dim, customer_address) which may prevent optimal filter pushdown.",
      "Plan shows no nested loops in the CTE definition, but the main query has nested loops driven by the correlated subquery."
    ],
    "cost_spine": [
      "CTE Scan on customer_total_return ctr1 with Filter (SubPlan 2)",
      "SubPlan 2: Aggregate -> CTE Scan on customer_total_return ctr2",
      "Parallel Seq Scan on catalog_returns",
      "Nested Loop (customer_total_return -> customer -> customer_address)"
    ],
    "hotspots": [
      {
        "op": "SubPlan 2 (correlated aggregate)",
        "why": "Correlated scalar subquery re-executes per outer row (3501 times), causing repeated CTE scans.",
        "evidence": "Rows=3501 for outer CTE scan, SubPlan cost=236.44 per execution, total cost dominated by CTE Scan on ctr1 (2,483,355.43)."
      },
      {
        "op": "Parallel Seq Scan on catalog_returns",
        "why": "Large fact table scan with zero rows filtered after join (ZERO_EST), indicating late filter application.",
        "evidence": "Est=899k rows, act=0 rows filtered after join (ZERO_EST mismatch)."
      },
      {
        "op": "Comma joins in CTE definition",
        "why": "Implicit join syntax may block predicate pushdown and optimal join ordering.",
        "evidence": "CTE defined with FROM catalog_returns, date_dim, customer_address (comma joins)."
      }
    ],
    "do_not_do": [
      "Do not split same-column OR predicates into UNION ALL (PostgreSQL BitmapOr is optimal).",
      "Do not materialize simple EXISTS subqueries (PostgreSQL semi-join optimization is effective).",
      "Do not duplicate heavy CTE bodies (CTE_MATERIALIZATION_FENCE guard).",
      "Avoid decorrelation on multi-fact join shapes (G_PG_CORR_FACT_COUNT guard)."
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "target": "Decompose correlated scalar subquery into three MATERIALIZED CTEs: (1) pre-filter date_dim for d_year=2000, (2) pre-join catalog_returns with filtered date_dim and customer_address to compute per-state aggregates, (3) join outer CTE with precomputed state averages.",
      "dag_target_hint": "Replace SubPlan 2 with a CTE containing state averages, then join on ctr_state.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return", "ORDER BY and LIMIT behavior"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.90,
      "expected_explain_delta": "SubPlan 2 disappears; CTE scan on ctr2 replaced by a single aggregate CTE; nested loop eliminated.",
      "recommended_patch_ops": ["insert_cte", "replace_subplan_with_join", "materialize_cte"],
      "recommended_examples": ["pg_shared_scan_decorrelate", "inline_decorrelate_materialized"],
      "rank_rationale": "Targets primary hotspot — correlated subquery drives O(n²) behavior.",
      "gold_example_id": "pg_shared_scan_decorrelate"
    },
    {
      "probe_id": "p02",
      "transform_id": "date_cte_explicit_join",
      "family": "A",
      "target": "Isolate date_dim filter into a CTE and convert comma joins to explicit JOIN syntax in the customer_total_return CTE definition.",
      "dag_target_hint": "Change CTE customer_total_return FROM clause to explicit JOINs with filtered date_dim CTE.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Comma joins become explicit JOINs; date_dim filter pushed into a tiny CTE; hash join order may improve.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "rank_rationale": "Addresses secondary hotspot — comma joins may block filter pushdown.",
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p03",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Prefilter all selective dimensions (date_dim, customer_address) into CTEs before joining with catalog_returns, using explicit JOIN syntax.",
      "dag_target_hint": "Replace CTE customer_total_return with a chain of CTEs: filtered date_dim, filtered customer_address, then join with catalog_returns.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.70,
      "expected_explain_delta": "Dimension tables materialized as tiny hash tables; fact table scan reduced via early join; explicit JOIN syntax enables better cardinality estimates.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "rank_rationale": "Addresses secondary hotspot — comma joins and late filtering on catalog_returns.",
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p04",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Combine early filtering of dimensions with decorrelation of the scalar subquery by precomputing state averages in a CTE after filtering dimensions.",
      "dag_target_hint": "Create filtered dimension CTEs, then compute per-state aggregates in a separate CTE, then join in main query.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return", "ORDER BY and LIMIT behavior"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.80,
      "expected_explain_delta": "SubPlan 2 eliminated; dimension filters applied early; fact table scan reduced.",
      "recommended_patch_ops": ["insert_cte", "replace_subplan_with_join", "replace_from"],
      "recommended_examples": ["early_filter_decorrelate"],
      "rank_rationale": "Combines early filtering (family A) with decorrelation (family B) for compounded impact.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p05",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Materialize filtered dimension CTEs and pre-join with fact table to reduce rows before the main query's correlated subquery.",
      "dag_target_hint": "Create CTE with filtered dimensions joined to catalog_returns, then compute per-state aggregates from that CTE.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return"]
      },
      "gates_checked": ["G_PG_NONEQUI_PRESENT:FAIL", "G_PG_NONEQUI_CARDINALITY:FAIL"],
      "exploration": true,
      "exploration_hypothesis": "Even without non-equi join, materializing filtered dimension-fact join may reduce rows entering the correlated subquery.",
      "confidence": 0.55,
      "expected_explain_delta": "CTE customer_total_return becomes a materialized join of filtered dimensions and fact; SubPlan 2 scans smaller CTE.",
      "recommended_patch_ops": ["insert_cte", "materialize_cte", "replace_from"],
      "recommended_examples": ["pg_materialized_dimension_fact_prefilter"],
      "rank_rationale": "Exploration — gold example shows 12.07x speedup for non-equi joins; testing applicability here.",
      "gold_example_id": "pg_materialized_dimension_fact_prefilter"
    },
    {
      "probe_id": "p06",
      "transform_id": "pg_explicit_join_materialized",
      "family": "F",
      "target": "Convert comma joins to explicit JOINs and materialize the CTE to force a fence, potentially improving join order decisions.",
      "dag_target_hint": "Change CTE customer_total_return to use explicit JOINs and add MATERIALIZED keyword.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.65,
      "expected_explain_delta": "Explicit JOINs enable better join ordering; MATERIALIZED CTE may prevent re-scanning of dimensions.",
      "recommended_patch_ops": ["replace_from", "materialize_cte"],
      "recommended_examples": ["pg_explicit_join_materialized"],
      "rank_rationale": "Gold example shows 8.56x speedup; targets comma-join weakness.",
      "gold_example_id": "pg_explicit_join_materialized"
    },
    {
      "probe_id": "p07",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate catalog_returns by (cr_returning_customer_sk, ca_state) before joining with date_dim and customer_address.",
      "dag_target_hint": "Push GROUP BY and SUM into a subquery that joins catalog_returns with date_dim and customer_address.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Aggregation pushdown may reduce rows early, but the CTE already aggregates after joins; this probe tests if pushing aggregation before joins reduces work.",
      "confidence": 0.50,
      "expected_explain_delta": "GroupAggregate moves below joins; fewer rows flow through joins.",
      "recommended_patch_ops": ["replace_from", "push_group_by"],
      "recommended_examples": ["aggregate_pushdown"],
      "rank_rationale": "Exploration — family C underrepresented; tests if early aggregation reduces join cost.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p08",
      "transform_id": "self_join_decomposition",
      "family": "F",
      "target": "Split the CTE self-join (ctr1 vs ctr2) into separate CTEs: one for outer rows, one for state averages.",
      "dag_target_hint": "Create two CTEs: ctr1 as original CTE, ctr2 as pre-aggregated state averages CTE.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return", "ORDER BY and LIMIT behavior"]
      },
      "gates_checked": ["G_PG_CTE_DUPLICATION_BLOCK:PASS", "G_PG_CTE_REUSE_REQUIRED:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Splitting the CTE may allow the optimizer to push filters differently and avoid correlated subquery.",
      "confidence": 0.60,
      "expected_explain_delta": "CTE self-join becomes two independent CTEs; SubPlan 2 replaced by join between CTEs.",
      "recommended_patch_ops": ["insert_cte", "replace_subplan_with_join"],
      "recommended_examples": ["self_join_decomposition"],
      "rank_rationale": "Exploration — targets CTE self-join pattern in correlated subquery.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p09",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Prefilter date_dim and customer_address into separate CTEs, then join with catalog_returns in the CTE definition.",
      "dag_target_hint": "Create CTE for filtered date_dim, CTE for filtered customer_address, then join with catalog_returns.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Prefiltering both dimensions may reduce catalog_returns scan more than filtering just date_dim.",
      "confidence": 0.55,
      "expected_explain_delta": "Dimension CTEs become tiny hash tables; catalog_returns scan reduced via early join.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "recommended_examples": ["multi_dimension_prefetch"],
      "rank_rationale": "Exploration — family A variant; tests multi-dimension prefetch impact.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p10",
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "target": "Stage join pipeline: filter date_dim, join with catalog_returns, then join with customer_address, all in CTE chain.",
      "dag_target_hint": "Create CTE chain: filtered date_dim -> join catalog_returns -> join customer_address.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return"]
      },
      "gates_checked": ["G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS", "G_PG_CROSS_CTE_SCALE_GUARD:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Staged join pipeline may reduce intermediate row count more effectively than single join.",
      "confidence": 0.50,
      "expected_explain_delta": "Sequential joins reduce rows early; catalog_returns scan filtered by date_dim first.",
      "recommended_patch_ops": ["insert_cte", "replace