{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The plan is dominated by a correlated scalar subquery (SubPlan 2) re-executing 3501 times against a materialized CTE, causing a nested-loop amplification of 185,553 rows (3501*53). The CTE itself performs a large parallel seq scan on catalog_returns (899K rows) with comma joins, limiting predicate pushdown. The primary bottleneck is the correlated subquery; secondary hotspots are the large fact scan and comma-join shape.",
    "reasoning_trace": [
      "SubPlan 2 (correlated aggregate) executes 3501 times, each scanning 53 rows from CTE ctr2.",
      "CTE customer_total_return scans catalog_returns via parallel seq scan (899K rows) with comma joins.",
      "Plan shows ZERO_EST cardinality error at catalog_returns scan, indicating statistic blindness.",
      "No nested loops in CTE join path, but main query has nested loop join between CTE scan and customer.",
      "Gold example pg_shared_scan_decorrelate shows 8043x speedup for similar correlated subquery pattern."
    ],
    "cost_spine": [
      "Nested Loop (main query)",
      "CTE Scan on customer_total_return ctr1 with SubPlan filter",
      "Aggregate (SubPlan 2)",
      "CTE Scan on customer_total_return ctr2",
      "Finalize GroupAggregate (CTE definition)",
      "Parallel Seq Scan on catalog_returns"
    ],
    "hotspots": [
      {
        "op": "SubPlan 2 (correlated aggregate)",
        "why": "Correlated scalar subquery re-executes per outer row (3501 times), causing nested-loop amplification.",
        "evidence": "SubPlan 2 inside CTE Scan filter; rows=53 per execution, loops=3501."
      },
      {
        "op": "Parallel Seq Scan on catalog_returns",
        "why": "Large fact table scan (899K rows) with ZERO_EST cardinality error; comma joins may block predicate pushdown.",
        "evidence": "cost=51979.00, rows=899300, est vs actual mismatch."
      },
      {
        "op": "Nested Loop (main query)",
        "why": "Join between CTE scan (3501 rows) and customer via index scan; driver order may be suboptimal.",
        "evidence": "cost=2502823.87, rows=3501."
      }
    ],
    "do_not_do": [
      "Do not split same-column OR predicates into UNION ALL (PostgreSQL BitmapOr is optimal).",
      "Do not materialize simple EXISTS paths (PostgreSQL semi-join optimization is protected).",
      "Do not duplicate heavy CTE bodies (CTE materialization fence risk).",
      "Avoid decorrelation on already-flattened correlated subqueries (check plan for SubPlan)."
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "target": "Decompose correlated scalar subquery into three MATERIALIZED CTEs: (1) pre-filter date_dim for d_year=2000, (2) pre-join catalog_returns with filtered date_dim and customer_address to compute per-state aggregates, (3) compute state-level average threshold. Then join threshold CTE in main query, removing correlation.",
      "dag_target_hint": "Replace SubPlan 2 with a join to a precomputed state_avg CTE; rewrite final_select FROM clause.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "ca_state = 'IA'", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return", "final ORDER BY and LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.95,
      "expected_explain_delta": "SubPlan 2 disappears; CTE scan filter becomes a join to state_avg CTE; nested-loop amplification eliminated.",
      "recommended_patch_ops": ["insert_cte", "replace_subquery_with_join", "add_materialized_hint"],
      "recommended_examples": ["pg_shared_scan_decorrelate"],
      "rank_rationale": "Primary hotspot: eliminates correlated subquery nested-loop amplification.",
      "gold_example_id": "pg_shared_scan_decorrelate"
    },
    {
      "probe_id": "p02",
      "transform_id": "date_cte_explicit_join",
      "family": "A",
      "target": "Extract date_dim filter (d_year=2000) into a MATERIALIZED CTE, then join explicitly with catalog_returns and customer_address using explicit JOIN syntax, converting comma joins.",
      "dag_target_hint": "Rewrite customer_total_return CTE definition to use explicit JOINs and pre-materialized date filter.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["cr_returning_customer_sk", "ca_state", "sum(cr_return_amt_inc_tax) as ctr_total_return"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Comma joins become explicit INNER JOINs; date_dim filter is pushed into a small materialized CTE; hash join order may improve.",
      "recommended_patch_ops": ["insert_cte", "replace_comma_with_join", "add_materialized_hint"],
      "recommended_examples": ["pg_date_cte_explicit_join"],
      "rank_rationale": "Secondary hotspot: addresses comma-join weakness and may improve predicate pushdown.",
      "gold_example_id": "pg_date_cte_explicit_join"
    },
    {
      "probe_id": "p03",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Create MATERIALIZED CTEs for filtered date_dim (d_year=2000) and customer_address (ca_state='IA'), then pre-join with catalog_returns to reduce rows before aggregation.",
      "dag_target_hint": "Rewrite customer_total_return CTE to stage dimension filters first, then join with fact.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "ca_state = 'IA'", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["cr_returning_customer_sk", "ca_state", "sum(cr_return_amt_inc_tax) as ctr_total_return"]
      },
      "gates_checked": ["G_PG_NONEQUI_PRESENT:FAIL", "G_PG_NONEQUI_CARDINALITY:FAIL"],
      "exploration": true,
      "exploration_hypothesis": "Even without non-equi join, pre-materializing dimension filters may improve join order and reduce fact scan rows.",
      "confidence": 0.60,
      "expected_explain_delta": "Dimension CTEs become tiny hash tables; fact table scan reduces via early join; parallel seq scan cost drops.",
      "recommended_patch_ops": ["insert_cte", "replace_comma_with_join", "add_materialized_hint"],
      "recommended_examples": ["pg_materialized_dimension_fact_prefilter"],
      "rank_rationale": "Exploration: targets secondary hotspot (fact scan) via dimension prefiltering.",
      "gold_example_id": "pg_materialized_dimension_fact_prefilter"
    },
    {
      "probe_id": "p04",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Pre-filter date_dim and customer_address into separate MATERIALIZED CTEs, then join with catalog_returns using explicit JOIN syntax, converting comma joins.",
      "dag_target_hint": "Rewrite customer_total_return CTE with staged dimension CTEs and explicit joins.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "ca_state = 'IA'", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["cr_returning_customer_sk", "ca_state", "sum(cr_return_amt_inc_tax) as ctr_total_return"]
      },
      "gates_checked": ["G_PG_COMMA_JOIN_PRESENT:PASS", "G_PG_COMMA_FACT_FANOUT:PASS", "G_PG_COMMA_SEMANTIC:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Explicit join conversion combined with dimension prefetch may improve cardinality estimates and join order.",
      "confidence": 0.65,
      "expected_explain_delta": "Explicit joins replace comma joins; dimension CTEs are materialized; hash join planning improves.",
      "recommended_patch_ops": ["insert_cte", "replace_comma_with_join", "add_materialized_hint"],
      "recommended_examples": ["pg_dimension_prefetch_star"],
      "rank_rationale": "Exploration: addresses comma-join weakness and dimension filter pushdown.",
      "gold_example_id": "pg_dimension_prefetch_star"
    },
    {
      "probe_id": "p05",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Combine dimension prefiltering (date_dim, customer_address) with decorrelation of the scalar subquery by precomputing state averages in a CTE, using explicit joins.",
      "dag_target_hint": "Rewrite both CTE definition and main query to push filters early and decorrelate.",
      "node_contract": {
        "from_must_include": ["catalog_returns", "date_dim", "customer_address"],
        "where_must_preserve": ["d_year = 2000", "ca_state = 'IA'", "cr_returned_date_sk = d_date_sk", "cr_returning_addr_sk = ca_address_sk"],
        "output_must_preserve": ["ctr_customer_sk", "ctr_state", "ctr_total_return", "final ORDER BY and LIMIT 100"]
      },
      "gates_checked": ["G_PG_CORR_SCALAR_REQUIRED:PASS", "G_PG_CORR_ALREADY_DECORRELATED:PASS", "G_PG_CORR_EXISTS_PROTECTION:PASS", "G_PG_CORR_FACT_COUNT:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.80,
      "expected_explain_delta": "Correlated subquery replaced with join; dimension filters pushed into CTEs; comma joins become explicit.",
      "recommended_patch_ops": ["insert_cte", "replace_subquery_with_join", "replace_comma_with_join"],
      "recommended_examples": ["early_filter_decorrelate"],
      "rank_rationale": "Combines early filtering (family A) with decorrelation (family B) for synergistic effect.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p06",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate catalog_returns by cr_returning_customer_sk and ca_address_sk before joining with date_dim and customer_address, reducing rows early.",
      "dag_target_hint": "Modify customer_total_return CTE to aggregate fact table before dimension joins.",
      "node_contract": {
        "from_must_include