{
  "dispatch": {
    "dialect": "postgresql",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The execution plan shows nested loops with zero-row outputs, indicating severe cardinality estimation errors and late-selective filtering. The primary hotspot is the Nested Loop chain involving store_sales and dimension tables, where selective predicates are not pushed down early enough. A secondary hotspot is the date_dim scan that feeds into an ineffective join path.",
    "reasoning_trace": [
      "Nested Loop operators show actual row counts of 0 despite high estimated costs, indicating misestimation.",
      "Index Only Scans on date_dim and item occur late in the plan after multiple joins, suggesting missed early filtering opportunities.",
      "No evidence of correlated subqueries or set operations, ruling out families B and D as primary targets.",
      "Repeated zero-row outputs suggest join order or predicate placement issues rather than raw aggregation cost."
    ],
    "cost_spine": [
      "Nested Loop",
      "Nested Loop",
      "Index Only Scan",
      "Index Scan"
    ],
    "hotspots": [
      {
        "op": "Nested Loop",
        "why": "amplification from misestimated join selectivity",
        "evidence": "time=15.38 rows=0"
      },
      {
        "op": "Index Only Scan on date_dim",
        "why": "late scan despite high selectivity potential",
        "evidence": "rows=122 time=14.241"
      }
    ],
    "do_not_do": [
      "avoid same-column OR to UNION ALL split",
      "do not duplicate large CTE bodies without reuse",
      "do not convert already efficient semi-joins"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "date_cte_explicit_join",
      "family": "A",
      "target": "Materialize selective date_dim filter into a CTE and convert comma joins to explicit JOINs for better cardinality propagation.",
      "dag_target_hint": "Rewrite final_select FROM clause to use explicit JOINs and add date_dim CTE.",
      "node_contract": {
        "from_must_include": [
          "date_dim",
          "store_sales"
        ],
        "where_must_preserve": [
          "d_year = 2002"
        ],
        "output_must_preserve": [
          "all original output columns and aliases"
        ]
      },
      "gates_checked": [
        "G_PG_COMMA_JOIN_PRESENT:PASS",
        "G_PG_COMMA_SEMANTIC:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Date scan moves earlier; Nested Loop replaced with Hash Join using small date CTE.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "pg_date_cte_explicit_join"
      ],
      "gold_example_id": "pg_date_cte_explicit_join",
      "rank_rationale": "Targets primary hotspot — late date_dim scan and poor join estimation from comma joins."
    },
    {
      "probe_id": "p02",
      "transform_id": "dimension_prefetch_star",
      "family": "A",
      "target": "Pre-filter all selective dimensions (date_dim, store, item, customer_demographics) into CTEs before joining with store_sales to reduce fact-table probe volume.",
      "dag_target_hint": "Add 4 CTEs for filtered dimensions and rewrite final_select to join them explicitly.",
      "node_contract": {
        "from_must_include": [
          "store_sales",
          "date_dim",
          "store",
          "item",
          "customer_demographics"
        ],
        "where_must_preserve": [
          "d_year = 2002",
          "s_state = 'IA'",
          "i_category = 'Sports'",
          "cd_gender = 'F'",
          "cd_marital_status = 'M'",
          "cd_education_status = 'Primary'"
        ],
        "output_must_preserve": [
          "all original output columns and aliases"
        ]
      },
      "gates_checked": [
        "G_PG_COMMA_JOIN_PRESENT:PASS",
        "G_PG_CROSS_CTE_COMMA_JOIN_PAIRING:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.78,
      "expected_explain_delta": "All dimension scans occur first; store_sales joins against tiny hash tables.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "pg_dimension_prefetch_star"
      ],
      "gold_example_id": "pg_dimension_prefetch_star",
      "rank_rationale": "Addresses secondary hotspot — repeated zero-row nested loop work from unfiltered dimensions."
    },
    {
      "probe_id": "p03",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate store_sales by join keys (ss_item_sk, ss_store_sk, ss_cdemo_sk) before joining with dimensions to reduce join input volume.",
      "dag_target_hint": "Insert pre-aggregation CTE above store_sales and rewrite final_select to join it.",
      "node_contract": {
        "from_must_include": [
          "store_sales"
        ],
        "where_must_preserve": [
          "d_year = 2002",
          "s_state = 'IA'",
          "i_category = 'Sports'",
          "cd_gender = 'F'",
          "cd_marital_status = 'M'",
          "cd_education_status = 'Primary'"
        ],
        "output_must_preserve": [
          "grouping key compatibility with final projection"
        ]
      },
      "gates_checked": [
        "agg_key_compatibility:PASS",
        "duplication_sensitive_metrics:none"
      ],
      "exploration": true,
      "exploration_hypothesis": "If dimension prefetch does not fully resolve the zero-row nested loop issue, early aggregation may reduce input volume enough to trigger better join planning.",
      "confidence": 0.62,
      "expected_explain_delta": "store_sales rows reduced before join; Nested Loop work decreases.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "pg_materialized_dimension_fact_prefilter"
      ],
      "gold_example_id": "pg_materialized_dimension_fact_prefilter",
      "rank_rationale": "Exploration probe — targets input volume reduction for join path when filter-based fixes are insufficient."
    },
    {
      "probe_id": "p04",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Materialize the result of the filtered dimension joins into a single CTE to avoid repeated scans or late filtering effects.",
      "dag_target_hint": "Wrap dimension join result in a MATERIALIZED CTE and reference it from final_select.",
      "node_contract": {
        "from_must_include": [
          "date_dim",
          "store",
          "item",
          "customer_demographics"
        ],
        "where_must_preserve": [
          "d_year = 2002",
          "s_state = 'IA'",
          "i_category = 'Sports'",
          "cd_gender = 'F'",
          "cd_marital_status = 'M'",
          "cd_education_status = 'Primary'"
        ],
        "output_must_preserve": [
          "all original output columns and aliases"
        ]
      },
      "gates_checked": [
        "G_PG_CTE_REUSE_REQUIRED:PASS",
        "G_PG_CTE_DUPLICATION_BLOCK:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Repeated zero-row outputs suggest PostgreSQL may be rescanning or re-evaluating dimension paths; materialization can stabilize this behavior.",
      "confidence": 0.55,
      "expected_explain_delta": "Dimension join result materialized once; avoids repeated zero-row nested loop attempts.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "pg_self_join_decomposition"
      ],
      "gold_example_id": "pg_self_join_decomposition",
      "rank_rationale": "Low-confidence exploration — tests materialization fence effect on nested loop rescans when other paths are exhausted."
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicates present in query; PostgreSQL BitmapOr already handles indexed disjunctions efficiently."
    },
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated subqueries detected in SQL or execution plan."
    },
    {
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "reason": "Transform is Snowflake-specific and not applicable to PostgreSQL runtime."
    }
  ]
}