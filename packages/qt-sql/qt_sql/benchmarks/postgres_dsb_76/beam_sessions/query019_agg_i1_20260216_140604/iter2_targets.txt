[
  {
    "target_id": "t2",
    "family": "C",
    "transform": "aggregate_after_item_join",
    "relevance_score": 0.95,
    "hypothesis": "Aggregate sales by item keys after joining store_sales with item. This exploits GROUP BY keys (i_brand_id, etc.) being available early to shrink row count before customer/geo joins, directly targeting the Hash Join (27K rows).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter"
    ]
  },
  {
    "target_id": "t3",
    "family": "F",
    "transform": "reorder_joins_early_geo",
    "relevance_score": 0.85,
    "hypothesis": "Join filtered_sales with filtered_geo_pairs immediately after date filtering. Geo conditions (102 stores) applied early will reduce rows before expensive item/customer joins, alleviating the Hash Join bottleneck.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_explicit_join_materialized"
    ]
  },
  {
    "target_id": "t4",
    "family": "C",
    "transform": "aggregate_pushdown_rescue",
    "relevance_score": 0.75,
    "hypothesis": "Rescue failed aggregation by including customer/store keys in pre-aggregation CTE. Ensures join integrity while reducing rows early, targeting Hash Join (27K rows).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter"
    ]
  },
  {
    "target_id": "t5",
    "family": "A+E",
    "transform": "prefilter_item_materialize",
    "relevance_score": 0.8,
    "hypothesis": "Materialize filtered jewelry items upfront to reduce rows before joining with store_sales. Targets Hash Join by shrinking its left input (27K rows).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_date_cte_explicit_join",
      "multi_dimension_prefetch"
    ]
  }
]