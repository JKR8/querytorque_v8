{
  "probe_id": "p01",
  "transform_id": "aggregate_pushdown",
  "family": "C",
  "dialect": "postgres",
  "hypothesis": "Pre-aggregate catalog_sales and catalog_returns into a cs_ui CTE to reduce row count before joining with other dimensions, avoiding repeated aggregation in cross_sales.",
  "reasoning_trace": [
    "The cs_ui CTE currently performs aggregation after joining catalog_sales and catalog_returns.",
    "Pushing the aggregation into a separate CTE reduces input size to the main join and avoids per-row re-aggregation."
  ],
  "target_ir": "CTE cs_ui_agg pre-aggregates catalog_sales and catalog_returns on cs_item_sk; cs_ui becomes a simple filter+join node; cross_sales references cs_ui_agg",
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {"by_node_id": "S0"},
      "payload": {
        "cte_name": "cs_ui_agg",
        "cte_query_sql": "SELECT cs_item_sk, SUM(cs_ext_list_price) AS sale FROM catalog_sales WHERE cs_wholesale_cost BETWEEN 76 AND 96 GROUP BY cs_item_sk"
      }
    },
    {
      "step_id": "s2",
      "op": "insert_cte",
      "target": {"by_node_id": "S0"},
      "payload": {
        "cte_name": "cr_ui_agg",
        "cte_query_sql": "SELECT cr_item_sk, SUM(cr_refunded_cash + cr_reversed_charge + cr_store_credit) AS refund FROM catalog_returns GROUP BY cr_item_sk"
      }
    },
    {
      "step_id": "s3",
      "op": "replace_body",
      "target": {"by_node_id": "CTE_Q_S0_cs_ui"},
      "payload": {
        "sql_fragment": "SELECT cs_ui_agg.cs_item_sk, cs_ui_agg.sale, cr_ui_agg.refund FROM cs_ui_agg JOIN cr_ui_agg ON cs_ui_agg.cs_item_sk = cr_ui_agg.cr_item_sk HAVING cs_ui_agg.sale > 2 * cr_ui_agg.refund"
      }
    }
  ]
}