```json
[
  {
    "family": "A",
    "transform": "early_filtering",
    "target_id": "t1",
    "relevance_score": 1.0,
    "hypothesis": "The CTE aggregates all years before filtering, but main query only needs 1998-1999. Pushing year filter into CTE reduces data volume early.",
    "target_ir": "S0 [SELECT]\n  CTE: all_sales  (via CTE_Q_S0_all_sales)\n    FROM: (subquery) sales_detail\n    WHERE: d_year IN (1998,1999)   [Anchor: added to each UNION branch]\n    GROUP BY: d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id\n  MAIN QUERY (via Q_S0)\n    FROM: all_sales curr_yr, all_sales prev_yr\n    WHERE [5a1a0e9548e5ef4e]: curr_yr.i_brand_id=prev_yr.i_brand_id AND ...\n    ORDER BY: sales_cnt_diff,sales_amt_diff",
    "recommended_examples": ["pg_date_cte_explicit_join"]
  },
  {
    "family": "F",
    "transform": "self_join_to_conditional_agg",
    "target_id": "t2",
    "relevance_score": 0.95,
    "hypothesis": "Self-join on large CTE output forces double materialization. Replace with single-pass conditional aggregation for year comparison.",
    "target_ir": "S0 [SELECT]\n  CTE: sales_2years  (new CTE)\n    SELECT \n        i_brand_id, i_class_id, i_category_id, i_manufact_id,\n        SUM(CASE d_year WHEN 1998 THEN sales_cnt ELSE 0 END) AS prev_yr_cnt,\n        SUM(CASE d_year WHEN 1999 THEN sales_cnt ELSE 0 END) AS curr_yr_cnt,\n        ... [similar for sales_amt]\n    FROM sales_detail\n    WHERE d_year IN (1998,1999)\n    GROUP BY i_brand_id, i_class_id, i_category_id, i_manufact_id\n  MAIN QUERY (via Q_S0)\n    FROM: sales_2years\n    WHERE: prev_yr_cnt > 0 AND curr_yr_cnt/prev_yr_cnt < 0.9\n    ORDER BY (curr_yr_cnt - prev_yr_cnt), ...",
    "recommended_examples": ["pg_explicit_join_materialized"]
  },
  {
    "family": "E",
    "transform": "item_prefetch",
    "target_id": "t3",
    "relevance_score": 0.85,
    "hypothesis": "Repeated full scans of item table in UNION branches. Pre-materialize filtered items to avoid redundant I/O.",
    "target_ir": "S0 [SELECT]\n  CTE: filtered_items  (new CTE)\n    FROM: item\n    WHERE: i_category='Home'\n  CTE: all_sales  (via CTE_Q_S0_all_sales)\n    FROM: (subquery) sales_detail\n      [Each branch: JOIN filtered_items ON i_item_sk=...]\n      [Remove i_category filter from branches]\n    WHERE: d_year IN (1998,1999)\n    GROUP BY: ...",
    "recommended_examples": ["multi_dimension_prefetch"]
  },
  {
    "family": "C",
    "transform": "channel_agg_pushdown",
    "target_id": "t4",
    "relevance_score": 0.75,
    "hypothesis": "Large joins produce inflated intermediates before aggregation. Pre-aggregate within each sales channel before UNION.",
    "target_ir": "S0 [SELECT]\n  CTE: all_sales  (restructured)\n    SELECT ... SUM(sales_cnt), SUM(sales_amt)\n    FROM (\n      SELECT d_year, i_brand_id..., SUM(cs_quantity - COALESCE(cr_qty,0)) AS sales_cnt\n      FROM catalog_sales ... [with original joins/filters]\n      GROUP BY d_year, i_brand_id...\n      UNION ALL\n      ... [similar for store/web]\n    ) channel_aggs\n    GROUP BY d_year, i_brand_id...",
    "recommended_examples": ["pg_materialized_dimension_fact_prefilter"]
  }
]
```

## Analysis
- **Family A (Early Filtering)**: HIGH. Critical win - pushing `d_year` filter into CTE avoids aggregating unnecessary years. Execution plan shows full table scans on large fact tables.
- **Family B (Decorrelation)**: LOW. No correlated subqueries present in query structure.
- **Family C (Aggregation Pushdown)**: MEDIUM. Pre-aggregating sales channels could reduce UNION input size, but year filter (A) may be sufficient.
- **Family D (Set Operation Optimization)**: LOW. UNION already minimal; no INTERSECT/EXCEPT patterns.
- **Family E (Materialization/Prefetch)**: HIGH. Repeated `item` scans (3x) with same filter - clear prefetch candidate.
- **Family F (Join Transform)**: HIGH. Self-join on CTE output forces double materialization - pivot to conditional aggregation is high-impact.

**Chosen families**: [A, F, E, C]  
**Confidence**: High (plan shows expensive operations align with optimization families)