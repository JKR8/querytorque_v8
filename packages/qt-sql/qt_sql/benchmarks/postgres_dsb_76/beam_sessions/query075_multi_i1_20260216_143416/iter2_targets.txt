[
  {
    "target_id": "t1",
    "family": "A+C+E",
    "transform": "preagg_returns_with_item_prefetch",
    "relevance_score": 0.95,
    "hypothesis": "Prefetch 'Home' items to avoid 3x sequential scans (28.7 ms each in t1). Combine with t1's preagg returns to attack both item and returns bottlenecks.",
    "target_ir": "S0: insert_cte home_items (SELECT i_item_sk, ... FROM item WHERE i_category='Home'). Replace all item scans in sales_detail UNION branches with home_items CTE.",
    "recommended_examples": [
      "multi_dimension_prefetch",
      "pg_materialized_dimension_fact_prefilter"
    ]
  },
  {
    "target_id": "t2",
    "family": "A",
    "transform": "push_sales_ratio_filter",
    "relevance_score": 0.85,
    "hypothesis": "Filter sales_price/list_price ratio BEFORE joining to reduce nested loop input. t1 plan shows store_sales index scan processing 0 rows due to late filters.",
    "target_ir": "S0_all_sales: In each sales_detail branch, move ratio filter (e.g., ss_sales_price/ss_list_price BETWEEN...) directly after FROM store_sales/catalog_sales/web_sales.",
    "recommended_examples": [
      "pg_date_cte_explicit_join"
    ]
  },
  {
    "target_id": "t3",
    "family": "F",
    "transform": "self_join_to_conditional_agg",
    "relevance_score": 0.8,
    "hypothesis": "Eliminate self-join by computing both years in one aggregation. Original scans all_sales twice (731+690 rows, 1217 ms). Retain t1's preagg returns gains.",
    "target_ir": "S0: Replace main query with conditional aggregation (SUM(CASE WHEN d_year=1999...), GROUP BY i_brand_id,...). Remove CTE self-join.",
    "recommended_examples": [
      "pg_explicit_join_materialized"
    ]
  },
  {
    "target_id": "t4",
    "family": "C",
    "transform": "preagg_sales_before_returns",
    "relevance_score": 0.75,
    "hypothesis": "Aggregate sales by item/date before joining returns to shrink intermediate rows. t1 still processes 172K store_returns rows pre-aggregation.",
    "target_ir": "S0_all_sales: For each channel, replace inline subquery with pre-aggregated sales (e.g., SELECT d_year, i_brand_id,..., SUM(ss_quantity), ... FROM store_sales JOIN item... GROUP BY d_year, i_brand_id...). Then left join preagg returns.",
    "recommended_examples": [
      "pg_materialized_dimension_fact_prefilter"
    ]
  }
]