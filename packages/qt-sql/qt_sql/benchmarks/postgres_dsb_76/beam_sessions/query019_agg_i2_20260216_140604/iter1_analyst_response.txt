### Step 1 — Compare EXPLAIN Plans

**t1 (NEUTRAL) Analysis**  
- **Improved Operator**:  
  `Hash Join (rows=123464 → 41155, time=316.648 → 46.125)`  
  **Structural Change**: Early filtering via CTEs (`pre_item`, `pre_customer`, `pre_ca`) reduced input rows to the Hash Join.  
- **Most Expensive Remaining Operator**:  
  `Nested Loop (rows=4389, time=102.306)`  
  This operator now dominates runtime after Hash Join improvement.

**t2/syn_w1/syn_w2 (FAIL)**  
- **Failure Cause**: Syntax errors (missing columns in CTEs) and transaction aborts. No plan comparison possible.

### Step 2 — Design Targets

**Primary Bottleneck**:  
The `Nested Loop (rows=4389, time=102.306)` in t1's plan processes excessive rows due to late aggregation.  

**Target 1: Combination (A+C)**  
- **Hypothesis**: Apply aggregation pushdown (Family C) to t1’s filtered results, reducing rows fed into the `Nested Loop`.  
- **Target Operator**: `Nested Loop (rows=4389)` in t1’s plan.  
- **Mechanism**: Aggregate `store_sales` early using filtered dimensions (date/store/customer/customer_address) before joining with `item`.  
- **Confidence**: High (C reduces intermediate rows; A ensures efficient filtering).

**Target 2: Refinement (C Standalone)**  
- **Hypothesis**: Push aggregation before joining `item` (without CTEs) to minimize rows early.  
- **Target Operator**: Original `Hash Join (rows=123464)`.  
- **Mechanism**: Aggregate sales by `item_sk` after filtering joins but before `item` lookup.  
- **Confidence**: High (C directly targets largest original operator).

**Target 3: Rescue (F Fixed)**  
- **Hypothesis**: Fix t2’s CTE to include all `item` columns (`i_brand_id`, etc.) and enforce optimal join order.  
- **Target Operator**: Original `Nested Loop (rows=13167)`.  
- **Mechanism**: Explicit join reordering + correct column projection.  
- **Confidence**: Medium (F addresses join topology; t2’s error was trivial).

---

```json
[
  {
    "family": "A+C",
    "transform": "agg_pushdown_after_early_filter",
    "target_id": "t3",
    "relevance_score": 0.95,
    "hypothesis": "Reduce input to Nested Loop (rows=4389 in t1) by aggregating sales after early-filtered joins but before item join. Combines predicate pushdown (A) and aggregation minimization (C).",
    "target_ir": "S0",
    "recommended_examples": ["pg_date_cte_explicit_join", "pg_materialized_dimension_fact_prefilter"]
  },
  {
    "family": "C",
    "transform": "standalone_agg_pushdown",
    "target_id": "t4",
    "relevance_score": 0.90,
    "hypothesis": "Target Hash Join (rows=123464) by aggregating sales pre-join with item. Avoids CTE overhead while reducing rows early.",
    "target_ir": "S0",
    "recommended_examples": ["pg_materialized_dimension_fact_prefilter"]
  },
  {
    "family": "F",
    "transform": "explicit_join_reorder_fixed",
    "target_id": "t5",
    "relevance_score": 0.80,
    "hypothesis": "Rescue t2: Include all item columns in CTE and enforce optimal join order to reduce Nested Loop (rows=13167).",
    "target_ir": "S0",
    "recommended_examples": ["pg_explicit_join_materialized"]
  }
]
```