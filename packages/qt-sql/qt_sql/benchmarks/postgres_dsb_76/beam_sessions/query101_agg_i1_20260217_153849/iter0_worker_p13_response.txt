{
  "probe_id": "p01",
  "transform_id": "date_cte_isolate",
  "family": "A",
  "dialect": "postgres",
  "hypothesis": "Isolate d1 and d2 date dimension scans into CTEs to enable index-only scans and reduce repeated evaluations in non-equi join predicates.",
  "reasoning_trace": [
    "The query uses comma-join syntax which blocks PostgreSQL's join reordering and leads to nested loop evaluation of date_dim",
    "d1 and d2 are filtered by selective conditions but appear late in the plan",
    "Materializing filtered surrogate keys as CTEs allows reuse and smaller hash table probes"
  ],
  "target_ir": "Two CTEs for d1_keys and d2_keys with selective WHERE clauses, joined explicitly in main FROM",
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {"by_node_id": "S0"},
      "payload": {
        "cte_name": "d1_keys",
        "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1998"
      }
    },
    {
      "step_id": "s2",
      "op": "insert_cte",
      "target": {"by_node_id": "S0"},
      "payload": {
        "cte_name": "d2_keys",
        "cte_query_sql": "SELECT d_date_sk FROM date_dim"
      }
    },
    {
      "step_id": "s3",
      "op": "replace_from",
      "target": {"by_node_id": "S0"},
      "payload": {
        "from_sql": "store_sales JOIN store_returns ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk JOIN web_sales ON ss_customer_sk = ws_bill_customer_sk AND sr_item_sk = ws_item_sk JOIN d1_keys ON sr_returned_date_sk = d1_keys.d_date_sk JOIN d2_keys ON ws_sold_date_sk = d2_keys.d_date_sk JOIN item ON i_item_sk = ss_item_sk JOIN customer ON ss_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk JOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk"
      }
    }
  ]
}