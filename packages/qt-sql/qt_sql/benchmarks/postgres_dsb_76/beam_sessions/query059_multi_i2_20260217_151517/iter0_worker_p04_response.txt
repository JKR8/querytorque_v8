{
  "probe_id": "p01",
  "transform_id": "pg_self_join_decomposition",
  "family": "E",
  "dialect": "postgres",
  "hypothesis": "Materialize the store and date_dim join once as a CTE to avoid repeated scans in self-join pattern, reducing overall query execution time.",
  "reasoning_trace": [
    "The original query performs the same join between store_sales and date_dim multiple times.",
    "By precomputing this join into a single CTE, PostgreSQL can reuse the materialized result instead of re-executing the scan."
  ],
  "target_ir": "CTE for filtered store_sales joined with date_dim; wss1/wss2 now reference the new CTE rather than repeating the base join.",
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {"by_node_id": "S0"},
      "payload": {
        "cte_name": "filtered_store_sales",
        "cte_query_sql": "SELECT ss_sold_date_sk, ss_store_sk, ss_sales_price, ss_list_price, d_week_seq FROM store_sales JOIN date_dim ON d_date_sk = ss_sold_date_sk WHERE ss_sales_price / ss_list_price BETWEEN 65 * 0.01 AND 85 * 0.01"
      }
    },
    {
      "step_id": "s2",
      "op": "replace_from",
      "target": {"by_node_id": "S0"},
      "payload": {
        "from_sql": "(SELECT d_week_seq, ss_store_sk, sum(CASE WHEN (d_day_name='Sunday') THEN ss_sales_price ELSE NULL END) sun_sales, sum(CASE WHEN (d_day_name='Monday') THEN ss_sales_price ELSE NULL END) mon_sales, sum(CASE WHEN (d_day_name='Tuesday') THEN ss_sales_price ELSE NULL END) tue_sales, sum(CASE WHEN (d_day_name='Wednesday') THEN ss_sales_price ELSE NULL END) wed_sales, sum(CASE WHEN (d_day_name='Thursday') THEN ss_sales_price ELSE NULL END) thu_sales, sum(CASE WHEN (d_day_name='Friday') THEN ss_sales_price ELSE NULL END) fri_sales, sum(CASE WHEN (d_day_name='Saturday') THEN ss_sales_price ELSE NULL END) sat_sales FROM filtered_store_sales GROUP BY d_week_seq, ss_store_sk) wss"
      }
    }
  ]
}