[
  {
    "plan_id": "compile_p1",
    "dialect": "postgres",
    "hypothesis": "Winning probe p01 (date_cte_explicit_join) addresses comma-join weakness pattern with CTE-based date filtering, achieving 1.11x speedup. Residual hotspot of catalog_sales-item nested loop remains unaddressed.",
    "target_ir": "Convert comma joins to explicit JOINs and isolate date_dim filter in CTE for better join planning.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["main_query"],
          "outputs": ["w_state", "i_item_id", "sales_before", "sales_after"],
          "changed": true,
          "sql": "WITH date_filter AS (\n  SELECT d_date_sk, d_date\n  FROM date_dim\n  WHERE d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day')\n                   AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day')\n),\nmain_query AS (\n  SELECT w.w_state,\n         i.i_item_id,\n         SUM(CASE WHEN (CAST(d.d_date AS DATE) < CAST('2002-02-19' AS DATE))\n                  THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0)\n                  ELSE 0 END) AS sales_before,\n         SUM(CASE WHEN (CAST(d.d_date AS DATE) >= CAST('2002-02-19' AS DATE))\n                  THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0)\n                  ELSE 0 END) AS sales_after\n  FROM date_filter d\n  JOIN catalog_sales cs ON d.d_date_sk = cs.cs_sold_date_sk\n  LEFT JOIN catalog_returns cr ON cs.cs_order_number = cr.cr_order_number AND cs.cs_item_sk = cr.cr_item_sk\n  JOIN warehouse w ON cs.cs_warehouse_sk = w.w_warehouse_sk\n  JOIN item i ON cs.cs_item_sk = i.i_item_sk\n  WHERE i.i_category = 'Jewelry'\n    AND i.i_manager_id BETWEEN 61 AND 100\n    AND cs.cs_wholesale_cost BETWEEN 42 AND 61\n    AND cr.cr_reason_sk = 33\n  GROUP BY w.w_state, i.i_item_id\n  ORDER BY w.w_state, i.i_item_id\n  LIMIT 100\n)\nSELECT * FROM main_query;"
        },
        {
          "node_id": "date_filter",
          "parent_node_id": "final_select",
          "sources": ["date_dim"],
          "outputs": ["d_date_sk", "d_date"],
          "changed": true,
          "sql": "SELECT d_date_sk, d_date\nFROM date_dim\nWHERE d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day')\n                 AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day')"
        },
        {
          "node_id": "main_query",
          "parent_node_id": "final_select",
          "sources": ["date_filter", "catalog_sales", "catalog_returns", "warehouse", "item"],
          "outputs": ["w_state", "i_item_id", "sales_before", "sales_after"],
          "changed": true,
          "sql": "SELECT w.w_state,\n       i.i_item_id,\n       SUM(CASE WHEN (CAST(d.d_date AS DATE) < CAST('2002-02-19' AS DATE))\n                THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0)\n                ELSE 0 END) AS sales_before,\n       SUM(CASE WHEN (CAST(d.d_date AS DATE) >= CAST('2002-02-19' AS DATE))\n                THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0)\n                ELSE 0 END) AS sales_after\nFROM date_filter d\nJOIN catalog_sales cs ON d.d_date_sk = cs.cs_sold_date_sk\nLEFT JOIN catalog_returns cr ON cs.cs_order_number = cr.cr_order_number AND cs.cs_item_sk = cr.cr_item_sk\nJOIN warehouse w ON cs.cs_warehouse_sk = w.w_warehouse_sk\nJOIN item i ON cs.cs_item_sk = i.i_item_sk\nWHERE i.i_category = 'Jewelry'\n  AND i.i_manager_id BETWEEN 61 AND 100\n  AND cs.cs_wholesale_cost BETWEEN 42 AND 61\n  AND cr.cr_reason_sk = 33\nGROUP BY w.w_state, i.i_item_id\nORDER BY w.w_state, i.i_item_id\nLIMIT 100"
        }
      ]
    },
    "confidence": 0.85,
    "based_on": "p01",
    "strategy": "CTE-based date filtering with explicit JOINs to address comma-join weakness",
    "expected_explain_delta": "Replace Nested Loop between date_dim and catalog_sales with hash join on filtered date CTE; reduce planner ambiguity from comma syntax."
  },
  {
    "plan_id": "compile_p2",
    "dialect": "postgres",
    "hypothesis": "Address residual catalog_sales-item nested loop hotspot by pre-filtering both date_dim and item into CTEs, reducing rows before the main join. This targets the 35K row amplification from original plan.",
    "target_ir": "Materialize filtered date_dim and item dimensions separately before joining with catalog_sales.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["filtered_date", "filtered_item", "catalog_sales", "catalog_returns", "warehouse"],
          "outputs": ["w_state", "i_item_id", "sales_before", "sales_after"],
          "changed": true,
          "sql": "WITH filtered_date AS (\n  SELECT d_date_sk, d_date\n  FROM date_dim\n  WHERE d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day')\n                   AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day')\n),\nfiltered_item AS (\n  SELECT i_item_sk, i_item_id\n  FROM item\n  WHERE i_category = 'Jewelry'\n    AND i_manager_id BETWEEN 61 AND 100\n)\nSELECT w.w_state,\n       i.i_item_id,\n       SUM(CASE WHEN (CAST(d.d_date AS DATE) < CAST('2002-02-19' AS DATE))\n                THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0)\n                ELSE 0 END) AS sales_before,\n       SUM(CASE WHEN (CAST(d.d_date AS DATE) >= CAST('2002-02-19' AS DATE))\n                THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0)\n                ELSE 0 END) AS sales_after\nFROM filtered_date d\nJOIN catalog_sales cs ON d.d_date_sk = cs.cs_sold_date_sk\nLEFT JOIN catalog_returns cr ON cs.cs_order_number = cr.cr_order_number AND cs.cs_item_sk = cr.cr_item_sk\nJOIN warehouse w ON cs.cs_warehouse_sk = w.w_warehouse_sk\nJOIN filtered_item i ON cs.cs_item_sk = i.i_item_sk\nWHERE cs.cs_wholesale_cost BETWEEN 42 AND 61\n  AND cr.cr_reason_sk = 33\nGROUP BY w.w_state, i.i_item_id\nORDER BY w.w_state, i.i_item_id\nLIMIT 100;"
        },
        {
          "node_id": "filtered_date",
          "parent_node_id": "final_select",
          "sources": ["date_dim"],
          "outputs": ["d_date_sk", "d_date"],
          "changed": true,
          "sql": "SELECT d_date_sk, d_date\nFROM date_dim\nWHERE d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day')\n                 AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day')"
        },
        {
          "node_id": "filtered_item",
          "parent_node_id": "final_select",
          "sources": ["item"],
          "outputs": ["i_item_sk", "i_item_id"],
          "changed": true,
          "sql": "SELECT i_item_sk, i_item_id\nFROM item\nWHERE i_category = 'Jewelry'\n  AND i_manager_id BETWEEN 61 AND 100"
        }
      ]
    },
    "confidence": 0.75,
    "based_on": "p03",
    "strategy": "Multi-dimension prefiltering to reduce rows before catalog_sales join",
    "expected_explain_delta": "Replace Nested Loop (date_dim→catalog_sales) and item Index Scan with hash joins on prefiltered dimensions; reduce row amplification from 30→35K."
  },
  {
    "plan_id": "compile_p3",
    "dialect": "postgres",
    "hypothesis": "Combine explicit JOIN conversion with inner join transformation (p02) and CTE date filtering (p01) while preserving left join semantics through ON clause filter placement. Uses INNER JOIN for catalog_returns because WHERE cr_reason_sk=33 eliminates NULL rows.",
    "target_ir": "Explicit JOINs with CTE date filter and inner join for catalog_returns.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["date_filter", "catalog_sales", "catalog_returns", "warehouse", "item"],
          "outputs": ["w_state", "i_item_id", "sales_before", "sales_after"],
          "changed": true,
          "sql": "WITH date_filter AS (\n  SELECT d_date_sk, d_date\n  FROM date_dim\n  WHERE d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day')\n                   AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day')\n)\nSELECT w.w_state,\n       i.i_item_id,\n       SUM(CASE WHEN (CAST(d.d_date AS DATE) < CAST('2002-02-19' AS DATE))\n                THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0)\n                ELSE 0 END) AS sales_before,\n       SUM(CASE WHEN (CAST(d.d_date AS DATE) >= CAST('2002-02-19' AS DATE))\n                THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0)\n                ELSE 0 END) AS sales_after\nFROM date_filter d\nJOIN catalog_sales cs ON d.d_date_sk = cs.cs_sold_date_sk\nJOIN catalog_returns cr ON cs.cs_order_number = cr.cr_order_number AND cs.cs_item_sk = cr.cr_item_sk\nJOIN warehouse w ON cs.cs_warehouse_sk = w.w_warehouse_sk\nJOIN item i ON cs.cs_item_sk = i.i_item_sk\nWHERE i.i_category = 'Jewelry'\n  AND i.i_manager_id BETWEEN 61 AND 100\n  AND cs.cs_wholesale_cost BETWEEN 42 AND 61\n  AND cr.cr_reason_sk = 33\nGROUP BY w.w_state, i.i_item_id\nORDER BY w.w_state, i.i_item_id\nLIMIT 100;"
        },
        {
          "node_id": "date_filter",
          "parent_node_id": "final_select",
          "sources": ["date_dim"],
          "outputs": ["d_date_sk", "d_date"],
          "changed": true,
          "sql": "SELECT d_date_sk, d_date\nFROM date_dim\nWHERE d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day')\n                 AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day')"
        }
      ]
    },
    "confidence": 0.80,
    "based_on": "p01,p02",
    "strategy": "CTE date filter with explicit inner join for catalog_returns",
    "expected_explain_delta": "Replace comma joins with explicit joins; convert left join to inner join because WHERE cr_reason_sk=33 filters NULLs; CTE date filter reduces base rows."
  }
]