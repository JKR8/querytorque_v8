```json
[
  {
    "plan_id": "compile_p1",
    "dialect": "postgres",
    "confidence": 0.82,
    "based_on": "p01",
    "strategy": "Explicit join conversion with date_dim CTE to enable better join reordering and push date filter early.",
    "hypothesis": "Winning probe p01 (1.11x) shows converting comma joins to explicit JOINs and isolating date_dim filter into a CTE helps PostgreSQL choose better join order. This addresses primary hotspot (date_dimâ†’catalog_sales nested loop) and matches COMMA_JOIN_WEAKNESS pattern with evidence.",
    "expected_explain_delta": "Sequential scan on date_dim replaced with CTE materialization; nested loops reduced; better join order enabled.",
    "target_ir": "Convert comma joins to explicit JOINs, add date_filter CTE, keep left join structure with WHERE filter on cr_reason_sk.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["date_filter", "catalog_sales", "catalog_returns", "warehouse", "item"],
          "outputs": ["w_state", "i_item_id", "sales_before", "sales_after"],
          "changed": true,
          "sql": "WITH date_filter AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day') AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day')) SELECT w.w_state, i.i_item_id, SUM(CASE WHEN (CAST(d.d_date AS DATE) < CAST('2002-02-19' AS DATE)) THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0) ELSE 0 END) AS sales_before, SUM(CASE WHEN (CAST(d.d_date AS DATE) >= CAST('2002-02-19' AS DATE)) THEN cs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0) ELSE 0 END) AS sales_after FROM date_filter d JOIN catalog_sales cs ON d.d_date_sk = cs.cs_sold_date_sk LEFT JOIN catalog_returns cr ON cs.cs_order_number = cr.cr_order_number AND cs.cs_item_sk = cr.cr_item_sk JOIN warehouse w ON cs.cs_warehouse_sk = w.w_warehouse_sk JOIN item i ON cs.cs_item_sk = i.i_item_sk WHERE i.i_category = 'Jewelry' AND i.i_manager_id BETWEEN 61 AND 100 AND cs.cs_wholesale_cost BETWEEN 42 AND 61 AND cr.cr_reason_sk = 33 GROUP BY w.w_state, i.i_item_id ORDER BY w.w_state, i.i_item_id LIMIT 100"
        },
        {
          "node_id": "date_filter",
          "parent_node_id": "final_select",
          "sources": ["date_dim"],
          "outputs": ["d_date_sk", "d_date"],
          "changed": true,
          "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day') AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day')"
        }
      ]
    }
  },
  {
    "plan_id": "compile_p2",
    "dialect": "postgres",
    "confidence": 0.78,
    "based_on": "p04",
    "strategy": "Materialize filtered fact-dimension join into CTE to provide stable cardinality estimates for the catalog_returns join.",
    "hypothesis": "Winning probe p04 (1.11x) uses materialization to avoid repeated scans and improve estimates. This pathway prefilters catalog_sales with date_dim, item, and warehouse conditions before joining to catalog_returns.",
    "expected_explain_delta": "Filtered CTE reduces rows entering nested loop with catalog_returns; better cardinality estimates for join planning.",
    "target_ir": "Create filtered_sales CTE joining catalog_sales, date_dim, item, warehouse; final select left joins catalog_returns with cr_reason_sk filter.",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": ["filtered_sales", "catalog_returns"],
          "outputs": ["w_state", "i_item_id", "sales_before", "sales_after"],
          "changed": true,
          "sql": "WITH filtered_sales AS (SELECT cs.cs_sales_price, cs.cs_order_number, cs.cs_item_sk, d.d_date, w.w_state, i.i_item_id FROM catalog_sales cs JOIN date_dim d ON cs.cs_sold_date_sk = d.d_date_sk JOIN item i ON cs.cs_item_sk = i.i_item_sk JOIN warehouse w ON cs.cs_warehouse_sk = w.w_warehouse_sk WHERE d.d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day') AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day') AND i.i_category = 'Jewelry' AND i.i_manager_id BETWEEN 61 AND 100 AND cs.cs_wholesale_cost BETWEEN 42 AND 61) SELECT fs.w_state, fs.i_item_id, SUM(CASE WHEN (CAST(fs.d_date AS DATE) < CAST('2002-02-19' AS DATE)) THEN fs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0) ELSE 0 END) AS sales_before, SUM(CASE WHEN (CAST(fs.d_date AS DATE) >= CAST('2002-02-19' AS DATE)) THEN fs.cs_sales_price - COALESCE(cr.cr_refunded_cash, 0) ELSE 0 END) AS sales_after FROM filtered_sales fs LEFT JOIN catalog_returns cr ON fs.cs_order_number = cr.cr_order_number AND fs.cs_item_sk = cr.cr_item_sk WHERE cr.cr_reason_sk = 33 GROUP BY fs.w_state, fs.i_item_id ORDER BY fs.w_state, fs.i_item_id LIMIT 100"
        },
        {
          "node_id": "filtered_sales",
          "parent_node_id": "final_select",
          "sources": ["catalog_sales", "date_dim", "item", "warehouse"],
          "outputs": ["cs_sales_price", "cs_order_number", "cs_item_sk", "d_date", "w_state", "i_item_id"],
          "changed": true,
          "sql": "SELECT cs.cs_sales_price, cs.cs_order_number, cs.cs_item_sk, d.d_date, w.w_state, i.i_item_id FROM catalog_sales cs JOIN date_dim d ON cs.cs_sold_date_sk = d.d_date_sk JOIN item i ON cs.cs_item_sk = i.i_item_sk JOIN warehouse w ON cs.cs_warehouse_sk = w.w_warehouse_sk WHERE d.d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 day') AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 day') AND i.i_category = 'Jewelry' AND i.i_manager_id BETWEEN 61 AND 100 AND cs.cs_wholesale_cost BETWEEN 42 AND 61"
        }
      ]
    }
  }
]
```