{  "dispatch": {
    "dialect": "postgres",
    "importance_stars": 3,
    "probe_count": 14,
    "early_stop": false,
    "equivalence_tier": "exact",
    "hypothesis": "The query's dominant hotspot is the correlated subquery re-executing per outer row in CTE comparisons (Nested Loop with 282k ms). Decorrelation via pre-computed aggregates and explicit joins should eliminate nested loops. Comma-join syntax prevents optimal join ordering.",
    "reasoning_trace": [
      "CTE Scan (ctr1) correlated subquery causes nested loop re-execution",
      "Comma-join syntax in main FROM clause blocks join reordering",
      "Late filters on store/customer_demographics/customer tables miss early reduction"
    ],
    "cost_spine": ["CTE Scan (ctr1) → Nested Loop → Sort → Aggregate → Limit"],
    "hotspots": [
      {"op": "CTE Scan (ctr1)", "why": "correlated subquery amplification", "evidence": "time=282373ms"},
      {"op": "Nested Loop", "why": "comma-join planning limitation", "evidence": "time=282387ms"}
    ],
    "do_not_do": ["or_to_union", "materialize_cte without reuse evidence"]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "status",
    "speedup",
    "expected_explain_delta",
    "ops_used",
    "confidence",
    "exploration",
    "failure_reason",
    "target"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "target": "Convert correlated subquery to MATERIALIZED CTE with group by ctr_store_sk",
      "node_contract": {
        "from_must_include": ["customer_total_return ctr1"],
        "where_must_preserve": ["ctr1.ctr_total_return > threshold"],
        "output_must_preserve": ["c_customer_id", "ORDER BY/LIMIT"]
      },
      "gates_checked": ["no_or_to_union:PASS", "not_simple_exists:PASS"],
      "exploration": false,
      "confidence": 0.92,
      "expected_explain_delta": "Replace nested loop with hash join to avg_threshold CTE",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate"]
    },
    {
      "probe_id": "p02",
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "target": "Convert comma joins to explicit INNER JOINs with optimized order",
      "node_contract": {
        "from_must_include": ["customer_total_return ctr1", "store", "customer", "customer_demographics"],
        "where_must_preserve": ["s_store_sk = ctr1.ctr_store_sk", "join predicates"],
        "output_must_preserve": ["All columns"]
      },
      "gates_checked": ["comma_join_weakness:PASS"],
      "exploration": false,
      "confidence": 0.88,
      "expected_explain_delta": "Join order improvement with explicit JOIN syntax"
    },
    {
      "probe_id": "p03",
      "transform_id": "date_cte_isolate",
      "family": "A",
      "target": "Materialize date_dim filter into CTE before store_returns join",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year=2002", "sr_return_amt/quantity BETWEEN"],
        "output_must_preserve": ["Group by keys"]
      },
      "gates_checked": ["cross_cte_predicate_blindness:PASS"],
      "exploration": false,
      "confidence": 0.85,
      "expected_explain_delta": "Earlier date filter application in CTE definition"
    },
    {
      "probe_id": "p04",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Pre-filter store table with s_state IN (...) via CTE",
      "node_contract": {
        "from_must_include": ["store"],
        "where_must_preserve": ["s_state IN ('IL','KY','TX')"],
        "output_must_preserve": ["s_store_sk"]
      },
      "gates_checked": ["cross_cte_predicate_blindness:PASS"],
      "exploration": false,
      "confidence": 0.9,
      "expected_explain_delta": "Replace seq scan with index scan on pre-filtered CTE"
    },
    {
      "probe_id": "p05",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Pre-filter customer_demographics via CTE with cd_* conditions",
      "node_contract": {
        "from_must_include": ["customer_demographics"],
        "where_must_preserve": ["cd_marital_status", "cd_education_status", "cd_gender"],
        "output_must_preserve": ["cd_demo_sk"]
      },
      "gates_checked": ["cross_cte_predicate_blindness:PASS"],
      "exploration": false,
      "confidence": 0.87,
      "expected_explain_delta": "Index scan on pre-filtered demographics CTE"
    },
    {
      "probe_id": "p06",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Pre-filter customer via CTE with birth month/year",
      "node_contract": {
        "from_must_include": ["customer"],
        "where_must_preserve": ["c_birth_month=2", "c_birth_year 1965-1971"],
        "output_must_preserve": ["c_customer_sk"]
      },
      "gates_checked": ["cross_cte_predicate_blindness:PASS"],
      "exploration": false,
      "confidence": 0.89,
      "expected_explain_delta": "Index scan on filtered customer CTE"
    },
    {
      "probe_id": "p07",
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "target": "Materialize customer_total_return with filters as separate CTE",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year=2002"],
        "output_must_preserve": ["Group by keys"]
      },
      "gates_checked": ["cte_materialization_fence:PASS"],
      "exploration": false,
      "confidence": 0.8,
      "expected_explain_delta": "Reduce repeated store_returns scans via materialization"
    },
    {
      "probe_id": "p08",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate store_returns before joining with date_dim",
      "node_contract": {
        "from_must_include": ["store_returns"],
        "where_must_preserve": ["sr_return_amt/quantity BETWEEN"],
        "output_must_preserve": ["Group by keys"]
      },
      "gates_checked": ["aggregate_below_join_blindness:PASS"],
      "exploration": true,
      "exploration_hypothesis": "PostgreSQL may push aggregates below joins when pre-grouped",
      "confidence": 0.65,
      "expected_explain_delta": "Aggregate before join in CTE definition"
    },
    {
      "probe_id": "p09",
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "target": "Stage joins via filtered dimension CTEs before fact scan",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year=2002"],
        "output_must_preserve": ["Group by keys"]
      },
      "gates_checked": ["cross_cte_predicate_blindness:PASS"],
      "exploration": true,
      "exploration_hypothesis": "DuckDB-inspired staged reduction may transfer via CTE materialization",
      "confidence": 0.6,
      "expected_explain_delta": "Reduced store_returns rows via early dimension filters"
    },
    {
      "probe_id": "p10",
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "target": "Materialize both date_dim and store_returns filters before main join",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year=2002", "BETWEEN condition"],
        "output_must_preserve": ["All original columns"]
      },
      "gates_checked": ["non_equi_join_input_blindness:PASS"],
      "exploration": false,
      "confidence": 0.75,
      "expected_explain_delta": "Hash join with pre-filtered fact CTE"
    },
    {
      "probe_id": "p11",
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "target": "Combine dimension filters with decorrelation in single CTE chain",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["d_year=2002"],
        "output_must_preserve": ["Group by keys"]
      },
      "gates_checked": ["correlated_subquery_paralysis:PASS"],
      "exploration": false,
      "confidence": 0.85,
      "expected_explain_delta": "Single CTE with combined filtering/decorrelation"
    },
    {
      "probe_id": "p12",
      "transform_id": "single_pass_aggregation",
      "family": "C",
      "target": "Compute AVG(ctr_total_return) in same scan as main aggregates",
      "node_contract": {
        "from_must_include": ["store_returns"],
        "where_must_preserve": ["BETWEEN condition"],
        "output_must_preserve": ["ctr_total_return computation"]
      },
      "gates_checked": ["redundant_scan_elimination:PASS"],
      "exploration": true,
      "exploration_hypothesis": "PostgreSQL can compute multiple aggregates in single scan",
      "confidence": 0.7,
      "expected_explain_delta": "Single aggregate node instead of separate scans"
    },
    {
      "probe_id": "p13",
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "target": "Reuse date_dim CTE across both CTE and main query",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_year=2002"],
        "output_must_preserve": ["d_date_sk"]
      },
      "gates_checked": ["cross_cte_predicate_blindness:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Shared dimension reuse reduces redundant scans",
      "confidence": 0.68,
      "expected_explain_delta": "Index scan on shared date CTE"
    },
    {
      "probe_id": "p14",
      "transform_id": "union_cte_split",
      "family": "D",
      "target": "Separate ctr1 and ctr2 CTEs with different reason_sk filters",
      "node_contract": {
        "from_must_include": ["store_returns"],
        "where_must_preserve": ["sr_reason_sk BETWEEN 43 AND 46 for ctr1"],
        "output_must_preserve": ["Group by keys"]
      },
      "gates_checked": ["no_double_scans:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Specialized CTEs optimize aggregate reuse",
      "confidence": 0.55,
      "expected_explain_delta": "Filtered ctr1 CTE with reason_sk early"
    }
  ],
  "dropped": [
    {"transform_id": "or_to_union", "family": "D", "reason": "No OR conditions in WHERE clause"},
    {"transform_id": "intersect_to_exists", "family": "D", "reason": "No INTERSECT operations present"}
  ]
}