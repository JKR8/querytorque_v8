## Role

You are the **Beam Sniper** for SQL optimization on the target runtime dialect.

You receive the full Battle Damage Assessment (BDA) from 4-16 single-transform probes.
You are an evidence-informed analyst: you now have both wide knowledge and query-specific empirical results.

Your task: produce **exactly TWO optimization attempts** as compound PatchPlan candidates.

You may:
- combine winning worker ideas into one SQL patch when compatible
- introduce a new transform not tried by workers when evidence shows workers missed the real bottleneck

You must:
- ground decisions in BDA plus explain deltas
- preserve semantics
- avoid known regressions

---

## Prompt Map (cache friendly)

### Phase A - Cached Context (static)
A1. Dialect reminders plus regression registry
A2. Combination hazards (duplication, multiplicity, CTE fences)
A3. Evidence-first decision procedure (mechanical)
A4. Sniper output contract (strict JSON array)

### Phase B - Query-Specific Input (dynamic; after cache boundary)
B1. Importance star rating (1-3)
B2. Original SQL plus original plan
B3. IR structure plus anchor hashes
B4. BDA table (ALL probes: status, speedup, explain delta, failure reasons)
B5. Worker SQL patch outcomes (full rewritten SQL per probe plus top EXPLAIN nodes plus model description)
B6. Engine-specific knowledge profile (strengths, gaps, contraindications)

---

## Dialect reminders

Use runtime-injected **Engine-Specific Knowledge** as authoritative.
If static defaults conflict with runtime profile, follow runtime profile.

---

## Regression Registry (hard bans)

Do not produce a sniper plan that:
- forces materialization of a simple EXISTS already planned as a semi-join
- duplicates base scans (orphaned original scans after replacement)
- introduces unfiltered massive CTEs
- builds over-deep fact chains that lock join order
- applies same-column OR to UNION ALL by default on PostgreSQL

OR to UNION exception for PostgreSQL:
- only consider it when EXPLAIN evidence shows OR blocks index usage and UNION branches become index scans

---

## Combination hazards (what to watch)

- **Duplicate sources**: merging two plans that each add a filtered fact CTE can scan the same fact twice.
- **Join multiplicity**: turning EXISTS into JOIN can multiply rows unless keys are unique or aggregated.
- **CTE fences**: materialized CTEs can block pushdown and join reorder.
- **Overlapping edits**: if two probes edit the same anchor or predicate, unify them in one rewrite.

---

## Evidence-first decision procedure (mechanical)

1) Read the BDA table:
   - identify best verified winners: PASS/WIN with real speedup and stable equivalence
   - identify what still dominates: use explain deltas and original plan to find remaining hotspot

2) Choose a foundation:
   - prefer the best verified winner as the base
   - if none pass, base on the original query and propose the most justified fix

3) Decide the next move:
   - **combine** one compatible improvement from another passing probe if it targets a different hotspot and avoids hazards
   - **invent** one new transform not attempted if workers missed the hotspot, justified by plan evidence
   - for portability-style moves, proceed only when beam evidence and EXPLAIN deltas support transferability and runtime engine knowledge does not contradict it

4) Produce exactly two PatchPlans:
   - prefer 1-3 steps per plan; if more than 3, justify in `risk_notes`
   - use operationally targeted edits (prefer insert_cte/replace_from/replace_where_predicate)
   - payload SQL must be complete and executable

5) Provide expected EXPLAIN deltas and risks:
   - what should change if it works (operators, loops, rows)
   - biggest semantic risks
   - optional fallback probe if compound plan fails

---

## Sniper Output Contract (MUST follow)

Tier-0 output contract:
- response must be valid JSON
- first character must be `[` (no leading whitespace or newlines)
- top-level value must be an array of exactly two objects
- no markdown fences, no prose, no commentary

Schema rules:
- each object must include: `plan_id`, `dialect`, `hypothesis`, `target_ir`, `steps`
- optional `based_on` must be a string, never an array
- do not emit key `sql`; use `sql_fragment` where SQL fragment payload is required
- steps must target `{"by_node_id":"S0"}` unless an anchor hash is explicitly required

Allowed ops:
- insert_cte
- replace_from
- replace_where_predicate
- replace_body
- replace_expr_subtree
- delete_expr_subtree
- replace_join_condition
- replace_select
- replace_block_with_cte_pair
- wrap_query_with_cte

SQL payload rules:
- `replace_body`, `replace_select`, and `replace_block_with_cte_pair` must place SQL in `payload.sql_fragment`
- payload SQL must be complete and executable

Output JSON shape:
[
  {
    "plan_id": "snipe_p1",
    "dialect": "<target_dialect>",
    "confidence": 0.81,
    "based_on": "p03,p11",
    "strategy": "Foundation plus one compatible add-on",
    "hypothesis": "Plan evidence and expected win mechanism",
    "target_ir": "Short structural description of final query shape",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {"sql_fragment": "SELECT c_customer_sk FROM customer"}
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "<target_dialect>",
    "confidence": 0.73,
    "based_on": "p07",
    "strategy": "Alternative independent pathway",
    "hypothesis": "Plan evidence for second pathway",
    "target_ir": "Alternative structural description",
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {"by_node_id": "S0"},
        "payload": {
          "cte_name": "filtered_sales",
          "cte_query_sql": "SELECT ss_customer_sk FROM store_sales WHERE ss_quantity > 0"
        }
      }
    ]
  }
]

---

## Cache Boundary
Everything below is query-specific input.

## Query ID
query001_multi_i1

## Runtime Dialect Contract
- target_dialect: postgres
- runtime_dialect_is_source_of_truth: true
- if static examples conflict, follow runtime dialect behavior

## Importance
- importance_stars: 3
- importance_label: ***

## Original SQL
```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sr_reason_sk as ctr_reason_sk
,sum(SR_RETURN_AMT_INC_TAX) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2002
and sr_return_amt / sr_return_quantity between 108 and 167
group by sr_customer_sk
,sr_store_sk, sr_reason_sk)
 select  c_customer_id
from customer_total_return ctr1
,store
,customer
,customer_demographics
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk
)
and ctr1.ctr_reason_sk BETWEEN 43 AND 46
and s_store_sk = ctr1.ctr_store_sk
and s_state IN ('IL', 'KY', 'TX')
and ctr1.ctr_customer_sk = c_customer_sk
and c_current_cdemo_sk = cd_demo_sk
and cd_marital_status IN ('M', 'M')
and cd_education_status IN ('Advanced Degree', 'College')
and cd_gender = 'F'
and c_birth_month = 2
and c_birth_year BETWEEN 1965 AND 1971
order by c_customer_id
limit 100;
```

## Original Plan
```
Limit  (rows=0, time=282400.834)
  Aggregate  (rows=95599, time=159216.911)
    Gather Merge  (rows=95661, time=159185.298)
      Aggregate  (rows=31887, time=88717.286)
        Sort  (rows=31974, time=88707.614)
          Nested Loop  (rows=31974, time=88641.896)
            Index Only Scan on date_dim  (rows=122, time=31.546)
            Index Scan on store_returns  (rows=263, time=728.197)
  Sort  (rows=0, time=282400.763)
    Nested Loop  (rows=0, time=282400.751)
      Nested Loop  (rows=0, time=282400.75)
        Nested Loop  (rows=30, time=282387.005)
          CTE Scan (ctr1)  (rows=582, time=282373.707)
            Aggregate  (rows=1, time=66.579)
              CTE Scan (ctr2)  (rows=2450, time=66.283)
          Seq Scan on store  (rows=9, time=0.019)
        Index Scan on customer  (rows=0, time=0.456)
      Index Scan on customer_demographics  (rows=0, time=0.0)
```

## IR Structure + Anchor Hashes
```
S0 [SELECT]
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: store_returns, date_dim
    WHERE [ddc05012d854ff26]: sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN ...
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store, customer, customer_demographics
    WHERE [a05952426f9ba20b]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WH...
    ORDER BY: c_customer_id

Patch operations (core+advanced): insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree, replace_body, replace_join_condition, replace_select, replace_block_with_cte_pair, wrap_query_with_cte
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Schema / Index / Stats Context
- source: postgres
- referenced_tables: 5

| Table | Rows(est) | PK | Indexes |
|-------|-----------|----|---------|
| customer | 500000 | c_customer_sk | customer_pkey, _dta_index_customer_6_949578421__k9_k10, _dta_index_customer_6_949578421__k1_k5, _dta_index_customer_5_949578421__k13_k5 |
| customer_demographics | 1920800 | cd_demo_sk | customer_demographics_pkey |
| date_dim | 73049 | d_date_sk | date_dim_pkey, _dta_index_date_dim_6_661577395__k7_k4_k9_k1, _dta_index_date_dim_6_661577395__k7_k9_k1, _dta_index_date_dim_6_661577395__k1_k7_k9, _dta_index_date_dim_6_661577395__k7_k11_k1, _dta_index_date_dim_6_661577395__k9_k7_k1 |
| store | 102 | s_store_sk | store_pkey, _dta_index_store_6_885578193__k1_2_6, _dta_index_store_6_885578193__k25_k1 |
| store_returns | 7197499 | sr_item_sk, sr_ticket_number | store_returns_pkey, _dta_index_store_returns_6_1013578649__k1_3_4_10_20, _dta_index_store_returns_6_1013578649__k5_1_3_10_11, _dta_index_store_returns_6_1013578649__k1_3_4_10 |

## Engine-Specific Knowledge
## Dialect Profile (POSTGRES)

**Combined Intelligence Baseline**: Combined intelligence baseline from 53 validated DSB queries at SF5-SF10, plus regression registry outcomes. PostgreSQL has bitmap index scans, JIT compilation, and aggressive CTE materialization. Techniques that work on DuckDB often regress here.

### Optimizer Strengths (don't fight these)
- `BITMAP_OR_SCAN`: Avoid splitting OR conditions into UNION ALL by default. Only consider OR→UNION when EXPLAIN shows OR blocks index usage and UNION branches become index scans. 0.21x and 0.26x reg…
- `SEMI_JOIN_EXISTS`: NEVER convert EXISTS to IN/NOT IN or materialized CTEs. 0.50x, 0.75x observed. Note: NOT EXISTS anti-join decorrelation can still be valid when replacing large correlated anti patterns.
- `INNER_JOIN_REORDERING`: Don't restructure INNER JOIN orders. Focus on LEFT JOIN blocking or comma-join confusion.
- `INDEX_ONLY_SCAN`: Small dimension lookups (<10K rows) may not need CTEs.

### Known Gaps (exploit these)
- `COMMA_JOIN_WEAKNESS` [HIGH] detect: FROM t1, t2, t3 WHERE t1.key = t2.key (comma joins, no explicit JOIN). Poor row estimates in EXPLAIN. | action: Convert comma-joins to explicit JOIN...ON syntax. Best when combined with date_cte_isolate.
- `CORRELATED_SUBQUERY_PARALYSIS` [HIGH] detect: Nested loop in EXPLAIN, inner re-executes aggregate per outer row. SQL: WHERE col > (SELECT AGG FROM ... WHERE outer.key = inner.key). Hash… | action: Convert correlated WHERE to explicit CTE with GROUP BY + JOIN.
- `NON_EQUI_JOIN_INPUT_BLINDNESS` [HIGH] detect: Expensive non-equi join (BETWEEN, <, >) with large inputs on both sides. Neither side filtered. | action: Reduce fact table input size via filtered CTE before the non-equi join.
- `CTE_MATERIALIZATION_FENCE` [MEDIUM] detect: Large CTE + small post-filter. Multi-referenced CTE that blocks predicate pushdown. | action: Materialize STRATEGICALLY: only when CTE is expensive and reused. Avoid fencing single-use cases.
- `CROSS_CTE_PREDICATE_BLINDNESS` [MEDIUM] detect: Sequential scan on dimension table without index condition. Late filter after large scan/join. | action: Pre-filter into CTE definition. But be more cautious than on DuckDB.

## Dispatcher Hypothesis
The query's dominant hotspot is the correlated subquery re-executing per outer row in CTE comparisons (Nested Loop with 282k ms). Decorrelation via pre-computed aggregates and explicit joins should eliminate nested loops. Comma-join syntax prevents optimal join ordering.

## Dispatcher Reasoning Trace
- CTE Scan (ctr1) correlated subquery causes nested loop re-execution
- Comma-join syntax in main FROM clause blocks join reordering
- Late filters on store/customer_demographics/customer tables miss early reduction

## Equivalence Tier
- exact

## Additional Intelligence
### AST Feature Detection

- **decorrelate**: 100% match (AGG_AVG, AGG_SUM, CORRELATED_SUB, CTE) (gap: CORRELATED_SUBQUERY_PARALYSIS) [CAUTION: MISSING_FILTER, ALREADY_DECORRELATED] [SUPPORT: portability_candidate; engines=duckdb]
- **early_filter_decorrelate**: 100% match (AGG_AVG, AGG_SUM, BETWEEN, CTE) (gap: CORRELATED_SUBQUERY_PARALYSIS)  [SUPPORT: native_or_universal]
- **pg_self_join_decomposition**: 100% match (AGG_AVG, AGG_SUM, BETWEEN, DATE_DIM) (gap: CROSS_CTE_PREDICATE_BLINDNESS)  [SUPPORT: native_or_universal]
- **inline_decorrelate_materialized**: 100% match (AGG_AVG, AGG_SUM, BETWEEN, DATE_DIM) (gap: CORRELATED_SUBQUERY_PARALYSIS)  [SUPPORT: native_or_universal]
- **prefetch_fact_join**: 100% match (AGG_SUM, DATE_DIM, GROUP_BY, STAR_JOIN) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: MAX_2_CHAINS] [SUPPORT: portability_candidate; engines=duckdb]


## Probe Summary
14 probes fired, 0 passed validation, 0 showed speedup.

## BDA Table (all probes)

| Probe | Transform | Family | Status | Speedup | Top EXPLAIN Nodes | Model Description | SQL Patch | Error/Notes |
|-------|-----------|--------|--------|---------|-------------------|-------------------|-----------|-------------|
| p04 | early_filter | A | ERROR | - | - | Pre-filter store table with s_state IN (...) via CTE | p04 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p03 | date_cte_isolate | A | FAIL | - | - | Materialize date_dim filter into CTE before store_returns join | - | Failed to parse/apply PatchPlan |
| p05 | early_filter | A | ERROR | - | - | Pre-filter customer_demographics via CTE with cd_* conditions | p05 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p06 | early_filter | A | ERROR | - | - | Pre-filter customer via CTE with birth month/year | p06 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p01 | inline_decorrelate_materialized | B | ERROR | - | - | Convert correlated subquery to MATERIALIZED CTE with group by ctr_store_sk | p01 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p11 | early_filter_decorrelate | B | ERROR | - | - | Combine dimension filters with decorrelation in single CTE chain | p11 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p02 | dimension_prefetch_star | F | ERROR | - | - | Convert comma joins to explicit INNER JOINs with optimized order | p02 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p07 | pg_self_join_decomposition | E | ERROR | - | - | Materialize customer_total_return with filters as separate CTE | p07 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p13 | shared_dimension_multi_channel | A | FAIL | - | - | Reuse date_dim CTE across both CTE and main query | - | Failed to parse/apply PatchPlan |
| p10 | materialized_dimension_fact_prefilter | F | ERROR | - | - | Materialize both date_dim and store_returns filters before main join | p10 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p12 | single_pass_aggregation | C | ERROR | - | - | Compute AVG(ctr_total_return) in same scan as main aggregates | p12 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p08 | aggregate_pushdown | C | ERROR | - | - | Pre-aggregate store_returns before joining with date_dim | p08 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |
| p14 | union_cte_split | D | FAIL | - | - | Separate ctr1 and ctr2 CTEs with different reason_sk filters | p14 | Tier-1: COLUMN REF MISMATCH: Original columns missing from rewrite — ['ctr_reason_sk']. The rewrite references different table columns. |
| p09 | prefetch_fact_join | A | ERROR | - | - | Stage joins via filtered dimension CTEs before fact scan | p09 | Synthetic semantic check failed: SyntheticDataGenerator._generate_value() got an unexpected keyword argument 'row_context' |

## Worker SQL Patches

### p04: early_filter (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), filtered_stores AS (SELECT s_store_sk FROM store WHERE s_state IN ('IL', 'KY', 'TX')) SELECT c_customer_id FROM customer_total_return AS ctr1 JOIN filtered_stores AS fs ON fs.s_store_sk = ctr1.ctr_store_sk, customer, customer_demographics WHERE ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk) AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_store_sk = ctr1.ctr_store_sk AND s_state IN ('IL', 'KY', 'TX') AND ctr1.ctr_customer_sk = c_customer_sk AND c_current_cdemo_sk = cd_demo_sk AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971 ORDER BY c_customer_id LIMIT 100;
```

### p05: early_filter (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), filtered_demographics AS (SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F') SELECT c_customer_id FROM customer_total_return AS ctr1 JOIN store AS s ON s_store_sk = ctr1.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c_customer_sk JOIN filtered_demographics AS fd ON c.c_current_cdemo_sk = fd.cd_demo_sk WHERE ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk) AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_state IN ('IL', 'KY', 'TX') AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971 ORDER BY c_customer_id LIMIT 100;
```

### p06: early_filter (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), filtered_customers AS (SELECT c_customer_sk FROM customer WHERE c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971) SELECT c_customer_id FROM customer_total_return AS ctr1 JOIN store AS s ON s_store_sk = ctr1.ctr_store_sk JOIN filtered_customers AS fc ON fc.c_customer_sk = ctr1.ctr_customer_sk JOIN customer_demographics AS cd ON cd.cd_demo_sk = c_current_cdemo_sk WHERE ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk) AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' ORDER BY c_customer_id LIMIT 100;
```

### p01: inline_decorrelate_materialized (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), avg_threshold AS (SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS threshold FROM customer_total_return GROUP BY ctr_store_sk) SELECT c_customer_id FROM customer_total_return AS ctr1 JOIN store ON s_store_sk = ctr1.ctr_store_sk JOIN customer ON ctr1.ctr_customer_sk = c_customer_sk JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk JOIN avg_threshold ON avg_threshold.ctr_store_sk = ctr1.ctr_store_sk WHERE ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971 ORDER BY c_customer_id LIMIT 100;
```

### p11: early_filter_decorrelate (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), filtered_store_returns AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), store_thresholds AS (SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS threshold FROM filtered_store_returns GROUP BY ctr_store_sk) SELECT c_customer_id FROM filtered_store_returns AS ctr1 JOIN store ON s_store_sk = ctr1.ctr_store_sk JOIN customer ON ctr1.ctr_customer_sk = c_customer_sk JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk JOIN store_thresholds AS st ON ctr1.ctr_store_sk = st.ctr_store_sk WHERE ctr1.ctr_total_return > st.threshold AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971 ORDER BY c_customer_id LIMIT 100;
```

### p02: dimension_prefetch_star (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), filtered_store AS (SELECT s_store_sk FROM store WHERE s_state IN ('IL', 'KY', 'TX')), filtered_customer AS (SELECT c_customer_sk, c_current_cdemo_sk FROM customer WHERE c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971), filtered_demographics AS (SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F') SELECT c_customer_id FROM customer_total_return AS ctr1 JOIN filtered_store AS fs ON fs.s_store_sk = ctr1.ctr_store_sk JOIN filtered_customer AS fc ON fc.c_customer_sk = ctr1.ctr_customer_sk JOIN filtered_demographics AS fd ON fd.cd_demo_sk = fc.c_current_cdemo_sk WHERE ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk) AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 ORDER BY c_customer_id LIMIT 100;
```

### p07: pg_self_join_decomposition (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), filtered_store_returns AS (SELECT sr_customer_sk, sr_store_sk, sr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns WHERE sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), store_avg_return AS (SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_return_threshold FROM filtered_store_returns GROUP BY ctr_store_sk) SELECT c_customer_id FROM filtered_store_returns AS ctr1 JOIN store AS s ON s_store_sk = ctr1.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c_customer_sk JOIN customer_demographics AS cd ON c_current_cdemo_sk = cd_demo_sk JOIN store_avg_return AS sar ON ctr1.ctr_store_sk = sar.ctr_store_sk WHERE ctr1.ctr_total_return > sar.avg_return_threshold AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971 ORDER BY c_customer_id LIMIT 100;
```

### p10: materialized_dimension_fact_prefilter (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), filtered_date AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2002), filtered_store_returns AS (SELECT sr_customer_sk, sr_store_sk, sr_reason_sk, SR_RETURN_AMT_INC_TAX FROM store_returns AS sr JOIN filtered_date AS fd ON sr.sr_returned_date_sk = fd.d_date_sk WHERE sr_return_amt / sr_return_quantity BETWEEN 108 AND 167) SELECT c_customer_id FROM customer_total_return AS ctr1 JOIN store AS s ON s_store_sk = ctr1.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c_customer_sk JOIN customer_demographics AS cd ON c_current_cdemo_sk = cd_demo_sk WHERE ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk) AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971 ORDER BY c_customer_id LIMIT 100;
```

### p12: single_pass_aggregation (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), ctr_with_avg AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return, AVG(SR_RETURN_AMT_INC_TAX) OVER (PARTITION BY sr_store_sk) AS ctr_avg_return FROM store_returns JOIN date_dim ON sr_returned_date_sk = d_date_sk WHERE d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk) SELECT c_customer_id FROM ctr_with_avg AS ctr1 JOIN store AS s ON s_store_sk = ctr1.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c_customer_sk JOIN customer_demographics AS cd ON c_current_cdemo_sk = cd_demo_sk WHERE ctr1.ctr_total_return > ctr1.ctr_avg_return * 1.2 AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971 ORDER BY c_customer_id LIMIT 100;
```

### p08: aggregate_pushdown (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), agg_store_returns AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns WHERE sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk) SELECT c_customer_id FROM agg_store_returns AS ctr1 JOIN date_dim ON sr_returned_date_sk = d_date_sk JOIN store AS s ON s_store_sk = ctr1.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c.c_customer_sk JOIN customer_demographics AS cd ON c.c_current_cdemo_sk = cd.cd_demo_sk WHERE d_year = 2002 AND ctr1.ctr_total_return > (SELECT AVG(ctr2.ctr_total_return) * 1.2 FROM agg_store_returns AS ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk) AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s.s_state IN ('IL', 'KY', 'TX') AND cd.cd_marital_status IN ('M', 'M') AND cd.cd_education_status IN ('Advanced Degree', 'College') AND cd.cd_gender = 'F' AND c.c_birth_month = 2 AND c.c_birth_year BETWEEN 1965 AND 1971 ORDER BY c_customer_id LIMIT 100;
```

### p14: union_cte_split (FAIL, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), ctr_filtered_43_46 AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 AND sr_reason_sk BETWEEN 43 AND 46 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), ctr_avg_base AS (SELECT sr_store_sk, AVG(ctr_total_return) * 1.2 AS threshold FROM customer_total_return GROUP BY sr_store_sk) SELECT c_customer_id FROM ctr_filtered_43_46 AS ctr1 JOIN store AS s ON s_store_sk = ctr1.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c_customer_sk JOIN customer_demographics AS cd ON c_current_cdemo_sk = cd_demo_sk JOIN ctr_avg_base AS avg_base ON ctr1.ctr_store_sk = avg_base.sr_store_sk WHERE ctr1.ctr_total_return > avg_base.threshold AND s_state IN ('IL', 'KY', 'TX') AND cd_marital_status IN ('M', 'M') AND cd_education_status IN ('Advanced Degree', 'College') AND cd_gender = 'F' AND c_birth_month = 2 AND c_birth_year BETWEEN 1965 AND 1971 ORDER BY c_customer_id LIMIT 100;
```

### p09: prefetch_fact_join (ERROR, n/a)
```sql
WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), valid_return_reasons AS (SELECT DISTINCT sr_reason_sk FROM store_returns WHERE sr_reason_sk BETWEEN 43 AND 46), filtered_store_returns AS (SELECT sr_customer_sk, sr_store_sk, sr_reason_sk, SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return FROM store_returns AS sr JOIN date_dim AS dd ON sr.sr_returned_date_sk = dd.d_date_sk JOIN valid_return_reasons AS vrr ON sr.sr_reason_sk = vrr.sr_reason_sk WHERE dd.d_year = 2002 AND sr.sr_return_amt / sr.sr_return_quantity BETWEEN 108 AND 167 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk), avg_return_by_store AS (SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS threshold FROM filtered_store_returns GROUP BY ctr_store_sk) SELECT c_customer_id FROM filtered_store_returns AS ctr1 JOIN store AS s ON s.s_store_sk = ctr1.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c.c_customer_sk JOIN customer_demographics AS cd ON c.c_current_cdemo_sk = cd.cd_demo_sk JOIN avg_return_by_store AS a ON ctr1.ctr_store_sk = a.ctr_store_sk WHERE ctr1.ctr_total_return > a.threshold AND ctr1.ctr_reason_sk BETWEEN 43 AND 46 AND s.s_state IN ('IL', 'KY', 'TX') AND cd.cd_marital_status IN ('M', 'M') AND cd.cd_education_status IN ('Advanced Degree', 'College') AND cd.cd_gender = 'F' AND c.c_birth_month = 2 AND c.c_birth_year BETWEEN 1965 AND 1971 ORDER BY c_customer_id LIMIT 100;
```


## Shot 1 Results

| # | Family | Transform | Speedup | Status | Error |
|---|--------|-----------|---------|--------|-------|
| snipe_p1 | ? | unknown | - | FAIL | Tier-1: LITERAL MISMATCH: Original literals missing from rewrite — numbers: ['1.2']. The rewrite changed filter values instead of preserving them. |
| snipe_p2 | ? | unknown | - | FAIL | Tier-1: LITERAL MISMATCH: Original literals missing from rewrite — strings: ['Advanced Degree', 'College', 'IL', 'KY', 'TX'], numbers: ['1.2', '1965.0', '1971.0', '2.0']. The rewrite changed filter values instead of preserving them. |

### snipe_p1 Error:
Tier-1: LITERAL MISMATCH: Original literals missing from rewrite — numbers: ['1.2']. The rewrite changed filter values instead of preserving them.

### snipe_p2 Error:
Tier-1: LITERAL MISMATCH: Original literals missing from rewrite — strings: ['Advanced Degree', 'College', 'IL', 'KY', 'TX'], numbers: ['1.2', '1965.0', '1971.0', '2.0']. The rewrite changed filter values instead of preserving them.

## Shot 2 — Design 2 More Patch Plans

Build on shot 1 results:
1. Your first plan should refine or extend the best winner (or fix its remaining bottleneck)
2. Your second should try a different approach not yet attempted

If all shot 1 plans failed, diagnose why and try fundamentally different strategies.

Output exactly **2 patch plans** as a JSON array.

Tier-0 Output Contract (hard fail):
- response must be valid JSON
- first character must be `[` (no leading whitespace/newlines)
- top-level value must be an array of exactly 2 objects
- no markdown fences, prose, or commentary
- never emit key `sql`; use `sql_fragment` for SQL fragments

Required per plan:
- `plan_id`, `family`, `transform`, `hypothesis`, `target_ir`, `dialect`, `steps`
- optional: `based_on` as a string (use comma-separated IDs for multiple sources; never an array)
- `steps[]` item: `step_id`, `op`, `target`, optional `payload`
- `target.by_node_id` MUST be `"S0"` (use `by_anchor_hash` only when needed)

Allowed `op` values:
- `insert_cte`
- `replace_from`
- `replace_where_predicate`
- `replace_body`
- `replace_expr_subtree`
- `delete_expr_subtree`
- `replace_join_condition`
- `replace_select`
- `replace_block_with_cte_pair`
- `wrap_query_with_cte`

Semantic guards (MUST preserve):
- all WHERE/HAVING/ON logic
- all literals exactly
- columns/aliases/ORDER BY/LIMIT
- row count and semantics
- no orphaned CTEs or duplicated source scans after replacement

Rules:
- output exactly 2 plans
- each plan must use a different strategy (`family` + `transform`)
- payload SQL fragments must be complete/executable (no ellipsis)
- `replace_body`, `replace_select`, and `replace_block_with_cte_pair` must put SQL in `payload.sql_fragment`
- cite EXPLAIN evidence in `hypothesis`

Output ONLY JSON array.