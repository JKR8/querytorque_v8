## Step 1 — Compare EXPLAIN Plans

### Analysis of Winners (Family A and B)
**Winners (t1, syn_w1, syn_w2 from Iteration 0)**:
- All winners achieved ~2.1x speedup via Family A (Early Filtering) and Family B (Decorrelation)
- **Structural change**: Pushed `d_month_seq` and `s_state` filters into CTEs earlier
- **Original expensive operator improved**:  
  `CTE Scan (wss)  (rows=9176, time=3557.402)`  
  This was reduced by filtering before joining, cutting input rows to CTE
- **Most expensive remaining operator in winners**:  
  `Hash Join  (rows=10176, time=5583.073)`  
  (Joins between y/x subqueries remains bottleneck)

**Classification**: Both A and B are COMPLEMENTARY  
- A reduced CTE build cost (filtering before aggregation)
- B optimized join patterns between CTE consumers

---

### Analysis of Failures (Family C)
**Failed Patches (t1 from Iteration 1)**:
- Attempted to push aggregation further into CTEs
- **Failure reason**: Literal mismatch (`57*0.01` → `0.57`) caused semantic errors
- **Structural issue**: Changed filter expressions instead of preserving logic
- No plan comparison possible due to execution failure

---

## Step 2 — Design Targets for Round 2

### Primary Bottleneck
`Hash Join  (rows=10176, time=5583.073)`  
(Joins between y/x subqueries after CTE materialization)

---

### Target 1: Combination (A+E)
**Family**: A+E  
**Transform**: `early_filter_then_multi_prefetch`  
**Target ID**: t1  
**Relevance**: 0.95  
**Hypothesis**:  
After Family A reduces CTE size, Family E avoids duplicate dimension scans in y/x subqueries by prefetching filtered store/date_dim. Targets both:  
1. Original CTE build (`CTE Scan (wss) time=3557.402`)  
2. Expensive hash join (`Hash Join time=5583.073`)  
**Target IR**:  
- `S0` (MAIN QUERY): Replace subqueries y/x with prefetched CTEs  
- `5f7f8283ea72d640` (CTE wss): Add store join + state filter  
**Examples**: `pg_date_cte_explicit_join`, `multi_dimension_prefetch`

### Target 2: Refinement (F)
**Family**: F  
**Transform**: `explicit_join_order`  
**Target ID**: t2  
**Relevance**: 0.85  
**Hypothesis**:  
Convert comma joins to explicit INNER JOIN + reorder joins to put small dimension tables first. Reduces input rows to hash join:  
`Hash Join  (rows=10176, time=5583.073)`  
**Target IR**:  
- `S0` (MAIN QUERY): Replace `FROM: (subquery)y, (subquery)x` with explicit JOIN  
- `0b824afb49a292d0`: Maintain join condition  
**Examples**: `pg_explicit_join_materialized`

### Target 3: Rescue (C)
**Family**: C  
**Transform**: `push_agg_into_cte_preserve_literals`  
**Target ID**: t3  
**Relevance**: 0.75  
**Hypothesis**:  
Fix literal mismatch while preserving core idea: aggregate before joining dimensions. Uses Family A winner as baseline.  
**Target IR**:  
- `5f7f8283ea72d640`: Keep `57*0.01` literal, add store join  
**Examples**: `pg_materialized_dimension_fact_prefilter`

### Target 4: Novel (E+F)
**Family**: E+F  
**Transform**: `prefetch_then_join_transform`  
**Target ID**: t4  
**Relevance**: 0.80  
**Hypothesis**:  
Combine dimension prefetching (E) with join flattening (F). Replace y/x subqueries with single CTE using conditional aggregation for both time periods, eliminating join.  
**Target IR**:  
- `S0`: Replace y/x subqueries with single `period_agg` CTE  
- `0b824afb49a292d0`: Convert join to WHERE clause  
**Examples**: `multi_dimension_prefetch`, `pg_explicit_join_materialized`

---

```json
[
  {
    "family": "A+E",
    "transform": "early_filter_then_multi_prefetch",
    "target_id": "t1",
    "relevance_score": 0.95,
    "hypothesis": "Reduces CTE build cost via early filtering (A) and avoids duplicate dimension scans in y/x subqueries via prefetch (E), targeting both CTE Scan (3557ms) and Hash Join (5583ms)",
    "target_ir": "S0: Replace subqueries y/x with prefetched CTEs; 5f7f8283ea72d640: Add store join + state filter",
    "recommended_examples": ["pg_date_cte_explicit_join", "multi_dimension_prefetch"]
  },
  {
    "family": "F",
    "transform": "explicit_join_order",
    "target_id": "t2",
    "relevance_score": 0.85,
    "hypothesis": "Optimizes join order and reduces input rows to expensive Hash Join (5583ms) by converting comma joins to explicit INNER JOIN with small tables first",
    "target_ir": "S0: Replace comma joins with explicit JOIN; 0b824afb49a292d0: Maintain join condition",
    "recommended_examples": ["pg_explicit_join_materialized"]
  },
  {
    "family": "C",
    "transform": "push_agg_into_cte_preserve_literals",
    "target_id": "t3",
    "relevance_score": 0.75,
    "hypothesis": "Rescues aggregation pushdown by preserving literals (57*0.01) while using filtered CTE from Family A winner as baseline",
    "target_ir": "5f7f8283ea72d640: Keep original literals, add store join and state filter",
    "recommended_examples": ["pg_materialized_dimension_fact_prefilter"]
  },
  {
    "family": "E+F",
    "transform": "prefetch_then_join_transform",
    "target_id": "t4",
    "relevance_score": 0.80,
    "hypothesis": "Eliminates Hash Join (5583ms) by prefetching dimensions (E) and converting y/x subqueries to single CTE with conditional aggregation for both periods",
    "target_ir": "S0: Replace y/x with period_agg CTE; 0b824afb49a292d0: Convert join to WHERE clause",
    "recommended_examples": ["multi_dimension_prefetch", "pg_explicit_join_materialized"]
  }
]
```