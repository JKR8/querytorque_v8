[
  {
    "target_id": "t1",
    "family": "A+E",
    "transform": "early_date_store_prefetch",
    "relevance_score": 0.95,
    "hypothesis": "Prefilter date_dim (d_year=2001) and store in CTEs to shrink store_sales scan. Materialize these small dimensions to avoid repeated access during nested loop. Targets the 168K-row Nested Loop.",
    "target_ir": "S0: insert_cte before MAIN QUERY (by_node_id)",
    "recommended_examples": [
      "pg_date_cte_explicit_join",
      "multi_dimension_prefetch"
    ]
  },
  {
    "target_id": "t2",
    "family": "D",
    "transform": "or_to_union_all",
    "relevance_score": 0.85,
    "hypothesis": "Convert OR conditions to UNION ALL branches to simplify planner decisions. Each branch isolates specific filters, avoiding combinatorial explosion in Hash Joins.",
    "target_ir": "S0: replace_where_predicate (by_anchor_hash a6beaa832eeb7899)",
    "recommended_examples": [
      "pg_intersect_to_exists"
    ]
  },
  {
    "target_id": "t3",
    "family": "A+F",
    "transform": "prefetch_explicit_join_reorder",
    "relevance_score": 0.9,
    "hypothesis": "Prefetch all dimension filters in CTEs (including household_demographics dep_count) and enforce optimal join order: date_dim \u2192 store_sales \u2192 store \u2192 other dimensions. Targets residual 18K-row Hash Join.",
    "target_ir": "S0: replace_from + replace_where_predicate",
    "recommended_examples": [
      "pg_date_cte_explicit_join",
      "pg_explicit_join_materialized"
    ]
  },
  {
    "target_id": "t4",
    "family": "E",
    "transform": "fact_table_materialize",
    "relevance_score": 0.8,
    "hypothesis": "Materialize store_sales after date filter to avoid repeated index scans. Join pre-aggregated fact rows with dimensions to reduce nested loop cost.",
    "target_ir": "S0: insert_cte after date_dim join (by_anchor_hash a6beaa832eeb7899)",
    "recommended_examples": [
      "multi_dimension_prefetch"
    ]
  }
]