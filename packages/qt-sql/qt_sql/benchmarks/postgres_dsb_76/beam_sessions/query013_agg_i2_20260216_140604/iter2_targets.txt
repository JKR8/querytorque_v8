[
  {
    "target_id": "t1",
    "family": "A+E",
    "transform": "prefilter_dimensions",
    "relevance_score": 0.95,
    "hypothesis": "Filter household_demographics (hd_dep_count IN (1,3)) and customer_demographics (cd_marital_status/education IN valid values) early to shrink Hash Join input from 1,440 to <100 rows.",
    "target_ir": "S0",
    "recommended_examples": [
      "multi_dimension_prefetch",
      "pg_date_cte_explicit_join"
    ]
  },
  {
    "target_id": "t1",
    "family": "A",
    "transform": "push_cd_filters",
    "relevance_score": 0.85,
    "hypothesis": "Push customer_demographics filters (cd_marital_status/education) into its join to avoid materializing invalid rows for the Hash Join (current input: 1,440 rows).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_date_cte_explicit_join"
    ]
  },
  {
    "target_id": "t1",
    "family": "D",
    "transform": "union_demographics_branches",
    "relevance_score": 0.75,
    "hypothesis": "Convert OR conditions on demographics to UNION ALL branches while preserving t1\u2019s date filter. Avoids single complex join by isolating branch-specific filters.",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_intersect_to_exists",
      "pg_union_all_rewrite"
    ]
  },
  {
    "target_id": "t1",
    "family": "F",
    "transform": "reorder_joins",
    "relevance_score": 0.7,
    "hypothesis": "Reorder joins to sequence small prefiltered dimensions (store, household_demographics) before large fact tables. Targets Hash Join row explosion (6,265 rows).",
    "target_ir": "S0",
    "recommended_examples": [
      "pg_explicit_join_materialized"
    ]
  }
]