### Analysis of Optimization Families

**Family A: Early Filtering (HIGH)**  
The CTE `cross_items` applies filters late after expensive set operations. Pushing item filters (category, manager_id) into the INTERSECT subqueries reduces row counts early. This aligns with cascading CTEs with downstream filters.

**Family B: Decorrelation (LOW)**  
No correlated subqueries exist in WHERE clauses. All subqueries are set-based operations or aggregations without per-row re-execution.

**Family C: Aggregation Pushdown (LOW)**  
GROUP BY operations happen after joins, but keys don't perfectly align with join keys. No clear opportunity to push aggregations earlier.

**Family D: Set Operation Optimization (HIGH)**  
The INTERSECT in `cross_items` materializes large intermediate sets. Replacing with EXISTS avoids full scans and reduces I/O.

**Family E: Materialization/Prefetch (MEDIUM)**  
The `cross_items` CTE is referenced twice but re-executed. Materializing it would prevent duplicate work, though the primary win is from set operation rewrite.

**Family F: Join Transform (HIGH)**  
The main query uses identical store_sales scans for `this_year`/`last_year` with different date filters. Combining into a single pass with conditional aggregation eliminates redundant work.

**Chosen Families**: [D, F, A]  
**Confidence**: High (structural patterns match gold examples)

---

### Optimization Targets

```json
[
  {
    "family": "D",
    "transform": "intersect_to_exists",
    "target_id": "t1",
    "relevance_score": 0.95,
    "hypothesis": "INTERSECT materializes 840K+ rows from three large sales tables. EXISTS avoids intermediate sets and leverages indexes.",
    "target_ir": "S0 [SELECT]\n  CTE: cross_items  (via CTE_Q_S0_cross_items)\n    FROM: item\n    WHERE: [item filters] AND EXISTS (SELECT 1 FROM store_sales, date_dim d1 WHERE ss_item_sk=i_item_sk AND d1.d_year BETWEEN 1999 AND 2001 AND ...)\n      AND EXISTS (SELECT 1 FROM catalog_sales, date_dim d2 WHERE cs_item_sk=i_item_sk AND d2.d_year BETWEEN 1999 AND 2001 AND ...)\n      AND EXISTS (SELECT 1 FROM web_sales, date_dim d3 WHERE ws_item_sk=i_item_sk AND d3.d_year BETWEEN 1999 AND 2001 AND ...)",
    "recommended_examples": ["pg_intersect_to_exists"]
  },
  {
    "family": "F",
    "transform": "join_transform_combine_subqueries",
    "target_id": "t2",
    "relevance_score": 0.85,
    "hypothesis": "Separate store_sales scans for 1999/2000 cause duplicate joins and aggregations. Single-pass with CASE expressions cuts I/O.",
    "target_ir": "S0 [SELECT]\n  CTE: sales_combined  (new)\n    FROM: store_sales, item, date_dim\n    WHERE: ss_item_sk IN (cross_items) AND ss_sold_date_sk=d_date_sk\n      AND d_week_seq IN (1999_week, 2000_week)\n    GROUP BY: i_brand_id, i_class_id, i_category_id, d_week_seq\n  MAIN QUERY (via Q_S0)\n    FROM: sales_combined this_year, sales_combined last_year\n    WHERE: this_year.d_week_seq=2000_week\n      AND last_year.d_week_seq=1999_week\n      AND [join on brand/class/category]\n    HAVING: this_year.sales > avg_sales AND last_year.sales > avg_sales",
    "recommended_examples": ["pg_explicit_join_materialized"]
  },
  {
    "family": "A",
    "transform": "predicate_push_into_setop",
    "target_id": "t3",
    "relevance_score": 0.75,
    "hypothesis": "Item filters (category, manager_id) applied late in cross_items. Push into INTERSECT subqueries to reduce rows early.",
    "target_ir": "S0 [SELECT]\n  CTE: cross_items  (via CTE_Q_S0_cross_items)\n    FROM: item, (subquery x WITH item filters in each INTERSECT branch)",
    "recommended_examples": ["pg_date_cte_explicit_join"]
  }
]
```