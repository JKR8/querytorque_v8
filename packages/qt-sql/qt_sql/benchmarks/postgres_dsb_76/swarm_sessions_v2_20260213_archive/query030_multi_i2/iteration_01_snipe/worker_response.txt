<reasoning>
1. **DIAGNOSE**: The best previous attempt (W3) achieved only 1.09x speedup because:
   - The CTE materialization fence blocked predicate pushdown of `ca_state IN ('OK','SC','TX','WI')` into the base aggregation.
   - The execution plan shows sequential scan on web_returns (2,617 rows) with hash joins to dimension tables - this is already optimal.
   - The real bottleneck is that `base_cte` computes returns for ALL states, but the final query only needs 4 states. This wastes I/O and compute.
   - The state average computation (state_avg_cte) scans the entire base_cte (99 rows) instead of just the 4 needed states.

2. **IDENTIFY**: Unexplored angles:
   - Push the `ca_state IN ('OK','SC','TX','WI')` filter EARLIER into the base aggregation CTE definition.
   - Use explicit JOIN syntax instead of comma joins for better PostgreSQL optimization.
   - Pre-filter customer_address for both returning and current address contexts.
   - Materialize filtered dimension tables to create tiny hash tables.

3. **REWRITE**: I'll create a fresh approach:
   - CTE1: Pre-filter date_dim for d_year=2002
   - CTE2: Pre-filter item for i_manager_id BETWEEN 68 AND 77
   - CTE3: Pre-filter customer_address for ca_state IN ('OK','SC','TX','WI') - for BOTH returning address (in base aggregation) AND current address (in final join)
   - CTE4: Join web_returns with all filtered dimensions, compute per-customer-state-reason returns ONLY for needed states
   - CTE5: Compute state averages ONLY for those 4 states
   - Main query: Join aggregated data with customer and current address (pre-filtered)
   This reduces the base aggregation input from all states to just 4 states.
</reasoning>

## Modified Logic Tree

[=] Original query structure with correlated subquery
[-] Remove correlated subquery approach
[+] Add dimension pre-filtering CTEs
  [+] date_filter: SELECT d_date_sk FROM date_dim WHERE d_year = 2002
  [+] item_filter: SELECT i_item_sk FROM item WHERE i_manager_id BETWEEN 68 AND 77
  [+] addr_filter: SELECT ca_address_sk, ca_state FROM customer_address WHERE ca_state IN ('OK','SC','TX','WI')
[+] Modify base aggregation CTE to:
  [-] Remove comma joins
  [+] Use explicit INNER JOINs with pre-filtered CTEs
  [+] Push ca_state filter into JOIN condition
  [+] Keep division guard: wr_return_amt / wr_return_quantity BETWEEN 242 AND 271
[+] Add state_avg CTE computed from filtered base aggregation
[=] Main query joins unchanged (preserves all columns and ordering)

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "pg_dimension_prefetch_star", "description": "Pre-filter selective dimensions into CTEs for tiny hash tables", "applied_to": ["date_filter", "item_filter", "addr_filter"]},
    {"id": "R2", "type": "explicit_join_conversion", "description": "Convert comma joins to explicit INNER JOIN syntax for better PG optimization", "applied_to": ["base_returns"]},
    {"id": "R3", "type": "early_state_filter", "description": "Push ca_state filter into base aggregation CTE to reduce input by ~90%", "applied_to": ["base_returns"]},
    {"id": "R4", "type": "decorrelate_state_avg", "description": "Replace correlated subquery with explicit CTE + JOIN", "applied_to": ["state_avg", "main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filter": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "item_filter": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk FROM item WHERE i_manager_id BETWEEN 68 AND 77",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "addr_filter": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ca_address_sk, ca_state FROM customer_address WHERE ca_state IN ('OK', 'SC', 'TX', 'WI')",
        "interfaces": {"outputs": ["ca_address_sk", "ca_state"], "consumes": []}
      },
      "base_returns": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT wr_returning_customer_sk AS ctr_customer_sk, ca_state AS ctr_state, wr_reason_sk AS ctr_reason_sk, SUM(wr_return_amt) AS ctr_total_return FROM web_returns INNER JOIN date_filter ON wr_returned_date_sk = date_filter.d_date_sk INNER JOIN addr_filter ON wr_returning_addr_sk = addr_filter.ca_address_sk INNER JOIN item_filter ON wr_item_sk = item_filter.i_item_sk WHERE wr_return_amt / wr_return_quantity BETWEEN 242 AND 271 GROUP BY wr_returning_customer_sk, ca_state, wr_reason_sk",
        "interfaces": {"outputs": ["ctr_customer_sk", "ctr_state", "ctr_reason_sk", "ctr_total_return"], "consumes": ["date_filter", "addr_filter", "item_filter"]}
      },
      "state_avg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ctr_state, AVG(ctr_total_return) * 1.2 AS state_avg_threshold FROM base_returns GROUP BY ctr_state",
        "interfaces": {"outputs": ["ctr_state", "state_avg_threshold"], "consumes": ["base_returns"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_customer_id, c_salutation, c_first_name, c_last_name, c_preferred_cust_flag, c_birth_day, c_birth_month, c_birth_year, c_birth_country, c_login, c_email_address, c_last_review_date_sk, base_returns.ctr_total_return FROM base_returns INNER JOIN state_avg ON base_returns.ctr_state = state_avg.ctr_state INNER JOIN customer ON base_returns.ctr_customer_sk = customer.c_customer_sk INNER JOIN addr_filter ON addr_filter.ca_address_sk = customer.c_current_addr_sk WHERE base_returns.ctr_total_return > state_avg.state_avg_threshold AND base_returns.ctr_reason_sk IN (20, 36) AND customer.c_birth_year BETWEEN 1985 AND 1991 ORDER BY c_customer_id, c_salutation, c_first_name, c_last_name, c_preferred_cust_flag, c_birth_day, c_birth_month, c_birth_year, c_birth_country, c_login, c_email_address, c_last_review_date_sk, base_returns.ctr_total_return LIMIT 100",
        "interfaces": {"outputs": ["c_customer_id", "c_salutation", "c_first_name", "c_last_name", "c_preferred_cust_flag", "c_birth_day", "c_birth_month", "c_birth_year", "c_birth_country", "c_login", "c_email_address", "c_last_review_date_sk", "ctr_total_return"], "consumes": ["base_returns", "state_avg", "addr_filter"]}
      }
    },
    "reconstruction_order": ["date_filter", "item_filter", "addr_filter", "base_returns", "state_avg", "main_query"],
    "assembly_template": "WITH date_filter AS ({date_filter}), item_filter AS ({item_filter}), addr_filter AS ({addr_filter}), base_returns AS ({base_returns}), state_avg AS ({state_avg}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '128MB'", "SET LOCAL enable_nestloop = off"],
  "validation_checks": []
}
```

**Changes**: Pushed state filter into base aggregation via pre-filtered address CTE, converted to explicit JOINs, and decorrelated the state average computation. This reduces the web_returns scan from all states to just 4 states.

**Expected speedup**: 2.5-3.0x by eliminating ~90% of base aggregation work and enabling better hash join planning with tiny dimension tables.