## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~121K
    ├── [~] CTE: filtered_dimensions_cte (date_dim × item with filters)
    ├── [~] CTE: store_sales_join (store_sales JOIN filtered_dimensions_cte)
    ├── [~] CTE: web_sales_join (web_sales JOIN filtered_dimensions_cte)
    ├── [~] CTE: catalog_sales_join (catalog_sales JOIN filtered_dimensions_cte)
    ├── [~] customer_filter (customer JOIN store_sales_join LEFT JOIN web/catalog)
    ├── [~] address_filter (customer_filter JOIN customer_address)
    ├── [~] demographics_filter (address_filter JOIN customer_demographics)
    ├── [=] AGG (GROUP BY)
    ├── [=] SORT (same 8 columns)
    └── [=] OUTPUT (same 14 columns)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "pg_dimension_prefetch_star", "description": "Prefilter date_dim and item into shared CTE for all three sales channels", "applied_to": ["filtered_dimensions_cte"]},
    {"id": "R2", "type": "structural_decomposition", "description": "Decompose OR EXISTS into LEFT JOIN + IS NOT NULL pattern", "applied_to": ["customer_filter"]},
    {"id": "R3", "type": "cte_inlining", "description": "Use CTE for dimension filters but leave fact table scans inline for parallelism", "applied_to": ["store_sales_join", "web_sales_join", "catalog_sales_join"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dimensions_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d.d_date_sk, i.i_item_sk FROM date_dim d CROSS JOIN item i WHERE d.d_year = 1999 AND d.d_moy BETWEEN 8 AND 11 AND i.i_category IN ('Children', 'Electronics', 'Music') AND i.i_manager_id BETWEEN 66 AND 75",
        "interfaces": {"outputs": ["d_date_sk", "i_item_sk"], "consumes": []}
      },
      "store_sales_join": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT ss.ss_customer_sk FROM store_sales ss JOIN filtered_dimensions_cte f ON ss.ss_sold_date_sk = f.d_date_sk AND ss.ss_item_sk = f.i_item_sk WHERE ss.ss_list_price > 0 AND ss.ss_sales_price / ss.ss_list_price BETWEEN 20 * 0.01 AND 30 * 0.01",
        "interfaces": {"outputs": ["ss_customer_sk"], "consumes": ["filtered_dimensions_cte"]}
      },
      "web_sales_join": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT DISTINCT ws.ws_bill_customer_sk FROM web_sales ws JOIN filtered_dimensions_cte f ON ws.ws_sold_date_sk = f.d_date_sk AND ws.ws_item_sk = f.i_item_sk WHERE ws.ws_list_price > 0 AND ws.ws_sales_price / ws.ws_list_price BETWEEN 20 * 0.01 AND 30 * 0.01",
        "interfaces": {"outputs": ["ws_bill_customer_sk"], "consumes": ["filtered_dimensions_cte"]}
      },
      "catalog_sales_join": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT cs.cs_ship_customer_sk FROM catalog_sales cs JOIN filtered_dimensions_cte f ON cs.cs_sold_date_sk = f.d_date_sk AND cs.cs_item_sk = f.i_item_sk WHERE cs.cs_list_price > 0 AND cs.cs_sales_price / cs.cs_list_price BETWEEN 20 * 0.01 AND 30 * 0.01",
        "interfaces": {"outputs": ["cs_ship_customer_sk"], "consumes": ["filtered_dimensions_cte"]}
      },
      "customer_filter": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c.c_current_addr_sk, c.c_current_cdemo_sk FROM customer c JOIN store_sales_join ss ON c.c_customer_sk = ss.ss_customer_sk LEFT JOIN web_sales_join ws ON c.c_customer_sk = ws.ws_bill_customer_sk LEFT JOIN catalog_sales_join cs ON c.c_customer_sk = cs.cs_ship_customer_sk WHERE c.c_birth_month IN (1, 5) AND (ws.ws_bill_customer_sk IS NOT NULL OR cs.cs_ship_customer_sk IS NOT NULL)",
        "interfaces": {"outputs": ["c_current_addr_sk", "c_current_cdemo_sk"], "consumes": ["store_sales_join", "web_sales_join", "catalog_sales_join"]}
      },
      "address_filter": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT cf.c_current_cdemo_sk FROM customer_filter cf JOIN customer_address ca ON cf.c_current_addr_sk = ca.ca_address_sk WHERE ca.ca_county IN ('Grays Harbor County', 'Kootenai County', 'Pike County', 'Thomas County', 'Uinta County')",
        "interfaces": {"outputs": ["c_current_cdemo_sk"], "consumes": ["customer_filter"]}
      },
      "demographics_filter": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd.cd_gender, cd.cd_marital_status, cd.cd_education_status, cd.cd_purchase_estimate, cd.cd_credit_rating, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM address_filter af JOIN customer_demographics cd ON af.c_current_cdemo_sk = cd.cd_demo_sk WHERE cd.cd_marital_status IN ('U', 'U', 'M') AND cd.cd_education_status IN ('College', 'Primary', '2 yr Degree') AND cd.cd_gender = 'M'",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"], "consumes": ["address_filter"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3, cd_dep_count, COUNT(*) AS cnt4, cd_dep_employed_count, COUNT(*) AS cnt5, cd_dep_college_count, COUNT(*) AS cnt6 FROM demographics_filter GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating, cd_dep_count, cd_dep_employed_count, cd_dep_college_count ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3", "cd_dep_count", "cnt4", "cd_dep_employed_count", "cnt5", "cd_dep_college_count", "cnt6"], "consumes": ["demographics_filter"]}
      }
    },
    "reconstruction_order": ["filtered_dimensions_cte", "store_sales_join", "web_sales_join", "catalog_sales_join", "customer_filter", "address_filter", "demographics_filter", "main_query"],
    "assembly_template": "WITH filtered_dimensions_cte AS ({filtered_dimensions_cte}), store_sales_join AS ({store_sales_join}), web_sales_join AS ({web_sales_join}), catalog_sales_join AS ({catalog_sales_join}), customer_filter AS ({customer_filter}), address_filter AS ({address_filter}), demographics_filter AS ({demographics_filter}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL enable_mergejoin = off", 
    "SET LOCAL hash_mem_multiplier = 2.0",
    "SET LOCAL max_parallel_workers_per_gather = 2"
  ],
  "validation_checks": []
}
```

**Changes**: Prefiltered date_dim × item into shared CTE (prefetch star pattern), decomposed OR EXISTS into LEFT JOIN + IS NOT NULL while preserving semi-join semantics via DISTINCT, kept defensive division guards. All fact table CTEs use DISTINCT to prevent row duplication from multiple qualifying sales per customer.

**Expected speedup**: 3-4x from eliminating redundant dimension scans and enabling parallel fact table scans with CTE inlining. The shared dimension filter CTE reduces total work, while DISTINCT + LEFT JOIN pattern preserves EXISTS semantics without blocking parallelism.