<reasoning>
1. **CLASSIFY**: This is a "channel-comparison self-join" query with EXISTS/NOT EXISTS set operations across three sales channels (store, web, catalog). It finds customers in specific states with specific demographics who made store sales in a period but NO web or catalog sales in the same period, then groups by demographics. The three EXISTS subqueries correlate by customer_sk and scan the same date_dim range three times.

2. **EXPLAIN PLAN ANALYSIS**:
   - Total runtime: 33.2s. Dominant nodes:
     - `Nested Loop Anti` for catalog_sales: 25.6s (77% of total) = 1105 loops × 12.5ms materialize + 1105 loops × (??) join filter.
     - `Nested Loop Anti` for web_sales: 3.8s (11.5%) = 1128 loops × 3.4ms materialize.
     - `Hash Join Semi` for store_sales: ~1.7s (5.1%) = 3 parallel loops × 573.6ms.
   - Row count drops:
     - customer_address: 83K → 11K (ca_state filter).
     - store_sales + date_dim: 151K rows after join and list_price filter.
     - customer + address + demographics: 22K rows → 1,691 rows after semi-join.
   - Missed opportunity: The same date_dim filter (d_year=2002, d_moy 10-12) is scanned three times (store, web, catalog). Each scan returns ~31 rows (index only). The optimizer already reuses the index scan pattern but doesn't share the result.
   - Fact table scans: store_sales scanned once (in semi-join), web_sales scanned once (in anti-join), catalog_sales scanned once (in anti-join). Each is a separate index scan with same date filter.
   - CTE materialization: The EXPLAIN shows Materialize nodes for web_sales and catalog_sales loops, meaning the subquery result is materialized per outer row? Actually "Materialize (rows=84K loops=1128)" indicates the inner side of the nested loop is materialized 1128 times (once per outer row). This is catastrophic.

3. **GAP MATCHING**:
   - COMMA_JOIN_WEAKNESS: Yes, query uses comma-separated implicit joins in main FROM and subqueries.
   - CORRELATED_SUBQUERY_PARALYSIS: Yes, EXISTS/NOT EXISTS are correlated. The EXPLAIN shows nested loop anti-joins with materialization per outer row.
   - CROSS_CTE_PREDICATE_BLINDNESS: The same date_dim filter appears three times but isn't shared.
   - NON_EQUI_JOIN_INPUT_BLINDNESS: Not applicable (no non-equi joins).
   - The optimizer already converts EXISTS to semi/anti joins but chooses nested loops with materialization for anti-joins.

4. **AGGREGATION TRAP CHECK**: The query uses COUNT(*) three times but they are identical counts (same group, no FILTER). All COUNTs are grouping-insensitive. Changing join order could introduce duplicates, but COUNT(*) would increase. Need to ensure no duplicate rows from joins.

5. **TRANSFORM SELECTION** (ranked by expected value):
   a. **pg_dimension_prefetch_star**: Addresses COMMA_JOIN_WEAKNESS. Pre-filter dimensions (customer_address, customer_demographics, date_dim) into CTEs, convert to explicit JOINs. Expected to improve cardinality estimates.
   b. **inline_decorrelate_materialized**: Addresses CORRELATED_SUBQUERY_PARALYSIS. Decorate EXISTS subqueries by precomputing customer sets for each channel in MATERIALIZED CTEs, then JOIN/ANTI-JOIN.
   c. **pg_self_join_decomposition**: Addresses CROSS_CTE_PREDICATE_BLINDNESS. Share the date_dim filter via a single CTE, maybe also share fact table scans? The three fact tables are different, but date_dim is common.
   d. **star_join_prefetch + scan_consolidation_pivot**: Novel combination. Pre-filter dimensions, compute customer presence per channel in a single pass using conditional aggregation, then filter.

6. **LOGICAL TREE DESIGN**:
   - For decorrelation strategy: Need CTEs for filtered_date, store_customers, web_customers, catalog_customers. Then join customer with address/demographics and anti-join with web/catalog customer sets.
   - For dimension prefetch: CTEs for filtered_ca, filtered_cd, filtered_date. Then explicit joins.
   - Must ensure all columns needed for GROUP BY and SELECT are in CTE outputs.

Worker 4 will attempt a novel combination: precomputing all three channel customer sets in parallel using a UNION ALL with discriminator, then pivoting to boolean columns per customer. This reduces three separate fact scans to one scan per fact table? Actually still three scans but consolidated into a single query. Might enable hash aggregation.

</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT: Business intent: Identify demographic segments of customers in three states who purchased in stores during Q4 2002 (list price $80-$169) but did NOT purchase via web or catalog in same period. JOIN semantics: All joins are INNER equi-joins (customer-address, customer-demographics) plus EXISTS semi-join and NOT EXISTS anti-joins correlated by customer_sk. Aggregation trap: Three COUNT(*) are identical per group (no FILTER clause). Filter dependencies: The date range (2002, months 10-12) and list price range (80-169) must apply identically across all three channel subqueries.

BOTTLENECK_DIAGNOSIS: Dominant cost is nested-loop anti-joins for web_sales and catalog_sales (89% combined), specifically the Materialize operations repeated per outer row (1105 and 1128 loops). The plan is join-bound due to poor correlation handling. Cardinality flow: 11K addresses → 22K customer+address → 1,691 after store_sales semi-join → 1,105 after web anti-join → 964 after catalog anti-join → 80 groups. Optimizer already handles parallel hash semi-join for store_sales well. Logical-tree costs misleading: store_sales semi-join shows 50% cost but only 5% runtime.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output cd_gender, cd_marital_status, cd_education_status, cnt1, cd_purchase_estimate, cnt2, cd_credit_rating, cnt3 in exact order.
- CTE_COLUMN_COMPLETENESS: Any CTE must include all columns referenced downstream: customer_sk, address_sk, demo_sk, ca_state, cd_* columns, etc.
- LITERAL_PRESERVATION: Must preserve literal values: ca_state IN ('CO','NC','TX'), cd_marital_status IN ('S','M','U'), cd_education_status IN ('Primary','College'), d_year=2002, d_moy between 10 and 12, list_price between 80 and 169.
- SEMANTIC_EQUIVALENCE: Must return same rows as original with same grouping counts.
- COMMA_JOIN_WEAKNESS: Query uses comma-separated joins in main FROM and subqueries, confusing cardinality estimation.
- CORRELATED_SUBQUERY_PARALYSIS: EXISTS/NOT EXISTS cause nested-loop anti-joins with per-row materialization.
- CROSS_CTE_PREDICATE_BLINDNESS: Same date_dim filter scanned three times separately.

REGRESSION_WARNINGS:
1. EXISTS to IN/NOT IN materializing CTEs (observed regression 0.50x on Q069):
   CAUSE: Converting EXISTS to NOT IN with CTEs blocked hash anti-join optimization.
   RULE: Do NOT convert NOT EXISTS to NOT IN; keep anti-join structure but decorrelate via precomputed sets and LEFT JOIN / IS NULL.
2. Splitting OR conditions into UNION ALL (observed regression 0.21x on Q085):
   CAUSE: PostgreSQL's bitmap OR scan is more efficient.
   RULE: Not applicable; query has no OR conditions on indexed columns.

=== WORKER 1 BRIEFING ===

STRATEGY: explicit_join_dimension_prefetch
TARGET_LOGICAL_TREE:
  filtered_ca -> filtered_cd -> filtered_date -> customer_join -> store_semi -> web_anti -> catalog_anti -> group_by
NODE_CONTRACTS:
  filtered_ca:
    FROM: customer_address
    WHERE: ca_state IN ('CO','NC','TX')
    OUTPUT: ca_address_sk, ca_state
    EXPECTED_ROWS: 11K
    CONSUMERS: customer_join
  filtered_cd:
    FROM: customer_demographics
    WHERE: cd_marital_status IN ('S','M','U') AND cd_education_status IN ('Primary','College')
    OUTPUT: cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: ~? (not in EXPLAIN; but selective)
    CONSUMERS: customer_join
  filtered_date:
    FROM: date_dim
    WHERE: d_year = 2002 AND d_moy BETWEEN 10 AND 12
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 31
    CONSUMERS: store_sales_cte, web_sales_cte, catalog_sales_cte
  store_sales_cte:
    FROM: store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk
    WHERE: ss_list_price BETWEEN 80 AND 169
    OUTPUT: ss_customer_sk
    EXPECTED_ROWS: 151K
    CONSUMERS: store_semi
  web_sales_cte:
    FROM: web_sales JOIN filtered_date ON ws_sold_date_sk = d_date_sk
    WHERE: ws_list_price BETWEEN 80 AND 169
    OUTPUT: ws_bill_customer_sk
    EXPECTED_ROWS: 84K
    CONSUMERS: web_anti
  catalog_sales_cte:
    FROM: catalog_sales JOIN filtered_date ON cs_sold_date_sk = d_date_sk
    WHERE: cs_list_price BETWEEN 80 AND 169
    OUTPUT: cs_ship_customer_sk
    EXPECTED_ROWS: 332K
    CONSUMERS: catalog_anti
  customer_join:
    FROM: customer c
      JOIN filtered_ca ON c.c_current_addr_sk = ca_address_sk
      JOIN filtered_cd ON cd_demo_sk = c.c_current_cdemo_sk
    OUTPUT: c_customer_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: 22K
    CONSUMERS: store_semi
  store_semi:
    FROM: customer_join
      INNER JOIN store_sales_cte ON c_customer_sk = ss_customer_sk
    OUTPUT: c_customer_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: 1,691
    CONSUMERS: web_anti
  web_anti:
    FROM: store_semi
      LEFT JOIN web_sales_cte ON c_customer_sk = ws_bill_customer_sk
    WHERE: ws_bill_customer_sk IS NULL
    OUTPUT: c_customer_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: 1,105
    CONSUMERS: catalog_anti
  catalog_anti:
    FROM: web_anti
      LEFT JOIN catalog_sales_cte ON c_customer_sk = cs_ship_customer_sk
    WHERE: cs_ship_customer_sk IS NULL
    OUTPUT: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: 964
    CONSUMERS: group_by
  group_by:
    FROM: catalog_anti
    GROUP BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    AGGREGATE: COUNT(*) AS cnt
    OUTPUT: cd_gender, cd_marital_status, cd_education_status, cnt AS cnt1, cd_purchase_estimate, cnt AS cnt2, cd_credit_rating, cnt AS cnt3
    EXPECTED_ROWS: 80
    CONSUMERS: order_by_limit
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply pre-filtering of customer_address and customer_demographics into CTEs and convert comma joins to explicit JOIN syntax. Ignore the promotion/item dimensions; our query has different dimensions.
- pg_date_cte_explicit_join: Apply date_dim isolation into CTE and explicit joins. Ignore the fact that example also converts fact joins; we keep fact tables in separate CTEs.
HAZARD_FLAGS:
- Converting NOT EXISTS to LEFT JOIN/IS NULL may change NULL handling if ws_bill_customer_sk can be NULL (unlikely in fact table).
- CTEs may be inlined unless MATERIALIZED is used, losing materialization benefit.

=== WORKER 2 BRIEFING ===

STRATEGY: decorrelate_materialized_sets
TARGET_LOGICAL_TREE:
  filtered_date -> channel_customers_ctes -> customer_base -> set_joins -> group_by
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_year = 2002 AND d_moy BETWEEN 10 AND 12
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 31
    CONSUMERS: store_customers, web_customers, catalog_customers
  store_customers:
    FROM: store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk
    WHERE: ss_list_price BETWEEN 80 AND 169
    OUTPUT: ss_customer_sk
    EXPECTED_ROWS: 151K
    CONSUMERS: customer_base
  web_customers:
    FROM: web_sales JOIN filtered_date ON ws_sold_date_sk = d_date_sk
    WHERE: ws_list_price BETWEEN 80 AND 169
    OUTPUT: ws_bill_customer_sk
    EXPECTED_ROWS: 84K
    CONSUMERS: customer_base
  catalog_customers:
    FROM: catalog_sales JOIN filtered_date ON cs_sold_date_sk = d_date_sk
    WHERE: cs_list_price BETWEEN 80 AND 169
    OUTPUT: cs_ship_customer_sk
    EXPECTED_ROWS: 332K
    CONSUMERS: customer_base
  customer_base:
    FROM: customer c
      JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk
      JOIN customer_demographics cd ON cd_demo_sk = c.c_current_cdemo_sk
    WHERE: ca.ca_state IN ('CO','NC','TX')
      AND cd.cd_marital_status IN ('S','M','U')
      AND cd.cd_education_status IN ('Primary','College')
    OUTPUT: c_customer_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: 22K
    CONSUMERS: set_joins
  set_joins:
    FROM: customer_base cb
      INNER JOIN store_customers sc ON cb.c_customer_sk = sc.ss_customer_sk
      LEFT JOIN web_customers wc ON cb.c_customer_sk = wc.ws_bill_customer_sk
      LEFT JOIN catalog_customers cc ON cb.c_customer_sk = cc.cs_ship_customer_sk
    WHERE: wc.ws_bill_customer_sk IS NULL AND cc.cs_ship_customer_sk IS NULL
    OUTPUT: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: 964
    CONSUMERS: group_by
  group_by:
    FROM: set_joins
    GROUP BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    AGGREGATE: COUNT(*) AS cnt
    OUTPUT: cd_gender, cd_marital_status, cd_education_status, cnt AS cnt1, cd_purchase_estimate, cnt AS cnt2, cd_credit_rating, cnt AS cnt3
    EXPECTED_ROWS: 80
    CONSUMERS: order_by_limit
EXAMPLES: inline_decorrelate_materialized, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- inline_decorrelate_materialized: Apply MATERIALIZED keyword to channel customer CTEs to force materialization and prevent per-row re-execution. Ignore the three-CTE decomposition for scalar subquery; our subqueries are EXISTS.
- early_filter_decorrelate: Push date filter into CTE definitions and precompute customer sets. Ignore the threshold precomputation; we have no scalar aggregate.
HAZARD_FLAGS:
- MATERIALIZED CTEs may increase memory usage if large (store_customers 151K rows).
- LEFT JOIN / IS NULL must preserve anti-join semantics; ensure no duplicate customer keys in channel CTEs (use DISTINCT if needed).

=== WORKER 3 BRIEFING ===

STRATEGY: shared_date_consolidation
TARGET_LOGICAL_TREE:
  filtered_date -> multi_channel_scan -> customer_base -> filtered_join -> group_by
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_year = 2002 AND d_moy BETWEEN 10 AND 12
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 31
    CONSUMERS: multi_channel_scan
  multi_channel_scan:
    FROM: 
      (SELECT ss_customer_sk, 'store' AS channel FROM store_sales WHERE ss_list_price BETWEEN 80 AND 169)
      UNION ALL
      (SELECT ws_bill_customer_sk, 'web' FROM web_sales WHERE ws_list_price BETWEEN 80 AND 169)
      UNION ALL
      (SELECT cs_ship_customer_sk, 'catalog' FROM catalog_sales WHERE cs_list_price BETWEEN 80 AND 169)
    JOIN filtered_date ON (store_sales.ss_sold_date_sk = d_date_sk OR web_sales.ws_sold_date_sk = d_date_sk OR catalog_sales.cs_sold_date_sk = d_date_sk) -- This is problematic. Better: join each branch separately.
    Actually, let's restructure: create three CTEs that join with filtered_date, then union.
  Let's redesign: Use three CTEs that join with filtered_date, then combine into a single customer-channel table.
  But we need to keep the date join efficient. Instead, do:
  store_sales_filtered:
    FROM: store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk
    WHERE: ss_list_price BETWEEN 80 AND 169
    OUTPUT: ss_customer_sk, 'store' AS channel
  web_sales_filtered: similar
  catalog_sales_filtered: similar
  Then union all into channel_activity.
  However, we still have three separate scans. But we can at least share the date CTE.
  So:
  filtered_date -> store_sales_filtered, web_sales_filtered, catalog_sales_filtered -> channel_activity CTE.
  Then pivot channel_activity to check conditions per customer.
  This is getting complex. Let's stick with sharing date CTE but keep channel scans separate.
  So:
  filtered_date (shared) -> store_sales_cte, web_sales_cte, catalog_sales_cte (as in Worker 1).
  Then same as Worker 1.
  That's essentially Worker 1 with explicit date CTE.
  But we want structural diversity. Let's instead try to consolidate the three fact scans into a single derived table that uses UNION ALL and then aggregate per customer to compute which channels they have.
  Let's design:
  filtered_date -> all_sales_union -> customer_channel_flags -> customer_base -> filter_flags -> group_by.
  So:
  all_sales_union:
    FROM: 
      (SELECT ss_customer_sk AS customer_sk, 'store' AS channel FROM store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk WHERE ss_list_price BETWEEN 80 AND 169)
      UNION ALL
      (SELECT ws_bill_customer_sk, 'web' FROM web_sales JOIN filtered_date ON ws_sold_date_sk = d_date_sk WHERE ws_list_price BETWEEN 80 AND 169)
      UNION ALL
      (SELECT cs_ship_customer_sk, 'catalog' FROM catalog_sales JOIN filtered_date ON cs_sold_date_sk = d_date_sk WHERE cs_list_price BETWEEN 80 AND 169)
    OUTPUT: customer_sk, channel
    EXPECTED_ROWS: 151K+84K+332K = 567K
    CONSUMERS: customer_channel_flags
  customer_channel_flags:
    FROM: all_sales_union
    GROUP BY: customer_sk
    AGGREGATE: 
        BOOL_OR(channel = 'store') AS has_store,
        BOOL_OR(channel = 'web') AS has_web,
        BOOL_OR(channel = 'catalog') AS has_catalog
    OUTPUT: customer_sk, has_store, has_web, has_catalog
    EXPECTED_ROWS: number of distinct customers across all sales (<= 567K)
    CONSUMERS: filter_flags
  Then join with customer_base and filter: has_store = true AND has_web = false AND has_catalog = false.
  This consolidates three fact scans into one pass each but via UNION ALL. However, it still scans each fact table once. The win is reducing date_dim scans to one and maybe enabling hash aggregation.
  Let's proceed with this design.

NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_year = 2002 AND d_moy BETWEEN 10 AND 12
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 31
    CONSUMERS: store_sales_filtered, web_sales_filtered, catalog_sales_filtered
  store_sales_filtered:
    FROM: store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk
    WHERE: ss_list_price BETWEEN 80 AND 169
    OUTPUT: ss_customer_sk AS customer_sk, 'store' AS channel
    EXPECTED_ROWS: 151K
    CONSUMERS: all_sales_union
  web_sales_filtered:
    FROM: web_sales JOIN filtered_date ON ws_sold_date_sk = d_date_sk
    WHERE: ws_list_price BETWEEN 80 AND 169
    OUTPUT: ws_bill_customer_sk AS customer_sk, 'web' AS channel
    EXPECTED_ROWS: 84K
    CONSUMERS: all_sales_union
  catalog_sales_filtered:
    FROM: catalog_sales JOIN filtered_date ON cs_sold_date_sk = d_date_sk
    WHERE: cs_list_price BETWEEN 80 AND 169
    OUTPUT: cs_ship_customer_sk AS customer_sk, 'catalog' AS channel
    EXPECTED_ROWS: 332K
    CONSUMERS: all_sales_union
  all_sales_union:
    FROM: store_sales_filtered UNION ALL web_sales_filtered UNION ALL catalog_sales_filtered
    OUTPUT: customer_sk, channel
    EXPECTED_ROWS: 567K
    CONSUMERS: customer_channel_flags
  customer_channel_flags:
    FROM: all_sales_union
    GROUP BY: customer_sk
    AGGREGATE: 
        MAX(CASE WHEN channel = 'store' THEN 1 ELSE 0 END) AS has_store,
        MAX(CASE WHEN channel = 'web' THEN 1 ELSE 0 END) AS has_web,
        MAX(CASE WHEN channel = 'catalog' THEN 1 ELSE 0 END) AS has_catalog
    OUTPUT: customer_sk, has_store, has_web, has_catalog
    EXPECTED_ROWS: distinct customers in union (<= 567K)
    CONSUMERS: filter_flags
  customer_base: (same as Worker 2)
    FROM: customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk
          JOIN customer_demographics cd ON cd_demo_sk = c.c_current_cdemo_sk
    WHERE: ca.ca_state IN ('CO','NC','TX')
      AND cd.cd_marital_status IN ('S','M','U')
      AND cd.cd_education_status IN ('Primary','College')
    OUTPUT: c_customer_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: 22K
    CONSUMERS: filter_flags
  filter_flags:
    FROM: customer_base cb
      INNER JOIN customer_channel_flags ccf ON cb.c_customer_sk = ccf.customer_sk
    WHERE: ccf.has_store = 1 AND ccf.has_web = 0 AND ccf.has_catalog = 0
    OUTPUT: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: 964
    CONSUMERS: group_by
  group_by: (same as others)
    FROM: filter_flags
    GROUP BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    AGGREGATE: COUNT(*) AS cnt
    OUTPUT: cd_gender, cd_marital_status, cd_education_status, cnt AS cnt1, cd_purchase_estimate, cnt AS cnt2, cd_credit_rating, cnt AS cnt3
    EXPECTED_ROWS: 80
    CONSUMERS: order_by_limit
EXAMPLES: pg_self_join_decomposition, single_pass_aggregation
EXAMPLE_ADAPTATION:
- pg_self_join_decomposition: Apply materialization of shared date filter into CTE and reuse across channel scans. Ignore the fact that example reuses same fact table; we have different fact tables.
- single_pass_aggregation: Use UNION ALL to consolidate channel scans and aggregate per customer to compute channel flags. Ignore the CASE/FILTER inside aggregates; we use MAX(CASE).
HAZARD_FLAGS:
- UNION ALL may increase temp space (567K rows). The per-customer aggregation could be expensive if many distinct customers.
- The MAX(CASE) aggregation must produce correct flags; ensure no duplicate customer_sk per channel? Actually a customer could have multiple sales in same channel, but flag is still 1.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: bitmap_aggregation_early_filter
TARGET_LOGICAL_TREE:
  filtered_date -> channel_bitmaps -> customer_base -> bitmap_join -> group_by
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_year = 2002 AND d_moy BETWEEN 10 AND 12
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 31
    CONSUMERS: channel_bitmaps
  channel_bitmaps:
    FROM: 
      (SELECT ss_customer_sk AS customer_sk FROM store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk WHERE ss_list_price BETWEEN 80 AND 169) store,
      (SELECT ws_bill_customer_sk FROM web_sales JOIN filtered_date ON ws_sold_date_sk = d_date_sk WHERE ws_list_price BETWEEN 80 AND 169) web,
      (SELECT cs_ship_customer_sk FROM catalog_sales JOIN filtered_date ON cs_sold_date_sk = d_date_sk WHERE cs_list_price BETWEEN 80 AND 169) catalog
    Actually, we need to combine them. Let's use a lateral approach: compute three bitmaps via subqueries? Not SQL.
    Instead, compute three separate CTEs of customer_sk, then join them via full outer join? Too complex.
    Let's try a novel approach: use PostgreSQL's hash aggregation with FILTER to compute per-customer channel presence in a single scan of each fact table, but combine with UNION ALL and pivot.
    But that's similar to Worker 3.
    Let's try a different novel combination: use LATERAL to compute channel existence per customer from the customer_base, but that's re-correlating.
    Let's instead precompute three bitmaps as temporary tables? Not allowed.
    Let's explore: Use a single CTE that scans all three fact tables with a discriminator, then use bitmap aggregates per customer.
    We'll design:
    all_sales:
      SELECT ss_customer_sk AS customer_sk, 1 AS store_bit, 0 AS web_bit, 0 AS catalog_bit FROM store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk WHERE ss_list_price BETWEEN 80 AND 169
      UNION ALL
      SELECT ws_bill_customer_sk, 0, 1, 0 FROM web_sales JOIN filtered_date ON ws_sold_date_sk = d_date_sk WHERE ws_list_price BETWEEN 80 AND 169
      UNION ALL
      SELECT cs_ship_customer_sk, 0, 0, 1 FROM catalog_sales JOIN filtered_date ON cs_sold_date_sk = d_date_sk WHERE cs_list_price BETWEEN 80 AND 169
    Then aggregate:
      SELECT customer_sk,
             BIT_OR(store_bit) AS has_store,
             BIT_OR(web_bit) AS has_web,
             BIT_OR(catalog_bit) AS has_catalog
      FROM all_sales
      GROUP BY customer_sk
    But BIT_OR not standard; use MAX.
    This is similar to Worker 3 but with bit columns.
    Let's accept that and focus on the exploration aspect: we are combining dimension prefetch with bitmap aggregation and early filtering.
    We'll also pre-filter customer_address and customer_demographics early.
    So TARGET_LOGICAL_TREE:
      filtered_ca -> filtered_cd -> filtered_date -> all_sales_union -> customer_channel_bits -> customer_join -> filter_bits -> group_by
    Let's define contracts.
NODE_CONTRACTS:
  filtered_ca: (as Worker 1)
    FROM: customer_address
    WHERE: ca_state IN ('CO','NC','TX')
    OUTPUT: ca_address_sk, ca_state
    EXPECTED_ROWS: 11K
    CONSUMERS: customer_join
  filtered_cd: (as Worker 1)
    FROM: customer_demographics
    WHERE: cd_marital_status IN ('S','M','U') AND cd_education_status IN ('Primary','College')
    OUTPUT: cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: ?
    CONSUMERS: customer_join
  filtered_date: (as Worker 1)
    FROM: date_dim
    WHERE: d_year = 2002 AND d_moy BETWEEN 10 AND 12
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 31
    CONSUMERS: store_sales_part, web_sales_part, catalog_sales_part
  store_sales_part:
    FROM: store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk
    WHERE: ss_list_price BETWEEN 80 AND 169
    OUTPUT: ss_customer_sk AS customer_sk, 1 AS store_bit, 0 AS web_bit, 0 AS catalog_bit
    EXPECTED_ROWS: 151K
    CONSUMERS: all_sales_union
  web_sales_part:
    FROM: web_sales JOIN filtered_date ON ws_sold_date_sk = d_date_sk
    WHERE: ws_list_price BETWEEN 80 AND 169
    OUTPUT: ws_bill_customer_sk AS customer_sk, 0 AS store_bit, 1 AS web_bit, 0 AS catalog_bit
    EXPECTED_ROWS: 84K
    CONSUMERS: all_sales_union
  catalog_sales_part:
    FROM: catalog_sales JOIN filtered_date ON cs_sold_date_sk = d_date_sk
    WHERE: cs_list_price BETWEEN 80 AND 169
    OUTPUT: cs_ship_customer_sk AS customer_sk, 0 AS store_bit, 0 AS web_bit, 1 AS catalog_bit
    EXPECTED_ROWS: 332K
    CONSUMERS: all_sales_union
  all_sales_union:
    FROM: store_sales_part UNION ALL web_sales_part UNION ALL catalog_sales_part
    OUTPUT: customer_sk, store_bit, web_bit, catalog_bit
    EXPECTED_ROWS: 567K
    CONSUMERS: customer_channel_bits
  customer_channel_bits:
    FROM: all_sales_union
    GROUP BY: customer_sk
    AGGREGATE: 
        MAX(store_bit) AS has_store,
        MAX(web_bit) AS has_web,
        MAX(catalog_bit) AS has_catalog
    OUTPUT: customer_sk, has_store, has_web, has_catalog
    EXPECTED_ROWS: distinct customers
    CONSUMERS: filter_bits
  customer_join:
    FROM: customer c
      JOIN filtered_ca ON c.c_current_addr_sk = ca_address_sk
      JOIN filtered_cd ON cd_demo_sk = c.c_current_cdemo_sk
    OUTPUT: c_customer_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: 22K
    CONSUMERS: filter_bits
  filter_bits:
    FROM: customer_join cj
      INNER JOIN customer_channel_bits ccb ON cj.c_customer_sk = ccb.customer_sk
    WHERE: ccb.has_store = 1 AND ccb.has_web = 0 AND ccb.has_catalog = 0
    OUTPUT: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    EXPECTED_ROWS: 964
    CONSUMERS: group_by
  group_by: (same)
    FROM: filter_bits
    GROUP BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    AGGREGATE: COUNT(*) AS cnt
    OUTPUT: cd_gender, cd_marital_status, cd_education_status, cnt AS cnt1, cd_purchase_estimate, cnt AS cnt2, cd_credit_rating, cnt AS cnt3
    EXPECTED_ROWS: 80
    CONSUMERS: order_by_limit
EXAMPLES: pg_materialized_dimension_fact_prefilter, channel_bitmap_aggregation
EXAMPLE_ADAPTATION:
- pg_materialized_dimension_fact_prefilter: Apply MATERIALIZED to filtered_date and filtered_ca/filtered_cd CTEs to force early reduction. Ignore the non-equi join aspect; we have equi-joins.
- channel_bitmap_aggregation: Use UNION ALL with bit flags and MAX aggregation to compute channel presence. This is directly applicable.
HAZARD_FLAGS:
- Using MAX on bits assumes at most one row per customer per channel; duplicate rows still produce 1.
- The UNION ALL may be large; consider using DISTINCT in each part to reduce rows? But could increase cost.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy (combining dimension prefetch, date consolidation, and bitmap aggregation)