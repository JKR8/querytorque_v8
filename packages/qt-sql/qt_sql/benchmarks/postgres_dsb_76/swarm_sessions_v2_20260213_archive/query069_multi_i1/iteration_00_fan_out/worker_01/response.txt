### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ~500K
    ├── [=] SCAN (customer AS c (join), customer_address AS ca (join), customer_demographics (join), date_dim (join))
    ├── [!] JOIN (explicit JOIN syntax replaces comma joins)
    ├── [!] CTE filtered_ca (new)
    ├── [!] CTE filtered_cd (new)  
    ├── [!] CTE filtered_date (new)
    ├── [!] CTE store_sales_cte (new)
    ├── [!] CTE web_sales_cte (new)
    ├── [!] CTE catalog_sales_cte (new)
    ├── [!] CTE customer_join (new)
    ├── [!] CTE store_semi (new)
    ├── [!] CTE web_anti (new)
    ├── [!] CTE catalog_anti (new)
    ├── [=] FILTER (ca_state IN ('CO', 'NC', 'TX'))
    ├── [=] FILTER (cd_marital_status IN ('S', 'M', 'U'))
    ├── [=] FILTER (cd_education_status IN ('Primary', 'College'))
    ├── [=] FILTER (d_year = 2002 AND d_moy between 10 and 12)
    ├── [=] FILTER (ss_list_price between 80 and 169)
    ├── [=] FILTER (ws_list_price between 80 and 169)
    ├── [=] FILTER (cs_list_price between 80 and 169)
    ├── [=] ANTI-JOIN (LEFT JOIN/IS NULL for web and catalog)
    ├── [=] AGG (GROUP BY)
    ├── [=] SORT (cd_gender ASC, cd_marital_status ASC, cd_education_status ASC, cd_purchase_estimate ASC, cd_credit_rating ASC)
    └── [=] OUTPUT (cd_gender, cd_marital_status, cd_education_status, cnt1, cd_purchase_estimate, cnt2, cd_credit_rating, cnt3)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL v16.11-0ubuntu0.24.04.1",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefetch", "description": "Pre-filter selective dimensions (address, demographics) into CTEs for hash join efficiency", "applied_to": ["filtered_ca", "filtered_cd"]},
    {"id": "R2", "type": "date_dimension_isolation", "description": "Isolate date filter into CTE to reuse across three fact tables", "applied_to": ["filtered_date"]},
    {"id": "R3", "type": "explicit_join_syntax", "description": "Convert comma-separated joins to explicit INNER JOIN syntax", "applied_to": ["customer_join", "store_sales_cte", "web_sales_cte", "catalog_sales_cte"]},
    {"id": "R4", "type": "decorrelated_anti_join", "description": "Convert correlated NOT EXISTS to LEFT JOIN/IS NULL using precomputed fact CTEs", "applied_to": ["web_anti", "catalog_anti"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_ca": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ca_address_sk, ca_state FROM customer_address WHERE ca_state IN ('CO','NC','TX')",
        "interfaces": {"outputs": ["ca_address_sk", "ca_state"], "consumes": []}
      },
      "filtered_cd": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating FROM customer_demographics WHERE cd_marital_status IN ('S','M','U') AND cd_education_status IN ('Primary','College')",
        "interfaces": {"outputs": ["cd_demo_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": []}
      },
      "filtered_date": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy BETWEEN 10 AND 12",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_sales_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_customer_sk FROM store_sales INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk WHERE ss_list_price BETWEEN 80 AND 169",
        "interfaces": {"outputs": ["ss_customer_sk"], "consumes": ["filtered_date"]}
      },
      "web_sales_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ws_bill_customer_sk FROM web_sales INNER JOIN filtered_date ON ws_sold_date_sk = d_date_sk WHERE ws_list_price BETWEEN 80 AND 169",
        "interfaces": {"outputs": ["ws_bill_customer_sk"], "consumes": ["filtered_date"]}
      },
      "catalog_sales_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cs_ship_customer_sk FROM catalog_sales INNER JOIN filtered_date ON cs_sold_date_sk = d_date_sk WHERE cs_list_price BETWEEN 80 AND 169",
        "interfaces": {"outputs": ["cs_ship_customer_sk"], "consumes": ["filtered_date"]}
      },
      "customer_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c.c_customer_sk, cd.cd_gender, cd.cd_marital_status, cd.cd_education_status, cd.cd_purchase_estimate, cd.cd_credit_rating FROM customer c INNER JOIN filtered_ca ca ON c.c_current_addr_sk = ca.ca_address_sk INNER JOIN filtered_cd cd ON cd.cd_demo_sk = c.c_current_cdemo_sk",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["filtered_ca", "filtered_cd"]}
      },
      "store_semi": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cj.c_customer_sk, cj.cd_gender, cj.cd_marital_status, cj.cd_education_status, cj.cd_purchase_estimate, cj.cd_credit_rating FROM customer_join cj INNER JOIN store_sales_cte ss ON cj.c_customer_sk = ss.ss_customer_sk",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["customer_join", "store_sales_cte"]}
      },
      "web_anti": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss.c_customer_sk, ss.cd_gender, ss.cd_marital_status, ss.cd_education_status, ss.cd_purchase_estimate, ss.cd_credit_rating FROM store_semi ss LEFT JOIN web_sales_cte ws ON ss.c_customer_sk = ws.ws_bill_customer_sk WHERE ws.ws_bill_customer_sk IS NULL",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["store_semi", "web_sales_cte"]}
      },
      "catalog_anti": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT wa.cd_gender, wa.cd_marital_status, wa.cd_education_status, wa.cd_purchase_estimate, wa.cd_credit_rating FROM web_anti wa LEFT JOIN catalog_sales_cte cs ON wa.c_customer_sk = cs.cs_ship_customer_sk WHERE cs.cs_ship_customer_sk IS NULL",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["web_anti", "catalog_sales_cte"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM catalog_anti GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"], "consumes": ["catalog_anti"]}
      }
    },
    "reconstruction_order": ["filtered_ca", "filtered_cd", "filtered_date", "store_sales_cte", "web_sales_cte", "catalog_sales_cte", "customer_join", "store_semi", "web_anti", "catalog_anti", "main_query"],
    "assembly_template": "WITH filtered_ca AS ({filtered_ca}), filtered_cd AS ({filtered_cd}), filtered_date AS ({filtered_date}), store_sales_cte AS ({store_sales_cte}), web_sales_cte AS ({web_sales_cte}), catalog_sales_cte AS ({catalog_sales_cte}), customer_join AS ({customer_join}), store_semi AS ({store_semi}), web_anti AS ({web_anti}), catalog_anti AS ({catalog_anti}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

Changes: Converted correlated subqueries to decorrelated anti-joins using precomputed fact CTEs, pre-filtered selective dimension tables into CTEs, and replaced comma joins with explicit JOIN syntax. This enables hash join planning with tiny dimension hash tables and eliminates per-row subquery evaluation.

Expected speedup: 3-5x due to elimination of correlated subquery overhead, better join order control, and reuse of date dimension filter via CTE materialization.