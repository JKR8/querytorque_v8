## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1
    ├── [CTE] fact_cte  [+]  (store_sales pre-filter)
    ├── [CTE] date_cte  [+]  (date_dim filter for 2001)
    ├── [CTE] hd_cte  [+]  (household_demographics filter)
    ├── [CTE] cd_cte  [+]  (customer_demographics filter)
    ├── [CTE] ca_cte  [+]  (customer_address filter)
    ├── [CTE] store_cte  [+]  (store dimension)
    ├── [CTE] joined  [+]  (join all CTEs with address/profit filters)
    └── [CTE] final_aggregate  [+]  (final MIN aggregates)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter_decorrelate", "description": "Push dimension filters into materialized CTEs before joining", "applied_to": ["date_cte", "hd_cte", "cd_cte", "ca_cte", "store_cte"]},
    {"id": "R2", "type": "pg_materialized_dimension_fact_prefilter", "description": "Pre-filter fact table into CTE with price/profit conditions before dimension joins", "applied_to": ["fact_cte"]},
    {"id": "R3", "type": "cte_structured_join", "description": "Replace comma joins with explicit INNER JOINs in staged CTE structure", "applied_to": ["joined"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "fact_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_store_sk, ss_sold_date_sk, ss_hdemo_sk, ss_cdemo_sk, ss_addr_sk, ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM store_sales WHERE ((ss_sales_price BETWEEN 100.00 AND 150.00) OR (ss_sales_price BETWEEN 50.00 AND 100.00) OR (ss_sales_price BETWEEN 150.00 AND 200.00)) AND ((ss_net_profit BETWEEN 100 AND 200) OR (ss_net_profit BETWEEN 150 AND 300) OR (ss_net_profit BETWEEN 50 AND 250))",
        "interfaces": {"outputs": ["ss_store_sk", "ss_sold_date_sk", "ss_hdemo_sk", "ss_cdemo_sk", "ss_addr_sk", "ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"], "consumes": []}
      },
      "date_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "hd_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE (hd_dep_count = 3) OR (hd_dep_count = 1)",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "cd_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd_demo_sk FROM customer_demographics WHERE ((cd_marital_status = 'M' AND cd_education_status = '2 yr Degree') OR (cd_marital_status = 'S' AND cd_education_status = 'Primary') OR (cd_marital_status = 'W' AND cd_education_status = 'Primary'))",
        "interfaces": {"outputs": ["cd_demo_sk"], "consumes": []}
      },
      "ca_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_country = 'United States' AND ca_state IN ('GA', 'KY', 'SD', 'AR', 'IN', 'VA', 'KS', 'OH', 'SD')",
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s_store_sk FROM store",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "joined": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT f.ss_quantity, f.ss_ext_sales_price, f.ss_ext_wholesale_cost FROM fact_cte f INNER JOIN date_cte d ON f.ss_sold_date_sk = d.d_date_sk INNER JOIN hd_cte h ON f.ss_hdemo_sk = h.hd_demo_sk INNER JOIN cd_cte c ON f.ss_cdemo_sk = c.cd_demo_sk INNER JOIN ca_cte a ON f.ss_addr_sk = a.ca_address_sk INNER JOIN store_cte s ON f.ss_store_sk = s.s_store_sk WHERE (a.ca_state IN ('GA','KY','SD') AND f.ss_net_profit BETWEEN 100 AND 200) OR (a.ca_state IN ('AR','IN','VA') AND f.ss_net_profit BETWEEN 150 AND 300) OR (a.ca_state IN ('KS','OH','SD') AND f.ss_net_profit BETWEEN 50 AND 250)",
        "interfaces": {"outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"], "consumes": ["fact_cte", "date_cte", "hd_cte", "cd_cte", "ca_cte", "store_cte"]}
      },
      "final_aggregate": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT MIN(ss_quantity) AS min_ss_quantity, MIN(ss_ext_sales_price) AS min_ss_ext_sales_price, MIN(ss_ext_wholesale_cost) AS min_ss_ext_wholesale_cost, MIN(ss_ext_wholesale_cost) AS min_ss_ext_wholesale_cost FROM joined",
        "interfaces": {"outputs": ["min_ss_quantity", "min_ss_ext_sales_price", "min_ss_ext_wholesale_cost", "min_ss_ext_wholesale_cost"], "consumes": ["joined"]}
      }
    },
    "reconstruction_order": ["fact_cte", "date_cte", "hd_cte", "cd_cte", "ca_cte", "store_cte", "joined", "final_aggregate"],
    "assembly_template": "WITH fact_cte AS (${fact_cte}), date_cte AS (${date_cte}), hd_cte AS (${hd_cte}), cd_cte AS (${cd_cte}), ca_cte AS (${ca_cte}), store_cte AS (${store_cte}), joined AS (${joined}) ${final_aggregate}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_seqscan = off",
    "SET LOCAL work_mem = '16MB'",
    "SET LOCAL effective_cache_size = '4GB'"
  ],
  "validation_checks": []
}
```

**Changes**: Replaced comma-separated implicit joins with explicit CTE-based staged reduction. Each dimension table is pre-filtered in its own CTE before joining with the pre-filtered fact table. The address/profit filter (Set B) is applied in the final join CTE after all dimensions are joined.

**Expected speedup**: 1.8-2.5x due to early filtering of dimension tables and materialization of fact table subset before expensive multi-table joins. The explicit join structure allows better optimization than comma joins.