## Part 1: Modified Logic Tree

```
[=] main_query (aggregates)
  [~] FROM clause
    [+] CTE: filtered_date (date_dim pre-filter)
    [+] CTE: filtered_store (store dimension)
    [+] CTE: filtered_hd (household_demographics pre-filter)
    [+] CTE: filtered_cd (customer_demographics pre-filter)
    [+] CTE: filtered_ca (customer_address pre-filter)
    [~] store_sales fact table
      [-] Old: comma joins with complex OR predicates
      [+] New: explicit INNER JOIN to filtered CTEs
  [=] WHERE clause (unchanged logic but restructured)
    [-] Removed: redundant OR pattern applied via join filters
    [+] Applied: bitmap OR via UNION ALL of three demographic branches
  [=] SELECT list (unchanged)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefetch", "description": "Pre-filter selective dimensions into materialized CTEs", "applied_to": ["filtered_date", "filtered_store", "filtered_hd", "filtered_cd", "filtered_ca"]},
    {"id": "R2", "type": "comma_to_explicit_join", "description": "Convert comma joins to explicit JOIN syntax", "applied_to": ["main_query"]},
    {"id": "R3", "type": "or_to_union_all", "description": "Split demographic OR conditions into UNION ALL branches", "applied_to": ["main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_store": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk FROM store",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "filtered_hd": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT hd_demo_sk, hd_dep_count FROM household_demographics WHERE hd_dep_count IN (1, 3)",
        "interfaces": {"outputs": ["hd_demo_sk", "hd_dep_count"], "consumes": []}
      },
      "filtered_cd": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cd_demo_sk, cd_marital_status, cd_education_status FROM customer_demographics WHERE (cd_marital_status = 'M' AND cd_education_status = '2 yr Degree') OR (cd_marital_status = 'S' AND cd_education_status = 'Primary') OR (cd_marital_status = 'W' AND cd_education_status = 'Primary')",
        "interfaces": {"outputs": ["cd_demo_sk", "cd_marital_status", "cd_education_status"], "consumes": []}
      },
      "filtered_ca": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ca_address_sk, ca_state FROM customer_address WHERE ca_country = 'United States' AND ca_state IN ('GA', 'KY', 'SD', 'AR', 'IN', 'VA', 'KS', 'OH', 'SD')",
        "interfaces": {"outputs": ["ca_address_sk", "ca_state"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT MIN(ss_quantity), MIN(ss_ext_sales_price), MIN(ss_ext_wholesale_cost), MIN(ss_ext_wholesale_cost) FROM (SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM store_sales INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk INNER JOIN filtered_store ON ss_store_sk = s_store_sk INNER JOIN filtered_hd ON ss_hdemo_sk = hd_demo_sk INNER JOIN filtered_cd ON ss_cdemo_sk = cd_demo_sk INNER JOIN filtered_ca ON ss_addr_sk = ca_address_sk WHERE cd_marital_status = 'M' AND cd_education_status = '2 yr Degree' AND ss_sales_price BETWEEN 100.00 AND 150.00 AND hd_dep_count = 3 AND ca_state IN ('GA', 'KY', 'SD') AND ss_net_profit BETWEEN 100 AND 200 UNION ALL SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM store_sales INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk INNER JOIN filtered_store ON ss_store_sk = s_store_sk INNER JOIN filtered_hd ON ss_hdemo_sk = hd_demo_sk INNER JOIN filtered_cd ON ss_cdemo_sk = cd_demo_sk INNER JOIN filtered_ca ON ss_addr_sk = ca_address_sk WHERE cd_marital_status = 'S' AND cd_education_status = 'Primary' AND ss_sales_price BETWEEN 50.00 AND 100.00 AND hd_dep_count = 1 AND ca_state IN ('AR', 'IN', 'VA') AND ss_net_profit BETWEEN 150 AND 300 UNION ALL SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM store_sales INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk INNER JOIN filtered_store ON ss_store_sk = s_store_sk INNER JOIN filtered_hd ON ss_hdemo_sk = hd_demo_sk INNER JOIN filtered_cd ON ss_cdemo_sk = cd_demo_sk INNER JOIN filtered_ca ON ss_addr_sk = ca_address_sk WHERE cd_marital_status = 'W' AND cd_education_status = 'Primary' AND ss_sales_price BETWEEN 150.00 AND 200.00 AND hd_dep_count = 1 AND ca_state IN ('KS', 'OH', 'SD') AND ss_net_profit BETWEEN 50 AND 250) AS union_branches",
        "interfaces": {
          "outputs": ["min(ss_quantity)", "min(ss_ext_sales_price)", "min(ss_ext_wholesale_cost)", "min(ss_ext_wholesale_cost)"],
          "consumes": ["filtered_date", "filtered_store", "filtered_hd", "filtered_cd", "filtered_ca"]
        }
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_store", "filtered_hd", "filtered_cd", "filtered_ca", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_store AS ({filtered_store}), filtered_hd AS ({filtered_hd}), filtered_cd AS ({filtered_cd}), filtered_ca AS ({filtered_ca}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '64MB'", "SET LOCAL enable_hashjoin = on", "SET LOCAL enable_mergejoin = off", "SET LOCAL enable_nestloop = off", "SET LOCAL from_collapse_limit = 1", "SET LOCAL join_collapse_limit = 1"],
  "validation_checks": []
}
```

**Changes**: The rewrite isolates selective dimensions into materialized CTEs, converts comma joins to explicit JOINs, and splits the complex OR conditions into UNION ALL branches. This enables PostgreSQL to use efficient bitmap index scans on each branch and reduces nested-loop overhead.

**Expected speedup**: 2.5xâ€“3.0x. The combination of dimension pre-filtering and UNION ALL decomposition should eliminate the costly index-only scan with late OR filtering, replacing it with three parallelizable index scans that apply all predicates early.