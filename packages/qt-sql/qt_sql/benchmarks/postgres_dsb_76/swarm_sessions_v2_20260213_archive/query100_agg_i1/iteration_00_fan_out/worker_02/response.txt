### Part 1: Modified Logic Tree

```plaintext
QUERY: (single statement)
├── [=] date_filtered
├── [=] item1_filtered
├── [=] item2_filtered
├── [=] custdemo_filtered
├── [=] customer_filtered
├── [=] sales1_filtered
├── [=] sales2_filtered
└── [~] main_query
    ├── CTE WITH date_filtered, item1_filtered, item2_filtered, custdemo_filtered, customer_filtered, sales1_filtered, sales2_filtered
    ├── JOIN (sales1_filtered.ss_ticket_number = sales2_filtered.ss_ticket_number)
    ├── JOIN (sales1_filtered.item1_sk < sales2_filtered.item2_sk)
    ├── JOIN (customer_address.ca_address_sk = sales1_filtered.c_current_addr_sk)
    ├── AGG (GROUP BY sales1_filtered.item1_sk, sales2_filtered.item2_sk)
    ├── SORT (cnt ASC)
    └── OUTPUT (item1_sk, item2_sk, cnt)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_decomposition",
      "description": "Decompose implicit multi-table join into explicit CTE chain following target logical tree",
      "applied_to": ["date_filtered", "item1_filtered", "item2_filtered", "custdemo_filtered", "customer_filtered", "sales1_filtered", "sales2_filtered"]
    },
    {
      "id": "R2",
      "type": "explicit_join_conversion",
      "description": "Convert comma joins to explicit INNER JOIN syntax",
      "applied_to": ["sales1_filtered", "sales2_filtered", "customer_filtered", "final_join"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year BETWEEN 1998 AND 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "item1_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Electronics', 'Jewelry')",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "item2_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk FROM item WHERE i_manager_id BETWEEN 81 AND 100",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "custdemo_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'S' AND cd_education_status = 'College'",
        "interfaces": {"outputs": ["cd_demo_sk"], "consumes": []}
      },
      "customer_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_customer_sk, c_current_addr_sk FROM customer INNER JOIN custdemo_filtered ON c_current_cdemo_sk = cd_demo_sk",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": ["custdemo_filtered"]}
      },
      "sales1_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s1.ss_ticket_number, s1.ss_item_sk AS item1_sk, customer_filtered.c_current_addr_sk FROM store_sales s1 INNER JOIN date_filtered ON s1.ss_sold_date_sk = date_filtered.d_date_sk INNER JOIN item1_filtered ON s1.ss_item_sk = item1_filtered.i_item_sk INNER JOIN customer_filtered ON s1.ss_customer_sk = customer_filtered.c_customer_sk WHERE s1.ss_list_price BETWEEN 108 AND 122",
        "interfaces": {"outputs": ["ss_ticket_number", "item1_sk", "c_current_addr_sk"], "consumes": ["date_filtered", "item1_filtered", "customer_filtered"]}
      },
      "sales2_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s2.ss_ticket_number, s2.ss_item_sk AS item2_sk FROM store_sales s2 INNER JOIN item2_filtered ON s2.ss_item_sk = item2_filtered.i_item_sk WHERE s2.ss_list_price BETWEEN 108 AND 122",
        "interfaces": {"outputs": ["ss_ticket_number", "item2_sk"], "consumes": ["item2_filtered"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT sales1_filtered.item1_sk, sales2_filtered.item2_sk, COUNT(*) AS cnt FROM sales1_filtered INNER JOIN sales2_filtered ON sales1_filtered.ss_ticket_number = sales2_filtered.ss_ticket_number AND sales1_filtered.item1_sk < sales2_filtered.item2_sk INNER JOIN customer_address ON customer_address.ca_address_sk = sales1_filtered.c_current_addr_sk GROUP BY sales1_filtered.item1_sk, sales2_filtered.item2_sk ORDER BY cnt",
        "interfaces": {"outputs": ["item1_sk", "item2_sk", "cnt"], "consumes": ["sales1_filtered", "sales2_filtered"]}
      }
    },
    "reconstruction_order": ["date_filtered", "item1_filtered", "item2_filtered", "custdemo_filtered", "customer_filtered", "sales1_filtered", "sales2_filtered", "main_query"],
    "assembly_template": "WITH date_filtered AS ({date_filtered}), item1_filtered AS ({item1_filtered}), item2_filtered AS ({item2_filtered}), custdemo_filtered AS ({custdemo_filtered}), customer_filtered AS ({customer_filtered}), sales1_filtered AS ({sales1_filtered}), sales2_filtered AS ({sales2_filtered}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

### Changes
Structural change: Decomposed original implicit multi-table join into explicit CTE chain following target logical tree, converting comma joins to explicit INNER JOIN syntax. Expected mechanism: Pre-filtering selective dimensions (date, item categories, customer demographics) into small hash tables enables PostgreSQL to plan efficient hash joins and better cardinality estimates. CTE materialization may prevent parallel scans but was mandated by the logical tree; explicit joins within CTEs still allow predicate pushdown.

Expected speedup: Moderate (2-3x) due to better join order control and reduced intermediate result sizes from early filtering.