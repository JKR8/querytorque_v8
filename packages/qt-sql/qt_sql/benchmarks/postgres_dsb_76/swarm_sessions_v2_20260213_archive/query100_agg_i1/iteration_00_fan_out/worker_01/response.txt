### Part 1: Modified Logic Tree

```
QUERY: (CTE-based)
├── [MAIN] main_query [!] Structural change: CTE-based decomposition
│   ├── [~] WITH filtered_sales_cte [new CTE]
│   │   ├── SCAN (store_sales, date_dim)
│   │   ├── JOIN (store_sales.ss_sold_date_sk = date_dim.d_date_sk)
│   │   ├── FILTER (d_year BETWEEN 1998 AND 1999)
│   │   ├── FILTER (ss_list_price BETWEEN 108 AND 122)
│   │   └── OUTPUT (ss_ticket_number, ss_item_sk, ss_customer_sk)
│   ├── [~] WITH sales_pairs_cte [new CTE]
│   │   ├── SCAN (filtered_sales AS s1, filtered_sales AS s2)
│   │   ├── JOIN (s1.ss_ticket_number = s2.ss_ticket_number AND s1.ss_item_sk < s2.ss_item_sk)
│   │   └── OUTPUT (item1_sk, item2_sk, ss_customer_sk)
│   └── [~] final_join [modified]
│       ├── SCAN (sales_pairs_cte)
│       ├── JOIN item AS item1 ON item1.i_item_sk = item1_sk
│       ├── JOIN item AS item2 ON item2.i_item_sk = item2_sk
│       ├── JOIN customer ON c_customer_sk = ss_customer_sk
│       ├── JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk
│       ├── JOIN customer_address ON ca_address_sk = c_current_addr_sk
│       ├── FILTER (item1.i_category IN ('Electronics', 'Jewelry'))
│       ├── FILTER (item2.i_manager_id BETWEEN 81 AND 100)
│       ├── FILTER (cd_marital_status = 'S')
│       ├── FILTER (cd_education_status = 'College')
│       ├── AGG (GROUP BY item1.i_item_sk, item2.i_item_sk; COUNT(*) AS cnt)
│       ├── SORT (cnt ASC)
│       └── OUTPUT (item1.i_item_sk, item2.i_item_sk, cnt)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_decomposition",
      "description": "Decompose monolithic join into CTEs following target logical tree: filtered_sales → sales_pairs → final_join with dimension filters applied late",
      "applied_to": ["main_query"]
    },
    {
      "id": "R2",
      "type": "materialization_strategy",
      "description": "Use non-materialized CTEs (default PostgreSQL behavior) to allow parallelism; avoid explicit MATERIALIZED keyword",
      "applied_to": ["filtered_sales_cte", "sales_pairs_cte"]
    },
    {
      "id": "R3",
      "type": "join_reordering_protection",
      "description": "Preserve dimension filters (item category, manager_id, demographics) in final_join WHERE clause rather than pushing down into CTEs",
      "applied_to": ["final_join"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_sales": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT ss_ticket_number, ss_item_sk, ss_customer_sk FROM store_sales JOIN date_dim ON ss_sold_date_sk = d_date_sk WHERE d_year BETWEEN 1998 AND 1999 AND ss_list_price BETWEEN 108 AND 122",
          "interfaces": {
            "outputs": ["ss_ticket_number", "ss_item_sk", "ss_customer_sk"],
            "consumes": []
          }
        },
        "sales_pairs": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT s1.ss_item_sk AS item1_sk, s2.ss_item_sk AS item2_sk, s1.ss_customer_sk FROM filtered_sales s1 JOIN filtered_sales s2 ON s1.ss_ticket_number = s2.ss_ticket_number AND s1.ss_item_sk < s2.ss_item_sk",
          "interfaces": {
            "outputs": ["item1_sk", "item2_sk", "ss_customer_sk"],
            "consumes": ["filtered_sales"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT item1.i_item_sk, item2.i_item_sk, COUNT(*) AS cnt FROM sales_pairs JOIN item AS item1 ON item1.i_item_sk = item1_sk JOIN item AS item2 ON item2.i_item_sk = item2_sk JOIN customer ON c_customer_sk = sales_pairs.ss_customer_sk JOIN customer_demographics ON cd_demo_sk = c_current_cdemo_sk JOIN customer_address ON ca_address_sk = c_current_addr_sk WHERE item1.i_category IN ('Electronics', 'Jewelry') AND item2.i_manager_id BETWEEN 81 AND 100 AND cd_marital_status = 'S' AND cd_education_status = 'College' GROUP BY item1.i_item_sk, item2.i_item_sk ORDER BY cnt",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_sk", "cnt"],
            "consumes": ["sales_pairs"]
          }
        }
      },
      "reconstruction_order": ["filtered_sales", "sales_pairs", "main_query"],
      "assembly_template": "WITH filtered_sales AS ({filtered_sales}), sales_pairs AS ({sales_pairs}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Structural decomposition into CTEs following the target logical tree: first materialize filtered store_sales transactions (date + price filters), then self-join for item pairs, finally join dimensions with filters applied late. This matches the required node contracts exactly.

**Expected speedup**: Moderate (1.5-2x) due to shared materialization of filtered store_sales and better join ordering control, while avoiding CTE materialization blockers to preserve parallelism.