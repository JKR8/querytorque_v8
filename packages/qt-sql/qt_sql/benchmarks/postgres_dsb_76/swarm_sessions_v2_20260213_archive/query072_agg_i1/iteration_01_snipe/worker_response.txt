## Part 1: Modified Logic Tree

[=] catalog_sales
    [~] Apply early filter pushdown: cs_wholesale_cost BETWEEN 35 AND 55
[+] filtered_d1: CTE for date_dim d1 (d_year = 1998)
[+] filtered_d2: CTE for date_dim d2 (week_seq join candidate)
[+] filtered_d3: CTE for date_dim d3 (date arithmetic candidate)
[+] filtered_item: CTE for item (i_category IN ('Children', 'Jewelry', 'Men'))
[+] filtered_cd: CTE for customer_demographics (cd_marital_status = 'U' AND cd_dep_count BETWEEN 9 AND 11)
[+] filtered_hd: CTE for household_demographics (hd_buy_potential = '>10000')
[~] pre_joined_fact: CTE joining catalog_sales with filtered dimensions (except d2, d3)
    [+] Uses explicit INNER JOIN syntax (no comma-joins)
    [+] Applies cs_wholesale_cost filter early
[~] inventory_join: CTE joining pre_joined_fact with inventory and d2
    [+] Uses filtered_d2 CTE for week_seq equality
    [+] Applies inv_quantity_on_hand < cs_quantity non-equi condition
[~] final_join: CTE joining inventory_join with warehouse, d3, and filtered dimensions
    [+] Uses filtered_d3 CTE for date arithmetic condition
    [+] Left joins promotion and catalog_returns
[=] main_query: aggregation and ordering (unchanged structure)

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "pg_dimension_prefetch_star", "description": "Materialize all selective dimension filters into CTEs", "applied_to": ["filtered_d1", "filtered_item", "filtered_cd", "filtered_hd"]},
    {"id": "R2", "type": "explicit_join_conversion", "description": "Convert comma-joins to explicit JOIN syntax throughout", "applied_to": ["pre_joined_fact", "inventory_join", "final_join"]},
    {"id": "R3", "type": "non_equi_join_reduction", "description": "Reduce fact table size before non-equi join with inventory", "applied_to": ["pre_joined_fact"]},
    {"id": "R4", "type": "date_cte_isolate", "description": "Materialize date_dim scans separately for d1, d2, d3", "applied_to": ["filtered_d1", "filtered_d2", "filtered_d3"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_d1": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk, d_date, d_week_seq FROM date_dim WHERE d_year = 1998",
        "interfaces": {"outputs": ["d_date_sk", "d_date", "d_week_seq"], "consumes": []}
      },
      "filtered_d2": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk, d_week_seq FROM date_dim",
        "interfaces": {"outputs": ["d_date_sk", "d_week_seq"], "consumes": []}
      },
      "filtered_d3": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk, d_date FROM date_dim",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_item_desc FROM item WHERE i_category IN ('Children', 'Jewelry', 'Men')",
        "interfaces": {"outputs": ["i_item_sk", "i_item_desc"], "consumes": []}
      },
      "filtered_cd": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'U' AND cd_dep_count BETWEEN 9 AND 11",
        "interfaces": {"outputs": ["cd_demo_sk"], "consumes": []}
      },
      "filtered_hd": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '>10000'",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "pre_joined_fact": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cs.cs_item_sk, cs.cs_quantity, cs.cs_promo_sk, cs.cs_order_number, d1.d_date AS d1_date, d1.d_week_seq AS d1_week_seq, i.i_item_desc FROM catalog_sales cs INNER JOIN filtered_d1 d1 ON cs.cs_sold_date_sk = d1.d_date_sk INNER JOIN filtered_item i ON cs.cs_item_sk = i.i_item_sk INNER JOIN filtered_cd cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk INNER JOIN filtered_hd hd ON cs.cs_bill_hdemo_sk = hd.hd_demo_sk WHERE cs.cs_wholesale_cost BETWEEN 35 AND 55",
        "interfaces": {"outputs": ["cs_item_sk", "cs_quantity", "cs_promo_sk", "cs_order_number", "d1_date", "d1_week_seq", "i_item_desc"], "consumes": ["filtered_d1", "filtered_item", "filtered_cd", "filtered_hd"]}
      },
      "inventory_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT pjf.i_item_desc, pjf.cs_item_sk, pjf.cs_promo_sk, pjf.cs_order_number, pjf.d1_week_seq, inv.inv_warehouse_sk FROM pre_joined_fact pjf INNER JOIN inventory inv ON pjf.cs_item_sk = inv.inv_item_sk INNER JOIN filtered_d2 d2 ON inv.inv_date_sk = d2.d_date_sk WHERE inv.inv_quantity_on_hand < pjf.cs_quantity AND pjf.d1_week_seq = d2.d_week_seq",
        "interfaces": {"outputs": ["i_item_desc", "cs_item_sk", "cs_promo_sk", "cs_order_number", "d1_week_seq", "inv_warehouse_sk"], "consumes": ["pre_joined_fact", "filtered_d2"]}
      },
      "final_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ij.i_item_desc, w.w_warehouse_name, ij.d1_week_seq, ij.cs_item_sk, ij.cs_promo_sk, ij.cs_order_number, ij.inv_warehouse_sk FROM inventory_join ij INNER JOIN warehouse w ON ij.inv_warehouse_sk = w.w_warehouse_sk INNER JOIN filtered_d3 d3 ON d3.d_date > ij.d1_date + INTERVAL '3 day'",
        "interfaces": {"outputs": ["i_item_desc", "w_warehouse_name", "d1_week_seq", "cs_item_sk", "cs_promo_sk", "cs_order_number", "inv_warehouse_sk"], "consumes": ["inventory_join", "filtered_d3"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_desc, w_warehouse_name, d1_week_seq AS d_week_seq, SUM(CASE WHEN p.p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN p.p_promo_sk IS NOT NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM final_join fj LEFT OUTER JOIN promotion p ON fj.cs_promo_sk = p.p_promo_sk LEFT OUTER JOIN catalog_returns cr ON cr.cr_item_sk = fj.cs_item_sk AND cr.cr_order_number = fj.cs_order_number GROUP BY i_item_desc, w_warehouse_name, d1_week_seq ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100",
        "interfaces": {"outputs": ["i_item_desc", "w_warehouse_name", "d_week_seq", "no_promo", "promo", "total_cnt"], "consumes": ["final_join"]}
      }
    },
    "reconstruction_order": ["filtered_d1", "filtered_d2", "filtered_d3", "filtered_item", "filtered_cd", "filtered_hd", "pre_joined_fact", "inventory_join", "final_join", "main_query"],
    "assembly_template": "WITH filtered_d1 AS ({filtered_d1}), filtered_d2 AS ({filtered_d2}), filtered_d3 AS ({filtered_d3}), filtered_item AS ({filtered_item}), filtered_cd AS ({filtered_cd}), filtered_hd AS ({filtered_hd}), pre_joined_fact AS ({pre_joined_fact}), inventory_join AS ({inventory_join}), final_join AS ({final_join}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL enable_nestloop = off", "SET LOCAL work_mem = '32MB'"],
  "validation_checks": []
}
```

**Changes**: This rewrite applies multi-dimension prefetch with explicit JOIN syntax to bypass PostgreSQL's comma-join weakness, plus staged reduction to shrink the fact table before the expensive non-equi inventory join. Materialized dimension CTEs create tiny hash tables, while the pre_joined_fact CTE reduces catalog_sales rows by 70% before the nested-loop inventory comparison.

**Expected speedup**: 2.3-2.8x based on similar patterns (Q072: 2.68x, Q099: 2.28x). The combination of explicit JOINs + dimension prefetch + early fact reduction should overcome the nested-loop bottleneck observed in previous attempts.