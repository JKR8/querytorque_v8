## Logic Tree Changes

```
[~] filtered_fact → rewritten to join store and customer_address early
    |- Uses explicit JOIN syntax (not comma joins)
    |- Filters on ca_state = 'KS' and ss_wholesale_cost BETWEEN 76 AND 96
    |- Applies substring(ca_zip,1,5) <> substring(s_zip,1,5) as early as possible
    |- Preserves all required columns for final aggregation

[+] store_filtered → new CTE to pre-filter store table
    |- SELECT s_store_sk, s_zip FROM store

[+] address_filtered → new CTE to pre-filter customer_address table  
    |- SELECT ca_address_sk, ca_zip FROM customer_address WHERE ca_state = 'KS'

[~] main_query → simplified aggregation over filtered_fact results
    |- Directly aggregates from filtered_fact CTE
    |- Maintains same GROUP BY and ORDER BY clauses
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "explicit_join_conversion",
      "description": "Convert comma-separated FROM clause to explicit JOIN...ON syntax",
      "applied_to": ["filtered_fact"]
    },
    {
      "id": "R2", 
      "type": "dimension_prefetch",
      "description": "Pre-filter store and customer_address tables into CTEs to create tiny hash tables",
      "applied_to": ["store_filtered", "address_filtered"]
    },
    {
      "id": "R3",
      "type": "non_equi_join_early_filter",
      "description": "Apply zip mismatch filter as early as possible in the join sequence",
      "applied_to": ["filtered_fact"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "store_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk, s_zip FROM store",
        "interfaces": {"outputs": ["s_store_sk", "s_zip"], "consumes": []}
      },
      "address_filtered": {
        "type": "cte", 
        "change": "new",
        "sql": "SELECT ca_address_sk, ca_zip FROM customer_address WHERE ca_state = 'KS'",
        "interfaces": {"outputs": ["ca_address_sk", "ca_zip"], "consumes": []}
      },
      "filtered_fact": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT ss_ext_sales_price, i_brand_id, i_brand, i_manufact_id, i_manufact FROM store_sales INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_year = 1999 AND d_moy = 2 INNER JOIN item ON ss_item_sk = i_item_sk AND i_category = 'Shoes' INNER JOIN customer ON ss_customer_sk = c_customer_sk AND c_birth_month = 2 INNER JOIN address_filtered ON c_current_addr_sk = ca_address_sk INNER JOIN store_filtered ON ss_store_sk = s_store_sk WHERE ss_wholesale_cost BETWEEN 76 AND 96 AND substring(ca_zip,1,5) <> substring(s_zip,1,5)",
        "interfaces": {
          "outputs": ["ss_ext_sales_price", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact"],
          "consumes": ["store_filtered", "address_filtered"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, i_manufact_id, i_manufact, SUM(ss_ext_sales_price) AS ext_price FROM filtered_fact GROUP BY i_brand, i_brand_id, i_manufact_id, i_manufact ORDER BY ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact LIMIT 100",
        "interfaces": {
          "outputs": ["brand_id", "brand", "i_manufact_id", "i_manufact", "ext_price"],
          "consumes": ["filtered_fact"]
        }
      }
    },
    "reconstruction_order": ["store_filtered", "address_filtered", "filtered_fact", "main_query"],
    "assembly_template": "WITH store_filtered AS ({store_filtered}), address_filtered AS ({address_filtered}), filtered_fact AS ({filtered_fact}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '256MB'",
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL max_parallel_workers_per_gather = 4"
  ],
  "validation_checks": []
}
```

**Changes**: Converted comma-joins to explicit JOIN syntax, prefetched dimension tables (store and customer_address) into CTEs to create tiny hash tables, and applied the zip mismatch filter as early as possible in the join sequence. This allows PostgreSQL to use hash joins with small dimension tables and avoid the nested-loop penalty for the non-equi zip condition.

**Expected speedup**: 2.5-3.0x by eliminating nested-loop overhead, enabling parallel hash joins, and reducing the working set before the final aggregation.