## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]
    ├── [~] filtered_dates  [NEW CTE]
    │   └── SCAN date_dim
    ├── [~] filtered_items  [NEW CTE]
    │   └── SCAN item
    ├── [~] sales_consolidated  [NEW CTE]
    │   ├── UNION ALL
    │   │   ├── store_sales with EXISTS filtered_dates, filtered_items
    │   │   ├── web_sales with EXISTS filtered_dates, filtered_items
    │   │   └── catalog_sales with EXISTS filtered_dates, filtered_items
    │   └── price ratio filter (65-75%)
    ├── [~] customer_base  [NEW CTE]
    │   ├── INNER JOIN customer, customer_address, customer_demographics
    │   ├── INNER JOIN sales_consolidated
    │   └── county, birth_month, demographics filters
    └── [~] final_aggregation  [MAIN]
        ├── GROUP BY 8 demographics
        ├── COUNT(*) x6 aggregates
        └── ORDER BY 8 demographics, LIMIT 100
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_materialization",
      "description": "Factor out date_dim and item filters into CTEs to avoid repeated subqueries",
      "applied_to": ["filtered_dates", "filtered_items"]
    },
    {
      "id": "R2", 
      "type": "union_consolidation",
      "description": "Consolidate three sales channel queries with UNION ALL instead of complex OR/EXISTS",
      "applied_to": ["sales_consolidated"]
    },
    {
      "id": "R3",
      "type": "join_decomposition",
      "description": "Separate customer join graph into explicit CTE for better optimization boundaries",
      "applied_to": ["customer_base"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy BETWEEN 5 AND 8",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_items": {
        "type": "cte",
        "change": "added", 
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Children', 'Home', 'Women') AND i_manager_id BETWEEN 91 AND 100",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "sales_consolidated": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_customer_sk AS customer_sk FROM store_sales ss WHERE EXISTS (SELECT 1 FROM filtered_dates fd WHERE ss.ss_sold_date_sk = fd.d_date_sk) AND EXISTS (SELECT 1 FROM filtered_items fi WHERE ss.ss_item_sk = fi.i_item_sk) AND ss.ss_sales_price / ss.ss_list_price BETWEEN 0.65 AND 0.75 UNION ALL SELECT ws_bill_customer_sk AS customer_sk FROM web_sales ws WHERE EXISTS (SELECT 1 FROM filtered_dates fd WHERE ws.ws_sold_date_sk = fd.d_date_sk) AND EXISTS (SELECT 1 FROM filtered_items fi WHERE ws.ws_item_sk = fi.i_item_sk) AND ws.ws_sales_price / ws.ws_list_price BETWEEN 0.65 AND 0.75 UNION ALL SELECT cs_ship_customer_sk AS customer_sk FROM catalog_sales cs WHERE EXISTS (SELECT 1 FROM filtered_dates fd WHERE cs.cs_sold_date_sk = fd.d_date_sk) AND EXISTS (SELECT 1 FROM filtered_items fi WHERE cs.cs_item_sk = fi.i_item_sk) AND cs.cs_sales_price / cs.cs_list_price BETWEEN 0.65 AND 0.75",
        "interfaces": {"outputs": ["customer_sk"], "consumes": ["filtered_dates", "filtered_items"]}
      },
      "customer_base": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cd.cd_gender, cd.cd_marital_status, cd.cd_education_status, cd.cd_purchase_estimate, cd.cd_credit_rating, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM customer c INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk INNER JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk INNER JOIN sales_consolidated sc ON c.c_customer_sk = sc.customer_sk WHERE ca.ca_county IN ('Alameda County', 'Lexington city', 'Pender County', 'Petroleum County', 'Walworth County') AND c.c_birth_month IN (4, 5) AND cd.cd_marital_status IN ('U', 'S', 'U') AND cd.cd_education_status IN ('College', 'Secondary', 'College') AND cd.cd_gender = 'M'",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"], "consumes": ["sales_consolidated"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3, cd_dep_count, COUNT(*) AS cnt4, cd_dep_employed_count, COUNT(*) AS cnt5, cd_dep_college_count, COUNT(*) AS cnt6 FROM customer_base GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating, cd_dep_count, cd_dep_employed_count, cd_dep_college_count ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3", "cd_dep_count", "cnt4", "cd_dep_employed_count", "cnt5", "cd_dep_college_count", "cnt6"], "consumes": ["customer_base"]}
      }
    },
    "reconstruction_order": ["filtered_dates", "filtered_items", "sales_consolidated", "customer_base", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), filtered_items AS ({filtered_items}), sales_consolidated AS ({sales_consolidated}), customer_base AS ({customer_base}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL enable_mergejoin = off", 
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL hash_mem_multiplier = 2.0",
    "SET LOCAL max_parallel_workers_per_gather = 2"
  ],
  "validation_checks": []
}
```

**Changes:** Restructured query into explicit CTE pipeline per target logical tree: filtered_dates → filtered_items → sales_consolidated → customer_base → final_aggregation. Maintains EXISTS semantics for dimension filters, consolidates three sales channels with UNION ALL, and preserves all original filters and grouping.

**Expected speedup:** 2-3x from eliminating repeated dimension table scans and enabling better join planning. CTE decomposition allows parallel scans of large fact tables (store_sales, web_sales, catalog_sales) while hash joins handle customer graph efficiently.

**Runtime config rationale:**
- `enable_nestloop = off`: Large fact table scans should use hash/merge joins
- `enable_mergejoin = off`: Hash joins preferred for equality predicates
- `enable_hashjoin = on`: Enable hash joins for customer and sales joins  
- `hash_mem_multiplier = 2.0`: Boost hash table memory for customer hash join
- `max_parallel_workers_per_gather = 2`: Allow parallel scans on large sales tables while staying within total 8 worker budget