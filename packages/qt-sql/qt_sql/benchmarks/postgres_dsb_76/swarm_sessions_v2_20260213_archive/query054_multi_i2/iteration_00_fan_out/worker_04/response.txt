## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_dim_cte  [+]  (new)
│   ├── SCAN (date_dim)
│   ├── FILTER (d_year = 1998 AND d_moy = 5)
│   └── OUTPUT (d_date_sk, d_month_seq)
├── [CTE] item_cte  [+]  (new)
│   ├── SCAN (item)
│   ├── FILTER (i_category = 'Home' AND i_class = 'curtains/drapes')
│   └── OUTPUT (i_item_sk)
├── [CTE] customer_cte  [+]  (new)
│   ├── SCAN (customer)
│   ├── FILTER (c_birth_year BETWEEN 1942 AND 1955)
│   └── OUTPUT (c_customer_sk, c_current_addr_sk)
├── [CTE] sales_union  [+]  (new)
│   ├── UNION ALL
│   │   ├── JOIN (catalog_sales ⋈ date_dim_cte ⋈ item_cte ⋈ customer_cte)
│   │   ├── FILTER (cs_wholesale_cost BETWEEN 70 AND 100)
│   │   └── OUTPUT (cs_bill_customer_sk as customer_sk)
│   │   ├── JOIN (web_sales ⋈ date_dim_cte ⋈ item_cte ⋈ customer_cte)
│   │   ├── FILTER (ws_wholesale_cost BETWEEN 70 AND 100)
│   │   └── OUTPUT (ws_bill_customer_sk as customer_sk)
│   └── OUTPUT (customer_sk)
├── [CTE] my_customers  [~]  (modified: uses sales_union + subquery)
│   ├── SCAN (sales_union)
│   ├── PROJECT (DISTINCT customer_sk, correlated subquery for address)
│   └── OUTPUT (c_customer_sk, c_current_addr_sk)
├── [CTE] month_seq_cte  [+]  (new)
│   ├── SCAN (date_dim_cte)
│   ├── PROJECT (d_month_seq+1, d_month_seq+3)
│   └── OUTPUT (month_seq_start, month_seq_end)
├── [CTE] my_revenue  [~]  (modified: uses explicit joins + month_seq_cte)
│   ├── SCAN (my_customers)
│   ├── JOIN (customer_address ON c_current_addr_sk = ca_address_sk)
│   ├── JOIN (store ON ca_county = s_county AND ca_state = s_state)
│   ├── JOIN (store_sales ON c_customer_sk = ss_customer_sk)
│   ├── JOIN (date_dim ON ss_sold_date_sk = d_date_sk)
│   ├── CROSS JOIN (month_seq_cte)
│   ├── FILTER (ss_wholesale_cost BETWEEN 70 AND 100)
│   ├── FILTER (s_state IN list)
│   ├── FILTER (d_month_seq BETWEEN month_seq_start AND month_seq_end)
│   ├── AGG (GROUP BY c_customer_sk)
│   └── OUTPUT (c_customer_sk, revenue)
├── [CTE] segments  [=]  (unchanged)
│   ├── SCAN (my_revenue)
│   └── OUTPUT (segment)
└── [MAIN] main_query  [=]  (unchanged)
    ├── SCAN (segments)
    ├── AGG (GROUP BY segment)
    ├── SORT (segment ASC, num_customers ASC)
    └── OUTPUT (segment, num_customers, segment_base)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "multi_dimension_prefetch",
      "description": "Extract selective dimension filters (date_dim, item, customer) into separate CTEs for early filtering and reuse",
      "applied_to": ["date_dim_cte", "item_cte", "customer_cte"]
    },
    {
      "id": "R2",
      "type": "shared_dimension_multi_channel",
      "description": "Share pre-filtered dimension CTEs across both catalog_sales and web_sales UNION branches",
      "applied_to": ["sales_union"]
    },
    {
      "id": "R3",
      "type": "correlated_subquery_elimination",
      "description": "Replace correlated date range subqueries with month_seq_cte CTE and explicit CROSS JOIN",
      "applied_to": ["month_seq_cte", "my_revenue"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "date_dim_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT d_date_sk, d_month_seq FROM date_dim WHERE d_year = 1998 AND d_moy = 5",
          "interfaces": {
            "outputs": ["d_date_sk", "d_month_seq"],
            "consumes": []
          }
        },
        "item_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i_item_sk FROM item WHERE i_category = 'Home' AND i_class = 'curtains/drapes'",
          "interfaces": {
            "outputs": ["i_item_sk"],
            "consumes": []
          }
        },
        "customer_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT c_customer_sk, c_current_addr_sk FROM customer WHERE c_birth_year BETWEEN 1942 AND 1955",
          "interfaces": {
            "outputs": ["c_customer_sk", "c_current_addr_sk"],
            "consumes": []
          }
        },
        "sales_union": {
          "type": "cte",
          "change": "modified",
          "sql": "(SELECT cs_bill_customer_sk AS customer_sk FROM catalog_sales INNER JOIN date_dim_cte ON cs_sold_date_sk = date_dim_cte.d_date_sk INNER JOIN item_cte ON cs_item_sk = item_cte.i_item_sk INNER JOIN customer_cte ON cs_bill_customer_sk = customer_cte.c_customer_sk WHERE cs_wholesale_cost BETWEEN 70 AND 100) UNION ALL (SELECT ws_bill_customer_sk AS customer_sk FROM web_sales INNER JOIN date_dim_cte ON ws_sold_date_sk = date_dim_cte.d_date_sk INNER JOIN item_cte ON ws_item_sk = item_cte.i_item_sk INNER JOIN customer_cte ON ws_bill_customer_sk = customer_cte.c_customer_sk WHERE ws_wholesale_cost BETWEEN 70 AND 100)",
          "interfaces": {
            "outputs": ["customer_sk"],
            "consumes": ["date_dim_cte", "item_cte", "customer_cte"]
          }
        },
        "my_customers": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT DISTINCT customer_sk AS c_customer_sk, (SELECT c_current_addr_sk FROM customer_cte WHERE c_customer_sk = sales_union.customer_sk) AS c_current_addr_sk FROM sales_union",
          "interfaces": {
            "outputs": ["c_customer_sk", "c_current_addr_sk"],
            "consumes": ["sales_union", "customer_cte"]
          }
        },
        "month_seq_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT d_month_seq + 1 AS month_seq_start, d_month_seq + 3 AS month_seq_end FROM date_dim_cte",
          "interfaces": {
            "outputs": ["month_seq_start", "month_seq_end"],
            "consumes": ["date_dim_cte"]
          }
        },
        "my_revenue": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT my_customers.c_customer_sk, SUM(ss_ext_sales_price) AS revenue FROM my_customers INNER JOIN customer_address ON my_customers.c_current_addr_sk = customer_address.ca_address_sk INNER JOIN store ON customer_address.ca_county = store.s_county AND customer_address.ca_state = store.s_state INNER JOIN store_sales ON my_customers.c_customer_sk = store_sales.ss_customer_sk INNER JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk CROSS JOIN month_seq_cte WHERE store_sales.ss_wholesale_cost BETWEEN 70 AND 100 AND store.s_state IN ('AR','GA','IN','KS','KY','NC','OH','PA','SD','VA') AND date_dim.d_month_seq BETWEEN month_seq_cte.month_seq_start AND month_seq_cte.month_seq_end GROUP BY my_customers.c_customer_sk",
          "interfaces": {
            "outputs": ["c_customer_sk", "revenue"],
            "consumes": ["my_customers", "month_seq_cte"]
          }
        },
        "segments": {
          "type": "cte",
          "change": "unchanged",
          "sql": "",
          "interfaces": {
            "outputs": ["segment"],
            "consumes": ["my_revenue"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "unchanged",
          "sql": "",
          "interfaces": {
            "outputs": ["segment", "num_customers", "segment_base"],
            "consumes": ["segments"]
          }
        }
      },
      "reconstruction_order": ["date_dim_cte", "item_cte", "customer_cte", "sales_union", "my_customers", "month_seq_cte", "my_revenue", "segments", "main_query"],
      "assembly_template": "WITH date_dim_cte AS ({date_dim_cte}), item_cte AS ({item_cte}), customer_cte AS ({customer_cte}), sales_union AS ({sales_union}), my_customers AS ({my_customers}), month_seq_cte AS ({month_seq_cte}), my_revenue AS ({my_revenue}), segments AS (SELECT CAST((revenue/50) AS INTEGER) AS segment FROM my_revenue) SELECT segment, COUNT(*) AS num_customers, segment*50 AS segment_base FROM segments GROUP BY segment ORDER BY segment, num_customers LIMIT 100"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Restructured to match target logical tree - pre-filter dimensions into CTEs, share them across UNION branches, replace correlated subqueries with explicit month_seq CTE. Preserves all original filters, defensive guards, and output semantics.

**Expected speedup**: Moderate (1.5-2x) due to early dimension filtering, elimination of correlated subqueries, and better join planning with explicit JOIN syntax.