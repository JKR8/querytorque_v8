### Part 1: Modified Logic Tree

```
QUERY: (WITH CTE chain)
└── [MAIN] main_query
    ├── [~] filtered_d1 [FROM date_dim → CTE]
    ├── [~] filtered_d2 [FROM date_dim → CTE with EXISTS subquery]
    ├── [~] filtered_item [FROM item → CTE]
    ├── [~] filtered_ca [FROM customer_address → CTE]
    ├── [~] filtered_hd [FROM household_demographics → CTE]
    ├── [+] customer_prefilter [NEW CTE: customer JOIN filtered_ca, filtered_hd]
    ├── [~] fact_joins [FROM store_sales with explicit INNER JOINs]
    ├── [~] aggregation [GROUP BY from fact_joins CTE]
    └── [~] sort [ORDER BY cnt from aggregation CTE]
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16.11",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefiltering", "description": "Pre-filter selective dimensions (date, item, customer_address, household_demographics) into CTEs", "applied_to": ["filtered_d1", "filtered_d2", "filtered_item", "filtered_ca", "filtered_hd"]},
    {"id": "R2", "type": "explicit_join_syntax", "description": "Convert comma joins to explicit INNER JOIN syntax with clear join conditions", "applied_to": ["fact_joins"]},
    {"id": "R3", "type": "staged_reduction", "description": "Create customer_prefilter CTE combining filtered customer tables before fact joins", "applied_to": ["customer_prefilter"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_d1": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_year = 2000",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "filtered_d2": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT d2.d_date_sk, d2.d_date FROM date_dim d2 WHERE EXISTS (SELECT 1 FROM filtered_d1 d1 WHERE d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '90 DAY'))",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": ["filtered_d1"]}
      },
      "filtered_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Children', 'Home', 'Women')",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "filtered_ca": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('AR', 'GA', 'IN', 'KY', 'VA')",
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "filtered_hd": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE hd_income_band_sk BETWEEN 8 AND 14 AND hd_buy_potential = '501-1000'",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "customer_prefilter": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, c.c_first_name, c.c_last_name, c.c_current_addr_sk, c.c_current_hdemo_sk FROM customer c INNER JOIN filtered_ca ON c.c_current_addr_sk = filtered_ca.ca_address_sk INNER JOIN filtered_hd ON c.c_current_hdemo_sk = filtered_hd.hd_demo_sk",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "c_current_addr_sk", "c_current_hdemo_sk"], "consumes": ["filtered_ca", "filtered_hd"]}
      },
      "fact_joins": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT customer_prefilter.c_customer_sk, customer_prefilter.c_first_name, customer_prefilter.c_last_name FROM store_sales INNER JOIN store_returns ON store_sales.ss_ticket_number = store_returns.sr_ticket_number AND store_sales.ss_item_sk = store_returns.sr_item_sk INNER JOIN filtered_item ON store_sales.ss_item_sk = filtered_item.i_item_sk INNER JOIN filtered_d1 ON store_returns.sr_returned_date_sk = filtered_d1.d_date_sk INNER JOIN web_sales ON store_returns.sr_item_sk = web_sales.ws_item_sk AND store_sales.ss_customer_sk = web_sales.ws_bill_customer_sk INNER JOIN filtered_d2 ON web_sales.ws_sold_date_sk = filtered_d2.d_date_sk INNER JOIN customer_prefilter ON store_sales.ss_customer_sk = customer_prefilter.c_customer_sk WHERE store_sales.ss_sales_price / store_sales.ss_list_price BETWEEN 76 * 0.01 AND 96 * 0.01",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name"], "consumes": ["filtered_item", "filtered_d1", "filtered_d2", "customer_prefilter"]}
      },
      "aggregation": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_customer_sk, c_first_name, c_last_name, COUNT(*) as cnt FROM fact_joins GROUP BY c_customer_sk, c_first_name, c_last_name",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "cnt"], "consumes": ["fact_joins"]}
      },
      "sort": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_customer_sk, c_first_name, c_last_name, cnt FROM aggregation ORDER BY cnt",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "cnt"], "consumes": ["aggregation"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT * FROM sort",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "cnt"], "consumes": ["sort"]}
      }
    },
    "reconstruction_order": ["filtered_d1", "filtered_d2", "filtered_item", "filtered_ca", "filtered_hd", "customer_prefilter", "fact_joins", "aggregation", "sort", "main_query"],
    "assembly_template": "WITH filtered_d1 AS ({filtered_d1}), filtered_d2 AS ({filtered_d2}), filtered_item AS ({filtered_item}), filtered_ca AS ({filtered_ca}), filtered_hd AS ({filtered_hd}), customer_prefilter AS ({customer_prefilter}), fact_joins AS ({fact_joins}), aggregation AS ({aggregation}), sort AS ({sort}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Restructured original comma-join query into CTEs following target logical tree: pre-filtered selective dimensions (date, item, customer_address, household_demographics), combined customer pre-filter, then explicit INNER JOIN fact joins with preserved division guard. Maintains exact semantic equivalence while enabling optimizer to better estimate cardinalities from small CTE hash tables.

**Expected speedup**: ~2-3x from dimension prefetching and explicit join syntax, avoiding CTE materialization to preserve parallelism.