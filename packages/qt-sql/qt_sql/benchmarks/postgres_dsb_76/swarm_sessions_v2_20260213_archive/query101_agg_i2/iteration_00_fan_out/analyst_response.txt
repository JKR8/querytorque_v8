<reasoning>
**1. CLASSIFY**
This is a star-join with late dimension filters. Query joins three fact tables (store_sales, store_returns, web_sales) through a complex network of equi-joins with multiple dimension tables. It has a non-equi date range join (d2.d_date between d1.d_date AND d1.d_date+90) and multiple selective filters on dimensions.

**2. EXPLAIN PLAN ANALYSIS**
- Total runtime: 1520.6ms
- Dominant operations:
  1. Nested Loop Inner between store_sales and web_sales (1501.5ms, 99% of runtime). This is the join-bound bottleneck.
  2. Hash Join between store_returns and item (135.5ms) - dimension filtering
  3. Nested Loop of store_returns with date_dim d1 (65.9ms)

- Cardinality flow:
  - date_dim d1: 122 rows → store_returns: 3190 rows per loop → 389K total rows
  - item: 9203 rows → hash join → 74K rows
  - store_sales join: highly selective (ss_sales_price filter) → 0 rows on average per probe
  - customer/household_demographics/customer_address: point lookups
  - web_sales: bitmap scan returns ~49 rows per outer row

- Missed opportunities:
  1. The optimizer scans store_returns (389K rows) before applying the highly selective ss_sales_price filter. Only 0 rows per probe pass through, meaning most store_returns rows are wasted.
  2. Comma-join syntax may prevent better join reordering.
  3. The same item table is joined twice (through store_sales and store_returns) but scanned once - this is already optimized.
  4. The web_sales join happens late in a nested loop; could be restructured as hash join.

- What optimizer already handles well:
  - Index-only scans on selective dimensions (item, store_returns)
  - Parallel execution (Gather Merge with 2 workers)
  - Bitmap index scans on web_sales

**3. GAP MATCHING**
- COMMA_JOIN_WEAKNESS: Present. Query uses comma-separated joins.
- CORRELATED_SUBQUERY_PARALYSIS: Not present.
- CROSS_CTE_PREDICATE_BLINDNESS: Not present (no repeated scans).
- NON_EQUI_JOIN_INPUT_BLINDNESS: Present. The d2.d_date BETWEEN condition is a range join that could benefit from pre-filtering both date dimensions.

**4. AGGREGATION TRAP CHECK**
Aggregation is COUNT(*). This is grouping-insensitive (modulo duplicates). However, changing join order could introduce or eliminate duplicates, changing the COUNT. Must maintain exact row multiplicity from the original join semantics.

**5. TRANSFORM SELECTION**
Ranked by expected value:
1. **star_join_prefetch** (COMMA_JOIN_WEAKNESS + dimension pre-filtering) - Pre-filter all selective dimensions into CTEs, convert to explicit JOINs. Expected high benefit due to reduced probe sizes for nested loops.
2. **late_attribute_binding** - Defer customer, customer_address, household_demographics joins until after fact table filtering. These dimensions are only used for display columns (c_first_name, c_last_name) and filters (ca_state, hd_*). Filters can be pushed down.
3. **transitive_predicate_propagation** - Push the selective ss_sales_price filter earlier in the join tree. Currently applied after joining with store_returns.
4. **single_pass_aggregation** (exploration) - Could restructure to compute the count from store_sales/store_returns/web_sales in a single scan with CASE statements.

**6. LOGICAL TREE DESIGN**
Each strategy requires different CTE structures:
- Worker 1: Pre-filtered dimension CTEs → fact table joins → aggregation
- Worker 2: Early fact filtering with dimension key lookups → late dimension decoration
- Worker 3: Push ss_sales_price filter into store_sales CTE before joining with store_returns
- Worker 4: Single CTE with all fact tables joined using UNION/conditional logic
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
This query finds customers who made store purchases and returns, then web purchases within 90 days, for items in specific categories, with specific discount ranges, living in certain states and demographic bands. It counts qualifying transaction combinations per customer. All joins are INNER (must match all sides). Aggregation uses COUNT(*) which is sensitive to row duplication from joins. The date range filter (d2 between d1 and d1+90) creates a temporal dependency between store returns and web sales.

BOTTLENECK_DIAGNOSIS:
The query is join-bound with a costly Nested Loop between store_sales and web_sales (99% runtime). Cardinality flow: date_dim d1 (122 rows) → store_returns (389K rows) → item join (74K rows) → store_sales join (highly selective, ~0 rows per probe) → customer dimensions (point lookups) → web_sales nested loop (expensive). The optimizer already handles parallel execution and index scans well but wastes work joining many store_returns rows that get filtered out by the late ss_sales_price filter. Logical-tree cost percentages are misleading as the Nested Loop dominates actual runtime.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Query outputs c_customer_sk, c_first_name, c_last_name, cnt
- CTE_COLUMN_COMPLETENESS: All CTEs must include columns referenced downstream: ss_customer_sk, ss_item_sk, ss_ticket_number, sr_item_sk, sr_ticket_number, ws_bill_customer_sk, ws_item_sk, plus dimension keys
- LITERAL_PRESERVATION: Must preserve exact filter values: i_category IN ('Children','Home','Women'), ca_state IN ('AR','GA','IN','KY','VA'), d_year=2000, etc.
- SEMANTIC_EQUIVALENCE: Must return same rows, columns, ordering
- COMMA_JOIN_WEAKNESS: Query uses comma-separated implicit joins (evidence from original SQL)
- NON_EQUI_JOIN_INPUT_BLINDNESS: Range join d2.d_date BETWEEN d1.d_date AND (d1.d_date + interval '90 day')

REGRESSION_WARNINGS:
1. CTE blocking parallelism (observed regression: 0.50x on Q069):
   CAUSE: MATERIALIZED CTEs executed single-threaded prevent parallel table scans
   RULE: Use non-materialized CTEs or inline subqueries for large fact tables when parallel scans are beneficial
2. Nestloop disable on lookups (observed regression: 184x):
   CAUSE: SET enable_nestloop=off forces hash/merge joins on selective index lookups
   RULE: Never disable nestloop globally; allow optimizer to choose for point lookups

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch_explicit
TARGET_LOGICAL_TREE:
  filtered_dates -> filtered_item -> filtered_ca_hd -> fact_joins -> aggregation -> sort
NODE_CONTRACTS:
  filtered_d1:
    FROM: date_dim d1
    WHERE: d1.d_year = 2000
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 122
    CONSUMERS: fact_joins
  filtered_d2:
    FROM: date_dim d2
    WHERE: EXISTS (SELECT 1 FROM filtered_d1 WHERE d2.d_date BETWEEN d1.d_date AND (d1.d_date + interval '90 day'))
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: ~365 (90 days * 4 years approx)
    CONSUMERS: fact_joins
  filtered_item:
    FROM: item
    WHERE: i_category IN ('Children', 'Home', 'Women')
    OUTPUT: i_item_sk
    EXPECTED_ROWS: 9203
    CONSUMERS: fact_joins
  filtered_ca:
    FROM: customer_address
    WHERE: ca_state IN ('AR', 'GA', 'IN', 'KY', 'VA')
    OUTPUT: ca_address_sk
    EXPECTED_ROWS: ~5 states / 50 = 10% of table
    CONSUMERS: customer_prefilter
  filtered_hd:
    FROM: household_demographics
    WHERE: hd_income_band_sk BETWEEN 8 AND 14 AND hd_buy_potential = '501-1000'
    OUTPUT: hd_demo_sk
    EXPECTED_ROWS: selective
    CONSUMERS: customer_prefilter
  customer_prefilter:
    FROM: customer
    JOIN: INNER JOIN filtered_ca ON c_current_addr_sk = ca_address_sk
          INNER JOIN filtered_hd ON c_current_hdemo_sk = hd_demo_sk
    OUTPUT: c_customer_sk, c_first_name, c_last_name, c_current_addr_sk, c_current_hdemo_sk
    EXPECTED_ROWS: reduced by state and demographic filters
    CONSUMERS: fact_joins
  fact_joins:
    FROM: store_sales
    JOIN: INNER JOIN store_returns ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk
          INNER JOIN filtered_item ON ss_item_sk = i_item_sk
          INNER JOIN filtered_d1 ON sr_returned_date_sk = d1.d_date_sk
          INNER JOIN web_sales ON sr_item_sk = ws_item_sk AND ss_customer_sk = ws_bill_customer_sk
          INNER JOIN filtered_d2 ON ws_sold_date_sk = d2.d_date_sk
          INNER JOIN customer_prefilter ON ss_customer_sk = c_customer_sk
    WHERE: ss_sales_price / ss_list_price BETWEEN 76 * 0.01 AND 96 * 0.01
    OUTPUT: c_customer_sk, c_first_name, c_last_name
    EXPECTED_ROWS: same as original output
    CONSUMERS: aggregation
  aggregation:
    FROM: fact_joins
    GROUP BY: c_customer_sk, c_first_name, c_last_name
    AGGREGATE: COUNT(*) as cnt
    OUTPUT: c_customer_sk, c_first_name, c_last_name, cnt
    EXPECTED_ROWS: same as original
    CONSUMERS: sort
  sort:
    FROM: aggregation
    ORDER BY: cnt
    OUTPUT: c_customer_sk, c_first_name, c_last_name, cnt
    EXPECTED_ROWS: same as original
    CONSUMERS: final output
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join, pg_materialized_dimension_fact_prefilter
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply pre-filtering of all selective dimensions (date, item, customer_address, household_demographics) into CTEs; convert comma joins to explicit JOIN syntax. Ignore promotion table references.
- pg_date_cte_explicit_join: Apply date_dim isolation for both d1 and d2 with explicit JOINs. Ignore single-date focus; adapt for two date dimensions with range condition.
- pg_materialized_dimension_fact_prefilter: Apply staged reduction via CTEs but avoid MATERIALIZED keyword to preserve parallelism; focus on dimension pre-filtering.
HAZARD_FLAGS:
- May lose parallel execution if CTEs are materialized
- Explicit JOIN syntax may constrain join order optimization

=== WORKER 2 BRIEFING ===

STRATEGY: late_attribute_binding
TARGET_LOGICAL_TREE:
  fact_core -> aggregation -> customer_decorate -> sort
NODE_CONTRACTS:
  filtered_d1:
    FROM: date_dim d1
    WHERE: d1.d_year = 2000
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 122
    CONSUMERS: fact_core
  filtered_d2:
    FROM: date_dim d2
    WHERE: EXISTS (SELECT 1 FROM filtered_d1 WHERE d2.d_date BETWEEN d1.d_date AND (d1.d_date + interval '90 day'))
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: ~365
    CONSUMERS: fact_core
  filtered_item:
    FROM: item
    WHERE: i_category IN ('Children', 'Home', 'Women')
    OUTPUT: i_item_sk
    EXPECTED_ROWS: 9203
    CONSUMERS: fact_core
  fact_core:
    FROM: store_sales
    JOIN: INNER JOIN store_returns ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk
          INNER JOIN filtered_item ON ss_item_sk = i_item_sk
          INNER JOIN filtered_d1 ON sr_returned_date_sk = d1.d_date_sk
          INNER JOIN web_sales ON sr_item_sk = ws_item_sk AND ss_customer_sk = ws_bill_customer_sk
          INNER JOIN filtered_d2 ON ws_sold_date_sk = d2.d_date_sk
    WHERE: ss_sales_price / ss_list_price BETWEEN 76 * 0.01 AND 96 * 0.01
    OUTPUT: ss_customer_sk
    EXPECTED_ROWS: reduced set of customer keys
    CONSUMERS: aggregation
  aggregation:
    FROM: fact_core
    GROUP BY: ss_customer_sk
    AGGREGATE: COUNT(*) as cnt
    OUTPUT: ss_customer_sk, cnt
    EXPECTED_ROWS: same as original groups
    CONSUMERS: customer_decorate
  customer_decorate:
    FROM: aggregation
    JOIN: INNER JOIN customer ON ss_customer_sk = c_customer_sk
          INNER JOIN customer_address ON c_current_addr_sk = ca_address_sk
          INNER JOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk
    WHERE: ca_state IN ('AR', 'GA', 'IN', 'KY', 'VA')
          AND hd_income_band_sk BETWEEN 8 AND 14
          AND hd_buy_potential = '501-1000'
    OUTPUT: c_customer_sk, c_first_name, c_last_name, cnt
    EXPECTED_ROWS: further filtered by state/demographics
    CONSUMERS: sort
  sort:
    FROM: customer_decorate
    ORDER BY: cnt
    OUTPUT: c_customer_sk, c_first_name, c_last_name, cnt
    EXPECTED_ROWS: same as original
    CONSUMERS: final output
EXAMPLES: early_filter_decorrelate, pg_dimension_prefetch_star
EXAMPLE_ADAPTATION:
- early_filter_decorrelate: Apply early filtering of fact tables before joining with dimensions; decorate with dimension attributes at the end. Ignore decorrelation aspect (no subqueries).
- pg_dimension_prefetch_star: Use dimension CTEs but only for date and item; defer customer-related dimensions. Adapt by moving customer/ca/hd filters to late decoration.
HAZARD_FLAGS:
- Moving customer filters late may increase intermediate aggregation size if state/demographic filters are very selective
- Must ensure customer join doesn't introduce duplicates (one-to-one on c_customer_sk)

=== WORKER 3 BRIEFING ===

STRATEGY: transitive_predicate_pushdown
TARGET_LOGICAL_TREE:
  prefiltered_store_sales -> joined_with_returns -> web_sales_join -> dimensions -> aggregation -> sort
NODE_CONTRACTS:
  filtered_d1:
    FROM: date_dim d1
    WHERE: d1.d_year = 2000
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 122
    CONSUMERS: store_returns_filtered
  store_returns_filtered:
    FROM: store_returns
    JOIN: INNER JOIN filtered_d1 ON sr_returned_date_sk = d1.d_date_sk
    OUTPUT: sr_ticket_number, sr_item_sk
    EXPECTED_ROWS: 389K
    CONSUMERS: store_sales_prefiltered
  store_sales_prefiltered:
    FROM: store_sales
    WHERE: ss_sales_price / ss_list_price BETWEEN 76 * 0.01 AND 96 * 0.01
    OUTPUT: ss_ticket_number, ss_item_sk, ss_customer_sk
    EXPECTED_ROWS: highly selective
    CONSUMERS: store_fact_join
  store_fact_join:
    FROM: store_sales_prefiltered
    JOIN: INNER JOIN store_returns_filtered ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk
    OUTPUT: ss_customer_sk, sr_item_sk
    EXPECTED_ROWS: very small (filtered by price ratio)
    CONSUMERS: web_sales_join
  filtered_item:
    FROM: item
    WHERE: i_category IN ('Children', 'Home', 'Women')
    OUTPUT: i_item_sk
    EXPECTED_ROWS: 9203
    CONSUMERS: web_sales_join
  filtered_d2:
    FROM: date_dim d2
    WHERE: EXISTS (SELECT 1 FROM filtered_d1 WHERE d2.d_date BETWEEN d1.d_date AND (d1.d_date + interval '90 day'))
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: ~365
    CONSUMERS: web_sales_join
  web_sales_join:
    FROM: store_fact_join
    JOIN: INNER JOIN web_sales ON sr_item_sk = ws_item_sk AND ss_customer_sk = ws_bill_customer_sk
          INNER JOIN filtered_item ON sr_item_sk = i_item_sk
          INNER JOIN filtered_d2 ON ws_sold_date_sk = d2.d_date_sk
    OUTPUT: ss_customer_sk
    EXPECTED_ROWS: same as final groups
    CONSUMERS: customer_dimensions
  customer_dimensions:
    FROM: web_sales_join
    JOIN: INNER JOIN customer ON ss_customer_sk = c_customer_sk
          INNER JOIN customer_address ON c_current_addr_sk = ca_address_sk
          INNER JOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk
    WHERE: ca_state IN ('AR', 'GA', 'IN', 'KY', 'VA')
          AND hd_income_band_sk BETWEEN 8 AND 14
          AND hd_buy_potential = '501-1000'
    OUTPUT: c_customer_sk, c_first_name, c_last_name
    EXPECTED_ROWS: filtered by state/demographics
    CONSUMERS: aggregation
  aggregation:
    FROM: customer_dimensions
    GROUP BY: c_customer_sk, c_first_name, c_last_name
    AGGREGATE: COUNT(*) as cnt
    OUTPUT: c_customer_sk, c_first_name, c_last_name, cnt
    EXPECTED_ROWS: same as original
    CONSUMERS: sort
  sort:
    FROM: aggregation
    ORDER BY: cnt
    OUTPUT: c_customer_sk, c_first_name, c_last_name, cnt
    EXPECTED_ROWS: same as original
    CONSUMERS: final output
EXAMPLES: pushdown, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pushdown: Apply the ss_sales_price filter directly on store_sales scan before joining with store_returns. Ignore other predicate pushdown aspects.
- early_filter_decorrelate: Push dimension filters early; adapt by pushing the most selective filter (price ratio) earliest.
HAZARD_FLAGS:
- May change join order significantly, affecting cardinality estimates
- Requires maintaining equivalence of item category filter (currently through store_sales join)

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: single_pass_conditional_aggregation
TARGET_LOGICAL_TREE:
  unified_facts -> conditional_aggregation -> dimensions -> sort
NODE_CONTRACTS:
  filtered_d1:
    FROM: date_dim d1
    WHERE: d1.d_year = 2000
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 122
    CONSUMERS: date_range
  date_range:
    FROM: date_dim d2
    JOIN: CROSS JOIN filtered_d1
    WHERE: d2.d_date BETWEEN d1.d_date AND (d1.d_date + interval '90 day')
    OUTPUT: d1.d_date_sk as d1_date_sk, d1.d_date as d1_date, d2.d_date_sk as d2_date_sk
    EXPECTED_ROWS: ~44,730 (122 * 365 approximate)
    CONSUMERS: unified_facts
  unified_facts:
    FROM: store_sales
    JOIN: INNER JOIN store_returns ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk
          INNER JOIN web_sales ON sr_item_sk = ws_item_sk AND ss_customer_sk = ws_bill_customer_sk
          INNER JOIN item ON ss_item_sk = i_item_sk
          INNER JOIN date_range ON sr_returned_date_sk = d1_date_sk AND ws_sold_date_sk = d2_date_sk
    WHERE: i_category IN ('Children', 'Home', 'Women')
          AND ss_sales_price / ss_list_price BETWEEN 76 * 0.01 AND 96 * 0.01
    OUTPUT: ss_customer_sk
    EXPECTED_ROWS: same as original qualifying rows
    CONSUMERS: conditional_aggregation
  conditional_aggregation:
    FROM: unified_facts
    GROUP BY: ss_customer_sk
    AGGREGATE: COUNT(*) as cnt
    OUTPUT: ss_customer_sk, cnt
    EXPECTED_ROWS: same as original groups
    CONSUMERS: customer_dimensions
  customer_dimensions:
    FROM: conditional_aggregation
    JOIN: INNER JOIN customer ON ss_customer_sk = c_customer_sk
          INNER JOIN customer_address ON c_current_addr_sk = ca_address_sk
          INNER JOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk
    WHERE: ca_state IN ('AR', 'GA', 'IN', 'KY', 'VA')
          AND hd_income_band_sk BETWEEN 8 AND 14
          AND hd_buy_potential = '501-1000'
    OUTPUT: c_customer_sk, c_first_name, c_last_name, cnt
    EXPECTED_ROWS: filtered by state/demographics
    CONSUMERS: sort
  sort:
    FROM: customer_dimensions
    ORDER BY: cnt
    OUTPUT: c_customer_sk, c_first_name, c_last_name, cnt
    EXPECTED_ROWS: same as original
    CONSUMERS: final output
EXAMPLES: pg_self_join_decomposition, single_pass_aggregation
EXAMPLE_ADAPTATION:
- pg_self_join_decomposition: Apply materialization of the fact join pattern once, but adapt by joining all three fact tables in one CTE rather than reusing same scan.
- single_pass_aggregation: Compute count from unified fact join in single pass. Ignore CASE/FILTER complexity since simple COUNT(*).
HAZARD_FLAGS:
- Cross join between d1 and d2 may produce large intermediate result (~44K rows)
- May lose parallel execution on large CTE
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy (combines date_range precomputation with unified fact join)