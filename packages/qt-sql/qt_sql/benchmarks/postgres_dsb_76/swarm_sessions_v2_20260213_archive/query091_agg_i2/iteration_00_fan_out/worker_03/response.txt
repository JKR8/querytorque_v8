## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Structural change: CTE-based rewrite per target logical tree
    ├── [~] filtered_dimensions_cte (CTE) - Early Cartesian product of filtered dimension rows
    ├── [~] pre_aggregated_fact (CTE) - Fact aggregation with dimension joins on date/call_center
    ├── [~] join_with_dimensions (CTE) - Join aggregated fact with customer and dimension keys
    ├── [~] final_aggregation (CTE) - Final grouping by call center and demographics
    └── [~] sort (main) - Final ordering and column renaming
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16.11",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_decomposition", "description": "Decompose monolithic query into CTEs matching target logical tree", "applied_to": ["filtered_dimensions_cte", "pre_aggregated_fact", "join_with_dimensions", "final_aggregation"]},
    {"id": "R2", "type": "early_filter_pushdown", "description": "Push dimension filters into initial CTE before joins", "applied_to": ["filtered_dimensions_cte"]},
    {"id": "R3", "type": "explicit_join_conversion", "description": "Convert comma joins to explicit INNER JOIN syntax", "applied_to": ["pre_aggregated_fact", "join_with_dimensions"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dimensions_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, cc_call_center_sk, ca_address_sk, cd_demo_sk, hd_demo_sk, cd_marital_status, cd_education_status, cc_call_center_id, cc_name, cc_manager FROM date_dim, call_center, customer_address, customer_demographics, household_demographics WHERE date_dim.d_year = 2001 AND date_dim.d_moy = 12 AND customer_address.ca_gmt_offset = -6 AND ((customer_demographics.cd_marital_status = 'M' AND customer_demographics.cd_education_status = 'Unknown') OR (customer_demographics.cd_marital_status = 'W' AND customer_demographics.cd_education_status = 'Advanced Degree')) AND household_demographics.hd_buy_potential LIKE '>10000%'",
        "interfaces": {"outputs": ["d_date_sk", "cc_call_center_sk", "ca_address_sk", "cd_demo_sk", "hd_demo_sk", "cd_marital_status", "cd_education_status", "cc_call_center_id", "cc_name", "cc_manager"], "consumes": []}
      },
      "pre_aggregated_fact": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cr_returning_customer_sk, fd.cc_call_center_id, fd.cc_name, fd.cc_manager, fd.cd_marital_status, fd.cd_education_status, SUM(cr_net_loss) AS partial_loss FROM catalog_returns INNER JOIN filtered_dimensions_cte fd ON catalog_returns.cr_returned_date_sk = fd.d_date_sk AND catalog_returns.cr_call_center_sk = fd.cc_call_center_sk GROUP BY cr_returning_customer_sk, fd.cc_call_center_id, fd.cc_name, fd.cc_manager, fd.cd_marital_status, fd.cd_education_status",
        "interfaces": {"outputs": ["cr_returning_customer_sk", "cc_call_center_id", "cc_name", "cc_manager", "cd_marital_status", "cd_education_status", "partial_loss"], "consumes": ["filtered_dimensions_cte"]}
      },
      "join_with_dimensions": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT paf.cc_call_center_id, paf.cc_name, paf.cc_manager, paf.cd_marital_status, paf.cd_education_status, paf.partial_loss FROM pre_aggregated_fact paf INNER JOIN customer ON customer.c_customer_sk = paf.cr_returning_customer_sk INNER JOIN filtered_dimensions_cte fd ON customer.c_current_addr_sk = fd.ca_address_sk AND customer.c_current_cdemo_sk = fd.cd_demo_sk AND customer.c_current_hdemo_sk = fd.hd_demo_sk",
        "interfaces": {"outputs": ["cc_call_center_id", "cc_name", "cc_manager", "cd_marital_status", "cd_education_status", "partial_loss"], "consumes": ["pre_aggregated_fact", "filtered_dimensions_cte"]}
      },
      "final_aggregation": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status, SUM(partial_loss) AS Returns_Loss FROM join_with_dimensions GROUP BY cc_call_center_id, cc_name, cc_manager, cd_marital_status, cd_education_status",
        "interfaces": {"outputs": ["cc_call_center_id", "cc_name", "cc_manager", "cd_marital_status", "cd_education_status", "Returns_Loss"], "consumes": ["join_with_dimensions"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cc_call_center_id AS Call_Center, cc_name AS Call_Center_Name, cc_manager AS Manager, Returns_Loss FROM final_aggregation ORDER BY Returns_Loss DESC",
        "interfaces": {"outputs": ["Call_Center", "Call_Center_Name", "Manager", "Returns_Loss"], "consumes": ["final_aggregation"]}
      }
    },
    "reconstruction_order": ["filtered_dimensions_cte", "pre_aggregated_fact", "join_with_dimensions", "final_aggregation", "main_query"],
    "assembly_template": "WITH filtered_dimensions_cte AS ({filtered_dimensions_cte}), pre_aggregated_fact AS ({pre_aggregated_fact}), join_with_dimensions AS ({join_with_dimensions}), final_aggregation AS ({final_aggregation}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Restructured monolithic query into CTEs matching the target logical tree. Early filtering in `filtered_dimensions_cte` reduces dimension rows before joins. The pre-aggregation groups fact data with dimension attributes, then joins with customer and dimension keys ensure correct grouping.

**Expected speedup**: 1.2-1.5x from reduced intermediate result sizes and better join selectivity.