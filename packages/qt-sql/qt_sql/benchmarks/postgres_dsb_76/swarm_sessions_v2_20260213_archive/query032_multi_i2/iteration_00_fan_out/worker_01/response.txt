**Part 1: Modified Logic Tree**

```
QUERY: (single statement)
├── [MAIN] main_query [~]
│   ├── WITH filtered_dates AS MATERIALIZED [+]
│   │   └── SCAN date_dim
│   │       └── FILTER (d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY')
│   ├── WITH filtered_items AS MATERIALIZED [~]
│   │   └── SCAN item
│   │       └── FILTER (i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71)
│   ├── WITH item_thresholds AS MATERIALIZED [~]
│   │   ├── JOIN (INNER) catalog_sales × filtered_dates
│   │   │   └── ON cs_sold_date_sk = d_date_sk
│   │   └── FILTER (cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 0.21 AND 0.41)
│   │   └── AGGREGATE (GROUP BY cs_item_sk) [1.3 * AVG(cs_ext_discount_amt) AS threshold]
│   └── FINAL SELECT [=]
│       ├── JOIN (INNER) filtered_items × catalog_sales ON i_item_sk = cs_item_sk
│       ├── JOIN (INNER) filtered_dates ON cs_sold_date_sk = d_date_sk
│       ├── JOIN (LEFT) item_thresholds ON cs_item_sk = item_thresholds.cs_item_sk
│       ├── FILTER (cs_ext_discount_amt > COALESCE(threshold, -1))
│       ├── AGGREGATE (SUM(cs_ext_discount_amt))
│       ├── SORT (SUM(cs_ext_discount_amt) ASC)
│       └── LIMIT 100
```

**Part 2: Component Payload JSON**

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "inline_decorrelate_materialized",
      "description": "Replace correlated scalar subquery with 3 MATERIALIZED CTEs: filtered dates, filtered items, and pre-computed per-item thresholds. Preserves exact semantics and row duplication in AVG.",
      "applied_to": ["main_query"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN '2001-02-23' AND CAST('2001-02-23' AS DATE) + INTERVAL '90 DAY'",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "filtered_items": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk, i_manufact_id, i_manager_id FROM item WHERE i_manufact_id IN (184, 307, 365, 560, 681) OR i_manager_id BETWEEN 42 AND 71",
        "interfaces": {"outputs": ["i_item_sk", "i_manufact_id", "i_manager_id"], "consumes": []}
      },
      "item_thresholds": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cs_item_sk, 1.3 * AVG(cs_ext_discount_amt) AS threshold FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk WHERE cs_list_price BETWEEN 115 AND 144 AND cs_sales_price / cs_list_price BETWEEN 0.21 AND 0.41 GROUP BY cs_item_sk",
        "interfaces": {"outputs": ["cs_item_sk", "threshold"], "consumes": ["filtered_dates"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT SUM(cs_ext_discount_amt) AS \"excess discount amount\" FROM filtered_items fi JOIN catalog_sales cs ON fi.i_item_sk = cs.cs_item_sk JOIN filtered_dates fd ON cs.cs_sold_date_sk = fd.d_date_sk LEFT JOIN item_thresholds it ON cs.cs_item_sk = it.cs_item_sk WHERE cs.cs_ext_discount_amt > COALESCE(it.threshold, -1) ORDER BY SUM(cs_ext_discount_amt) LIMIT 100",
        "interfaces": {"outputs": ["excess discount amount"], "consumes": ["filtered_dates", "filtered_items", "item_thresholds"]}
      }
    },
    "reconstruction_order": ["filtered_dates", "filtered_items", "item_thresholds", "main_query"],
    "assembly_template": "WITH filtered_dates AS MATERIALIZED ({filtered_dates}), filtered_items AS MATERIALIZED ({filtered_items}), item_thresholds AS MATERIALIZED ({item_thresholds}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '256MB'", "SET LOCAL hash_mem_multiplier = 2.0", "SET LOCAL enable_nestloop = off", "SET LOCAL enable_mergejoin = off", "SET LOCAL max_parallel_workers_per_gather = 2"],
  "validation_checks": []
}
```

**Changes:** Decorrelated the query by pre-computing per-item thresholds in a MATERIALIZED CTE, eliminating N re-executions of the scalar subquery. The 3-CTE structure ensures the same rows participate in each per-item average calculation, with defensive guards preserved via COALESCE.

**Expected speedup:** 3-10x reduction in execution time by eliminating correlated subquery overhead, enabling hash joins, and allowing parallel aggregation on threshold computation.