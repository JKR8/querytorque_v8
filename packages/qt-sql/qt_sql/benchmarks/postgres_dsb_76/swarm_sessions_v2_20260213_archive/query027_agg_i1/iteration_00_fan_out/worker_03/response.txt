### Part 1: Modified Logic Tree

```
QUERY: (WITH CTEs)
├── [~] fact_filtered CTE [EXISTS replaces joins]
│   ├── SCAN (store_sales)
│   ├── FILTER (EXISTS subqueries for date_dim and customer_demographics)
│   └── OUTPUT (ss_item_sk, ss_store_sk, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price)
├── [~] joined_store_item CTE [explicit INNER JOINs]
│   ├── SCAN (fact_filtered)
│   ├── JOIN store (ss_store_sk = s_store_sk AND s_state = 'IA')
│   ├── JOIN item (ss_item_sk = i_item_sk AND i_category = 'Sports')
│   └── OUTPUT (i_item_id, s_state, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price)
├── [=] aggregated CTE [GROUP BY ROLLUP]
├── [=] sorted_limited [ORDER BY, LIMIT]
└── OUTPUT (i_item_id, s_state, g_state, agg1, agg2, agg3, agg4)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter_decorrelate", "description": "Replace dimension joins with EXISTS subqueries in fact_filtered CTE to push filters early", "applied_to": ["fact_filtered"]},
    {"id": "R2", "type": "comma_to_explicit_join", "description": "Convert comma joins to explicit INNER JOINs with filters in ON clauses", "applied_to": ["joined_store_item"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "fact_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_item_sk, ss_store_sk, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price FROM store_sales WHERE EXISTS (SELECT 1 FROM date_dim WHERE d_date_sk = store_sales.ss_sold_date_sk AND d_year = 2002) AND EXISTS (SELECT 1 FROM customer_demographics WHERE cd_demo_sk = store_sales.ss_cdemo_sk AND cd_gender = 'F' AND cd_marital_status = 'M' AND cd_education_status = 'Primary')",
        "interfaces": {"outputs": ["ss_item_sk", "ss_store_sk", "ss_quantity", "ss_list_price", "ss_coupon_amt", "ss_sales_price"], "consumes": []}
      },
      "joined_store_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i.i_item_id, s.s_state, f.ss_quantity, f.ss_list_price, f.ss_coupon_amt, f.ss_sales_price FROM fact_filtered f INNER JOIN store s ON f.ss_store_sk = s.s_store_sk AND s.s_state = 'IA' INNER JOIN item i ON f.ss_item_sk = i.i_item_sk AND i.i_category = 'Sports'",
        "interfaces": {"outputs": ["i_item_id", "s_state", "ss_quantity", "ss_list_price", "ss_coupon_amt", "ss_sales_price"], "consumes": ["fact_filtered"]}
      },
      "aggregated": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["i_item_id", "s_state", "g_state", "agg1", "agg2", "agg3", "agg4"], "consumes": ["joined_store_item"]}
      },
      "sorted_limited": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, s_state, GROUPING(s_state) AS g_state, AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4 FROM joined_store_item GROUP BY ROLLUP (i_item_id, s_state) ORDER BY i_item_id, s_state LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "s_state", "g_state", "agg1", "agg2", "agg3", "agg4"], "consumes": ["joined_store_item"]}
      }
    },
    "reconstruction_order": ["fact_filtered", "joined_store_item", "sorted_limited"],
    "assembly_template": "WITH fact_filtered AS ({fact_filtered}), joined_store_item AS ({joined_store_item}) {sorted_limited}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Early filtering via EXISTS subqueries reduces fact rows before joins; explicit INNER JOINs maintain semantic equivalence while allowing better join ordering.

**Expected speedup**: Moderate (1.2-1.5x) due to reduced intermediate row count from early EXISTS filtering, though PostgreSQL may still optimize the original joins similarly.