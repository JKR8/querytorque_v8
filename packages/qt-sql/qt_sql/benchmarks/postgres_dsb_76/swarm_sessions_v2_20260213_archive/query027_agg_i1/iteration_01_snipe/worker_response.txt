## Part 1: Modified Logic Tree

```
[!] Structural change: Convert comma-joins to explicit JOIN syntax with strategic CTE materialization
  [=] date_dim filter unchanged: d_year = 2002
  [=] store filter unchanged: s_state = 'IA'
  [=] item filter unchanged: i_category = 'Sports'
  [=] customer_demographics filter unchanged: cd_gender='F', cd_marital_status='M', cd_education_status='Primary'
  [~] Join structure: FROM comma-join → explicit INNER JOIN sequence
  [+] New strategy: Use MATERIALIZED CTEs for selective dimensions to create optimization fence
  [~] Aggregation: Keep ROLLUP(i_item_id, s_state) unchanged
  [~] Output: Preserve exact column order and naming
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "comma_join_to_explicit", "description": "Convert implicit comma-joins to explicit JOIN...ON syntax", "applied_to": ["main_query"]},
    {"id": "R2", "type": "strategic_materialization", "description": "Materialize highly selective dimension filters to create optimization fence", "applied_to": ["filtered_date", "filtered_store", "filtered_item", "filtered_cdemo"]},
    {"id": "R3", "type": "bitmap_or_scan_enabler", "description": "Structure joins to encourage bitmap index scan on fact table foreign keys", "applied_to": ["main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_store": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s_store_sk, s_state FROM store WHERE s_state = 'IA'",
        "interfaces": {"outputs": ["s_store_sk", "s_state"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_id FROM item WHERE i_category = 'Sports'",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id"], "consumes": []}
      },
      "filtered_cdemo": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_gender = 'F' AND cd_marital_status = 'M' AND cd_education_status = 'Primary'",
        "interfaces": {"outputs": ["cd_demo_sk"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, s_state, grouping(s_state) g_state, avg(ss_quantity) agg1, avg(ss_list_price) agg2, avg(ss_coupon_amt) agg3, avg(ss_sales_price) agg4 FROM store_sales INNER JOIN filtered_date ON store_sales.ss_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_store ON store_sales.ss_store_sk = filtered_store.s_store_sk INNER JOIN filtered_item ON store_sales.ss_item_sk = filtered_item.i_item_sk INNER JOIN filtered_cdemo ON store_sales.ss_cdemo_sk = filtered_cdemo.cd_demo_sk GROUP BY ROLLUP (i_item_id, s_state) ORDER BY i_item_id, s_state LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "s_state", "g_state", "agg1", "agg2", "agg3", "agg4"], "consumes": ["filtered_date", "filtered_store", "filtered_item", "filtered_cdemo"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_store", "filtered_item", "filtered_cdemo", "main_query"],
    "assembly_template": "WITH filtered_date AS (MATERIALIZED {filtered_date}), filtered_store AS (MATERIALIZED {filtered_store}), filtered_item AS (MATERIALIZED {filtered_item}), filtered_cdemo AS (MATERIALIZED {filtered_cdemo}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL enable_mergejoin = off",
    "SET LOCAL join_collapse_limit = 1",
    "SET LOCAL from_collapse_limit = 1",
    "SET LOCAL work_mem = '32MB'",
    "SET LOCAL hash_mem_multiplier = 2.0"
  ],
  "validation_checks": []
}
```

**Changes**: Converted implicit comma-joins to explicit INNER JOIN syntax and materialized selective dimension filters into CTEs to create optimization fences. This combination addresses PostgreSQL's comma-join weakness and enables better hash join planning with small dimension hash tables.

**Expected speedup**: 2.1x–2.5x. The key insight is that previous attempts used CTEs but didn't materialize them strategically, allowing the planner to fall back to nested loops. By forcing materialization and disabling nested loops, we should see hash joins that can process the fact table once with parallel bitmap index scans instead of iterative nested loop probes.

**Mechanism**: The MATERIALIZED keyword prevents CTE inlining, creating stable dimension hash tables. Disabling nested loops forces hash joins. The explicit JOIN syntax gives PostgreSQL's cost model better join ordering information. The small work_mem increase supports hash table construction without spill.