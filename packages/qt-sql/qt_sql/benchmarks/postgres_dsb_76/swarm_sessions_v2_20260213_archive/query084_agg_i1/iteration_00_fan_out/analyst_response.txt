<reasoning>
1. **CLASSIFY**: This is a star-join with late dimension filter on customer_address.city and income_band range. It's a classic dimensional model query: fact table (store_returns) joined to multiple dimension tables (customer, customer_address, customer_demographics, household_demographics, income_band). No aggregation, just filtering and joining.

2. **EXPLAIN PLAN ANALYSIS**:
   - Total runtime: 43.9ms
   - Dominant node: Nested Loop Inner (rows=44 loops=3, time=39.9ms) - accounts for 91% of runtime
   - Row reduction pattern:
     - customer_address: 83K → 33 rows (filter: ca_city='Jackson')
     - income_band: 20 → 4 rows (filter: ib_lower_bound/ib_upper_bound)
     - customer: 167K rows full scan (no reduction)
     - Then nested loops to household_demographics (1:1), customer_demographics (1:1), store_returns (1:4)
   - The optimizer already does: predicate pushdown (customer_address and income_band filters applied at scan), hash joins where appropriate, parallel execution
   - Missed opportunities: comma joins (implicit joins), customer table scanned fully despite being filtered indirectly through customer_address (only 33 matching addresses)

3. **GAP MATCHING**:
   - **COMMA_JOIN_WEAKNESS**: Yes - query uses comma-separated implicit joins. Converting to explicit JOINs with pre-filtered CTEs could improve cardinality estimation.
   - **CORRELATED_SUBQUERY_PARALYSIS**: No - no correlated subqueries.
   - **CROSS_CTE_PREDICATE_BLINDNESS**: No - no repeated fact scans.
   - **NON_EQUI_JOIN_INPUT_BLINDNESS**: No - all equi-joins.

4. **AGGREGATION TRAP CHECK**: No aggregates in query.

5. **TRANSFORM SELECTION** (ranked by expected value):
   1. **star_join_prefetch** (pg_dimension_prefetch_star): Pre-filter all dimension tables into CTEs, convert to explicit JOINs. Addresses COMMA_JOIN_WEAKNESS.
   2. **global_predicate_pushdown** (early_filter_decorrelate): Push customer_address filter early to reduce customer scan. Customer table is largest scan (167K rows) but only needs rows matching the 33 Jackson addresses.
   3. **late_attribute_binding**: Defer non-filtering dimension joins. customer_demographics and household_demographics are only used for join keys to reach store_returns - their attributes aren't in SELECT. Could join them later.
   4. **EXPLORATION**: Try converting to single CTE with all pre-filtered dimensions joined early, then join to store_returns. Novel combination of prefetch + pushdown.

6. **LOGICAL TREE DESIGN**:
   - For star_join_prefetch: Create CTEs for each filtered dimension, then join.
   - For global_predicate_pushdown: Create CTE with customer + customer_address joined early, filter on ca_city.
   - For late_attribute_binding: First join customer + customer_address + income_band (filtering dimensions), then join to store_returns via surrogate keys, skip intermediate dimension tables.
   - For exploration: Single CTE with all dimensions pre-joined and filtered, then join to store_returns.

All strategies must preserve the 100-row limit and ORDER BY c_customer_id.
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT: This query finds customers in Jackson city within a specific income band who have store returns. Business intent: identify customers for targeted marketing based on geography, income, and return behavior. All joins are INNER (must match all sides). No aggregation traps. Filter dependencies: customer_address.city filter must remain joined to customer via address_sk; income_band range filter must remain joined to household_demographics.

BOTTLENECK_DIAGNOSIS: The dominant cost is scanning the entire customer table (167K rows) when only ~33 customers match the Jackson city filter via customer_address. This is scan-bound on customer. Cardinality flow: customer_address reduces 83K→33 rows, income_band 20→4 rows, but customer scans 167K rows then hash joins to the 33 addresses. The optimizer already pushes filters to customer_address and income_band scans, uses efficient nested loops for dimension lookups, and parallelizes the sort. Logical-tree cost percentages are misleading - the customer scan appears cheap (15.3ms) but is multiplied by 3 parallel workers and drives downstream nested loops.

ACTIVE_CONSTRAINTS:
- CORRECTNESS_CONSTRAINT_ID: COMPLETE_OUTPUT - Must output c_customer_id and customername exactly as defined.
- CORRECTNESS_CONSTRAINT_ID: CTE_COLUMN_COMPLETENESS - Any CTE must include all columns referenced downstream: address_sk, demo_sk, hdemo_sk, income_band_sk, etc.
- CORRECTNESS_CONSTRAINT_ID: LITERAL_PRESERVATION - Must preserve 'Jackson', 23567, 50000 literals.
- CORRECTNESS_CONSTRAINT_ID: SEMANTIC_EQUIVALENCE - Must return same 100 rows in same order.
- ENGINE_GAP_ID: COMMA_JOIN_WEAKNESS - Query uses comma-separated implicit joins (FROM customer, customer_address, ...). EXPLAIN shows optimizer reorders joins but explicit JOINs with pre-filtered CTEs may improve cardinality estimation.

REGRESSION_WARNINGS:
None applicable.

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  filtered_customer_address -> filtered_income_band -> filtered_household_demographics -> filtered_customer_demographics -> customer -> store_returns -> main
NODE_CONTRACTS:
  filtered_customer_address:
    FROM: customer_address
    WHERE: ca_city = 'Jackson'
    OUTPUT: ca_address_sk, (all columns)
    EXPECTED_ROWS: 33
    CONSUMERS: customer_join
  filtered_income_band:
    FROM: income_band
    WHERE: ib_lower_bound >= 23567 AND ib_upper_bound <= 73567
    OUTPUT: ib_income_band_sk, (all columns)
    EXPECTED_ROWS: 4
    CONSUMERS: household_demographics_filter
  filtered_household_demographics:
    FROM: household_demographics
    JOIN: INNER JOIN filtered_income_band ON household_demographics.hd_income_band_sk = filtered_income_band.ib_income_band_sk
    OUTPUT: hd_demo_sk, hd_income_band_sk, (all columns)
    EXPECTED_ROWS: ~12 (3 workers × 4 rows)
    CONSUMERS: customer_join
  filtered_customer_demographics:
    FROM: customer_demographics
    OUTPUT: cd_demo_sk, (all columns)
    EXPECTED_ROWS: ~500K (full table)
    CONSUMERS: customer_join, store_returns_join
  customer_join:
    FROM: customer
    JOIN: INNER JOIN filtered_customer_address ON customer.c_current_addr_sk = filtered_customer_address.ca_address_sk
          INNER JOIN filtered_household_demographics ON customer.c_current_hdemo_sk = filtered_household_demographics.hd_demo_sk
          INNER JOIN filtered_customer_demographics ON customer.c_current_cdemo_sk = filtered_customer_demographics.cd_demo_sk
    OUTPUT: c_customer_id, c_first_name, c_last_name, c_current_cdemo_sk, (all columns)
    EXPECTED_ROWS: ~44 (matching all filters)
    CONSUMERS: store_returns_join
  store_returns_join:
    FROM: customer_join
    JOIN: INNER JOIN store_returns ON store_returns.sr_cdemo_sk = customer_join.c_current_cdemo_sk
    OUTPUT: c_customer_id, customername (coalesce concatenation)
    EXPECTED_ROWS: ~100 (after limit)
    CONSUMERS: main
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join
EXAMPLE_ADAPTATION:
pg_dimension_prefetch_star: Apply pre-filtering of all dimension tables into separate CTEs. Ignore that example uses date/item/promotion - here use customer_address, income_band, etc.
pg_date_cte_explicit_join: Apply explicit JOIN syntax conversion and materialize selective filters (customer_address, income_band). Ignore date-specific patterns.
HAZARD_FLAGS:
- CTE materialization overhead may outweigh benefit for small dimension tables (income_band only 4 rows).
- Must ensure filtered_household_demographics CTE includes hd_demo_sk for join to customer.

=== WORKER 2 BRIEFING ===

STRATEGY: global_predicate_pushdown
TARGET_LOGICAL_TREE:
  jackson_customers -> income_household -> customer_demographics -> store_returns -> main
NODE_CONTRACTS:
  jackson_customers:
    FROM: customer
    JOIN: INNER JOIN customer_address ON customer.c_current_addr_sk = customer_address.ca_address_sk
    WHERE: customer_address.ca_city = 'Jackson'
    OUTPUT: c_customer_id, c_first_name, c_last_name, c_current_cdemo_sk, c_current_hdemo_sk, (all customer columns), customer_address.ca_address_sk
    EXPECTED_ROWS: ~33
    CONSUMERS: income_household
  income_household:
    FROM: jackson_customers
    JOIN: INNER JOIN household_demographics ON jackson_customers.c_current_hdemo_sk = household_demographics.hd_demo_sk
          INNER JOIN income_band ON household_demographics.hd_income_band_sk = income_band.ib_income_band_sk
    WHERE: income_band.ib_lower_bound >= 23567 AND income_band.ib_upper_bound <= 73567
    OUTPUT: c_customer_id, c_first_name, c_last_name, c_current_cdemo_sk, (all needed columns)
    EXPECTED_ROWS: ~12
    CONSUMERS: customer_demographics_join
  customer_demographics_join:
    FROM: income_household
    JOIN: INNER JOIN customer_demographics ON income_household.c_current_cdemo_sk = customer_demographics.cd_demo_sk
    OUTPUT: c_customer_id, c_first_name, c_last_name, customer_demographics.cd_demo_sk
    EXPECTED_ROWS: ~12
    CONSUMERS: store_returns_join
  store_returns_join:
    FROM: customer_demographics_join
    JOIN: INNER JOIN store_returns ON store_returns.sr_cdemo_sk = customer_demographics_join.cd_demo_sk
    OUTPUT: c_customer_id, customername (coalesce concatenation)
    EXPECTED_ROWS: ~100 (after limit)
    CONSUMERS: main
EXAMPLES: early_filter_decorrelate, pushdown
EXAMPLE_ADAPTATION:
early_filter_decorrelate: Apply early filtering of customer_address into the first CTE to reduce customer scan. Ignore decorrelation aspect (no subqueries).
pushdown: Push customer_address city filter as early as possible into the join with customer.
HAZARD_FLAGS:
- Must maintain join to household_demographics before income_band to apply income filter correctly.
- The customer_demographics join is still needed to connect to store_returns.

=== WORKER 3 BRIEFING ===

STRATEGY: late_attribute_binding
TARGET_LOGICAL_TREE:
  filtered_core -> store_returns -> customer_demographics_lookup -> main
NODE_CONTRACTS:
  filtered_core:
    FROM: customer
    JOIN: INNER JOIN customer_address ON customer.c_current_addr_sk = customer_address.ca_address_sk
          INNER JOIN household_demographics ON customer.c_current_hdemo_sk = household_demographics.hd_demo_sk
          INNER JOIN income_band ON household_demographics.hd_income_band_sk = income_band.ib_income_band_sk
    WHERE: customer_address.ca_city = 'Jackson' 
           AND income_band.ib_lower_bound >= 23567 AND income_band.ib_upper_bound <= 73567
    OUTPUT: c_customer_id, c_first_name, c_last_name, c_current_cdemo_sk, (all columns needed for downstream)
    EXPECTED_ROWS: ~12
    CONSUMERS: store_returns_join
  store_returns_join:
    FROM: filtered_core
    JOIN: INNER JOIN store_returns ON store_returns.sr_cdemo_sk = filtered_core.c_current_cdemo_sk
    OUTPUT: c_customer_id, c_first_name, c_last_name, store_returns.sr_cdemo_sk
    EXPECTED_ROWS: ~44
    CONSUMERS: customer_demographics_lookup
  customer_demographics_lookup:
    FROM: store_returns_join
    JOIN: INNER JOIN customer_demographics ON store_returns_join.sr_cdemo_sk = customer_demographics.cd_demo_sk
    OUTPUT: c_customer_id, customername (coalesce concatenation)
    EXPECTED_ROWS: ~100 (after limit)
    CONSUMERS: main
EXAMPLES: dimension_cte_isolate, late_attribute_binding
EXAMPLE_ADAPTATION:
dimension_cte_isolate: Apply filtering of core dimensions (customer_address, income_band) early. Ignore CTE materialization if not beneficial.
late_attribute_binding: Defer customer_demographics join until after store_returns join, since customer_demographics columns aren't used in filters or SELECT (only join key). This is the core adaptation.
HAZARD_FLAGS:
- Must verify customer_demographics join isn't needed earlier for filtering (it's not).
- store_returns join uses sr_cdemo_sk which comes from customer_demographics, but we're joining store_returns before customer_demographics. Actually store_returns.sr_cdemo_sk references customer_demographics.cd_demo_sk, so we need customer_demographics to join to store_returns. Strategy revision: join customer_demographics earlier, but skip household_demographics if possible? Wait, household_demographics is needed for income_band filter. Revised: filtered_core includes customer+customer_address+household_demographics+income_band, then join to customer_demographics, then store_returns.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: single_cte_prejoined_dimensions
TARGET_LOGICAL_TREE:
  prejoined_dims -> store_returns -> main
NODE_CONTRACTS:
  prejoined_dims:
    FROM: customer
    JOIN: INNER JOIN customer_address ON customer.c_current_addr_sk = customer_address.ca_address_sk
          INNER JOIN household_demographics ON customer.c_current_hdemo_sk = household_demographics.hd_demo_sk
          INNER JOIN income_band ON household_demographics.hd_income_band_sk = income_band.ib_income_band_sk
          INNER JOIN customer_demographics ON customer.c_current_cdemo_sk = customer_demographics.cd_demo_sk
    WHERE: customer_address.ca_city = 'Jackson'
           AND income_band.ib_lower_bound >= 23567 AND income_band.ib_upper_bound <= 73567
    OUTPUT: c_customer_id, c_first_name, c_last_name, customer_demographics.cd_demo_sk, (all columns needed)
    EXPECTED_ROWS: ~12
    CONSUMERS: store_returns_join
  store_returns_join:
    FROM: prejoined_dims
    JOIN: INNER JOIN store_returns ON store_returns.sr_cdemo_sk = prejoined_dims.cd_demo_sk
    OUTPUT: c_customer_id, customername (coalesce concatenation)
    EXPECTED_ROWS: ~100 (after limit)
    CONSUMERS: main
EXAMPLES: pg_materialized_dimension_fact_prefilter, pg_self_join_decomposition
EXAMPLE_ADAPTATION:
pg_materialized_dimension_fact_prefilter: Apply materialization of pre-joined dimension filter results into a single CTE. Ignore fact table prefiltering (store_returns not filtered).
pg_self_join_decomposition: Not applicable, but the materialization principle applies: compute dimension joins once.
HAZARD_FLAGS:
- Single CTE may become large if joins aren't selective, but here expected ~12 rows.
- PostgreSQL may inline the CTE, losing materialization benefit. Consider MATERIALIZED keyword.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy