## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 98%  Rows: ~150K
    ├── [~] store_channel  (CTE)
    │   ├── SCAN (store_sales, date_dim, customer)
    │   ├── JOIN (store_sales.ss_sold_date_sk = date_dim.d_date_sk)
    │   ├── JOIN (store_sales.ss_customer_sk = customer.c_customer_sk)
    │   ├── FILTER (d_month_seq BETWEEN 1207 AND 1207 + 11)
    │   ├── FILTER (c_birth_month IN (2, 3, 4, 10))
    │   ├── FILTER (ss_list_price between 241 and 300)
    │   ├── FILTER (ss_wholesale_cost BETWEEN 76 AND 96)
    │   └── OUTPUT (channel, c_last_name, c_first_name, d_date)
    ├── [~] catalog_channel  (CTE)
    │   ├── SCAN (catalog_sales, date_dim, customer)
    │   ├── JOIN (catalog_sales.cs_sold_date_sk = date_dim.d_date_sk)
    │   ├── JOIN (catalog_sales.cs_bill_customer_sk = customer.c_customer_sk)
    │   ├── FILTER (d_month_seq BETWEEN 1207 AND 1207 + 11)
    │   ├── FILTER (c_birth_month IN (2, 3, 4, 10))
    │   ├── FILTER (cs_list_price between 241 and 300)
    │   ├── FILTER (cs_wholesale_cost BETWEEN 76 AND 96)
    │   └── OUTPUT (channel, c_last_name, c_first_name, d_date)
    ├── [~] web_channel  (CTE)
    │   ├── SCAN (web_sales, date_dim, customer)
    │   ├── JOIN (web_sales.ws_sold_date_sk = date_dim.d_date_sk)
    │   ├── JOIN (web_sales.ws_bill_customer_sk = customer.c_customer_sk)
    │   ├── FILTER (d_month_seq BETWEEN 1207 AND 1207 + 11)
    │   ├── FILTER (c_birth_month IN (2, 3, 4, 10))
    │   ├── FILTER (ws_list_price between 241 and 300)
    │   ├── FILTER (ws_wholesale_cost BETWEEN 76 AND 96)
    │   └── OUTPUT (channel, c_last_name, c_first_name, d_date)
    ├── [~] all_channel_sales  (CTE)
    │   ├── UNION ALL (store_channel, catalog_channel, web_channel)
    │   └── OUTPUT (channel, c_last_name, c_first_name, d_date)
    ├── [~] grouped_channels  (CTE)
    │   ├── AGGREGATE (GROUP BY c_last_name, c_first_name, d_date)
    │   ├── FILTER (HAVING count(DISTINCT channel) = 3)
    │   └── OUTPUT (c_last_name, c_first_name, d_date)
    └── OUTPUT (COUNT(*))
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_per_channel",
      "description": "Replace INTERSECT with CTEs for each channel, UNION ALL, and group filtering",
      "applied_to": ["main_query"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "store_channel": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT DISTINCT 'store' AS channel, customer.c_last_name, customer.c_first_name, date_dim.d_date FROM store_sales, date_dim, customer WHERE store_sales.ss_sold_date_sk = date_dim.d_date_sk AND store_sales.ss_customer_sk = customer.c_customer_sk AND date_dim.d_month_seq BETWEEN 1207 AND 1207 + 11 AND customer.c_birth_month IN (2, 3, 4, 10) AND store_sales.ss_list_price BETWEEN 241 AND 300 AND store_sales.ss_wholesale_cost BETWEEN 76 AND 96",
          "interfaces": {
            "outputs": ["channel", "c_last_name", "c_first_name", "d_date"],
            "consumes": []
          }
        },
        "catalog_channel": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT DISTINCT 'catalog' AS channel, customer.c_last_name, customer.c_first_name, date_dim.d_date FROM catalog_sales, date_dim, customer WHERE catalog_sales.cs_sold_date_sk = date_dim.d_date_sk AND catalog_sales.cs_bill_customer_sk = customer.c_customer_sk AND date_dim.d_month_seq BETWEEN 1207 AND 1207 + 11 AND customer.c_birth_month IN (2, 3, 4, 10) AND catalog_sales.cs_list_price BETWEEN 241 AND 300 AND catalog_sales.cs_wholesale_cost BETWEEN 76 AND 96",
          "interfaces": {
            "outputs": ["channel", "c_last_name", "c_first_name", "d_date"],
            "consumes": []
          }
        },
        "web_channel": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT DISTINCT 'web' AS channel, customer.c_last_name, customer.c_first_name, date_dim.d_date FROM web_sales, date_dim, customer WHERE web_sales.ws_sold_date_sk = date_dim.d_date_sk AND web_sales.ws_bill_customer_sk = customer.c_customer_sk AND date_dim.d_month_seq BETWEEN 1207 AND 1207 + 11 AND customer.c_birth_month IN (2, 3, 4, 10) AND web_sales.ws_list_price BETWEEN 241 AND 300 AND web_sales.ws_wholesale_cost BETWEEN 76 AND 96",
          "interfaces": {
            "outputs": ["channel", "c_last_name", "c_first_name", "d_date"],
            "consumes": []
          }
        },
        "all_channel_sales": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT channel, c_last_name, c_first_name, d_date FROM store_channel UNION ALL SELECT channel, c_last_name, c_first_name, d_date FROM catalog_channel UNION ALL SELECT channel, c_last_name, c_first_name, d_date FROM web_channel",
          "interfaces": {
            "outputs": ["channel", "c_last_name", "c_first_name", "d_date"],
            "consumes": ["store_channel", "catalog_channel", "web_channel"]
          }
        },
        "grouped_channels": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT c_last_name, c_first_name, d_date FROM all_channel_sales GROUP BY c_last_name, c_first_name, d_date HAVING COUNT(DISTINCT channel) = 3",
          "interfaces": {
            "outputs": ["c_last_name", "c_first_name", "d_date"],
            "consumes": ["all_channel_sales"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT COUNT(*) FROM grouped_channels LIMIT 100",
          "interfaces": {
            "outputs": ["count"],
            "consumes": ["grouped_channels"]
          }
        }
      },
      "reconstruction_order": ["store_channel", "catalog_channel", "web_channel", "all_channel_sales", "grouped_channels", "main_query"],
      "assembly_template": "WITH store_channel AS ({store_channel}), catalog_channel AS ({catalog_channel}), web_channel AS ({web_channel}), all_channel_sales AS ({all_channel_sales}), grouped_channels AS ({grouped_channels}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '32MB'", "SET LOCAL max_parallel_workers_per_gather = 2", "SET LOCAL jit = off"],
  "validation_checks": []
}
```

**Changes**: Replaced triple INTERSECT with per-channel DISTINCT CTEs → UNION ALL → group by customer/date with HAVING COUNT(DISTINCT channel)=3. This eliminates INTERSECT's row-by-row deduplication overhead while preserving exact semantics.

**Expected speedup**: 2-3× from eliminating INTERSECT's intermediate sorts/unique operations and allowing hash aggregation on the final grouping.