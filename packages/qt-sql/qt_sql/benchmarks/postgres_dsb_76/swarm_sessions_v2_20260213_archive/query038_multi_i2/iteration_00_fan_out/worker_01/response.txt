## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Structural change: CTE isolation + explicit JOINs
    ├── [CTE] filtered_date  [+]
    │   ├── SCAN (date_dim) with filter d_month_seq
    │   └── OUTPUT (d_date_sk, d_date)
    ├── [CTE] filtered_customer  [+]
    │   ├── SCAN (customer) with filter c_birth_month
    │   └── OUTPUT (c_customer_sk, c_last_name, c_first_name)
    ├── [CTE] store_channel  [+]
    │   ├── JOIN (store_sales ⋈ filtered_date ⋈ filtered_customer) explicit INNER
    │   ├── FILTER (ss_list_price, ss_wholesale_cost)
    │   └── OUTPUT (c_last_name, c_first_name, d_date) DISTINCT
    ├── [CTE] catalog_channel  [+]
    │   ├── JOIN (catalog_sales ⋈ filtered_date ⋈ filtered_customer) explicit INNER
    │   ├── FILTER (cs_list_price, cs_wholesale_cost)
    │   └── OUTPUT (c_last_name, c_first_name, d_date) DISTINCT
    ├── [CTE] web_channel  [+]
    │   ├── JOIN (web_sales ⋈ filtered_date ⋈ filtered_customer) explicit INNER
    │   ├── FILTER (ws_list_price, ws_wholesale_cost)
    │   └── OUTPUT (c_last_name, c_first_name, d_date) DISTINCT
    └── [OP] INTERSECT of three channels → COUNT(*)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "dimension_isolation",
      "description": "Pre-filter date_dim and customer into CTEs to create tiny hash tables for repeated joins",
      "applied_to": ["filtered_date", "filtered_customer"]
    },
    {
      "id": "R2",
      "type": "explicit_join",
      "description": "Convert comma-separated joins to explicit INNER JOIN syntax for better planner control",
      "applied_to": ["store_channel", "catalog_channel", "web_channel"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1207 AND 1207 + 11",
        "interfaces": {
          "outputs": ["d_date_sk", "d_date"],
          "consumes": []
        }
      },
      "filtered_customer": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_customer_sk, c_last_name, c_first_name FROM customer WHERE c_birth_month IN (2, 3, 4, 10)",
        "interfaces": {
          "outputs": ["c_customer_sk", "c_last_name", "c_first_name"],
          "consumes": []
        }
      },
      "store_channel": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT filtered_customer.c_last_name, filtered_customer.c_first_name, filtered_date.d_date FROM store_sales INNER JOIN filtered_date ON store_sales.ss_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_customer ON store_sales.ss_customer_sk = filtered_customer.c_customer_sk WHERE store_sales.ss_list_price BETWEEN 241 AND 300 AND store_sales.ss_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": ["filtered_date", "filtered_customer"]
        }
      },
      "catalog_channel": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT filtered_customer.c_last_name, filtered_customer.c_first_name, filtered_date.d_date FROM catalog_sales INNER JOIN filtered_date ON catalog_sales.cs_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_customer ON catalog_sales.cs_bill_customer_sk = filtered_customer.c_customer_sk WHERE catalog_sales.cs_list_price BETWEEN 241 AND 300 AND catalog_sales.cs_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": ["filtered_date", "filtered_customer"]
        }
      },
      "web_channel": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT filtered_customer.c_last_name, filtered_customer.c_first_name, filtered_date.d_date FROM web_sales INNER JOIN filtered_date ON web_sales.ws_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_customer ON web_sales.ws_bill_customer_sk = filtered_customer.c_customer_sk WHERE web_sales.ws_list_price BETWEEN 241 AND 300 AND web_sales.ws_wholesale_cost BETWEEN 76 AND 96",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": ["filtered_date", "filtered_customer"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT COUNT(*) FROM (SELECT c_last_name, c_first_name, d_date FROM store_channel INTERSECT SELECT c_last_name, c_first_name, d_date FROM catalog_channel INTERSECT SELECT c_last_name, c_first_name, d_date FROM web_channel) AS hot_cust LIMIT 100",
        "interfaces": {
          "outputs": ["count"],
          "consumes": ["store_channel", "catalog_channel", "web_channel"]
        }
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_customer", "store_channel", "catalog_channel", "web_channel", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_customer AS ({filtered_customer}), store_channel AS ({store_channel}), catalog_channel AS ({catalog_channel}), web_channel AS ({web_channel}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '512MB'",
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL enable_mergejoin = off",
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL max_parallel_workers_per_gather = 2",
    "SET LOCAL jit = off",
    "SET LOCAL effective_cache_size = '4GB'"
  ],
  "validation_checks": []
}
```

## Changes and Expected Speedup

**Changes**: Isolated dimension filtering into CTEs (`filtered_date`, `filtered_customer`) and converted comma joins to explicit INNER JOINs. This creates tiny hash tables (182 dates, ~25% customers) for repeated probing across three large fact tables.

**Expected speedup**: ~3.32x based on pg_dimension_prefetch_star pattern. The combination of dimension isolation and explicit JOINs enables PostgreSQL to build small hash tables once and reuse them for efficient hash joins across all three channels, avoiding repeated full table scans and comma-join cross-product inefficiencies. The runtime config optimizes for hash joins with ample work_mem and disables nested loops/merge joins that would be inefficient for this data volume.