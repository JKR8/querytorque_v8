## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~6.0M
    ├── [~] WITH filtered_dates CTE (isolates date_dim filter)
    │   ├── SCAN date_dim
    │   ├── FILTER (d_month_seq BETWEEN 1200 AND 1200 + 11)
    │   └── OUTPUT (d_date_sk, d_date)
    ├── [~] WITH filtered_customers CTE (isolates customer filter)
    │   ├── SCAN customer
    │   ├── FILTER (c_birth_month IN (1, 2, 5, 12))
    │   └── OUTPUT (c_customer_sk, c_last_name, c_first_name)
    ├── [~] store_subquery (explicit JOIN + CTE references)
    │   ├── JOIN filtered_dates d ON ss_sold_date_sk = d.d_date_sk
    │   ├── JOIN filtered_customers c ON ss_customer_sk = c.c_customer_sk
    │   ├── FILTER (ss_list_price BETWEEN 193 AND 252)
    │   ├── FILTER (ss_wholesale_cost BETWEEN 35 AND 55)
    │   └── OUTPUT (c_last_name, c_first_name, d_date)
    ├── [~] catalog_subquery (explicit JOIN + CTE references)
    │   ├── JOIN filtered_dates d ON cs_sold_date_sk = d.d_date_sk
    │   ├── JOIN filtered_customers c ON cs_bill_customer_sk = c.c_customer_sk
    │   ├── FILTER (cs_list_price BETWEEN 193 AND 252)
    │   ├── FILTER (cs_wholesale_cost BETWEEN 35 AND 55)
    │   └── OUTPUT (c_last_name, c_first_name, d_date)
    ├── [~] web_subquery (explicit JOIN + CTE references)
    │   ├── JOIN filtered_dates d ON ws_sold_date_sk = d.d_date_sk
    │   ├── JOIN filtered_customers c ON ws_bill_customer_sk = c.c_customer_sk
    │   ├── FILTER (ws_list_price BETWEEN 193 AND 252)
    │   ├── FILTER (ws_wholesale_cost BETWEEN 35 AND 55)
    │   └── OUTPUT (c_last_name, c_first_name, d_date)
    ├── INTERSECT (unchanged)
    └── OUTPUT (COUNT(*))
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefetch_cte", "description": "Pre-filter date_dim and customer into CTEs to create tiny hash tables", "applied_to": ["filtered_dates", "filtered_customers"]},
    {"id": "R2", "type": "explicit_join_syntax", "description": "Convert comma-separated joins to explicit INNER JOIN syntax", "applied_to": ["store_subquery", "catalog_subquery", "web_subquery"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1200 AND 1200 + 11",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "filtered_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_customer_sk, c_last_name, c_first_name FROM customer WHERE c_birth_month IN (1, 2, 5, 12)",
        "interfaces": {"outputs": ["c_customer_sk", "c_last_name", "c_first_name"], "consumes": []}
      },
      "store_subquery": {
        "type": "subquery",
        "change": "modified",
        "sql": "SELECT DISTINCT c.c_last_name, c.c_first_name, d.d_date FROM store_sales ss INNER JOIN filtered_dates d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN filtered_customers c ON ss.ss_customer_sk = c.c_customer_sk WHERE ss.ss_list_price BETWEEN 193 AND 252 AND ss.ss_wholesale_cost BETWEEN 35 AND 55",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_dates", "filtered_customers"]}
      },
      "catalog_subquery": {
        "type": "subquery",
        "change": "modified",
        "sql": "SELECT DISTINCT c.c_last_name, c.c_first_name, d.d_date FROM catalog_sales cs INNER JOIN filtered_dates d ON cs.cs_sold_date_sk = d.d_date_sk INNER JOIN filtered_customers c ON cs.cs_bill_customer_sk = c.c_customer_sk WHERE cs.cs_list_price BETWEEN 193 AND 252 AND cs.cs_wholesale_cost BETWEEN 35 AND 55",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_dates", "filtered_customers"]}
      },
      "web_subquery": {
        "type": "subquery",
        "change": "modified",
        "sql": "SELECT DISTINCT c.c_last_name, c.c_first_name, d.d_date FROM web_sales ws INNER JOIN filtered_dates d ON ws.ws_sold_date_sk = d.d_date_sk INNER JOIN filtered_customers c ON ws.ws_bill_customer_sk = c.c_customer_sk WHERE ws.ws_list_price BETWEEN 193 AND 252 AND ws.ws_wholesale_cost BETWEEN 35 AND 55",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_dates", "filtered_customers"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT COUNT(*) FROM (SELECT * FROM store_subquery INTERSECT SELECT * FROM catalog_subquery INTERSECT SELECT * FROM web_subquery) hot_cust LIMIT 100",
        "interfaces": {"outputs": ["count"], "consumes": ["store_subquery", "catalog_subquery", "web_subquery"]}
      }
    },
    "reconstruction_order": ["filtered_dates", "filtered_customers", "store_subquery", "catalog_subquery", "web_subquery", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), filtered_customers AS ({filtered_customers}), store_subquery AS ({store_subquery}), catalog_subquery AS ({catalog_subquery}), web_subquery AS ({web_subquery}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '64MB'", "SET LOCAL hash_mem_multiplier = 2.0", "SET LOCAL enable_nestloop = off", "SET LOCAL enable_mergejoin = off"],
  "validation_checks": []
}
```

**Changes:** Isolated date_dim and customer filters into CTEs to create tiny hash tables (183 rows and ~25% of customer), then converted all comma-separated joins to explicit INNER JOIN syntax. This combination enables PostgreSQL to build efficient hash join plans with small dimension tables.

**Expected speedup:** 2.5–3.5× (based on pg_date_cte_explicit_join + pg_dimension_prefetch_star patterns). The explicit JOIN syntax prevents comma-join planning ambiguity, while CTEs give accurate cardinality estimates for the small dimension filters.