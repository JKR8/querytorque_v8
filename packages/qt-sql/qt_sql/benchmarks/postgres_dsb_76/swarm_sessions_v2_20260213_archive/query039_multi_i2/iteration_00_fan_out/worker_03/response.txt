### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_star_month5  [+]  Cost: 15%  Rows: ~5K
│   ├── SCAN (inventory, date_dim, item, warehouse)
│   ├── JOIN (inv_date_sk = d_date_sk)
│   ├── JOIN (inv_item_sk = i_item_sk)
│   ├── JOIN (inv_warehouse_sk = w_warehouse_sk)
│   ├── FILTER (d_year=2002 AND d_moy=5 AND i_category IN ('Shoes','Sports') AND i_manager_id BETWEEN 42 AND 61 AND inv_quantity_on_hand BETWEEN 791 AND 991)
│   └── OUTPUT (w_warehouse_sk, w_warehouse_name, i_item_sk, inv_quantity_on_hand)
├── [CTE] aggregated5  [+]  Cost: 10%  Rows: ~100s
│   ├── FROM filtered_star_month5
│   ├── GROUP BY (w_warehouse_name, w_warehouse_sk, i_item_sk)
│   ├── AGGREGATE (STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean)
│   └── OUTPUT (w_warehouse_name, w_warehouse_sk, i_item_sk, stdev, mean)
├── [CTE] filtered_cov5  [+]  Cost: 5%  Rows: ~10s
│   ├── FROM aggregated5
│   ├── FILTER (CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1)
│   └── OUTPUT (w_warehouse_sk, i_item_sk, mean AS mean_5, stdev/mean AS cov_5)
├── [CTE] filtered_star_month6  [+]  Cost: 15%  Rows: ~5K
│   ├── SCAN (inventory, date_dim, item, warehouse)
│   ├── JOIN (inv_date_sk = d_date_sk)
│   ├── JOIN (inv_item_sk = i_item_sk)
│   ├── JOIN (inv_warehouse_sk = w_warehouse_sk)
│   ├── FILTER (d_year=2002 AND d_moy=6 AND i_category IN ('Shoes','Sports') AND i_manager_id BETWEEN 42 AND 61 AND inv_quantity_on_hand BETWEEN 791 AND 991)
│   └── OUTPUT (w_warehouse_sk, w_warehouse_name, i_item_sk, inv_quantity_on_hand)
├── [CTE] aggregated6  [+]  Cost: 10%  Rows: ~100s
│   ├── FROM filtered_star_month6
│   ├── GROUP BY (w_warehouse_name, w_warehouse_sk, i_item_sk)
│   ├── AGGREGATE (STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean)
│   └── OUTPUT (w_warehouse_name, w_warehouse_sk, i_item_sk, stdev, mean)
├── [CTE] filtered_cov6  [+]  Cost: 5%  Rows: ~10s
│   ├── FROM aggregated6
│   ├── FILTER (CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1)
│   └── OUTPUT (w_warehouse_sk, i_item_sk, mean AS mean_6, stdev/mean AS cov_6)
└── [MAIN] main_join_reduced  [~]  Cost: 40%  Rows: ~10s
    ├── FROM (filtered_cov5 AS inv1 INNER JOIN filtered_cov6 AS inv2)
    ├── JOIN (inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk)
    ├── ORDER BY (inv1.w_warehouse_sk, inv1.i_item_sk, 5, inv1.mean_5, inv1.cov_5, 6, inv2.mean_6, inv2.cov_6)
    └── OUTPUT (inv1.w_warehouse_sk, inv1.i_item_sk, 5 AS inv1_d_moy, inv1.mean_5 AS inv1_mean, inv1.cov_5 AS inv1_cov,
                inv2.w_warehouse_sk, inv2.i_item_sk, 6 AS inv2_d_moy, inv2.mean_6 AS inv2_mean, inv2.cov_6 AS inv2_cov)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "pg_self_join_decomposition",
      "description": "Split single CTE with d_moy grouping into separate CTEs for month 5 and month 6, filtering early by month",
      "applied_to": ["filtered_star_month5", "filtered_star_month6"]
    },
    {
      "id": "R2",
      "type": "early_filter_decorrelate",
      "description": "Push month filters into CTE definitions before aggregation and cov>1 filtering",
      "applied_to": ["filtered_star_month5", "filtered_star_month6"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_star_month5": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT w.w_warehouse_sk, w.w_warehouse_name, i.i_item_sk, inv.inv_quantity_on_hand FROM inventory inv JOIN date_dim d ON inv.inv_date_sk = d.d_date_sk JOIN item i ON inv.inv_item_sk = i.i_item_sk JOIN warehouse w ON inv.inv_warehouse_sk = w.w_warehouse_sk WHERE d.d_year = 2002 AND d.d_moy = 5 AND i.i_category IN ('Shoes', 'Sports') AND i.i_manager_id BETWEEN 42 AND 61 AND inv.inv_quantity_on_hand BETWEEN 791 AND 991",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "w_warehouse_name", "i_item_sk", "inv_quantity_on_hand"],
            "consumes": []
          }
        },
        "aggregated5": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean FROM filtered_star_month5 GROUP BY w_warehouse_name, w_warehouse_sk, i_item_sk",
          "interfaces": {
            "outputs": ["w_warehouse_name", "w_warehouse_sk", "i_item_sk", "stdev", "mean"],
            "consumes": ["filtered_star_month5"]
          }
        },
        "filtered_cov5": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT w_warehouse_sk, i_item_sk, mean AS mean_5, CASE mean WHEN 0 THEN 0 ELSE stdev/mean END AS cov_5 FROM aggregated5 WHERE CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "mean_5", "cov_5"],
            "consumes": ["aggregated5"]
          }
        },
        "filtered_star_month6": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT w.w_warehouse_sk, w.w_warehouse_name, i.i_item_sk, inv.inv_quantity_on_hand FROM inventory inv JOIN date_dim d ON inv.inv_date_sk = d.d_date_sk JOIN item i ON inv.inv_item_sk = i.i_item_sk JOIN warehouse w ON inv.inv_warehouse_sk = w.w_warehouse_sk WHERE d.d_year = 2002 AND d.d_moy = 6 AND i.i_category IN ('Shoes', 'Sports') AND i.i_manager_id BETWEEN 42 AND 61 AND inv.inv_quantity_on_hand BETWEEN 791 AND 991",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "w_warehouse_name", "i_item_sk", "inv_quantity_on_hand"],
            "consumes": []
          }
        },
        "aggregated6": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean FROM filtered_star_month6 GROUP BY w_warehouse_name, w_warehouse_sk, i_item_sk",
          "interfaces": {
            "outputs": ["w_warehouse_name", "w_warehouse_sk", "i_item_sk", "stdev", "mean"],
            "consumes": ["filtered_star_month6"]
          }
        },
        "filtered_cov6": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT w_warehouse_sk, i_item_sk, mean AS mean_6, CASE mean WHEN 0 THEN 0 ELSE stdev/mean END AS cov_6 FROM aggregated6 WHERE CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "mean_6", "cov_6"],
            "consumes": ["aggregated6"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT inv1.w_warehouse_sk, inv1.i_item_sk, 5 AS inv1_d_moy, inv1.mean_5 AS inv1_mean, inv1.cov_5 AS inv1_cov, inv2.w_warehouse_sk, inv2.i_item_sk, 6 AS inv2_d_moy, inv2.mean_6 AS inv2_mean, inv2.cov_6 AS inv2_cov FROM filtered_cov5 inv1 INNER JOIN filtered_cov6 inv2 ON inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk ORDER BY inv1.w_warehouse_sk, inv1.i_item_sk, 5, inv1.mean_5, inv1.cov_5, 6, inv2.mean_6, inv2.cov_6",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "inv1_d_moy", "inv1_mean", "inv1_cov", "w_warehouse_sk", "i_item_sk", "inv2_d_moy", "inv2_mean", "inv2_cov"],
            "consumes": ["filtered_cov5", "filtered_cov6"]
          }
        }
      },
      "reconstruction_order": ["filtered_star_month5", "aggregated5", "filtered_cov5", "filtered_star_month6", "aggregated6", "filtered_cov6", "main_query"],
      "assembly_template": "WITH filtered_star_month5 AS ({filtered_star_month5}), aggregated5 AS ({aggregated5}), filtered_cov5 AS ({filtered_cov5}), filtered_star_month6 AS ({filtered_star_month6}), aggregated6 AS ({aggregated6}), filtered_cov6 AS ({filtered_cov6}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Decomposed the single CTE with d_moy grouping into separate CTEs for month 5 and month 6, pushing month filters early into each CTE definition before aggregation and coefficient of variation filtering. This allows PostgreSQL to use parallel table scans on inventory for each month independently while maintaining semantic equivalence.

**Expected speedup:** 2-3x from parallel table scan enablement and reduced aggregation size (5K rows per month instead of 10K total). The early filtering by month before cov>1 evaluation prevents unnecessary computation for non-matching months.