You are a SQL rewrite engine for PostgreSQL v16.11-0ubuntu0.24.04.1). Follow the Target Logical Tree structure below. Your job is to write correct, executable SQL for each node — not to decide whether to restructure. Preserve exact semantic equivalence (same rows, same columns, same ordering). Preserve defensive guards: if the original uses CASE WHEN x > 0 THEN y/x END around a division, keep it — even when a WHERE clause makes the zero case unreachable. Guards prevent silent breakage if filters change upstream. Strip benchmark comments (-- start query, -- end query) from your output.

## Semantic Contract (MUST preserve)

This query analyzes inventory variability, comparing coefficient of variation between consecutive months (May vs June 2002) for Sports/Shoes items managed by specific managers. The business intent is to identify items with high inventory volatility. JOIN semantics are INNER throughout—all dimension tables must match the fact table, and the self-join requires matching warehouse and item. Aggregation trap: STDDEV_SAMP requires ≥2 values per group; NULL groups are filtered out by CASE mean WHEN 0 THEN NULL. Filter dependencies: The cov>1 filter in CTE must be applied BEFORE the self-join; the d_moy=5/6 filters in main query are independent per side.

## Target Logical Tree + Node Contracts

Build your rewrite following this CTE structure. Each node's OUTPUT list is exhaustive — your SQL must produce exactly those columns.

TARGET_LOGICAL_TREE:
filtered_star_month5 -> aggregated5 -> filtered_cov5 -> 
  filtered_star_month6 -> aggregated6 -> filtered_cov6 -> 
  main_join_reduced
NODE_CONTRACTS:
  filtered_star_month5:
    FROM: inventory 
    JOIN: date_dim ON inv_date_sk = d_date_sk
    JOIN: item ON inv_item_sk = i_item_sk  
    JOIN: warehouse ON inv_warehouse_sk = w_warehouse_sk
    WHERE: d_year = 2002 AND d_moy = 5 AND i_category IN ('Shoes', 'Sports') 
           AND i_manager_id BETWEEN 42 AND 61 AND inv_quantity_on_hand BETWEEN 791 AND 991
    OUTPUT: w_warehouse_sk, w_warehouse_name, i_item_sk, inv_quantity_on_hand
    EXPECTED_ROWS: ~5K
    CONSUMERS: aggregated5
  aggregated5:
    FROM: filtered_star_month5
    GROUP BY: w_warehouse_name, w_warehouse_sk, i_item_sk
    AGGREGATE: STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean
    OUTPUT: w_warehouse_name, w_warehouse_sk, i_item_sk, stdev, mean
    EXPECTED_ROWS: ~100s
    CONSUMERS: filtered_cov5
  filtered_cov5:
    FROM: aggregated5
    WHERE: CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1
    OUTPUT: w_warehouse_sk, i_item_sk, mean AS mean_5, stdev/mean AS cov_5
    EXPECTED_ROWS: ~10s
    CONSUMERS: main_join_reduced
  filtered_star_month6:
    FROM: inventory 
    JOIN: date_dim ON inv_date_sk = d_date_sk
    JOIN: item ON inv_item_sk = i_item_sk  
    JOIN: warehouse ON inv_warehouse_sk = w_warehouse_sk
    WHERE: d_year = 2002 AND d_moy = 6 AND i_category IN ('Shoes', 'Sports') 
           AND i_manager_id BETWEEN 42 AND 61 AND inv_quantity_on_hand BETWEEN 791 AND 991
    OUTPUT: w_warehouse_sk, w_warehouse_name, i_item_sk, inv_quantity_on_hand
    EXPECTED_ROWS: ~5K
    CONSUMERS: aggregated6
  aggregated6:
    FROM: filtered_star_month6
    GROUP BY: w_warehouse_name, w_warehouse_sk, i_item_sk
    AGGREGATE: STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean
    OUTPUT: w_warehouse_name, w_warehouse_sk, i_item_sk, stdev, mean
    EXPECTED_ROWS: ~100s
    CONSUMERS: filtered_cov6
  filtered_cov6:
    FROM: aggregated6
    WHERE: CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1
    OUTPUT: w_warehouse_sk, i_item_sk, mean AS mean_6, stdev/mean AS cov_6
    EXPECTED_ROWS: ~10s
    CONSUMERS: main_join_reduced
  main_join_reduced:
    FROM: filtered_cov5 AS inv1 INNER JOIN filtered_cov6 AS inv2 ON inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk
    ORDER BY: inv1.w_warehouse_sk, inv1.i_item_sk, 5, inv1.mean_5, inv1.cov_5, 6, inv2.mean_6, inv2.cov_6
    OUTPUT: inv1.w_warehouse_sk, inv1.i_item_sk, 5 AS inv1_d_moy, inv1.mean_5 AS inv1_mean, inv1.cov_5 AS inv1_cov,
            inv2.w_warehouse_sk, inv2.i_item_sk, 6 AS inv2_d_moy, inv2.mean_6 AS inv2_mean, inv2.cov_6 AS inv2_cov
    EXPECTED_ROWS: ~10s
    CONSUMERS: final

NODE_CONTRACTS:
filtered_star_month5:
    FROM: inventory 
    JOIN: date_dim ON inv_date_sk = d_date_sk
    JOIN: item ON inv_item_sk = i_item_sk  
    JOIN: warehouse ON inv_warehouse_sk = w_warehouse_sk
    WHERE: d_year = 2002 AND d_moy = 5 AND i_category IN ('Shoes', 'Sports') 
           AND i_manager_id BETWEEN 42 AND 61 AND inv_quantity_on_hand BETWEEN 791 AND 991
    OUTPUT: w_warehouse_sk, w_warehouse_name, i_item_sk, inv_quantity_on_hand
    EXPECTED_ROWS: ~5K
    CONSUMERS: aggregated5
  aggregated5:
    FROM: filtered_star_month5
    GROUP BY: w_warehouse_name, w_warehouse_sk, i_item_sk
    AGGREGATE: STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean
    OUTPUT: w_warehouse_name, w_warehouse_sk, i_item_sk, stdev, mean
    EXPECTED_ROWS: ~100s
    CONSUMERS: filtered_cov5
  filtered_cov5:
    FROM: aggregated5
    WHERE: CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1
    OUTPUT: w_warehouse_sk, i_item_sk, mean AS mean_5, stdev/mean AS cov_5
    EXPECTED_ROWS: ~10s
    CONSUMERS: main_join_reduced
  filtered_star_month6:
    FROM: inventory 
    JOIN: date_dim ON inv_date_sk = d_date_sk
    JOIN: item ON inv_item_sk = i_item_sk  
    JOIN: warehouse ON inv_warehouse_sk = w_warehouse_sk
    WHERE: d_year = 2002 AND d_moy = 6 AND i_category IN ('Shoes', 'Sports') 
           AND i_manager_id BETWEEN 42 AND 61 AND inv_quantity_on_hand BETWEEN 791 AND 991
    OUTPUT: w_warehouse_sk, w_warehouse_name, i_item_sk, inv_quantity_on_hand
    EXPECTED_ROWS: ~5K
    CONSUMERS: aggregated6
  aggregated6:
    FROM: filtered_star_month6
    GROUP BY: w_warehouse_name, w_warehouse_sk, i_item_sk
    AGGREGATE: STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean
    OUTPUT: w_warehouse_name, w_warehouse_sk, i_item_sk, stdev, mean
    EXPECTED_ROWS: ~100s
    CONSUMERS: filtered_cov6
  filtered_cov6:
    FROM: aggregated6
    WHERE: CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1
    OUTPUT: w_warehouse_sk, i_item_sk, mean AS mean_6, stdev/mean AS cov_6
    EXPECTED_ROWS: ~10s
    CONSUMERS: main_join_reduced
  main_join_reduced:
    FROM: filtered_cov5 AS inv1 INNER JOIN filtered_cov6 AS inv2 ON inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk
    ORDER BY: inv1.w_warehouse_sk, inv1.i_item_sk, 5, inv1.mean_5, inv1.cov_5, 6, inv2.mean_6, inv2.cov_6
    OUTPUT: inv1.w_warehouse_sk, inv1.i_item_sk, 5 AS inv1_d_moy, inv1.mean_5 AS inv1_mean, inv1.cov_5 AS inv1_cov,
            inv2.w_warehouse_sk, inv2.i_item_sk, 6 AS inv2_d_moy, inv2.mean_6 AS inv2_mean, inv2.cov_6 AS inv2_cov
    EXPECTED_ROWS: ~10s
    CONSUMERS: final

## Hazard Flags (avoid these specific risks)

- Duplicates inventory scan (2x) but each scan is smaller (filtered by month)
- Must ensure both month CTEs include same warehouse/item combinations for join

## Regression Warnings (observed failures on similar queries)

1. CTE blocking parallelism (observed regression in Q045):
   CAUSE: Materialized CTE prevents parallel table scan on inventory
   RULE: Use LATERAL or subquery instead of CTE for fact table scan when parallel execution is needed
2. UNION ALL over-splitting (observed 0.21x on Q085):
   CAUSE: Splitting OR conditions into UNION ALL when PostgreSQL's bitmap scan handles it better
   RULE: Do NOT convert OR to UNION ALL—this query has no OR conditions requiring split

## Constraints (analyst-filtered for this query)

- COMPLETE_OUTPUT: Must output 10 columns in exact order: inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov, inv2.w_warehouse_sk, inv2.i_item_sk, inv2.d_moy, inv2.mean, inv2.cov
- CTE_COLUMN_COMPLETENESS: Any CTE must include w_warehouse_sk, i_item_sk, d_moy, mean, cov for downstream self-join and SELECT
- LITERAL_PRESERVATION: Must preserve literal values: 2002, 'Shoes','Sports', 42, 61, 791, 991, 5, 1, 1.5 (second query)
- SEMANTIC_EQUIVALENCE: Must return same rows—cov>1 filter in CTE and month filters in main query are critical
- COMMA_JOIN_WEAKNESS: CTE uses comma-separated joins (inventory, item, warehouse, date_dim)
- CROSS_CTE_PREDICATE_BLINDNESS: CTE contains all months, filtered late in main query (d_moy=5/6)

## Example Adaptation Notes

For each example: what to apply to your rewrite, and what to ignore.

- pg_self_join_decomposition: Apply separate CTEs for each month; ignore single materialization aspect
- union_cte_split: Apply splitting by discriminator (month); ignore UNION ALL structure
- early_filter_decorrelate: Apply early month filtering; ignore decorrelation

## Reference Examples

Pattern reference only — do not copy table/column names or literals.

### 1. pg_self_join_decomposition (3.93x)

**Principle:** Shared Materialization (PG): when the same fact+dimension scan appears multiple times in self-join patterns, materialize it once as a CTE and derive all needed aggregates from the same result. PostgreSQL materializes CTEs by default, making this extremely effective.

**BEFORE (slow):**
```sql
select 
	s_store_name,
	i_item_desc,
	sc.revenue,
	i_current_price,
	i_wholesale_cost,
	i_brand
 from store, item,
     (select ss_store_sk, avg(revenue) as ave
	from
	    (select  ss_store_sk, ss_item_sk,
		     sum(ss_sales_price) as revenue
		from store_sales, date_dim
		where ss_sold_date_sk = d_date_sk and d_month_seq between 1213 and 1213+11
   and ss_sales_price / ss_list_price BETWEEN 38 * 0.01 AND 48 * 0.01
		group by ss_store_sk, ss_item_sk) sa
	group by ss_store_sk) sb,
     (select  ss_store_sk, ss_item_sk, sum(ss_sales_price) as revenue
	from store_sales, date_dim
	where ss_sold_date_sk = d_date_sk and d_month_seq between 1213 and 1213+11
  and ss_sales_price / ss_list_price BETWEEN 38 * 0.01 AND 48 * 0.01
	group by ss_store_sk, ss_item_sk) sc
 where sb.ss_store_sk = sc.ss_store_sk and
       sc.revenue <= 0.1 * sb.ave and
       s_store_sk = sc.ss_store_sk and
       i_item_sk = sc.ss_item_sk
       and i_manager_id BETWEEN 32 and 36
       and s_state in ('TN','TX','VA')
 order by s_store_name, i_item_desc
limit 100;
```

**AFTER (fast):**
[date_filter]:
```sql
SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1213 AND 1224
```
[store_sales_revenue]:
```sql
SELECT ss_store_sk, ss_item_sk, SUM(ss_sales_price) AS revenue FROM store_sales JOIN date_filter ON ss_sold_date_sk = d_date_sk WHERE ss_sales_price / ss_list_price BETWEEN 0.38 AND 0.48 GROUP BY ss_store_sk, ss_item_sk
```
[store_avg_revenue]:
```sql
SELECT ss_store_sk, AVG(revenue) AS ave FROM store_sales_revenue GROUP BY ss_store_sk
```
[filtered_store]:
```sql
SELECT s_store_sk, s_store_name FROM store WHERE s_state IN ('TN', 'TX', 'VA')
```
[filtered_item]:
```sql
SELECT i_item_sk, i_item_desc, i_current_price, i_wholesale_cost, i_brand FROM item WHERE i_manager_id BETWEEN 32 AND 36
```
[main_query]:
```sql
SELECT s_store_name, i_item_desc, sc.revenue, i_current_price, i_wholesale_cost, i_brand FROM store_avg_revenue AS sb JOIN store_sales_revenue AS sc ON sb.ss_store_sk = sc.ss_store_sk JOIN filtered_store AS s ON sc.ss_store_sk = s.s_store_sk JOIN filtered_item AS i ON sc.ss_item_sk = i.i_item_sk WHERE sc.revenue <= 0.1 * sb.ave ORDER BY s_store_name, i_item_desc LIMIT 100
```

### 2. early_filter_decorrelate (1.13x)

**Principle:** Early Selection + Decorrelation: push dimension filters into CTE definitions before materialization, and decorrelate correlated subqueries by pre-computing thresholds in separate CTEs. Filters reduce rows early; decorrelation replaces per-row subquery execution with a single pre-computed JOIN.

**BEFORE (slow):**
```sql
WITH customer_total_return AS (
  SELECT sr_customer_sk AS ctr_customer_sk,
         sr_store_sk AS ctr_store_sk,
         sr_reason_sk AS ctr_reason_sk,
         SUM(SR_REFUNDED_CASH) AS ctr_total_return
  FROM store_returns, date_dim
  WHERE sr_returned_date_sk = d_date_sk
    AND d_year = 2001
    AND sr_return_amt / sr_return_quantity BETWEEN 236 AND 295
  GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk
)
SELECT c_customer_id
FROM customer_total_return ctr1, store, customer, customer_demographics
WHERE ctr1.ctr_total_return > (
    SELECT AVG(ctr_total_return) * 1.2
    FROM customer_total_return ctr2
    WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk
  )
  AND ctr1.ctr_reason_sk BETWEEN 28 AND 31
  AND s_store_sk = ctr1.ctr_store_sk
  AND s_state IN ('MI', 'NC', 'WI')
  AND ctr1.ctr_customer_sk = c_customer_sk
  AND c_current_cdemo_sk = cd_demo_sk
  AND cd_marital_status IN ('W', 'W')
  AND cd_education_status IN ('4 yr Degree', 'College')
  AND cd_gender = 'M'
  AND c_birth_month = 5
  AND c_birth_year BETWEEN 1950 AND 1956
ORDER BY c_customer_id
LIMIT 100
```

**AFTER (fast):**
```sql
WITH customer_total_return AS (
    SELECT sr_customer_sk AS ctr_customer_sk,
           sr_store_sk AS ctr_store_sk,
           sr_reason_sk AS ctr_reason_sk,
           SUM(SR_REFUNDED_CASH) AS ctr_total_return
    FROM store_returns
    JOIN date_dim ON sr_returned_date_sk = d_date_sk
    JOIN store ON sr_store_sk = s_store_sk
    WHERE d_year = 2001
      AND s_state IN ('MI', 'NC', 'WI')
      AND sr_return_amt / sr_return_quantity BETWEEN 236 AND 295
    GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk
),
store_thresholds AS (
    SELECT ctr_store_sk,
           AVG(ctr_total_return) * 1.2 AS avg_limit
    FROM customer_total_return
    GROUP BY ctr_store_sk
)
SELECT c_customer_id
FROM customer_total_return ctr1
JOIN store_thresholds st ON ctr1.ctr_store_sk = st.ctr_store_sk
JOIN customer ON ctr1.ctr_customer_sk = c_customer_sk
JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk
JOIN store s ON ctr1.ctr_store_sk = s.s_store_sk
WHERE ctr1.ctr_total_return > st.avg_limit
  AND ctr1.ctr_reason_sk BETWEEN 28 AND 31
  AND s.s_state IN ('MI', 'NC', 'WI')
  AND cd_marital_status = 'W'
  AND cd_education_status IN ('4 yr Degree', 'College')
  AND cd_gender = 'M'
  AND c_birth_month = 5
  AND c_birth_year BETWEEN 1950 AND 1956
ORDER BY c_customer_id
LIMIT 100
```

## Original SQL

```sql
with inv as
(select w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy
       ,stdev,mean, case mean when 0 then null else stdev/mean end cov
 from(select w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy
            ,stddev_samp(inv_quantity_on_hand) stdev,avg(inv_quantity_on_hand) mean
      from inventory
          ,item
          ,warehouse
          ,date_dim
      where inv_item_sk = i_item_sk
        and inv_warehouse_sk = w_warehouse_sk
        and inv_date_sk = d_date_sk
        and d_year =2002
        and i_category IN ('Shoes', 'Sports')
        and i_manager_id BETWEEN 42 and 61
        and inv_quantity_on_hand between 791 and 991
      group by w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy) foo
 where case mean when 0 then 0 else stdev/mean end > 1)
select inv1.w_warehouse_sk,inv1.i_item_sk,inv1.d_moy,inv1.mean, inv1.cov
        ,inv2.w_warehouse_sk,inv2.i_item_sk,inv2.d_moy,inv2.mean, inv2.cov
from inv inv1,inv inv2
where inv1.i_item_sk = inv2.i_item_sk
  and inv1.w_warehouse_sk =  inv2.w_warehouse_sk
  and inv1.d_moy=5
  and inv2.d_moy=5+1
order by inv1.w_warehouse_sk,inv1.i_item_sk,inv1.d_moy,inv1.mean,inv1.cov
        ,inv2.d_moy,inv2.mean, inv2.cov
;
with inv as
(select w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy
       ,stdev,mean, case mean when 0 then null else stdev/mean end cov
 from(select w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy
            ,stddev_samp(inv_quantity_on_hand) stdev,avg(inv_quantity_on_hand) mean
      from inventory
          ,item
          ,warehouse
          ,date_dim
      where inv_item_sk = i_item_sk
        and inv_warehouse_sk = w_warehouse_sk
        and inv_date_sk = d_date_sk
        and d_year =2002
        and i_category IN ('Shoes', 'Sports')
        and i_manager_id BETWEEN 42 and 61
        and inv_quantity_on_hand between 791 and 991
      group by w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy) foo
 where case mean when 0 then 0 else stdev/mean end > 1)
select inv1.w_warehouse_sk,inv1.i_item_sk,inv1.d_moy,inv1.mean, inv1.cov
        ,inv2.w_warehouse_sk,inv2.i_item_sk,inv2.d_moy,inv2.mean, inv2.cov
from inv inv1,inv inv2
where inv1.i_item_sk = inv2.i_item_sk
  and inv1.w_warehouse_sk =  inv2.w_warehouse_sk
  and inv1.d_moy=5
  and inv2.d_moy=5+1
  and inv1.cov > 1.5
order by inv1.w_warehouse_sk,inv1.i_item_sk,inv1.d_moy,inv1.mean,inv1.cov
        ,inv2.d_moy,inv2.mean, inv2.cov
;
```

## Rewrite Checklist (must pass before final SQL)

- Follow every node in `TARGET_LOGICAL_TREE` and produce each `NODE_CONTRACT` output column exactly.
- Keep all semantic invariants from `Semantic Contract` and `Constraints` (including join/null behavior).
- Preserve all literals and the exact final output schema/order.
- Apply `Hazard Flags` and `Regression Warnings` as hard guards against known failure modes.

## Original Query Structure

This is the current query structure. All nodes are `[=]` (unchanged). Your modified Logic Tree below should show which nodes you changed.

```
QUERY: (single statement)
├── [CTE] inv  [=]  Cost: 50%  Rows: ~1K
│   ├── SCAN (inventory, item, warehouse, date_dim)
│   ├── FILTER (CASE mean WHEN 0 THEN 0 ELSE stdev / mean END > 1)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy, stdev, mean, cov)
└── [MAIN] main_query  [=]  Cost: 50%  Rows: ~1K
    ├── SCAN (inv AS inv1 (join), inv AS inv2 (join))
    ├── JOIN (inv1.i_item_sk = inv2.i_item_sk)
    ├── JOIN (inv1.w_warehouse_sk = inv2.w_warehouse_sk)
    ├── FILTER (inv1.d_moy = 5)
    ├── FILTER (inv2.d_moy = 5 + 1)
    ├── AGG (GROUP BY)
    ├── SORT (inv1.w_warehouse_sk ASC, inv1.i_item_sk ASC, inv1.d_moy ASC, inv1.mean ASC, inv1.cov ASC, inv2.d_moy ASC, inv2.mean ASC, inv2.cov ASC)
    └── OUTPUT (w_warehouse_sk, i_item_sk, d_moy, mean, cov, w_warehouse_sk, i_item_sk, d_moy, ...)
```

## Output Format

Your response has **two parts** in order:

### Part 1: Modified Logic Tree

Show what changed using change markers. Generate the tree BEFORE writing SQL.

Change markers:
- `[+]` — New component added
- `[-]` — Component removed
- `[~]` — Component modified (describe what changed)
- `[=]` — Unchanged (no children needed)
- `[!]` — Structural change (e.g. CTE → subquery)

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "<dialect>",
  "rewrite_rules": [
    {"id": "R1", "type": "<transform_name>", "description": "<what changed>", "applied_to": ["<component_id>"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "<cte_name>": {
        "type": "cte",
        "change": "modified",
        "sql": "<complete SQL for this CTE body>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<upstream_id>"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "<final SELECT>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<cte_name>"]}
      }
    },
    "reconstruction_order": ["<cte_name>", "main_query"],
    "assembly_template": "WITH <cte_name> AS ({<cte_name>}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '512MB'"],
  "validation_checks": []
}
```

### Rules
- **Tree first, always.** Generate the Logic Tree before writing any SQL
- **One component at a time.** When writing SQL for component X, treat others as opaque interfaces
- **No ellipsis.** Every `sql` value must be complete, executable SQL
- **Frozen blocks are copy-paste.** Large CASE-WHEN lookups must be verbatim
- **Validate interfaces.** Verify every `consumes` reference exists in upstream `outputs`
- Only include components you **changed or added** — set unchanged components to `"change": "unchanged"` with `"sql": ""`
- `main_query` output columns must match the Column Completeness Contract above
- `runtime_config`: SET LOCAL commands for PostgreSQL. Omit or use empty array if not needed
- `reconstruction_order`: topological order of components for assembly

After the JSON, explain the mechanism:

```
Changes: <1-2 sentences: what structural change + the expected mechanism>
Expected speedup: <estimate>
```

Now output your Logic Tree and Component Payload JSON: