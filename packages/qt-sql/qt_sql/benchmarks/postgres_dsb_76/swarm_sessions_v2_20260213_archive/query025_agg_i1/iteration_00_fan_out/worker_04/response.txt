## Modified Logic Tree

```
QUERY:
└── [MAIN] main_query  [!]
    ├── [~] CTE structure replaces comma joins
    │   ├── [+] d1_cte (date_dim filter for store_sales)
    │   ├── [+] d2_cte (date_dim filter for store_returns)
    │   ├── [+] d3_cte (date_dim filter for catalog_sales)
    │   ├── [+] store_sales_cte (store_sales JOIN d1_cte)
    │   ├── [+] store_returns_cte (store_returns JOIN d2_cte)
    │   ├── [+] catalog_sales_cte (catalog_sales JOIN d3_cte)
    │   ├── [+] fact_joins_parallel_cte (INNER JOIN all three fact CTEs)
    │   ├── [+] aggregation_cte (GROUP BY ss_item_sk, ss_store_sk)
    │   └── [+] dimension_lookup_cte (JOIN item and store)
    ├── [=] FILTER predicates moved into CTEs
    ├── [=] JOIN conditions remain same semantics
    ├── [=] AGGREGATION (MAX per group)
    ├── [=] SORT (same order by)
    └── [=] OUTPUT (same columns)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "dimension_prefetch",
      "description": "Isolate date_dim filters into separate CTEs to create small hash tables",
      "applied_to": ["d1_cte", "d2_cte", "d3_cte"]
    },
    {
      "id": "R2",
      "type": "explicit_join",
      "description": "Convert comma joins to explicit INNER JOIN syntax with clear join conditions",
      "applied_to": ["store_sales_cte", "store_returns_cte", "catalog_sales_cte", "fact_joins_parallel_cte", "dimension_lookup_cte"]
    },
    {
      "id": "R3",
      "type": "parallel_fact_scans",
      "description": "Keep fact table scans outside CTEs to enable parallel execution",
      "applied_to": ["store_sales_cte", "store_returns_cte", "catalog_sales_cte"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "d1_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 3 AND d_year = 1999",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "d2_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 3 AND 5 AND d_year = 1999",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "d3_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 3 AND 5 AND d_year = 1999",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "store_sales_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT ss_item_sk, ss_store_sk, ss_customer_sk, ss_ticket_number, ss_net_profit FROM store_sales INNER JOIN d1_cte ON ss_sold_date_sk = d1_cte.d_date_sk",
          "interfaces": {
            "outputs": ["ss_item_sk", "ss_store_sk", "ss_customer_sk", "ss_ticket_number", "ss_net_profit"],
            "consumes": ["d1_cte"]
          }
        },
        "store_returns_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT sr_item_sk, sr_customer_sk, sr_ticket_number, sr_net_loss FROM store_returns INNER JOIN d2_cte ON sr_returned_date_sk = d2_cte.d_date_sk",
          "interfaces": {
            "outputs": ["sr_item_sk", "sr_customer_sk", "sr_ticket_number", "sr_net_loss"],
            "consumes": ["d2_cte"]
          }
        },
        "catalog_sales_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT cs_item_sk, cs_bill_customer_sk, cs_net_profit FROM catalog_sales INNER JOIN d3_cte ON cs_sold_date_sk = d3_cte.d_date_sk",
          "interfaces": {
            "outputs": ["cs_item_sk", "cs_bill_customer_sk", "cs_net_profit"],
            "consumes": ["d3_cte"]
          }
        },
        "fact_joins_parallel_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT ss.ss_item_sk, ss.ss_store_sk, ss.ss_net_profit, sr.sr_net_loss, cs.cs_net_profit FROM store_sales_cte ss INNER JOIN store_returns_cte sr ON ss.ss_item_sk = sr.sr_item_sk AND ss.ss_customer_sk = sr.sr_customer_sk AND ss.ss_ticket_number = sr.sr_ticket_number INNER JOIN catalog_sales_cte cs ON sr.sr_item_sk = cs.cs_item_sk AND sr.sr_customer_sk = cs.cs_bill_customer_sk",
          "interfaces": {
            "outputs": ["ss_item_sk", "ss_store_sk", "ss_net_profit", "sr_net_loss", "cs_net_profit"],
            "consumes": ["store_sales_cte", "store_returns_cte", "catalog_sales_cte"]
          }
        },
        "aggregation_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT ss_item_sk, ss_store_sk, MAX(ss_net_profit) AS store_sales_profit, MAX(sr_net_loss) AS store_returns_loss, MAX(cs_net_profit) AS catalog_sales_profit FROM fact_joins_parallel_cte GROUP BY ss_item_sk, ss_store_sk",
          "interfaces": {
            "outputs": ["ss_item_sk", "ss_store_sk", "store_sales_profit", "store_returns_loss", "catalog_sales_profit"],
            "consumes": ["fact_joins_parallel_cte"]
          }
        },
        "dimension_lookup_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT i.i_item_id, i.i_item_desc, s.s_store_id, s.s_store_name, agg.store_sales_profit, agg.store_returns_loss, agg.catalog_sales_profit FROM aggregation_cte agg INNER JOIN item i ON agg.ss_item_sk = i.i_item_sk INNER JOIN store s ON agg.ss_store_sk = s.s_store_sk",
          "interfaces": {
            "outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_profit", "store_returns_loss", "catalog_sales_profit"],
            "consumes": ["aggregation_cte"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_profit, store_returns_loss, catalog_sales_profit FROM dimension_lookup_cte ORDER BY i_item_id, i_item_desc, s_store_id, s_store_name LIMIT 100",
          "interfaces": {
            "outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_profit", "store_returns_loss", "catalog_sales_profit"],
            "consumes": ["dimension_lookup_cte"]
          }
        }
      },
      "reconstruction_order": ["d1_cte", "d2_cte", "d3_cte", "store_sales_cte", "store_returns_cte", "catalog_sales_cte", "fact_joins_parallel_cte", "aggregation_cte", "dimension_lookup_cte", "main_query"],
      "assembly_template": "WITH d1_cte AS ({d1_cte}), d2_cte AS ({d2_cte}), d3_cte AS ({d3_cte}), store_sales_cte AS ({store_sales_cte}), store_returns_cte AS ({store_returns_cte}), catalog_sales_cte AS ({catalog_sales_cte}), fact_joins_parallel_cte AS ({fact_joins_parallel_cte}), aggregation_cte AS ({aggregation_cte}), dimension_lookup_cte AS ({dimension_lookup_cte}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL join_collapse_limit = 1",
    "SET LOCAL from_collapse_limit = 1",
    "SET LOCAL work_mem = '32MB'",
    "SET LOCAL hash_mem_multiplier = 2.0"
  ],
  "validation_checks": []
}
```

## Explanation

**Changes:** Converted comma joins to explicit INNER JOINs with separate date dimension CTEs for each fact table filter. This isolates the date predicates into small, materialized hash tables while keeping fact table scans outside CTEs to enable parallel execution.

**Expected speedup:** ~2-3x from better join planning and parallel fact scans. The date CTEs become tiny hash tables (31 and 92 rows), while the explicit join order prevents the planner from reordering into inefficient join sequences. The work_mem increase supports hash joins on the small dimension tables, and the collapse limits preserve the intended join order.