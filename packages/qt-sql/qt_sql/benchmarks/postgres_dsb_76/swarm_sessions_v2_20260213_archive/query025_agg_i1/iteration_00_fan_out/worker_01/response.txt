## Modified Logic Tree

```
QUERY:
└── [MAIN] final  [~]  Cost: 100%  Rows: ~5
    ├── [~] WITH date_ctes (d1_cte, d2_cte, d3_cte) MATERIALIZED
    ├── [~] WITH fact_prejoins (store_sales_join, store_returns_join, catalog_sales_join)
    ├── [~] combined_join (explicit INNER JOIN chain)
    ├── [~] aggregation (GROUP BY ss_item_sk, ss_store_sk)
    ├── [~] dimension_lookup (JOIN item, store)
    ├── [=] SORT (i_item_id, i_item_desc, s_store_id, s_store_name)
    └── [=] OUTPUT (i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_profit, store_returns_loss, catalog_sales_profit)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefetch", "description": "Materialize filtered date_dim rows into CTEs to create tiny hash tables", "applied_to": ["d1_cte", "d2_cte", "d3_cte"]},
    {"id": "R2", "type": "explicit_join", "description": "Convert comma joins to explicit INNER JOIN syntax", "applied_to": ["store_sales_join", "store_returns_join", "catalog_sales_join", "combined_join", "dimension_lookup"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "d1_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 3 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "d2_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 3 AND 5 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "d3_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 3 AND 5 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_sales_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_item_sk, ss_store_sk, ss_customer_sk, ss_ticket_number, ss_net_profit FROM store_sales JOIN d1_cte ON ss_sold_date_sk = d1_cte.d_date_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_store_sk", "ss_customer_sk", "ss_ticket_number", "ss_net_profit"], "consumes": ["d1_cte"]}
      },
      "store_returns_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT sr_item_sk, sr_customer_sk, sr_ticket_number, sr_net_loss FROM store_returns JOIN d2_cte ON sr_returned_date_sk = d2_cte.d_date_sk",
        "interfaces": {"outputs": ["sr_item_sk", "sr_customer_sk", "sr_ticket_number", "sr_net_loss"], "consumes": ["d2_cte"]}
      },
      "catalog_sales_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cs_item_sk, cs_bill_customer_sk, cs_net_profit FROM catalog_sales JOIN d3_cte ON cs_sold_date_sk = d3_cte.d_date_sk",
        "interfaces": {"outputs": ["cs_item_sk", "cs_bill_customer_sk", "cs_net_profit"], "consumes": ["d3_cte"]}
      },
      "combined_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss.ss_item_sk, ss.ss_store_sk, ss.ss_net_profit, sr.sr_net_loss, cs.cs_net_profit FROM store_sales_join ss INNER JOIN store_returns_join sr ON ss.ss_item_sk = sr.sr_item_sk AND ss.ss_customer_sk = sr.sr_customer_sk AND ss.ss_ticket_number = sr.sr_ticket_number INNER JOIN catalog_sales_join cs ON sr.sr_item_sk = cs.cs_item_sk AND sr.sr_customer_sk = cs.cs_bill_customer_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_store_sk", "ss_net_profit", "sr_net_loss", "cs_net_profit"], "consumes": ["store_sales_join", "store_returns_join", "catalog_sales_join"]}
      },
      "aggregation": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_item_sk, ss_store_sk, MAX(ss_net_profit) AS store_sales_profit, MAX(sr_net_loss) AS store_returns_loss, MAX(cs_net_profit) AS catalog_sales_profit FROM combined_join GROUP BY ss_item_sk, ss_store_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_store_sk", "store_sales_profit", "store_returns_loss", "catalog_sales_profit"], "consumes": ["combined_join"]}
      },
      "dimension_lookup": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, agg.store_sales_profit, agg.store_returns_loss, agg.catalog_sales_profit FROM aggregation agg INNER JOIN item ON agg.ss_item_sk = item.i_item_sk INNER JOIN store ON agg.ss_store_sk = store.s_store_sk",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_profit", "store_returns_loss", "catalog_sales_profit"], "consumes": ["aggregation"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_profit, store_returns_loss, catalog_sales_profit FROM dimension_lookup ORDER BY i_item_id, i_item_desc, s_store_id, s_store_name LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_profit", "store_returns_loss", "catalog_sales_profit"], "consumes": ["dimension_lookup"]}
      }
    },
    "reconstruction_order": ["d1_cte", "d2_cte", "d3_cte", "store_sales_join", "store_returns_join", "catalog_sales_join", "combined_join", "aggregation", "dimension_lookup", "main_query"],
    "assembly_template": "WITH d1_cte AS ({d1_cte}), d2_cte AS ({d2_cte}), d3_cte AS ({d3_cte}), store_sales_join AS ({store_sales_join}), store_returns_join AS ({store_returns_join}), catalog_sales_join AS ({catalog_sales_join}), combined_join AS ({combined_join}), aggregation AS ({aggregation}), dimension_lookup AS ({dimension_lookup}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Converted from comma-separated joins to explicit INNER JOINs and pre-filtered date dimensions into materialized CTEs. This isolates selective dimension filters into tiny hash tables (31 and 92 rows) before joining with large fact tables, giving the optimizer better cardinality estimates.

**Expected speedup:** ~2–3x from better join planning and reduced predicate blindness.