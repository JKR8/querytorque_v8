## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~55K
    ├── CTE_WITH filtered_date  [+]
    │   └── SCAN (date_dim) with filter (d_year=2002, d_moy=4)
    ├── CTE_WITH filtered_item  [+]
    │   └── SCAN (item) with filter (i_category='Jewelry')
    ├── CTE_WITH filtered_customer  [+]
    │   └── SCAN (customer) with filter (c_birth_month=1)
    ├── CTE_WITH filtered_customer_address  [+]
    │   └── SCAN (customer_address) with filter (ca_state='IL')
    ├── CTE_WITH fact_join  [+]
    │   ├── SCAN (store_sales) with filter (ss_wholesale_cost BETWEEN 35 AND 55)
    │   ├── JOIN (INNER JOIN filtered_date ON d_date_sk = ss_sold_date_sk)
    │   ├── JOIN (INNER JOIN filtered_item ON i_item_sk = ss_item_sk)
    │   ├── JOIN (INNER JOIN filtered_customer ON c_customer_sk = ss_customer_sk)
    │   └── JOIN (INNER JOIN filtered_customer_address ON ca_address_sk = c_current_addr_sk)
    ├── CTE_WITH store_join  [+]
    │   ├── SCAN (store)
    │   └── JOIN (INNER JOIN fact_join ON s_store_sk = ss_store_sk) with filter (substring(ca_zip,1,5) <> substring(s_zip,1,5))
    ├── AGG (GROUP BY i_brand_id, i_brand, i_manufact_id, i_manufact)
    ├── SORT (ext_price DESC, i_brand ASC, i_brand_id ASC, i_manufact_id ASC, i_manufact ASC)
    └── OUTPUT (brand_id, brand, i_manufact_id, i_manufact, ext_price)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter_decorrelate", "description": "Pre-filter dimension tables into CTEs before joining to fact table", "applied_to": ["filtered_date", "filtered_item", "filtered_customer", "filtered_customer_address"]},
    {"id": "R2", "type": "pg_dimension_prefetch_star", "description": "Join all selective dimensions (except store) as small hash tables before store join with zip inequality", "applied_to": ["fact_join", "store_join"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy = 4",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_brand_id, i_brand, i_manufact_id, i_manufact FROM item WHERE i_category = 'Jewelry'",
        "interfaces": {"outputs": ["i_item_sk", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact"], "consumes": []}
      },
      "filtered_customer": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_customer_sk, c_current_addr_sk FROM customer WHERE c_birth_month = 1",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": []}
      },
      "filtered_customer_address": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ca_address_sk, ca_zip FROM customer_address WHERE ca_state = 'IL'",
        "interfaces": {"outputs": ["ca_address_sk", "ca_zip"], "consumes": []}
      },
      "fact_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_ext_sales_price, i_brand_id, i_brand, i_manufact_id, i_manufact, ca_zip, ss_store_sk FROM store_sales INNER JOIN filtered_date ON d_date_sk = ss_sold_date_sk INNER JOIN filtered_item ON i_item_sk = ss_item_sk INNER JOIN filtered_customer ON c_customer_sk = ss_customer_sk INNER JOIN filtered_customer_address ON ca_address_sk = c_current_addr_sk WHERE ss_wholesale_cost BETWEEN 35 AND 55",
        "interfaces": {"outputs": ["ss_ext_sales_price", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "ca_zip", "ss_store_sk"], "consumes": ["filtered_date", "filtered_item", "filtered_customer", "filtered_customer_address"]}
      },
      "store_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_ext_sales_price, i_brand_id, i_brand, i_manufact_id, i_manufact FROM fact_join INNER JOIN store ON s_store_sk = ss_store_sk WHERE substring(ca_zip,1,5) <> substring(s_zip,1,5)",
        "interfaces": {"outputs": ["ss_ext_sales_price", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact"], "consumes": ["fact_join"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, i_manufact_id, i_manufact, SUM(ss_ext_sales_price) AS ext_price FROM store_join GROUP BY i_brand_id, i_brand, i_manufact_id, i_manufact ORDER BY ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact LIMIT 100",
        "interfaces": {"outputs": ["brand_id", "brand", "i_manufact_id", "i_manufact", "ext_price"], "consumes": ["store_join"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_item", "filtered_customer", "filtered_customer_address", "fact_join", "store_join", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_item AS ({filtered_item}), filtered_customer AS ({filtered_customer}), filtered_customer_address AS ({filtered_customer_address}), fact_join AS ({fact_join}), store_join AS ({store_join}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL enable_nestloop = off", "SET LOCAL enable_hashjoin = on", "SET LOCAL work_mem = '32MB'"],
  "validation_checks": []
}
```

**Changes:** Replaced comma-separated implicit joins with explicit INNER JOINs in a CTE pipeline. Pre-filtered selective dimensions (date, item, customer, customer_address) into small hash tables before joining to the fact table, then joined store last for the zip inequality filter.

**Expected speedup:** 1.5-2x due to better cardinality estimates from pre-materialized dimension filters and explicit join ordering that avoids combinatorial explosion in the planner's join search space. The store join with inequality is deferred until after all equi-joins, reducing rows before the expensive substring comparison.

**Runtime config rationale:** 
1. `enable_nestloop = off` - The store join uses a substring inequality that would be expensive with nested loops. Hash join is better.
2. `enable_hashjoin = on` - Ensure hash joins are allowed for all joins.
3. `work_mem = '32MB'` - The final GROUP BY hash aggregation and intermediate hash joins need more memory than default 4MB to avoid spilling to disk. 32MB is safe within connection limits.