<thinking>
We need to achieve 2.0x speedup. The best previous attempt (W1) achieved only 1.087x. Looking at the execution plan and the bottleneck diagnosis:

1. **Main bottleneck**: Nested loop joins, particularly the 30-row date_dim result probing catalog_sales index 61 times (2 workers Ã— 30.5 avg), consuming ~64% of runtime (142ms).

2. **Why previous attempts failed**:
   - W1 used CTEs to pre-filter dimensions but still ended up with nested loops
   - W2, W3, W4 had errors (row count mismatch) - they changed the semantics

3. **Key insights from engine profile**:
   - PostgreSQL has weak comma-join optimization (original uses comma joins)
   - CTE materialization creates optimization fences
   - Original query uses implicit comma-joins: `catalog_sales left outer join catalog_returns on ... ,warehouse ,item ,date_dim where ...`

4. **Untapped optimization angles**:
   - Convert comma-joins to explicit JOIN syntax (pg_dimension_prefetch_star pattern)
   - Strategic use of materialization to reduce nested loop probe cost
   - Pre-aggregation where possible
   - The catalog_returns LEFT JOIN becomes INNER due to cr_reason_sk=33 filter

5. **Important observation**: The catalog_returns join is effectively an INNER join because:
   - LEFT JOIN catalog_returns ON (...)
   - WHERE cr_reason_sk = 33
   - This filters out NULLs, making it equivalent to INNER JOIN

Let me analyze the original query structure:
```sql
select 
   w_state
  ,i_item_id
  ,sum(case when (cast(d_date as date) < cast ('2002-02-19' as date))
 		then cs_sales_price - coalesce(cr_refunded_cash,0) else 0 end) as sales_before
  ,sum(case when (cast(d_date as date) >= cast ('2002-02-19' as date))
 		then cs_sales_price - coalesce(cr_refunded_cash,0) else 0 end) as sales_after
 from
   catalog_sales left outer join catalog_returns on
       (cs_order_number = cr_order_number
        and cs_item_sk = cr_item_sk)
  ,warehouse
  ,item
  ,date_dim
 where
 i_item_sk          = cs_item_sk
 and cs_warehouse_sk    = w_warehouse_sk
 and cs_sold_date_sk    = d_date_sk
 and d_date between  (cast ('2002-02-19' as date) - interval '30 day')
                and (cast ('2002-02-19' as date) + interval '30 day') 
 and i_category  = 'Jewelry'
 and i_manager_id between 61 and 100
 and cs_wholesale_cost between 42 and 61
 and cr_reason_sk = 33
 group by
    w_state,i_item_id
 order by w_state,i_item_id
limit 100;
```

Key issues:
1. Comma-joins for warehouse, item, date_dim
2. LEFT JOIN to catalog_returns but WHERE filter makes it INNER
3. Multiple filters that could be pushed down

Let me design a new approach:

**Strategy**:
1. Convert all comma-joins to explicit JOIN syntax (pg_dimension_prefetch_star pattern)
2. Use strategic CTE materialization to create small dimension hash tables
3. Change LEFT JOIN to INNER JOIN since cr_reason_sk=33 filter makes it equivalent
4. Consider pre-aggregating at warehouse/item level before final aggregation

Wait, but we need to be careful about the CASE expressions that depend on d_date. We can't pre-aggregate before checking the date threshold.

Actually, looking at the execution plan more carefully: the biggest cost is the nested loop between date_dim (30 rows) and catalog_sales. Each date probes catalog_sales index. This suggests we might benefit from:
- Materializing the filtered date range
- Converting to hash joins instead of nested loops
- Increasing work_mem to allow better hash joins

Let me check the pg_dimension_prefetch_star pattern from the examples. That achieved 3.32x by:
- Pre-filtering all selective dimensions into CTEs
- Using explicit JOIN syntax
- Creating tiny hash tables

The best foundation SQL already does this somewhat, but still uses nested loops. Maybe we need to force hash joins by:
1. Increasing work_mem
2. Disabling nested loop joins
3. Using explicit JOIN order

Also, note that warehouse table is small (10 rows in plan), item is filtered, date_dim is 30 rows. These should be hash joined.

Let me design a new logical tree:
</thinking>

# Part 1: Modified Logic Tree

```
[!] Original: catalog_sales LEFT JOIN catalog_returns, comma-joins to warehouse, item, date_dim
[~] Convert to explicit INNER JOINs (since cr_reason_sk=33 makes LEFT JOIN effectively INNER)
[+] date_cte: Materialized date filter for 60-day range
[+] item_cte: Materialized item filter for category='Jewelry' and manager_id 61-100  
[+] returns_cte: Materialized catalog_returns filter for cr_reason_sk=33
[+] warehouse_cte: All warehouses (small table)
[!] Join order: Start with smallest dimension CTEs, hash join to fact table
[~] Main query: Explicit JOIN syntax with strategic join order
```

# Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "comma_join_to_explicit", "description": "Convert comma-separated FROM tables to explicit JOIN syntax", "applied_to": ["main_query"]},
    {"id": "R2", "type": "cte_dimension_prefilter", "description": "Pre-filter selective dimensions into materialized CTEs", "applied_to": ["date_cte", "item_cte", "returns_cte", "warehouse_cte"]},
    {"id": "R3", "type": "left_to_inner_join", "description": "Convert LEFT JOIN to INNER JOIN since WHERE cr_reason_sk=33 filters out NULLs", "applied_to": ["main_query"]},
    {"id": "R4", "type": "strategic_materialization", "description": "Use MATERIALIZED CTEs to create small hash tables for dimension joins", "applied_to": ["date_cte", "item_cte", "returns_cte", "warehouse_cte"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 DAY') AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 DAY')",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "item_cte": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_id FROM item WHERE i_category = 'Jewelry' AND i_manager_id BETWEEN 61 AND 100",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id"], "consumes": []}
      },
      "returns_cte": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT cr_order_number, cr_item_sk, cr_refunded_cash FROM catalog_returns WHERE cr_reason_sk = 33",
        "interfaces": {"outputs": ["cr_order_number", "cr_item_sk", "cr_refunded_cash"], "consumes": []}
      },
      "warehouse_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT w_warehouse_sk, w_state FROM warehouse",
        "interfaces": {"outputs": ["w_warehouse_sk", "w_state"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT w.w_state, i.i_item_id, SUM(CASE WHEN d.d_date < CAST('2002-02-19' AS DATE) THEN cs.cs_sales_price - COALESCE(r.cr_refunded_cash, 0) ELSE 0 END) AS sales_before, SUM(CASE WHEN d.d_date >= CAST('2002-02-19' AS DATE) THEN cs.cs_sales_price - COALESCE(r.cr_refunded_cash, 0) ELSE 0 END) AS sales_after FROM catalog_sales cs JOIN date_cte d ON cs.cs_sold_date_sk = d.d_date_sk JOIN item_cte i ON cs.cs_item_sk = i.i_item_sk JOIN warehouse_cte w ON cs.cs_warehouse_sk = w.w_warehouse_sk JOIN returns_cte r ON cs.cs_order_number = r.cr_order_number AND cs.cs_item_sk = r.cr_item_sk WHERE cs.cs_wholesale_cost BETWEEN 42 AND 61 GROUP BY w.w_state, i.i_item_id ORDER BY w.w_state, i.i_item_id LIMIT 100",
        "interfaces": {"outputs": ["w_state", "i_item_id", "sales_before", "sales_after"], "consumes": ["date_cte", "item_cte", "returns_cte", "warehouse_cte"]}
      }
    },
    "reconstruction_order": ["date_cte", "item_cte", "returns_cte", "warehouse_cte", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), item_cte AS ({item_cte}), returns_cte AS ({returns_cte}), warehouse_cte AS ({warehouse_cte}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL work_mem = '256MB'",
    "SET LOCAL hash_mem_multiplier = 2.0"
  ],
  "validation_checks": []
}
```

**Changes**: Converted comma-joins to explicit JOIN syntax with strategic CTE materialization, changed LEFT JOIN to INNER JOIN (semantically equivalent due to cr_reason_sk=33 filter), and configured planner to prefer hash joins over nested loops.

**Expected speedup**: 2.5x-3.0x by eliminating nested loop bottleneck through hash joins and explicit join ordering. The small dimension CTEs (date: 30 rows, item: filtered, warehouse: 10 rows, returns: filtered) will create efficient hash tables for joining with catalog_sales.