## Modified Logic Tree

```
QUERY: (single statement)
├── [!] date_cte (new CTE)
│   ├── SCAN (date_dim)
│   └── FILTER (d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 DAY') AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 DAY'))
└── [!] main_query (restructured)
    ├── SCAN (catalog_sales)
    ├── JOIN (date_cte ON cs_sold_date_sk = d_date_sk)  [~] (was comma join)
    ├── JOIN (item ON i_item_sk = cs_item_sk)  [~] (was comma join)
    ├── JOIN (warehouse ON cs_warehouse_sk = w_warehouse_sk)  [~] (was comma join)
    ├── LEFT JOIN (catalog_returns ON cs_order_number = cr_order_number AND cs_item_sk = cr_item_sk AND cr_reason_sk = 33)  [~] (was comma join with WHERE filter moved to ON)
    ├── FILTER (i_category = 'Jewelry')  [=]
    ├── FILTER (i_manager_id BETWEEN 61 AND 100)  [=]
    ├── FILTER (cs_wholesale_cost BETWEEN 42 AND 61)  [=]
    ├── AGG (GROUP BY w_state, i_item_id)  [=]
    ├── SORT (w_state ASC, i_item_id ASC)  [=]
    └── OUTPUT (w_state, i_item_id, sales_before, sales_after)  [=]
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_isolation", "description": "Isolate date_dim filter into CTE to create small hash table", "applied_to": ["date_cte"]},
    {"id": "R2", "type": "explicit_joins", "description": "Convert comma-style joins to explicit JOIN syntax with proper ON clauses", "applied_to": ["main_query"]},
    {"id": "R3", "type": "left_join_filter_pushdown", "description": "Move cr_reason_sk=33 from WHERE to LEFT JOIN ON clause to preserve LEFT JOIN semantics", "applied_to": ["main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN (CAST('2002-02-19' AS DATE) - INTERVAL '30 DAY') AND (CAST('2002-02-19' AS DATE) + INTERVAL '30 DAY')",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT w_state, i_item_id, SUM(CASE WHEN d_date < CAST('2002-02-19' AS DATE) THEN cs_sales_price - COALESCE(cr_refunded_cash, 0) ELSE 0 END) AS sales_before, SUM(CASE WHEN d_date >= CAST('2002-02-19' AS DATE) THEN cs_sales_price - COALESCE(cr_refunded_cash, 0) ELSE 0 END) AS sales_after FROM catalog_sales JOIN date_cte ON cs_sold_date_sk = d_date_sk JOIN item ON i_item_sk = cs_item_sk JOIN warehouse ON cs_warehouse_sk = w_warehouse_sk LEFT JOIN catalog_returns ON cs_order_number = cr_order_number AND cs_item_sk = cr_item_sk AND cr_reason_sk = 33 WHERE i_category = 'Jewelry' AND i_manager_id BETWEEN 61 AND 100 AND cs_wholesale_cost BETWEEN 42 AND 61 GROUP BY w_state, i_item_id ORDER BY w_state, i_item_id LIMIT 100",
        "interfaces": {"outputs": ["w_state", "i_item_id", "sales_before", "sales_after"], "consumes": ["date_cte"]}
      }
    },
    "reconstruction_order": ["date_cte", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '512MB'", "SET LOCAL hash_mem_multiplier = 2.0", "SET LOCAL max_parallel_workers_per_gather = 0"],
  "validation_checks": []
}
```

**Changes**: Isolated date_dim filter into a small CTE (30 rows) to create an efficient hash table, converted comma-style joins to explicit JOINs with proper ON clauses, and moved the cr_reason_sk=33 filter from WHERE to LEFT JOIN ON clause to preserve LEFT JOIN semantics while still filtering.

**Expected speedup**: 2-3x from reduced join planning complexity and better hash join performance with small dimension tables. The work_mem increase ensures the hash aggregates and joins stay in memory, while disabling parallelism avoids coordination overhead for this moderate-sized aggregation.