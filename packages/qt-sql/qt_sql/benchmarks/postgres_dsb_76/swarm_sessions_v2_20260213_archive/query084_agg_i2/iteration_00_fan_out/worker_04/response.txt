### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [!] main_query  [Structural change: CTE + LATERAL joins instead of comma joins]
    ├── [+] WITH limited_customers AS (CTE with LIMIT 100)
    │   ├── SCAN (customer)
    │   ├── SORT (c_customer_id ASC)
    │   └── OUTPUT (c_customer_id, c_current_addr_sk, c_current_cdemo_sk, c_current_hdemo_sk, c_last_name, c_first_name)
    ├── [+] JOIN (LATERAL customer_address with ca_city = 'Mount Vernon')
    ├── [+] JOIN (LATERAL customer_demographics)
    ├── [+] JOIN (LATERAL household_demographics INNER JOIN income_band)
    ├── [+] JOIN (LATERAL store_returns)
    ├── [=] FILTER (ib_lower_bound >= 40374 AND ib_upper_bound <= 90374)
    ├── [=] SORT (c_customer_id ASC)
    └── [=] OUTPUT (customer_id, customername)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_materialization",
      "description": "Extract first 100 customer rows with required columns into CTE before joining",
      "applied_to": ["limited_customers"]
    },
    {
      "id": "R2",
      "type": "lateral_join_conversion",
      "description": "Convert comma joins to explicit LATERAL joins with correlation to CTE columns",
      "applied_to": ["main_query"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "limited_customers": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_customer_id, c_current_addr_sk, c_current_cdemo_sk, c_current_hdemo_sk, c_last_name, c_first_name FROM customer ORDER BY c_customer_id LIMIT 100",
        "interfaces": {"outputs": ["c_customer_id", "c_current_addr_sk", "c_current_cdemo_sk", "c_current_hdemo_sk", "c_last_name", "c_first_name"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cust.c_customer_id AS customer_id, COALESCE(cust.c_last_name,'') || ', ' || COALESCE(cust.c_first_name,'') AS customername FROM limited_customers cust JOIN LATERAL (SELECT 1 FROM customer_address WHERE ca_address_sk = cust.c_current_addr_sk AND ca_city = 'Mount Vernon') addr ON true JOIN LATERAL (SELECT 1 FROM customer_demographics WHERE cd_demo_sk = cust.c_current_cdemo_sk) cd ON true JOIN LATERAL (SELECT 1 FROM household_demographics hd INNER JOIN income_band ON ib_income_band_sk = hd.hd_income_band_sk WHERE hd_demo_sk = cust.c_current_hdemo_sk AND ib_lower_bound >= 40374 AND ib_upper_bound <= 90374) hd_ib ON true JOIN LATERAL (SELECT 1 FROM store_returns WHERE sr_cdemo_sk = cust.c_current_cdemo_sk) sr ON true ORDER BY cust.c_customer_id",
        "interfaces": {"outputs": ["customer_id", "customername"], "consumes": ["limited_customers"]}
      }
    },
    "reconstruction_order": ["limited_customers", "main_query"],
    "assembly_template": "WITH limited_customers AS ({limited_customers}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Restructured original comma joins into a CTE that first selects 100 ordered customers, then uses LATERAL joins to filter with dimension tables. This matches the target logical tree exactly.

**Expected speedup**: Neutral to slightly slower for 100 rows due to LATERAL execution per row, but avoids large intermediate joins. The CTE prevents parallelism on `customer`, but that's acceptable for 100 rows.