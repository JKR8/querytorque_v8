<reasoning>
## 1. CLASSIFY
This is a **star-join with late dim filter** query. It joins a large fact table (`store_sales`) with four dimension tables (`customer_demographics`, `date_dim`, `store`, `item`) using foreign key joins, filters on each dimension, then aggregates with ROLLUP. No correlated subqueries, no UNION ALL, no self-joins.

## 2. EXPLAIN PLAN ANALYSIS
- **Total time**: 599.3 ms
- **Dominant nodes**: 
  1. `Nested Loop Inner (rows=0 loops=365 time=2.6ms)` × 365 loops = ~950 ms total across all workers? Wait: The timings are cumulative. The `Nested Loop Inner` shows `time=322.0ms` for 3 loops (leader + 2 workers). The inner `Index Only Scan on store_sales` runs 365 loops per worker? Actually, loops=365 for the `Nested Loop Inner` that contains the store_sales scan. That's per worker? The plan shows `loops=3` for the outermost Nested Loop, but `loops=365` for the inner Nested Loop. This suggests the store_sales index scan is executed 365 times per worker, totaling ~365*3 = 1095 probes. Each probe takes ~2.6ms/365 = 0.007ms, but the cumulative time is the bottleneck.

- **Cardinality flow**:
  - `date_dim`: 122 rows (per worker) via Index Only Scan (fast)
  - `store`: 1 row after filter (per loop) via Seq Scan (fast)
  - `store_sales`: 0 rows per probe (very selective) via Index Only Scan on (ss_sold_date_sk, ss_store_sk)
  - `item` and `customer_demographics`: 0 rows per probe (very selective) via Index Scan
  - Final aggregate: ~366 rows -> limit 100

- **Key insight**: The plan uses **nested loops** driven by `date_dim` and `store`, probing `store_sales` by (`ss_sold_date_sk`, `ss_store_sk`). This is efficient because the index is highly selective (0 rows per probe). However, the nested loop fan-out is 122 (date rows) × 1 (store) = 122 probes per worker, and there are 3 workers, so ~365 probes total. Each probe is fast (0.007ms), but the cumulative time is 322ms for the nested loop section.

- **Optimizer already does**: Predicate pushdown to dimension scans, index selection, parallel execution (2 workers). It does NOT split CTEs (none exist), but it does reorder joins (the comma joins are reordered).

- **Scans per base table**:
  - `date_dim`: 1 scan (per worker)
  - `store`: 1 scan (per loop? Actually seq scan repeated 365 times, but that's inside the nested loop; same table scanned multiple times)
  - `store_sales`: 1 index scan per probe (365 times per worker? Actually the index scan is inside the nested loop, so it's executed many times)
  - `item`: 1 index scan per matching store_sales row (very few)
  - `customer_demographics`: 1 index scan per matching store_sales row (very few)

- **Opportunity**: The repeated seq scan on `store` (365 times) is cheap but unnecessary. Could pre-filter `store` once. The nested loop probing of `store_sales` is efficient due to index, but maybe a hash join with pre-filtered dimensions could reduce probing overhead.

## 3. GAP MATCHING

- **COMMA_JOIN_WEAKNESS**: Yes, query uses comma-separated joins. Converting to explicit JOINs with pre-filtered CTEs could improve cardinality estimation.
- **CORRELATED_SUBQUERY_PARALYSIS**: No correlated subqueries.
- **CROSS_CTE_PREDICATE_BLINDNESS**: No repeated fact scans.
- **NON_EQUI_JOIN_INPUT_BLINDNESS**: No non-equi joins.

**Engine Strengths already in use**:
- INNER_JOIN_REORDERING: Optimizer reorders joins.
- INDEX_ONLY_SCAN: Used on `date_dim` and `store_sales`.
- PARALLEL_QUERY_EXECUTION: Already used (2 workers).

**Gaps present**: COMMA_JOIN_WEAKNESS.

## 4. AGGREGATION TRAP CHECK
Aggregates are all `AVG`. AVG is **not** duplicate-safe. However, the joins are foreign key joins from fact to dimensions, which should not introduce duplicates (one-to-many from fact to dimensions? Actually, each store_sales row joins to exactly one row in each dimension via foreign key. So no duplication.) Any rewrite must preserve this property.

## 5. TRANSFORM SELECTION
Given the structure, these transforms are applicable:

1. **star_join_prefetch** (pre-filter dimensions into CTEs, then join fact). This attacks COMMA_JOIN_WEAKNESS.
2. **late_attribute_binding** (defer dimension joins that only provide columns used in SELECT? But `item` provides `i_item_id` (GROUP BY) and `store` provides `s_state` (GROUP BY). So cannot defer.)
3. **global_predicate_pushdown** (already done by optimizer).
4. **single_pass_aggregation** (not applicable, only one aggregate group).
5. **scan_consolidation_pivot** (not applicable, no multiple discriminator filters).

But we need 4 diverse strategies. Let's think:

- Strategy 1: **Explicit JOINs with pre-filtered CTEs** (star_join_prefetch). Convert comma joins to explicit JOINs, pre-filter dimensions into CTEs.
- Strategy 2: **Force hash joins** by disabling nested loops (no_nestloop). The plan shows nested loops are used; maybe hash joins would be better for joining the pre-filtered dimensions with fact.
- Strategy 3: **Materialized CTEs for all dimensions** (pg_materialized_dimension_fact_prefilter). Use MATERIALIZED CTEs to force early reduction.
- Strategy 4: **Exploration**: Combine star_join_prefetch with **aggregate_pushdown**? Not safe because AVG over joins. Instead, try **parallelism boost** (increase workers) since the query already uses parallelism.

## 6. LOGICAL TREE DESIGN

For each strategy, define CTEs and joins.

**Strategy 1 (star_join_prefetch)**:
- CTE_date: filter date_dim
- CTE_store: filter store
- CTE_item: filter item
- CTE_cd: filter customer_demographics
- Then join these CTEs with store_sales via explicit JOINs, then aggregate.

**Strategy 2 (no_nestloop)**:
- Same as Strategy 1, but add SET enable_nestloop = off to force hash/merge joins.

**Strategy 3 (materialized CTEs)**:
- Same as Strategy 1, but use MATERIALIZED keyword on CTEs.

**Strategy 4 (parallelism boost)**:
- Increase max_parallel_workers_per_gather, use explicit JOINs without CTEs (maybe just convert comma joins to explicit JOINs).

Check column completeness: Each CTE must output join keys and any columns needed downstream (e.g., i_item_id, s_state).
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
This query computes average sales metrics for Music items sold in Ohio stores in 1999 to male, widowed, secondary‑educated customers, grouped by item and state with a rollup. All joins are INNER (each fact row must match all dimension filters). The aggregates are AVG, which are sensitive to row duplication—joins must preserve one‑to‑many cardinality from fact to dimensions. Filters on dimension columns (cd_gender, cd_marital_status, cd_education_status, d_year, s_state, i_category) are interdependent only through the fact table; pushing them earlier is safe.

BOTTLENECK_DIAGNOSIS:
The dominant cost is nested‑loop probing of store_sales (365 probes total across workers) driven by filtered date_dim and store. Each probe is fast (0.007 ms) but cumulative time is 322 ms. The plan is join‑bound, not scan‑bound. Cardinality drops sharply at store (1 row) and store_sales (0 rows per probe). The optimizer already pushes predicates, uses indexes, and parallelizes well. Logical‑tree costs are misleading because the nested‑loop overhead is not fully reflected.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Output columns i_item_id, s_state, g_state, agg1, agg2, agg3, agg4 must be preserved.
- CTE_COLUMN_COMPLETENESS: Any CTE must include all columns referenced downstream (join keys, i_item_id, s_state, and fact aggregates).
- LITERAL_PRESERVATION: Literals 'M', 'W', 'Secondary', 1999, 'OH', 'Music' must be copied exactly.
- SEMANTIC_EQUIVALENCE: Result set must match original row‑for‑row, including ROLLUP rows and ordering.
- COMMA_JOIN_WEAKNESS: Query uses comma‑separated joins; EXPLAIN shows optimizer reorders them, but explicit JOINs may improve cardinality estimation.

REGRESSION_WARNINGS:
1. Nestloop off regression (observed 184x regression):
   CAUSE: Disabling nested loops on lookup‑style joins forces hash/merge joins that may be slower.
   RULE: Only set enable_nestloop = off if you pre‑filter dimensions into tiny CTEs, making hash join build side small.
2. CTE inlining (observed regression in some plans):
   CAUSE: PostgreSQL may inline CTEs, defeating materialization benefits.
   RULE: Use AS MATERIALIZED on CTEs when early reduction is critical.

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  date_cte -> store_cte -> item_cte -> cd_cte -> fact_join -> aggregation -> sort -> limit
NODE_CONTRACTS:
  date_cte:
    FROM: date_dim
    WHERE: d_year = 1999
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 122
    CONSUMERS: fact_join
  store_cte:
    FROM: store
    WHERE: s_state = 'OH'
    OUTPUT: s_store_sk, s_state
    EXPECTED_ROWS: 1
    CONSUMERS: fact_join
  item_cte:
    FROM: item
    WHERE: i_category = 'Music'
    OUTPUT: i_item_sk, i_item_id
    EXPECTED_ROWS: unknown (small)
    CONSUMERS: fact_join
  cd_cte:
    FROM: customer_demographics
    WHERE: cd_gender = 'M' AND cd_marital_status = 'W' AND cd_education_status = 'Secondary'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: unknown (small)
    CONSUMERS: fact_join
  fact_join:
    FROM: store_sales
      JOIN date_cte ON ss_sold_date_sk = date_cte.d_date_sk
      JOIN store_cte ON ss_store_sk = store_cte.s_store_sk
      JOIN item_cte ON ss_item_sk = item_cte.i_item_sk
      JOIN cd_cte ON ss_cdemo_sk = cd_cte.cd_demo_sk
    OUTPUT: i_item_id, s_state, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    EXPECTED_ROWS: unknown (small, ~0 per probe)
    CONSUMERS: aggregation
  aggregation:
    GROUP BY: ROLLUP (i_item_id, s_state)
    AGGREGATE: AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4
    OUTPUT: i_item_id, s_state, GROUPING(s_state) AS g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: ~366
    CONSUMERS: sort
  sort:
    ORDER BY: i_item_id, s_state
    CONSUMERS: limit
  limit:
    LIMIT: 100
    CONSUMERS: final output
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply pre-filtering of all dimensions (date, store, item, customer_demographics) into CTEs and convert comma joins to explicit JOINs. Ignore promotion table pattern.
- pg_date_cte_explicit_join: Apply date_cte isolation and explicit JOIN syntax. Ignore decorrelation aspect.
- early_filter_decorrelate: Apply early filtering of dimensions into CTEs. Ignore decorrelation (no correlated subquery).
HAZARD_FLAGS:
- CTEs may be inlined, losing materialization benefit. Consider MATERIALIZED keyword.
- Explicit JOINs may change join order; use join_collapse_limit=1 to preserve order if needed.

=== WORKER 2 BRIEFING ===

STRATEGY: no_nestloop_hash_join
TARGET_LOGICAL_TREE:
  date_cte -> store_cte -> item_cte -> cd_cte -> fact_hash_join -> aggregation -> sort -> limit
NODE_CONTRACTS:
  date_cte:
    FROM: date_dim
    WHERE: d_year = 1999
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 122
    CONSUMERS: fact_hash_join
  store_cte:
    FROM: store
    WHERE: s_state = 'OH'
    OUTPUT: s_store_sk, s_state
    EXPECTED_ROWS: 1
    CONSUMERS: fact_hash_join
  item_cte:
    FROM: item
    WHERE: i_category = 'Music'
    OUTPUT: i_item_sk, i_item_id
    EXPECTED_ROWS: unknown (small)
    CONSUMERS: fact_hash_join
  cd_cte:
    FROM: customer_demographics
    WHERE: cd_gender = 'M' AND cd_marital_status = 'W' AND cd_education_status = 'Secondary'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: unknown (small)
    CONSUMERS: fact_hash_join
  fact_hash_join:
    FROM: store_sales
      JOIN date_cte ON ss_sold_date_sk = date_cte.d_date_sk
      JOIN store_cte ON ss_store_sk = store_cte.s_store_sk
      JOIN item_cte ON ss_item_sk = item_cte.i_item_sk
      JOIN cd_cte ON ss_cdemo_sk = cd_cte.cd_demo_sk
    OUTPUT: i_item_id, s_state, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    EXPECTED_ROWS: unknown (small)
    CONSUMERS: aggregation
  aggregation:
    GROUP BY: ROLLUP (i_item_id, s_state)
    AGGREGATE: AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4
    OUTPUT: i_item_id, s_state, GROUPING(s_state) AS g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: ~366
    CONSUMERS: sort
  sort:
    ORDER BY: i_item_id, s_state
    CONSUMERS: limit
  limit:
    LIMIT: 100
    CONSUMERS: final output
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply pre-filtering of dimensions into CTEs and explicit JOINs. Additionally, set enable_nestloop = off to force hash joins.
- pg_date_cte_explicit_join: Apply date_cte isolation and explicit JOINs, plus enable_nestloop = off. Ignore decorrelation.
HAZARD_FLAGS:
- Forcing hash joins may increase memory usage; ensure work_mem is sufficient.
- If dimension CTEs are large, hash join build side could be expensive.

=== WORKER 3 BRIEFING ===

STRATEGY: materialized_ctes
TARGET_LOGICAL_TREE:
  date_cte (MATERIALIZED) -> store_cte (MATERIALIZED) -> item_cte (MATERIALIZED) -> cd_cte (MATERIALIZED) -> fact_join -> aggregation -> sort -> limit
NODE_CONTRACTS:
  date_cte:
    FROM: date_dim
    WHERE: d_year = 1999
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 122
    CONSUMERS: fact_join
  store_cte:
    FROM: store
    WHERE: s_state = 'OH'
    OUTPUT: s_store_sk, s_state
    EXPECTED_ROWS: 1
    CONSUMERS: fact_join
  item_cte:
    FROM: item
    WHERE: i_category = 'Music'
    OUTPUT: i_item_sk, i_item_id
    EXPECTED_ROWS: unknown (small)
    CONSUMERS: fact_join
  cd_cte:
    FROM: customer_demographics
    WHERE: cd_gender = 'M' AND cd_marital_status = 'W' AND cd_education_status = 'Secondary'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: unknown (small)
    CONSUMERS: fact_join
  fact_join:
    FROM: store_sales
      JOIN date_cte ON ss_sold_date_sk = date_cte.d_date_sk
      JOIN store_cte ON ss_store_sk = store_cte.s_store_sk
      JOIN item_cte ON ss_item_sk = item_cte.i_item_sk
      JOIN cd_cte ON ss_cdemo_sk = cd_cte.cd_demo_sk
    OUTPUT: i_item_id, s_state, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    EXPECTED_ROWS: unknown (small)
    CONSUMERS: aggregation
  aggregation:
    GROUP BY: ROLLUP (i_item_id, s_state)
    AGGREGATE: AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4
    OUTPUT: i_item_id, s_state, GROUPING(s_state) AS g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: ~366
    CONSUMERS: sort
  sort:
    ORDER BY: i_item_id, s_state
    CONSUMERS: limit
  limit:
    LIMIT: 100
    CONSUMERS: final output
EXAMPLES: pg_materialized_dimension_fact_prefilter, pg_dimension_prefetch_star
EXAMPLE_ADAPTATION:
- pg_materialized_dimension_fact_prefilter: Apply MATERIALIZED keyword to all dimension CTEs. Ignore fact table pre‑filtering (not needed here).
- pg_dimension_prefetch_star: Apply pre‑filtering and explicit JOINs, plus MATERIALIZED on CTEs.
HAZARD_FLAGS:
- MATERIALIZED CTEs are executed singly; may block parallelism.
- Materialization overhead may outweigh benefit if CTEs are tiny.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: parallel_boost_explicit_joins
TARGET_LOGICAL_TREE:
  fact_join_explicit -> aggregation -> sort -> limit
NODE_CONTRACTS:
  fact_join_explicit:
    FROM: store_sales
      INNER JOIN date_dim ON ss_sold_date_sk = date_dim.d_date_sk
      INNER JOIN store ON ss_store_sk = store.s_store_sk
      INNER JOIN item ON ss_item_sk = item.i_item_sk
      INNER JOIN customer_demographics ON ss_cdemo_sk = customer_demographics.cd_demo_sk
    WHERE: date_dim.d_year = 1999
      AND store.s_state = 'OH'
      AND item.i_category = 'Music'
      AND customer_demographics.cd_gender = 'M'
      AND customer_demographics.cd_marital_status = 'W'
      AND customer_demographics.cd_education_status = 'Secondary'
    OUTPUT: i_item_id, s_state, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    EXPECTED_ROWS: unknown (small)
    CONSUMERS: aggregation
  aggregation:
    GROUP BY: ROLLUP (i_item_id, s_state)
    AGGREGATE: AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4
    OUTPUT: i_item_id, s_state, GROUPING(s_state) AS g_state, agg1, agg2, agg3, agg4
    EXPECTED_ROWS: ~366
    CONSUMERS: sort
  sort:
    ORDER BY: i_item_id, s_state
    CONSUMERS: limit
  limit:
    LIMIT: 100
    CONSUMERS: final output
EXAMPLES: pg_date_cte_explicit_join, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_date_cte_explicit_join: Apply explicit JOIN syntax only, without CTEs. Additionally, increase parallel workers.
- early_filter_decorrelate: Apply explicit JOINs and push filters into JOIN conditions. Ignore CTE creation.
HAZARD_FLAGS:
- Increasing parallelism may not help if data is already small.
- Explicit JOINs without CTEs may not improve cardinality estimation significantly.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy (explicit JOINs + parallelism boost)