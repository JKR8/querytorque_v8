<reasoning>
1. **CLASSIFY**: This is a multi-channel set difference query with three independent fact table scans (store_sales, catalog_sales, web_sales) joined to the same dimension tables (date_dim, customer) with identical filters. Each branch computes distinct tuples (c_last_name, c_first_name, d_date) from a sales channel, then performs EXCEPT operations. This is a "repeated fact scan with shared dimension joins" archetype.

2. **EXPLAIN PLAN ANALYSIS**:
   - **Total runtime**: 1263.9ms, with store_sales (652.6ms), catalog_sales (370.5ms), web_sales (240.7ms).
   - **Dominant nodes**: Nested Loop Inner joins from date_dim → sales fact tables consume >80% of runtime. Each date_dim scan returns 182 rows (filtered from 36K). For each date, an index scan on the sales table probes with date key, then applies list_price and wholesale_cost filters, removing 3K-14K rows per loop.
   - **Row count drops**: date_dim filter reduces 36K→182 rows (0.5% selectivity). Sales table filters have moderate selectivity (removing 70-90% of index-scanned rows). Customer index scan is highly selective (birth_year filter).
   - **Missed opportunities**: Same date_dim and customer tables are scanned THREE times (once per channel) with identical filters. The optimizer does NOT share these dimension scans. Each channel repeats the same dimension filtering work.
   - **Scan counts**: date_dim scanned 3× (182 rows each), customer scanned 3×. Fact tables scanned 1× each.
   - **CTE materialization**: The EXCEPT structure uses SetOp; subqueries are executed independently with no sharing.

3. **GAP MATCHING**:
   - **COMMA_JOIN_WEAKNESS**: Present. Query uses comma-separated implicit joins (store_sales, date_dim, customer). PostgreSQL's cardinality estimation suffers.
   - **CROSS_CTE_PREDICATE_BLINDNESS**: Present. Same dimension scans repeated 3×. Opportunity to materialize filtered dimensions once.
   - **CORRELATED_SUBQUERY_PARALYSIS**: Not present (no correlated subqueries).
   - **NON_EQUI_JOIN_INPUT_BLINDNESS**: Not present (all equi-joins).
   - **Optimizer already does**: Parallel execution (1 worker per channel), index scans on sales tables, predicate pushdown to date_dim. Does NOT share dimension scans.

4. **AGGREGATION TRAP CHECK**: Only COUNT(*) at outermost level. No grouping-sensitive aggregates (STDDEV, VARIANCE). The DISTINCT within each branch ensures duplicate elimination before EXCEPT. Any rewrite must preserve exact set semantics.

5. **TRANSFORM SELECTION** (ranked by impact):
   - **star_join_prefetch** (dimension CTE sharing): Pre-filter date_dim and customer once, probe all three fact tables. Expected high win (3× dimension scan elimination).
   - **union_consolidation**: Share dimension lookups across UNION ALL of fact channels. Convert EXCEPT to NOT EXISTS with shared dimension CTEs.
   - **scan_consolidation_pivot**: Combine three fact scans into one with channel discriminator, then filter for store_sales-only tuples. Requires careful handling of EXCEPT semantics.
   - **minimal-change baseline**: Convert comma joins to explicit JOINs only (no structural changes) as safety baseline.

6. **LOGICAL TREE DESIGN**:
   - For dimension sharing: CTE_date (filtered date_dim), CTE_cust (filtered customer). Then three fact joins reference these CTEs.
   - Must include all columns needed downstream: d_date_sk, d_date, c_customer_sk, c_last_name, c_first_name, c_birth_year.
   - Verify column completeness: Each CTE must output join keys and columns used in SELECT list.
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
Business intent: Count distinct customer-date combinations that appear in store sales but NOT in catalog sales nor web sales, for customers born 1955-1961, items priced $242-$271 with wholesale cost $35-$45, during a specific 12-month period. JOIN semantics are strict INNER joins: all three tables must match in each subquery. No aggregation traps (only COUNT). Filter dependencies: date filter (d_month_seq) applies identically to all three channels; customer birth_year filter applies to all channels; price/wholesale filters are channel-specific but identical in value ranges.

BOTTLENECK_DIAGNOSIS:
Dominant cost is repeated nested loop joins from date_dim to each sales fact table (3×). Each date_dim scan returns 182 rows, then probes sales index 182 times per channel, with expensive per-row filtering on list_price and wholesale_cost that discards 70-90% of rows. This is join-bound and scan-bound: 3 independent dimension scans waste I/O. Cardinality flow: date_dim 36K→182, sales tables thousands→hundreds per date, customer highly selective. Optimizer already handles parallel execution and index scans well but cannot share dimension scans across channels. Logical-tree costs are misleading: store_sales appears most expensive due to larger table, but all three channels repeat same dimension work.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output COUNT(*) exactly as original.
- CTE_COLUMN_COMPLETENESS: Any CTE must include d_date_sk, d_date, c_customer_sk, c_last_name, c_first_name, c_birth_year for downstream joins and SELECT.
- LITERAL_PRESERVATION: All numeric literals (1214, 11, 242, 271, 1955, 1961, 35, 45) must be preserved exactly.
- SEMANTIC_EQUIVALENCE: EXCEPT semantics must be preserved; no duplicate introduction or filtering beyond original.
- COMMA_JOIN_WEAKNESS: Query uses comma-separated implicit joins (store_sales, date_dim, customer).
- CROSS_CTE_PREDICATE_BLINDNESS: Same date_dim and customer tables scanned 3× with identical filters.

REGRESSION_WARNINGS:
1. EXISTS to IN/NOT IN (observed regression 0.50x):
   CAUSE: Converting EXCEPT to NOT IN with NULL values blocks hash anti-joins.
   RULE: When converting EXCEPT to NOT EXISTS, ensure join columns are NOT NULL or use NOT EXISTS correlated subquery.
2. Splitting OR to UNION ALL (observed regression 0.21x):
   CAUSE: This query has no OR conditions; do not introduce UNION ALL branches unnecessarily.
   RULE: Only use UNION ALL when consolidating multiple fact table scans with same dimension joins.

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  filtered_date -> filtered_customer -> store_sales_join -> catalog_sales_join -> web_sales_join -> set_difference -> count
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_month_seq BETWEEN 1214 AND 1214+11
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 182
    CONSUMERS: store_sales_join, catalog_sales_join, web_sales_join
  filtered_customer:
    FROM: customer
    WHERE: c_birth_year BETWEEN 1955 AND 1961
    OUTPUT: c_customer_sk, c_last_name, c_first_name
    EXPECTED_ROWS: ~(selectivity from plan)
    CONSUMERS: store_sales_join, catalog_sales_join, web_sales_join
  store_sales_join:
    FROM: filtered_date fd, filtered_customer fc, store_sales
    JOIN: store_sales.ss_sold_date_sk = fd.d_date_sk AND store_sales.ss_customer_sk = fc.c_customer_sk
    WHERE: ss_list_price BETWEEN 242 AND 271 AND ss_wholesale_cost BETWEEN 35 AND 45
    OUTPUT: fc.c_last_name, fc.c_first_name, fd.d_date
    EXPECTED_ROWS: ~(rows from plan)
    CONSUMERS: set_difference
  catalog_sales_join:
    FROM: filtered_date fd, filtered_customer fc, catalog_sales
    JOIN: catalog_sales.cs_sold_date_sk = fd.d_date_sk AND catalog_sales.cs_bill_customer_sk = fc.c_customer_sk
    WHERE: cs_list_price BETWEEN 242 AND 271 AND cs_wholesale_cost BETWEEN 35 AND 45
    OUTPUT: fc.c_last_name, fc.c_first_name, fd.d_date
    EXPECTED_ROWS: ~(rows from plan)
    CONSUMERS: set_difference
  web_sales_join:
    FROM: filtered_date fd, filtered_customer fc, web_sales
    JOIN: web_sales.ws_sold_date_sk = fd.d_date_sk AND web_sales.ws_bill_customer_sk = fc.c_customer_sk
    WHERE: ws_list_price BETWEEN 242 AND 271 AND ws_wholesale_cost BETWEEN 35 AND 45
    OUTPUT: fc.c_last_name, fc.c_first_name, fd.d_date
    EXPECTED_ROWS: ~(rows from plan)
    CONSUMERS: set_difference
  set_difference:
    FROM: store_sales_join ss
    WHERE: NOT EXISTS (SELECT 1 FROM catalog_sales_join cs WHERE cs.c_last_name = ss.c_last_name AND cs.c_first_name = ss.c_first_name AND cs.d_date = ss.d_date)
      AND NOT EXISTS (SELECT 1 FROM web_sales_join ws WHERE ws.c_last_name = ss.c_last_name AND ws.c_first_name = ss.c_first_name AND ws.d_date = ss.d_date)
    OUTPUT: c_last_name, c_first_name, d_date
    EXPECTED_ROWS: 0 (from plan)
    CONSUMERS: count
  count:
    AGGREGATE: COUNT(*)
    OUTPUT: count
    EXPECTED_ROWS: 1
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join, early_filter_decorrelate
EXAMPLE_ADAPTATION:
- pg_dimension_prefetch_star: Apply pre-filtering of date_dim and customer into CTEs; convert comma joins to explicit JOIN syntax. Ignore the promotion/item dimensions (not present here).
- pg_date_cte_explicit_join: Use date_dim CTE with explicit JOINs; also add customer CTE. Ignore any window function optimizations.
- early_filter_decorrelate: Push dimension filters into CTE definitions before joins. Ignore decorrelation (no correlated subqueries).
HAZARD_FLAGS:
- Must ensure DISTINCT semantics preserved (original has DISTINCT in each branch).
- NOT EXISTS must correlate on all three output columns (c_last_name, c_first_name, d_date).

=== WORKER 2 BRIEFING ===

STRATEGY: union_consolidation
TARGET_LOGICAL_TREE:
  filtered_date -> filtered_customer -> sales_union -> grouped_sales -> filter_store_only -> count
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_month_seq BETWEEN 1214 AND 1214+11
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 182
    CONSUMERS: sales_union
  filtered_customer:
    FROM: customer
    WHERE: c_birth_year BETWEEN 1955 AND 1961
    OUTPUT: c_customer_sk, c_last_name, c_first_name
    EXPECTED_ROWS: ~(selectivity)
    CONSUMERS: sales_union
  sales_union:
    FROM: 
      (SELECT 'store' AS channel, fc.c_last_name, fc.c_first_name, fd.d_date
       FROM filtered_date fd, filtered_customer fc, store_sales
       WHERE store_sales.ss_sold_date_sk = fd.d_date_sk
         AND store_sales.ss_customer_sk = fc.c_customer_sk
         AND ss_list_price BETWEEN 242 AND 271
         AND ss_wholesale_cost BETWEEN 35 AND 45)
      UNION ALL
      (SELECT 'catalog', fc.c_last_name, fc.c_first_name, fd.d_date
       FROM filtered_date fd, filtered_customer fc, catalog_sales
       WHERE catalog_sales.cs_sold_date_sk = fd.d_date_sk
         AND catalog_sales.cs_bill_customer_sk = fc.c_customer_sk
         AND cs_list_price BETWEEN 242 AND 271
         AND cs_wholesale_cost BETWEEN 35 AND 45)
      UNION ALL
      (SELECT 'web', fc.c_last_name, fc.c_first_name, fd.d_date
       FROM filtered_date fd, filtered_customer fc, web_sales
       WHERE web_sales.ws_sold_date_sk = fd.d_date_sk
         AND web_sales.ws_bill_customer_sk = fc.c_customer_sk
         AND ws_list_price BETWEEN 242 AND 271
         AND ws_wholesale_cost BETWEEN 35 AND 45)
    OUTPUT: channel, c_last_name, c_first_name, d_date
    EXPECTED_ROWS: sum of rows from three channels
    CONSUMERS: grouped_sales
  grouped_sales:
    FROM: sales_union
    GROUP BY: c_last_name, c_first_name, d_date
    AGGREGATE: array_agg(DISTINCT channel) AS channels_present
    OUTPUT: c_last_name, c_first_name, d_date, channels_present
    EXPECTED_ROWS: distinct tuples across all channels
    CONSUMERS: filter_store_only
  filter_store_only:
    FROM: grouped_sales
    WHERE: channels_present = ARRAY['store']::text[]
    OUTPUT: c_last_name, c_first_name, d_date
    EXPECTED_ROWS: store-only tuples (same as EXCEPT result)
    CONSUMERS: count
  count:
    AGGREGATE: COUNT(*)
    OUTPUT: count
    EXPECTED_ROWS: 1
EXAMPLES: shared_dimension_multi_channel, union_cte_split, pg_self_join_decomposition
EXAMPLE_ADAPTATION:
- shared_dimension_multi_channel: Share filtered date_dim and customer CTEs across UNION ALL branches. Ignore any aggregation pushdown.
- union_cte_split: Use UNION ALL to combine channels, then group by output columns. Ignore splitting into separate CTEs (we're consolidating).
- pg_self_join_decomposition: Materialize filtered dimensions once and reuse across channels. Ignore the self-join pattern.
HAZARD_FLAGS:
- Must handle duplicate tuples within a channel (original has DISTINCT per channel). Use DISTINCT inside each UNION ALL branch or GROUP BY with array_agg(DISTINCT).
- array_agg(DISTINCT) ordering may differ but semantic equivalence preserved.

=== WORKER 3 BRIEFING ===

STRATEGY: scan_consolidation_pivot
TARGET_LOGICAL_TREE:
  filtered_date -> filtered_customer -> sales_consolidated -> pivot_filter -> count
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_month_seq BETWEEN 1214 AND 1214+11
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 182
    CONSUMERS: sales_consolidated
  filtered_customer:
    FROM: customer
    WHERE: c_birth_year BETWEEN 1955 AND 1961
    OUTPUT: c_customer_sk, c_last_name, c_first_name
    EXPECTED_ROWS: ~(selectivity)
    CONSUMERS: sales_consolidated
  sales_consolidated:
    FROM: 
      (SELECT fd.d_date_sk, fd.d_date, fc.c_customer_sk, fc.c_last_name, fc.c_first_name,
              'store' AS channel,
              CASE WHEN ss.ss_sold_date_sk IS NOT NULL 
                   AND ss.ss_list_price BETWEEN 242 AND 271 
                   AND ss.ss_wholesale_cost BETWEEN 35 AND 45 
                   THEN 1 ELSE 0 END AS store_flag,
              'catalog' AS channel2,
              CASE WHEN cs.cs_sold_date_sk IS NOT NULL 
                   AND cs.cs_list_price BETWEEN 242 AND 271 
                   AND cs.cs_wholesale_cost BETWEEN 35 AND 45 
                   THEN 1 ELSE 0 END AS catalog_flag,
              'web' AS channel3,
              CASE WHEN ws.ws_sold_date_sk IS NOT NULL 
                   AND ws.ws_list_price BETWEEN 242 AND 271 
                   AND ws.ws_wholesale_cost BETWEEN 35 AND 45 
                   THEN 1 ELSE 0 END AS web_flag
       FROM filtered_date fd
       CROSS JOIN filtered_customer fc
       LEFT JOIN store_sales ss ON ss.ss_sold_date_sk = fd.d_date_sk AND ss.ss_customer_sk = fc.c_customer_sk
       LEFT JOIN catalog_sales cs ON cs.cs_sold_date_sk = fd.d_date_sk AND cs.cs_bill_customer_sk = fc.c_customer_sk
       LEFT JOIN web_sales ws ON ws.ws_sold_date_sk = fd.d_date_sk AND ws.ws_bill_customer_sk = fc.c_customer_sk)
    OUTPUT: d_date_sk, d_date, c_customer_sk, c_last_name, c_first_name, store_flag, catalog_flag, web_flag
    EXPECTED_ROWS: 182 * customer_rows (Cartesian product)
    CONSUMERS: pivot_filter
  pivot_filter:
    FROM: sales_consolidated
    WHERE: store_flag = 1 AND catalog_flag = 0 AND web_flag = 0
    OUTPUT: c_last_name, c_first_name, d_date
    EXPECTED_ROWS: store-only tuples
    CONSUMERS: count
  count:
    AGGREGATE: COUNT(*)
    OUTPUT: count
    EXPECTED_ROWS: 1
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Combine three channel checks into a single scan with CASE flags. Ignore any aggregation (we're not aggregating across channels).
- channel_bitmap_aggregation: Use bitmap of channel presence via integer flags. Ignore the bitmap aggregation if using simple CASE.
HAZARD_FLAGS:
- Cartesian product of filtered_date and filtered_customer could be large (182 * ~thousands). Must ensure join selectivity is applied via LEFT JOIN conditions.
- Must preserve DISTINCT semantics: original deduplicates within each channel; this approach may produce duplicates if a customer-date appears multiple times in store_sales. Need DISTINCT on output.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: minimal_change_explicit_joins
TARGET_LOGICAL_TREE:
  store_subquery -> catalog_subquery -> web_subquery -> except_chain -> count
NODE_CONTRACTS:
  store_subquery:
    FROM: store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk
          JOIN customer ON store_sales.ss_customer_sk = customer.c_customer_sk
    WHERE: d_month_seq BETWEEN 1214 AND 1214+11
      AND ss_list_price BETWEEN 242 AND 271
      AND c_birth_year BETWEEN 1955 AND 1961
      AND ss_wholesale_cost BETWEEN 35 AND 45
    OUTPUT: c_last_name, c_first_name, d_date
    EXPECTED_ROWS: ~(rows from plan)
    CONSUMERS: except_chain
  catalog_subquery:
    FROM: catalog_sales JOIN date_dim ON catalog_sales.cs_sold_date_sk = date_dim.d_date_sk
          JOIN customer ON catalog_sales.cs_bill_customer_sk = customer.c_customer_sk
    WHERE: d_month_seq BETWEEN 1214 AND 1214+11
      AND cs_list_price BETWEEN 242 AND 271
      AND c_birth_year BETWEEN 1955 AND 1961
      AND cs_wholesale_cost BETWEEN 35 AND 45
    OUTPUT: c_last_name, c_first_name, d_date
    EXPECTED_ROWS: ~(rows from plan)
    CONSUMERS: except_chain
  web_subquery:
    FROM: web_sales JOIN date_dim ON web_sales.ws_sold_date_sk = date_dim.d_date_sk
          JOIN customer ON web_sales.ws_bill_customer_sk = customer.c_customer_sk
    WHERE: d_month_seq BETWEEN 1214 AND 1214+11
      AND ws_list_price BETWEEN 242 AND 271
      AND c_birth_year BETWEEN 1955 AND 1961
      AND ws_wholesale_cost BETWEEN 35 AND 45
    OUTPUT: c_last_name, c_first_name, d_date
    EXPECTED_ROWS: ~(rows from plan)
    CONSUMERS: except_chain
  except_chain:
    FROM: (store_subquery EXCEPT catalog_subquery EXCEPT web_subquery)
    OUTPUT: c_last_name, c_first_name, d_date
    EXPECTED_ROWS: 0
    CONSUMERS: count
  count:
    AGGREGATE: COUNT(*)
    OUTPUT: count
    EXPECTED_ROWS: 1
EXAMPLES: pg_date_cte_explicit_join
EXAMPLE_ADAPTATION:
- pg_date_cte_explicit_join: Convert comma-separated joins to explicit JOIN syntax only. Do NOT add any CTEs; keep original EXCEPT structure. Ignore the date CTE isolation part.
HAZARD_FLAGS:
- Minimal change may not improve performance; serves as baseline for regression safety.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: constraint_relaxation (testing if explicit JOIN syntax alone addresses COMMA_JOIN_WEAKNESS without structural changes)