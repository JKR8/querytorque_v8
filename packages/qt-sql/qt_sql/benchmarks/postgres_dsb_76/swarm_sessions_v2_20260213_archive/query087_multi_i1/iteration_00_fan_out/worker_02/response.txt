## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~5.0M
    ├── [~] CTE filtered_date
    │   ├── SCAN date_dim  [=]
    │   └── FILTER d_month_seq BETWEEN 1214 AND 1225  [~] (changed: exact range)
    ├── [~] CTE filtered_customer
    │   ├── SCAN customer  [=]
    │   └── FILTER c_birth_year BETWEEN 1955 AND 1961  [=]
    ├── [+] CTE sales_union
    │   ├── UNION ALL (3 branches)
    │   ├── BRANCH 1: store_sales JOIN filtered_date JOIN filtered_customer
    │   ├── BRANCH 2: catalog_sales JOIN filtered_date JOIN filtered_customer  
    │   └── BRANCH 3: web_sales JOIN filtered_date JOIN filtered_customer
    ├── [~] CTE grouped_sales
    │   └── GROUP BY (c_last_name, c_first_name, d_date) with array_agg(DISTINCT channel)
    ├── [~] CTE filter_store_only
    │   └── FILTER channels_present = ARRAY['store']::text[]
    └── [~] OUTPUT COUNT(*)  [=] (final count)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1", 
      "type": "shared_dimension_materialization",
      "description": "Materialize filtered date_dim and customer once, reuse across three channels",
      "applied_to": ["filtered_date", "filtered_customer", "sales_union"]
    },
    {
      "id": "R2",
      "type": "except_to_array_intersection", 
      "description": "Replace EXCEPT with UNION ALL + array_agg(DISTINCT) + filter for store-only",
      "applied_to": ["sales_union", "grouped_sales", "filter_store_only"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1214 AND 1214+11",
        "interfaces": {
          "outputs": ["d_date_sk", "d_date"],
          "consumes": []
        }
      },
      "filtered_customer": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT c_customer_sk, c_last_name, c_first_name FROM customer WHERE c_birth_year BETWEEN 1955 AND 1961",
        "interfaces": {
          "outputs": ["c_customer_sk", "c_last_name", "c_first_name"],
          "consumes": []
        }
      },
      "sales_union": {
        "type": "cte",
        "change": "added",
        "sql": "(SELECT DISTINCT 'store' AS channel, fc.c_last_name, fc.c_first_name, fd.d_date FROM filtered_date fd, filtered_customer fc, store_sales WHERE store_sales.ss_sold_date_sk = fd.d_date_sk AND store_sales.ss_customer_sk = fc.c_customer_sk AND ss_list_price BETWEEN 242 AND 271 AND ss_wholesale_cost BETWEEN 35 AND 45) UNION ALL (SELECT DISTINCT 'catalog' AS channel, fc.c_last_name, fc.c_first_name, fd.d_date FROM filtered_date fd, filtered_customer fc, catalog_sales WHERE catalog_sales.cs_sold_date_sk = fd.d_date_sk AND catalog_sales.cs_bill_customer_sk = fc.c_customer_sk AND cs_list_price BETWEEN 242 AND 271 AND cs_wholesale_cost BETWEEN 35 AND 45) UNION ALL (SELECT DISTINCT 'web' AS channel, fc.c_last_name, fc.c_first_name, fd.d_date FROM filtered_date fd, filtered_customer fc, web_sales WHERE web_sales.ws_sold_date_sk = fd.d_date_sk AND web_sales.ws_bill_customer_sk = fc.c_customer_sk AND ws_list_price BETWEEN 242 AND 271 AND ws_wholesale_cost BETWEEN 35 AND 45)",
        "interfaces": {
          "outputs": ["channel", "c_last_name", "c_first_name", "d_date"],
          "consumes": ["filtered_date", "filtered_customer"]
        }
      },
      "grouped_sales": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT c_last_name, c_first_name, d_date, array_agg(DISTINCT channel) AS channels_present FROM sales_union GROUP BY c_last_name, c_first_name, d_date",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date", "channels_present"],
          "consumes": ["sales_union"]
        }
      },
      "filter_store_only": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, d_date FROM grouped_sales WHERE channels_present = ARRAY['store']::text[]",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": ["grouped_sales"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT COUNT(*) AS count FROM filter_store_only",
        "interfaces": {
          "outputs": ["count"],
          "consumes": ["filter_store_only"]
        }
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_customer", "sales_union", "grouped_sales", "filter_store_only", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_customer AS ({filtered_customer}), sales_union AS ({sales_union}), grouped_sales AS ({grouped_sales}), filter_store_only AS ({filter_store_only}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

Changes: Transformed original EXCEPT pattern into shared dimension CTEs + UNION ALL + array_agg(DISTINCT) + filter, preserving exact EXCEPT semantics (store-only tuples) while eliminating redundant dimension table scans.

Expected speedup: 3-4x (eliminates 2 redundant full dimension table scans and reduces JOIN overhead through materialized CTEs)