## Modified Logic Tree

```
QUERY:
├── [CTE] date_filter [+]  (new component)
├── [CTE] returning_addr [+]  (new component)
├── [CTE] fact_agg [+]  (new component, replaces customer_total_return)
├── [CTE] state_filter [+]  (new component)
├── [CTE] customer_filter [+]  (new component)
└── [MAIN] late_addr_join [~]  (modified: now consumes customer_filter instead of original tables)
    ├── SCAN (customer_filter AS cf, customer_address)
    ├── JOIN (subquery on customer.c_current_addr_sk)
    ├── FILTER (ca_state = 'OH')
    ├── SORT (original 16 columns)
    └── LIMIT (100)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "early_filter_decorrelate",
      "description": "Push date filter early into CTE, pre-aggregate with early joins, use LATERAL for per-state threshold",
      "applied_to": ["date_filter", "returning_addr", "fact_agg", "state_filter"]
    },
    {
      "id": "R2",
      "type": "pg_materialized_dimension_fact_prefilter",
      "description": "Stage reduction: create filtered CTEs for dimensions before expensive aggregation",
      "applied_to": ["date_filter", "returning_addr"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "date_filter": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "returning_addr": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT ca_address_sk, ca_state FROM customer_address",
          "interfaces": {
            "outputs": ["ca_address_sk", "ca_state"],
            "consumes": []
          }
        },
        "fact_agg": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT cr.cr_returning_customer_sk AS ctr_customer_sk, ra.ca_state AS ctr_state, SUM(cr.cr_return_amt_inc_tax) AS ctr_total_return FROM catalog_returns cr INNER JOIN date_filter d ON cr.cr_returned_date_sk = d.d_date_sk INNER JOIN returning_addr ra ON cr.cr_returning_addr_sk = ra.ca_address_sk GROUP BY cr.cr_returning_customer_sk, ra.ca_state",
          "interfaces": {
            "outputs": ["ctr_customer_sk", "ctr_state", "ctr_total_return"],
            "consumes": ["date_filter", "returning_addr"]
          }
        },
        "state_filter": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT f.ctr_customer_sk, f.ctr_state, f.ctr_total_return FROM fact_agg f CROSS JOIN LATERAL (SELECT AVG(f2.ctr_total_return) * 1.2 AS threshold FROM fact_agg f2 WHERE f.ctr_state = f2.ctr_state) AS state_avg WHERE f.ctr_total_return > state_avg.threshold",
          "interfaces": {
            "outputs": ["ctr_customer_sk", "ctr_state", "ctr_total_return"],
            "consumes": ["fact_agg"]
          }
        },
        "customer_filter": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT sf.ctr_customer_sk, sf.ctr_state, sf.ctr_total_return, c.c_customer_id, c.c_salutation, c.c_first_name, c.c_last_name FROM state_filter sf INNER JOIN customer c ON sf.ctr_customer_sk = c.c_customer_sk WHERE EXISTS (SELECT 1 FROM customer_address ca WHERE ca.ca_address_sk = c.c_current_addr_sk AND ca.ca_state = 'OH')",
          "interfaces": {
            "outputs": ["ctr_customer_sk", "ctr_state", "ctr_total_return", "c_customer_id", "c_salutation", "c_first_name", "c_last_name"],
            "consumes": ["state_filter"]
          }
        },
        "late_addr_join": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT cf.c_customer_id, cf.c_salutation, cf.c_first_name, cf.c_last_name, ca.ca_street_number, ca.ca_street_name, ca.ca_street_type, ca.ca_suite_number, ca.ca_city, ca.ca_county, ca.ca_state, ca.ca_zip, ca.ca_country, ca.ca_gmt_offset, ca.ca_location_type, cf.ctr_total_return FROM customer_filter cf INNER JOIN customer_address ca ON ca.ca_address_sk = (SELECT c_current_addr_sk FROM customer WHERE c_customer_sk = cf.ctr_customer_sk) WHERE ca.ca_state = 'OH' ORDER BY cf.c_customer_id, cf.c_salutation, cf.c_first_name, cf.c_last_name, ca.ca_street_number, ca.ca_street_name, ca.ca_street_type, ca.ca_suite_number, ca.ca_city, ca.ca_county, ca.ca_state, ca.ca_zip, ca.ca_country, ca.ca_gmt_offset, ca.ca_location_type, cf.ctr_total_return LIMIT 100",
          "interfaces": {
            "outputs": ["c_customer_id", "c_salutation", "c_first_name", "c_last_name", "ca_street_number", "ca_street_name", "ca_street_type", "ca_suite_number", "ca_city", "ca_county", "ca_state", "ca_zip", "ca_country", "ca_gmt_offset", "ca_location_type", "ctr_total_return"],
            "consumes": ["customer_filter"]
          }
        }
      },
      "reconstruction_order": ["date_filter", "returning_addr", "fact_agg", "state_filter", "customer_filter", "late_addr_join"],
      "assembly_template": "WITH date_filter AS ({date_filter}), returning_addr AS ({returning_addr}), fact_agg AS ({fact_agg}), state_filter AS ({state_filter}), customer_filter AS ({customer_filter}) {late_addr_join}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Replaced single monolithic CTE with staged CTE pipeline: date and address filters first, then aggregation, then state-wise comparison via LATERAL, then customer filtering via EXISTS, final address join. Preserves original semantics while enabling early filtering and decorrelation of state average.

**Expected speedup**: ~1.5-2x from reduced intermediate rows and decorrelated per-state computation.