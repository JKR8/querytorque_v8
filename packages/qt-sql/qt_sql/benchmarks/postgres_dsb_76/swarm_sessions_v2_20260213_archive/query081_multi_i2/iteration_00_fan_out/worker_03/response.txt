## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] base_agg_cte (was: customer_total_return)  [~]
│   ├── SCAN (catalog_returns cr INNER JOIN date_dim d, customer_address ca1)
│   ├── JOIN (cr.cr_returned_date_sk = d.d_date_sk)
│   ├── JOIN (cr.cr_returning_addr_sk = ca1.ca_address_sk)
│   ├── FILTER (d.d_year = 2002)
│   ├── AGG (GROUP BY cr.cr_returning_customer_sk, ca1.ca_state)
│   └── OUTPUT (ctr_customer_sk, ctr_state, ctr_total_return)
├── [CTE] state_avg_cte  [+]
│   ├── SCAN (base_agg_cte)
│   ├── AGG (GROUP BY ctr_state)
│   └── OUTPUT (ctr_state, state_avg_threshold)
└── [MAIN] main_filtered_join (was: main_query)  [~]
    ├── SCAN (base_agg_cte ctr1 INNER JOIN state_avg_cte sa, customer c, customer_address ca2)
    ├── JOIN (ctr1.ctr_state = sa.ctr_state)
    ├── JOIN (ctr1.ctr_customer_sk = c.c_customer_sk)
    ├── JOIN (ca2.ca_address_sk = c.c_current_addr_sk)
    ├── FILTER (ca2.ca_state = 'OH')
    ├── FILTER (ctr1.ctr_total_return > sa.state_avg_threshold)
    ├── SORT (original 16 columns)
    └── OUTPUT (original 16 columns)
```

**Change markers:**
- `[~]` base_agg_cte: Renamed from `customer_total_return` to match logical tree; explicit JOIN syntax; otherwise same semantics.
- `[+]` state_avg_cte: New CTE replacing correlated subquery; computes 120% of average returns per state.
- `[~]` main_filtered_join: Replaces correlated subquery with join to `state_avg_cte`; explicit JOIN syntax; same filters and ordering.

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_decomposition", "description": "Replace correlated subquery with derived CTE for state averages", "applied_to": ["state_avg_cte", "main_filtered_join"]},
    {"id": "R2", "type": "explicit_join_conversion", "description": "Convert comma joins to explicit INNER JOIN syntax", "applied_to": ["base_agg_cte", "main_filtered_join"]},
    {"id": "R3", "type": "shared_materialization", "description": "Materialize base scan once, reuse for per-state aggregates and main join", "applied_to": ["base_agg_cte"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "base_agg_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cr.cr_returning_customer_sk AS ctr_customer_sk, ca1.ca_state AS ctr_state, SUM(cr.cr_return_amt_inc_tax) AS ctr_total_return FROM catalog_returns cr INNER JOIN date_dim d ON cr.cr_returned_date_sk = d.d_date_sk INNER JOIN customer_address ca1 ON cr.cr_returning_addr_sk = ca1.ca_address_sk WHERE d.d_year = 2002 GROUP BY cr.cr_returning_customer_sk, ca1.ca_state",
        "interfaces": {"outputs": ["ctr_customer_sk", "ctr_state", "ctr_total_return"], "consumes": []}
      },
      "state_avg_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ctr_state, AVG(ctr_total_return) * 1.2 AS state_avg_threshold FROM base_agg_cte GROUP BY ctr_state",
        "interfaces": {"outputs": ["ctr_state", "state_avg_threshold"], "consumes": ["base_agg_cte"]}
      },
      "main_filtered_join": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c.c_customer_id, c.c_salutation, c.c_first_name, c.c_last_name, ca2.ca_street_number, ca2.ca_street_name, ca2.ca_street_type, ca2.ca_suite_number, ca2.ca_city, ca2.ca_county, ca2.ca_state, ca2.ca_zip, ca2.ca_country, ca2.ca_gmt_offset, ca2.ca_location_type, ctr1.ctr_total_return FROM base_agg_cte ctr1 INNER JOIN state_avg_cte sa ON ctr1.ctr_state = sa.ctr_state INNER JOIN customer c ON ctr1.ctr_customer_sk = c.c_customer_sk INNER JOIN customer_address ca2 ON ca2.ca_address_sk = c.c_current_addr_sk WHERE ca2.ca_state = 'OH' AND ctr1.ctr_total_return > sa.state_avg_threshold ORDER BY c.c_customer_id, c.c_salutation, c.c_first_name, c.c_last_name, ca2.ca_street_number, ca2.ca_street_name, ca2.ca_street_type, ca2.ca_suite_number, ca2.ca_city, ca2.ca_county, ca2.ca_state, ca2.ca_zip, ca2.ca_country, ca2.ca_gmt_offset, ca2.ca_location_type, ctr1.ctr_total_return LIMIT 100",
        "interfaces": {"outputs": ["c_customer_id", "c_salutation", "c_first_name", "c_last_name", "ca_street_number", "ca_street_name", "ca_street_type", "ca_suite_number", "ca_city", "ca_county", "ca_state", "ca_zip", "ca_country", "ca_gmt_offset", "ca_location_type", "ctr_total_return"], "consumes": ["base_agg_cte", "state_avg_cte"]}
      }
    },
    "reconstruction_order": ["base_agg_cte", "state_avg_cte", "main_filtered_join"],
    "assembly_template": "WITH base_agg_cte AS ({base_agg_cte}), state_avg_cte AS ({state_avg_cte}) {main_filtered_join}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Replaced correlated subquery with a CTE that computes state averages once, then joined. Used explicit INNER JOINs throughout. Preserved all original semantics, literals (2002, 1.2, 'OH'), and output column order.

**Expected speedup:** ~3-4x by eliminating per-row correlated subquery execution and materializing the base scan once.