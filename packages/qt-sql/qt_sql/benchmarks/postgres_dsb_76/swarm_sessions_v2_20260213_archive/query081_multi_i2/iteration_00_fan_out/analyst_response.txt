<reasoning>
1. **CLASSIFY**: This is a "correlated-aggregate filter" archetype with star-join characteristics. The query:
   - Has a CTE that aggregates fact table (catalog_returns) with dimension joins (date_dim, customer_address)
   - In the main query, filters rows where the aggregated value > 1.2× the state average (correlated subquery on same CTE)
   - Then joins with customer and customer_address (different instance) for current address
   - Filters to state 'OH' (current address state, not returning address state)

2. **EXPLAIN PLAN ANALYSIS**: No EXPLAIN output provided, but logical tree shows:
   - CTE scans catalog_returns (~50% cost) with joins to date_dim (filtered to 2002) and customer_address
   - Main query scans CTE twice: once as ctr1 (join), once as ctr2 (correlated subquery)
   - Missed optimization: The correlated subquery re-executes per state; could be pre-computed
   - The CTE likely gets materialized once (PostgreSQL default for multiple references)
   - Cardinality flow: catalog_returns → aggregated to ~1K rows (CTE) → filtered by OH state and aggregate condition → final 100 rows

3. **GAP MATCHING**:
   - **CORRELATED_SUBQUERY_PARALYSIS**: Yes! Line 19-21 has `ctr1.ctr_total_return > (SELECT avg(ctr_total_return)*1.2 FROM customer_total_return ctr2 WHERE ctr1.ctr_state = ctr2.ctr_state)`
   - **COMMA_JOIN_WEAKNESS**: Yes! Lines 5-7 and 16-18 use comma-separated implicit joins
   - **CROSS_CTE_PREDICATE_BLINDNESS**: Potentially - same CTE referenced twice
   - Optimizer strengths: PostgreSQL should handle INNER_JOIN_REORDERING well, but comma joins may confuse it

4. **AGGREGATION TRAP CHECK**: Only SUM and AVG aggregates. Both are duplicate-sensitive if joins change row counts. The CTE groups by cr_returning_customer_sk, ca_state before the main query joins. Need to ensure joins don't introduce duplicates that would change the SUM values. The main query joins on ctr_customer_sk = c_customer_sk (1:1) and ca_address_sk = c_current_addr_sk (1:1 for current address), so no duplication risk.

5. **TRANSFORM SELECTION** (ranked by expected value):
   a) **inline_decorrelate_materialized**: Addresses correlated subquery directly (highest impact)
   b) **pg_dimension_prefetch_star**: Addresses comma joins and pre-filters dimensions
   c) **pg_self_join_decomposition**: Eliminates duplicate CTE reference
   d) **pg_materialized_dimension_fact_prefilter**: Staged reduction for non-equi join (the > condition)

6. **LOGICAL TREE DESIGN**:
   For each strategy, need to ensure CTE column completeness:
   - Original CTE outputs: ctr_customer_sk, ctr_state, ctr_total_return
   - Downstream references: ctr1 uses all three; ctr2 subquery uses ctr_state, ctr_total_return
   - Main query joins need: ctr_customer_sk for customer join, ctr_state for filter
   
   Also note: The query uses customer_address TWICE:
   - In CTE: cr_returning_addr_sk = ca_address_sk (returning address)
   - In main: ca_address_sk = c_current_addr_sk (current address, filtered to 'OH')
   These are DIFFERENT customer_address instances with different semantics!
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
This query finds Ohio customers whose total 2002 catalog returns (at their returning address state) exceed 120% of the average returns for that returning state. All joins are INNER: catalog_returns must match date_dim (2002) and returning customer_address; the aggregated CTE must match customer and current customer_address (Ohio). The aggregates SUM and AVG are duplicate-sensitive but safe because joins preserve 1:1 cardinality on grouping keys. The current address filter (ca_state = 'OH') depends on customer_address re-join, not the CTE's returning address state.

BOTTLENECK_DIAGNOSIS:
The correlated subquery executing per state dominates cost—PostgreSQL re-evaluates AVG(ctr_total_return) for each outer CTE row's state. The CTE materialization (once) is efficient, but the per-state subquery forces repeated aggregation scans. Cardinality: catalog_returns (large) → CTE (~1K rows) → OH filter reduces, then correlated filter reduces further → 100 rows. The optimizer already handles INNER join reordering well; logical-tree 50/50 cost split is misleading—correlation overhead dwarfs scan costs.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output all 16 columns from original SELECT in same order.
- CTE_COLUMN_COMPLETENESS: CTEs must include cr_returning_customer_sk, ca_state, cr_return_amt_inc_tax (for SUM), plus any join keys for downstream.
- LITERAL_PRESERVATION: Must preserve d_year=2002, multiplier 1.2, state 'OH'.
- SEMANTIC_EQUIVALENCE: Result must match original exactly.
- CORRELATED_SUBQUERY_PARALYSIS: Correlated subquery at lines 19-21 causes per-state re-execution.
- COMMA_JOIN_WEAKNESS: Implicit comma joins at lines 5-7 and 16-18 hinder cardinality estimation.

REGRESSION_WARNINGS:
None applicable.

=== WORKER 1 BRIEFING ===

STRATEGY: inline_decorrelate_materialized
TARGET_LOGICAL_TREE:
  date_filter_cte -> returning_addr_cte -> fact_agg_cte -> state_avg_cte -> main_join
NODE_CONTRACTS:
  date_filter:
    FROM: date_dim
    WHERE: d_year = 2002
    OUTPUT: d_date_sk
    EXPECTED_ROWS: ~365
    CONSUMERS: fact_agg_cte
  returning_addr_cte:
    FROM: customer_address
    WHERE: (no filter - all returning addresses)
    OUTPUT: ca_address_sk, ca_state
    EXPECTED_ROWS: all customer_address rows
    CONSUMERS: fact_agg_cte
  fact_agg_cte:
    FROM: catalog_returns cr JOIN date_filter df ON cr.cr_returned_date_sk = df.d_date_sk
           JOIN returning_addr_cte ra ON cr.cr_returning_addr_sk = ra.ca_address_sk
    GROUP BY: cr.cr_returning_customer_sk, ra.ca_state
    AGGREGATE: SUM(cr.cr_return_amt_inc_tax) AS ctr_total_return
    OUTPUT: cr.cr_returning_customer_sk AS ctr_customer_sk, ra.ca_state AS ctr_state, ctr_total_return
    EXPECTED_ROWS: ~1K
    CONSUMERS: state_avg_cte, main_join
  state_avg_cte:
    FROM: fact_agg_cte
    GROUP BY: ctr_state
    AGGREGATE: AVG(ctr_total_return) * 1.2 AS state_avg_threshold
    OUTPUT: ctr_state, state_avg_threshold
    EXPECTED_ROWS: number of distinct states in CTE
    CONSUMERS: main_join
  main_join:
    FROM: fact_agg_cte f
          JOIN state_avg_cte s ON f.ctr_state = s.ctr_state
          JOIN customer c ON f.ctr_customer_sk = c.c_customer_sk
          JOIN customer_address ca ON ca.ca_address_sk = c.c_current_addr_sk
    WHERE: ca.ca_state = 'OH' AND f.ctr_total_return > s.state_avg_threshold
    ORDER BY: (original 16-column ORDER BY list)
    LIMIT: 100
    OUTPUT: (original 16 columns)
    EXPECTED_ROWS: 100
    CONSUMERS: final output
EXAMPLES: inline_decorrelate_materialized
EXAMPLE_ADAPTATION:
- Apply: Decompose correlated subquery into 3 MATERIALIZED CTEs: date filter, fact aggregation, state averages
- Ignore: The example's dimension pre-filtering - we keep returning_addr_cte unfiltered
HAZARD_FLAGS:
- Must use AS MATERIALIZED on CTEs to prevent PostgreSQL from inlining back to correlated form
- Returning address vs current address distinction critical: don't filter returning_addr_cte by 'OH'

=== WORKER 2 BRIEFING ===

STRATEGY: pg_dimension_prefetch_star
TARGET_LOGICAL_TREE:
  date_prefilter -> addr_prefilter -> fact_agg -> state_avg -> main_explicit_joins
NODE_CONTRACTS:
  date_prefilter:
    FROM: date_dim
    WHERE: d_year = 2002
    OUTPUT: d_date_sk
    EXPECTED_ROWS: ~365
    CONSUMERS: fact_agg
  addr_prefilter:
    FROM: customer_address
    OUTPUT: ca_address_sk, ca_state
    EXPECTED_ROWS: all customer_address rows
    CONSUMERS: fact_agg
  fact_agg:
    FROM: catalog_returns cr
          INNER JOIN date_prefilter d ON cr.cr_returned_date_sk = d.d_date_sk
          INNER JOIN addr_prefilter a ON cr.cr_returning_addr_sk = a.ca_address_sk
    GROUP BY: cr.cr_returning_customer_sk, a.ca_state
    AGGREGATE: SUM(cr.cr_return_amt_inc_tax) AS ctr_total_return
    OUTPUT: cr.cr_returning_customer_sk AS ctr_customer_sk, a.ca_state AS ctr_state, ctr_total_return
    EXPECTED_ROWS: ~1K
    CONSUMERS: state_avg, main_explicit_joins
  state_avg:
    FROM: fact_agg
    GROUP BY: ctr_state
    AGGREGATE: AVG(ctr_total_return) * 1.2 AS state_avg_threshold
    OUTPUT: ctr_state, state_avg_threshold
    EXPECTED_ROWS: distinct states
    CONSUMERS: main_explicit_joins
  main_explicit_joins:
    FROM: fact_agg ctr1
          INNER JOIN state_avg sa ON ctr1.ctr_state = sa.ctr_state
          INNER JOIN customer c ON ctr1.ctr_customer_sk = c.c_customer_sk
          INNER JOIN customer_address ca ON ca.ca_address_sk = c.c_current_addr_sk
    WHERE: ca.ca_state = 'OH' AND ctr1.ctr_total_return > sa.state_avg_threshold
    ORDER BY: (original 16 columns)
    LIMIT: 100
    OUTPUT: (original 16 columns)
    EXPECTED_ROWS: 100
    CONSUMERS: final output
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join
EXAMPLE_ADAPTATION:
- Apply pg_dimension_prefetch_star: Pre-filter date_dim into CTE, convert all comma joins to explicit INNER JOIN syntax
- Apply pg_date_cte_explicit_join: Isolate date filter into CTE AND use explicit joins
- Ignore: Promotion/item filtering from examples - we only have date and address dimensions
HAZARD_FLAGS:
- Explicit JOIN syntax must preserve original INNER semantics
- Returning address CTE must not be filtered by 'OH' (different semantic)

=== WORKER 3 BRIEFING ===

STRATEGY: pg_self_join_decomposition
TARGET_LOGICAL_TREE:
  base_agg_cte -> state_avg_cte -> main_filtered_join
NODE_CONTRACTS:
  base_agg_cte:
    FROM: catalog_returns cr
          INNER JOIN date_dim d ON cr.cr_returned_date_sk = d.d_date_sk
          INNER JOIN customer_address ca1 ON cr.cr_returning_addr_sk = ca1.ca_address_sk
    WHERE: d.d_year = 2002
    GROUP BY: cr.cr_returning_customer_sk, ca1.ca_state
    AGGREGATE: SUM(cr.cr_return_amt_inc_tax) AS ctr_total_return
    OUTPUT: cr.cr_returning_customer_sk AS ctr_customer_sk, ca1.ca_state AS ctr_state, ctr_total_return
    EXPECTED_ROWS: ~1K
    CONSUMERS: state_avg_cte, main_filtered_join
  state_avg_cte:
    FROM: base_agg_cte
    GROUP BY: ctr_state
    AGGREGATE: AVG(ctr_total_return) * 1.2 AS state_avg_threshold
    OUTPUT: ctr_state, state_avg_threshold
    EXPECTED_ROWS: distinct states
    CONSUMERS: main_filtered_join
  main_filtered_join:
    FROM: base_agg_cte ctr1
          INNER JOIN state_avg_cte sa ON ctr1.ctr_state = sa.ctr_state
          INNER JOIN customer c ON ctr1.ctr_customer_sk = c.c_customer_sk
          INNER JOIN customer_address ca2 ON ca2.ca_address_sk = c.c_current_addr_sk
    WHERE: ca2.ca_state = 'OH' AND ctr1.ctr_total_return > sa.state_avg_threshold
    ORDER BY: (original 16 columns)
    LIMIT: 100
    OUTPUT: (original 16 columns)
    EXPECTED_ROWS: 100
    CONSUMERS: final output
EXAMPLES: pg_self_join_decomposition
EXAMPLE_ADAPTATION:
- Apply: Materialize fact+dimension scan once in base_agg_cte, derive state averages from same result
- Ignore: The example's store vs item decomposition - we have customer/state decomposition
HAZARD_FLAGS:
- PostgreSQL may inline the CTE if referenced only twice; consider MATERIALIZED hint
- Ensure state_avg_cte computes from same base_agg_cte, not re-scanning catalog_returns

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: late_attribute_binding_compound
TARGET_LOGICAL_TREE:
  date_filter -> returning_addr -> fact_agg -> state_filter -> customer_filter -> late_addr_join
NODE_CONTRACTS:
  date_filter:
    FROM: date_dim
    WHERE: d_year = 2002
    OUTPUT: d_date_sk
    EXPECTED_ROWS: ~365
    CONSUMERS: fact_agg
  returning_addr:
    FROM: customer_address
    OUTPUT: ca_address_sk, ca_state
    EXPECTED_ROWS: all rows
    CONSUMERS: fact_agg
  fact_agg:
    FROM: catalog_returns cr
          INNER JOIN date_filter d ON cr.cr_returned_date_sk = d.d_date_sk
          INNER JOIN returning_addr ra ON cr.cr_returning_addr_sk = ra.ca_address_sk
    GROUP BY: cr.cr_returning_customer_sk, ra.ca_state
    AGGREGATE: SUM(cr.cr_return_amt_inc_tax) AS ctr_total_return
    OUTPUT: cr.cr_returning_customer_sk AS ctr_customer_sk, ra.ca_state AS ctr_state, ctr_total_return
    EXPECTED_ROWS: ~1K
    CONSUMERS: state_filter
  state_filter:
    FROM: fact_agg f
          CROSS JOIN LATERAL (
            SELECT AVG(ctr_total_return) * 1.2 AS threshold 
            FROM fact_agg f2 
            WHERE f.ctr_state = f2.ctr_state
          ) AS state_avg
    WHERE: f.ctr_total_return > state_avg.threshold
    OUTPUT: ctr_customer_sk, ctr_state, ctr_total_return
    EXPECTED_ROWS: rows where customer > state average
    CONSUMERS: customer_filter
  customer_filter:
    FROM: state_filter sf
          INNER JOIN customer c ON sf.ctr_customer_sk = c.c_customer_sk
    WHERE: EXISTS (SELECT 1 FROM customer_address ca WHERE ca.ca_address_sk = c.c_current_addr_sk AND ca.ca_state = 'OH')
    OUTPUT: sf.ctr_customer_sk, sf.ctr_state, sf.ctr_total_return, c_customer_id, c_salutation, c_first_name, c_last_name
    EXPECTED_ROWS: Ohio customers only
    CONSUMERS: late_addr_join
  late_addr_join:
    FROM: customer_filter cf
          INNER JOIN customer_address ca ON ca.ca_address_sk = (SELECT c_current_addr_sk FROM customer WHERE c_customer_sk = cf.ctr_customer_sk)
    WHERE: ca.ca_state = 'OH'
    ORDER BY: (original 16 columns)
    LIMIT: 100
    OUTPUT: (original 16 columns)
    EXPECTED_ROWS: 100
    CONSUMERS: final output
EXAMPLES: early_filter_decorrelate, pg_materialized_dimension_fact_prefilter
EXAMPLE_ADAPTATION:
- Apply early_filter_decorrelate: Push date filter early, use LATERAL for state average
- Apply pg_materialized_dimension_fact_prefilter: Stage reduction with CTEs before final join
- Ignore: The non-equi join aspect of pg_materialized_dimension_fact_prefilter - we have > comparison
HAZARD_FLAGS:
- LATERAL may still execute per row; depends on optimizer
- EXISTS subquery for Ohio filter might not push down efficiently
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy