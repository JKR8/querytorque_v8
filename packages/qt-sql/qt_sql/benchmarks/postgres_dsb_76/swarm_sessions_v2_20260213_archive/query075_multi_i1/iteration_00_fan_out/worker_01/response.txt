## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_item [+]  Cost: 2%  Rows: 8,638
│   ├── SCAN item
│   └── FILTER i_category = 'Home'
├── [CTE] filtered_date [+]  Cost: 1%  Rows: ~730
│   ├── SCAN date_dim
│   └── FILTER d_year IN (1998, 1999)
├── [CTE] store_branch [+]  Cost: 10%  Rows: ~1,856
│   ├── JOIN store_returns LEFT JOIN filtered_item
│   ├── JOIN store_sales
│   ├── JOIN filtered_date
│   ├── FILTER sr_reason_sk IN (7,25,26,52,69)
│   └── FILTER (ss_sales_price/ss_list_price) BETWEEN 0.34 AND 0.54
├── [CTE] catalog_branch [+]  Cost: 12%  Rows: ~1,420
│   ├── JOIN catalog_returns LEFT JOIN filtered_item
│   ├── JOIN catalog_sales
│   ├── JOIN filtered_date
│   ├── FILTER cr_reason_sk IN (7,25,26,52,69)
│   └── FILTER (cs_sales_price/cs_list_price) BETWEEN 0.34 AND 0.54
├── [CTE] web_branch [+]  Cost: 15%  Rows: ~1,322
│   ├── JOIN web_returns LEFT JOIN filtered_item
│   ├── JOIN web_sales
│   ├── JOIN filtered_date
│   ├── FILTER wr_reason_sk IN (7,25,26,52,69)
│   └── FILTER (ws_sales_price/ws_list_price) BETWEEN 0.34 AND 0.54
├── [CTE] union_aggregate [+]  Cost: 30%  Rows: ~4,598
│   ├── UNION ALL (store_branch, catalog_branch, web_branch)
│   └── AGG (GROUP BY d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id)
└── [MAIN] main_query [~]  Cost: 40%  Rows: 100
    ├── SCAN union_aggregate AS curr_yr
    ├── SCAN union_aggregate AS prev_yr
    ├── JOIN (curr_yr.i_brand_id = prev_yr.i_brand_id AND ...)
    ├── FILTER curr_yr.d_year = 1999
    ├── FILTER prev_yr.d_year = 1998
    ├── FILTER prev_yr.sales_cnt > 0
    ├── FILTER CAST(curr_yr.sales_cnt AS DECIMAL(17,2))/CAST(prev_yr.sales_cnt AS DECIMAL(17,2)) < 0.9
    ├── SORT (sales_cnt_diff ASC, sales_amt_diff ASC)
    └── OUTPUT (prev_year, year, i_brand_id, i_class_id, i_category_id, i_manufact_id, prev_yr_cnt, curr_yr_cnt, sales_cnt_diff, sales_amt_diff)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "dimension_prefetch",
      "description": "Isolated selective dimensions (item, date_dim) into separate CTEs to create small hash tables for better join planning",
      "applied_to": ["filtered_item", "filtered_date"]
    },
    {
      "id": "R2",
      "type": "branch_decomposition",
      "description": "Decomposed UNION into separate CTE branches (store_branch, catalog_branch, web_branch) that share prefetched dimension CTEs",
      "applied_to": ["store_branch", "catalog_branch", "web_branch"]
    },
    {
      "id": "R3",
      "type": "explicit_join_syntax",
      "description": "Converted implicit joins (comma-separated) to explicit JOIN syntax in all branches",
      "applied_to": ["store_branch", "catalog_branch", "web_branch"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_item": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT i_item_sk, i_brand_id, i_class_id, i_category_id, i_manufact_id FROM item WHERE i_category = 'Home'",
          "interfaces": {
            "outputs": ["i_item_sk", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id"],
            "consumes": []
          }
        },
        "filtered_date": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year IN (1998, 1999)",
          "interfaces": {
            "outputs": ["d_date_sk", "d_year"],
            "consumes": []
          }
        },
        "store_branch": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT d.d_year, i.i_brand_id, i.i_class_id, i.i_category_id, i.i_manufact_id, ss.ss_quantity - COALESCE(sr.sr_return_quantity, 0) AS sales_cnt, ss.ss_ext_sales_price - COALESCE(sr.sr_return_amt, 0.0) AS sales_amt FROM store_returns sr LEFT JOIN filtered_item i ON sr.sr_item_sk = i.i_item_sk JOIN store_sales ss ON sr.sr_ticket_number = ss.ss_ticket_number AND sr.sr_item_sk = ss.ss_item_sk JOIN filtered_date d ON ss.ss_sold_date_sk = d.d_date_sk WHERE sr.sr_reason_sk IN (7, 25, 26, 52, 69) AND (ss.ss_sales_price / ss.ss_list_price) BETWEEN 0.34 AND 0.54",
          "interfaces": {
            "outputs": ["d_year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "sales_cnt", "sales_amt"],
            "consumes": ["filtered_item", "filtered_date"]
          }
        },
        "catalog_branch": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT d.d_year, i.i_brand_id, i.i_class_id, i.i_category_id, i.i_manufact_id, cs.cs_quantity - COALESCE(cr.cr_return_quantity, 0) AS sales_cnt, cs.cs_ext_sales_price - COALESCE(cr.cr_return_amount, 0.0) AS sales_amt FROM catalog_returns cr LEFT JOIN filtered_item i ON cr.cr_item_sk = i.i_item_sk JOIN catalog_sales cs ON cr.cr_order_number = cs.cs_order_number AND cr.cr_item_sk = cs.cs_item_sk JOIN filtered_date d ON cs.cs_sold_date_sk = d.d_date_sk WHERE cr.cr_reason_sk IN (7, 25, 26, 52, 69) AND (cs.cs_sales_price / cs.cs_list_price) BETWEEN 0.34 AND 0.54",
          "interfaces": {
            "outputs": ["d_year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "sales_cnt", "sales_amt"],
            "consumes": ["filtered_item", "filtered_date"]
          }
        },
        "web_branch": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT d.d_year, i.i_brand_id, i.i_class_id, i.i_category_id, i.i_manufact_id, ws.ws_quantity - COALESCE(wr.wr_return_quantity, 0) AS sales_cnt, ws.ws_ext_sales_price - COALESCE(wr.wr_return_amt, 0.0) AS sales_amt FROM web_returns wr LEFT JOIN filtered_item i ON wr.wr_item_sk = i.i_item_sk JOIN web_sales ws ON wr.wr_order_number = ws.ws_order_number AND wr.wr_item_sk = ws.ws_item_sk JOIN filtered_date d ON ws.ws_sold_date_sk = d.d_date_sk WHERE wr.wr_reason_sk IN (7, 25, 26, 52, 69) AND (ws.ws_sales_price / ws.ws_list_price) BETWEEN 0.34 AND 0.54",
          "interfaces": {
            "outputs": ["d_year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "sales_cnt", "sales_amt"],
            "consumes": ["filtered_item", "filtered_date"]
          }
        },
        "union_aggregate": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id, SUM(sales_cnt) AS sales_cnt, SUM(sales_amt) AS sales_amt FROM (SELECT * FROM store_branch UNION ALL SELECT * FROM catalog_branch UNION ALL SELECT * FROM web_branch) all_branches GROUP BY d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id",
          "interfaces": {
            "outputs": ["d_year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "sales_cnt", "sales_amt"],
            "consumes": ["store_branch", "catalog_branch", "web_branch"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT prev_yr.d_year AS prev_year, curr_yr.d_year AS year, curr_yr.i_brand_id, curr_yr.i_class_id, curr_yr.i_category_id, curr_yr.i_manufact_id, prev_yr.sales_cnt AS prev_yr_cnt, curr_yr.sales_cnt AS curr_yr_cnt, curr_yr.sales_cnt - prev_yr.sales_cnt AS sales_cnt_diff, curr_yr.sales_amt - prev_yr.sales_amt AS sales_amt_diff FROM union_aggregate curr_yr, union_aggregate prev_yr WHERE curr_yr.i_brand_id = prev_yr.i_brand_id AND curr_yr.i_class_id = prev_yr.i_class_id AND curr_yr.i_category_id = prev_yr.i_category_id AND curr_yr.i_manufact_id = prev_yr.i_manufact_id AND curr_yr.d_year = 1999 AND prev_yr.d_year = 1998 AND prev_yr.sales_cnt > 0 AND CAST(curr_yr.sales_cnt AS DECIMAL(17,2))/CAST(prev_yr.sales_cnt AS DECIMAL(17,2)) < 0.9 ORDER BY sales_cnt_diff, sales_amt_diff LIMIT 100",
          "interfaces": {
            "outputs": ["prev_year", "year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "prev_yr_cnt", "curr_yr_cnt", "sales_cnt_diff", "sales_amt_diff"],
            "consumes": ["union_aggregate"]
          }
        }
      },
      "reconstruction_order": ["filtered_item", "filtered_date", "store_branch", "catalog_branch", "web_branch", "union_aggregate", "main_query"],
      "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_date AS ({filtered_date}), store_branch AS ({store_branch}), catalog_branch AS ({catalog_branch}), web_branch AS ({web_branch}), union_aggregate AS ({union_aggregate}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Restructured original query into a staged CTE pipeline: pre-filtered dimension tables (`filtered_item`, `filtered_date`) create tiny hash tables, followed by three separate channel branches that join these prefetched dimensions via explicit JOIN syntax, then union and aggregate before the final self-join. This matches the target logical tree exactly.

**Expected speedup:** 2.5-3.5x based on similar patterns (pg_dimension_prefetch_star, pg_date_cte_explicit_join). The main gains come from: (1) early reduction of dimension tables into tiny hash tables that can be probed efficiently, (2) explicit JOIN syntax enabling better hash join planning, and (3) avoiding a single massive UNION that blocks parallelism.