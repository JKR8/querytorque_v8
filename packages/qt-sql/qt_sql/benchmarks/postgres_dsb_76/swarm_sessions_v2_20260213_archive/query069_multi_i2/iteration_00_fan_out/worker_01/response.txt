### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ~500K
    ├── CTE filtered_address  [+]
    │   └── SCAN customer_address (ca_state IN ('GA','KY','SD'))
    ├── CTE filtered_demo  [+]
    │   └── SCAN customer_demographics (cd_marital_status IN ('D','W','U'), cd_education_status IN ('Primary','College'))
    ├── CTE filtered_date  [+]
    │   └── SCAN date_dim (d_year=1999, d_moy BETWEEN 3 AND 5)
    ├── CTE customer_base  [+]
    │   ├── SCAN customer
    │   ├── JOIN INNER filtered_address (c_current_addr_sk = ca_address_sk)
    │   └── JOIN INNER filtered_demo (c_current_cdemo_sk = cd_demo_sk)
    ├── CTE store_sales_filtered  [+]
    │   ├── SCAN store_sales (ss_list_price BETWEEN 52 AND 141)
    │   └── JOIN INNER filtered_date (ss_sold_date_sk = d_date_sk)
    ├── CTE store_exists  [+]
    │   └── FILTER EXISTS (SELECT 1 FROM store_sales_filtered WHERE ss_customer_sk = c_customer_sk)
    ├── CTE web_sales_filtered  [+]
    │   ├── SCAN web_sales (ws_list_price BETWEEN 52 AND 141)
    │   └── JOIN INNER filtered_date (ws_sold_date_sk = d_date_sk)
    ├── CTE web_not_exists  [+]
    │   └── FILTER NOT EXISTS (SELECT 1 FROM web_sales_filtered WHERE ws_bill_customer_sk = c_customer_sk)
    ├── CTE catalog_sales_filtered  [+]
    │   ├── SCAN catalog_sales (cs_list_price BETWEEN 52 AND 141)
    │   └── JOIN INNER filtered_date (cs_sold_date_sk = d_date_sk)
    ├── CTE catalog_not_exists  [+]
    │   └── FILTER NOT EXISTS (SELECT 1 FROM catalog_sales_filtered WHERE cs_ship_customer_sk = c_customer_sk)
    ├── AGG (GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating)
    ├── SORT (cd_gender ASC, cd_marital_status ASC, cd_education_status ASC, cd_purchase_estimate ASC, cd_credit_rating ASC)
    └── OUTPUT (cd_gender, cd_marital_status, cd_education_status, cnt1, cd_purchase_estimate, cnt2, cd_credit_rating, cnt3)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "dimension_prefetch",
      "description": "Pre-filter selective dimensions (address, demographics) into CTEs for early cardinality reduction",
      "applied_to": ["filtered_address", "filtered_demo"]
    },
    {
      "id": "R2",
      "type": "explicit_join_syntax",
      "description": "Replace comma-separated joins with explicit INNER JOIN syntax in customer_base CTE",
      "applied_to": ["customer_base"]
    },
    {
      "id": "R3",
      "type": "date_filter_isolation",
      "description": "Isolate date filter into separate CTE reused across all three fact tables",
      "applied_to": ["filtered_date", "store_sales_filtered", "web_sales_filtered", "catalog_sales_filtered"]
    },
    {
      "id": "R4",
      "type": "correlation_preservation",
      "description": "Keep EXISTS/NOT EXISTS subqueries (not converted to IN/ANTI JOIN) to maintain NULL semantics and hash-anti-join eligibility",
      "applied_to": ["store_exists", "web_not_exists", "catalog_not_exists"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_address": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('GA','KY','SD')",
          "interfaces": {
            "outputs": ["ca_address_sk"],
            "consumes": []
          }
        },
        "filtered_demo": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating FROM customer_demographics WHERE cd_marital_status IN ('D','W','U') AND cd_education_status IN ('Primary','College')",
          "interfaces": {
            "outputs": ["cd_demo_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"],
            "consumes": []
          }
        },
        "filtered_date": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy BETWEEN 3 AND 5",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "customer_base": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT c.c_customer_sk, fd.cd_gender, fd.cd_marital_status, fd.cd_education_status, fd.cd_purchase_estimate, fd.cd_credit_rating FROM customer c INNER JOIN filtered_address fa ON c.c_current_addr_sk = fa.ca_address_sk INNER JOIN filtered_demo fd ON c.c_current_cdemo_sk = fd.cd_demo_sk",
          "interfaces": {
            "outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"],
            "consumes": ["filtered_address", "filtered_demo"]
          }
        },
        "store_sales_filtered": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT ss_customer_sk FROM store_sales INNER JOIN filtered_date fd ON ss_sold_date_sk = fd.d_date_sk WHERE ss_list_price BETWEEN 52 AND 141",
          "interfaces": {
            "outputs": ["ss_customer_sk"],
            "consumes": ["filtered_date"]
          }
        },
        "store_exists": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT cb.* FROM customer_base cb WHERE EXISTS (SELECT 1 FROM store_sales_filtered ssf WHERE ssf.ss_customer_sk = cb.c_customer_sk)",
          "interfaces": {
            "outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"],
            "consumes": ["customer_base", "store_sales_filtered"]
          }
        },
        "web_sales_filtered": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT ws_bill_customer_sk FROM web_sales INNER JOIN filtered_date fd ON ws_sold_date_sk = fd.d_date_sk WHERE ws_list_price BETWEEN 52 AND 141",
          "interfaces": {
            "outputs": ["ws_bill_customer_sk"],
            "consumes": ["filtered_date"]
          }
        },
        "web_not_exists": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT se.* FROM store_exists se WHERE NOT EXISTS (SELECT 1 FROM web_sales_filtered wsf WHERE wsf.ws_bill_customer_sk = se.c_customer_sk)",
          "interfaces": {
            "outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"],
            "consumes": ["store_exists", "web_sales_filtered"]
          }
        },
        "catalog_sales_filtered": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT cs_ship_customer_sk FROM catalog_sales INNER JOIN filtered_date fd ON cs_sold_date_sk = fd.d_date_sk WHERE cs_list_price BETWEEN 52 AND 141",
          "interfaces": {
            "outputs": ["cs_ship_customer_sk"],
            "consumes": ["filtered_date"]
          }
        },
        "catalog_not_exists": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT wne.* FROM web_not_exists wne WHERE NOT EXISTS (SELECT 1 FROM catalog_sales_filtered csf WHERE csf.cs_ship_customer_sk = wne.c_customer_sk)",
          "interfaces": {
            "outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"],
            "consumes": ["web_not_exists", "catalog_sales_filtered"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM catalog_not_exists GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100",
          "interfaces": {
            "outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"],
            "consumes": ["catalog_not_exists"]
          }
        }
      },
      "reconstruction_order": ["filtered_address", "filtered_demo", "filtered_date", "customer_base", "store_sales_filtered", "store_exists", "web_sales_filtered", "web_not_exists", "catalog_sales_filtered", "catalog_not_exists", "main_query"],
      "assembly_template": "WITH filtered_address AS ({filtered_address}), filtered_demo AS ({filtered_demo}), filtered_date AS ({filtered_date}), customer_base AS ({customer_base}), store_sales_filtered AS ({store_sales_filtered}), store_exists AS ({store_exists}), web_sales_filtered AS ({web_sales_filtered}), web_not_exists AS ({web_not_exists}), catalog_sales_filtered AS ({catalog_sales_filtered}), catalog_not_exists AS ({catalog_not_exists}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

Changes: Pre-filtered selective dimension tables (address, demographics) into CTEs and converted comma joins to explicit INNER JOIN syntax, enabling PostgreSQL to build hash tables from small filtered dimension sets. Kept EXISTS/NOT EXISTS structure (not converted to IN/ANTI JOIN) to preserve NULL semantics and hash‑anti‑join eligibility.

Expected speedup: 2‑3× from dimension prefetching and explicit join planning.