## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] pref_selective_dims  [+]  New CTE isolating selective dimension filters
│   ├── SCAN (promotion, customer_address ad2, customer_demographics cd1, customer_demographics cd2)
│   ├── JOIN (implicit cartesian product - all independent filters)
│   ├── FILTER (p_channel_email = 'Y' AND p_channel_tv = 'Y' AND p_channel_radio = 'Y')
│   ├── FILTER (ad2.ca_state IN ('KS','OH','VA'))
│   ├── FILTER (cd1.cd_marital_status IN ('S','S','S') AND cd1.cd_education_status IN ('Advanced Degree','4 yr Degree','4 yr Degree'))
│   ├── FILTER (cd2.cd_marital_status IN ('S','S','S') AND cd2.cd_education_status IN ('Advanced Degree','4 yr Degree','4 yr Degree'))
│   └── OUTPUT (p_promo_sk, ad2.ca_address_sk, cd1.cd_demo_sk, cd2.cd_demo_sk)
├── [CTE] filtered_cs_ui  [=]  Cost: 29%  Rows: ~2.2M
│   ├── SCAN (catalog_sales, catalog_returns (join))
│   ├── JOIN (cs_item_sk = cr_item_sk)
│   ├── JOIN (cs_order_number = cr_order_number)
│   ├── FILTER (cs_wholesale_cost BETWEEN 76 AND 96)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (cs_item_sk, sale, refund)
├── [CTE] fact_join_both_years  [+]  New CTE with explicit JOINs and both years in single scan
│   ├── SCAN (store_sales)
│   ├── JOIN store_returns (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number)
│   ├── JOIN filtered_cs_ui (ss_item_sk = cs_item_sk)
│   ├── JOIN item (ss_item_sk = i_item_sk AND i_current_price BETWEEN 77 AND 87)
│   ├── JOIN pref_selective_dims p (ss_promo_sk = p_promo_sk)
│   ├── JOIN date_dim d1 (ss_sold_date_sk = d1.d_date_sk AND d1.d_year IN (2000, 2001))
│   ├── JOIN store (ss_store_sk = s_store_sk)
│   ├── JOIN customer (ss_customer_sk = c_customer_sk)
│   ├── JOIN pref_selective_dims cd1 (ss_cdemo_sk = cd_demo_sk)
│   ├── JOIN pref_selective_dims cd2 (c_current_cdemo_sk = cd_demo_sk)
│   ├── JOIN household_demographics hd1 (ss_hdemo_sk = hd1.hd_demo_sk)
│   ├── JOIN household_demographics hd2 (c_current_hdemo_sk = hd2.hd_demo_sk)
│   ├── JOIN pref_selective_dims ad2 (c_current_addr_sk = ca_address_sk)
│   ├── JOIN customer_address ad1 (ss_addr_sk = ad1.ca_address_sk)
│   ├── JOIN date_dim d2 (c_first_sales_date_sk = d2.d_date_sk)
│   ├── JOIN date_dim d3 (c_first_shipto_date_sk = d3.d_date_sk)
│   ├── JOIN income_band ib1 (hd1.hd_income_band_sk = ib1.ib_income_band_sk)
│   ├── JOIN income_band ib2 (hd2.hd_income_band_sk = ib2.ib_income_band_sk)
│   ├── FILTER (ss_wholesale_cost BETWEEN 76 AND 96)
│   ├── FILTER (cd1.cd_marital_status <> cd2.cd_marital_status)
│   └── OUTPUT (i_product_name, i_item_sk, s_store_name, s_zip, ad1.ca_street_number, ad1.ca_street_name, ad1.ca_city, ad1.ca_zip, ad2.ca_street_number, ad2.ca_street_name, ad2.ca_city, ad2.ca_zip, d1.d_year, d2.d_year, d3.d_year, ss_wholesale_cost, ss_list_price, ss_coupon_amt)
├── [CTE] pivoted_aggregation  [+]  New CTE with conditional aggregation by year
│   ├── SCAN (fact_join_both_years)
│   ├── GROUP BY (i_product_name, i_item_sk, s_store_name, s_zip, ad1.ca_street_number, ad1.ca_street_name, ad1.ca_city, ad1.ca_zip, ad2.ca_street_number, ad2.ca_street_name, ad2.ca_city, ad2.ca_zip, d2.d_year, d3.d_year)
│   ├── AGG (conditional aggregates for 2000 and 2001)
│   └── OUTPUT (product_name, item_sk, store_name, store_zip, b_street_number, b_street_name, b_city, b_zip, c_street_number, c_street_name, c_city, c_zip, fsyear, s2year, cnt_2000, s1_2000, s2_2000, s3_2000, cnt_2001, s1_2001, s2_2001, s3_2001)
└── [MAIN] main_pivot_compare  [~]  Modified to use pivoted CTE instead of self-join
    ├── SCAN (pivoted_aggregation)
    ├── FILTER (cnt_2001 <= cnt_2000)
    ├── SORT (product_name ASC, store_name ASC, cnt_2001 ASC, s1_2000 ASC, s1_2001 ASC)
    └── OUTPUT (product_name, store_name, store_zip, b_street_number, b_street_name, b_city, b_zip, c_street_number, c_street_name, c_city, c_zip, syear_2000, cnt_2000, s1_2000 as s11, s2_2000 as s21, s3_2000 as s31, s1_2001 as s12, s2_2001 as s22, s3_2001 as s32, syear_2001, cnt_2001)

CHANGES:
[+] pref_selective_dims: Added CTE to pre-filter selective dimensions (promotion, address, demographics)
[+] fact_join_both_years: Added CTE with explicit JOIN syntax and both years in single scan
[+] pivoted_aggregation: Added CTE with conditional aggregation by year (2000 vs 2001)
[~] main_pivot_compare: Modified to use pivoted CTE instead of self-join on cross_sales
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefetch_star", "description": "Isolate selective dimension filters into prefetch CTE", "applied_to": ["pref_selective_dims"]},
    {"id": "R2", "type": "explicit_join_conversion", "description": "Convert comma-separated joins to explicit JOIN syntax", "applied_to": ["fact_join_both_years"]},
    {"id": "R3", "type": "self_join_decomposition", "description": "Replace year self-join with conditional aggregation in single scan", "applied_to": ["pivoted_aggregation", "main_pivot_compare"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "pref_selective_dims": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT p.p_promo_sk, ad2.ca_address_sk, cd1.cd_demo_sk, cd2.cd_demo_sk FROM promotion p, customer_address ad2, customer_demographics cd1, customer_demographics cd2 WHERE p.p_channel_email = 'Y' AND p.p_channel_tv = 'Y' AND p.p_channel_radio = 'Y' AND ad2.ca_state IN ('KS','OH','VA') AND cd1.cd_marital_status IN ('S','S','S') AND cd1.cd_education_status IN ('Advanced Degree','4 yr Degree','4 yr Degree') AND cd2.cd_marital_status IN ('S','S','S') AND cd2.cd_education_status IN ('Advanced Degree','4 yr Degree','4 yr Degree')",
        "interfaces": {"outputs": ["p_promo_sk", "ca_address_sk", "cd_demo_sk", "cd_demo_sk"], "consumes": []}
      },
      "filtered_cs_ui": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["cs_item_sk", "sale", "refund"], "consumes": []}
      },
      "fact_join_both_years": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i.i_product_name, i.i_item_sk, s.s_store_name, s.s_zip, ad1.ca_street_number, ad1.ca_street_name, ad1.ca_city, ad1.ca_zip, ad2.ca_street_number, ad2.ca_street_name, ad2.ca_city, ad2.ca_zip, d1.d_year, d2.d_year, d3.d_year, ss.ss_wholesale_cost, ss.ss_list_price, ss.ss_coupon_amt FROM store_sales ss JOIN store_returns sr ON ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number JOIN filtered_cs_ui cs ON ss.ss_item_sk = cs.cs_item_sk JOIN item i ON ss.ss_item_sk = i.i_item_sk AND i.i_current_price BETWEEN 77 AND 87 JOIN pref_selective_dims p ON ss.ss_promo_sk = p.p_promo_sk JOIN date_dim d1 ON ss.ss_sold_date_sk = d1.d_date_sk AND d1.d_year IN (2000, 2001) JOIN store s ON ss.ss_store_sk = s.s_store_sk JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk JOIN pref_selective_dims cd1 ON ss.ss_cdemo_sk = cd1.cd_demo_sk JOIN pref_selective_dims cd2 ON c.c_current_cdemo_sk = cd2.cd_demo_sk JOIN household_demographics hd1 ON ss.ss_hdemo_sk = hd1.hd_demo_sk JOIN household_demographics hd2 ON c.c_current_hdemo_sk = hd2.hd_demo_sk JOIN pref_selective_dims ad2 ON c.c_current_addr_sk = ad2.ca_address_sk JOIN customer_address ad1 ON ss.ss_addr_sk = ad1.ca_address_sk JOIN date_dim d2 ON c.c_first_sales_date_sk = d2.d_date_sk JOIN date_dim d3 ON c.c_first_shipto_date_sk = d3.d_date_sk JOIN income_band ib1 ON hd1.hd_income_band_sk = ib1.ib_income_band_sk JOIN income_band ib2 ON hd2.hd_income_band_sk = ib2.ib_income_band_sk WHERE ss.ss_wholesale_cost BETWEEN 76 AND 96 AND cd1.cd_marital_status <> cd2.cd_marital_status",
        "interfaces": {"outputs": ["i_product_name", "i_item_sk", "s_store_name", "s_zip", "ca_street_number", "ca_street_name", "ca_city", "ca_zip", "ca_street_number", "ca_street_name", "ca_city", "ca_zip", "d_year", "d_year", "d_year", "ss_wholesale_cost", "ss_list_price", "ss_coupon_amt"], "consumes": ["pref_selective_dims", "filtered_cs_ui"]}
      },
      "pivoted_aggregation": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_product_name AS product_name, i_item_sk AS item_sk, s_store_name AS store_name, s_zip AS store_zip, ca_street_number AS b_street_number, ca_street_name AS b_street_name, ca_city AS b_city, ca_zip AS b_zip, ca_street_number AS c_street_number, ca_street_name AS c_street_name, ca_city AS c_city, ca_zip AS c_zip, d2.d_year AS fsyear, d3.d_year AS s2year, COUNT(*) FILTER (WHERE d1.d_year = 2000) AS cnt_2000, SUM(ss_wholesale_cost) FILTER (WHERE d1.d_year = 2000) AS s1_2000, SUM(ss_list_price) FILTER (WHERE d1.d_year = 2000) AS s2_2000, SUM(ss_coupon_amt) FILTER (WHERE d1.d_year = 2000) AS s3_2000, COUNT(*) FILTER (WHERE d1.d_year = 2001) AS cnt_2001, SUM(ss_wholesale_cost) FILTER (WHERE d1.d_year = 2001) AS s1_2001, SUM(ss_list_price) FILTER (WHERE d1.d_year = 2001) AS s2_2001, SUM(ss_coupon_amt) FILTER (WHERE d1.d_year = 2001) AS s3_2001 FROM fact_join_both_years GROUP BY i_product_name, i_item_sk, s_store_name, s_zip, ca_street_number, ca_street_name, ca_city, ca_zip, ca_street_number, ca_street_name, ca_city, ca_zip, d2.d_year, d3.d_year",
        "interfaces": {"outputs": ["product_name", "item_sk", "store_name", "store_zip", "b_street_number", "b_street_name", "b_city", "b_zip", "c_street_number", "c_street_name", "c_city", "c_zip", "fsyear", "s2year", "cnt_2000", "s1_2000", "s2_2000", "s3_2000", "cnt_2001", "s1_2001", "s2_2001", "s3_2001"], "consumes": ["fact_join_both_years"]}
      },
      "main_pivot_compare": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cs1.product_name, cs1.store_name, cs1.store_zip, cs1.b_street_number, cs1.b_street_name, cs1.b_city, cs1.b_zip, cs1.c_street_number, cs1.c_street_name, cs1.c_city, cs1.c_zip, 2000 AS syear, cs1.cnt_2000 AS cnt, cs1.s1_2000 AS s11, cs1.s2_2000 AS s21, cs1.s3_2000 AS s31, cs1.s1_2001 AS s12, cs1.s2_2001 AS s22, cs1.s3_2001 AS s32, 2001 AS syear, cs1.cnt_2001 AS cnt FROM pivoted_aggregation cs1 WHERE cs1.cnt_2001 <= cs1.cnt_2000 ORDER BY cs1.product_name, cs1.store_name, cs1.cnt_2001, cs1.s1_2000, cs1.s1_2001",
        "interfaces": {"outputs": ["product_name", "store_name", "store_zip", "b_street_number", "b_street_name", "b_city", "b_zip", "c_street_number", "c_street_name", "c_city", "c_zip", "syear", "cnt", "s11", "s21", "s31", "s12", "s22", "s32", "syear", "cnt"], "consumes": ["pivoted_aggregation"]}
      }
    },
    "reconstruction_order": ["filtered_cs_ui", "pref_selective_dims", "fact_join_both_years", "pivoted_aggregation", "main_pivot_compare"],
    "assembly_template": "WITH filtered_cs_ui AS ({filtered_cs_ui}), pref_selective_dims AS ({pref_selective_dims}), fact_join_both_years AS ({fact_join_both_years}), pivoted_aggregation AS ({pivoted_aggregation}) {main_pivot_compare}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Applied dimension prefetching to isolate selective filters into a tiny CTE, converted comma-separated joins to explicit JOIN syntax, and replaced the year self-join with conditional aggregation in a single fact scan.

**Expected speedup**: 3.5-4x due to elimination of self-join overhead, better join ordering from explicit JOINs, and reduced dimension table scanning via prefetching.