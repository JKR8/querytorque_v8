## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~39K
    ├── [~] CTE: date_cte (d_date_sk)
    ├── [~] CTE: item_cte (i_item_sk, i_item_id)
    ├── [~] CTE: cd_cte (cd_demo_sk)
    ├── [~] CTE: customer_cte (c_customer_sk, c_birth_year)
    ├── [~] CTE: filtered_sales (joins catalog_sales with all dimension CTEs + cs_wholesale_cost filter)
    ├── [~] CTE: aggregate_partial (group by i_item_id, c_customer_sk, c_birth_year with AVG aggregates)
    ├── [~] CTE: ca_cte (ca_address_sk, ca_country, ca_state, ca_county)
    ├── [~] CTE: join_ca (join aggregate_partial → customer → ca_cte)
    ├── [~] CTE: final_aggregate (ROLLUP(i_item_id, ca_country, ca_state, ca_county) over join_ca)
    ├── SORT (ca_country ASC, ca_state ASC, ca_county ASC, i_item_id ASC)
    └── OUTPUT (i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, ...)
```

**Change Summary**  
- Restructured original flat FROM list into explicit CTE pipeline following target logical tree.  
- Isolated dimension filters into separate CTEs (date, item, customer_demographics, customer).  
- Separated fact-table filtering (cs_wholesale_cost) into filtered_sales CTE.  
- Split aggregation into two stages: partial grouping (by i_item_id, c_customer_sk, c_birth_year) and final ROLLUP after joining address.  
- Maintained INNER JOIN semantics and all original literals/filters.  

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_isolation", "description": "Isolate dimension filters into dedicated CTEs", "applied_to": ["date_cte", "item_cte", "cd_cte", "customer_cte", "ca_cte"]},
    {"id": "R2", "type": "fact_filter_early", "description": "Push cs_wholesale_cost filter into filtered_sales CTE", "applied_to": ["filtered_sales"]},
    {"id": "R3", "type": "two_stage_aggregation", "description": "Split aggregation into partial (per customer/item/birth_year) then final ROLLUP after address join", "applied_to": ["aggregate_partial", "final_aggregate"]},
    {"id": "R4", "type": "explicit_join_chain", "description": "Replace comma joins with explicit INNER JOINs preserving join order", "applied_to": ["filtered_sales", "join_ca"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1998",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "item_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_id FROM item WHERE i_category = 'Sports'",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id"], "consumes": []}
      },
      "cd_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_gender = 'F' AND cd_education_status = 'College'",
        "interfaces": {"outputs": ["cd_demo_sk"], "consumes": []}
      },
      "customer_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_customer_sk, c_birth_year FROM customer WHERE c_birth_month = 2",
        "interfaces": {"outputs": ["c_customer_sk", "c_birth_year"], "consumes": []}
      },
      "filtered_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i.i_item_id, c.c_customer_sk, c.c_birth_year, cs.cs_quantity, cs.cs_list_price, cs.cs_coupon_amt, cs.cs_sales_price, cs.cs_net_profit FROM catalog_sales cs INNER JOIN date_cte d ON cs.cs_sold_date_sk = d.d_date_sk INNER JOIN item_cte i ON cs.cs_item_sk = i.i_item_sk INNER JOIN cd_cte cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk INNER JOIN customer_cte c ON cs.cs_bill_customer_sk = c.c_customer_sk WHERE cs.cs_wholesale_cost BETWEEN 41 AND 46",
        "interfaces": {"outputs": ["i_item_id", "c_customer_sk", "c_birth_year", "cs_quantity", "cs_list_price", "cs_coupon_amt", "cs_sales_price", "cs_net_profit"], "consumes": ["date_cte", "item_cte", "cd_cte", "customer_cte"]}
      },
      "aggregate_partial": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id, c_customer_sk, c_birth_year, AVG(CAST(cs_quantity AS DECIMAL(12,2))) AS agg1, AVG(CAST(cs_list_price AS DECIMAL(12,2))) AS agg2, AVG(CAST(cs_coupon_amt AS DECIMAL(12,2))) AS agg3, AVG(CAST(cs_sales_price AS DECIMAL(12,2))) AS agg4, AVG(CAST(cs_net_profit AS DECIMAL(12,2))) AS agg5, AVG(CAST(c_birth_year AS DECIMAL(12,2))) AS agg6 FROM filtered_sales GROUP BY i_item_id, c_customer_sk, c_birth_year",
        "interfaces": {"outputs": ["i_item_id", "c_customer_sk", "c_birth_year", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"], "consumes": ["filtered_sales"]}
      },
      "ca_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_address_sk, ca_country, ca_state, ca_county FROM customer_address WHERE ca_state IN ('AR', 'NY', 'TX')",
        "interfaces": {"outputs": ["ca_address_sk", "ca_country", "ca_state", "ca_county"], "consumes": []}
      },
      "join_ca": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ap.i_item_id, ca.ca_country, ca.ca_state, ca.ca_county, ap.agg1, ap.agg2, ap.agg3, ap.agg4, ap.agg5, ap.agg6 FROM aggregate_partial ap INNER JOIN customer cust ON ap.c_customer_sk = cust.c_customer_sk INNER JOIN ca_cte ca ON cust.c_current_addr_sk = ca.ca_address_sk",
        "interfaces": {"outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"], "consumes": ["aggregate_partial", "ca_cte"]}
      },
      "final_aggregate": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id, ca_country, ca_state, ca_county, AVG(agg1) AS agg1, AVG(agg2) AS agg2, AVG(agg3) AS agg3, AVG(agg4) AS agg4, AVG(agg5) AS agg5, AVG(agg6) AS agg6 FROM join_ca GROUP BY ROLLUP (i_item_id, ca_country, ca_state, ca_county)",
        "interfaces": {"outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"], "consumes": ["join_ca"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, agg5, agg6 FROM final_aggregate ORDER BY ca_country, ca_state, ca_county, i_item_id LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"], "consumes": ["final_aggregate"]}
      }
    },
    "reconstruction_order": ["date_cte", "item_cte", "cd_cte", "customer_cte", "filtered_sales", "aggregate_partial", "ca_cte", "join_ca", "final_aggregate", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), item_cte AS ({item_cte}), cd_cte AS ({cd_cte}), customer_cte AS ({customer_cte}), filtered_sales AS ({filtered_sales}), aggregate_partial AS ({aggregate_partial}), ca_cte AS ({ca_cte}), join_ca AS ({join_ca}), final_aggregate AS ({final_aggregate}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '128MB'",
    "SET LOCAL effective_cache_size = '4096MB'",
    "SET LOCAL max_parallel_workers_per_gather = 2"
  ],
  "validation_checks": []
}
```

**Changes:** The rewrite decomposes the flat comma-join query into a staged CTE pipeline, isolating dimension filters, pushing fact-table filters early, and splitting aggregation into a customer/item partial stage followed by a ROLLUP after address join. This preserves exact semantics (INNER JOIN intersection, duplicate-sensitive AVGs) while enabling better filter pushdown and intermediate result caching.

**Expected speedup:** Moderate (1.5–2×) due to reduced intermediate row counts from early filtering and parallel-friendly hash aggregates. The two-stage aggregation avoids recomputing per-customer aggregates during the ROLLUP.

**Runtime config rationale:**  
- `work_mem = '128MB'`: Supports hash aggregates for partial and final aggregation stages (two hash aggregates + sort).  
- `effective_cache_size = '4096MB'`: Advisory cache size matches global setting; helps planner favor index scans on dimension tables.  
- `max_parallel_workers_per_gather = 2`: Allows parallel scan/aggregate on filtered_sales (expected ~22 rows) but limited to avoid overhead.