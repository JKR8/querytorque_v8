<reasoning>
1. **CLASSIFY**: This is a classic star-join aggregation query with ROLLUP. A fact table (catalog_sales) joins with 5 dimension tables, filtered on multiple dimensions, then aggregated with ROLLUP. No correlated subqueries, no UNION ALL, no self-joins. Structural archetype: star-join with late dim filter.

2. **EXPLAIN PLAN ANALYSIS**:
   - Total execution: 462.2 ms
   - Dominant node: Nested Loop Inner (rows=1 loop=1 time=462.2ms) → essentially the entire query time.
   - Inside that: Gather (rows=22 loops=1 time=461.9ms) → parallel portion dominates.
   - Inside parallel workers: Nested Loop chain starting with Index Only Scan on date_dim (122 rows per worker) → Index Scan on catalog_sales (107 rows kept, 5,171 removed by filter) → this filter on cs_wholesale_cost is expensive.
   - Row count flow: date_dim: ~365 rows → catalog_sales: ~38982 rows after join, reduced to ~107 rows after filter → item: ~4397 rows after join → customer: ~475 rows after join → customer_demographics: ~22 rows after join → customer_address: final ~5 rows.
   - Bottleneck: The Index Scan on catalog_sales with Filter on cs_wholesale_cost removes 98% of rows (5,171 removed vs 107 kept). This is a scan-bound bottleneck where an index on cs_sold_date_sk doesn't help with the wholesale_cost range.
   - The optimizer already does: parallel execution, index scans on all dimension tables, predicate pushdown to dimension scans. It does NOT: pre-filter the fact table by wholesale_cost before joining with date_dim (the filter happens after the index scan). The comma joins are already transformed to nested loops - no explicit JOIN syntax.
   - Each base table scanned once. No repeated scans.

3. **GAP MATCHING**:
   - COMMA_JOIN_WEAKNESS: Yes - query uses comma-separated implicit joins. PostgreSQL might not optimize cardinality estimation as well as explicit JOINs with pre-filtered CTEs.
   - CORRELATED_SUBQUERY_PARALYSIS: No - no correlated subqueries.
   - CROSS_CTE_PREDICATE_BLINDNESS: No - no repeated fact scans.
   - NON_EQUI_JOIN_INPUT_BLINDNESS: No - all equi-joins.
   - The optimizer already handles INNER_JOIN_REORDERING well (reordered from textual order).

4. **AGGREGATION TRAP CHECK**: Only AVG functions. All are duplicate-sensitive (AVG changes with row duplication). However, all joins are 1:1 or 1:many from fact to dimensions? Let's check:
   - date_dim to catalog_sales: 1 date → many sales (1:many)
   - item to catalog_sales: 1 item → many sales (1:many)  
   - customer_demographics to catalog_sales: 1 demo → many sales (1:many)
   - customer to catalog_sales: 1 customer → many sales (1:many)
   - customer_address to customer: 1 address → many customers? Actually c_current_addr_sk is current address, so 1:1.
   So there's potential for row duplication from the 1:many joins. But the GROUP BY includes i_item_id, ca_country, ca_state, ca_county which should uniquely identify rows after all joins? Actually, same item sold to different customers in same county would have same grouping values but different sales rows - that's correct duplication for AVG. Any restructuring must preserve this exact join multiplicity.

5. **TRANSFORM SELECTION** (4 diverse strategies):
   a) **star_join_prefetch**: Pre-filter all selective dimensions into CTEs, then explicit JOIN with fact. Attacks COMMA_JOIN_WEAKNESS and late filtering.
   b) **global_predicate_pushdown**: Push fact table filter (cs_wholesale_cost) earlier in the join order. Currently filter applied after date join; could filter fact table first.
   c) **single_pass_aggregation**: Not applicable (no multiple aggregations).
   d) **late_attribute_binding**: Defer customer_address join until after filtering/aggregation since its columns only used in GROUP BY/SELECT, not in WHERE.
   e) **explicit_join_syntax_only**: Minimal change - just convert comma joins to explicit JOINs without CTEs.
   
   Selected 4:
   1. **Worker 1**: pg_dimension_prefetch_star - pre-filter all dimensions into CTEs, explicit JOINs.
   2. **Worker 2**: global_predicate_pushdown - filter catalog_sales by wholesale_cost FIRST, then join.
   3. **Worker 3**: late_attribute_binding - defer customer_address join until after customer filtering.
   4. **Worker 4 (Exploration)**: pg_materialized_dimension_fact_prefilter - pre-filter BOTH dimensions AND fact into CTEs.

6. **LOGICAL TREE DESIGN**: For each strategy, design CTEs with exhaustive columns.

Check CTE column completeness: Need all columns referenced downstream:
- For joins: cs_sold_date_sk, cs_item_sk, cs_bill_cdemo_sk, cs_bill_customer_sk, i_item_sk, d_date_sk, cd_demo_sk, c_customer_sk, c_current_addr_sk, ca_address_sk
- For GROUP BY: i_item_id, ca_country, ca_state, ca_county  
- For SELECT aggregates: cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit, c_birth_year
- For filters: cs_wholesale_cost, d_year, i_category, cd_gender, cd_education_status, c_birth_month, ca_state
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
This query computes average sales metrics for sports items sold in 1998 to college-educated female customers born in February living in AR, NY, or TX, with wholesale costs 41-46. All joins are INNER (intersection) requiring matches on all sides. Aggregates are AVG which are duplicate-sensitive - restructuring must preserve exact join multiplicity. The ca_state filter depends on customer_address which joins through customer - breaking this chain changes results.

BOTTLENECK_DIAGNOSIS:
Scan-bound bottleneck on catalog_sales Index Scan with Filter on cs_wholesale_cost (removes 98% of rows, 5,171 vs 107 kept). Cardinality flows: date_dim (365 rows) → catalog_sales (38K rows) filtered to 107 → dimensions filter to ~5 rows. The optimizer already handles parallel execution, index scans, and join reordering well. Logical-tree cost percentages are misleading - the 98% filter cost is hidden in the Index Scan node.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output all 10 columns with exact aliases agg1-agg6.
- CTE_COLUMN_COMPLETENESS: Each CTE must include all columns referenced downstream: join keys, GROUP BY columns, aggregates, filter columns.
- LITERAL_PRESERVATION: All filter values ('F', 'College', 1998, 2, 'AR','NY','TX', 41-46, 'Sports') must be preserved exactly.
- SEMANTIC_EQUIVALENCE: Must return same rows with same AVG values (duplicate-sensitive).
- COMMA_JOIN_WEAKNESS: Query uses comma-separated joins; EXPLAIN shows nested loops but cardinality estimation may suffer.

REGRESSION_WARNINGS:
None applicable.

=== WORKER 1 BRIEFING ===

STRATEGY: pg_dimension_prefetch_star
TARGET_LOGICAL_TREE:
date_cte -> item_cte -> cd_cte -> customer_cte -> ca_cte -> filtered_sales -> join_all -> aggregate -> sort -> limit
NODE_CONTRACTS:
  date_cte:
    FROM: date_dim
    WHERE: d_year = 1998
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 365
    CONSUMERS: filtered_sales
  item_cte:
    FROM: item
    WHERE: i_category = 'Sports'
    OUTPUT: i_item_sk, i_item_id
    EXPECTED_ROWS: unknown (but selective)
    CONSUMERS: filtered_sales
  cd_cte:
    FROM: customer_demographics
    WHERE: cd_gender = 'F' AND cd_education_status = 'College'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: unknown (but selective)
    CONSUMERS: filtered_sales
  customer_cte:
    FROM: customer
    WHERE: c_birth_month = 2
    OUTPUT: c_customer_sk, c_current_addr_sk, c_birth_year
    EXPECTED_ROWS: unknown (but selective)
    CONSUMERS: filtered_sales, ca_cte
  ca_cte:
    FROM: customer_address
    WHERE: ca_state IN ('AR', 'NY', 'TX')
    OUTPUT: ca_address_sk, ca_country, ca_state, ca_county
    EXPECTED_ROWS: unknown (but selective)
    CONSUMERS: join_all
  filtered_sales:
    FROM: catalog_sales
    WHERE: cs_wholesale_cost BETWEEN 41 AND 46
    OUTPUT: cs_sold_date_sk, cs_item_sk, cs_bill_cdemo_sk, cs_bill_customer_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit
    EXPECTED_ROWS: ~38K filtered by cost range
    CONSUMERS: join_all
  join_all:
    FROM: filtered_sales JOIN date_cte ON cs_sold_date_sk = d_date_sk JOIN item_cte ON cs_item_sk = i_item_sk JOIN cd_cte ON cs_bill_cdemo_sk = cd_demo_sk JOIN customer_cte ON cs_bill_customer_sk = c_customer_sk JOIN ca_cte ON c_current_addr_sk = ca_address_sk
    WHERE: (none beyond joins)
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit, c_birth_year
    EXPECTED_ROWS: ~5
    CONSUMERS: aggregate
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join
EXAMPLE_ADAPTATION:
pg_dimension_prefetch_star: Apply pre-filtering ALL dimension tables into CTEs and explicit JOIN syntax. Ignore that example uses UNION - this query has no UNION.
pg_date_cte_explicit_join: Apply explicit JOIN syntax and date CTE pattern. Ignore that it only pre-filters date_dim - we pre-filter all dimensions.
HAZARD_FLAGS:
- CTE materialization may block parallelism (each CTE executes single-threaded).
- Pre-filtering catalog_sales by wholesale_cost alone may still scan large portion of table without date filter.

=== WORKER 2 BRIEFING ===

STRATEGY: global_predicate_pushdown
TARGET_LOGICAL_TREE:
filtered_sales -> date_cte -> item_cte -> cd_cte -> customer_cte -> ca_cte -> aggregate -> sort -> limit
NODE_CONTRACTS:
  filtered_sales:
    FROM: catalog_sales
    WHERE: cs_wholesale_cost BETWEEN 41 AND 46
    OUTPUT: cs_sold_date_sk, cs_item_sk, cs_bill_cdemo_sk, cs_bill_customer_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit
    EXPECTED_ROWS: ~38K filtered by cost range
    CONSUMERS: join_date
  date_cte:
    FROM: date_dim
    WHERE: d_year = 1998
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 365
    CONSUMERS: join_date
  join_date:
    FROM: filtered_sales JOIN date_cte ON cs_sold_date_sk = d_date_sk
    WHERE: (none)
    OUTPUT: cs_item_sk, cs_bill_cdemo_sk, cs_bill_customer_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit
    EXPECTED_ROWS: ~107
    CONSUMERS: join_item
  item_cte:
    FROM: item
    WHERE: i_category = 'Sports'
    OUTPUT: i_item_sk, i_item_id
    EXPECTED_ROWS: unknown
    CONSUMERS: join_item
  join_item:
    FROM: join_date JOIN item_cte ON cs_item_sk = i_item_sk
    WHERE: (none)
    OUTPUT: i_item_id, cs_bill_cdemo_sk, cs_bill_customer_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit
    EXPECTED_ROWS: ~107
    CONSUMERS: join_cd
  cd_cte:
    FROM: customer_demographics
    WHERE: cd_gender = 'F' AND cd_education_status = 'College'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: unknown
    CONSUMERS: join_cd
  join_cd:
    FROM: join_item JOIN cd_cte ON cs_bill_cdemo_sk = cd_demo_sk
    WHERE: (none)
    OUTPUT: i_item_id, cs_bill_customer_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit
    EXPECTED_ROWS: ~107
    CONSUMERS: join_customer
  customer_cte:
    FROM: customer
    WHERE: c_birth_month = 2
    OUTPUT: c_customer_sk, c_current_addr_sk, c_birth_year
    EXPECTED_ROWS: unknown
    CONSUMERS: join_customer
  join_customer:
    FROM: join_cd JOIN customer_cte ON cs_bill_customer_sk = c_customer_sk
    WHERE: (none)
    OUTPUT: i_item_id, c_current_addr_sk, c_birth_year, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit
    EXPECTED_ROWS: ~22
    CONSUMERS: join_ca
  ca_cte:
    FROM: customer_address
    WHERE: ca_state IN ('AR', 'NY', 'TX')
    OUTPUT: ca_address_sk, ca_country, ca_state, ca_county
    EXPECTED_ROWS: unknown
    CONSUMERS: join_ca
  join_ca:
    FROM: join_customer JOIN ca_cte ON c_current_addr_sk = ca_address_sk
    WHERE: (none)
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit, c_birth_year
    EXPECTED_ROWS: ~5
    CONSUMERS: aggregate
EXAMPLES: early_filter_decorrelate, pushdown
EXAMPLE_ADAPTATION:
early_filter_decorrelate: Apply early filtering of dimension tables into CTEs. Ignore decorrelation aspect - no correlated subqueries.
pushdown: Apply pushing the cs_wholesale_cost filter to the earliest possible point (first scan of catalog_sales).
HAZARD_FLAGS:
- Filtering catalog_sales by wholesale_cost before date join may still scan large table without date restriction.
- Sequential CTEs may prevent parallel execution within each CTE.

=== WORKER 3 BRIEFING ===

STRATEGY: late_attribute_binding
TARGET_LOGICAL_TREE:
filtered_sales -> date_cte -> item_cte -> cd_cte -> customer_cte -> aggregate_partial -> join_ca -> final_aggregate -> sort -> limit
NODE_CONTRACTS:
  date_cte:
    FROM: date_dim
    WHERE: d_year = 1998
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 365
    CONSUMERS: filtered_sales
  item_cte:
    FROM: item
    WHERE: i_category = 'Sports'
    OUTPUT: i_item_sk, i_item_id
    EXPECTED_ROWS: unknown
    CONSUMERS: filtered_sales
  cd_cte:
    FROM: customer_demographics
    WHERE: cd_gender = 'F' AND cd_education_status = 'College'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: unknown
    CONSUMERS: filtered_sales
  customer_cte:
    FROM: customer
    WHERE: c_birth_month = 2
    OUTPUT: c_customer_sk, c_birth_year
    EXPECTED_ROWS: unknown
    CONSUMERS: filtered_sales
  filtered_sales:
    FROM: catalog_sales JOIN date_cte ON cs_sold_date_sk = d_date_sk JOIN item_cte ON cs_item_sk = i_item_sk JOIN cd_cte ON cs_bill_cdemo_sk = cd_demo_sk JOIN customer_cte ON cs_bill_customer_sk = c_customer_sk
    WHERE: cs_wholesale_cost BETWEEN 41 AND 46
    OUTPUT: i_item_id, c_customer_sk, c_birth_year, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit
    EXPECTED_ROWS: ~22
    CONSUMERS: aggregate_partial
  aggregate_partial:
    FROM: filtered_sales
    GROUP BY: i_item_id, c_customer_sk, c_birth_year
    AGGREGATE: AVG(CAST(cs_quantity AS DECIMAL(12,2))), AVG(CAST(cs_list_price AS DECIMAL(12,2))), AVG(CAST(cs_coupon_amt AS DECIMAL(12,2))), AVG(CAST(cs_sales_price AS DECIMAL(12,2))), AVG(CAST(cs_net_profit AS DECIMAL(12,2))), AVG(CAST(c_birth_year AS DECIMAL(12,2)))
    OUTPUT: i_item_id, c_customer_sk, c_birth_year, agg1, agg2, agg3, agg4, agg5, agg6
    EXPECTED_ROWS: ≤22
    CONSUMERS: join_ca
  ca_cte:
    FROM: customer_address
    WHERE: ca_state IN ('AR', 'NY', 'TX')
    OUTPUT: ca_address_sk, ca_country, ca_state, ca_county, c_customer_sk
    EXPECTED_ROWS: unknown
    CONSUMERS: join_ca
  join_ca:
    FROM: aggregate_partial JOIN customer ON aggregate_partial.c_customer_sk = customer.c_customer_sk JOIN ca_cte ON customer.c_current_addr_sk = ca_cte.ca_address_sk
    WHERE: (none)
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, agg5, agg6
    EXPECTED_ROWS: ~5
    CONSUMERS: final_aggregate
  final_aggregate:
    FROM: join_ca
    GROUP BY ROLLUP: i_item_id, ca_country, ca_state, ca_county
    AGGREGATE: AVG(agg1), AVG(agg2), AVG(agg3), AVG(agg4), AVG(agg5), AVG(agg6)
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, agg5, agg6
    EXPECTED_ROWS: ~5 with rollup
    CONSUMERS: sort
EXAMPLES: dimension_cte_isolate, early_filter
EXAMPLE_ADAPTATION:
dimension_cte_isolate: Apply isolating dimension filters into CTEs. Ignore that example may pre-filter fact table - we defer customer_address join.
early_filter: Apply early filtering of dimension tables before joining with fact. Ignore decorrelation.
HAZARD_FLAGS:
- Aggregating before joining customer_address changes group membership if multiple addresses per customer (but c_current_addr_sk is current address, so 1:1).
- AVG of AVGs is not mathematically equivalent to single AVG over all rows unless groups are disjoint and weights equal.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: pg_materialized_dimension_fact_prefilter
TARGET_LOGICAL_TREE:
date_cte -> item_cte -> cd_cte -> customer_cte -> ca_cte -> sales_cte -> join_all -> aggregate -> sort -> limit
NODE_CONTRACTS:
  date_cte:
    FROM: date_dim
    WHERE: d_year = 1998
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 365
    CONSUMERS: sales_cte
  item_cte:
    FROM: item
    WHERE: i_category = 'Sports'
    OUTPUT: i_item_sk, i_item_id
    EXPECTED_ROWS: unknown
    CONSUMERS: sales_cte
  cd_cte:
    FROM: customer_demographics
    WHERE: cd_gender = 'F' AND cd_education_status = 'College'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: unknown
    CONSUMERS: sales_cte
  customer_cte:
    FROM: customer
    WHERE: c_birth_month = 2
    OUTPUT: c_customer_sk, c_current_addr_sk, c_birth_year
    EXPECTED_ROWS: unknown
    CONSUMERS: sales_cte, ca_cte
  ca_cte:
    FROM: customer_address
    WHERE: ca_state IN ('AR', 'NY', 'TX')
    OUTPUT: ca_address_sk, ca_country, ca_state, ca_county
    EXPECTED_ROWS: unknown
    CONSUMERS: join_all
  sales_cte:
    FROM: catalog_sales
    WHERE: cs_wholesale_cost BETWEEN 41 AND 46
    OUTPUT: cs_sold_date_sk, cs_item_sk, cs_bill_cdemo_sk, cs_bill_customer_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit
    EXPECTED_ROWS: ~38K
    CONSUMERS: join_all
  join_all:
    FROM: sales_cte JOIN date_cte ON cs_sold_date_sk = d_date_sk JOIN item_cte ON cs_item_sk = i_item_sk JOIN cd_cte ON cs_bill_cdemo_sk = cd_demo_sk JOIN customer_cte ON cs_bill_customer_sk = c_customer_sk JOIN ca_cte ON c_current_addr_sk = ca_address_sk
    WHERE: (none beyond joins)
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit, c_birth_year
    EXPECTED_ROWS: ~5
    CONSUMERS: aggregate
EXAMPLES: pg_materialized_dimension_fact_prefilter, pg_dimension_prefetch_star
EXAMPLE_ADAPTATION:
pg_materialized_dimension_fact_prefilter: Apply materializing BOTH dimension and fact table CTEs before join. This query has no non-equi joins, but the principle of staged reduction applies.
pg_dimension_prefetch_star: Also apply explicit JOIN syntax and pre-filtered dimensions. Combine with fact pre-filtering.
HAZARD_FLAGS:
- Materializing large fact table CTE (38K rows) may consume memory.
- Multiple MATERIALIZED CTEs may execute sequentially, losing parallelism.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy