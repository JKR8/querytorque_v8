## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~100
    ├── [CTE] filtered_sales  [+]  NEW: Isolates date+ratio filter before aggregation
    ├── [CTE] grouped_sales   [+]  NEW: Per store/item revenue aggregates
    ├── [CTE] store_avg       [+]  NEW: Store-level average revenue (computed BEFORE store/item filters)
    ├── JOIN (explicit INNER joins) [~]  Replaces comma-joins with explicit JOIN syntax
    ├── FILTER (revenue <= 0.1 * ave) [=]  Preserved in final_join WHERE clause
    ├── FILTER (i_manager_id BETWEEN 80 AND 84) [=]  Preserved in final_join JOIN condition
    ├── FILTER (s_state IN ('IA','IL','NC')) [=]  Preserved in final_join JOIN condition
    ├── SORT (s_store_name ASC, i_item_desc ASC) [=]
    └── OUTPUT (s_store_name, i_item_desc, revenue, i_current_price, i_wholesale_cost, i_brand) [=]
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "early_filter_decorrelate",
      "description": "Extract date and ratio filters into separate CTE before aggregation, preventing predicate pushdown that would alter store_avg calculation",
      "applied_to": ["filtered_sales"]
    },
    {
      "id": "R2",
      "type": "pushdown",
      "description": "Convert comma-joins to explicit INNER JOIN syntax for clarity and predictable execution",
      "applied_to": ["final_join"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_sales": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_store_sk, ss_item_sk, ss_sales_price FROM store_sales INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk WHERE d_month_seq BETWEEN 1195 AND 1195 + 11 AND ss_sales_price / ss_list_price BETWEEN 0.38 AND 0.48",
        "interfaces": {"outputs": ["ss_store_sk", "ss_item_sk", "ss_sales_price"], "consumes": []}
      },
      "grouped_sales": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_store_sk, ss_item_sk, SUM(ss_sales_price) AS revenue FROM filtered_sales GROUP BY ss_store_sk, ss_item_sk",
        "interfaces": {"outputs": ["ss_store_sk", "ss_item_sk", "revenue"], "consumes": ["filtered_sales"]}
      },
      "store_avg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_store_sk, AVG(revenue) AS ave FROM grouped_sales GROUP BY ss_store_sk",
        "interfaces": {"outputs": ["ss_store_sk", "ave"], "consumes": ["grouped_sales"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT s_store_name, i_item_desc, g.revenue, i_current_price, i_wholesale_cost, i_brand FROM grouped_sales g INNER JOIN store_avg a ON g.ss_store_sk = a.ss_store_sk INNER JOIN store ON store.s_store_sk = g.ss_store_sk AND store.s_state IN ('IA','IL','NC') INNER JOIN item ON item.i_item_sk = g.ss_item_sk AND item.i_manager_id BETWEEN 80 AND 84 WHERE g.revenue <= 0.1 * a.ave ORDER BY s_store_name, i_item_desc LIMIT 100",
        "interfaces": {"outputs": ["s_store_name", "i_item_desc", "revenue", "i_current_price", "i_wholesale_cost", "i_brand"], "consumes": ["grouped_sales", "store_avg"]}
      }
    },
    "reconstruction_order": ["filtered_sales", "grouped_sales", "store_avg", "main_query"],
    "assembly_template": "WITH filtered_sales AS ({filtered_sales}), grouped_sales AS ({grouped_sales}), store_avg AS ({store_avg}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '128MB'",
    "SET LOCAL enable_hashjoin = on",
    "SET LOCAL enable_nestloop = off",
    "SET LOCAL max_parallel_workers_per_gather = 2"
  ],
  "validation_checks": []
}
```

**Changes:** Restructured original comma-joins and inline subqueries into explicit CTE pipeline following the target logical tree. This isolates the date+ratio filter in `filtered_sales`, computes store averages BEFORE applying store/item filters, and uses explicit JOIN syntax for clarity and planner control.

**Expected speedup:** ~1.3-1.5x due to early reduction of 438K rows in `filtered_sales` CTE, elimination of redundant store_sales scans, and better hash join planning with increased work_mem.

**Runtime config rationale:**
- `work_mem = '128MB'`: Supports hash aggregates on ~78K rows in `grouped_sales` and hash joins in final_join
- `enable_hashjoin = on`: Optimal for equality joins on grouped keys
- `enable_nestloop = off`: Prevents inefficient nested loops on large intermediate results
- `max_parallel_workers_per_gather = 2`: Leverages parallel scans on date_dim and store_sales within CTEs