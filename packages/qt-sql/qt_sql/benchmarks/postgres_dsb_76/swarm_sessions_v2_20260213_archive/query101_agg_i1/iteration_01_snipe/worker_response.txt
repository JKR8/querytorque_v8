<reasoning>
**1. DIAGNOSE: Why previous attempts failed to reach 2.0x**

The original query returns 0 rows (extreme selectivity). The bottleneck is the massive nested loop join between store_sales (3.9M rows) and store_returns (890K rows) with the non-equi date window condition (d2 between d1 and d1+90). All previous attempts:

- **W1**: Used CTEs but created a complex join structure that still resulted in large hash joins (store_sales 3.9M rows × store_returns 352K rows). The CTE materialization fences prevented predicate pushdown.
- **W2**: Attempted date_pair CTE but had ambiguous column errors.
- **W3**: "Late attribute binding" kept the core fact join monolithic, so the expensive nested loop remained.
- **W4**: Complex CTE structure with subqueries caused massive materialization (21M rows in fact_web_sales).

The root cause: **Non-equi join input blindness**. PostgreSQL cannot pre-filter fact tables before the non-equi date window comparison. The original comma-join syntax also limits optimizer join reordering.

**2. IDENTIFY: Unexplored optimization angles**

Two key angles remain untried:
1. **Comma-join to explicit JOIN conversion** - PostgreSQL's optimizer handles explicit JOIN...ON much better than comma-joins for join reordering.
2. **Staged reduction for non-equi joins** - Pre-filter BOTH store_returns and web_sales by their respective date dimensions BEFORE the date window comparison.

**3. REWRITE: Strategy**

I'll apply a hybrid approach:
- Convert all comma-joins to explicit JOINs for better optimizer planning.
- Create filtered CTEs for selective dimensions (item, customer, household_demographics, customer_address).
- Pre-filter store_returns by d1 (year=1998) and web_sales by d2 (any date) BEFORE the date window comparison.
- Join the pre-filtered fact tables and apply the date window condition as an INNER JOIN between the two date dimensions.
- Use COUNT(DISTINCT) elimination (not needed here since we're counting rows).
- Preserve all defensive guards (none in original).

This reduces the nested loop input sizes dramatically before the expensive non-equi comparison.
</reasoning>

## Modified Logic Tree

```
[=] Original query
[~] Transform: comma-joins → explicit JOINs
[+] Add: filtered_item CTE
[+] Add: filtered_customer_dims CTE  
[+] Add: filtered_store_returns CTE (pre-joined with d1)
[+] Add: filtered_web_sales CTE (pre-joined with d2)
[~] Main query: JOIN filtered CTEs with explicit date window condition
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {"id": "R1", "type": "comma_join_to_explicit", "description": "Convert all comma-separated FROM tables to explicit JOIN...ON syntax", "applied_to": ["main_query"]},
    {"id": "R2", "type": "dimension_prefilter", "description": "Pre-filter selective dimensions into CTEs: item, customer+address+household", "applied_to": ["filtered_item", "filtered_customer_dims"]},
    {"id": "R3", "type": "staged_fact_reduction", "description": "Pre-filter store_returns by d1 (year=1998) and web_sales by d2 before date window comparison", "applied_to": ["filtered_store_returns", "filtered_web_sales"]},
    {"id": "R4", "type": "non_equi_join_reduction", "description": "Apply date window condition as INNER JOIN between pre-filtered date dimensions", "applied_to": ["main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Children', 'Electronics', 'Music')",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "filtered_customer_dims": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c.c_customer_sk, c.c_first_name, c.c_last_name FROM customer c INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk INNER JOIN household_demographics hd ON c.c_current_hdemo_sk = hd.hd_demo_sk WHERE ca.ca_state IN ('AR', 'CO', 'NC', 'NY', 'TX') AND hd.hd_income_band_sk BETWEEN 7 AND 13 AND hd.hd_buy_potential = '0-500'",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name"], "consumes": []}
      },
      "filtered_store_returns": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT sr.sr_ticket_number, sr.sr_item_sk, d1.d_date_sk AS d1_date_sk, d1.d_date AS d1_date FROM store_returns sr INNER JOIN date_dim d1 ON sr.sr_returned_date_sk = d1.d_date_sk INNER JOIN filtered_item i ON sr.sr_item_sk = i.i_item_sk WHERE d1.d_year = 1998",
        "interfaces": {"outputs": ["sr_ticket_number", "sr_item_sk", "d1_date_sk", "d1_date"], "consumes": ["filtered_item"]}
      },
      "filtered_web_sales": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ws.ws_bill_customer_sk, ws.ws_item_sk, d2.d_date_sk AS d2_date_sk, d2.d_date AS d2_date FROM web_sales ws INNER JOIN date_dim d2 ON ws.ws_sold_date_sk = d2.d_date_sk INNER JOIN filtered_item i ON ws.ws_item_sk = i.i_item_sk",
        "interfaces": {"outputs": ["ws_bill_customer_sk", "ws_item_sk", "d2_date_sk", "d2_date"], "consumes": ["filtered_item"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c.c_customer_sk, c.c_first_name, c.c_last_name, COUNT(*) AS cnt FROM store_sales ss INNER JOIN filtered_store_returns sr ON ss.ss_ticket_number = sr.sr_ticket_number AND ss.ss_item_sk = sr.sr_item_sk INNER JOIN filtered_web_sales ws ON ss.ss_customer_sk = ws.ws_bill_customer_sk AND ss.ss_item_sk = ws.ws_item_sk INNER JOIN filtered_customer_dims c ON ss.ss_customer_sk = c.c_customer_sk WHERE ss.ss_sales_price / ss.ss_list_price BETWEEN 35 * 0.01 AND 55 * 0.01 AND ws.d2_date BETWEEN sr.d1_date AND (sr.d1_date + INTERVAL '90 DAY') GROUP BY c.c_customer_sk, c.c_first_name, c.c_last_name ORDER BY cnt",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "cnt"], "consumes": ["filtered_store_returns", "filtered_web_sales", "filtered_customer_dims"]}
      }
    },
    "reconstruction_order": ["filtered_item", "filtered_customer_dims", "filtered_store_returns", "filtered_web_sales", "main_query"],
    "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_customer_dims AS ({filtered_customer_dims}), filtered_store_returns AS ({filtered_store_returns}), filtered_web_sales AS ({filtered_web_sales}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": ["SET LOCAL work_mem = '256MB'", "SET LOCAL enable_nestloop = off", "SET LOCAL enable_mergejoin = off", "SET LOCAL hash_mem_multiplier = 2.0"],
  "validation_checks": []
}
```

**Changes**: Converted comma-joins to explicit JOINs and created staged CTEs to pre-filter fact tables before the expensive date window non-equi join. This reduces nested loop input sizes dramatically.

**Expected speedup**: ≥2.0x. The rewrite eliminates the massive nested loop between store_sales and store_returns by pre-filtering both fact tables with their respective date dimensions, then applying the date window as a simple filter between pre-computed dates. The explicit JOIN syntax gives PostgreSQL better join reordering freedom. Runtime config disables nested/merge joins (forcing hash joins) and increases work_mem for larger hash tables.