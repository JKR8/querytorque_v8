## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~890K
    ├── [~] WITH date_pairs AS (MATERIALIZED date_dim self-join with 90-day window)
    ├── [~] WITH filtered_item AS (MATERIALIZED item filter by category)
    ├── [~] WITH store_returns_with_date AS (store_returns JOIN date_pairs)
    ├── [~] WITH store_returns_with_item AS (store_returns_with_date JOIN filtered_item)
    ├── [~] WITH store_sales_with_item AS (store_sales JOIN filtered_item with price ratio filter)
    ├── [~] WITH store_sales_joined AS (store_sales_with_item JOIN store_returns_with_item)
    ├── [~] WITH web_sales_joined AS (web_sales JOIN store_returns_with_date JOIN date_pairs)
    ├── [~] WITH final_join AS (store_sales_joined JOIN web_sales_joined)
    ├── [~] WITH aggregation AS (final_join + dim tables with demographic filters)
    └── [~] final_sort (ORDER BY cnt)
```

**Change markers:**
- `[~]` – All components modified from original comma joins to explicit CTE-based staged reduction
- Structural change: Materialized date_pairs and filtered_item CTEs pre-reduce dimension tables before joining with fact tables
- Preserved all original semantics: same filters, same join conditions, same output columns

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16",
  "rewrite_rules": [
    {"id": "R1", "type": "staged_dimension_reduction", "description": "Materialize filtered date pairs and items before joining with fact tables", "applied_to": ["date_pairs", "filtered_item"]},
    {"id": "R2", "type": "cte_pipeline", "description": "Break comma joins into explicit CTE chain following target logical tree", "applied_to": ["store_returns_with_date", "store_returns_with_item", "store_sales_with_item", "store_sales_joined", "web_sales_joined", "final_join"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_pairs": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d1.d_date_sk AS d1_date_sk, d1.d_date AS d1_date, d2.d_date_sk AS d2_date_sk FROM date_dim d1 INNER JOIN date_dim d2 ON d2.d_date BETWEEN d1.d_date AND (d1.d_date + INTERVAL '90 DAY') WHERE d1.d_year = 1998",
        "interfaces": {"outputs": ["d1_date_sk", "d1_date", "d2_date_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk FROM item WHERE i_category IN ('Children', 'Electronics', 'Music')",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "store_returns_with_date": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT sr_ticket_number, sr_item_sk, d2_date_sk FROM store_returns INNER JOIN date_pairs ON sr_returned_date_sk = d1_date_sk",
        "interfaces": {"outputs": ["sr_ticket_number", "sr_item_sk", "d2_date_sk"], "consumes": ["date_pairs"]}
      },
      "store_returns_with_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT sr_ticket_number, sr_item_sk, d2_date_sk FROM store_returns_with_date INNER JOIN filtered_item ON sr_item_sk = i_item_sk",
        "interfaces": {"outputs": ["sr_ticket_number", "sr_item_sk", "d2_date_sk"], "consumes": ["store_returns_with_date", "filtered_item"]}
      },
      "store_sales_with_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_ticket_number, ss_item_sk, ss_customer_sk FROM store_sales INNER JOIN filtered_item ON ss_item_sk = i_item_sk WHERE ss_sales_price / ss_list_price BETWEEN 35 * 0.01 AND 55 * 0.01",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_item_sk", "ss_customer_sk"], "consumes": ["filtered_item"]}
      },
      "store_sales_joined": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_customer_sk, ss_item_sk, d2_date_sk FROM store_sales_with_item INNER JOIN store_returns_with_item ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk",
        "interfaces": {"outputs": ["ss_customer_sk", "ss_item_sk", "d2_date_sk"], "consumes": ["store_sales_with_item", "store_returns_with_item"]}
      },
      "web_sales_joined": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ws_bill_customer_sk, ws_item_sk FROM web_sales INNER JOIN store_returns_with_date ON ws_item_sk = sr_item_sk INNER JOIN date_pairs ON ws_sold_date_sk = d2_date_sk AND store_returns_with_date.d2_date_sk = date_pairs.d2_date_sk",
        "interfaces": {"outputs": ["ws_bill_customer_sk", "ws_item_sk"], "consumes": ["store_returns_with_date", "date_pairs"]}
      },
      "final_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_customer_sk FROM store_sales_joined INNER JOIN web_sales_joined ON ss_customer_sk = ws_bill_customer_sk AND ss_item_sk = ws_item_sk",
        "interfaces": {"outputs": ["ss_customer_sk"], "consumes": ["store_sales_joined", "web_sales_joined"]}
      },
      "aggregation": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c_customer_sk, c_first_name, c_last_name, COUNT(*) AS cnt FROM final_join INNER JOIN customer ON ss_customer_sk = c_customer_sk INNER JOIN customer_address ON c_current_addr_sk = ca_address_sk INNER JOIN household_demographics ON c_current_hdemo_sk = hd_demo_sk WHERE ca_state IN ('AR', 'CO', 'NC', 'NY', 'TX') AND hd_income_band_sk BETWEEN 7 AND 13 AND hd_buy_potential = '0-500' GROUP BY c_customer_sk, c_first_name, c_last_name",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "cnt"], "consumes": ["final_join"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_customer_sk, c_first_name, c_last_name, cnt FROM aggregation ORDER BY cnt",
        "interfaces": {"outputs": ["c_customer_sk", "c_first_name", "c_last_name", "cnt"], "consumes": ["aggregation"]}
      }
    },
    "reconstruction_order": ["date_pairs", "filtered_item", "store_returns_with_date", "store_returns_with_item", "store_sales_with_item", "store_sales_joined", "web_sales_joined", "final_join", "aggregation", "main_query"],
    "assembly_template": "WITH date_pairs AS ({date_pairs}), filtered_item AS ({filtered_item}), store_returns_with_date AS ({store_returns_with_date}), store_returns_with_item AS ({store_returns_with_item}), store_sales_with_item AS ({store_sales_with_item}), store_sales_joined AS ({store_sales_joined}), web_sales_joined AS ({web_sales_joined}), final_join AS ({final_join}), aggregation AS ({aggregation}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Materialized date_pairs and filtered_item CTEs first to reduce dimension tables, then staged joins follow the target logical tree exactly. This addresses the non-equi join blindness by precomputing valid date pairs and filters items before expensive fact table joins.

**Expected speedup:** ~2.5x due to staged reduction of date_dim self-join (122×90 pairs) and early filtering of item categories before joining with large fact tables. The CTE pipeline prevents re-execution of expensive non-equi joins while preserving exact semantics.