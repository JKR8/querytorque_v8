## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ~744K
    ├── WITH filtered_sales_cte AS (MATERIALIZED)  [+]
    │   └── [CTE] filtered_sales_cte: store_sales+date+item scan with OR condition
    ├── WITH paired_items_cte AS (NOT MATERIALIZED)  [+]
    │   └── [CTE] paired_items_cte: self-join on filtered_sales_cte with i1 < i2
    ├── WITH dimension_join_cte AS (NOT MATERIALIZED)  [+]
    │   └── [CTE] dimension_join_cte: join to customer/customer_address/customer_demographics
    ├── WITH final_aggregate AS (NOT MATERIALIZED)  [+]
    │   └── [CTE] final_aggregate: group by both items and count
    ├── SELECT final_aggregate.*  [~]
    ├── SORT (cnt ASC)  [=]
    └── OUTPUT (i_item_sk, i_item_sk, cnt)  [=]
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "staged_cte_decomposition",
      "description": "Decompose original comma joins into explicit CTE pipeline following Target Logical Tree",
      "applied_to": ["filtered_sales_cte", "paired_items_cte", "dimension_join_cte", "final_aggregate"]
    },
    {
      "id": "R2",
      "type": "shared_materialization",
      "description": "Materialize filtered fact+dimension scan once, reuse for s1/s2 self-join",
      "applied_to": ["filtered_sales_cte"]
    },
    {
      "id": "R3",
      "type": "preserve_non_equi_join",
      "description": "Keep i_item_sk < i_item_sk in paired_items_cte to avoid duplicate pairs",
      "applied_to": ["paired_items_cte"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_sales_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT s.ss_ticket_number, s.ss_item_sk, s.ss_customer_sk, s.ss_list_price, i.i_item_sk, i.i_category, i.i_manager_id FROM store_sales s INNER JOIN date_dim d ON s.ss_sold_date_sk = d.d_date_sk INNER JOIN item i ON s.ss_item_sk = i.i_item_sk WHERE d.d_year BETWEEN 1999 AND 1999 + 1 AND s.ss_list_price BETWEEN 115 AND 129 AND (i.i_category IN ('Electronics', 'Men') OR i.i_manager_id BETWEEN 44 AND 63)",
          "interfaces": {
            "outputs": ["ss_ticket_number", "ss_item_sk", "ss_customer_sk", "ss_list_price", "i_item_sk", "i_category", "i_manager_id"],
            "consumes": []
          }
        },
        "paired_items_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT s1.i_item_sk AS i_item_sk, s2.i_item_sk AS i_item_sk2, s1.ss_customer_sk FROM filtered_sales_cte s1 INNER JOIN filtered_sales_cte s2 ON s1.ss_ticket_number = s2.ss_ticket_number AND s1.i_item_sk < s2.i_item_sk WHERE s1.i_category IN ('Electronics', 'Men') AND s2.i_manager_id BETWEEN 44 AND 63",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_sk2", "ss_customer_sk"],
            "consumes": ["filtered_sales_cte"]
          }
        },
        "dimension_join_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT p.i_item_sk, p.i_item_sk2 FROM paired_items_cte p INNER JOIN customer c ON p.ss_customer_sk = c.c_customer_sk INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk INNER JOIN customer_demographics cd ON c.c_current_cdemo_sk = cd.cd_demo_sk WHERE cd.cd_marital_status = 'D' AND cd.cd_education_status = 'College'",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_sk2"],
            "consumes": ["paired_items_cte"]
          }
        },
        "final_aggregate": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i_item_sk, i_item_sk2 AS i_item_sk, COUNT(*) AS cnt FROM dimension_join_cte GROUP BY i_item_sk, i_item_sk2 ORDER BY cnt",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_sk", "cnt"],
            "consumes": ["dimension_join_cte"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_item_sk, i_item_sk, cnt FROM final_aggregate",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_sk", "cnt"],
            "consumes": ["final_aggregate"]
          }
        }
      },
      "reconstruction_order": ["filtered_sales_cte", "paired_items_cte", "dimension_join_cte", "final_aggregate", "main_query"],
      "assembly_template": "WITH filtered_sales_cte AS ({filtered_sales_cte}), paired_items_cte AS ({paired_items_cte}), dimension_join_cte AS ({dimension_join_cte}), final_aggregate AS ({final_aggregate}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Converted original comma-join structure into explicit CTE pipeline following the target logical tree, with filtered_sales_cte materialized once then reused for s1/s2 self-join. This reduces redundant store_sales+date+item scans from 2 to 1 while preserving exact semantic equivalence.

**Expected speedup:** 2-3x from eliminating duplicate fact table scans and enabling better predicate pushdown into materialized CTE.