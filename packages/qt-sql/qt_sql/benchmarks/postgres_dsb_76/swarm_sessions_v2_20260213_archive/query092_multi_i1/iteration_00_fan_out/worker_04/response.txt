### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [~] filtered_item [=] CTE for item filtering
├── [~] filtered_dates [=] CTE for date filtering  
├── [~] ws_data [=] CTE for main web_sales join
├── [+] lateral_subquery [new] CTE for subquery base data
├── [~] lateral_avg [modified] Uses LATERAL join to correlated CTE
├── [~] filter [=] Simple WHERE clause
└── [=] aggregation [=] Final SUM with ORDER BY and LIMIT
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "PostgreSQL 16.11",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_decomposition", "description": "Split original query into CTEs per target logical tree", "applied_to": ["filtered_item", "filtered_dates", "ws_data", "lateral_subquery"]},
    {"id": "R2", "type": "lateral_transform", "description": "Convert correlated subquery to LATERAL join with separate CTE", "applied_to": ["lateral_avg"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk FROM item WHERE (i_manufact_id BETWEEN 566 AND 765 OR i_category IN ('Children', 'Jewelry', 'Men'))",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "filtered_dates": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2002-03-06' AND CAST('2002-03-06' AS DATE) + INTERVAL '90 day'",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "ws_data": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT fi.i_item_sk, ws.ws_item_sk, ws.ws_ext_discount_amt FROM filtered_item fi INNER JOIN web_sales ws ON fi.i_item_sk = ws.ws_item_sk INNER JOIN filtered_dates fd ON fd.d_date_sk = ws.ws_sold_date_sk WHERE ws.ws_wholesale_cost BETWEEN 16 AND 36",
        "interfaces": {"outputs": ["i_item_sk", "ws_item_sk", "ws_ext_discount_amt"], "consumes": ["filtered_item", "filtered_dates"]}
      },
      "lateral_subquery": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT ws.ws_item_sk, ws.ws_ext_discount_amt FROM web_sales ws INNER JOIN filtered_dates fd ON fd.d_date_sk = ws.ws_sold_date_sk WHERE ws.ws_wholesale_cost BETWEEN 16 AND 36 AND ws.ws_sales_price / ws.ws_list_price BETWEEN 35 * 0.01 AND 50 * 0.01",
        "interfaces": {"outputs": ["ws_item_sk", "ws_ext_discount_amt"], "consumes": ["filtered_dates"]}
      },
      "lateral_avg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT wd.ws_ext_discount_amt, sub.threshold FROM ws_data wd LEFT JOIN LATERAL (SELECT 1.3 * AVG(ls.ws_ext_discount_amt) AS threshold FROM lateral_subquery ls WHERE ls.ws_item_sk = wd.i_item_sk) sub ON true",
        "interfaces": {"outputs": ["ws_ext_discount_amt", "threshold"], "consumes": ["ws_data", "lateral_subquery"]}
      },
      "filter": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ws_ext_discount_amt FROM lateral_avg WHERE ws_ext_discount_amt > threshold",
        "interfaces": {"outputs": ["ws_ext_discount_amt"], "consumes": ["lateral_avg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT SUM(ws_ext_discount_amt) AS \"Excess Discount Amount\" FROM filter ORDER BY SUM(ws_ext_discount_amt) ASC LIMIT 100",
        "interfaces": {"outputs": ["Excess Discount Amount"], "consumes": ["filter"]}
      }
    },
    "reconstruction_order": ["filtered_item", "filtered_dates", "ws_data", "lateral_subquery", "lateral_avg", "filter", "main_query"],
    "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_dates AS ({filtered_dates}), ws_data AS ({ws_data}), lateral_subquery AS ({lateral_subquery}), lateral_avg AS ({lateral_avg}), filter AS ({filter}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes**: Converted the correlated scalar subquery to a LATERAL join with a separate CTE (`lateral_subquery`) that contains the filtered base data. The LATERAL computes the per-item average threshold, preserving the original correlation logic while exposing it for optimization.

**Expected speedup**: Moderate (1.5-2x). PostgreSQL's LATERAL optimization should enable better decorrelation and more efficient execution plans compared to the original correlated subquery execution model, while maintaining the per-item grouping semantics. The CTE structure helps materialize filtered subsets early.