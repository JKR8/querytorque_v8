```
=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
This query identifies customers (born Feb 1965-1971) in IL/KY/TX stores who returned items exceeding 120% of their store's average return, with specific demographics (female, married, college-educated). All joins are INNER = all conditions must match. The AVG in the correlated subquery must be computed PER STORE without duplicates. The condition `sr_return_amt / sr_return_quantity` depends on non-null quantity values.

BOTTLENECK_DIAGNOSIS:
Correlated subquery execution (SubPlan 2) dominates runtime (10461ms) - re-executes 1845x against 95K-row CTE. Cardinality flow: CTE builds 95K rows → filtered to 582 rows → correlated subquery scans 95K rows per outer row. Optimizer handles CTE materialization and date join efficiently. Logical-tree cost (88% main) understates physical reality (subquery is 99.8% of runtime).

ACTIVE_CONSTRAINTS:
- SEMANTIC_EQUIVALENCE: Must preserve per-store AVG comparison and demographic filters exactly.
- COMPLETE_OUTPUT: Output must be exactly c_customer_id ordered ASC.
- LITERAL_PRESERVATION: All literals (d_year=2002, states, education, birth month) must be copied exactly.
- CTE_COLUMN_COMPLETENESS: New CTEs must output all columns referenced by joins/consumers.
- CORRELATED_SUBQUERY_PARALYSIS: EXPLAIN shows nested-loop re-execution (1845x) of 95K-row CTE scan.
- COMMA_JOIN_WEAKNESS: CTE uses comma-join (store_returns, date_dim) preventing hash-join optimization.

REGRESSION_WARNINGS:
1. Correlated subquery decorrelation (P2) [observed regression: Q054 0.51x]:
   CAUSE: Applied to multi-fact join query causing join-order lock.
   RULE: This query has single fact table (store_returns) - safe to decorrelate.
2. Multi-dimension prefetch (P7) [observed regression: Q031_i1 0.25x]:
   CAUSE: Applied to self-join pattern destroying parallelism.
   RULE: This query has no self-join - star-schema pattern applies.

=== WORKER 1 BRIEFING ===

STRATEGY: early_filter_decorrelate
TARGET_LOGICAL_TREE:
  store_avg_return (CTE) → customer_total_return (CTE) → filtered_store (CTE) → main_join → output
NODE_CONTRACTS:
  store_avg_return:
    FROM: customer_total_return
    GROUP BY: ctr_store_sk
    AGGREGATE: AVG(ctr_total_return)*1.2 AS store_avg
    OUTPUT: ctr_store_sk, store_avg
    EXPECTED_ROWS: ~1.8K (distinct stores)
    CONSUMERS: main_join

  customer_total_return:
    FROM: store_returns INNER JOIN date_dim ON sr_returned_date_sk = d_date_sk
    WHERE: d_year=2002 AND (sr_return_amt/sr_return_quantity) BETWEEN 108 AND 167
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
    OUTPUT: ctr_customer_sk, ctr_store_sk, ctr_reason_sk, ctr_total_return
    EXPECTED_ROWS: 95K
    CONSUMERS: store_avg_return, main_join

  filtered_store:
    FROM: store
    WHERE: s_state IN ('IL','KY','TX')
    OUTPUT: s_store_sk, s_state
    EXPECTED_ROWS: ~9 (from EXPLAIN: 9 rows after filter)
    CONSUMERS: main_join

  main_join:
    FROM: customer_total_return ctr1 
          INNER JOIN store_avg_return ON ctr1.ctr_store_sk = store_avg_return.ctr_store_sk
          INNER JOIN filtered_store ON ctr1.ctr_store_sk = filtered_store.s_store_sk
          INNER JOIN customer ON ctr1.ctr_customer_sk = customer.c_customer_sk
          INNER JOIN customer_demographics ON customer.c_current_cdemo_sk = customer_demographics.cd_demo_sk
    WHERE: ctr1.ctr_reason_sk BETWEEN 43 AND 46
           AND ctr1.ctr_total_return > store_avg_return.store_avg
           AND customer_demographics.cd_marital_status IN ('M','M')
           AND customer_demographics.cd_education_status IN ('Advanced Degree','College')
           AND customer_demographics.cd_gender = 'F'
           AND customer.c_birth_month = 2
           AND customer.c_birth_year BETWEEN 1965 AND 1971
    OUTPUT: customer.c_customer_id
    EXPECTED_ROWS: 100
    CONSUMERS: output

EXAMPLES: decorrelate, early_filter, pg_date_cte_explicit_join
EXAMPLE_ADAPTATION:
  - decorrelate: Use CTE for store averages but keep customer_total_return intact
  - early_filter: Push store-state filter into CTE (filtered_store)
  - pg_date_cte_explicit_join: Convert comma join to explicit INNER JOIN
HAZARD_FLAGS:
- Verify AVG*1.2 matches original subquery semantics exactly
- Ensure CTE customer_total_return outputs all columns for both consumers

=== WORKER 2 BRIEFING ===

STRATEGY: inline_decorrelate_materialized
TARGET_LOGICAL_TREE:
  base_returns (CTE) → store_agg (CTE) → customer_agg (CTE) → filtered_dims → main_join → output
NODE_CONTRACTS:
  base_returns:
    FROM: store_returns INNER JOIN date_dim ON sr_returned_date_sk = d_date_sk
    WHERE: d_year=2002 AND (sr_return_amt/sr_return_quantity) BETWEEN 108 AND 167
    OUTPUT: sr_customer_sk, sr_store_sk, sr_reason_sk, SR_RETURN_AMT_INC_TAX
    EXPECTED_ROWS: ~2.5M (pre-aggregation)
    CONSUMERS: store_agg, customer_agg

  store_agg:
    FROM: base_returns
    GROUP BY: sr_store_sk
    AGGREGATE: AVG(SUM(SR_RETURN_AMT_INC_TAX)) OVER () * 1.2 AS store_avg
    OUTPUT: sr_store_sk, store_avg
    EXPECTED_ROWS: ~1.8K
    CONSUMERS: main_join

  customer_agg:
    FROM: base_returns
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
    AGGREGATE: SUM(SR_RETURN_AMT_INC_TAX) AS ctr_total_return
    OUTPUT: sr_customer_sk, sr_store_sk, sr_reason_sk, ctr_total_return
    EXPECTED_ROWS: 95K
    CONSUMERS: main_join

  main_join: [Same as Worker 1]
EXAMPLES: inline_decorrelate_materialized, single_pass_aggregation
EXAMPLE_ADAPTATION:
  - inline_decorrelate_materialized: Compute store averages from base scan
  - single_pass_aggregation: Use window function for store AVG (verify AVG(SUM) correctness)
HAZARD_FLAGS:
- AVG(SUM(...)) must match original per-store AVG semantics
- CTE base_returns must be MATERIALIZED to prevent re-scan

=== WORKER 3 BRIEFING ===

STRATEGY: pg_dimension_prefetch_star
TARGET_LOGICAL_TREE:
  filtered_demographics (CTE) → filtered_store (CTE) → customer_total_return (CTE) → store_avg_return (CTE) → main_join → output
NODE_CONTRACTS:
  filtered_demographics:
    FROM: customer_demographics
    WHERE: cd_marital_status IN ('M','M') 
           AND cd_education_status IN ('Advanced Degree','College')
           AND cd_gender = 'F'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: small (demographic slice)
    CONSUMERS: main_join

  filtered_store: [Same as Worker 1]
  customer_total_return: [Same as Worker 1]
  store_avg_return: [Same as Worker 1]
  
  main_join:
    FROM: ... [Same as Worker 1] ...
    JOIN: Add INNER JOIN filtered_demographics
EXAMPLES: pg_dimension_prefetch_star, dimension_cte_isolate
EXAMPLE_ADAPTATION:
  - pg_dimension_prefetch_star: Pre-filter demographics into CTE
  - dimension_cte_isolate: Isolate store filter early
HAZARD_FLAGS:
- Ensure all dimension keys (cd_demo_sk, s_store_sk) preserved
- Verify no join order change with multiple CTEs

=== WORKER 4 BRIEFING ===

STRATEGY: compound_strategy
TARGET_LOGICAL_TREE:
  filtered_demographics (CTE) → filtered_store (CTE) → base_returns (CTE) → store_agg (CTE) → customer_agg (CTE) → main_join → output
NODE_CONTRACTS:
  filtered_demographics: [Same as Worker 3]
  filtered_store: [Same as Worker 1]
  base_returns: [Same as Worker 2]
  store_agg: [Same as Worker 2]
  customer_agg: [Same as Worker 2]
  main_join: [Combine Worker 2/3 contracts]
EXAMPLES: pg_dimension_prefetch_star, inline_decorrelate_materialized
EXAMPLE_ADAPTATION:
  - Combine dimension prefetch (Worker 3) with inline decorrelation (Worker 2)
HAZARD_FLAGS:
- Risk of over-materialization (5 CTEs) blocking parallelism
- Verify AVG(SUM()) matches original AVG semantics
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy
```