<reasoning>
CLASSIFY:
This is a star-join aggregation query with ROLLUP grouping on dimension attributes (item_id, country, state, county). It follows a classic fact-to-dimension pattern: catalog_sales (fact) joined to 5 dimension tables with filters on each dimension. No self-joins, no correlated subqueries, no UNION ALL. Structural archetype: "star-join with late dim filter" - all filters are on dimension tables, but the optimizer pushes them down to index scans.

EXPLAIN PLAN ANALYSIS:
- Total execution: 528.8ms
- Dominant cost: Nested Loop between date_dim and catalog_sales (165.3ms for 45K rows) followed by filtering on cs_wholesale_cost (Rows Removed by Filter: 4,816 per loop). This is scan-bound on the fact table with index filter overhead.
- Cardinality flow: date_dim (122 rows) → catalog_sales (45K rows after wholesale_cost filter) → item (reduces to 390 rows) → customer (26 rows) → customer_demographics (2 rows) → customer_address (1 row). Sharp drop at item join (i_category='Music').
- Optimizer already does: predicate pushdown to all dimension tables via index scans, parallel execution (2 workers), nested loop joins with indexed lookups.
- Not doing: hash joins between small dimension CTEs, consolidation of fact table scans (only 1 scan), comma-join weakness (query uses implicit joins).
- CTE materialization: No CTEs in original query.

GAP MATCHING:
1. COMMA_JOIN_WEAKNESS: YES - query uses comma-separated implicit joins. Opportunity: convert to explicit JOINs with pre-filtered CTEs.
2. CORRELATED_SUBQUERY_PARALYSIS: NO - no correlated subqueries.
3. CROSS_CTE_PREDICATE_BLINDNESS: NO - no repeated fact scans.
4. NON_EQUI_JOIN_INPUT_BLINDNESS: NO - all joins are equi-joins.

AGGREGATION TRAP CHECK:
All aggregates are AVG of numeric columns. AVG is duplicate-sensitive but commutative with joins that don't change row multiplicity (inner joins on foreign keys). The joins are all on foreign keys (cs_item_sk, cs_bill_cdemo_sk, cs_bill_customer_sk, cs_sold_date_sk) with one-to-one relationships between fact and dimension rows. However, dimension filters could eliminate fact rows, changing which rows participate in averages. Any rewrite must preserve the same set of matching fact rows.

TRANSFORM SELECTION (ranked by expected value):
1. star_join_prefetch (maps to pg_dimension_prefetch_star, pg_date_cte_explicit_join) - Addresses comma-join weakness, pre-filters dimensions for better cardinality estimation.
2. global_predicate_pushdown (maps to early_filter_decorrelate) - Push all dimension filters into CTE definitions to reduce rows before joins.
3. late_attribute_binding - Defer customer_address join until after aggregation (since ca_country, ca_state, ca_county are only needed for GROUP BY, not for filtering).
4. single_pass_aggregation - Not applicable (only one aggregation).
5. minimal-change baseline - Since optimizer already does well, one worker should focus on just converting to explicit JOINs.

Diverse strategies:
- Worker 1: star_join_prefetch (pre-filter all dimensions into CTEs, explicit JOINs)
- Worker 2: global_predicate_pushdown (push filters into CTEs, maintain implicit joins)
- Worker 3: late_attribute_binding (defer address join post-aggregation)
- Worker 4: minimal-change baseline + parallel boost (explicit JOINs only, force parallelism)

LOGICAL TREE DESIGN:
For Worker 1: Create CTEs for each dimension with filters, then join with fact table.
For Worker 2: Create CTEs that push filters earlier in the join chain.
For Worker 3: Aggregate fact+dimensions first, then join with address.
For Worker 4: Simple explicit JOIN rewrite.

CTE column completeness check: Each CTE must output all columns referenced downstream (join keys, GROUP BY columns, aggregates).
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
Analyze music sales in 1999 for female college graduates born in December living in AR, IN, or VA, with wholesale cost $5-10. All joins are INNER (must match all dimension conditions). Aggregates are AVG (sensitive to row duplication from joins). Filters on customer_demographics (gender, education), customer (birth month), customer_address (state), date_dim (year), item (category), and catalog_sales (wholesale cost) must all be satisfied for each row.

BOTTLENECK_DIAGNOSIS:
Scan-bound on catalog_sales with index filter overhead (45K rows after date filter, then 4,816 rows removed per loop by wholesale_cost filter). Nested loops with indexed dimension lookups work well (each dimension filtered to tiny result). Optimizer already pushes all dimension predicates to index scans and uses parallel workers. Logical-tree costs misleading - actual time dominated by fact table scan filtering, not joins.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output i_item_id, ca_country, ca_state, ca_county, and 6 AVG aggregates.
- CTE_COLUMN_COMPLETENESS: Any CTE must include all columns referenced downstream (join keys, group-by columns).
- LITERAL_PRESERVATION: Must preserve exact filter values: 'F', '4 yr Degree', 1999, 12, ('AR','IN','VA'), 5-10, 'Music'.
- SEMANTIC_EQUIVALENCE: Must return same rows and aggregates.
- COMMA_JOIN_WEAKNESS: Query uses comma-separated implicit joins (PostgreSQL cardinality estimation weakness).

REGRESSION_WARNINGS:
1. CTE blocking parallelism (observed regression: 0.5x):
   CAUSE: Materialized CTEs execute single-threaded, preventing parallel table scans.
   RULE: Avoid wrapping large fact table scans in CTEs; keep them in main query for parallel execution.

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  date_cte -> item_cte -> customer_demo_cte -> customer_cte -> address_cte -> prefactored_fact -> main_join -> aggregate -> sort -> limit
NODE_CONTRACTS:
  date_cte:
    FROM: date_dim
    WHERE: d_year = 1999
    OUTPUT: d_date_sk, d_year
    EXPECTED_ROWS: 122
    CONSUMERS: prefactored_fact
  item_cte:
    FROM: item
    WHERE: i_category = 'Music'
    OUTPUT: i_item_sk, i_item_id
    EXPECTED_ROWS: ~1 per cs_item_sk (selective)
    CONSUMERS: prefactored_fact
  customer_demo_cte:
    FROM: customer_demographics
    WHERE: cd_gender = 'F' AND cd_education_status = '4 yr Degree'
    OUTPUT: cd_demo_sk, cd_gender, cd_education_status
    EXPECTED_ROWS: small
    CONSUMERS: prefactored_fact
  customer_cte:
    FROM: customer
    WHERE: c_birth_month = 12
    OUTPUT: c_customer_sk, c_birth_month, c_birth_year, c_current_addr_sk
    EXPECTED_ROWS: ~1/12 of customers
    CONSUMERS: prefactored_fact
  address_cte:
    FROM: customer_address
    WHERE: ca_state IN ('AR', 'IN', 'VA')
    OUTPUT: ca_address_sk, ca_country, ca_state, ca_county
    EXPECTED_ROWS: small
    CONSUMERS: main_join
  prefactored_fact:
    FROM: catalog_sales
    WHERE: cs_wholesale_cost BETWEEN 5 AND 10
    OUTPUT: cs_sold_date_sk, cs_item_sk, cs_bill_cdemo_sk, cs_bill_customer_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit
    EXPECTED_ROWS: 45K after date join, filtered
    CONSUMERS: main_join
  main_join:
    FROM: prefactored_fact
    JOIN: date_cte ON cs_sold_date_sk = d_date_sk
    JOIN: item_cte ON cs_item_sk = i_item_sk
    JOIN: customer_demo_cte ON cs_bill_cdemo_sk = cd_demo_sk
    JOIN: customer_cte ON cs_bill_customer_sk = c_customer_sk
    JOIN: address_cte ON c_current_addr_sk = ca_address_sk
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit, c_birth_year
    EXPECTED_ROWS: ~1 (after all filters)
    CONSUMERS: aggregate
  aggregate:
    FROM: main_join
    GROUP BY: ROLLUP (i_item_id, ca_country, ca_state, ca_county)
    AGGREGATE: AVG(cast(cs_quantity as decimal(12,2))), AVG(cast(cs_list_price as decimal(12,2))), AVG(cast(cs_coupon_amt as decimal(12,2))), AVG(cast(cs_sales_price as decimal(12,2))), AVG(cast(cs_net_profit as decimal(12,2))), AVG(cast(c_birth_year as decimal(12,2)))
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, agg5, agg6
    EXPECTED_ROWS: >1 (ROLLUP groups)
    CONSUMERS: sort
EXAMPLES: pg_dimension_prefetch_star, pg_date_cte_explicit_join, pg_materialized_dimension_fact_prefilter
EXAMPLE_ADAPTATION:
pg_dimension_prefetch_star: Apply pre-filtering all dimensions (date, item, customer_demographics, customer, address) into CTEs and explicit JOIN syntax. Ignore the UNION ALL aspect (this query has none).
pg_date_cte_explicit_join: Apply date_cte isolation and explicit JOIN conversion. Ignore the single-dimension focus - extend to all dimensions.
pg_materialized_dimension_fact_prefilter: Apply MATERIALIZED to dimension CTEs for early reduction. Ignore the non-equi join aspect - all joins here are equi.
HAZARD_FLAGS:
- CTEs may block parallelism on fact table scan (prefactored_fact executes single-threaded).
- Over-materialization could increase overhead for small dimension lookups.

=== WORKER 2 BRIEFING ===

STRATEGY: global_predicate_pushdown
TARGET_LOGICAL_TREE:
  filtered_catalog_sales -> join_with_dims -> aggregate -> sort -> limit
NODE_CONTRACTS:
  filtered_catalog_sales:
    FROM: catalog_sales
    JOIN: date_dim ON cs_sold_date_sk = d_date_sk AND d_year = 1999
    JOIN: item ON cs_item_sk = i_item_sk AND i_category = 'Music'
    JOIN: customer_demographics ON cs_bill_cdemo_sk = cd_demo_sk AND cd_gender = 'F' AND cd_education_status = '4 yr Degree'
    JOIN: customer ON cs_bill_customer_sk = c_customer_sk AND c_birth_month = 12
    WHERE: cs_wholesale_cost BETWEEN 5 AND 10
    OUTPUT: cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit, i_item_id, c_birth_year, c_current_addr_sk
    EXPECTED_ROWS: ~1 (after filters)
    CONSUMERS: join_with_dims
  join_with_dims:
    FROM: filtered_catalog_sales
    JOIN: customer_address ON c_current_addr_sk = ca_address_sk AND ca_state IN ('AR', 'IN', 'VA')
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit, c_birth_year
    EXPECTED_ROWS: ~1
    CONSUMERS: aggregate
  aggregate:
    FROM: join_with_dims
    GROUP BY: ROLLUP (i_item_id, ca_country, ca_state, ca_county)
    AGGREGATE: AVG(cast(cs_quantity as decimal(12,2))), AVG(cast(cs_list_price as decimal(12,2))), AVG(cast(cs_coupon_amt as decimal(12,2))), AVG(cast(cs_sales_price as decimal(12,2))), AVG(cast(cs_net_profit as decimal(12,2))), AVG(cast(c_birth_year as decimal(12,2)))
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, agg5, agg6
    EXPECTED_ROWS: >1
    CONSUMERS: sort
EXAMPLES: early_filter_decorrelate, pushdown
EXAMPLE_ADAPTATION:
early_filter_decorrelate: Apply pushing dimension filters into JOIN ON conditions (not WHERE) to filter early. Ignore the decorrelation aspect - no subqueries.
pushdown: Apply predicate movement to push all filters as close to scans as possible. Use explicit JOIN syntax with conditions in ON clauses.
HAZARD_FLAGS:
- May confuse optimizer with complex ON conditions across multiple joins.
- Must ensure all joins remain INNER to preserve semantics.

=== WORKER 3 BRIEFING ===

STRATEGY: late_attribute_binding
TARGET_LOGICAL_TREE:
  fact_dim_agg -> address_join -> sort -> limit
NODE_CONTRACTS:
  fact_dim_agg:
    FROM: catalog_sales
    JOIN: date_dim ON cs_sold_date_sk = d_date_sk
    JOIN: item ON cs_item_sk = i_item_sk
    JOIN: customer_demographics ON cs_bill_cdemo_sk = cd_demo_sk
    JOIN: customer ON cs_bill_customer_sk = c_customer_sk
    WHERE: d_year = 1999
      AND i_category = 'Music'
      AND cd_gender = 'F'
      AND cd_education_status = '4 yr Degree'
      AND c_birth_month = 12
      AND cs_wholesale_cost BETWEEN 5 AND 10
    GROUP BY: i_item_id, c_current_addr_sk, c_birth_year
    AGGREGATE: AVG(cast(cs_quantity as decimal(12,2))), AVG(cast(cs_list_price as decimal(12,2))), AVG(cast(cs_coupon_amt as decimal(12,2))), AVG(cast(cs_sales_price as decimal(12,2))), AVG(cast(cs_net_profit as decimal(12,2))), AVG(cast(c_birth_year as decimal(12,2)))
    OUTPUT: i_item_id, c_current_addr_sk, agg1, agg2, agg3, agg4, agg5, agg6
    EXPECTED_ROWS: small (grouped by item and address)
    CONSUMERS: address_join
  address_join:
    FROM: fact_dim_agg
    JOIN: customer_address ON c_current_addr_sk = ca_address_sk AND ca_state IN ('AR', 'IN', 'VA')
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, agg5, agg6
    EXPECTED_ROWS: same as input (address filter applied)
    CONSUMERS: sort
EXAMPLES: dimension_cte_isolate, late_attribute_binding
EXAMPLE_ADAPTATION:
dimension_cte_isolate: Apply isolating customer_address as separate CTE joined last. Ignore the CTE materialization - can use direct join.
late_attribute_binding: Defer customer_address join until after aggregation since its columns only appear in GROUP BY/SELECT, not in WHERE. Verify address columns not used in earlier filters (they aren't).
HAZARD_FLAGS:
- Aggregation before address join changes group membership if address filter eliminates groups. Must apply address filter AFTER aggregation but before final ROLLUP? Actually ROLLUP needs address columns. Need to group by address surrogate key first, then join and group again? This is complex.
- May break ROLLUP semantics if address columns not in initial GROUP BY.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: minimal_explicit_joins_parallel
TARGET_LOGICAL_TREE:
  main_explicit_joins -> aggregate -> sort -> limit
NODE_CONTRACTS:
  main_explicit_joins:
    FROM: catalog_sales
    JOIN: date_dim ON cs_sold_date_sk = d_date_sk
    JOIN: item ON cs_item_sk = i_item_sk
    JOIN: customer_demographics ON cs_bill_cdemo_sk = cd_demo_sk
    JOIN: customer ON cs_bill_customer_sk = c_customer_sk
    JOIN: customer_address ON c_current_addr_sk = ca_address_sk
    WHERE: cd_gender = 'F'
      AND cd_education_status = '4 yr Degree'
      AND d_year = 1999
      AND c_birth_month = 12
      AND ca_state IN ('AR', 'IN', 'VA')
      AND cs_wholesale_cost BETWEEN 5 AND 10
      AND i_category = 'Music'
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit, c_birth_year
    EXPECTED_ROWS: ~1
    CONSUMERS: aggregate
  aggregate:
    FROM: main_explicit_joins
    GROUP BY: ROLLUP (i_item_id, ca_country, ca_state, ca_county)
    AGGREGATE: AVG(cast(cs_quantity as decimal(12,2))), AVG(cast(cs_list_price as decimal(12,2))), AVG(cast(cs_coupon_amt as decimal(12,2))), AVG(cast(cs_sales_price as decimal(12,2))), AVG(cast(cs_net_profit as decimal(12,2))), AVG(cast(c_birth_year as decimal(12,2)))
    OUTPUT: i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, agg5, agg6
    EXPECTED_ROWS: >1
    CONSUMERS: sort
EXAMPLES: pg_date_cte_explicit_join
EXAMPLE_ADAPTATION:
pg_date_cte_explicit_join: Apply explicit JOIN syntax conversion only. Ignore the CTE isolation - keep all tables in main FROM.
HAZARD_FLAGS:
- Minimal change may not improve performance significantly.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy (combines explicit JOINs with parallel hints)