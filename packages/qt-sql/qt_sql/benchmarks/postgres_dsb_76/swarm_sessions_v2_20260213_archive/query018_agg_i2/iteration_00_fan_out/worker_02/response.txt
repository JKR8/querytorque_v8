## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~135K
    ├── [CTE] filtered_catalog_sales  [+]  (new CTE for early filtering)
    │   ├── SCAN catalog_sales
    │   ├── JOIN date_dim ON cs_sold_date_sk = d_date_sk AND d_year = 1999
    │   ├── JOIN item ON cs_item_sk = i_item_sk AND i_category = 'Music'
    │   ├── JOIN customer_demographics ON cs_bill_cdemo_sk = cd_demo_sk AND cd_gender = 'F' AND cd_education_status = '4 yr Degree'
    │   ├── JOIN customer ON cs_bill_customer_sk = c_customer_sk AND c_birth_month = 12
    │   └── FILTER cs_wholesale_cost BETWEEN 5 AND 10
    ├── [CTE] join_with_dims  [+]  (new CTE for address join)
    │   ├── FROM filtered_catalog_sales
    │   └── JOIN customer_address ON c_current_addr_sk = ca_address_sk AND ca_state IN ('AR','IN','VA')
    ├── [CTE] aggregate  [+]  (new CTE for aggregation)
    │   ├── FROM join_with_dims
    │   └── GROUP BY ROLLUP (i_item_id, ca_country, ca_state, ca_county)
    ├── SORT (ca_country, ca_state, ca_county, i_item_id)
    └── OUTPUT (i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, ...)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "early_filter_decorrelate",
      "description": "Push dimension filters into JOIN ON conditions for early filtering, use explicit JOIN syntax",
      "applied_to": ["filtered_catalog_sales", "join_with_dims", "aggregate"]
    },
    {
      "id": "R2",
      "type": "pushdown",
      "description": "Move all filters as close to scans as possible using explicit JOIN ON clauses",
      "applied_to": ["filtered_catalog_sales", "join_with_dims"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_catalog_sales": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT cs.cs_quantity, cs.cs_list_price, cs.cs_coupon_amt, cs.cs_sales_price, cs.cs_net_profit, i.i_item_id, c.c_birth_year, c.c_current_addr_sk FROM catalog_sales cs JOIN date_dim d ON cs.cs_sold_date_sk = d.d_date_sk AND d.d_year = 1999 JOIN item i ON cs.cs_item_sk = i.i_item_sk AND i.i_category = 'Music' JOIN customer_demographics cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk AND cd.cd_gender = 'F' AND cd.cd_education_status = '4 yr Degree' JOIN customer c ON cs.cs_bill_customer_sk = c.c_customer_sk AND c.c_birth_month = 12 WHERE cs.cs_wholesale_cost BETWEEN 5 AND 10",
          "interfaces": {
            "outputs": ["cs_quantity", "cs_list_price", "cs_coupon_amt", "cs_sales_price", "cs_net_profit", "i_item_id", "c_birth_year", "c_current_addr_sk"],
            "consumes": []
          }
        },
        "join_with_dims": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT fcs.i_item_id, ca.ca_country, ca.ca_state, ca.ca_county, fcs.cs_quantity, fcs.cs_list_price, fcs.cs_coupon_amt, fcs.cs_sales_price, fcs.cs_net_profit, fcs.c_birth_year FROM filtered_catalog_sales fcs JOIN customer_address ca ON fcs.c_current_addr_sk = ca.ca_address_sk AND ca.ca_state IN ('AR', 'IN', 'VA')",
          "interfaces": {
            "outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "cs_quantity", "cs_list_price", "cs_coupon_amt", "cs_sales_price", "cs_net_profit", "c_birth_year"],
            "consumes": ["filtered_catalog_sales"]
          }
        },
        "aggregate": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT i_item_id, ca_country, ca_state, ca_county, AVG(CAST(cs_quantity AS DECIMAL(12,2))) AS agg1, AVG(CAST(cs_list_price AS DECIMAL(12,2))) AS agg2, AVG(CAST(cs_coupon_amt AS DECIMAL(12,2))) AS agg3, AVG(CAST(cs_sales_price AS DECIMAL(12,2))) AS agg4, AVG(CAST(cs_net_profit AS DECIMAL(12,2))) AS agg5, AVG(CAST(c_birth_year AS DECIMAL(12,2))) AS agg6 FROM join_with_dims GROUP BY ROLLUP (i_item_id, ca_country, ca_state, ca_county)",
          "interfaces": {
            "outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"],
            "consumes": ["join_with_dims"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, agg5, agg6 FROM aggregate ORDER BY ca_country, ca_state, ca_county, i_item_id LIMIT 100",
          "interfaces": {
            "outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"],
            "consumes": ["aggregate"]
          }
        }
      },
      "reconstruction_order": ["filtered_catalog_sales", "join_with_dims", "aggregate", "main_query"],
      "assembly_template": "WITH filtered_catalog_sales AS ({filtered_catalog_sales}), join_with_dims AS ({join_with_dims}), aggregate AS ({aggregate}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [],
  "validation_checks": []
}
```

**Changes:** Restructured into three CTEs following the target logical tree: 1) filtered_catalog_sales with all dimension joins and early filters, 2) join_with_dims adds customer_address filtering, 3) aggregate performs the ROLLUP aggregation. All joins use explicit JOIN syntax with filters in ON clauses for early pruning.

**Expected speedup:** ~1.2x from improved cardinality estimation and better join ordering. CTEs may limit parallelism but the expected row counts are small (~1 row).