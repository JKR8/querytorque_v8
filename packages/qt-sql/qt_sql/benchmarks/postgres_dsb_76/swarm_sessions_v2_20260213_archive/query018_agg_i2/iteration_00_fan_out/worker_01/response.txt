## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~135K
    ├── [~] CTE date_cte (replaces direct filter)
    ├── [~] CTE item_cte (replaces direct filter)
    ├── [~] CTE customer_demo_cte (replaces direct filter)
    ├── [~] CTE customer_cte (replaces direct filter)
    ├── [~] CTE address_cte (replaces direct filter)
    ├── [~] CTE prefactored_fact (replaces direct filter + separates large scan)
    ├── [~] JOIN (explicit INNER JOIN replaces comma joins)
    ├── [=] AGG (GROUP BY ROLLUP)
    ├── [=] SORT (ca_country, ca_state, ca_county, i_item_id)
    └── [=] OUTPUT (i_item_id, ca_country, ca_state, ca_county, agg1-6)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "dimension_prefetch",
      "description": "Pre-filter selective dimensions into materialized CTEs to create tiny hash tables",
      "applied_to": ["date_cte", "item_cte", "customer_demo_cte", "customer_cte", "address_cte"]
    },
    {
      "id": "R2",
      "type": "explicit_join_syntax",
      "description": "Convert comma-separated implicit joins to explicit INNER JOIN syntax for better cardinality estimation",
      "applied_to": ["main_query"]
    },
    {
      "id": "R3",
      "type": "staged_reduction",
      "description": "Filter fact table early (wholesale cost) before joining with prefetched dimensions",
      "applied_to": ["prefactored_fact"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "date_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year = 1999",
          "interfaces": {
            "outputs": ["d_date_sk", "d_year"],
            "consumes": []
          }
        },
        "item_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i_item_sk, i_item_id FROM item WHERE i_category = 'Music'",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_id"],
            "consumes": []
          }
        },
        "customer_demo_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT cd_demo_sk, cd_gender, cd_education_status FROM customer_demographics WHERE cd_gender = 'F' AND cd_education_status = '4 yr Degree'",
          "interfaces": {
            "outputs": ["cd_demo_sk", "cd_gender", "cd_education_status"],
            "consumes": []
          }
        },
        "customer_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT c_customer_sk, c_birth_month, c_birth_year, c_current_addr_sk FROM customer WHERE c_birth_month = 12",
          "interfaces": {
            "outputs": ["c_customer_sk", "c_birth_month", "c_birth_year", "c_current_addr_sk"],
            "consumes": []
          }
        },
        "address_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT ca_address_sk, ca_country, ca_state, ca_county FROM customer_address WHERE ca_state IN ('AR', 'IN', 'VA')",
          "interfaces": {
            "outputs": ["ca_address_sk", "ca_country", "ca_state", "ca_county"],
            "consumes": []
          }
        },
        "prefactored_fact": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT cs_sold_date_sk, cs_item_sk, cs_bill_cdemo_sk, cs_bill_customer_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price, cs_net_profit FROM catalog_sales WHERE cs_wholesale_cost BETWEEN 5 AND 10",
          "interfaces": {
            "outputs": ["cs_sold_date_sk", "cs_item_sk", "cs_bill_cdemo_sk", "cs_bill_customer_sk", "cs_quantity", "cs_list_price", "cs_coupon_amt", "cs_sales_price", "cs_net_profit"],
            "consumes": []
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_item_id, ca_country, ca_state, ca_county, AVG(CAST(cs_quantity AS DECIMAL(12,2))) AS agg1, AVG(CAST(cs_list_price AS DECIMAL(12,2))) AS agg2, AVG(CAST(cs_coupon_amt AS DECIMAL(12,2))) AS agg3, AVG(CAST(cs_sales_price AS DECIMAL(12,2))) AS agg4, AVG(CAST(cs_net_profit AS DECIMAL(12,2))) AS agg5, AVG(CAST(c_birth_year AS DECIMAL(12,2))) AS agg6 FROM prefactored_fact INNER JOIN date_cte ON cs_sold_date_sk = d_date_sk INNER JOIN item_cte ON cs_item_sk = i_item_sk INNER JOIN customer_demo_cte ON cs_bill_cdemo_sk = cd_demo_sk INNER JOIN customer_cte ON cs_bill_customer_sk = c_customer_sk INNER JOIN address_cte ON c_current_addr_sk = ca_address_sk GROUP BY ROLLUP (i_item_id, ca_country, ca_state, ca_county) ORDER BY ca_country, ca_state, ca_county, i_item_id LIMIT 100",
          "interfaces": {
            "outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"],
            "consumes": ["date_cte", "item_cte", "customer_demo_cte", "customer_cte", "address_cte", "prefactored_fact"]
          }
        }
      },
      "reconstruction_order": ["date_cte", "item_cte", "customer_demo_cte", "customer_cte", "address_cte", "prefactored_fact", "main_query"],
      "assembly_template": "WITH date_cte AS ({date_cte}), item_cte AS ({item_cte}), customer_demo_cte AS ({customer_demo_cte}), customer_cte AS ({customer_cte}), address_cte AS ({address_cte}), prefactored_fact AS ({prefactored_fact}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '512MB'",
    "SET LOCAL hash_mem_multiplier = 2.0",
    "SET LOCAL max_parallel_workers_per_gather = 0",
    "SET LOCAL from_collapse_limit = 1",
    "SET LOCAL join_collapse_limit = 1"
  ],
  "validation_checks": []
}
```

**Changes:** Converted implicit comma joins to explicit INNER JOINs with pre-materialized dimension CTEs, isolating each selective dimension filter into tiny hash tables. The fact table is filtered early on wholesale cost before joining.

**Expected speedup:** 2-3x (dimension prefetch reduces hash table build cost, explicit joins improve cardinality estimation, and CTE materialization prevents PostgreSQL from overestimating dimension sizes). The runtime config disables parallelism for the CTE-wrapped fact scan (which would be single-threaded anyway) and increases memory for hash operations. Setting collapse limits to 1 preserves the explicit join order.