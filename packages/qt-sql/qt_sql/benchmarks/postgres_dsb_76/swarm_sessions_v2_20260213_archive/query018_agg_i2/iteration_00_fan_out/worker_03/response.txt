## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Structural change: CTEs for phased aggregation + address filter
    ├── [~] CTE: fact_dim_agg
    │   ├── SCAN (catalog_sales, date_dim, item, customer_demographics, customer)
    │   ├── JOIN (cs_sold_date_sk = d_date_sk)
    │   ├── JOIN (cs_item_sk = i_item_sk)
    │   ├── JOIN (cs_bill_cdemo_sk = cd_demo_sk)
    │   ├── JOIN (cs_bill_customer_sk = c_customer_sk)
    │   ├── FILTER (d_year=1999, i_category='Music', cd_gender='F', cd_education_status='4 yr Degree', c_birth_month=12, cs_wholesale_cost 5-10)
    │   ├── GROUP BY (i_item_id, c_current_addr_sk, c_birth_year)
    │   └── AGGREGATE (6 AVGs)
    ├── [~] CTE: address_join
    │   ├── SCAN (fact_dim_agg, customer_address)
    │   ├── JOIN (c_current_addr_sk = ca_address_sk)
    │   └── FILTER (ca_state IN ('AR','IN','VA'))
    ├── [~] MAIN_BODY
    │   ├── SCAN (address_join)
    │   ├── GROUP BY ROLLUP (i_item_id, ca_country, ca_state, ca_county)
    │   ├── SORT (ca_country, ca_state, ca_county, i_item_id)
    │   └── LIMIT 100
    └── OUTPUT (i_item_id, ca_country, ca_state, ca_county, agg1..agg6)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "postgresql",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "late_attribute_binding",
      "description": "Deferred customer_address join until after initial aggregation to avoid duplicating fact rows before aggregation",
      "applied_to": ["fact_dim_agg", "address_join"]
    },
    {
      "id": "R2",
      "type": "explicit_cte_structure",
      "description": "Structured query per target logical tree with explicit CTEs for each phase",
      "applied_to": ["fact_dim_agg", "address_join", "main_query"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "fact_dim_agg": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT \n  i_item_id,\n  c_current_addr_sk,\n  AVG(CAST(cs_quantity AS DECIMAL(12,2))) AS agg1,\n  AVG(CAST(cs_list_price AS DECIMAL(12,2))) AS agg2,\n  AVG(CAST(cs_coupon_amt AS DECIMAL(12,2))) AS agg3,\n  AVG(CAST(cs_sales_price AS DECIMAL(12,2))) AS agg4,\n  AVG(CAST(cs_net_profit AS DECIMAL(12,2))) AS agg5,\n  AVG(CAST(c_birth_year AS DECIMAL(12,2))) AS agg6\nFROM catalog_sales\nINNER JOIN date_dim ON cs_sold_date_sk = d_date_sk\nINNER JOIN item ON cs_item_sk = i_item_sk\nINNER JOIN customer_demographics ON cs_bill_cdemo_sk = cd_demo_sk\nINNER JOIN customer ON cs_bill_customer_sk = c_customer_sk\nWHERE d_year = 1999\n  AND i_category = 'Music'\n  AND cd_gender = 'F'\n  AND cd_education_status = '4 yr Degree'\n  AND c_birth_month = 12\n  AND cs_wholesale_cost BETWEEN 5 AND 10\nGROUP BY i_item_id, c_current_addr_sk, c_birth_year",
          "interfaces": {
            "outputs": ["i_item_id", "c_current_addr_sk", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"],
            "consumes": []
          }
        },
        "address_join": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT \n  f.i_item_id,\n  ca.ca_country,\n  ca.ca_state,\n  ca.ca_county,\n  f.agg1,\n  f.agg2,\n  f.agg3,\n  f.agg4,\n  f.agg5,\n  f.agg6\nFROM fact_dim_agg f\nINNER JOIN customer_address ca ON f.c_current_addr_sk = ca.ca_address_sk\nWHERE ca.ca_state IN ('AR', 'IN', 'VA')",
          "interfaces": {
            "outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"],
            "consumes": ["fact_dim_agg"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT \n  i_item_id,\n  ca_country,\n  ca_state,\n  ca_county,\n  CASE WHEN COUNT(*) > 0 THEN AVG(CAST(agg1 AS DECIMAL(12,2))) END AS agg1,\n  CASE WHEN COUNT(*) > 0 THEN AVG(CAST(agg2 AS DECIMAL(12,2))) END AS agg2,\n  CASE WHEN COUNT(*) > 0 THEN AVG(CAST(agg3 AS DECIMAL(12,2))) END AS agg3,\n  CASE WHEN COUNT(*) > 0 THEN AVG(CAST(agg4 AS DECIMAL(12,2))) END AS agg4,\n  CASE WHEN COUNT(*) > 0 THEN AVG(CAST(agg5 AS DECIMAL(12,2))) END AS agg5,\n  CASE WHEN COUNT(*) > 0 THEN AVG(CAST(agg6 AS DECIMAL(12,2))) END AS agg6\nFROM address_join\nGROUP BY ROLLUP (i_item_id, ca_country, ca_state, ca_county)\nORDER BY ca_country, ca_state, ca_county, i_item_id\nLIMIT 100",
          "interfaces": {
            "outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6"],
            "consumes": ["address_join"]
          }
        }
      },
      "reconstruction_order": ["fact_dim_agg", "address_join", "main_query"],
      "assembly_template": "WITH fact_dim_agg AS ({fact_dim_agg}), address_join AS ({address_join}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "runtime_config": [
    "SET LOCAL work_mem = '512MB'",
    "SET LOCAL hash_mem_multiplier = 2.0",
    "SET LOCAL max_parallel_workers_per_gather = 2",
    "SET LOCAL parallel_tuple_cost = 0.1",
    "SET LOCAL parallel_setup_cost = 1000.0"
  ],
  "validation_checks": []
}
```

**Changes**: Restructured to defer address join until after initial aggregation, using CTEs to match target logical tree while preserving ROLLUP semantics. This avoids pre-aggregation fact row duplication from address table joins.

**Expected speedup**: 1.5-2x from reduced intermediate data volume and better parallelization of initial fact scan.