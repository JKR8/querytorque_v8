{
  "probe_id": "p01",
  "transform_id": "aggregate_pushdown",
  "family": "C",
  "dialect": "duckdb",
  "hypothesis": "Push aggregation on store_returns below the join with date_dim to reduce join input from 558K rows to distinct (customer, store, date) groups, moving the HASH_GROUP_BY cost before the join.",
  "reasoning_trace": [
    "The CTE customer_total_return aggregates store_returns after joining with date_dim.",
    "Grouping keys (sr_customer_sk, sr_store_sk) are join keys, but the join condition uses sr_returned_date_sk.",
    "We can pre-aggregate store_returns by (sr_customer_sk, sr_store_sk, sr_returned_date_sk) before the join.",
    "This reduces rows flowing into the join, then final aggregation sums the pre-aggregated fees."
  ],
  "target_ir": "CTE with two stages: store_returns_preagg (GROUP BY sr_customer_sk, sr_store_sk, sr_returned_date_sk) then join with date_dim and sum.",
  "steps": [
    {
      "step_id": "s1",
      "op": "replace_body",
      "target": {"by_node_id": "S0"},
      "payload": {
        "sql_fragment": "WITH store_returns_preagg AS (\n  SELECT sr_customer_sk,\n         sr_store_sk,\n         sr_returned_date_sk,\n         SUM(SR_FEE) AS sr_fee_sum\n  FROM store_returns\n  GROUP BY sr_customer_sk, sr_store_sk, sr_returned_date_sk\n),\ncustomer_total_return AS (\n  SELECT sr_customer_sk AS ctr_customer_sk,\n         sr_store_sk AS ctr_store_sk,\n         SUM(sr_fee_sum) AS ctr_total_return\n  FROM store_returns_preagg sra\n  INNER JOIN date_dim ON sra.sr_returned_date_sk = date_dim.d_date_sk\n  WHERE date_dim.d_year = 2000\n  GROUP BY sr_customer_sk, sr_store_sk\n)\nSELECT c_customer_id\nFROM customer_total_return ctr1,\n     store,\n     customer\nWHERE ctr1.ctr_total_return > (\n  SELECT AVG(ctr_total_return) * 1.2\n  FROM customer_total_return ctr2\n  WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk\n)\n  AND s_store_sk = ctr1.ctr_store_sk\n  AND s_state = 'SD'\n  AND ctr1.ctr_customer_sk = c_customer_sk\nORDER BY c_customer_id\nLIMIT 100"
      }
    }
  ]
}