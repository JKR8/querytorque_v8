[
  {
    "plan_id": "snipe_p1",
    "dialect": "duckdb",
    "confidence": 0.83,
    "based_on": "p04,p03",
    "strategy": "Combine decorrelation winner with corrected early store filter",
    "hypothesis": "p04 decorrelates subquery to hash join (1.53x win). p03's early store filter failed on column reference but is valid for DuckDB's CTE_INLINING; moving store filter into a CTE can reduce rows before main join. DuckDB's predicate pushdown already works, but explicit CTE may help join reorder. Merge both improvements.",
    "target_ir": "CTE customer_total_return unchanged; add filtered_store CTE; add store_averages CTE (decorrelated); main query uses explicit JOINs with filtered_store and store_averages.",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "WITH customer_total_return AS (\n  SELECT sr_customer_sk AS ctr_customer_sk,\n         sr_store_sk AS ctr_store_sk,\n         SUM(SR_FEE) AS ctr_total_return\n  FROM store_returns, date_dim\n  WHERE sr_returned_date_sk = d_date_sk\n    AND d_year = 2000\n  GROUP BY sr_customer_sk, sr_store_sk\n),\nfiltered_store AS (\n  SELECT s_store_sk\n  FROM store\n  WHERE s_state = 'SD'\n),\nstore_averages AS (\n  SELECT ctr_store_sk,\n         AVG(ctr_total_return) * 1.2 AS avg_return\n  FROM customer_total_return\n  GROUP BY ctr_store_sk\n)\nSELECT c_customer_id\nFROM customer_total_return AS ctr1\nJOIN store_averages AS sa ON ctr1.ctr_store_sk = sa.ctr_store_sk\nJOIN filtered_store AS s ON s.s_store_sk = ctr1.ctr_store_sk\nJOIN customer AS c ON ctr1.ctr_customer_sk = c.c_customer_sk\nWHERE ctr1.ctr_total_return > sa.avg_return\nORDER BY c_customer_id\nLIMIT 100"
        }
      }
    ]
  },
  {
    "plan_id": "snipe_p2",
    "dialect": "duckdb",
    "confidence": 0.78,
    "based_on": "p04",
    "strategy": "Decorrelation only, keep original store join for safety",
    "hypothesis": "p04 alone achieved 1.53x speedup by decorrelating subquery to hash join. Adding filtered_store CTE may not improve further; DuckDB can push filter into join. Keep original store join to avoid any risk of misâ€‘joining.",
    "target_ir": "CTE customer_total_return unchanged; add store_averages CTE; main query explicit JOINs with store and customer, keep s_state filter in WHERE.",
    "steps": [
      {
        "step_id": "s1",
        "op": "replace_body",
        "target": {"by_node_id": "S0"},
        "payload": {
          "sql_fragment": "WITH customer_total_return AS (\n  SELECT sr_customer_sk AS ctr_customer_sk,\n         sr_store_sk AS ctr_store_sk,\n         SUM(SR_FEE) AS ctr_total_return\n  FROM store_returns, date_dim\n  WHERE sr_returned_date_sk = d_date_sk\n    AND d_year = 2000\n  GROUP BY sr_customer_sk, sr_store_sk\n),\nstore_averages AS (\n  SELECT ctr_store_sk,\n         AVG(ctr_total_return) * 1.2 AS avg_return\n  FROM customer_total_return\n  GROUP BY ctr_store_sk\n)\nSELECT c_customer_id\nFROM customer_total_return AS ctr1\nJOIN store_averages AS sa ON ctr1.ctr_store_sk = sa.ctr_store_sk\nJOIN store AS s ON s.s_store_sk = ctr1.ctr_store_sk\nJOIN customer AS c ON ctr1.ctr_customer_sk = c.c_customer_sk\nWHERE s.s_state = 'SD'\n  AND ctr1.ctr_total_return > sa.avg_return\nORDER BY c_customer_id\nLIMIT 100"
        }
      }
    ]
  }
]