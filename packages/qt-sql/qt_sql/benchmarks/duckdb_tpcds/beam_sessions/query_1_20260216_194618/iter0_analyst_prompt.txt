## Role

You are a SQL optimization analyst. Your task is to analyze this query, identify the primary bottleneck, and design structural optimization targets.

For each target, describe the STRUCTURAL SHAPE of the optimized query using an IR node map (CTE names, FROM tables, WHERE conditions, GROUP BY, ORDER BY). A separate code-generation worker will convert your targets into executable patch plans.

Identify the primary bottleneck. Only provide secondary targets if they are distinct and high-confidence. **Quality > Quantity.**

## Query: query_1

**Dialect**: DUCKDB

```sql
-- start query 1 in stream 0 using template query1.tpl
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sum(SR_FEE) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2000
group by sr_customer_sk
,sr_store_sk)
 select c_customer_id
from customer_total_return ctr1
,store
,customer
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk)
and s_store_sk = ctr1.ctr_store_sk
and s_state = 'SD'
and ctr1.ctr_customer_sk = c_customer_sk
order by c_customer_id
 LIMIT 100;

-- end query 1 in stream 0 using template query1.tpl
```


## Current Execution Plan

```
Total execution time: 3551ms

CTE [0 rows, 13.1ms]
  HASH_GROUP_BY [539K rows, 1443.2ms, 41%]
    HASH_JOIN INNER on sr_returned_date_sk = d_date_sk [558K rows, 41.0ms, 1%]
      SEQ_SCAN  store_returns [558K of 69.1M rows, 1723.3ms, 49%]
      FILTER [366 rows, 0.4ms]
        SEQ_SCAN  date_dim [366 of 73K rows, 4.0ms]  Filters: d_year=2000
  TOP_N [100 rows, 29.3ms]
    FILTER [62K rows, 14.1ms]
      LEFT_DELIM_JOIN LEFT on ctr_store_sk IS NOT DISTINCT FROM ctr_store_sk [0 rows, 17.9ms]
        HASH_JOIN INNER on c_customer_sk = ctr_customer_sk [158K rows, 99.5ms, 3%]
          SEQ_SCAN  customer [500K of 2.5M rows, 71.5ms, 2%]
          HASH_JOIN INNER on ctr_store_sk = s_store_sk [158K rows, 10.1ms]
            CTE_SCAN [539K rows, 1.4ms]
            SEQ_SCAN  store [35 of 102 rows, 3.9ms]  Filters: s_state='SD'
        HASH_JOIN LEFT on ctr_store_sk IS NOT DISTINCT FROM ctr_store_sk [158K rows, 18.2ms]
          HASH_GROUP_BY [15 rows, 35.2ms]
            HASH_JOIN INNER on ctr_store_sk = ctr_store_sk [158K rows, 2.9ms]
              CTE_SCAN [539K rows, 1.0ms]
              DELIM_SCAN [0 rows]
        HASH_GROUP_BY [15 rows, 2.8ms]
```


## IR Structure (for patch targeting)

```
S0 [SELECT]
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: store_returns, date_dim
    WHERE [eb0f6bc97f7168d4]: sr_returned_date_sk = d_date_sk AND d_year = 2000
    GROUP BY: sr_customer_sk, sr_store_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store, customer
    WHERE [e5b7485395ff5a80]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WH...
    ORDER BY: c_customer_id
S1 [OTHER_DDL]

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**Note**: Use `by_node_id` (e.g., "S0") and `by_anchor_hash` (16-char hex) from map above to target patch operations.


## Optimization Families

This is a briefing of what we know, not a set of hard rules. Use your judgement about what's worth trying based on the EXPLAIN plan above.

**6 families have proven gold examples** on this engine. All 6 families are listed — those without gold examples are still valid strategies if the EXPLAIN plan warrants them.

Choose the most relevant families for this query based on:
- Query structure (CTEs, subqueries, joins, aggregations, set operations)
- Execution plan signals (WHERE placement, repeated scans, correlated subqueries)
- Problem signature (cardinality estimation errors, loops vs sets, filter ordering)



### Family A: Early Filtering (Predicate Pushback)
**Description**: Push small filters into CTEs early, reduce row count before expensive operations
**Speedup Range**: 1.3–4.0x (~35% of all wins)
**Use When**:
  1. Late WHERE filters on dimension tables
  2. Cascading CTEs with filters applied downstream
  3. Expensive joins after filters could be pushed earlier

**Gold Example**: `date_cte_isolate` (4.00x)



### Family B: Decorrelation (Sets Over Loops)
**Description**: Convert correlated subqueries to standalone CTEs with GROUP BY, eliminate per-row re-execution
**Speedup Range**: 2.4–2.9x (~15% of all wins)
**Use When**:
  1. Correlated subqueries in WHERE clause
  2. Scalar aggregates computed per outer row
  3. DELIM_SCAN in execution plan (indicates correlation)

**Gold Example**: `decorrelate` (2.92x)



### Family C: Aggregation Pushdown (Minimize Rows Touched)
**Description**: Aggregate before expensive joins when GROUP BY keys ⊇ join keys, reduce intermediate sizes
**Speedup Range**: 1.3–15.3x (~5% of all wins (high variance))
**Use When**:
  1. GROUP BY happens after large joins
  2. GROUP BY keys are subset of join keys
  3. Intermediate result size >> final result size

**Gold Example**: `aggregate_pushdown` (42.90x)



### Family D: Set Operation Optimization (Sets Over Loops)
**Description**: Replace INTERSECT/UNION-based patterns with EXISTS/NOT EXISTS, avoid full materialization
**Speedup Range**: 1.7–2.7x (~8% of all wins)
**Use When**:
  1. INTERSECT patterns between large sets
  2. UNION ALL with duplicate elimination
  3. Set operations materializing full intermediate results

**Gold Example**: `intersect_to_exists` (1.83x)



### Family E: Materialization / Prefetch (Don't Repeat Work)
**Description**: Extract repeated scans or pre-compute intermediate results for reuse across multiple consumers
**Speedup Range**: 1.3–6.2x (~18% of all wins)
**Use When**:
  1. Repeated scans of same table with different filters
  2. Dimension filters applied independently multiple times
  3. CTE referenced multiple times with implicit re-evaluation

**Gold Example**: `multi_dimension_prefetch` (2.71x)



### Family F: Join Transform (Right Shape First)
**Description**: Restructure join topology: convert comma joins to explicit INNER JOIN, optimize join order, eliminate self-joins via single-pass aggregation
**Speedup Range**: 1.8–8.6x (~19% of all wins)
**Use When**:
  1. Comma-separated joins (implicit cross joins) in FROM clause
  2. Self-joins scanning same table multiple times
  3. Dimension-fact join order suboptimal for predicate pushdown

**Gold Example**: `inner_join_conversion` (3.44x)



## Detected Patterns

### AST Feature Detection

- **decorrelate**: 100% match (AGG_AVG, AGG_SUM, CORRELATED_SUB, CTE) (gap: CORRELATED_SUBQUERY_PARALYSIS) [CAUTION: MISSING_FILTER, ALREADY_DECORRELATED]
- **prefetch_fact_join**: 100% match (AGG_SUM, DATE_DIM, GROUP_BY, STAR_JOIN) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: MAX_2_CHAINS]
- **dimension_cte_isolate**: 100% match (DATE_DIM, GROUP_BY, MULTI_TABLE_5+) (gap: CROSS_CTE_PREDICATE_BLINDNESS) [CAUTION: CROSS_JOIN_3_DIMS, UNFILTERED_CTE]
- **self_join_decomposition**: 100% match (AGG_AVG, CTE, GROUP_BY) (gap: CROSS_CTE_PREDICATE_BLINDNESS)
- **multi_dimension_prefetch**: 75% match (AGG_SUM, DATE_DIM, GROUP_BY) (gap: CROSS_CTE_PREDICATE_BLINDNESS)
  Missing: CASE_EXPR


**Instruction**: Prioritize detected patterns above. If a high-confidence
pathology is detected, your primary target SHOULD address it.


## Engine Playbook (DUCKDB)

# DuckDB Rewrite Playbook
# TPC-DS SF1–SF10 field intelligence

## ENGINE STRENGTHS — do NOT rewrite

1. **Predicate pushdown**: filter inside scan node → leave it.
2. **Same-column OR**: handled natively in one scan. Splitting = lethal (0.23x observed).
3. **Hash join selection**: sound for 2–4 tables. Reduce inputs, not order.
4. **CTE inlining**: single-ref CTEs inlined automatically (zero overhead).
5. **Columnar projection**: only referenced columns read.
6. **Parallel aggregation**: scans and aggregations parallelized across threads.
7. **EXISTS semi-join**: early termination. **Never materialize** (0.14x observed).

## GLOBAL GUARDS

1. EXISTS/NOT EXISTS → never materialize (0.14x, 0.54x — semi-join destroyed)
2. Same-column OR → never split to UNION (0.23x, 0.59x — native OR handling)
3. Baseline < 100ms → skip CTE-based rewrites (overhead exceeds savings)
4. 3+ fact table joins → do not pre-materialize facts (locks join order)
5. Every CTE MUST have a WHERE clause (0.85x observed)
6. No orphaned CTEs — remove original after splitting (0.49x, 0.68x — double materialization)
7. No cross-joining 3+ dimension CTEs (0.0076x — Cartesian product)
8. Max 2 cascading fact-table CTE chains (0.78x observed)
9. Convert comma joins to explicit JOIN...ON
10. NOT EXISTS → NOT IN breaks with NULLs — preserve EXISTS form

---

## DOCUMENTED CASES

Cases ordered by safety (zero-regression cases first, then by decreasing risk).

**P0: Predicate Chain Pushback** (SMALLEST SET FIRST) — ~35% of wins

| Aspect | Detail |
|---|---|
| Detect | Row counts flat through CTE chain, sharp drop at late filter. 2+ stage CTE chain + late predicate with columns available earlier. |
| Gates | Filter ratio >5:1 strong, 2:1–5:1 moderate if baseline >200ms, <2:1 skip. 1 fact = safe, 2 = careful, 3+ = STOP (0.50x). ROLLUP/WINDOW downstream: CAUTION (0.85x). CTE already filtered on this predicate: skip (0.71x). |
| Treatments | date_cte_isolate (12 wins, 1.34x avg), prefetch_fact_join (4 wins, 1.89x avg), multi_dimension_prefetch (3 wins, 1.55x avg), multi_date_range_cte (3 wins, 1.42x avg), shared_dimension_multi_channel (1 win, 1.40x), self_join_decomposition (1 win, 4.76x) |
| Failures | 0.0076x (3 dim CTE cross-join → Cartesian), 0.50x (3-fact join lock), 0.85x (ROLLUP blocked), 0.71x (over-decomposed) |

**P1: Repeated Scans of Same Table** (DON'T REPEAT WORK) — ZERO REGRESSIONS

| Aspect | Detail |
|---|---|
| Detect | N separate SEQ_SCAN nodes on same table, identical joins, different bucket filters. |
| Gates | Identical join structure across all subqueries, max 8 branches, COUNT/SUM/AVG/MIN/MAX only (not STDDEV/VARIANCE/PERCENTILE). |
| Treatments | single_pass_aggregation (8 wins, 1.88x avg), channel_bitmap_aggregation (1 win, 6.24x) |
| Failures | None observed. |

**P3: Aggregation After Join** (MINIMIZE ROWS TOUCHED) — ZERO REGRESSIONS

| Aspect | Detail |
|---|---|
| Detect | GROUP BY input rows >> distinct keys, aggregate node sits after join. |
| Gates | GROUP BY keys ⊇ join keys (CORRECTNESS). Reconstruct AVG from SUM/COUNT when pre-aggregating for ROLLUP. |
| Treatments | aggregate_pushdown, star_join_prefetch. 3 wins (1.3x–42.9x, avg 15.3x). |
| Failures | None observed. |

**P5: LEFT JOIN + NULL-Eliminating WHERE** (ARM THE OPTIMIZER) — ZERO REGRESSIONS

| Aspect | Detail |
|---|---|
| Detect | LEFT JOIN + WHERE on right-table column (proves right non-null). |
| Gates | No CASE WHEN IS NULL / COALESCE on right-table column. |
| Treatments | inner_join_conversion. 2 wins (1.9x–3.4x, avg 2.7x). |
| Failures | None observed. |

**P6: INTERSECT Materializing Both Sides** (SETS OVER LOOPS) — ZERO REGRESSIONS

| Aspect | Detail |
|---|---|
| Detect | INTERSECT between 10K+ row result sets. |
| Gates | Both sides >1K rows. |
| Treatments | intersect_to_exists, multi_intersect_exists_cte. 1 win (2.7x). Related: semi_join_exists (1.67x). |
| Failures | None observed. |

**P8: Window Functions in CTEs Before Join** (MINIMIZE ROWS TOUCHED) — ZERO REGRESSIONS

| Aspect | Detail |
|---|---|
| Detect | N WINDOW nodes inside CTEs, same ORDER BY key, CTEs then joined. |
| Gates | Not LAG/LEAD (depends on pre-join row order), not ROWS BETWEEN with specific frame. SUM() OVER() naturally skips NULLs. |
| Treatments | deferred_window_aggregation. 1 win (1.4x). |
| Failures | None observed. |

**P7: Self-Joined CTE Materialized for All Values** (SMALLEST SET FIRST)

| Aspect | Detail |
|---|---|
| Detect | CTE joined to itself with different WHERE per arm (e.g., period=1 vs period=2). |
| Gates | 2–4 discriminator values, MUST remove original combined CTE after splitting. |
| Treatments | self_join_decomposition (1 win, 4.76x), union_cte_split (2 wins, 1.72x avg), rollup_to_union_windowing (1 win, 2.47x) |
| Failures | 0.49x (orphaned CTE → double materialization), 0.68x (orphaned variant) |

**P2: Correlated Subquery Nested Loop** (SETS OVER LOOPS)

| Aspect | Detail |
|---|---|
| Detect | Nested loop, inner re-executes aggregate per outer row. If EXPLAIN shows hash join on correlation key → already decorrelated → STOP. |
| Gates | NEVER decorrelate EXISTS (0.34x, 0.14x — semi-join destroyed). Preserve ALL WHERE filters. Check if Phase 1 reduced outer to <1000 rows (nested loop may be fast enough). |
| Treatments | decorrelate (3 wins, 2.45x avg), composite_decorrelate_union (1 win, 2.42x) |
| Failures | 0.34x (semi-join destroyed), 0.71x (already decorrelated) |

**P9: Shared Subexpression Executed Multiple Times** (DON'T REPEAT WORK)

| Aspect | Detail |
|---|---|
| Detect | Identical subtrees with identical costs scanning same tables. HARD STOP: EXISTS/NOT EXISTS → NEVER materialize (0.14x). |
| Gates | NOT EXISTS, subquery is expensive (joins/aggregates), CTE must have WHERE. |
| Treatments | materialize_cte. 1 win (1.4x). |
| Failures | 0.14x (EXISTS materialized → semi-join destroyed), 0.54x (correlated EXISTS pairs broken) |

**P4: Cross-Column OR Forcing Full Scan** (MINIMIZE ROWS TOUCHED) — HIGHEST VARIANCE

| Aspect | Detail |
|---|---|
| Detect | Single scan, OR across DIFFERENT columns, 70%+ rows discarded. CRITICAL: same column in all OR arms → STOP (engine handles natively). |
| Gates | Max 3 branches, cross-column only, no self-join, no nested OR (multiplicative expansion). |
| Treatments | or_to_union. 4 wins (1.4x–6.3x, avg 3.1x). |
| Failures | 0.23x (9 branches from nested OR), 0.41x (nested OR expansion), 0.59x (same-col split), 0.51x (self-join re-executed per branch) |

---

## PRUNING GUIDE

| Plan shows | Skip |
|---|---|
| No nested loops | P2 (decorrelation) |
| Each table appears once | P1 (repeated scans) |
| No LEFT JOIN | P5 (INNER conversion) |
| No OR predicates | P4 (OR decomposition) |
| No GROUP BY | P3 (aggregate pushdown) |
| No WINDOW/OVER | P8 (deferred window) |
| No INTERSECT/EXCEPT | P6 (set rewrite) |
| Baseline < 50ms | ALL CTE-based transforms |
| Row counts monotonically decreasing | P0 (predicate pushback) |

## REGRESSION REGISTRY

| Severity | Transform | Result | Root cause |
|----------|-----------|--------|------------|
| CATASTROPHIC | dimension_cte_isolate | 0.0076x | Cross-joined 3 dim CTEs: Cartesian product |
| CATASTROPHIC | materialize_cte | 0.14x | Materialized EXISTS → semi-join destroyed |
| SEVERE | or_to_union | 0.23x | 9 UNION branches from nested OR |
| SEVERE | decorrelate | 0.34x | LEFT JOIN was already semi-join |
| MAJOR | union_cte_split | 0.49x | Original CTE kept → double materialization |
| MAJOR | date_cte_isolate | 0.50x | 3-way fact join locked optimizer order |
| MAJOR | or_to_union | 0.51x | Self-join re-executed per branch |
| MAJOR | semantic_rewrite | 0.54x | Correlated EXISTS pairs broken |
| MODERATE | or_to_union | 0.59x | Split same-column OR |
| MODERATE | union_cte_split | 0.68x | Original CTE kept alongside split |
| MODERATE | decorrelate | 0.71x | Pre-aggregated ALL stores when only subset needed |
| MODERATE | prefetch_fact_join | 0.78x | 3rd cascading CTE chain |
| MINOR | multi_dimension_prefetch | 0.77x | Forced suboptimal join order |
| MINOR | date_cte_isolate | 0.85x | CTE blocked ROLLUP pushdown |


## Worker Routing

Your targets will be routed to specialized workers:
- **W1 "Reducer"** (Families A, D): Cardinality reduction — early filtering, set operations
- **W2 "Unnester"** (Families B, C): Decorrelation, aggregation pushdown
- **W3 "Builder"** (Families F, E): Join restructuring, materialization/prefetch
- **W4 "Wildcard"** (Dynamic): Deep specialist — your **#1 target** gets maximum effort

The highest-relevance target always goes to W4. Design diverse targets across worker roles for maximum coverage.


## Your Task

Analyze this query against the 6 families above.

Identify the **primary bottleneck**. Only provide secondary targets if they are distinct and high-confidence. Quality > Quantity.

For each target (1 to 4):
1. Describe the bottleneck hypothesis
2. Design a TARGET IR node map showing what the optimized query SHOULD look like
3. Score relevance (0.0–1.0)
4. Recommend which gold example(s) a code-generation worker should use as reference


**Output format**:

```json
[
  {
    "family": "B",
    "transform": "shared_scan_decorrelate",
    "target_id": "t1",
    "relevance_score": 0.95,
    "hypothesis": "Correlated scalar subquery re-scans web_sales per row. Shared-scan variant: inner=outer table with same date filter.",
    "target_ir": "S0 [SELECT]\n  CTE: common_scan  (via Q1)\n    FROM: web_sales, date_dim\n    WHERE: d_date BETWEEN ... AND d_date_sk = ws_sold_date_sk\n  CTE: thresholds  (via Q2)\n    FROM: common_scan\n    GROUP BY: ws_item_sk\n  MAIN QUERY (via Q0)\n    FROM: common_scan cs, item, thresholds t\n    WHERE: i_manufact_id = 320 AND ... AND cs.ws_ext_discount_amt > t.threshold\n    ORDER BY: sum(ws_ext_discount_amt)",
    "recommended_examples": ["sf_shared_scan_decorrelate"]
  }
]
```

**Rules**:
- target_ir must follow the IR node map format (same as Section 4)
- target_ir describes the STRUCTURAL SHAPE of the optimized query (CTE names, FROM tables, WHERE conditions, GROUP BY, ORDER BY)
- recommended_examples: list gold example IDs the worker should use as reference patch template
- Each target should represent a DIFFERENT optimization strategy
- Rank by relevance_score (highest first)
- Output up to 4 targets

After JSON, provide analysis:

## Analysis
For each available family, explain relevance (HIGH / MEDIUM / LOW) in 1-2 sentences.
**Chosen families**: [list]
**Confidence**: High/Medium/Low
