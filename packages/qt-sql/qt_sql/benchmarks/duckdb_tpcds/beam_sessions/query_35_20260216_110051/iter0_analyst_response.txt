## Optimization Targets

```json
[
  {
    "family": "B",
    "transform": "shared_scan_decorrelate",
    "target_id": "t1",
    "relevance_score": 0.95,
    "hypothesis": "Correlated EXISTS subqueries re-execute expensive date_dim joins for each customer row. Precompute sales-validated customers once.",
    "target_ir": "S0 [SELECT]\n  CTE: date_filter  (via CTE_Q_S0_date_filter)\n    FROM: date_dim\n    WHERE: d_year=2001 AND d_qoy<4\n  CTE: sales_customers  (via CTE_Q_S0_sales_customers)\n    FROM: (\n        SELECT ss_customer_sk AS customer_sk FROM store_sales, date_filter WHERE ss_sold_date_sk = d_date_sk\n        UNION\n        SELECT ws_bill_customer_sk AS customer_sk FROM web_sales, date_filter WHERE ws_sold_date_sk = d_date_sk\n        UNION\n        SELECT cs_ship_customer_sk AS customer_sk FROM catalog_sales, date_filter WHERE cs_sold_date_sk = d_date_sk\n    )\n  MAIN QUERY (via Q_S0)\n    FROM: customer c\n    INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk\n    INNER JOIN customer_demographics cd ON cd_demo_sk = c.c_current_cdemo_sk\n    INNER JOIN sales_customers sc ON sc.customer_sk = c.c_customer_sk\n    GROUP BY: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count\n    ORDER BY: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count",
    "recommended_examples": ["decorrelate"]
  },
  {
    "family": "E",
    "transform": "date_dim_prefetch",
    "target_id": "t2",
    "relevance_score": 0.85,
    "hypothesis": "Repeated date_dim scans with identical filters (d_year=2001, d_qoy<4) across 3 subqueries. Materialize once.",
    "target_ir": "S0 [SELECT]\n  CTE: date_filter  (via CTE_Q_S0_date_filter)\n    FROM: date_dim\n    WHERE: d_year=2001 AND d_qoy<4\n  MAIN QUERY (via Q_S0)\n    FROM: customer c, customer_address ca, customer_demographics cd\n    WHERE: c.c_current_addr_sk = ca.ca_address_sk \n      AND cd_demo_sk = c.c_current_cdemo_sk\n      AND EXISTS (SELECT 1 FROM store_sales, date_filter WHERE ...)\n      AND (EXISTS (SELECT 1 FROM web_sales, date_filter WHERE ...) \n           OR EXISTS (SELECT 1 FROM catalog_sales, date_filter WHERE ...))\n    GROUP BY: ...",
    "recommended_examples": ["multi_dimension_prefetch"]
  },
  {
    "family": "F",
    "transform": "explicit_join_conversion",
    "target_id": "t3",
    "relevance_score": 0.75,
    "hypothesis": "Comma-join obscures join dependencies. Convert to explicit INNER JOINs for better predicate pushdown.",
    "target_ir": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: customer c\n    INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk\n    INNER JOIN customer_demographics cd ON cd_demo_sk = c.c_current_cdemo_sk\n    WHERE: EXISTS (...) AND (EXISTS (...) OR EXISTS (...))\n    GROUP BY: ...",
    "recommended_examples": ["inner_join_conversion"]
  }
]
```

## Analysis

### Family Relevance Assessment
1. **B (Decorrelation)**: HIGH  
Correlated EXISTS subqueries force re-execution of expensive sales-date joins per customer row. The plan shows DELIM_SCAN operations confirming correlation overhead. Precomputing validated customers via UNION is optimal.

2. **E (Materialization/Prefetch)**: HIGH  
Identical date_dim filters (d_year=2001, d_qoy<4) appear in 3 subqueries. Materializing the 274 filtered rows once avoids redundant scans.

3. **F (Join Transform)**: MEDIUM  
Comma-joins obscure join dependencies. Explicit INNER JOIN syntax helps the optimizer push predicates earlier.

4. **A (Early Filtering)**: LOW  
Date_dim filters are already pushed into subqueries. No late-applied dimension filters found.

5. **C (Aggregation Pushdown)**: LOW  
Grouping happens after dimension joins with no intermediate aggregation opportunities.

6. **D (Set Operations)**: LOW  
No INTERSECT/UNION patterns. EXISTS already handles OR-branches efficiently post-decorrelation.

**Chosen families**: B, E, F  
**Confidence**: High (plan shows DELIM_SCAN + repeated date_dim scans)