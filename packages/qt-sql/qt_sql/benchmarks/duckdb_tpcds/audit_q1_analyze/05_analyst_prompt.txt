You are an expert database performance analyst. Your job is to deeply analyze a slow SQL query, identify the root cause of its performance problems, and propose specific structural changes.

You follow a rigorous methodology: understand the structure, profile the costs, identify the mechanism (not just the symptom), propose changes with correctness reasoning, and learn from past failures.

## Query: query_1
## Dialect: duckdb

```sql
/* start query 1 in stream 0 using template query1.tpl */
WITH customer_total_return AS (
  SELECT
    sr_customer_sk AS ctr_customer_sk,
    sr_store_sk AS ctr_store_sk,
    SUM(SR_FEE) AS ctr_total_return
  FROM store_returns, date_dim
  WHERE
    sr_returned_date_sk = d_date_sk AND d_year = 2000
  GROUP BY
    sr_customer_sk,
    sr_store_sk
)
SELECT
  c_customer_id
FROM customer_total_return AS ctr1, store, customer
WHERE
  ctr1.ctr_total_return > (
    SELECT
      AVG(ctr_total_return) * 1.2
    FROM customer_total_return AS ctr2
    WHERE
      ctr1.ctr_store_sk = ctr2.ctr_store_sk
  )
  AND s_store_sk = ctr1.ctr_store_sk
  AND s_state = 'SD'
  AND ctr1.ctr_customer_sk = c_customer_sk
ORDER BY
  c_customer_id
LIMIT 100
```

## Query Structure (DAG)

### 1. customer_total_return
**Role**: CTE (Definition Order: 0)
**Stats**: 85% Cost | ~557k rows
**Flags**: GROUP_BY
**Outputs**: [ctr_customer_sk, ctr_store_sk, ctr_total_return]
**Dependencies**: store_returns, date_dim (join)
**Joins**: sr_returned_date_sk = d_date_sk
**Filters**: d_year = 2000
**Operators**: SEQ_SCAN[store_returns], SEQ_SCAN[date_dim], HASH_GROUP_BY
**Key Logic (SQL)**:
```sql
SELECT
  sr_customer_sk AS ctr_customer_sk,
  sr_store_sk AS ctr_store_sk,
  SUM(SR_FEE) AS ctr_total_return
FROM store_returns, date_dim
WHERE
  sr_returned_date_sk = d_date_sk AND d_year = 2000
GROUP BY
  sr_customer_sk,
  sr_store_sk
```

### 2. main_query
**Role**: Root / Output (Definition Order: 1)
**Stats**: 13% Cost | ~539k rows processed → 100 rows output
**Flags**: GROUP_BY, CORRELATED_SUBQUERY(ctr1.ctr_store_sk = ctr2.ctr_store_sk), ORDER_BY, LIMIT(100)
**Outputs**: [c_customer_id] — ordered by c_customer_id ASC
**Dependencies**: customer_total_return AS ctr1 (join), store (join), customer (join), customer_total_return AS ctr2 (correlated subquery)
**Joins**: s_store_sk = ctr1.ctr_store_sk | ctr1.ctr_customer_sk = c_customer_sk
**Filters**: ctr1.ctr_total_return > AVG(ctr_total_return) * 1.2 (per store_sk) | s_state = 'SD'
**Operators**: SEQ_SCAN[customer], CTE_SCAN, SEQ_SCAN[store], COLUMN_DATA_SCAN, CTE_SCAN
**Key Logic (SQL)**:
```sql
SELECT
  c_customer_id
FROM customer_total_return AS ctr1, store, customer
WHERE
  ctr1.ctr_total_return > (
    SELECT
      AVG(ctr_total_return) * 1.2
    FROM customer_total_return AS ctr2
    WHERE
      ctr1.ctr_store_sk = ctr2.ctr_store_sk
  )
  AND s_store_sk = ctr1.ctr_store_sk
  AND s_state = 'SD'
  AND ctr1.ctr_customer_sk = c_customer_sk
ORDER BY
  c_customer_id
LIMIT 100
```

### Edges
- customer_total_return → main_query
- customer_total_return → main_query


## Reference Examples

**FAISS selected (by structural similarity):** decorrelate, materialize_cte, union_cte_split

## Your Task

Analyze this query following these steps IN ORDER:

### 1. STRUCTURAL BREAKDOWN
For each CTE/subquery/block, explain in 1-2 sentences:
- What it computes (in plain language)
- What tables it reads and approximately how many rows
- What it outputs (cardinality estimate)

### 2. BOTTLENECK IDENTIFICATION
Using the DAG costs above, identify the dominant cost center.
Don't just name it — explain the MECHANISM:
- Is it a full table scan that could be filtered?
- Is it a sort for a window function that could be deferred?
- Is it a hash join on a large build side that could be pre-filtered?
- Is it scanning the same table multiple times when once would suffice?

### 3. PROPOSED OPTIMIZATION
Propose 1-3 specific structural changes. For EACH one:
- **What**: Exactly what to change (e.g., 'merge CTEs X and Y into one scan')
- **Why**: The performance mechanism (e.g., 'eliminates a 28M-row rescan of store_sales')
- **Risk**: What semantic constraint could break (e.g., 'the HAVING filter must be preserved')
- **Estimated impact**: minor / moderate / significant

### 5. RECOMMENDED STRATEGY
Synthesize everything into a single recommended optimization approach.
Be specific enough that another engineer could implement it from your description.
