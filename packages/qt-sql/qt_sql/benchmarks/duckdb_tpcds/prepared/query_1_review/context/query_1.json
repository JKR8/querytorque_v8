{
  "explain_plan_text": "Total execution time: 253ms\n\nCTE [0 rows, 5.2ms, 2%]\n  HASH_GROUP_BY [539K rows, 124.6ms, 49%]\n    HASH_JOIN INNER on sr_returned_date_sk = d_date_sk [558K rows, 5.8ms, 2%]\n      SEQ_SCAN  store_returns [558K of 69.1M rows, 23.7ms, 9%]\n      FILTER [366 rows]\n        SEQ_SCAN  date_dim [366 of 73K rows, 0.1ms]  Filters: d_year=2000\n  TOP_N [100 rows, 5.0ms, 2%]\n    FILTER [62K rows, 5.1ms, 2%]\n      LEFT_DELIM_JOIN LEFT on ctr_store_sk IS NOT DISTINCT FROM ctr_store_sk [0 rows, 6.9ms, 3%]\n        HASH_JOIN INNER on c_customer_sk = ctr_customer_sk [158K rows, 24.6ms, 10%]\n          SEQ_SCAN  customer [500K of 2.5M rows, 6.2ms, 2%]\n          HASH_JOIN INNER on ctr_store_sk = s_store_sk [158K rows, 2.9ms, 1%]\n            CTE_SCAN [539K rows, 1.8ms]\n            SEQ_SCAN  store [35 of 102 rows]  Filters: s_state='SD'\n        HASH_JOIN LEFT on ctr_store_sk IS NOT DISTINCT FROM ctr_store_sk [158K rows, 14.8ms, 6%]\n          HASH_GROUP_BY [15 rows, 15.2ms, 6%]\n            HASH_JOIN INNER on ctr_store_sk = ctr_store_sk [158K rows, 3.7ms, 1%]\n              CTE_SCAN [539K rows, 1.4ms]\n              DELIM_SCAN [0 rows]\n        HASH_GROUP_BY [15 rows, 1.0ms]",
  "plan_scanner_text": null,
  "semantic_intents": {
    "query_id": "q1",
    "query_intent": "Find South Dakota customers whose total 2000 store-return fees at a given store are more than 120% of that store's average customer return total, and list the matching customer IDs in sorted order.",
    "dag_nodes": [
      {
        "node_id": "customer_total_return",
        "node_type": "cte",
        "depth": 0,
        "intent": "Aggregate 2000 store returns to one row per (customer, store), summing return fees as each customer's total return amount at that store."
      },
      {
        "node_id": "main_query",
        "node_type": "main",
        "depth": 1,
        "intent": "Compare each customer-store return total against 1.2x the same store's average return total, keep only South Dakota stores, join to customer, and output ordered customer IDs."
      }
    ]
  },
  "matched_examples": [
    {
      "id": "decorrelate",
      "name": "Decorrelate Subquery",
      "description": "Convert correlated subquery to separate CTE with GROUP BY, then JOIN",
      "verified_speedup": "2.92x",
      "principle": "Decorrelation: convert correlated subqueries to standalone CTEs with GROUP BY, then JOIN. Correlated subqueries re-execute per outer row; a pre-computed CTE executes once.",
      "example": {
        "opportunity": "DECORRELATE + PUSHDOWN",
        "input_slice": "[customer_total_return] CORRELATED:\nSELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(SR_FEE) AS ctr_total_return\nFROM store_returns, date_dim\nWHERE sr_returned_date_sk = d_date_sk AND d_year = 2000\nGROUP BY sr_customer_sk, sr_store_sk\n\n[main_query]:\nSELECT c_customer_id FROM customer_total_return ctr1, store, customer\nWHERE ctr1.ctr_total_return > (SELECT avg(ctr_total_return)*1.2 FROM customer_total_return ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk)\n  AND s_store_sk = ctr1.ctr_store_sk AND s_state = 'SD' AND ctr1.ctr_customer_sk = c_customer_sk\nORDER BY c_customer_id LIMIT 100",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "decorrelate",
              "nodes": {
                "filtered_returns": "SELECT sr.sr_customer_sk, sr.sr_store_sk, sr.sr_fee FROM store_returns sr JOIN date_dim d ON sr.sr_returned_date_sk = d.d_date_sk JOIN store s ON sr.sr_store_sk = s.s_store_sk WHERE d.d_year = 2000 AND s.s_state = 'SD'",
                "customer_total_return": "SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(sr_fee) AS ctr_total_return FROM filtered_returns GROUP BY sr_customer_sk, sr_store_sk",
                "store_avg_return": "SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_return_threshold FROM customer_total_return GROUP BY ctr_store_sk",
                "main_query": "SELECT c.c_customer_id FROM customer_total_return ctr1 JOIN store_avg_return sar ON ctr1.ctr_store_sk = sar.ctr_store_sk JOIN customer c ON ctr1.ctr_customer_sk = c.c_customer_sk WHERE ctr1.ctr_total_return > sar.avg_return_threshold ORDER BY c.c_customer_id LIMIT 100"
              },
              "invariants_kept": [
                "same result rows",
                "same ordering",
                "same column output"
              ],
              "expected_speedup": "2.90x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Decorrelation \u2014 convert correlated subqueries to standalone CTEs with GROUP BY, then JOIN. Correlated subqueries re-execute per outer row; a pre-computed CTE executes once. Here: push s_state='SD' filter early into first CTE, compute average as separate CTE with GROUP BY (not window function), then JOIN on the average threshold."
      },
      "original_sql": "with customer_total_return as\n(select sr_customer_sk as ctr_customer_sk\n,sr_store_sk as ctr_store_sk\n,sum(SR_FEE) as ctr_total_return\nfrom store_returns\n,date_dim\nwhere sr_returned_date_sk = d_date_sk\nand d_year =2000\ngroup by sr_customer_sk\n,sr_store_sk)\n select c_customer_id\nfrom customer_total_return ctr1\n,store\n,customer\nwhere ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2\nfrom customer_total_return ctr2\nwhere ctr1.ctr_store_sk = ctr2.ctr_store_sk)\nand s_store_sk = ctr1.ctr_store_sk\nand s_state = 'SD'\nand ctr1.ctr_customer_sk = c_customer_sk\norder by c_customer_id\n LIMIT 100;",
      "optimized_sql": "WITH filtered_returns AS (SELECT sr.sr_customer_sk, sr.sr_store_sk, sr.SR_FEE FROM store_returns AS sr JOIN date_dim AS d ON sr.sr_returned_date_sk = d.d_date_sk JOIN store AS s ON sr.sr_store_sk = s.s_store_sk WHERE d.d_year = 2000 AND s.s_state = 'SD'), customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(SR_FEE) AS ctr_total_return FROM filtered_returns GROUP BY sr_customer_sk, sr_store_sk), store_avg_return AS (SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_return_threshold FROM customer_total_return GROUP BY ctr_store_sk)\nSELECT c.c_customer_id FROM customer_total_return AS ctr1 JOIN store_avg_return AS sar ON ctr1.ctr_store_sk = sar.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c.c_customer_sk WHERE ctr1.ctr_total_return > sar.avg_return_threshold ORDER BY c.c_customer_id LIMIT 100;",
      "optimized_source": "kimi",
      "sf10_rows_match": true,
      "family": "B",
      "patch_plan": {
        "plan_id": "gold_duckdb_decorrelate",
        "dialect": "duckdb",
        "description": "Convert correlated subquery to separate CTE with GROUP BY, then JOIN",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_returns",
              "cte_query_sql": "SELECT sr.sr_customer_sk, sr.sr_store_sk, sr.SR_FEE FROM store_returns AS sr JOIN date_dim AS d ON sr.sr_returned_date_sk = d.d_date_sk JOIN store AS s ON sr.sr_store_sk = s.s_store_sk WHERE d.d_year = 2000 AND s.s_state = 'SD'"
            },
            "description": "Insert CTE 'filtered_returns' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "store_avg_return",
              "cte_query_sql": "SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_return_threshold FROM customer_total_return GROUP BY ctr_store_sk"
            },
            "description": "Insert CTE 'store_avg_return' for pre-aggregated computation"
          },
          {
            "step_id": "s3",
            "op": "replace_block_with_cte_pair",
            "target": {
              "by_node_id": "S0",
              "by_label": "customer_total_return"
            },
            "payload": {
              "sql_fragment": "customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(SR_FEE) AS ctr_total_return FROM filtered_returns GROUP BY sr_customer_sk, sr_store_sk)"
            },
            "description": "Replace CTE 'customer_total_return' body with optimized version"
          },
          {
            "step_id": "s4",
            "op": "replace_from",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "from_sql": "customer_total_return AS ctr1 JOIN store_avg_return AS sar ON ctr1.ctr_store_sk = sar.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c.c_customer_sk"
            },
            "description": "Replace comma-join FROM with explicit JOINs"
          },
          {
            "step_id": "s5",
            "op": "replace_where_predicate",
            "target": {
              "by_node_id": "S0",
              "by_anchor_hash": "e5b7485395ff5a80"
            },
            "payload": {
              "expr_sql": "ctr1.ctr_total_return > sar.avg_return_threshold"
            },
            "description": "Replace WHERE predicate with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)\n    FROM: store_returns, date_dim\n    WHERE [eb0f6bc97f7168d4]: sr_returned_date_sk = d_date_sk AND d_year = 2000\n    GROUP BY: sr_customer_sk, sr_store_sk\n  MAIN QUERY (via Q_S0)\n    FROM: customer_total_return ctr1, store, customer\n    WHERE [e5b7485395ff5a80]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WH...\n    ORDER BY: c_customer_id\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_returns  (via CTE_Q_S0_filtered_returns)\n    FROM: store_returns sr, date_dim d, store s\n    WHERE [e49579c0ddbdbdda]: d.d_year = 2000 AND s.s_state = 'SD'\n  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)\n    FROM: filtered_returns\n    GROUP BY: sr_customer_sk, sr_store_sk\n  CTE: store_avg_return  (via CTE_Q_S0_store_avg_return)\n    FROM: customer_total_return\n    GROUP BY: ctr_store_sk\n  MAIN QUERY (via Q_S0)\n    FROM: customer_total_return ctr1, store_avg_return sar, customer c\n    WHERE [0f5f48abeb70c147]: ctr1.ctr_total_return > sar.avg_return_threshold\n    ORDER BY: c.c_customer_id\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "decorrelate"
      ],
      "families": [
        "B"
      ],
      "gap_ids": [
        "CORRELATED_SUBQUERY_PARALYSIS"
      ],
      "_match_score": 0.947
    },
    {
      "id": "shared_dimension_multi_channel",
      "name": "Shared Dimension CTEs Across Multi-Channel Queries",
      "description": "Extract shared dimension filters (date, item, promotion) into CTEs when multiple channel CTEs (store/catalog/web) apply identical filters independently",
      "verified_speedup": "1.30x",
      "principle": "Shared Dimension Extraction: when multiple channel CTEs (store/catalog/web) apply identical dimension filters, extract those shared filters into one CTE and reference it from each channel. Avoids redundant dimension scans.",
      "example": {
        "opportunity": "DIMENSION_CTE_ISOLATE + PREFETCH_FACT_JOIN",
        "input_slice": "[ssr] type=cte:\nSELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, ...\nFROM store_sales LEFT OUTER JOIN store_returns ON (...), date_dim, store, item, promotion\nWHERE ss_sold_date_sk = d_date_sk\n  AND d_date BETWEEN '1998-08-28' AND '1998-08-28' + 30 days\n  AND ss_item_sk = i_item_sk AND i_current_price > 50\n  AND ss_promo_sk = p_promo_sk AND p_channel_tv = 'N'\nGROUP BY s_store_id\n\n[wsr] type=cte:\nSELECT web_site_id, SUM(ws_ext_sales_price) AS sales, ...\nFROM web_sales LEFT OUTER JOIN web_returns ON (...), date_dim, web_site, item, promotion\nWHERE ws_sold_date_sk = d_date_sk\n  AND d_date BETWEEN '1998-08-28' AND '1998-08-28' + 30 days\n  AND ws_item_sk = i_item_sk AND i_current_price > 50\n  AND ws_promo_sk = p_promo_sk AND p_channel_tv = 'N'\nGROUP BY web_site_id\n\n[csr] type=cte: (same pattern for catalog_sales)\n\n[main_query]: SELECT channel, id, SUM(sales), SUM(returns), SUM(profit)\nFROM (ssr UNION ALL csr UNION ALL wsr) GROUP BY ROLLUP(channel, id)",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "dimension_cte_isolate",
              "nodes": {
                "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' AS DATE) + INTERVAL '30' DAY)",
                "filtered_items": "SELECT i_item_sk FROM item WHERE i_current_price > 50",
                "filtered_promotions": "SELECT p_promo_sk FROM promotion WHERE p_channel_tv = 'N'",
                "prefiltered_store_sales": "SELECT ss_item_sk, ss_store_sk, ss_ticket_number, ss_ext_sales_price, ss_net_profit FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_items ON ss_item_sk = i_item_sk JOIN filtered_promotions ON ss_promo_sk = p_promo_sk",
                "prefiltered_web_sales": "SELECT ws_item_sk, ws_web_site_sk, ws_order_number, ws_ext_sales_price, ws_net_profit FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_items ON ws_item_sk = i_item_sk JOIN filtered_promotions ON ws_promo_sk = p_promo_sk",
                "ssr": "SELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, SUM(COALESCE(sr_return_amt, 0)) AS returns, SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit FROM prefiltered_store_sales LEFT OUTER JOIN store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number) JOIN store ON ss_store_sk = s_store_sk GROUP BY s_store_id",
                "wsr": "SELECT web_site_id, SUM(ws_ext_sales_price) AS sales, SUM(COALESCE(wr_return_amt, 0)) AS returns, SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit FROM prefiltered_web_sales LEFT OUTER JOIN web_returns ON (ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number) JOIN web_site ON ws_web_site_sk = web_site_sk GROUP BY web_site_id"
              },
              "invariants_kept": [
                "same result rows",
                "same ordering",
                "same column output",
                "same ROLLUP semantics"
              ],
              "expected_speedup": "1.30x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Shared Dimension Extraction \u2014 when multiple channel CTEs (store/catalog/web) apply identical dimension filters, extract those shared filters into common dimension CTEs and reference them from each channel. This eliminates redundant dimension scans across channels. Here: shared date, item, and promotion filters extracted once, then pre-joined with each channel's fact table. Only apply where join structure is straightforward."
      },
      "original_sql": "with ssr as\n (select  s_store_id as store_id,\n          sum(ss_ext_sales_price) as sales,\n          sum(coalesce(sr_return_amt, 0)) as \"returns\",\n          sum(ss_net_profit - coalesce(sr_net_loss, 0)) as profit\n  from store_sales left outer join store_returns on\n         (ss_item_sk = sr_item_sk and ss_ticket_number = sr_ticket_number),\n     date_dim,\n     store,\n     item,\n     promotion\n where ss_sold_date_sk = d_date_sk\n       and d_date between cast('1998-08-28' as date) \n                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)\n       and ss_store_sk = s_store_sk\n       and ss_item_sk = i_item_sk\n       and i_current_price > 50\n       and ss_promo_sk = p_promo_sk\n       and p_channel_tv = 'N'\n group by s_store_id)\n ,\n csr as\n (select  cp_catalog_page_id as catalog_page_id,\n          sum(cs_ext_sales_price) as sales,\n          sum(coalesce(cr_return_amount, 0)) as \"returns\",\n          sum(cs_net_profit - coalesce(cr_net_loss, 0)) as profit\n  from catalog_sales left outer join catalog_returns on\n         (cs_item_sk = cr_item_sk and cs_order_number = cr_order_number),\n     date_dim,\n     catalog_page,\n     item,\n     promotion\n where cs_sold_date_sk = d_date_sk\n       and d_date between cast('1998-08-28' as date)\n                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)\n        and cs_catalog_page_sk = cp_catalog_page_sk\n       and cs_item_sk = i_item_sk\n       and i_current_price > 50\n       and cs_promo_sk = p_promo_sk\n       and p_channel_tv = 'N'\ngroup by cp_catalog_page_id)\n ,\n wsr as\n (select  web_site_id,\n          sum(ws_ext_sales_price) as sales,\n          sum(coalesce(wr_return_amt, 0)) as \"returns\",\n          sum(ws_net_profit - coalesce(wr_net_loss, 0)) as profit\n  from web_sales left outer join web_returns on\n         (ws_item_sk = wr_item_sk and ws_order_number = wr_order_number),\n     date_dim,\n     web_site,\n     item,\n     promotion\n where ws_sold_date_sk = d_date_sk\n       and d_date between cast('1998-08-28' as date)\n                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)\n        and ws_web_site_sk = web_site_sk\n       and ws_item_sk = i_item_sk\n       and i_current_price > 50\n       and ws_promo_sk = p_promo_sk\n       and p_channel_tv = 'N'\ngroup by web_site_id)\n  select channel\n        , id\n        , sum(sales) as sales\n        , sum(\"returns\") as \"returns\"\n        , sum(profit) as profit\n from \n (select 'store channel' as channel\n        , 'store' || store_id as id\n        , sales\n        , \"returns\"\n        , profit\n from   ssr\n union all\n select 'catalog channel' as channel\n        , 'catalog_page' || catalog_page_id as id\n        , sales\n        , \"returns\"\n        , profit\n from  csr\n union all\n select 'web channel' as channel\n        , 'web_site' || web_site_id as id\n        , sales\n        , \"returns\"\n        , profit\n from   wsr\n ) x\n group by rollup (channel, id)\n order by channel\n         ,id\n LIMIT 100;",
      "optimized_sql": "WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' AS DATE) + INTERVAL '30' DAY)), filtered_items AS (SELECT i_item_sk FROM item WHERE i_current_price > 50), filtered_promotions AS (SELECT p_promo_sk FROM promotion WHERE p_channel_tv = 'N'), prefiltered_store_sales AS (SELECT ss_item_sk, ss_store_sk, ss_ticket_number, ss_ext_sales_price, ss_net_profit FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_items ON ss_item_sk = i_item_sk JOIN filtered_promotions ON ss_promo_sk = p_promo_sk), prefiltered_web_sales AS (SELECT ws_item_sk, ws_web_site_sk, ws_order_number, ws_ext_sales_price, ws_net_profit FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_items ON ws_item_sk = i_item_sk JOIN filtered_promotions ON ws_promo_sk = p_promo_sk), ssr AS (SELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, SUM(COALESCE(sr_return_amt, 0)) AS \"returns\", SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit FROM prefiltered_store_sales LEFT OUTER JOIN store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number) JOIN store ON ss_store_sk = s_store_sk GROUP BY s_store_id), wsr AS (SELECT web_site_id, SUM(ws_ext_sales_price) AS sales, SUM(COALESCE(wr_return_amt, 0)) AS \"returns\", SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit FROM prefiltered_web_sales LEFT OUTER JOIN web_returns ON (ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number) JOIN web_site ON ws_web_site_sk = web_site_sk GROUP BY web_site_id), csr AS (SELECT cp_catalog_page_id AS catalog_page_id, SUM(cs_ext_sales_price) AS sales, SUM(COALESCE(cr_return_amount, 0)) AS \"returns\", SUM(cs_net_profit - COALESCE(cr_net_loss, 0)) AS profit FROM catalog_sales LEFT OUTER JOIN catalog_returns ON (cs_item_sk = cr_item_sk AND cs_order_number = cr_order_number), date_dim, catalog_page, item, promotion WHERE cs_sold_date_sk = d_date_sk AND d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' AS DATE) + INTERVAL '30' DAY) AND cs_catalog_page_sk = cp_catalog_page_sk AND cs_item_sk = i_item_sk AND i_current_price > 50 AND cs_promo_sk = p_promo_sk AND p_channel_tv = 'N' GROUP BY cp_catalog_page_id)\nSELECT channel, id, SUM(sales) AS sales, SUM(\"returns\") AS \"returns\", SUM(profit) AS profit FROM (SELECT 'store channel' AS channel, 'store' || store_id AS id, sales, \"returns\", profit FROM ssr UNION ALL SELECT 'catalog channel' AS channel, 'catalog_page' || catalog_page_id AS id, sales, \"returns\", profit FROM csr UNION ALL SELECT 'web channel' AS channel, 'web_site' || web_site_id AS id, sales, \"returns\", profit FROM wsr) AS x GROUP BY ROLLUP (channel, id) ORDER BY channel, id LIMIT 100;",
      "optimized_source": "dsr1",
      "sf10_rows_match": true,
      "family": "A",
      "patch_plan": {
        "plan_id": "gold_duckdb_shared_dimension_multi_channel",
        "dialect": "duckdb",
        "description": "Extract shared dimension filters (date, item, promotion) into CTEs when multiple channel CTEs (store/catalog/web) apply identical filters independently",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_dates",
              "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' AS DATE) + INTERVAL '30' DAY)"
            },
            "description": "Insert CTE 'filtered_dates' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_items",
              "cte_query_sql": "SELECT i_item_sk FROM item WHERE i_current_price > 50"
            },
            "description": "Insert CTE 'filtered_items'"
          },
          {
            "step_id": "s3",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_promotions",
              "cte_query_sql": "SELECT p_promo_sk FROM promotion WHERE p_channel_tv = 'N'"
            },
            "description": "Insert CTE 'filtered_promotions'"
          },
          {
            "step_id": "s4",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "prefiltered_store_sales",
              "cte_query_sql": "SELECT ss_item_sk, ss_store_sk, ss_ticket_number, ss_ext_sales_price, ss_net_profit FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_items ON ss_item_sk = i_item_sk JOIN filtered_promotions ON ss_promo_sk = p_promo_sk"
            },
            "description": "Insert CTE 'prefiltered_store_sales' for date dimension filtering"
          },
          {
            "step_id": "s5",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "prefiltered_web_sales",
              "cte_query_sql": "SELECT ws_item_sk, ws_web_site_sk, ws_order_number, ws_ext_sales_price, ws_net_profit FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_items ON ws_item_sk = i_item_sk JOIN filtered_promotions ON ws_promo_sk = p_promo_sk"
            },
            "description": "Insert CTE 'prefiltered_web_sales' for date dimension filtering"
          },
          {
            "step_id": "s6",
            "op": "replace_block_with_cte_pair",
            "target": {
              "by_node_id": "S0",
              "by_label": "ssr"
            },
            "payload": {
              "sql_fragment": "ssr AS (SELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, SUM(COALESCE(sr_return_amt, 0)) AS \"returns\", SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit FROM prefiltered_store_sales LEFT OUTER JOIN store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number) JOIN store ON ss_store_sk = s_store_sk GROUP BY s_store_id)"
            },
            "description": "Replace CTE 'ssr' body with optimized version"
          },
          {
            "step_id": "s7",
            "op": "replace_block_with_cte_pair",
            "target": {
              "by_node_id": "S0",
              "by_label": "wsr"
            },
            "payload": {
              "sql_fragment": "wsr AS (SELECT web_site_id, SUM(ws_ext_sales_price) AS sales, SUM(COALESCE(wr_return_amt, 0)) AS \"returns\", SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit FROM prefiltered_web_sales LEFT OUTER JOIN web_returns ON (ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number) JOIN web_site ON ws_web_site_sk = web_site_sk GROUP BY web_site_id)"
            },
            "description": "Replace CTE 'wsr' body with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  CTE: ssr  (via CTE_Q_S0_ssr)\n    FROM: store_sales, store_returns, date_dim, store, item, promotion\n    WHERE [654f4839a48b9196]: ss_sold_date_sk = d_date_sk AND d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' ...\n    GROUP BY: s_store_id\n  CTE: csr  (via CTE_Q_S0_csr)\n    FROM: catalog_sales, catalog_returns, date_dim, catalog_page, item, promotion\n    WHERE [430cc821b3eef70d]: cs_sold_date_sk = d_date_sk AND d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' ...\n    GROUP BY: cp_catalog_page_id\n  CTE: wsr  (via CTE_Q_S0_wsr)\n    FROM: web_sales, web_returns, date_dim, web_site, item, promotion\n    WHERE [9c17bf543e5c9cb9]: ws_sold_date_sk = d_date_sk AND d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' ...\n    GROUP BY: web_site_id\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) x\n    ORDER BY: channel, id\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_dates  (via CTE_Q_S0_filtered_dates)\n    FROM: date_dim\n    WHERE [a4feef12e51b8318]: d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' AS DATE) + INTERVAL '30' DAY)\n  CTE: filtered_items  (via CTE_Q_S0_filtered_items)\n    FROM: item\n    WHERE [eda9d4f5d52c385c]: i_current_price > 50\n  CTE: filtered_promotions  (via CTE_Q_S0_filtered_promotions)\n    FROM: promotion\n    WHERE [f46abae93a7973ac]: p_channel_tv = 'N'\n  CTE: prefiltered_store_sales  (via CTE_Q_S0_prefiltered_store_sales)\n    FROM: store_sales, filtered_dates, filtered_items, filtered_promotions\n  CTE: prefiltered_web_sales  (via CTE_Q_S0_prefiltered_web_sales)\n    FROM: web_sales, filtered_dates, filtered_items, filtered_promotions\n  CTE: ssr  (via CTE_Q_S0_ssr)\n    FROM: prefiltered_store_sales, store_returns, store\n    GROUP BY: s_store_id\n  CTE: wsr  (via CTE_Q_S0_wsr)\n    FROM: prefiltered_web_sales, web_returns, web_site\n    GROUP BY: web_site_id\n  CTE: csr  (via CTE_Q_S0_csr)\n    FROM: catalog_sales, catalog_returns, date_dim, catalog_page, item, promotion\n    WHERE [430cc821b3eef70d]: cs_sold_date_sk = d_date_sk AND d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' ...\n    GROUP BY: cp_catalog_page_id\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) x\n    ORDER BY: channel, id\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "dimension_cte_isolate"
      ],
      "families": [
        "A"
      ],
      "gap_ids": [
        "CROSS_CTE_PREDICATE_BLINDNESS"
      ],
      "_match_score": 0.684
    },
    {
      "id": "date_cte_isolate",
      "name": "Date CTE Isolation",
      "description": "Extract date filtering into a separate CTE to enable predicate pushdown and reduce scans",
      "verified_speedup": "4.00x",
      "principle": "Dimension Isolation: extract small dimension lookups into CTEs so they materialize once and subsequent joins probe a tiny hash table instead of rescanning.",
      "example": {
        "opportunity": "DATE_CTE_ISOLATE + CATEGORY_AVG",
        "input_slice": "[main_query]:\nSELECT a.ca_state state, count(*) cnt\nFROM customer_address a, customer c, store_sales s, date_dim d, item i\nWHERE a.ca_address_sk = c.c_current_addr_sk\n  AND c.c_customer_sk = s.ss_customer_sk\n  AND s.ss_sold_date_sk = d.d_date_sk\n  AND s.ss_item_sk = i.i_item_sk\n  AND d.d_month_seq = (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2000 AND d_moy = 1)\n  AND i.i_current_price > 1.2 * (SELECT avg(j.i_current_price) FROM item j WHERE j.i_category = i.i_category)\nGROUP BY a.ca_state HAVING count(*) >= 10\nORDER BY cnt, a.ca_state LIMIT 100",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "date_cte_isolate",
              "nodes": {
                "target_month": "SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2000 AND d_moy = 1",
                "category_avg_price": "SELECT i_category, AVG(i_current_price) * 1.2 AS avg_threshold FROM item GROUP BY i_category",
                "filtered_dates": "SELECT d_date_sk FROM date_dim JOIN target_month ON d_month_seq = target_month.d_month_seq",
                "filtered_sales": "SELECT ss_customer_sk, ss_item_sk FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk",
                "main_query": "SELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address a JOIN customer c ON a.ca_address_sk = c.c_current_addr_sk JOIN filtered_sales s ON c.c_customer_sk = s.ss_customer_sk JOIN item i ON s.ss_item_sk = i.i_item_sk JOIN category_avg_price cap ON i.i_category = cap.i_category WHERE i.i_current_price > cap.avg_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100"
              },
              "invariants_kept": [
                "same result rows",
                "same ordering",
                "same column output",
                "same grouping and aggregation"
              ],
              "expected_speedup": "2.0x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Dimension Isolation \u2014 extract small dimension lookups into CTEs so they materialize once and subsequent joins probe a tiny hash table. Here: extract date month_seq subquery into CTE, extract category average into separate CTE with GROUP BY, then JOIN instead of correlated subquery. Each CTE is scanned once.",
        "when_not_to_use": "Do not use when the optimizer already pushes date predicates effectively (e.g., simple equality filters on date columns in self-joins). Do not decompose an already-efficient existing CTE into sub-CTEs \u2014 this adds materialization overhead without reducing scans. Caused 0.49x regression on an already-optimized date-pushdown case and 0.71x on an over-decomposed CTE case."
      },
      "original_sql": "select a.ca_state state, count(*) cnt\n from customer_address a\n     ,customer c\n     ,store_sales s\n     ,date_dim d\n     ,item i\n where       a.ca_address_sk = c.c_current_addr_sk\n \tand c.c_customer_sk = s.ss_customer_sk\n \tand s.ss_sold_date_sk = d.d_date_sk\n \tand s.ss_item_sk = i.i_item_sk\n \tand d.d_month_seq = \n \t     (select distinct (d_month_seq)\n \t      from date_dim\n               where d_year = 2002\n \t        and d_moy = 3 )\n \tand i.i_current_price > 1.2 * \n             (select avg(j.i_current_price) \n \t     from item j \n \t     where j.i_category = i.i_category)\n group by a.ca_state\n having count(*) >= 10\n order by cnt, a.ca_state\n LIMIT 100;",
      "optimized_sql": "WITH target_month AS (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3), category_avg AS (SELECT i_category, AVG(i_current_price) * 1.2 AS price_threshold FROM item GROUP BY i_category)\nSELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address AS a JOIN customer AS c ON a.ca_address_sk = c.c_current_addr_sk JOIN store_sales AS s ON c.c_customer_sk = s.ss_customer_sk JOIN date_dim AS d ON s.ss_sold_date_sk = d.d_date_sk JOIN target_month AS tm ON d.d_month_seq = tm.d_month_seq JOIN item AS i ON s.ss_item_sk = i.i_item_sk JOIN category_avg AS ca ON i.i_category = ca.i_category WHERE i.i_current_price > ca.price_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100;",
      "optimized_source": "kimi",
      "sf10_rows_match": true,
      "family": "A",
      "patch_plan": {
        "plan_id": "gold_duckdb_date_cte_isolate",
        "dialect": "duckdb",
        "description": "Extract date filtering into a separate CTE to enable predicate pushdown and reduce scans",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "target_month",
              "cte_query_sql": "SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3"
            },
            "description": "Insert CTE 'target_month' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "category_avg",
              "cte_query_sql": "SELECT i_category, AVG(i_current_price) * 1.2 AS price_threshold FROM item GROUP BY i_category"
            },
            "description": "Insert CTE 'category_avg' for pre-aggregated computation"
          },
          {
            "step_id": "s3",
            "op": "replace_from",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "from_sql": "customer_address AS a JOIN customer AS c ON a.ca_address_sk = c.c_current_addr_sk JOIN store_sales AS s ON c.c_customer_sk = s.ss_customer_sk JOIN date_dim AS d ON s.ss_sold_date_sk = d.d_date_sk JOIN target_month AS tm ON d.d_month_seq = tm.d_month_seq JOIN item AS i ON s.ss_item_sk = i.i_item_sk JOIN category_avg AS ca ON i.i_category = ca.i_category"
            },
            "description": "Replace comma-join FROM with explicit JOINs"
          },
          {
            "step_id": "s4",
            "op": "replace_where_predicate",
            "target": {
              "by_node_id": "S0",
              "by_anchor_hash": "2837aea03aa52676"
            },
            "payload": {
              "expr_sql": "i.i_current_price > ca.price_threshold"
            },
            "description": "Replace WHERE predicate with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: customer_address a, customer c, store_sales s, date_dim d, item i\n    WHERE [2837aea03aa52676]: a.ca_address_sk = c.c_current_addr_sk AND c.c_customer_sk = s.ss_customer_sk AND s.ss_sold_date_s...\n    GROUP BY: a.ca_state\n    ORDER BY: cnt, a.ca_state\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: target_month  (via CTE_Q_S0_target_month)\n    FROM: date_dim\n    WHERE [198e5f8f07395c48]: d_year = 2002 AND d_moy = 3\n  CTE: category_avg  (via CTE_Q_S0_category_avg)\n    FROM: item\n    GROUP BY: i_category\n  MAIN QUERY (via Q_S0)\n    FROM: customer_address a, customer c, store_sales s, date_dim d, target_month tm, item i, category_avg ca\n    WHERE [031e98036ebea62d]: i.i_current_price > ca.price_threshold\n    GROUP BY: a.ca_state\n    ORDER BY: cnt, a.ca_state\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "date_cte_isolate"
      ],
      "families": [
        "A"
      ],
      "gap_ids": [
        "CROSS_CTE_PREDICATE_BLINDNESS"
      ],
      "_match_score": 0.632
    },
    {
      "id": "deferred_window_aggregation",
      "name": "Deferred Window Aggregation",
      "description": "When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joined with FULL OUTER JOIN followed by another WINDOW pass for NULL carry-forward: defer the WINDOW out of the CTEs, join daily totals, then compute cumulative sums once on the joined result. SUM() OVER() naturally skips NULLs, eliminating the need for a separate MAX() carry-forward window.",
      "verified_speedup": "1.36x",
      "principle": "Deferred Aggregation: delay expensive operations (window functions) until after joins reduce the dataset. Computing window functions inside individual CTEs then joining is more expensive than joining first and computing windows once on the combined result.",
      "example": {
        "opportunity": "CONSOLIDATE WINDOW PASSES",
        "input_slice": "[web_v1] type=cte\nSELECT ws_item_sk AS item_sk, d_date,\n  SUM(SUM(ws_sales_price)) OVER (PARTITION BY ws_item_sk ORDER BY d_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cume_sales\nFROM web_sales, date_dim\nWHERE ws_sold_date_sk = d_date_sk AND d_month_seq BETWEEN 1216 AND 1216+11 AND ws_item_sk IS NOT NULL\nGROUP BY ws_item_sk, d_date\n\n[store_v1] type=cte\nSELECT ss_item_sk AS item_sk, d_date,\n  SUM(SUM(ss_sales_price)) OVER (PARTITION BY ss_item_sk ORDER BY d_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cume_sales\nFROM store_sales, date_dim\nWHERE ss_sold_date_sk = d_date_sk AND d_month_seq BETWEEN 1216 AND 1216+11 AND ss_item_sk IS NOT NULL\nGROUP BY ss_item_sk, d_date\n\n[main_query] type=main\nSELECT * FROM (\n  SELECT item_sk, d_date, web_sales, store_sales,\n    MAX(web_sales) OVER (PARTITION BY item_sk ORDER BY d_date ROWS UNBOUNDED PRECEDING) AS web_cumulative,\n    MAX(store_sales) OVER (PARTITION BY item_sk ORDER BY d_date ROWS UNBOUNDED PRECEDING) AS store_cumulative\n  FROM (\n    SELECT COALESCE(web.item_sk, store.item_sk) AS item_sk, COALESCE(web.d_date, store.d_date) AS d_date,\n      web.cume_sales AS web_sales, store.cume_sales AS store_sales\n    FROM web_v1 web FULL OUTER JOIN store_v1 store ON (web.item_sk = store.item_sk AND web.d_date = store.d_date)\n  ) x\n) y\nWHERE web_cumulative > store_cumulative ORDER BY item_sk, d_date LIMIT 100",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "deferred_window_aggregation",
              "nodes": {
                "web_daily": "SELECT ws_item_sk AS item_sk, d_date, SUM(ws_sales_price) AS daily_sales FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND d_month_seq BETWEEN 1216 AND 1216 + 11 AND ws_item_sk IS NOT NULL GROUP BY ws_item_sk, d_date",
                "store_daily": "SELECT ss_item_sk AS item_sk, d_date, SUM(ss_sales_price) AS daily_sales FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_month_seq BETWEEN 1216 AND 1216 + 11 AND ss_item_sk IS NOT NULL GROUP BY ss_item_sk, d_date",
                "main_query": "SELECT * FROM (SELECT COALESCE(web.item_sk, store.item_sk) AS item_sk, COALESCE(web.d_date, store.d_date) AS d_date, SUM(web.daily_sales) OVER (PARTITION BY COALESCE(web.item_sk, store.item_sk) ORDER BY COALESCE(web.d_date, store.d_date) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS web_cumulative, SUM(store.daily_sales) OVER (PARTITION BY COALESCE(web.item_sk, store.item_sk) ORDER BY COALESCE(web.d_date, store.d_date) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS store_cumulative FROM web_daily web FULL OUTER JOIN store_daily store ON web.item_sk = store.item_sk AND web.d_date = store.d_date) y WHERE web_cumulative > store_cumulative ORDER BY item_sk, d_date LIMIT 100"
              },
              "invariants_kept": [
                "same result rows",
                "same ordering",
                "same column output",
                "same cumulative semantics"
              ],
              "expected_speedup": "1.4x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Deferred Aggregation \u2014 delay expensive operations (window functions) until after joins reduce the dataset. Computing windows in CTEs before joining wastes work on rows that get filtered. Here: remove WINDOW from CTEs (keep only GROUP BY for daily totals), join the reduced results, then compute SUM() OVER() once on the joined output. Reduces 3 WINDOW passes to 1, and SUM() naturally skips NULLs from the FULL OUTER JOIN.",
        "when_not_to_use": "Do not use when the CTE window function is referenced by other consumers besides the final join (the cumulative value is needed elsewhere). Do not use when the window function is not a monotonically accumulating SUM - e.g., AVG, COUNT, or non-monotonic window functions require separate computation. Only applies when the join is FULL OUTER and the carry-forward window is MAX/LAST_VALUE over a cumulative sum."
      },
      "original_sql": "WITH web_v1 as (\nselect\n  ws_item_sk item_sk, d_date,\n  sum(sum(ws_sales_price))\n      over (partition by ws_item_sk order by d_date rows between unbounded preceding and current row) cume_sales\nfrom web_sales\n    ,date_dim\nwhere ws_sold_date_sk=d_date_sk\n  and d_month_seq between 1216 and 1216+11\n  and ws_item_sk is not NULL\ngroup by ws_item_sk, d_date),\nstore_v1 as (\nselect\n  ss_item_sk item_sk, d_date,\n  sum(sum(ss_sales_price))\n      over (partition by ss_item_sk order by d_date rows between unbounded preceding and current row) cume_sales\nfrom store_sales\n    ,date_dim\nwhere ss_sold_date_sk=d_date_sk\n  and d_month_seq between 1216 and 1216+11\n  and ss_item_sk is not NULL\ngroup by ss_item_sk, d_date)\n select *\nfrom (select item_sk\n     ,d_date\n     ,web_sales\n     ,store_sales\n     ,max(web_sales)\n         over (partition by item_sk order by d_date rows between unbounded preceding and current row) web_cumulative\n     ,max(store_sales)\n         over (partition by item_sk order by d_date rows between unbounded preceding and current row) store_cumulative\n     from (select case when web.item_sk is not null then web.item_sk else store.item_sk end item_sk\n                 ,case when web.d_date is not null then web.d_date else store.d_date end d_date\n                 ,web.cume_sales web_sales\n                 ,store.cume_sales store_sales\n           from web_v1 web full outer join store_v1 store on (web.item_sk = store.item_sk\n                                                          and web.d_date = store.d_date)\n          )x )y\nwhere web_cumulative > store_cumulative\norder by item_sk\n        ,d_date\n LIMIT 100;",
      "optimized_sql": "WITH filtered_dates AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1216 AND 1216 + 11), filtered_web_sales AS (SELECT ws_item_sk AS item_sk, d_date, ws_sales_price FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk WHERE NOT ws_item_sk IS NULL), filtered_store_sales AS (SELECT ss_item_sk AS item_sk, d_date, ss_sales_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk WHERE NOT ss_item_sk IS NULL), web_v1 AS (SELECT item_sk, d_date, SUM(SUM(ws_sales_price)) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS cume_sales FROM filtered_web_sales GROUP BY item_sk, d_date), store_v1 AS (SELECT item_sk, d_date, SUM(SUM(ss_sales_price)) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS cume_sales FROM filtered_store_sales GROUP BY item_sk, d_date)\nSELECT * FROM (SELECT item_sk, d_date, web_sales, store_sales, MAX(web_sales) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS web_cumulative, MAX(store_sales) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS store_cumulative FROM (SELECT CASE WHEN NOT web.item_sk IS NULL THEN web.item_sk ELSE store.item_sk END AS item_sk, CASE WHEN NOT web.d_date IS NULL THEN web.d_date ELSE store.d_date END AS d_date, web.cume_sales AS web_sales, store.cume_sales AS store_sales FROM web_v1 AS web FULL OUTER JOIN store_v1 AS store ON (web.item_sk = store.item_sk AND web.d_date = store.d_date)) AS x) AS y WHERE web_cumulative > store_cumulative ORDER BY item_sk, d_date LIMIT 100;",
      "optimized_source": "dsr1",
      "family": "C",
      "patch_plan": {
        "plan_id": "gold_duckdb_deferred_window_aggregation",
        "dialect": "duckdb",
        "description": "When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joined with FULL OUTER JOIN followed by another WINDOW pass for NULL carry-forward: defer the WINDOW out of the CTEs, join daily totals, then compute cumulative sums once on the joined result. SUM() OVER() naturally skips NULLs, eliminating the need for a separate MAX() carry-forward window.",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_dates",
              "cte_query_sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1216 AND 1216 + 11"
            },
            "description": "Insert CTE 'filtered_dates' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_web_sales",
              "cte_query_sql": "SELECT ws_item_sk AS item_sk, d_date, ws_sales_price FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk WHERE NOT ws_item_sk IS NULL"
            },
            "description": "Insert CTE 'filtered_web_sales' for date dimension filtering"
          },
          {
            "step_id": "s3",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_store_sales",
              "cte_query_sql": "SELECT ss_item_sk AS item_sk, d_date, ss_sales_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk WHERE NOT ss_item_sk IS NULL"
            },
            "description": "Insert CTE 'filtered_store_sales' for date dimension filtering"
          },
          {
            "step_id": "s4",
            "op": "replace_block_with_cte_pair",
            "target": {
              "by_node_id": "S0",
              "by_label": "web_v1"
            },
            "payload": {
              "sql_fragment": "web_v1 AS (SELECT item_sk, d_date, SUM(SUM(ws_sales_price)) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS cume_sales FROM filtered_web_sales GROUP BY item_sk, d_date)"
            },
            "description": "Replace CTE 'web_v1' body with optimized version"
          },
          {
            "step_id": "s5",
            "op": "replace_block_with_cte_pair",
            "target": {
              "by_node_id": "S0",
              "by_label": "store_v1"
            },
            "payload": {
              "sql_fragment": "store_v1 AS (SELECT item_sk, d_date, SUM(SUM(ss_sales_price)) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS cume_sales FROM filtered_store_sales GROUP BY item_sk, d_date)"
            },
            "description": "Replace CTE 'store_v1' body with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  CTE: web_v1  (via CTE_Q_S0_web_v1)\n    FROM: web_sales, date_dim\n    WHERE [24eee82fc5dd7bae]: ws_sold_date_sk = d_date_sk AND d_month_seq BETWEEN 1216 AND 1216 + 11 AND NOT ws_item_sk IS NULL\n    GROUP BY: ws_item_sk, d_date\n  CTE: store_v1  (via CTE_Q_S0_store_v1)\n    FROM: store_sales, date_dim\n    WHERE [e5a7dd3d284ba767]: ss_sold_date_sk = d_date_sk AND d_month_seq BETWEEN 1216 AND 1216 + 11 AND NOT ss_item_sk IS NULL\n    GROUP BY: ss_item_sk, d_date\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) y\n    WHERE [54e2ee130d548b22]: web_cumulative > store_cumulative\n    ORDER BY: item_sk, d_date\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_dates  (via CTE_Q_S0_filtered_dates)\n    FROM: date_dim\n    WHERE [b9a4e340dd13fc02]: d_month_seq BETWEEN 1216 AND 1216 + 11\n  CTE: filtered_web_sales  (via CTE_Q_S0_filtered_web_sales)\n    FROM: web_sales, filtered_dates\n    WHERE [613d08944b89c277]: NOT ws_item_sk IS NULL\n  CTE: filtered_store_sales  (via CTE_Q_S0_filtered_store_sales)\n    FROM: store_sales, filtered_dates\n    WHERE [5f21bb4218f0fbc0]: NOT ss_item_sk IS NULL\n  CTE: web_v1  (via CTE_Q_S0_web_v1)\n    FROM: filtered_web_sales\n    GROUP BY: item_sk, d_date\n  CTE: store_v1  (via CTE_Q_S0_store_v1)\n    FROM: filtered_store_sales\n    GROUP BY: item_sk, d_date\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) y\n    WHERE [54e2ee130d548b22]: web_cumulative > store_cumulative\n    ORDER BY: item_sk, d_date\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "deferred_window_aggregation"
      ],
      "families": [
        "C"
      ],
      "_match_score": 0.579
    },
    {
      "id": "intersect_to_exists",
      "name": "INTERSECT to EXISTS",
      "description": "Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join planning",
      "verified_speedup": "1.83x",
      "principle": "Semi-Join Short-Circuit: replace INTERSECT with EXISTS to avoid full materialization and sorting. INTERSECT must compute complete result sets before intersecting; EXISTS stops at the first match per row, enabling semi-join optimizations.",
      "example": {
        "opportunity": "INTERSECT_TO_EXISTS",
        "input_slice": "[cross_items] type=cte:\nSELECT i_item_sk AS ss_item_sk FROM item,\n  (SELECT iss.i_brand_id, iss.i_class_id, iss.i_category_id\n   FROM store_sales, item iss, date_dim d1\n   WHERE ss_item_sk = iss.i_item_sk AND ss_sold_date_sk = d1.d_date_sk AND d1.d_year BETWEEN 1999 AND 2001\n   INTERSECT\n   SELECT ics.i_brand_id, ics.i_class_id, ics.i_category_id\n   FROM catalog_sales, item ics, date_dim d2\n   WHERE cs_item_sk = ics.i_item_sk AND cs_sold_date_sk = d2.d_date_sk AND d2.d_year BETWEEN 1999 AND 2001\n   INTERSECT\n   SELECT iws.i_brand_id, iws.i_class_id, iws.i_category_id\n   FROM web_sales, item iws, date_dim d3\n   WHERE ws_item_sk = iws.i_item_sk AND ws_sold_date_sk = d3.d_date_sk AND d3.d_year BETWEEN 1999 AND 2001)\nWHERE i_brand_id = brand_id AND i_class_id = class_id AND i_category_id = category_id",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "intersect_to_exists",
              "nodes": {
                "cross_items_flat": "SELECT i.i_item_sk AS ss_item_sk FROM item i WHERE EXISTS (SELECT 1 FROM store_sales, item iss, date_dim d1 WHERE ss_item_sk = iss.i_item_sk AND ss_sold_date_sk = d1.d_date_sk AND d1.d_year BETWEEN 1999 AND 2001 AND iss.i_brand_id = i.i_brand_id AND iss.i_class_id = i.i_class_id AND iss.i_category_id = i.i_category_id) AND EXISTS (SELECT 1 FROM catalog_sales, item ics, date_dim d2 WHERE cs_item_sk = ics.i_item_sk AND cs_sold_date_sk = d2.d_date_sk AND d2.d_year BETWEEN 1999 AND 2001 AND ics.i_brand_id = i.i_brand_id AND ics.i_class_id = i.i_class_id AND ics.i_category_id = i.i_category_id) AND EXISTS (SELECT 1 FROM web_sales, item iws, date_dim d3 WHERE ws_item_sk = iws.i_item_sk AND ws_sold_date_sk = d3.d_date_sk AND d3.d_year BETWEEN 1999 AND 2001 AND iws.i_brand_id = i.i_brand_id AND iws.i_class_id = i.i_class_id AND iws.i_category_id = i.i_category_id)",
                "main_query": "SELECT ... FROM ... WHERE i_item_sk IN (SELECT ss_item_sk FROM cross_items_flat) ..."
              },
              "invariants_kept": [
                "same result rows",
                "same columns",
                "same grouping"
              ],
              "expected_speedup": "1.83x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Semi-Join Short-Circuit \u2014 replace INTERSECT with EXISTS to avoid full materialization and sorting. INTERSECT must compute complete result sets before intersecting; EXISTS stops at the first match per row, enabling semi-join optimizations. Here: convert three INTERSECT subqueries to EXISTS clauses, allowing the optimizer to short-circuit and use index-based semi-joins."
      },
      "original_sql": "with  cross_items as\n (select i_item_sk ss_item_sk\n from item,\n (select iss.i_brand_id brand_id\n     ,iss.i_class_id class_id\n     ,iss.i_category_id category_id\n from store_sales\n     ,item iss\n     ,date_dim d1\n where ss_item_sk = iss.i_item_sk\n   and ss_sold_date_sk = d1.d_date_sk\n   and d1.d_year between 2000 AND 2000 + 2\n intersect \n select ics.i_brand_id\n     ,ics.i_class_id\n     ,ics.i_category_id\n from catalog_sales\n     ,item ics\n     ,date_dim d2\n where cs_item_sk = ics.i_item_sk\n   and cs_sold_date_sk = d2.d_date_sk\n   and d2.d_year between 2000 AND 2000 + 2\n intersect\n select iws.i_brand_id\n     ,iws.i_class_id\n     ,iws.i_category_id\n from web_sales\n     ,item iws\n     ,date_dim d3\n where ws_item_sk = iws.i_item_sk\n   and ws_sold_date_sk = d3.d_date_sk\n   and d3.d_year between 2000 AND 2000 + 2)\n where i_brand_id = brand_id\n      and i_class_id = class_id\n      and i_category_id = category_id\n),\n avg_sales as\n (select avg(quantity*list_price) average_sales\n  from (select ss_quantity quantity\n             ,ss_list_price list_price\n       from store_sales\n           ,date_dim\n       where ss_sold_date_sk = d_date_sk\n         and d_year between 2000 and 2000 + 2\n       union all \n       select cs_quantity quantity \n             ,cs_list_price list_price\n       from catalog_sales\n           ,date_dim\n       where cs_sold_date_sk = d_date_sk\n         and d_year between 2000 and 2000 + 2 \n       union all\n       select ws_quantity quantity\n             ,ws_list_price list_price\n       from web_sales\n           ,date_dim\n       where ws_sold_date_sk = d_date_sk\n         and d_year between 2000 and 2000 + 2) x)\n  select channel, i_brand_id,i_class_id,i_category_id,sum(sales), sum(number_sales)\n from(\n       select 'store' channel, i_brand_id,i_class_id\n             ,i_category_id,sum(ss_quantity*ss_list_price) sales\n             , count(*) number_sales\n       from store_sales\n           ,item\n           ,date_dim\n       where ss_item_sk in (select ss_item_sk from cross_items)\n         and ss_item_sk = i_item_sk\n         and ss_sold_date_sk = d_date_sk\n         and d_year = 2000+2 \n         and d_moy = 11\n       group by i_brand_id,i_class_id,i_category_id\n       having sum(ss_quantity*ss_list_price) > (select average_sales from avg_sales)\n       union all\n       select 'catalog' channel, i_brand_id,i_class_id,i_category_id, sum(cs_quantity*cs_list_price) sales, count(*) number_sales\n       from catalog_sales\n           ,item\n           ,date_dim\n       where cs_item_sk in (select ss_item_sk from cross_items)\n         and cs_item_sk = i_item_sk\n         and cs_sold_date_sk = d_date_sk\n         and d_year = 2000+2 \n         and d_moy = 11\n       group by i_brand_id,i_class_id,i_category_id\n       having sum(cs_quantity*cs_list_price) > (select average_sales from avg_sales)\n       union all\n       select 'web' channel, i_brand_id,i_class_id,i_category_id, sum(ws_quantity*ws_list_price) sales , count(*) number_sales\n       from web_sales\n           ,item\n           ,date_dim\n       where ws_item_sk in (select ss_item_sk from cross_items)\n         and ws_item_sk = i_item_sk\n         and ws_sold_date_sk = d_date_sk\n         and d_year = 2000+2\n         and d_moy = 11\n       group by i_brand_id,i_class_id,i_category_id\n       having sum(ws_quantity*ws_list_price) > (select average_sales from avg_sales)\n ) y\n group by rollup (channel, i_brand_id,i_class_id,i_category_id)\n order by channel,i_brand_id,i_class_id,i_category_id\n LIMIT 100;",
      "optimized_sql": "WITH cross_items AS (SELECT i.i_item_sk AS ss_item_sk FROM item AS i WHERE EXISTS(SELECT 1 FROM store_sales, item AS iss, date_dim AS d1 WHERE ss_item_sk = iss.i_item_sk AND ss_sold_date_sk = d1.d_date_sk AND d1.d_year BETWEEN 2000 AND 2000 + 2 AND iss.i_brand_id = i.i_brand_id AND iss.i_class_id = i.i_class_id AND iss.i_category_id = i.i_category_id) AND EXISTS(SELECT 1 FROM catalog_sales, item AS ics, date_dim AS d2 WHERE cs_item_sk = ics.i_item_sk AND cs_sold_date_sk = d2.d_date_sk AND d2.d_year BETWEEN 2000 AND 2000 + 2 AND ics.i_brand_id = i.i_brand_id AND ics.i_class_id = i.i_class_id AND ics.i_category_id = i.i_category_id) AND EXISTS(SELECT 1 FROM web_sales, item AS iws, date_dim AS d3 WHERE ws_item_sk = iws.i_item_sk AND ws_sold_date_sk = d3.d_date_sk AND d3.d_year BETWEEN 2000 AND 2000 + 2 AND iws.i_brand_id = i.i_brand_id AND iws.i_class_id = i.i_class_id AND iws.i_category_id = i.i_category_id)), avg_sales AS (SELECT AVG(quantity * list_price) AS average_sales FROM (SELECT ss_quantity AS quantity, ss_list_price AS list_price FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2000 + 2 UNION ALL SELECT cs_quantity AS quantity, cs_list_price AS list_price FROM catalog_sales, date_dim WHERE cs_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2000 + 2 UNION ALL SELECT ws_quantity AS quantity, ws_list_price AS list_price FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2000 + 2) AS x)\nSELECT channel, i_brand_id, i_class_id, i_category_id, SUM(sales), SUM(number_sales) FROM (SELECT 'store' AS channel, i_brand_id, i_class_id, i_category_id, SUM(ss_quantity * ss_list_price) AS sales, COUNT(*) AS number_sales FROM store_sales, item, date_dim WHERE ss_item_sk IN (SELECT ss_item_sk FROM cross_items) AND ss_item_sk = i_item_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2000 + 2 AND d_moy = 11 GROUP BY i_brand_id, i_class_id, i_category_id HAVING SUM(ss_quantity * ss_list_price) > (SELECT average_sales FROM avg_sales) UNION ALL SELECT 'catalog' AS channel, i_brand_id, i_class_id, i_category_id, SUM(cs_quantity * cs_list_price) AS sales, COUNT(*) AS number_sales FROM catalog_sales, item, date_dim WHERE cs_item_sk IN (SELECT ss_item_sk FROM cross_items) AND cs_item_sk = i_item_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2000 + 2 AND d_moy = 11 GROUP BY i_brand_id, i_class_id, i_category_id HAVING SUM(cs_quantity * cs_list_price) > (SELECT average_sales FROM avg_sales) UNION ALL SELECT 'web' AS channel, i_brand_id, i_class_id, i_category_id, SUM(ws_quantity * ws_list_price) AS sales, COUNT(*) AS number_sales FROM web_sales, item, date_dim WHERE ws_item_sk IN (SELECT ss_item_sk FROM cross_items) AND ws_item_sk = i_item_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2000 + 2 AND d_moy = 11 GROUP BY i_brand_id, i_class_id, i_category_id HAVING SUM(ws_quantity * ws_list_price) > (SELECT average_sales FROM avg_sales)) AS y GROUP BY ROLLUP (channel, i_brand_id, i_class_id, i_category_id) ORDER BY channel, i_brand_id, i_class_id, i_category_id LIMIT 100;",
      "optimized_source": "dsr1",
      "sf10_rows_match": false,
      "family": "D",
      "patch_plan": {
        "plan_id": "gold_duckdb_intersect_to_exists",
        "dialect": "duckdb",
        "description": "Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join planning",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "replace_block_with_cte_pair",
            "target": {
              "by_node_id": "S0",
              "by_label": "cross_items"
            },
            "payload": {
              "sql_fragment": "cross_items AS (SELECT i.i_item_sk AS ss_item_sk FROM item AS i WHERE EXISTS(SELECT 1 FROM store_sales, item AS iss, date_dim AS d1 WHERE ss_item_sk = iss.i_item_sk AND ss_sold_date_sk = d1.d_date_sk AND d1.d_year BETWEEN 2000 AND 2000 + 2 AND iss.i_brand_id = i.i_brand_id AND iss.i_class_id = i.i_class_id AND iss.i_category_id = i.i_category_id) AND EXISTS(SELECT 1 FROM catalog_sales, item AS ics, date_dim AS d2 WHERE cs_item_sk = ics.i_item_sk AND cs_sold_date_sk = d2.d_date_sk AND d2.d_year BETWEEN 2000 AND 2000 + 2 AND ics.i_brand_id = i.i_brand_id AND ics.i_class_id = i.i_class_id AND ics.i_category_id = i.i_category_id) AND EXISTS(SELECT 1 FROM web_sales, item AS iws, date_dim AS d3 WHERE ws_item_sk = iws.i_item_sk AND ws_sold_date_sk = d3.d_date_sk AND d3.d_year BETWEEN 2000 AND 2000 + 2 AND iws.i_brand_id = i.i_brand_id AND iws.i_class_id = i.i_class_id AND iws.i_category_id = i.i_category_id))"
            },
            "description": "Replace CTE 'cross_items' body with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  CTE: cross_items  (via CTE_Q_S0_cross_items)\n    FROM: item, (subquery) \n    WHERE [3f561bc366ff68bb]: i_brand_id = brand_id AND i_class_id = class_id AND i_category_id = category_id\n  CTE: avg_sales  (via CTE_Q_S0_avg_sales)\n    FROM: (subquery) x\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) y\n    ORDER BY: channel, i_brand_id, i_class_id, i_category_id\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: cross_items  (via CTE_Q_S0_cross_items)\n    FROM: item i\n    WHERE [8094f2c0095034d2]: EXISTS(SELECT 1 FROM store_sales, item AS iss, date_dim AS d1 WHERE ss_item_sk = iss.i_item_sk AN...\n  CTE: avg_sales  (via CTE_Q_S0_avg_sales)\n    FROM: (subquery) x\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) y\n    ORDER BY: channel, i_brand_id, i_class_id, i_category_id\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "intersect_to_exists"
      ],
      "families": [
        "D"
      ],
      "_match_score": 0.579
    },
    {
      "id": "multi_intersect_exists_cte",
      "name": "Multi-INTERSECT to EXISTS with CTEs",
      "description": "Convert cascading INTERSECT operations into correlated EXISTS subqueries with pre-materialized date and channel CTEs",
      "verified_speedup": "2.39x",
      "example": {
        "opportunity": "INTERSECT_TO_EXISTS + DATE_CTE_ISOLATE + MATERIALIZE_CTE",
        "input_slice": "with cross_items as\n (select i_item_sk ss_item_sk from item,\n  (select iss.i_brand_id brand_id, iss.i_class_id class_id, iss.i_category_id category_id\n   from store_sales, item iss, date_dim d1\n   where ss_item_sk = iss.i_item_sk and ss_sold_date_sk = d1.d_date_sk\n     and d1.d_year between 2000 AND 2002\n   intersect\n   select ics.i_brand_id, ics.i_class_id, ics.i_category_id\n   from catalog_sales, item ics, date_dim d2\n   where cs_item_sk = ics.i_item_sk and cs_sold_date_sk = d2.d_date_sk\n     and d2.d_year between 2000 AND 2002\n   intersect\n   select iws.i_brand_id, iws.i_class_id, iws.i_category_id\n   from web_sales, item iws, date_dim d3\n   where ws_item_sk = iws.i_item_sk and ws_sold_date_sk = d3.d_date_sk\n     and d3.d_year between 2000 AND 2002)\n  where i_brand_id = brand_id and i_class_id = class_id and i_category_id = category_id)",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "intersect_to_exists",
              "nodes": {
                "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_year BETWEEN 2000 AND 2002",
                "cross_items": "SELECT i_item_sk AS ss_item_sk, i_brand_id, i_class_id, i_category_id FROM item WHERE EXISTS (SELECT 1 FROM store_sales JOIN item iss ON ss_item_sk = iss.i_item_sk JOIN filtered_dates d1 ON ss_sold_date_sk = d1.d_date_sk WHERE iss.i_brand_id = item.i_brand_id AND iss.i_class_id = item.i_class_id AND iss.i_category_id = item.i_category_id) AND EXISTS (SELECT 1 FROM catalog_sales JOIN item ics ON cs_item_sk = ics.i_item_sk JOIN filtered_dates d2 ON cs_sold_date_sk = d2.d_date_sk WHERE ics.i_brand_id = item.i_brand_id AND ics.i_class_id = item.i_class_id AND ics.i_category_id = item.i_category_id) AND EXISTS (SELECT 1 FROM web_sales JOIN item iws ON ws_item_sk = iws.i_item_sk JOIN filtered_dates d3 ON ws_sold_date_sk = d3.d_date_sk WHERE iws.i_brand_id = item.i_brand_id AND iws.i_class_id = item.i_class_id AND iws.i_category_id = item.i_category_id)"
              },
              "invariants_kept": [
                "same cross-channel items identified",
                "output columns unchanged"
              ],
              "expected_speedup": "2.39x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "INTERSECT materializes full intermediate result sets (brand_id, class_id, category_id triples) from each channel before intersecting. EXISTS with correlated predicates short-circuits early \u2014 once a matching row is found for each channel, processing stops. Pre-filtering date_dim into a CTE avoids repeated scans of the 73K-row date table.",
        "when_not_to_use": "Do not use when the INTERSECT operates on small result sets (< 1000 rows) where materialization cost is negligible. Also not applicable when the EXISTS correlation would be on non-indexed columns, as the correlated probe could be slower than the hash-based INTERSECT."
      },
      "original_sql": "with cross_items as\n (select i_item_sk ss_item_sk\n from item,\n (select iss.i_brand_id brand_id, iss.i_class_id class_id, iss.i_category_id category_id\n from store_sales, item iss, date_dim d1\n where ss_item_sk = iss.i_item_sk and ss_sold_date_sk = d1.d_date_sk\n   and d1.d_year between 2000 AND 2000 + 2\n intersect\n select ics.i_brand_id, ics.i_class_id, ics.i_category_id\n from catalog_sales, item ics, date_dim d2\n where cs_item_sk = ics.i_item_sk and cs_sold_date_sk = d2.d_date_sk\n   and d2.d_year between 2000 AND 2000 + 2\n intersect\n select iws.i_brand_id, iws.i_class_id, iws.i_category_id\n from web_sales, item iws, date_dim d3\n where ws_item_sk = iws.i_item_sk and ws_sold_date_sk = d3.d_date_sk\n   and d3.d_year between 2000 AND 2000 + 2)\n where i_brand_id = brand_id and i_class_id = class_id and i_category_id = category_id),\n avg_sales as\n (select avg(quantity*list_price) average_sales\n  from (select ss_quantity quantity, ss_list_price list_price from store_sales, date_dim where ss_sold_date_sk = d_date_sk and d_year between 2000 and 2000 + 2\n   union all select cs_quantity, cs_list_price from catalog_sales, date_dim where cs_sold_date_sk = d_date_sk and d_year between 2000 and 2000 + 2\n   union all select ws_quantity, ws_list_price from web_sales, date_dim where ws_sold_date_sk = d_date_sk and d_year between 2000 and 2000 + 2) x)\n select channel, i_brand_id, i_class_id, i_category_id, sum(sales), sum(number_sales)\n from (\n  select 'store' channel, i_brand_id, i_class_id, i_category_id, sum(ss_quantity*ss_list_price) sales, count(*) number_sales\n  from store_sales, item, date_dim\n  where ss_item_sk in (select ss_item_sk from cross_items) and ss_item_sk = i_item_sk and ss_sold_date_sk = d_date_sk and d_year = 2000+2 and d_moy = 11\n  group by i_brand_id, i_class_id, i_category_id\n  having sum(ss_quantity*ss_list_price) > (select average_sales from avg_sales)\n  union all\n  select 'catalog' channel, i_brand_id, i_class_id, i_category_id, sum(cs_quantity*cs_list_price) sales, count(*) number_sales\n  from catalog_sales, item, date_dim\n  where cs_item_sk in (select ss_item_sk from cross_items) and cs_item_sk = i_item_sk and cs_sold_date_sk = d_date_sk and d_year = 2000+2 and d_moy = 11\n  group by i_brand_id, i_class_id, i_category_id\n  having sum(cs_quantity*cs_list_price) > (select average_sales from avg_sales)\n  union all\n  select 'web' channel, i_brand_id, i_class_id, i_category_id, sum(ws_quantity*ws_list_price) sales, count(*) number_sales\n  from web_sales, item, date_dim\n  where ws_item_sk in (select ss_item_sk from cross_items) and ws_item_sk = i_item_sk and ws_sold_date_sk = d_date_sk and d_year = 2000+2 and d_moy = 11\n  group by i_brand_id, i_class_id, i_category_id\n  having sum(ws_quantity*ws_list_price) > (select average_sales from avg_sales)\n ) y\n group by rollup (channel, i_brand_id, i_class_id, i_category_id)\n order by channel, i_brand_id, i_class_id, i_category_id\n LIMIT 100;",
      "optimized_sql": "WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_year BETWEEN 2000 AND 2002), cross_items AS (SELECT i_item_sk AS ss_item_sk, i_brand_id, i_class_id, i_category_id FROM item WHERE EXISTS (SELECT 1 FROM store_sales JOIN item iss ON ss_item_sk = iss.i_item_sk JOIN filtered_dates d1 ON ss_sold_date_sk = d1.d_date_sk WHERE iss.i_brand_id = item.i_brand_id AND iss.i_class_id = item.i_class_id AND iss.i_category_id = item.i_category_id) AND EXISTS (SELECT 1 FROM catalog_sales JOIN item ics ON cs_item_sk = ics.i_item_sk JOIN filtered_dates d2 ON cs_sold_date_sk = d2.d_date_sk WHERE ics.i_brand_id = item.i_brand_id AND ics.i_class_id = item.i_class_id AND ics.i_category_id = item.i_category_id) AND EXISTS (SELECT 1 FROM web_sales JOIN item iws ON ws_item_sk = iws.i_item_sk JOIN filtered_dates d3 ON ws_sold_date_sk = d3.d_date_sk WHERE iws.i_brand_id = item.i_brand_id AND iws.i_class_id = item.i_class_id AND iws.i_category_id = item.i_category_id)), avg_sales AS (SELECT AVG(quantity * list_price) AS average_sales FROM (SELECT ss_quantity AS quantity, ss_list_price AS list_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk UNION ALL SELECT cs_quantity, cs_list_price FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk UNION ALL SELECT ws_quantity, ws_list_price FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk) x), nov2002_dates AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy = 11), store_sales_data AS (SELECT 'store' AS channel, i.i_brand_id, i.i_class_id, i.i_category_id, SUM(ss_quantity * ss_list_price) AS sales, COUNT(*) AS number_sales FROM store_sales ss JOIN item i ON ss.ss_item_sk = i.i_item_sk JOIN nov2002_dates nd ON ss.ss_sold_date_sk = nd.d_date_sk WHERE EXISTS (SELECT 1 FROM cross_items ci WHERE ci.ss_item_sk = ss.ss_item_sk) GROUP BY i.i_brand_id, i.i_class_id, i.i_category_id HAVING SUM(ss_quantity * ss_list_price) > (SELECT average_sales FROM avg_sales)), catalog_sales_data AS (SELECT 'catalog' AS channel, i.i_brand_id, i.i_class_id, i.i_category_id, SUM(cs_quantity * cs_list_price) AS sales, COUNT(*) AS number_sales FROM catalog_sales cs JOIN item i ON cs.cs_item_sk = i.i_item_sk JOIN nov2002_dates nd ON cs.cs_sold_date_sk = nd.d_date_sk WHERE EXISTS (SELECT 1 FROM cross_items ci WHERE ci.ss_item_sk = cs.cs_item_sk) GROUP BY i.i_brand_id, i.i_class_id, i.i_category_id HAVING SUM(cs_quantity * cs_list_price) > (SELECT average_sales FROM avg_sales)), web_sales_data AS (SELECT 'web' AS channel, i.i_brand_id, i.i_class_id, i.i_category_id, SUM(ws_quantity * ws_list_price) AS sales, COUNT(*) AS number_sales FROM web_sales ws JOIN item i ON ws.ws_item_sk = i.i_item_sk JOIN nov2002_dates nd ON ws.ws_sold_date_sk = nd.d_date_sk WHERE EXISTS (SELECT 1 FROM cross_items ci WHERE ci.ss_item_sk = ws.ws_item_sk) GROUP BY i.i_brand_id, i.i_class_id, i.i_category_id HAVING SUM(ws_quantity * ws_list_price) > (SELECT average_sales FROM avg_sales))\nSELECT channel, i_brand_id, i_class_id, i_category_id, SUM(sales) AS \"SUM(sales)\", SUM(number_sales) AS \"SUM(number_sales)\" FROM (SELECT * FROM store_sales_data UNION ALL SELECT * FROM catalog_sales_data UNION ALL SELECT * FROM web_sales_data) y GROUP BY ROLLUP(channel, i_brand_id, i_class_id, i_category_id) ORDER BY channel, i_brand_id, i_class_id, i_category_id LIMIT 100;",
      "optimized_source": "swarm_final_worker",
      "sf10_rows_match": true,
      "family": "D",
      "patch_plan": {
        "plan_id": "gold_duckdb_multi_intersect_exists_cte",
        "dialect": "duckdb",
        "description": "Convert cascading INTERSECT operations into correlated EXISTS subqueries with pre-materialized date and channel CTEs",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_dates",
              "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_year BETWEEN 2000 AND 2002"
            },
            "description": "Insert CTE 'filtered_dates' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "nov2002_dates",
              "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002 AND d_moy = 11"
            },
            "description": "Insert CTE 'nov2002_dates' for date dimension filtering"
          },
          {
            "step_id": "s3",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "store_sales_data",
              "cte_query_sql": "SELECT 'store' AS channel, i.i_brand_id, i.i_class_id, i.i_category_id, SUM(ss_quantity * ss_list_price) AS sales, COUNT(*) AS number_sales FROM store_sales AS ss JOIN item AS i ON ss.ss_item_sk = i.i_item_sk JOIN nov2002_dates AS nd ON ss.ss_sold_date_sk = nd.d_date_sk WHERE EXISTS(SELECT 1 FROM cross_items AS ci WHERE ci.ss_item_sk = ss.ss_item_sk) GROUP BY i.i_brand_id, i.i_class_id, i.i_category_id HAVING SUM(ss_quantity * ss_list_price) > (SELECT average_sales FROM avg_sales)"
            },
            "description": "Insert CTE 'store_sales_data' for pre-aggregated computation"
          },
          {
            "step_id": "s4",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "catalog_sales_data",
              "cte_query_sql": "SELECT 'catalog' AS channel, i.i_brand_id, i.i_class_id, i.i_category_id, SUM(cs_quantity * cs_list_price) AS sales, COUNT(*) AS number_sales FROM catalog_sales AS cs JOIN item AS i ON cs.cs_item_sk = i.i_item_sk JOIN nov2002_dates AS nd ON cs.cs_sold_date_sk = nd.d_date_sk WHERE EXISTS(SELECT 1 FROM cross_items AS ci WHERE ci.ss_item_sk = cs.cs_item_sk) GROUP BY i.i_brand_id, i.i_class_id, i.i_category_id HAVING SUM(cs_quantity * cs_list_price) > (SELECT average_sales FROM avg_sales)"
            },
            "description": "Insert CTE 'catalog_sales_data' for pre-aggregated computation"
          },
          {
            "step_id": "s5",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "web_sales_data",
              "cte_query_sql": "SELECT 'web' AS channel, i.i_brand_id, i.i_class_id, i.i_category_id, SUM(ws_quantity * ws_list_price) AS sales, COUNT(*) AS number_sales FROM web_sales AS ws JOIN item AS i ON ws.ws_item_sk = i.i_item_sk JOIN nov2002_dates AS nd ON ws.ws_sold_date_sk = nd.d_date_sk WHERE EXISTS(SELECT 1 FROM cross_items AS ci WHERE ci.ss_item_sk = ws.ws_item_sk) GROUP BY i.i_brand_id, i.i_class_id, i.i_category_id HAVING SUM(ws_quantity * ws_list_price) > (SELECT average_sales FROM avg_sales)"
            },
            "description": "Insert CTE 'web_sales_data' for pre-aggregated computation"
          },
          {
            "step_id": "s6",
            "op": "replace_block_with_cte_pair",
            "target": {
              "by_node_id": "S0",
              "by_label": "cross_items"
            },
            "payload": {
              "sql_fragment": "cross_items AS (SELECT i_item_sk AS ss_item_sk, i_brand_id, i_class_id, i_category_id FROM item WHERE EXISTS(SELECT 1 FROM store_sales JOIN item AS iss ON ss_item_sk = iss.i_item_sk JOIN filtered_dates AS d1 ON ss_sold_date_sk = d1.d_date_sk WHERE iss.i_brand_id = item.i_brand_id AND iss.i_class_id = item.i_class_id AND iss.i_category_id = item.i_category_id) AND EXISTS(SELECT 1 FROM catalog_sales JOIN item AS ics ON cs_item_sk = ics.i_item_sk JOIN filtered_dates AS d2 ON cs_sold_date_sk = d2.d_date_sk WHERE ics.i_brand_id = item.i_brand_id AND ics.i_class_id = item.i_class_id AND ics.i_category_id = item.i_category_id) AND EXISTS(SELECT 1 FROM web_sales JOIN item AS iws ON ws_item_sk = iws.i_item_sk JOIN filtered_dates AS d3 ON ws_sold_date_sk = d3.d_date_sk WHERE iws.i_brand_id = item.i_brand_id AND iws.i_class_id = item.i_class_id AND iws.i_category_id = item.i_category_id))"
            },
            "description": "Replace CTE 'cross_items' body with optimized version"
          },
          {
            "step_id": "s7",
            "op": "replace_block_with_cte_pair",
            "target": {
              "by_node_id": "S0",
              "by_label": "avg_sales"
            },
            "payload": {
              "sql_fragment": "avg_sales AS (SELECT AVG(quantity * list_price) AS average_sales FROM (SELECT ss_quantity AS quantity, ss_list_price AS list_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk UNION ALL SELECT cs_quantity, cs_list_price FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk UNION ALL SELECT ws_quantity, ws_list_price FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk) AS x)"
            },
            "description": "Replace CTE 'avg_sales' body with optimized version"
          },
          {
            "step_id": "s8",
            "op": "replace_from",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "from_sql": "(SELECT * FROM store_sales_data UNION ALL SELECT * FROM catalog_sales_data UNION ALL SELECT * FROM web_sales_data) AS y"
            },
            "description": "Replace FROM clause with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  CTE: cross_items  (via CTE_Q_S0_cross_items)\n    FROM: item, (subquery) \n    WHERE [3f561bc366ff68bb]: i_brand_id = brand_id AND i_class_id = class_id AND i_category_id = category_id\n  CTE: avg_sales  (via CTE_Q_S0_avg_sales)\n    FROM: (subquery) x\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) y\n    ORDER BY: channel, i_brand_id, i_class_id, i_category_id\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_dates  (via CTE_Q_S0_filtered_dates)\n    FROM: date_dim\n    WHERE [cb445fc057c7c479]: d_year BETWEEN 2000 AND 2002\n  CTE: cross_items  (via CTE_Q_S0_cross_items)\n    FROM: item\n    WHERE [e24a3609eb5cc197]: EXISTS(SELECT 1 FROM store_sales JOIN item AS iss ON ss_item_sk = iss.i_item_sk JOIN filtered_dat...\n  CTE: avg_sales  (via CTE_Q_S0_avg_sales)\n    FROM: (subquery) x\n  CTE: nov2002_dates  (via CTE_Q_S0_nov2002_dates)\n    FROM: date_dim\n    WHERE [b7c24f0f8c3d8fdd]: d_year = 2002 AND d_moy = 11\n  CTE: store_sales_data  (via CTE_Q_S0_store_sales_data)\n    FROM: store_sales ss, item i, nov2002_dates nd\n    WHERE [624098a99e864725]: EXISTS(SELECT 1 FROM cross_items AS ci WHERE ci.ss_item_sk = ss.ss_item_sk)\n    GROUP BY: i.i_brand_id, i.i_class_id, i.i_category_id\n  CTE: catalog_sales_data  (via CTE_Q_S0_catalog_sales_data)\n    FROM: catalog_sales cs, item i, nov2002_dates nd\n    WHERE [be40a5e8d278b3bf]: EXISTS(SELECT 1 FROM cross_items AS ci WHERE ci.ss_item_sk = cs.cs_item_sk)\n    GROUP BY: i.i_brand_id, i.i_class_id, i.i_category_id\n  CTE: web_sales_data  (via CTE_Q_S0_web_sales_data)\n    FROM: web_sales ws, item i, nov2002_dates nd\n    WHERE [be1f08b0c604c3d7]: EXISTS(SELECT 1 FROM cross_items AS ci WHERE ci.ss_item_sk = ws.ws_item_sk)\n    GROUP BY: i.i_brand_id, i.i_class_id, i.i_category_id\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) y\n    ORDER BY: channel, i_brand_id, i_class_id, i_category_id\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "intersect_to_exists"
      ],
      "families": [
        "D"
      ],
      "_match_score": 0.579
    },
    {
      "id": "self_join_decomposition",
      "name": "Self-Join Decomposition",
      "description": "Split self-joined CTE with different filter values into separate per-filter CTEs to avoid full materialization and post-filtering",
      "verified_speedup": "4.76x",
      "principle": "When a CTE is self-joined with different filter values (e.g., inv1.d_moy=1 AND inv2.d_moy=2), split into separate CTEs each embedding their filter. The optimizer cannot push the outer WHERE filter into the CTE's GROUP BY, causing full materialization and post-filtering.",
      "example": {
        "opportunity": "SELF_JOIN_DECOMPOSITION",
        "input_slice": "WITH inv AS (\n  SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy,\n    stdev, mean, CASE mean WHEN 0 THEN NULL ELSE stdev/mean END cov\n  FROM (SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy,\n          stddev_samp(inv_quantity_on_hand) stdev, avg(inv_quantity_on_hand) mean\n        FROM inventory, item, warehouse, date_dim\n        WHERE inv_item_sk = i_item_sk AND inv_warehouse_sk = w_warehouse_sk\n          AND inv_date_sk = d_date_sk AND d_year = 1998\n        GROUP BY w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy) foo\n  WHERE CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1)\nSELECT inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov,\n       inv2.w_warehouse_sk, inv2.i_item_sk, inv2.d_moy, inv2.mean, inv2.cov\nFROM inv inv1, inv inv2\nWHERE inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk\n  AND inv1.d_moy=1 AND inv2.d_moy=1+1\nORDER BY inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov,\n         inv2.d_moy, inv2.mean, inv2.cov",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "self_join_decomposition",
              "nodes": {
                "month1_stats": "SELECT w_warehouse_sk, i_item_sk, 1 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 1 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1",
                "month2_stats": "SELECT w_warehouse_sk, i_item_sk, 2 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 2 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1",
                "main_query": "SELECT month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.w_warehouse_sk, month2_stats.i_item_sk, month2_stats.d_moy, month2_stats.mean, month2_stats.cov FROM month1_stats JOIN month2_stats ON month1_stats.w_warehouse_sk = month2_stats.w_warehouse_sk AND month1_stats.i_item_sk = month2_stats.i_item_sk ORDER BY month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.d_moy, month2_stats.mean, month2_stats.cov"
              },
              "invariants_kept": [
                "output columns unchanged",
                "grain preserved",
                "same result rows"
              ],
              "expected_speedup": "4.76x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Self-Join Decomposition \u2014 when a CTE is self-joined with different discriminator filters (d_moy=1 vs d_moy=2), the optimizer materializes the CTE for ALL months then post-filters. Splitting into month1_stats and month2_stats CTEs each with their own d_moy filter means each CTE aggregates only its month's rows. The comma join is also converted to explicit JOIN ON. 4.76x speedup from processing 1/12th of the data in each CTE.",
        "when_not_to_use": "Only applies when the CTE is self-joined with different discriminator values. If the self-join uses the same filter on both aliases, decomposition provides no benefit."
      },
      "original_sql": "with inv as\n(select w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy\n       ,stdev,mean, case mean when 0 then null else stdev/mean end cov\n from(select w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy\n            ,stddev_samp(inv_quantity_on_hand) stdev,avg(inv_quantity_on_hand) mean\n      from inventory\n          ,item\n          ,warehouse\n          ,date_dim\n      where inv_item_sk = i_item_sk\n        and inv_warehouse_sk = w_warehouse_sk\n        and inv_date_sk = d_date_sk\n        and d_year =1998\n      group by w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy) foo\n where case mean when 0 then 0 else stdev/mean end > 1)\nselect inv1.w_warehouse_sk,inv1.i_item_sk,inv1.d_moy,inv1.mean, inv1.cov\n        ,inv2.w_warehouse_sk,inv2.i_item_sk,inv2.d_moy,inv2.mean, inv2.cov\nfrom inv inv1,inv inv2\nwhere inv1.i_item_sk = inv2.i_item_sk\n  and inv1.w_warehouse_sk =  inv2.w_warehouse_sk\n  and inv1.d_moy=1\n  and inv2.d_moy=1+1\norder by inv1.w_warehouse_sk,inv1.i_item_sk,inv1.d_moy,inv1.mean,inv1.cov\n        ,inv2.d_moy,inv2.mean, inv2.cov\n;",
      "optimized_sql": "WITH month1_stats AS (SELECT w_warehouse_sk, i_item_sk, 1 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 1 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1), month2_stats AS (SELECT w_warehouse_sk, i_item_sk, 2 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 2 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1) SELECT month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.w_warehouse_sk, month2_stats.i_item_sk, month2_stats.d_moy, month2_stats.mean, month2_stats.cov FROM month1_stats JOIN month2_stats ON month1_stats.w_warehouse_sk = month2_stats.w_warehouse_sk AND month1_stats.i_item_sk = month2_stats.i_item_sk ORDER BY month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.d_moy, month2_stats.mean, month2_stats.cov",
      "optimized_source": "swarm_w2",
      "sf10_rows_match": true,
      "family": "F",
      "patch_plan": {
        "plan_id": "gold_duckdb_self_join_decomposition",
        "dialect": "duckdb",
        "description": "Split self-joined CTE with different filter values into separate per-filter CTEs to avoid full materialization and post-filtering",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "month1_stats",
              "cte_query_sql": "SELECT w_warehouse_sk, i_item_sk, 1 AS d_moy, STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean, CASE WHEN AVG(inv_quantity_on_hand) = 0 THEN NULL ELSE STDDEV_SAMP(inv_quantity_on_hand) / AVG(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 1 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN AVG(inv_quantity_on_hand) = 0 THEN 0 ELSE STDDEV_SAMP(inv_quantity_on_hand) / AVG(inv_quantity_on_hand) END > 1"
            },
            "description": "Insert CTE 'month1_stats' for pre-aggregated computation"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "month2_stats",
              "cte_query_sql": "SELECT w_warehouse_sk, i_item_sk, 2 AS d_moy, STDDEV_SAMP(inv_quantity_on_hand) AS stdev, AVG(inv_quantity_on_hand) AS mean, CASE WHEN AVG(inv_quantity_on_hand) = 0 THEN NULL ELSE STDDEV_SAMP(inv_quantity_on_hand) / AVG(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 2 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN AVG(inv_quantity_on_hand) = 0 THEN 0 ELSE STDDEV_SAMP(inv_quantity_on_hand) / AVG(inv_quantity_on_hand) END > 1"
            },
            "description": "Insert CTE 'month2_stats' for pre-aggregated computation"
          },
          {
            "step_id": "s3",
            "op": "replace_body",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "sql_fragment": "SELECT month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.w_warehouse_sk, month2_stats.i_item_sk, month2_stats.d_moy, month2_stats.mean, month2_stats.cov FROM month1_stats JOIN month2_stats ON month1_stats.w_warehouse_sk = month2_stats.w_warehouse_sk AND month1_stats.i_item_sk = month2_stats.i_item_sk ORDER BY month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.d_moy, month2_stats.mean, month2_stats.cov"
            },
            "description": "Replace main query body with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  CTE: inv  (via CTE_Q_S0_inv)\n    FROM: (subquery) foo\n    WHERE [ceb681f4fee117f7]: CASE mean WHEN 0 THEN 0 ELSE stdev / mean END > 1\n  MAIN QUERY (via Q_S0)\n    FROM: inv inv1, inv inv2\n    WHERE [903785bf15ae0b13]: inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk AND inv1.d_moy = 1 ...\n    ORDER BY: inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov, inv2.d_moy, inv2.mean, inv2.cov\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: month1_stats  (via CTE_Q_S0_month1_stats)\n    FROM: inventory, item, warehouse, date_dim\n    WHERE [897571daf06f68d7]: d_year = 1998 AND d_moy = 1\n    GROUP BY: w_warehouse_sk, i_item_sk\n  CTE: month2_stats  (via CTE_Q_S0_month2_stats)\n    FROM: inventory, item, warehouse, date_dim\n    WHERE [ce1ca54e676639f9]: d_year = 1998 AND d_moy = 2\n    GROUP BY: w_warehouse_sk, i_item_sk\n  MAIN QUERY (via Q_S0)\n    FROM: month1_stats, month2_stats\n    ORDER BY: month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.d_moy, month2_stats.mean, month2_stats.cov\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "self_join_decomposition"
      ],
      "families": [
        "F"
      ],
      "gap_ids": [
        "CROSS_CTE_PREDICATE_BLINDNESS"
      ],
      "_match_score": 0.579
    },
    {
      "id": "materialize_cte",
      "name": "Materialize Repeated Subquery",
      "description": "Extract repeated subquery patterns into a CTE to avoid recomputation",
      "verified_speedup": "1.37x",
      "principle": "Shared Materialization: extract repeated subquery patterns into CTEs to avoid recomputation. When the same logical check appears multiple times, compute it once and reference the result.",
      "example": {
        "opportunity": "MATERIALIZE_CTE",
        "input_slice": "[main_query]:\nSELECT COUNT(DISTINCT ws_order_number) AS order_count,\n       SUM(ws_ext_ship_cost) AS total_shipping\nFROM web_sales ws1, date_dim, customer_address, web_site\nWHERE d_date BETWEEN '2000-03-01' AND '2000-05-01'\n  AND ws1.ws_ship_date_sk = d_date_sk\n  AND ws1.ws_ship_addr_sk = ca_address_sk\n  AND ca_state = 'IL'\n  AND ws1.ws_web_site_sk = web_site_sk\n  AND web_company_name = 'pri'\n  AND EXISTS (SELECT * FROM web_sales ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)\n  AND NOT EXISTS (SELECT * FROM web_returns wr1 WHERE ws1.ws_order_number = wr1.wr_order_number)",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "materialize_cte",
              "nodes": {
                "multi_warehouse_orders": "SELECT DISTINCT ws_order_number FROM web_sales ws1 WHERE EXISTS (SELECT 1 FROM web_sales ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)",
                "returned_orders": "SELECT DISTINCT wr_order_number FROM web_returns",
                "main_query": "SELECT COUNT(DISTINCT ws_order_number) AS order_count, SUM(ws_ext_ship_cost) AS total_shipping FROM web_sales ws1 JOIN date_dim ON ws1.ws_ship_date_sk = d_date_sk JOIN customer_address ON ws1.ws_ship_addr_sk = ca_address_sk JOIN web_site ON ws1.ws_web_site_sk = web_site_sk JOIN multi_warehouse_orders mwo ON ws1.ws_order_number = mwo.ws_order_number LEFT JOIN returned_orders ro ON ws1.ws_order_number = ro.wr_order_number WHERE d_date BETWEEN '2000-03-01' AND '2000-05-01' AND ca_state = 'IL' AND web_company_name = 'pri' AND ro.wr_order_number IS NULL"
              },
              "invariants_kept": [
                "same result rows",
                "same aggregation"
              ],
              "expected_speedup": "1.8x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Shared Materialization \u2014 extract repeated subquery patterns into CTEs to avoid recomputation. When the same logical check appears in multiple places (EXISTS, WHERE, JOIN), computing it once as a CTE and referencing it is cheaper. Here: extract multi-warehouse order detection into one CTE, returned orders into another, then JOIN instead of nested EXISTS checks.",
        "when_not_to_use": "NEVER convert EXISTS or NOT EXISTS subqueries into materialized CTEs when the EXISTS is used as a filter (not a data source). EXISTS uses semi-join short-circuiting \u2014 the database stops scanning as soon as one match is found. Materializing into a CTE forces a full scan of the subquery table, destroying this optimization. Caused 0.14x when EXISTS on catalog_sales was materialized into a full CTE scan and 0.54x when EXISTS on web_sales was forced into full materialization."
      },
      "original_sql": "with ws_wh as\n(select ws1.ws_order_number,ws1.ws_warehouse_sk wh1,ws2.ws_warehouse_sk wh2\n from web_sales ws1,web_sales ws2\n where ws1.ws_order_number = ws2.ws_order_number\n   and ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)\n select \n   count(distinct ws_order_number) as \"order count\"\n  ,sum(ws_ext_ship_cost) as \"total shipping cost\"\n  ,sum(ws_net_profit) as \"total net profit\"\nfrom\n   web_sales ws1\n  ,date_dim\n  ,customer_address\n  ,web_site\nwhere\n    d_date between '1999-2-01' and \n           (cast('1999-2-01' as date) + INTERVAL 60 DAY)\nand ws1.ws_ship_date_sk = d_date_sk\nand ws1.ws_ship_addr_sk = ca_address_sk\nand ca_state = 'NC'\nand ws1.ws_web_site_sk = web_site_sk\nand web_company_name = 'pri'\nand ws1.ws_order_number in (select ws_order_number\n                            from ws_wh)\nand ws1.ws_order_number in (select wr_order_number\n                            from web_returns,ws_wh\n                            where wr_order_number = ws_wh.ws_order_number)\norder by count(distinct ws_order_number)\n LIMIT 100;",
      "optimized_sql": "WITH ws_wh AS (SELECT ws1.ws_order_number, ws1.ws_warehouse_sk AS wh1, ws2.ws_warehouse_sk AS wh2 FROM web_sales AS ws1, web_sales AS ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)\nSELECT COUNT(DISTINCT ws_order_number) AS \"order count\", SUM(ws_ext_ship_cost) AS \"total shipping cost\", SUM(ws_net_profit) AS \"total net profit\" FROM web_sales AS ws1 JOIN date_dim ON ws1.ws_ship_date_sk = d_date_sk JOIN customer_address ON ws1.ws_ship_addr_sk = ca_address_sk JOIN web_site ON ws1.ws_web_site_sk = web_site_sk WHERE d_date BETWEEN '1999-2-01' AND (CAST('1999-2-01' AS DATE) + INTERVAL '60' DAY) AND ca_state = 'NC' AND web_company_name = 'pri' AND EXISTS(SELECT 1 FROM ws_wh WHERE ws_wh.ws_order_number = ws1.ws_order_number) AND EXISTS(SELECT 1 FROM web_returns JOIN ws_wh ON wr_order_number = ws_wh.ws_order_number WHERE wr_order_number = ws1.ws_order_number) ORDER BY COUNT(DISTINCT ws_order_number) LIMIT 100;",
      "optimized_source": "kimi",
      "sf10_rows_match": true,
      "family": "E",
      "patch_plan": {
        "plan_id": "gold_duckdb_materialize_cte",
        "dialect": "duckdb",
        "description": "Extract repeated subquery patterns into a CTE to avoid recomputation",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "replace_from",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "from_sql": "web_sales AS ws1 JOIN date_dim ON ws1.ws_ship_date_sk = d_date_sk JOIN customer_address ON ws1.ws_ship_addr_sk = ca_address_sk JOIN web_site ON ws1.ws_web_site_sk = web_site_sk"
            },
            "description": "Replace comma-join FROM with explicit JOINs"
          },
          {
            "step_id": "s2",
            "op": "replace_where_predicate",
            "target": {
              "by_node_id": "S0",
              "by_anchor_hash": "80ee6b9f8f62284b"
            },
            "payload": {
              "expr_sql": "d_date BETWEEN '1999-2-01' AND (CAST('1999-2-01' AS DATE) + INTERVAL '60' DAY) AND ca_state = 'NC' AND web_company_name = 'pri' AND EXISTS(SELECT 1 FROM ws_wh WHERE ws_wh.ws_order_number = ws1.ws_order_number) AND EXISTS(SELECT 1 FROM web_returns JOIN ws_wh ON wr_order_number = ws_wh.ws_order_number WHERE wr_order_number = ws1.ws_order_number)"
            },
            "description": "Replace WHERE predicate with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  CTE: ws_wh  (via CTE_Q_S0_ws_wh)\n    FROM: web_sales ws1, web_sales ws2\n    WHERE [268f6e93aa72c351]: ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk\n  MAIN QUERY (via Q_S0)\n    FROM: web_sales ws1, date_dim, customer_address, web_site\n    WHERE [80ee6b9f8f62284b]: d_date BETWEEN '1999-2-01' AND (CAST('1999-2-01' AS DATE) + INTERVAL '60' DAY) AND ws1.ws_ship_da...\n    ORDER BY: COUNT(DISTINCT ws_order_number)\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: ws_wh  (via CTE_Q_S0_ws_wh)\n    FROM: web_sales ws1, web_sales ws2\n    WHERE [268f6e93aa72c351]: ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk\n  MAIN QUERY (via Q_S0)\n    FROM: web_sales ws1, date_dim, customer_address, web_site\n    WHERE [346390125c1ff549]: d_date BETWEEN '1999-2-01' AND (CAST('1999-2-01' AS DATE) + INTERVAL '60' DAY) AND ca_state = 'NC...\n    ORDER BY: COUNT(DISTINCT ws_order_number)\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "materialize_cte"
      ],
      "families": [
        "E"
      ],
      "_match_score": 0.526
    },
    {
      "id": "multi_date_range_cte",
      "name": "Multi Date Range CTE",
      "description": "When query uses multiple date_dim aliases with different filters (d1, d2, d3), create separate CTEs for each date range and pre-join with fact tables",
      "verified_speedup": "2.35x",
      "principle": "Early Selection per Alias: when a query joins the same dimension table multiple times with different filters (d1, d2, d3), create separate CTEs for each filter and pre-join with fact tables to reduce rows entering the main join.",
      "example": {
        "opportunity": "MULTI DATE RANGE CTE",
        "input_slice": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name,\n  sum(ss_quantity) AS store_sales_quantity,\n  sum(sr_return_quantity) AS store_returns_quantity,\n  sum(cs_quantity) AS catalog_sales_quantity\nFROM store_sales, store_returns, catalog_sales,\n  date_dim d1, date_dim d2, date_dim d3, store, item\nWHERE d1.d_moy = 9 AND d1.d_year = 1999 AND d1.d_date_sk = ss_sold_date_sk\n  AND d2.d_moy BETWEEN 9 AND 12 AND d2.d_year = 1999 AND sr_returned_date_sk = d2.d_date_sk\n  AND d3.d_year IN (1999, 2000, 2001) AND cs_sold_date_sk = d3.d_date_sk\n  AND ss_customer_sk = sr_customer_sk AND ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number\n  AND sr_customer_sk = cs_bill_customer_sk AND sr_item_sk = cs_item_sk\nGROUP BY i_item_id, i_item_desc, s_store_id, s_store_name LIMIT 100",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "multi_date_range_cte",
              "nodes": {
                "d1_dates": "SELECT d_date_sk FROM date_dim WHERE d_moy = 9 AND d_year = 1999",
                "d2_dates": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 9 AND 12 AND d_year = 1999",
                "d3_dates": "SELECT d_date_sk FROM date_dim WHERE d_year IN (1999, 2000, 2001)",
                "filtered_store_sales": "SELECT ss_item_sk, ss_customer_sk, ss_ticket_number, ss_store_sk, ss_quantity FROM store_sales JOIN d1_dates ON store_sales.ss_sold_date_sk = d1_dates.d_date_sk",
                "filtered_store_returns": "SELECT sr_item_sk, sr_customer_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN d2_dates ON store_returns.sr_returned_date_sk = d2_dates.d_date_sk",
                "filtered_catalog_sales": "SELECT cs_item_sk, cs_bill_customer_sk, cs_quantity FROM catalog_sales JOIN d3_dates ON catalog_sales.cs_sold_date_sk = d3_dates.d_date_sk",
                "main_query": "SELECT i.i_item_id, i.i_item_desc, s.s_store_id, s.s_store_name, SUM(fss.ss_quantity) AS store_sales_quantity, SUM(fsr.sr_return_quantity) AS store_returns_quantity, SUM(fcs.cs_quantity) AS catalog_sales_quantity FROM filtered_store_sales AS fss JOIN filtered_store_returns AS fsr ON fss.ss_customer_sk = fsr.sr_customer_sk AND fss.ss_item_sk = fsr.sr_item_sk AND fss.ss_ticket_number = fsr.sr_ticket_number JOIN filtered_catalog_sales AS fcs ON fsr.sr_customer_sk = fcs.cs_bill_customer_sk AND fsr.sr_item_sk = fcs.cs_item_sk JOIN store AS s ON fss.ss_store_sk = s.s_store_sk JOIN item AS i ON fss.ss_item_sk = i.i_item_sk GROUP BY i.i_item_id, i.i_item_desc, s.s_store_id, s.s_store_name ORDER BY i.i_item_id, i.i_item_desc, s.s_store_id, s.s_store_name LIMIT 100"
              },
              "invariants_kept": [
                "same result rows",
                "same ordering",
                "same column output"
              ],
              "expected_speedup": "2.35x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Early Selection per Alias \u2014 when a query joins the same dimension table multiple times with different filters (d1, d2, d3 pattern), create separate filtered CTEs for each alias. Pre-join each date CTE with its corresponding fact table reference. This filters fact rows early before the expensive multi-way join, avoiding repeated full dimension scans."
      },
      "original_sql": "select  \n     i_item_id\n    ,i_item_desc\n    ,s_store_id\n    ,s_store_name\n    ,avg(ss_quantity)        as store_sales_quantity\n    ,avg(sr_return_quantity) as store_returns_quantity\n    ,avg(cs_quantity)        as catalog_sales_quantity\n from\n    store_sales\n   ,store_returns\n   ,catalog_sales\n   ,date_dim             d1\n   ,date_dim             d2\n   ,date_dim             d3\n   ,store\n   ,item\n where\n     d1.d_moy               = 4 \n and d1.d_year              = 1999\n and d1.d_date_sk           = ss_sold_date_sk\n and i_item_sk              = ss_item_sk\n and s_store_sk             = ss_store_sk\n and ss_customer_sk         = sr_customer_sk\n and ss_item_sk             = sr_item_sk\n and ss_ticket_number       = sr_ticket_number\n and sr_returned_date_sk    = d2.d_date_sk\n and d2.d_moy               between 4 and  4 + 3 \n and d2.d_year              = 1999\n and sr_customer_sk         = cs_bill_customer_sk\n and sr_item_sk             = cs_item_sk\n and cs_sold_date_sk        = d3.d_date_sk     \n and d3.d_year              in (1999,1999+1,1999+2)\n group by\n    i_item_id\n   ,i_item_desc\n   ,s_store_id\n   ,s_store_name\n order by\n    i_item_id \n   ,i_item_desc\n   ,s_store_id\n   ,s_store_name\n LIMIT 100;",
      "optimized_sql": "WITH d1_filtered AS (SELECT d_date_sk FROM date_dim WHERE d_moy = 4 AND d_year = 1999), d2_filtered AS (SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 4 AND 7 AND d_year = 1999), d3_filtered AS (SELECT d_date_sk FROM date_dim WHERE d_year IN (1999, 2000, 2001)), filtered_store_sales AS (SELECT ss.ss_item_sk, ss.ss_store_sk, ss.ss_customer_sk, ss.ss_ticket_number, ss.ss_quantity FROM store_sales AS ss JOIN d1_filtered AS d1 ON ss.ss_sold_date_sk = d1.d_date_sk), filtered_store_returns AS (SELECT sr.sr_customer_sk, sr.sr_item_sk, sr.sr_ticket_number, sr.sr_return_quantity FROM store_returns AS sr JOIN d2_filtered AS d2 ON sr.sr_returned_date_sk = d2.d_date_sk), filtered_catalog_sales AS (SELECT cs.cs_bill_customer_sk, cs.cs_item_sk, cs.cs_quantity FROM catalog_sales AS cs JOIN d3_filtered AS d3 ON cs.cs_sold_date_sk = d3.d_date_sk)\nSELECT i.i_item_id, i.i_item_desc, s.s_store_id, s.s_store_name, AVG(ss.ss_quantity) AS store_sales_quantity, AVG(sr.sr_return_quantity) AS store_returns_quantity, AVG(cs.cs_quantity) AS catalog_sales_quantity FROM filtered_store_sales AS ss JOIN item AS i ON ss.ss_item_sk = i.i_item_sk JOIN store AS s ON ss.ss_store_sk = s.s_store_sk JOIN filtered_store_returns AS sr ON ss.ss_customer_sk = sr.sr_customer_sk AND ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number JOIN filtered_catalog_sales AS cs ON sr.sr_customer_sk = cs.cs_bill_customer_sk AND sr.sr_item_sk = cs.cs_item_sk GROUP BY i.i_item_id, i.i_item_desc, s.s_store_id, s.s_store_name ORDER BY i.i_item_id, i.i_item_desc, s.s_store_id, s.s_store_name LIMIT 100;",
      "optimized_source": "kimi",
      "family": "A",
      "patch_plan": {
        "plan_id": "gold_duckdb_multi_date_range_cte",
        "dialect": "duckdb",
        "description": "When query uses multiple date_dim aliases with different filters (d1, d2, d3), create separate CTEs for each date range and pre-join with fact tables",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "d1_filtered",
              "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 4 AND d_year = 1999"
            },
            "description": "Insert CTE 'd1_filtered' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "d2_filtered",
              "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 4 AND 7 AND d_year = 1999"
            },
            "description": "Insert CTE 'd2_filtered' for date dimension filtering"
          },
          {
            "step_id": "s3",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "d3_filtered",
              "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_year IN (1999, 2000, 2001)"
            },
            "description": "Insert CTE 'd3_filtered' for date dimension filtering"
          },
          {
            "step_id": "s4",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_store_sales",
              "cte_query_sql": "SELECT ss.ss_item_sk, ss.ss_store_sk, ss.ss_customer_sk, ss.ss_ticket_number, ss.ss_quantity FROM store_sales AS ss JOIN d1_filtered AS d1 ON ss.ss_sold_date_sk = d1.d_date_sk"
            },
            "description": "Insert CTE 'filtered_store_sales' for date dimension filtering"
          },
          {
            "step_id": "s5",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_store_returns",
              "cte_query_sql": "SELECT sr.sr_customer_sk, sr.sr_item_sk, sr.sr_ticket_number, sr.sr_return_quantity FROM store_returns AS sr JOIN d2_filtered AS d2 ON sr.sr_returned_date_sk = d2.d_date_sk"
            },
            "description": "Insert CTE 'filtered_store_returns' for date dimension filtering"
          },
          {
            "step_id": "s6",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_catalog_sales",
              "cte_query_sql": "SELECT cs.cs_bill_customer_sk, cs.cs_item_sk, cs.cs_quantity FROM catalog_sales AS cs JOIN d3_filtered AS d3 ON cs.cs_sold_date_sk = d3.d_date_sk"
            },
            "description": "Insert CTE 'filtered_catalog_sales' for date dimension filtering"
          },
          {
            "step_id": "s7",
            "op": "replace_from",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "from_sql": "filtered_store_sales AS ss JOIN item AS i ON ss.ss_item_sk = i.i_item_sk JOIN store AS s ON ss.ss_store_sk = s.s_store_sk JOIN filtered_store_returns AS sr ON ss.ss_customer_sk = sr.sr_customer_sk AND ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number JOIN filtered_catalog_sales AS cs ON sr.sr_customer_sk = cs.cs_bill_customer_sk AND sr.sr_item_sk = cs.cs_item_sk"
            },
            "description": "Replace comma-join FROM with explicit JOINs"
          },
          {
            "step_id": "s8",
            "op": "delete_expr_subtree",
            "target": {
              "by_node_id": "S0",
              "by_anchor_hash": "71927f19345ff8e4"
            },
            "description": "Remove WHERE clause (conditions moved to CTEs)"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: store_sales, store_returns, catalog_sales, date_dim d1, date_dim d2, date_dim d3, store, item\n    WHERE [71927f19345ff8e4]: d1.d_moy = 4 AND d1.d_year = 1999 AND d1.d_date_sk = ss_sold_date_sk AND i_item_sk = ss_item_sk A...\n    GROUP BY: i_item_id, i_item_desc, s_store_id, s_store_name\n    ORDER BY: i_item_id, i_item_desc, s_store_id, s_store_name\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: d1_filtered  (via CTE_Q_S0_d1_filtered)\n    FROM: date_dim\n    WHERE [29155e96e4783f98]: d_moy = 4 AND d_year = 1999\n  CTE: d2_filtered  (via CTE_Q_S0_d2_filtered)\n    FROM: date_dim\n    WHERE [33674997f893a3df]: d_moy BETWEEN 4 AND 7 AND d_year = 1999\n  CTE: d3_filtered  (via CTE_Q_S0_d3_filtered)\n    FROM: date_dim\n    WHERE [b653aab07ba6640d]: d_year IN (1999, 2000, 2001)\n  CTE: filtered_store_sales  (via CTE_Q_S0_filtered_store_sales)\n    FROM: store_sales ss, d1_filtered d1\n  CTE: filtered_store_returns  (via CTE_Q_S0_filtered_store_returns)\n    FROM: store_returns sr, d2_filtered d2\n  CTE: filtered_catalog_sales  (via CTE_Q_S0_filtered_catalog_sales)\n    FROM: catalog_sales cs, d3_filtered d3\n  MAIN QUERY (via Q_S0)\n    FROM: filtered_store_sales ss, item i, store s, filtered_store_returns sr, filtered_catalog_sales cs\n    GROUP BY: i.i_item_id, i.i_item_desc, s.s_store_id, s.s_store_name\n    ORDER BY: i.i_item_id, i.i_item_desc, s.s_store_id, s.s_store_name\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "multi_date_range_cte"
      ],
      "families": [
        "A"
      ],
      "gap_ids": [
        "CROSS_CTE_PREDICATE_BLINDNESS"
      ],
      "_match_score": 0.474
    },
    {
      "id": "union_cte_split",
      "name": "Union CTE Split/Specialization",
      "description": "Split a generic UNION ALL CTE into specialized CTEs when the main query filters by year or discriminator - eliminates redundant scans",
      "verified_speedup": "1.36x",
      "principle": "CTE Specialization: when a generic CTE is scanned multiple times with different filters (e.g., by year), split it into specialized CTEs that embed the filter in their definition. Each specialized CTE processes only its relevant subset, eliminating redundant scans.",
      "example": {
        "opportunity": "UNION_CTE_SPLIT: CTE with UNION ALL is scanned twice with different year filters - split into year-specific CTEs",
        "input_slice": "WITH wscs AS (\n  SELECT ws_sold_date_sk AS sold_date_sk, ws_ext_sales_price AS sales_price FROM web_sales\n  UNION ALL\n  SELECT cs_sold_date_sk AS sold_date_sk, cs_ext_sales_price AS sales_price FROM catalog_sales\n), wswscs AS (\nSELECT d_week_seq, SUM(CASE WHEN d_day_name='Sunday' THEN sales_price ELSE NULL END) AS sun_sales,\n       SUM(CASE WHEN d_day_name='Monday' THEN sales_price ELSE NULL END) AS mon_sales\nFROM wscs, date_dim WHERE d_date_sk = sold_date_sk GROUP BY d_week_seq\n)\nSELECT y.d_week_seq AS d_week_seq1, ROUND(y.sun_sales/z.sun_sales,2)\nFROM (SELECT wswscs.d_week_seq, wswscs.sun_sales FROM wswscs, date_dim WHERE date_dim.d_week_seq = wswscs.d_week_seq AND d_year = 1998) y,\n     (SELECT wswscs.d_week_seq, wswscs.sun_sales FROM wswscs, date_dim WHERE date_dim.d_week_seq = wswscs.d_week_seq AND d_year = 1999) z\nWHERE y.d_week_seq = z.d_week_seq - 53 ORDER BY d_week_seq1",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "union_cte_split",
              "nodes": {
                "year_1998_dates": "SELECT d_date_sk, d_week_seq, d_day_name FROM date_dim WHERE d_year = 1998",
                "year_1999_dates": "SELECT d_date_sk, d_week_seq, d_day_name FROM date_dim WHERE d_year = 1999",
                "wswscs_1998": "SELECT d_week_seq, SUM(CASE WHEN d_day_name='Sunday' THEN sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN d_day_name='Monday' THEN sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN d_day_name='Tuesday' THEN sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN d_day_name='Wednesday' THEN sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN d_day_name='Thursday' THEN sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN d_day_name='Friday' THEN sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN d_day_name='Saturday' THEN sales_price ELSE NULL END) AS sat_sales FROM (SELECT ws_sold_date_sk AS sold_date_sk, ws_ext_sales_price AS sales_price FROM web_sales UNION ALL SELECT cs_sold_date_sk AS sold_date_sk, cs_ext_sales_price AS sales_price FROM catalog_sales) wscs JOIN year_1998_dates ON d_date_sk = sold_date_sk GROUP BY d_week_seq",
                "wswscs_1999": "SELECT d_week_seq, SUM(CASE WHEN d_day_name='Sunday' THEN sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN d_day_name='Monday' THEN sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN d_day_name='Tuesday' THEN sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN d_day_name='Wednesday' THEN sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN d_day_name='Thursday' THEN sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN d_day_name='Friday' THEN sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN d_day_name='Saturday' THEN sales_price ELSE NULL END) AS sat_sales FROM (SELECT ws_sold_date_sk AS sold_date_sk, ws_ext_sales_price AS sales_price FROM web_sales UNION ALL SELECT cs_sold_date_sk AS sold_date_sk, cs_ext_sales_price AS sales_price FROM catalog_sales) wscs JOIN year_1999_dates ON d_date_sk = sold_date_sk GROUP BY d_week_seq",
                "main_query": "SELECT y.d_week_seq AS d_week_seq1, ROUND(y.sun_sales / NULLIF(z.sun_sales, 0), 2), ROUND(y.mon_sales / NULLIF(z.mon_sales, 0), 2), ROUND(y.tue_sales / NULLIF(z.tue_sales, 0), 2), ROUND(y.wed_sales / NULLIF(z.wed_sales, 0), 2), ROUND(y.thu_sales / NULLIF(z.thu_sales, 0), 2), ROUND(y.fri_sales / NULLIF(z.fri_sales, 0), 2), ROUND(y.sat_sales / NULLIF(z.sat_sales, 0), 2) FROM wswscs_1998 y JOIN wswscs_1999 z ON y.d_week_seq = z.d_week_seq - 53 ORDER BY y.d_week_seq"
              },
              "invariants_kept": [
                "same result rows",
                "same ordering",
                "same column output",
                "same aggregation semantics"
              ],
              "expected_speedup": "1.5x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: CTE Specialization \u2014 when a generic CTE is scanned multiple times with different filters (e.g., by year), split it into specialized CTEs that embed the filter in their definition. Each specialized CTE processes only its relevant subset, eliminating redundant scans and post-hoc filtering. Here: generic wswscs CTE scanned twice with year filters becomes wswscs_1998 and wswscs_1999, each joining date_dim once during aggregation."
      },
      "original_sql": "with year_total as (\n select c_customer_id customer_id\n       ,c_first_name customer_first_name\n       ,c_last_name customer_last_name\n       ,d_year as year\n       ,stddev_samp(ss_net_paid) year_total\n       ,'s' sale_type\n from customer\n     ,store_sales\n     ,date_dim\n where c_customer_sk = ss_customer_sk\n   and ss_sold_date_sk = d_date_sk\n   and d_year in (1999,1999+1)\n group by c_customer_id\n         ,c_first_name\n         ,c_last_name\n         ,d_year\n union all\n select c_customer_id customer_id\n       ,c_first_name customer_first_name\n       ,c_last_name customer_last_name\n       ,d_year as year\n       ,stddev_samp(ws_net_paid) year_total\n       ,'w' sale_type\n from customer\n     ,web_sales\n     ,date_dim\n where c_customer_sk = ws_bill_customer_sk\n   and ws_sold_date_sk = d_date_sk\n   and d_year in (1999,1999+1)\n group by c_customer_id\n         ,c_first_name\n         ,c_last_name\n         ,d_year\n         )\n  select\n        t_s_secyear.customer_id, t_s_secyear.customer_first_name, t_s_secyear.customer_last_name\n from year_total t_s_firstyear\n     ,year_total t_s_secyear\n     ,year_total t_w_firstyear\n     ,year_total t_w_secyear\n where t_s_secyear.customer_id = t_s_firstyear.customer_id\n         and t_s_firstyear.customer_id = t_w_secyear.customer_id\n         and t_s_firstyear.customer_id = t_w_firstyear.customer_id\n         and t_s_firstyear.sale_type = 's'\n         and t_w_firstyear.sale_type = 'w'\n         and t_s_secyear.sale_type = 's'\n         and t_w_secyear.sale_type = 'w'\n         and t_s_firstyear.year = 1999\n         and t_s_secyear.year = 1999+1\n         and t_w_firstyear.year = 1999\n         and t_w_secyear.year = 1999+1\n         and t_s_firstyear.year_total > 0\n         and t_w_firstyear.year_total > 0\n         and case when t_w_firstyear.year_total > 0 then t_w_secyear.year_total / t_w_firstyear.year_total else null end\n           > case when t_s_firstyear.year_total > 0 then t_s_secyear.year_total / t_s_firstyear.year_total else null end\n order by 2,1,3\n LIMIT 100;",
      "optimized_sql": "WITH year_total AS (SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, STDDEV_SAMP(ss_net_paid) AS year_total, 's' AS sale_type FROM customer, store_sales, date_dim WHERE c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1) GROUP BY c_customer_id, c_first_name, c_last_name, d_year UNION ALL SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, STDDEV_SAMP(ws_net_paid) AS year_total, 'w' AS sale_type FROM customer, web_sales, date_dim WHERE c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1) GROUP BY c_customer_id, c_first_name, c_last_name, d_year), year_total_store AS (SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, STDDEV_SAMP(ss_net_paid) AS year_total FROM customer, store_sales, date_dim WHERE c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1) GROUP BY c_customer_id, c_first_name, c_last_name, d_year), year_total_web AS (SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, STDDEV_SAMP(ws_net_paid) AS year_total FROM customer, web_sales, date_dim WHERE c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1) GROUP BY c_customer_id, c_first_name, c_last_name, d_year)\nSELECT t_s_secyear.customer_id, t_s_secyear.customer_first_name, t_s_secyear.customer_last_name FROM year_total_store AS t_s_firstyear, year_total_store AS t_s_secyear, year_total_web AS t_w_firstyear, year_total_web AS t_w_secyear WHERE t_s_secyear.customer_id = t_s_firstyear.customer_id AND t_s_firstyear.customer_id = t_w_secyear.customer_id AND t_s_firstyear.customer_id = t_w_firstyear.customer_id AND t_s_firstyear.year = 1999 AND t_s_secyear.year = 1999 + 1 AND t_w_firstyear.year = 1999 AND t_w_secyear.year = 1999 + 1 AND t_s_firstyear.year_total > 0 AND t_w_firstyear.year_total > 0 AND CASE WHEN t_w_firstyear.year_total > 0 THEN t_w_secyear.year_total / t_w_firstyear.year_total ELSE NULL END > CASE WHEN t_s_firstyear.year_total > 0 THEN t_s_secyear.year_total / t_s_firstyear.year_total ELSE NULL END ORDER BY 2, 1, 3 LIMIT 100;",
      "optimized_source": "kimi",
      "sf10_rows_match": true,
      "family": "D",
      "patch_plan": {
        "plan_id": "gold_duckdb_union_cte_split",
        "dialect": "duckdb",
        "description": "Split a generic UNION ALL CTE into specialized CTEs when the main query filters by year or discriminator - eliminates redundant scans",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "year_total_store",
              "cte_query_sql": "SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, STDDEV_SAMP(ss_net_paid) AS year_total FROM customer, store_sales, date_dim WHERE c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1) GROUP BY c_customer_id, c_first_name, c_last_name, d_year"
            },
            "description": "Insert CTE 'year_total_store' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "year_total_web",
              "cte_query_sql": "SELECT c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, STDDEV_SAMP(ws_net_paid) AS year_total FROM customer, web_sales, date_dim WHERE c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1) GROUP BY c_customer_id, c_first_name, c_last_name, d_year"
            },
            "description": "Insert CTE 'year_total_web' for date dimension filtering"
          },
          {
            "step_id": "s3",
            "op": "replace_from",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "from_sql": "year_total_store AS t_s_firstyear , year_total_store AS t_s_secyear , year_total_web AS t_w_firstyear , year_total_web AS t_w_secyear"
            },
            "description": "Replace FROM clause with optimized version"
          },
          {
            "step_id": "s4",
            "op": "replace_where_predicate",
            "target": {
              "by_node_id": "S0",
              "by_anchor_hash": "5aebe09d57fd40a1"
            },
            "payload": {
              "expr_sql": "t_s_secyear.customer_id = t_s_firstyear.customer_id AND t_s_firstyear.customer_id = t_w_secyear.customer_id AND t_s_firstyear.customer_id = t_w_firstyear.customer_id AND t_s_firstyear.year = 1999 AND t_s_secyear.year = 1999 + 1 AND t_w_firstyear.year = 1999 AND t_w_secyear.year = 1999 + 1 AND t_s_firstyear.year_total > 0 AND t_w_firstyear.year_total > 0 AND CASE WHEN t_w_firstyear.year_total > 0 THEN t_w_secyear.year_total / t_w_firstyear.year_total ELSE NULL END > CASE WHEN t_s_firstyear.year_total > 0 THEN t_s_secyear.year_total / t_s_firstyear.year_total ELSE NULL END"
            },
            "description": "Replace WHERE predicate with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  CTE: year_total  (via CTE_Q_S0_year_total)\n  MAIN QUERY (via Q_S0)\n    FROM: year_total t_s_firstyear, year_total t_s_secyear, year_total t_w_firstyear, year_total t_w_secyear\n    WHERE [5aebe09d57fd40a1]: t_s_secyear.customer_id = t_s_firstyear.customer_id AND t_s_firstyear.customer_id = t_w_secyear.c...\n    ORDER BY: 2, 1, 3\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: year_total  (via CTE_Q_S0_year_total)\n  CTE: year_total_store  (via CTE_Q_S0_year_total_store)\n    FROM: customer, store_sales, date_dim\n    WHERE [6fb117ccf9feb83f]: c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1)\n    GROUP BY: c_customer_id, c_first_name, c_last_name, d_year\n  CTE: year_total_web  (via CTE_Q_S0_year_total_web)\n    FROM: customer, web_sales, date_dim\n    WHERE [978706cec4304d8d]: c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk AND d_year IN (1999, 1999 + 1)\n    GROUP BY: c_customer_id, c_first_name, c_last_name, d_year\n  MAIN QUERY (via Q_S0)\n    FROM: year_total_store t_s_firstyear, year_total_store t_s_secyear, year_total_web t_w_firstyear, year_total_web t_w_secyear\n    WHERE [00b536073cae37ff]: t_s_secyear.customer_id = t_s_firstyear.customer_id AND t_s_firstyear.customer_id = t_w_secyear.c...\n    ORDER BY: 2, 1, 3\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "union_cte_split"
      ],
      "families": [
        "D"
      ],
      "gap_ids": [
        "UNION_CTE_SELF_JOIN_DECOMPOSITION"
      ],
      "_match_score": 0.474
    },
    {
      "id": "composite_decorrelate_union",
      "name": "Decorrelate EXISTS + OR-to-UNION Composite",
      "description": "Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT customer CTEs with a shared date filter, and replace OR(EXISTS a, EXISTS b) with UNION of key sets",
      "verified_speedup": "2.42x",
      "principle": "Composite Decorrelation: when multiple correlated EXISTS share common filters, extract shared dimensions into a single CTE and decorrelate the EXISTS checks into pre-materialized key sets joined via UNION.",
      "example": {
        "opportunity": "DECORRELATE + DATE_CTE_ISOLATE + OR_TO_UNION",
        "input_slice": "[main_query]:\nSELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, count(*) cnt1, ...\nFROM customer c, customer_address ca, customer_demographics\nWHERE c.c_current_addr_sk = ca.ca_address_sk\n  AND cd_demo_sk = c.c_current_cdemo_sk\n  AND EXISTS (SELECT * FROM store_sales, date_dim\n              WHERE c.c_customer_sk = ss_customer_sk\n              AND ss_sold_date_sk = d_date_sk AND d_year = 2001 AND d_qoy < 4)\n  AND (EXISTS (SELECT * FROM web_sales, date_dim\n               WHERE c.c_customer_sk = ws_bill_customer_sk\n               AND ws_sold_date_sk = d_date_sk AND d_year = 2001 AND d_qoy < 4)\n       OR EXISTS (SELECT * FROM catalog_sales, date_dim\n                  WHERE c.c_customer_sk = cs_ship_customer_sk\n                  AND cs_sold_date_sk = d_date_sk AND d_year = 2001 AND d_qoy < 4))\nGROUP BY ... ORDER BY ... LIMIT 100",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "decorrelate",
              "nodes": {
                "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_qoy < 4",
                "store_customers": "SELECT DISTINCT ss_customer_sk FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk",
                "web_customers": "SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk",
                "catalog_customers": "SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk",
                "web_or_catalog_customers": "SELECT ws_bill_customer_sk AS customer_sk FROM web_customers UNION SELECT cs_ship_customer_sk AS customer_sk FROM catalog_customers",
                "main_query": "SELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, COUNT(*) AS cnt1, MAX(cd_dep_count), SUM(cd_dep_count), MAX(cd_dep_count), cd_dep_employed_count, COUNT(*) AS cnt2, MAX(cd_dep_employed_count), SUM(cd_dep_employed_count), MAX(cd_dep_employed_count), cd_dep_college_count, COUNT(*) AS cnt3, MAX(cd_dep_college_count), SUM(cd_dep_college_count), MAX(cd_dep_college_count) FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics ON cd_demo_sk = c.c_current_cdemo_sk JOIN store_customers AS sc ON c.c_customer_sk = sc.ss_customer_sk JOIN web_or_catalog_customers AS wcc ON c.c_customer_sk = wcc.customer_sk GROUP BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count ORDER BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100"
              },
              "invariants_kept": [
                "same result rows",
                "same ordering",
                "same column output"
              ],
              "expected_speedup": "2.40x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Composite Decorrelation \u2014 when multiple correlated EXISTS share common filters, extract shared dimensions once, decorrelate each EXISTS into a DISTINCT CTE, and replace OR(EXISTS) with UNION at the set level. Here: (1) shared date filter CTE, (2) each EXISTS becomes SELECT DISTINCT customer_sk joined with filtered_dates, (3) OR(EXISTS web, EXISTS catalog) becomes UNION of key CTEs. Works because the query only checks membership, which DISTINCT + JOIN achieves."
      },
      "original_sql": "select  \n  ca_state,\n  cd_gender,\n  cd_marital_status,\n  cd_dep_count,\n  count(*) cnt1,\n  max(cd_dep_count),\n  sum(cd_dep_count),\n  max(cd_dep_count),\n  cd_dep_employed_count,\n  count(*) cnt2,\n  max(cd_dep_employed_count),\n  sum(cd_dep_employed_count),\n  max(cd_dep_employed_count),\n  cd_dep_college_count,\n  count(*) cnt3,\n  max(cd_dep_college_count),\n  sum(cd_dep_college_count),\n  max(cd_dep_college_count)\n from\n  customer c,customer_address ca,customer_demographics\n where\n  c.c_current_addr_sk = ca.ca_address_sk and\n  cd_demo_sk = c.c_current_cdemo_sk and \n  exists (select *\n          from store_sales,date_dim\n          where c.c_customer_sk = ss_customer_sk and\n                ss_sold_date_sk = d_date_sk and\n                d_year = 2001 and\n                d_qoy < 4) and\n   (exists (select *\n            from web_sales,date_dim\n            where c.c_customer_sk = ws_bill_customer_sk and\n                  ws_sold_date_sk = d_date_sk and\n                  d_year = 2001 and\n                  d_qoy < 4) or \n    exists (select * \n            from catalog_sales,date_dim\n            where c.c_customer_sk = cs_ship_customer_sk and\n                  cs_sold_date_sk = d_date_sk and\n                  d_year = 2001 and\n                  d_qoy < 4))\n group by ca_state,\n          cd_gender,\n          cd_marital_status,\n          cd_dep_count,\n          cd_dep_employed_count,\n          cd_dep_college_count\n order by ca_state,\n          cd_gender,\n          cd_marital_status,\n          cd_dep_count,\n          cd_dep_employed_count,\n          cd_dep_college_count\n LIMIT 100;",
      "optimized_sql": "WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_qoy < 4), store_customers AS (SELECT DISTINCT ss_customer_sk FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk), web_customers AS (SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk), catalog_customers AS (SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk), web_or_catalog_customers AS (SELECT ws_bill_customer_sk AS customer_sk FROM web_customers UNION SELECT cs_ship_customer_sk AS customer_sk FROM catalog_customers)\nSELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, COUNT(*) AS cnt1, MAX(cd_dep_count), SUM(cd_dep_count), MAX(cd_dep_count), cd_dep_employed_count, COUNT(*) AS cnt2, MAX(cd_dep_employed_count), SUM(cd_dep_employed_count), MAX(cd_dep_employed_count), cd_dep_college_count, COUNT(*) AS cnt3, MAX(cd_dep_college_count), SUM(cd_dep_college_count), MAX(cd_dep_college_count) FROM customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics ON cd_demo_sk = c.c_current_cdemo_sk JOIN store_customers AS sc ON c.c_customer_sk = sc.ss_customer_sk JOIN web_or_catalog_customers AS wcc ON c.c_customer_sk = wcc.customer_sk GROUP BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count ORDER BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100;",
      "optimized_source": "dsr1",
      "sf10_rows_match": true,
      "family": "B",
      "patch_plan": {
        "plan_id": "gold_duckdb_composite_decorrelate_union",
        "dialect": "duckdb",
        "description": "Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT customer CTEs with a shared date filter, and replace OR(EXISTS a, EXISTS b) with UNION of key sets",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_dates",
              "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_qoy < 4"
            },
            "description": "Insert CTE 'filtered_dates' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "store_customers",
              "cte_query_sql": "SELECT DISTINCT ss_customer_sk FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk"
            },
            "description": "Insert CTE 'store_customers' for date dimension filtering"
          },
          {
            "step_id": "s3",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "web_customers",
              "cte_query_sql": "SELECT DISTINCT ws_bill_customer_sk FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk"
            },
            "description": "Insert CTE 'web_customers' for date dimension filtering"
          },
          {
            "step_id": "s4",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "catalog_customers",
              "cte_query_sql": "SELECT DISTINCT cs_ship_customer_sk FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk"
            },
            "description": "Insert CTE 'catalog_customers' for date dimension filtering"
          },
          {
            "step_id": "s5",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "web_or_catalog_customers",
              "cte_query_sql": "SELECT ws_bill_customer_sk AS customer_sk FROM web_customers UNION SELECT cs_ship_customer_sk AS customer_sk FROM catalog_customers"
            },
            "description": "Insert CTE 'web_or_catalog_customers' for UNION-based decomposition"
          },
          {
            "step_id": "s6",
            "op": "replace_from",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "from_sql": "customer AS c JOIN customer_address AS ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics ON cd_demo_sk = c.c_current_cdemo_sk JOIN store_customers AS sc ON c.c_customer_sk = sc.ss_customer_sk JOIN web_or_catalog_customers AS wcc ON c.c_customer_sk = wcc.customer_sk"
            },
            "description": "Replace comma-join FROM with explicit JOINs"
          },
          {
            "step_id": "s7",
            "op": "delete_expr_subtree",
            "target": {
              "by_node_id": "S0",
              "by_anchor_hash": "8ec0dc781ff406d9"
            },
            "description": "Remove WHERE clause (conditions moved to CTEs)"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: customer c, customer_address ca, customer_demographics\n    WHERE [8ec0dc781ff406d9]: c.c_current_addr_sk = ca.ca_address_sk AND cd_demo_sk = c.c_current_cdemo_sk AND EXISTS(SELECT * ...\n    GROUP BY: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count\n    ORDER BY: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_dates  (via CTE_Q_S0_filtered_dates)\n    FROM: date_dim\n    WHERE [4297dc79fb99a14a]: d_year = 2001 AND d_qoy < 4\n  CTE: store_customers  (via CTE_Q_S0_store_customers)\n    FROM: store_sales, filtered_dates\n  CTE: web_customers  (via CTE_Q_S0_web_customers)\n    FROM: web_sales, filtered_dates\n  CTE: catalog_customers  (via CTE_Q_S0_catalog_customers)\n    FROM: catalog_sales, filtered_dates\n  CTE: web_or_catalog_customers  (via CTE_Q_S0_web_or_catalog_customers)\n  MAIN QUERY (via Q_S0)\n    FROM: customer c, customer_address ca, customer_demographics, store_customers sc, web_or_catalog_customers wcc\n    GROUP BY: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count\n    ORDER BY: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "decorrelate"
      ],
      "families": [
        "B"
      ],
      "gap_ids": [
        "CORRELATED_SUBQUERY_PARALYSIS"
      ],
      "_match_score": 0.421
    },
    {
      "id": "channel_bitmap_aggregation",
      "name": "Channel Bitmap Aggregation",
      "description": "Consolidate repeated scans of the same fact table (one per time/channel bucket) into a single scan with CASE WHEN labels and conditional aggregation",
      "verified_speedup": "6.24x",
      "example": {
        "opportunity": "SINGLE_PASS_AGGREGATION + DIMENSION_CTE_ISOLATE",
        "input_slice": "select * from\n (select count(*) h8_30_to_9\n from store_sales, household_demographics, time_dim, store\n where ss_sold_time_sk = time_dim.t_time_sk\n   and ss_hdemo_sk = household_demographics.hd_demo_sk\n   and ss_store_sk = s_store_sk\n   and time_dim.t_hour = 8 and time_dim.t_minute >= 30\n   and ((hd_dep_count = -1 and hd_vehicle_count <= 1) or ...)\n   and store.s_store_name = 'ese') s1,\n (select count(*) h9_to_9_30 ...same pattern for 8 time buckets...)",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "single_pass_aggregation",
              "nodes": {
                "filtered_store": "SELECT s_store_sk FROM store WHERE s_store_name = 'ese'",
                "filtered_hd": "SELECT hd_demo_sk FROM household_demographics WHERE (hd_dep_count = -1 AND hd_vehicle_count <= 1) OR (hd_dep_count = 4 AND hd_vehicle_count <= 6) OR (hd_dep_count = 3 AND hd_vehicle_count <= 5)",
                "time_ranges": "SELECT t_time_sk, CASE WHEN t_hour = 8 AND t_minute >= 30 THEN 1 WHEN t_hour = 9 AND t_minute < 30 THEN 2 WHEN t_hour = 9 AND t_minute >= 30 THEN 3 WHEN t_hour = 10 AND t_minute < 30 THEN 4 WHEN t_hour = 10 AND t_minute >= 30 THEN 5 WHEN t_hour = 11 AND t_minute < 30 THEN 6 WHEN t_hour = 11 AND t_minute >= 30 THEN 7 WHEN t_hour = 12 AND t_minute < 30 THEN 8 END AS time_window FROM time_dim WHERE (t_hour BETWEEN 8 AND 12)",
                "sales_with_time": "SELECT tr.time_window FROM store_sales ss JOIN filtered_store fs ON ss.ss_store_sk = fs.s_store_sk JOIN filtered_hd fhd ON ss.ss_hdemo_sk = fhd.hd_demo_sk JOIN time_ranges tr ON ss.ss_sold_time_sk = tr.t_time_sk",
                "main_query": "SELECT COUNT(CASE WHEN time_window = 1 THEN 1 END) AS h8_30_to_9, COUNT(CASE WHEN time_window = 2 THEN 1 END) AS h9_to_9_30, COUNT(CASE WHEN time_window = 3 THEN 1 END) AS h9_30_to_10, COUNT(CASE WHEN time_window = 4 THEN 1 END) AS h10_to_10_30, COUNT(CASE WHEN time_window = 5 THEN 1 END) AS h10_30_to_11, COUNT(CASE WHEN time_window = 6 THEN 1 END) AS h11_to_11_30, COUNT(CASE WHEN time_window = 7 THEN 1 END) AS h11_30_to_12, COUNT(CASE WHEN time_window = 8 THEN 1 END) AS h12_to_12_30 FROM sales_with_time"
              },
              "invariants_kept": [
                "output columns unchanged",
                "same row counts per bucket"
              ],
              "expected_speedup": "6.24x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "The original query scans store_sales 8 times (once per time bucket), each with identical dimension joins. Consolidating into a single scan with CASE WHEN labels inside COUNT() reduces I/O from 8x to 1x. Dimension pre-filtering CTEs further reduce the join probe size.",
        "when_not_to_use": "Do not use when the number of distinct buckets exceeds 8 (diminishing returns from CASE evaluation overhead). Also not applicable when each subquery has structurally different joins or table references."
      },
      "original_sql": "select * from\n (select count(*) h8_30_to_9\n from store_sales, household_demographics, time_dim, store\n where ss_sold_time_sk = time_dim.t_time_sk\n   and ss_hdemo_sk = household_demographics.hd_demo_sk\n   and ss_store_sk = s_store_sk\n   and time_dim.t_hour = 8 and time_dim.t_minute >= 30\n   and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or\n        (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or\n        (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))\n   and store.s_store_name = 'ese') s1,\n (select count(*) h9_to_9_30\n from store_sales, household_demographics, time_dim, store\n where ss_sold_time_sk = time_dim.t_time_sk\n   and ss_hdemo_sk = household_demographics.hd_demo_sk\n   and ss_store_sk = s_store_sk\n   and time_dim.t_hour = 9 and time_dim.t_minute < 30\n   and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or\n        (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or\n        (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))\n   and store.s_store_name = 'ese') s2,\n (select count(*) h9_30_to_10\n from store_sales, household_demographics, time_dim, store\n where ss_sold_time_sk = time_dim.t_time_sk\n   and ss_hdemo_sk = household_demographics.hd_demo_sk\n   and ss_store_sk = s_store_sk\n   and time_dim.t_hour = 9 and time_dim.t_minute >= 30\n   and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or\n        (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or\n        (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))\n   and store.s_store_name = 'ese') s3,\n (select count(*) h10_to_10_30\n from store_sales, household_demographics, time_dim, store\n where ss_sold_time_sk = time_dim.t_time_sk\n   and ss_hdemo_sk = household_demographics.hd_demo_sk\n   and ss_store_sk = s_store_sk\n   and time_dim.t_hour = 10 and time_dim.t_minute < 30\n   and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or\n        (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or\n        (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))\n   and store.s_store_name = 'ese') s4,\n (select count(*) h10_30_to_11\n from store_sales, household_demographics, time_dim, store\n where ss_sold_time_sk = time_dim.t_time_sk\n   and ss_hdemo_sk = household_demographics.hd_demo_sk\n   and ss_store_sk = s_store_sk\n   and time_dim.t_hour = 10 and time_dim.t_minute >= 30\n   and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or\n        (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or\n        (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))\n   and store.s_store_name = 'ese') s5,\n (select count(*) h11_to_11_30\n from store_sales, household_demographics, time_dim, store\n where ss_sold_time_sk = time_dim.t_time_sk\n   and ss_hdemo_sk = household_demographics.hd_demo_sk\n   and ss_store_sk = s_store_sk\n   and time_dim.t_hour = 11 and time_dim.t_minute < 30\n   and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or\n        (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or\n        (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))\n   and store.s_store_name = 'ese') s6,\n (select count(*) h11_30_to_12\n from store_sales, household_demographics, time_dim, store\n where ss_sold_time_sk = time_dim.t_time_sk\n   and ss_hdemo_sk = household_demographics.hd_demo_sk\n   and ss_store_sk = s_store_sk\n   and time_dim.t_hour = 11 and time_dim.t_minute >= 30\n   and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or\n        (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or\n        (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))\n   and store.s_store_name = 'ese') s7,\n (select count(*) h12_to_12_30\n from store_sales, household_demographics, time_dim, store\n where ss_sold_time_sk = time_dim.t_time_sk\n   and ss_hdemo_sk = household_demographics.hd_demo_sk\n   and ss_store_sk = s_store_sk\n   and time_dim.t_hour = 12 and time_dim.t_minute < 30\n   and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or\n        (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or\n        (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))\n   and store.s_store_name = 'ese') s8;",
      "optimized_sql": "WITH filtered_store AS (SELECT s_store_sk FROM store WHERE s_store_name = 'ese'), filtered_hd AS (SELECT hd_demo_sk FROM household_demographics WHERE (hd_dep_count = -1 AND hd_vehicle_count <= -1 + 2) OR (hd_dep_count = 4 AND hd_vehicle_count <= 4 + 2) OR (hd_dep_count = 3 AND hd_vehicle_count <= 3 + 2)), time_ranges AS (SELECT t_time_sk, CASE WHEN t_hour = 8 AND t_minute >= 30 THEN 1 WHEN t_hour = 9 AND t_minute < 30 THEN 2 WHEN t_hour = 9 AND t_minute >= 30 THEN 3 WHEN t_hour = 10 AND t_minute < 30 THEN 4 WHEN t_hour = 10 AND t_minute >= 30 THEN 5 WHEN t_hour = 11 AND t_minute < 30 THEN 6 WHEN t_hour = 11 AND t_minute >= 30 THEN 7 WHEN t_hour = 12 AND t_minute < 30 THEN 8 END AS time_window FROM time_dim WHERE (t_hour = 8 AND t_minute >= 30) OR (t_hour = 9 AND t_minute < 30) OR (t_hour = 9 AND t_minute >= 30) OR (t_hour = 10 AND t_minute < 30) OR (t_hour = 10 AND t_minute >= 30) OR (t_hour = 11 AND t_minute < 30) OR (t_hour = 11 AND t_minute >= 30) OR (t_hour = 12 AND t_minute < 30)), sales_with_time AS (SELECT tr.time_window FROM store_sales ss JOIN filtered_store fs ON ss.ss_store_sk = fs.s_store_sk JOIN filtered_hd fhd ON ss.ss_hdemo_sk = fhd.hd_demo_sk JOIN time_ranges tr ON ss.ss_sold_time_sk = tr.t_time_sk)\nSELECT COUNT(CASE WHEN time_window = 1 THEN 1 END) AS h8_30_to_9, COUNT(CASE WHEN time_window = 2 THEN 1 END) AS h9_to_9_30, COUNT(CASE WHEN time_window = 3 THEN 1 END) AS h9_30_to_10, COUNT(CASE WHEN time_window = 4 THEN 1 END) AS h10_to_10_30, COUNT(CASE WHEN time_window = 5 THEN 1 END) AS h10_30_to_11, COUNT(CASE WHEN time_window = 6 THEN 1 END) AS h11_to_11_30, COUNT(CASE WHEN time_window = 7 THEN 1 END) AS h11_30_to_12, COUNT(CASE WHEN time_window = 8 THEN 1 END) AS h12_to_12_30 FROM sales_with_time;",
      "optimized_source": "swarm_w2",
      "sf10_rows_match": true,
      "family": "C",
      "patch_plan": {
        "plan_id": "gold_duckdb_channel_bitmap_aggregation",
        "dialect": "duckdb",
        "description": "Consolidate repeated scans of the same fact table (one per time/channel bucket) into a single scan with CASE WHEN labels and conditional aggregation",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_store",
              "cte_query_sql": "SELECT s_store_sk FROM store WHERE s_store_name = 'ese'"
            },
            "description": "Insert CTE 'filtered_store'"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_hd",
              "cte_query_sql": "SELECT hd_demo_sk FROM household_demographics WHERE (hd_dep_count = -1 AND hd_vehicle_count <= -1 + 2) OR (hd_dep_count = 4 AND hd_vehicle_count <= 4 + 2) OR (hd_dep_count = 3 AND hd_vehicle_count <= 3 + 2)"
            },
            "description": "Insert CTE 'filtered_hd'"
          },
          {
            "step_id": "s3",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "time_ranges",
              "cte_query_sql": "SELECT t_time_sk, CASE WHEN t_hour = 8 AND t_minute >= 30 THEN 1 WHEN t_hour = 9 AND t_minute < 30 THEN 2 WHEN t_hour = 9 AND t_minute >= 30 THEN 3 WHEN t_hour = 10 AND t_minute < 30 THEN 4 WHEN t_hour = 10 AND t_minute >= 30 THEN 5 WHEN t_hour = 11 AND t_minute < 30 THEN 6 WHEN t_hour = 11 AND t_minute >= 30 THEN 7 WHEN t_hour = 12 AND t_minute < 30 THEN 8 END AS time_window FROM time_dim WHERE (t_hour = 8 AND t_minute >= 30) OR (t_hour = 9 AND t_minute < 30) OR (t_hour = 9 AND t_minute >= 30) OR (t_hour = 10 AND t_minute < 30) OR (t_hour = 10 AND t_minute >= 30) OR (t_hour = 11 AND t_minute < 30) OR (t_hour = 11 AND t_minute >= 30) OR (t_hour = 12 AND t_minute < 30)"
            },
            "description": "Insert CTE 'time_ranges'"
          },
          {
            "step_id": "s4",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "sales_with_time",
              "cte_query_sql": "SELECT tr.time_window FROM store_sales AS ss JOIN filtered_store AS fs ON ss.ss_store_sk = fs.s_store_sk JOIN filtered_hd AS fhd ON ss.ss_hdemo_sk = fhd.hd_demo_sk JOIN time_ranges AS tr ON ss.ss_sold_time_sk = tr.t_time_sk"
            },
            "description": "Insert CTE 'sales_with_time' for pre-filtered join"
          },
          {
            "step_id": "s5",
            "op": "replace_body",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "sql_fragment": "SELECT COUNT(CASE WHEN time_window = 1 THEN 1 END) AS h8_30_to_9, COUNT(CASE WHEN time_window = 2 THEN 1 END) AS h9_to_9_30, COUNT(CASE WHEN time_window = 3 THEN 1 END) AS h9_30_to_10, COUNT(CASE WHEN time_window = 4 THEN 1 END) AS h10_to_10_30, COUNT(CASE WHEN time_window = 5 THEN 1 END) AS h10_30_to_11, COUNT(CASE WHEN time_window = 6 THEN 1 END) AS h11_to_11_30, COUNT(CASE WHEN time_window = 7 THEN 1 END) AS h11_30_to_12, COUNT(CASE WHEN time_window = 8 THEN 1 END) AS h12_to_12_30 FROM sales_with_time"
            },
            "description": "Replace main query body with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) s1, (subquery) s2, (subquery) s3, (subquery) s4, (subquery) s5, (subquery) s6, (subquery) s7, (subquery) s8\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_store  (via CTE_Q_S0_filtered_store)\n    FROM: store\n    WHERE [a3f99d93f88bca07]: s_store_name = 'ese'\n  CTE: filtered_hd  (via CTE_Q_S0_filtered_hd)\n    FROM: household_demographics\n    WHERE [287dba843691dcdf]: (hd_dep_count = -1 AND hd_vehicle_count <= -1 + 2) OR (hd_dep_count = 4 AND hd_vehicle_count <= 4...\n  CTE: time_ranges  (via CTE_Q_S0_time_ranges)\n    FROM: time_dim\n    WHERE [ee87b852d602c284]: (t_hour = 8 AND t_minute >= 30) OR (t_hour = 9 AND t_minute < 30) OR (t_hour = 9 AND t_minute >= ...\n  CTE: sales_with_time  (via CTE_Q_S0_sales_with_time)\n    FROM: store_sales ss, filtered_store fs, filtered_hd fhd, time_ranges tr\n  MAIN QUERY (via Q_S0)\n    FROM: sales_with_time\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "single_pass_aggregation"
      ],
      "families": [
        "C"
      ],
      "gap_ids": [
        "REDUNDANT_SCAN_ELIMINATION"
      ],
      "_match_score": 0.368
    },
    {
      "id": "early_filter",
      "name": "Early Dimension Filter",
      "description": "Filter dimension tables FIRST, then join to fact tables to reduce expensive joins",
      "verified_speedup": "4.00x",
      "principle": "Early Selection: filter small dimension tables first, then join to large fact tables. This reduces the fact table scan to only rows matching the filter, rather than scanning all rows and filtering after the join.",
      "example": {
        "opportunity": "EARLY_FILTER",
        "input_slice": "[main_query]:\nSELECT ss_customer_sk, SUM(act_sales) AS sumsales\nFROM (SELECT ss.ss_customer_sk, CASE WHEN sr.sr_return_quantity IS NOT NULL\n        THEN (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price\n        ELSE ss.ss_quantity * ss.ss_sales_price END AS act_sales\n      FROM store_sales ss LEFT JOIN store_returns sr ON ss.ss_item_sk = sr.sr_item_sk\n      JOIN reason r ON sr.sr_reason_sk = r.r_reason_sk\n      WHERE r.r_reason_desc = 'duplicate purchase') t\nGROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "early_filter",
              "nodes": {
                "filtered_reason": "SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'",
                "filtered_returns": "SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk",
                "main_query": "SELECT ss_customer_sk, SUM(act_sales) AS sumsales FROM (SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales ss JOIN filtered_returns fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100"
              },
              "invariants_kept": [
                "output columns unchanged",
                "grain preserved",
                "same result rows"
              ],
              "expected_speedup": "2.71x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Early Selection \u2014 filter small dimension tables first, then join to large fact tables. This reduces the fact table scan to only rows matching the filter, rather than scanning all rows and filtering after the join. Here: filter reason table to 'duplicate purchase' first, then join to store_returns, then to store_sales \u2014 dramatically reducing the rows entering the expensive fact join."
      },
      "original_sql": "select ss_customer_sk\n            ,sum(act_sales) sumsales\n      from (select ss_item_sk\n                  ,ss_ticket_number\n                  ,ss_customer_sk\n                  ,case when sr_return_quantity is not null then (ss_quantity-sr_return_quantity)*ss_sales_price\n                                                            else (ss_quantity*ss_sales_price) end act_sales\n            from store_sales left outer join store_returns on (sr_item_sk = ss_item_sk\n                                                               and sr_ticket_number = ss_ticket_number)\n                ,reason\n            where sr_reason_sk = r_reason_sk\n              and r_reason_desc = 'duplicate purchase') t\n      group by ss_customer_sk\n      order by sumsales, ss_customer_sk\n LIMIT 100;",
      "optimized_sql": "WITH filtered_reason AS (SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'), filtered_returns AS (SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk)\nSELECT ss_customer_sk, SUM(act_sales) AS sumsales FROM (SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales AS ss JOIN filtered_returns AS fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100;",
      "optimized_source": "kimi",
      "sf10_rows_match": true,
      "family": "C",
      "patch_plan": {
        "plan_id": "gold_duckdb_early_filter",
        "dialect": "duckdb",
        "description": "Filter dimension tables FIRST, then join to fact tables to reduce expensive joins",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_reason",
              "cte_query_sql": "SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'"
            },
            "description": "Insert CTE 'filtered_reason'"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_returns",
              "cte_query_sql": "SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk"
            },
            "description": "Insert CTE 'filtered_returns' for pre-filtered join"
          },
          {
            "step_id": "s3",
            "op": "replace_from",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "from_sql": "(SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales AS ss JOIN filtered_returns AS fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t"
            },
            "description": "Replace FROM clause with CTE-based JOINs"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) t\n    GROUP BY: ss_customer_sk\n    ORDER BY: sumsales, ss_customer_sk\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_reason  (via CTE_Q_S0_filtered_reason)\n    FROM: reason\n    WHERE [a7afe1b89848b69b]: r_reason_desc = 'duplicate purchase'\n  CTE: filtered_returns  (via CTE_Q_S0_filtered_returns)\n    FROM: store_returns, filtered_reason\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) t\n    GROUP BY: ss_customer_sk\n    ORDER BY: sumsales, ss_customer_sk\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "early_filter"
      ],
      "families": [
        "C"
      ],
      "gap_ids": [
        "CROSS_CTE_PREDICATE_BLINDNESS"
      ],
      "_match_score": 0.368
    },
    {
      "id": "inner_join_conversion",
      "name": "Inner Join Conversion",
      "description": "Convert LEFT JOIN + right-table WHERE filter to INNER JOIN + early filter CTE when the WHERE eliminates NULL rows",
      "verified_speedup": "3.44x",
      "principle": "When a LEFT JOIN is immediately followed by a WHERE filter on the right table that eliminates NULL rows, convert to INNER JOIN + early filter CTE. The WHERE clause already makes the LEFT JOIN behave as an INNER JOIN, but the optimizer keeps the LEFT JOIN semantics (preserving all left rows), wasting work on rows that are filtered out.",
      "example": {
        "opportunity": "INNER_JOIN_CONVERSION",
        "input_slice": "SELECT ss_customer_sk, SUM(act_sales) sumsales\nFROM (SELECT ss_item_sk, ss_ticket_number, ss_customer_sk,\n        CASE WHEN sr_return_quantity IS NOT NULL\n          THEN (ss_quantity-sr_return_quantity)*ss_sales_price\n          ELSE (ss_quantity*ss_sales_price) END act_sales\n      FROM store_sales LEFT OUTER JOIN store_returns\n        ON (sr_item_sk = ss_item_sk AND sr_ticket_number = ss_ticket_number)\n        , reason\n      WHERE sr_reason_sk = r_reason_sk\n        AND r_reason_desc = 'duplicate purchase') t\nGROUP BY ss_customer_sk\nORDER BY sumsales, ss_customer_sk LIMIT 100",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "inner_join_conversion",
              "nodes": {
                "filtered_reason": "SELECT r_reason_sk, r_reason_desc FROM reason WHERE r_reason_desc = 'duplicate purchase'",
                "joined_returns_sales": "SELECT ss.ss_customer_sk, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales ss INNER JOIN store_returns sr ON (ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number) INNER JOIN filtered_reason fr ON sr.sr_reason_sk = fr.r_reason_sk",
                "main_query": "SELECT ss_customer_sk, SUM((ss_quantity - sr_return_quantity) * ss_sales_price) AS sumsales FROM joined_returns_sales GROUP BY ss_customer_sk ORDER BY sumsales ASC, ss_customer_sk ASC LIMIT 100"
              },
              "invariants_kept": [
                "output columns unchanged",
                "grain preserved",
                "same result rows"
              ],
              "expected_speedup": "3.44x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Inner Join Conversion \u2014 when a LEFT JOIN is followed by a WHERE filter on the right table (sr_reason_sk = r_reason_sk), the WHERE already eliminates NULL rows from the LEFT JOIN, making it behave as an INNER JOIN. Converting explicitly to INNER JOIN + early filter CTE lets the optimizer skip preserving left-side rows. Here: filtered reason \u2192 INNER JOIN store_returns + store_sales \u2192 aggregate. The optimizer cannot infer that the WHERE makes LEFT JOIN equivalent to INNER JOIN.",
        "when_not_to_use": "Do NOT convert if CASE WHEN checks for IS NULL on the right-table column \u2014 the NULL branch is semantically meaningful and the LEFT JOIN is intentional."
      },
      "original_sql": "select ss_customer_sk\n            ,sum(act_sales) sumsales\n      from (select ss_item_sk\n                  ,ss_ticket_number\n                  ,ss_customer_sk\n                  ,case when sr_return_quantity is not null then (ss_quantity-sr_return_quantity)*ss_sales_price\n                                                            else (ss_quantity*ss_sales_price) end act_sales\n            from store_sales left outer join store_returns on (sr_item_sk = ss_item_sk\n                                                               and sr_ticket_number = ss_ticket_number)\n                ,reason\n            where sr_reason_sk = r_reason_sk\n              and r_reason_desc = 'duplicate purchase') t\n      group by ss_customer_sk\n      order by sumsales, ss_customer_sk\n LIMIT 100;",
      "optimized_sql": "WITH filtered_reason AS (SELECT r_reason_sk, r_reason_desc FROM reason WHERE r_reason_desc = 'duplicate purchase'), joined_returns_sales AS (SELECT ss.ss_customer_sk, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales ss INNER JOIN store_returns sr ON (ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number) INNER JOIN filtered_reason fr ON sr.sr_reason_sk = fr.r_reason_sk), aggregated AS (SELECT ss_customer_sk, SUM((ss_quantity - sr_return_quantity) * ss_sales_price) AS sumsales FROM joined_returns_sales GROUP BY ss_customer_sk), top_n AS (SELECT ss_customer_sk, sumsales FROM aggregated ORDER BY sumsales ASC, ss_customer_sk ASC LIMIT 100) SELECT ss_customer_sk, sumsales FROM top_n",
      "optimized_source": "swarm_w2",
      "sf10_rows_match": true,
      "family": "F",
      "patch_plan": {
        "plan_id": "gold_duckdb_inner_join_conversion",
        "dialect": "duckdb",
        "description": "Convert LEFT JOIN + right-table WHERE filter to INNER JOIN + early filter CTE when the WHERE eliminates NULL rows",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_reason",
              "cte_query_sql": "SELECT r_reason_sk, r_reason_desc FROM reason WHERE r_reason_desc = 'duplicate purchase'"
            },
            "description": "Insert CTE 'filtered_reason'"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "joined_returns_sales",
              "cte_query_sql": "SELECT ss.ss_customer_sk, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales AS ss INNER JOIN store_returns AS sr ON (ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number) INNER JOIN filtered_reason AS fr ON sr.sr_reason_sk = fr.r_reason_sk"
            },
            "description": "Insert CTE 'joined_returns_sales' for pre-filtered join"
          },
          {
            "step_id": "s3",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "aggregated",
              "cte_query_sql": "SELECT ss_customer_sk, SUM((ss_quantity - sr_return_quantity) * ss_sales_price) AS sumsales FROM joined_returns_sales GROUP BY ss_customer_sk"
            },
            "description": "Insert CTE 'aggregated' for pre-aggregated computation"
          },
          {
            "step_id": "s4",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "top_n",
              "cte_query_sql": "SELECT ss_customer_sk, sumsales FROM aggregated ORDER BY sumsales ASC, ss_customer_sk ASC LIMIT 100"
            },
            "description": "Insert CTE 'top_n'"
          },
          {
            "step_id": "s5",
            "op": "replace_body",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "sql_fragment": "SELECT ss_customer_sk, sumsales FROM top_n"
            },
            "description": "Replace main query body with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) t\n    GROUP BY: ss_customer_sk\n    ORDER BY: sumsales, ss_customer_sk\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_reason  (via CTE_Q_S0_filtered_reason)\n    FROM: reason\n    WHERE [a7afe1b89848b69b]: r_reason_desc = 'duplicate purchase'\n  CTE: joined_returns_sales  (via CTE_Q_S0_joined_returns_sales)\n    FROM: store_sales ss, store_returns sr, filtered_reason fr\n  CTE: aggregated  (via CTE_Q_S0_aggregated)\n    FROM: joined_returns_sales\n    GROUP BY: ss_customer_sk\n  CTE: top_n  (via CTE_Q_S0_top_n)\n    FROM: aggregated\n    ORDER BY: sumsales, ss_customer_sk\n  MAIN QUERY (via Q_S0)\n    FROM: top_n\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "inner_join_conversion"
      ],
      "families": [
        "F"
      ],
      "gap_ids": [
        "LEFT_JOIN_FILTER_ORDER_RIGIDITY"
      ],
      "_match_score": 0.368
    },
    {
      "id": "or_to_union",
      "name": "OR to UNION ALL",
      "description": "Split OR conditions on different columns into UNION ALL branches for better index usage",
      "verified_speedup": "3.17x",
      "principle": "OR-to-UNION Decomposition: split OR conditions on different columns into separate UNION ALL branches, each with a focused predicate. The optimizer can use different access paths per branch instead of a single scan with a complex filter.",
      "example": {
        "opportunity": "OR_TO_UNION + EARLY_FILTER",
        "input_slice": "[main_query]:\nSELECT ca_zip, sum(cs_sales_price)\nFROM catalog_sales, customer, customer_address, date_dim\nWHERE cs_bill_customer_sk = c_customer_sk\n  AND c_current_addr_sk = ca_address_sk\n  AND (substr(ca_zip,1,5) IN ('85669', '86197', '88274', '83405', '86475')\n       OR ca_state IN ('CA','WA','GA')\n       OR cs_sales_price > 500)\n  AND cs_sold_date_sk = d_date_sk\n  AND d_qoy = 1 AND d_year = 2001\nGROUP BY ca_zip ORDER BY ca_zip LIMIT 100",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "or_to_union",
              "nodes": {
                "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_qoy = 1 AND d_year = 2001",
                "filtered_sales": "SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE substr(ca_zip,1,5) IN ('85669', '86197', '88274', '83405', '86475', '85392', '85460', '80348', '81792') UNION ALL SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE ca_state IN ('CA','WA','GA') UNION ALL SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE cs_sales_price > 500",
                "main_query": "SELECT ca_zip, SUM(cs_sales_price) FROM filtered_sales GROUP BY ca_zip ORDER BY ca_zip LIMIT 100"
              },
              "invariants_kept": [
                "output columns unchanged",
                "same rows after aggregation"
              ],
              "expected_speedup": "2.98x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: OR-to-UNION Decomposition \u2014 split OR conditions on different columns into separate UNION ALL branches, each with a focused predicate. The optimizer can use different access paths per branch instead of a single scan with a complex filter. Here: three OR branches (zip codes, states, price threshold) become three UNION ALL branches, each with its own focused predicate. Date filter extracted as shared CTE.",
        "when_not_to_use": "Do not split OR when all branches filter the SAME column on the same table (e.g., t_hour >= 8 OR t_hour <= 17). This duplicates the entire fact table scan for each branch with no selectivity benefit. Only apply when OR conditions span DIFFERENT tables or fundamentally different column families. Also never split into more than 3 UNION branches \u2014 each branch rescans the fact table. Caused 0.59x on a same-column time-range split and historically 0.23x-0.41x on queries with 9+ UNION branches."
      },
      "original_sql": "select ca_zip\n       ,sum(cs_sales_price)\n from catalog_sales\n     ,customer\n     ,customer_address\n     ,date_dim\n where cs_bill_customer_sk = c_customer_sk\n \tand c_current_addr_sk = ca_address_sk \n \tand ( substr(ca_zip,1,5) in ('85669', '86197','88274','83405','86475',\n                                   '85392', '85460', '80348', '81792')\n \t      or ca_state in ('CA','WA','GA')\n \t      or cs_sales_price > 500)\n \tand cs_sold_date_sk = d_date_sk\n \tand d_qoy = 1 and d_year = 2001\n group by ca_zip\n order by ca_zip\n LIMIT 100;",
      "optimized_sql": "WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_qoy = 1 AND d_year = 2001), filtered_sales AS (SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE SUBSTRING(ca_zip, 1, 5) IN ('85669', '86197', '88274', '83405', '86475', '85392', '85460', '80348', '81792') UNION ALL SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE ca_state IN ('CA', 'WA', 'GA') UNION ALL SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE cs_sales_price > 500)\nSELECT ca_zip, SUM(cs_sales_price) FROM filtered_sales GROUP BY ca_zip ORDER BY ca_zip LIMIT 100;",
      "optimized_source": "kimi",
      "sf10_rows_match": true,
      "family": "D",
      "patch_plan": {
        "plan_id": "gold_duckdb_or_to_union",
        "dialect": "duckdb",
        "description": "Split OR conditions on different columns into UNION ALL branches for better index usage",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_dates",
              "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_qoy = 1 AND d_year = 2001"
            },
            "description": "Insert CTE 'filtered_dates' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_sales",
              "cte_query_sql": "SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE SUBSTRING(ca_zip, 1, 5) IN ('85669', '86197', '88274', '83405', '86475', '85392', '85460', '80348', '81792') UNION ALL SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE ca_state IN ('CA', 'WA', 'GA') UNION ALL SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE cs_sales_price > 500"
            },
            "description": "Insert CTE 'filtered_sales' for UNION-based decomposition"
          },
          {
            "step_id": "s3",
            "op": "replace_from",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "from_sql": "filtered_sales"
            },
            "description": "Replace FROM clause with optimized version"
          },
          {
            "step_id": "s4",
            "op": "delete_expr_subtree",
            "target": {
              "by_node_id": "S0",
              "by_anchor_hash": "e25b4365ec270836"
            },
            "description": "Remove WHERE clause (conditions moved to CTEs)"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: catalog_sales, customer, customer_address, date_dim\n    WHERE [e25b4365ec270836]: cs_bill_customer_sk = c_customer_sk AND c_current_addr_sk = ca_address_sk AND (SUBSTRING(ca_zip, ...\n    GROUP BY: ca_zip\n    ORDER BY: ca_zip\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_dates  (via CTE_Q_S0_filtered_dates)\n    FROM: date_dim\n    WHERE [149a822fa5e48a07]: d_qoy = 1 AND d_year = 2001\n  CTE: filtered_sales  (via CTE_Q_S0_filtered_sales)\n  MAIN QUERY (via Q_S0)\n    FROM: filtered_sales\n    GROUP BY: ca_zip\n    ORDER BY: ca_zip\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "or_to_union"
      ],
      "families": [
        "D"
      ],
      "gap_ids": [
        "CROSS_COLUMN_OR_DECOMPOSITION"
      ],
      "_match_score": 0.368
    },
    {
      "id": "rollup_to_union_windowing",
      "name": "ROLLUP to UNION ALL Windowing",
      "description": "Replace GROUP BY ROLLUP with explicit UNION ALL of pre-aggregated CTEs at each hierarchy level, combined with window functions for ranking",
      "verified_speedup": "2.47x",
      "example": {
        "opportunity": "EARLY_FILTER + MATERIALIZE_CTE + UNION_CTE_SPLIT",
        "input_slice": "select sum(ss_net_profit)/sum(ss_ext_sales_price) as gross_margin,\n  i_category, i_class,\n  grouping(i_category)+grouping(i_class) as lochierarchy,\n  rank() over (partition by grouping(i_category)+grouping(i_class),\n    case when grouping(i_class) = 0 then i_category end\n    order by sum(ss_net_profit)/sum(ss_ext_sales_price) asc) as rank_within_parent\nfrom store_sales, date_dim d1, item, store\nwhere d1.d_year = 2002 and d1.d_date_sk = ss_sold_date_sk\n  and i_item_sk = ss_item_sk and s_store_sk = ss_store_sk\n  and s_state in ('SD','TN','GA','SC','MO','AL','MI','OH')\ngroup by rollup(i_category,i_class)\norder by lochierarchy desc, case when lochierarchy = 0 then i_category end, rank_within_parent\nLIMIT 100",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "early_filter",
              "nodes": {
                "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002",
                "filtered_stores": "SELECT s_store_sk FROM store WHERE s_state IN ('SD', 'TN', 'GA', 'SC', 'MO', 'AL', 'MI', 'OH')",
                "item_sums": "SELECT ss_item_sk, SUM(ss_net_profit) AS net_profit, SUM(ss_ext_sales_price) AS sales_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_stores ON ss_store_sk = s_store_sk GROUP BY ss_item_sk",
                "item_aggregates": "SELECT i.i_category, i.i_class, SUM(item_sums.net_profit) AS net_profit, SUM(item_sums.sales_price) AS sales_price FROM item_sums JOIN item i ON item_sums.ss_item_sk = i.i_item_sk GROUP BY i.i_category, i.i_class",
                "detailed": "SELECT net_profit / sales_price AS gross_margin, i_category, i_class, 0 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0",
                "category_summary": "SELECT SUM(net_profit) / SUM(sales_price) AS gross_margin, i_category, NULL AS i_class, 1 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0 GROUP BY i_category",
                "grand_total": "SELECT SUM(net_profit) / SUM(sales_price) AS gross_margin, NULL AS i_category, NULL AS i_class, 2 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0",
                "all_levels": "SELECT * FROM detailed UNION ALL SELECT * FROM category_summary UNION ALL SELECT * FROM grand_total",
                "main_query": "SELECT gross_margin, i_category, i_class, lochierarchy, CASE WHEN lochierarchy < 2 THEN RANK() OVER (PARTITION BY lochierarchy, CASE WHEN lochierarchy = 0 THEN i_category END ORDER BY gross_margin ASC) ELSE 1 END AS rank_within_parent FROM all_levels ORDER BY lochierarchy DESC, CASE WHEN lochierarchy = 0 THEN i_category END, rank_within_parent LIMIT 100"
              },
              "invariants_kept": [
                "output columns unchanged",
                "same hierarchy levels"
              ],
              "expected_speedup": "2.47x",
              "risk": "medium"
            }
          ]
        },
        "key_insight": "ROLLUP generates all grouping levels in a single pass, but the optimizer cannot specialize each level's aggregation. Breaking into explicit UNION ALL of pre-computed CTEs allows each level to use the already-aggregated item_aggregates CTE, and dimension filters are pushed into early CTEs.",
        "when_not_to_use": "Do not use when ROLLUP generates all levels efficiently (small dimension tables, few groups) or when the query genuinely needs all possible grouping set combinations. Only beneficial when specific levels need different optimization paths."
      },
      "original_sql": "select sum(ss_net_profit)/sum(ss_ext_sales_price) as gross_margin, i_category, i_class, grouping(i_category)+grouping(i_class) as lochierarchy, rank() over (partition by grouping(i_category)+grouping(i_class), case when grouping(i_class) = 0 then i_category end order by sum(ss_net_profit)/sum(ss_ext_sales_price) asc) as rank_within_parent from store_sales, date_dim d1, item, store where d1.d_year = 2002 and d1.d_date_sk = ss_sold_date_sk and i_item_sk = ss_item_sk and s_store_sk = ss_store_sk and s_state in ('SD','TN','GA','SC','MO','AL','MI','OH') group by rollup(i_category,i_class) order by lochierarchy desc, case when lochierarchy = 0 then i_category end, rank_within_parent LIMIT 100;",
      "optimized_sql": "WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2002), filtered_stores AS (SELECT s_store_sk FROM store WHERE s_state IN ('SD', 'TN', 'GA', 'SC', 'MO', 'AL', 'MI', 'OH')), item_sums AS (SELECT ss_item_sk, SUM(ss_net_profit) AS net_profit, SUM(ss_ext_sales_price) AS sales_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = filtered_dates.d_date_sk JOIN filtered_stores ON ss_store_sk = filtered_stores.s_store_sk GROUP BY ss_item_sk), item_aggregates AS (SELECT i.i_category, i.i_class, SUM(item_sums.net_profit) AS net_profit, SUM(item_sums.sales_price) AS sales_price FROM item_sums JOIN item i ON item_sums.ss_item_sk = i.i_item_sk GROUP BY i.i_category, i.i_class), detailed AS (SELECT net_profit / sales_price AS gross_margin, i_category, i_class, 0 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0), category_summary AS (SELECT SUM(net_profit) / SUM(sales_price) AS gross_margin, i_category, NULL AS i_class, 1 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0 GROUP BY i_category), grand_total AS (SELECT SUM(net_profit) / SUM(sales_price) AS gross_margin, NULL AS i_category, NULL AS i_class, 2 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0), all_levels AS (SELECT * FROM detailed UNION ALL SELECT * FROM category_summary UNION ALL SELECT * FROM grand_total), ranked AS (SELECT gross_margin, i_category, i_class, lochierarchy, CASE WHEN lochierarchy < 2 THEN RANK() OVER (PARTITION BY lochierarchy, CASE WHEN lochierarchy = 0 THEN i_category END ORDER BY gross_margin ASC) ELSE 1 END AS rank_within_parent FROM all_levels)\nSELECT gross_margin, i_category, i_class, lochierarchy, rank_within_parent FROM ranked ORDER BY lochierarchy DESC, CASE WHEN lochierarchy = 0 THEN i_category END, rank_within_parent LIMIT 100;",
      "optimized_source": "swarm_final_worker",
      "sf10_rows_match": true,
      "family": "C",
      "patch_plan": {
        "plan_id": "gold_duckdb_rollup_to_union_windowing",
        "dialect": "duckdb",
        "description": "Replace GROUP BY ROLLUP with explicit UNION ALL of pre-aggregated CTEs at each hierarchy level, combined with window functions for ranking",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_dates",
              "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002"
            },
            "description": "Insert CTE 'filtered_dates' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_stores",
              "cte_query_sql": "SELECT s_store_sk FROM store WHERE s_state IN ('SD', 'TN', 'GA', 'SC', 'MO', 'AL', 'MI', 'OH')"
            },
            "description": "Insert CTE 'filtered_stores'"
          },
          {
            "step_id": "s3",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "item_sums",
              "cte_query_sql": "SELECT ss_item_sk, SUM(ss_net_profit) AS net_profit, SUM(ss_ext_sales_price) AS sales_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = filtered_dates.d_date_sk JOIN filtered_stores ON ss_store_sk = filtered_stores.s_store_sk GROUP BY ss_item_sk"
            },
            "description": "Insert CTE 'item_sums' for pre-aggregated computation"
          },
          {
            "step_id": "s4",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "item_aggregates",
              "cte_query_sql": "SELECT i.i_category, i.i_class, SUM(item_sums.net_profit) AS net_profit, SUM(item_sums.sales_price) AS sales_price FROM item_sums JOIN item AS i ON item_sums.ss_item_sk = i.i_item_sk GROUP BY i.i_category, i.i_class"
            },
            "description": "Insert CTE 'item_aggregates' for pre-aggregated computation"
          },
          {
            "step_id": "s5",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "detailed",
              "cte_query_sql": "SELECT net_profit / sales_price AS gross_margin, i_category, i_class, 0 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0"
            },
            "description": "Insert CTE 'detailed'"
          },
          {
            "step_id": "s6",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "category_summary",
              "cte_query_sql": "SELECT SUM(net_profit) / SUM(sales_price) AS gross_margin, i_category, NULL AS i_class, 1 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0 GROUP BY i_category"
            },
            "description": "Insert CTE 'category_summary' for pre-aggregated computation"
          },
          {
            "step_id": "s7",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "grand_total",
              "cte_query_sql": "SELECT SUM(net_profit) / SUM(sales_price) AS gross_margin, NULL AS i_category, NULL AS i_class, 2 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0"
            },
            "description": "Insert CTE 'grand_total' for aggregate computation"
          },
          {
            "step_id": "s8",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "all_levels",
              "cte_query_sql": "SELECT * FROM detailed UNION ALL SELECT * FROM category_summary UNION ALL SELECT * FROM grand_total"
            },
            "description": "Insert CTE 'all_levels' for UNION-based decomposition"
          },
          {
            "step_id": "s9",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "ranked",
              "cte_query_sql": "SELECT gross_margin, i_category, i_class, lochierarchy, CASE WHEN lochierarchy < 2 THEN RANK() OVER (PARTITION BY lochierarchy, CASE WHEN lochierarchy = 0 THEN i_category END ORDER BY gross_margin ASC) ELSE 1 END AS rank_within_parent FROM all_levels"
            },
            "description": "Insert CTE 'ranked'"
          },
          {
            "step_id": "s10",
            "op": "replace_body",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "sql_fragment": "SELECT gross_margin, i_category, i_class, lochierarchy, rank_within_parent FROM ranked ORDER BY lochierarchy DESC, CASE WHEN lochierarchy = 0 THEN i_category END, rank_within_parent LIMIT 100"
            },
            "description": "Replace main query body with optimized version"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: store_sales, date_dim d1, item, store\n    WHERE [7fc2787aa25bb4c7]: d1.d_year = 2002 AND d1.d_date_sk = ss_sold_date_sk AND i_item_sk = ss_item_sk AND s_store_sk = s...\n    ORDER BY: lochierarchy, CASE WHEN lochierarchy = 0 THEN i_category END, rank_within_parent\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_dates  (via CTE_Q_S0_filtered_dates)\n    FROM: date_dim\n    WHERE [3bd58edb689ab8bb]: d_year = 2002\n  CTE: filtered_stores  (via CTE_Q_S0_filtered_stores)\n    FROM: store\n    WHERE [4561ce3930df7e56]: s_state IN ('SD', 'TN', 'GA', 'SC', 'MO', 'AL', 'MI', 'OH')\n  CTE: item_sums  (via CTE_Q_S0_item_sums)\n    FROM: store_sales, filtered_dates, filtered_stores\n    GROUP BY: ss_item_sk\n  CTE: item_aggregates  (via CTE_Q_S0_item_aggregates)\n    FROM: item_sums, item i\n    GROUP BY: i.i_category, i.i_class\n  CTE: detailed  (via CTE_Q_S0_detailed)\n    FROM: item_aggregates\n    WHERE [e1bc97291091a8d8]: sales_price <> 0\n  CTE: category_summary  (via CTE_Q_S0_category_summary)\n    FROM: item_aggregates\n    WHERE [e1bc97291091a8d8]: sales_price <> 0\n    GROUP BY: i_category\n  CTE: grand_total  (via CTE_Q_S0_grand_total)\n    FROM: item_aggregates\n    WHERE [e1bc97291091a8d8]: sales_price <> 0\n  CTE: all_levels  (via CTE_Q_S0_all_levels)\n  CTE: ranked  (via CTE_Q_S0_ranked)\n    FROM: all_levels\n  MAIN QUERY (via Q_S0)\n    FROM: ranked\n    ORDER BY: lochierarchy, CASE WHEN lochierarchy = 0 THEN i_category END, rank_within_parent\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "early_filter"
      ],
      "families": [
        "C"
      ],
      "gap_ids": [
        "CROSS_CTE_PREDICATE_BLINDNESS"
      ],
      "_match_score": 0.368
    },
    {
      "id": "CORRELATED_SUBQUERY_TO_WINDOW",
      "name": "Correlated Subquery To Window",
      "description": "Rewrite scalar subqueries computing group aggregates to window functions,\n      eliminating correlated execution and enabling single-pass processing.",
      "category": "window_functions",
      "priority": "medium",
      "verified_speedup": "High - single scan vs N scans",
      "example": {
        "before_sql": "SELECT employee_id, name, salary\n      FROM employees emp\n      WHERE salary > (\n          SELECT AVG(salary) FROM employees \n          WHERE department = emp.department\n      );",
        "after_sql": "SELECT employee_id, name, salary\n      FROM (\n          SELECT *, AVG(salary) OVER (PARTITION BY department) AS dept_avg\n          FROM employees\n      ) emp\n      WHERE salary > dept_avg;",
        "alternative_sql": "",
        "key_insight": "Correlated subquery calculates aggregate for current row's group\n      without changing row count.",
        "transforms": [
          "correlated_subquery_to_window"
        ]
      },
      "metadata": {
        "pg_version": "8.4+",
        "auto_applied_by_pg": "false",
        "research_source": "",
        "notes": ""
      },
      "dialect": "duckdb",
      "transforms": [
        "correlated_subquery_to_window"
      ],
      "_match_score": 0.316
    },
    {
      "id": "CORRELATED_WHERE_TO_DERIVED_TABLE",
      "name": "Correlated Where To Derived Table",
      "description": "Convert correlated subqueries in WHERE clause to derived table joins\n      when PostgreSQL fails to decorrelate automatically.",
      "category": "subquery_transformations",
      "priority": "medium",
      "verified_speedup": "unknown",
      "example": {
        "before_sql": "SELECT * FROM employees emp\n      WHERE salary > (\n          SELECT AVG(salary) FROM employees \n          WHERE department = emp.department\n      );",
        "after_sql": "SELECT emp.*\n      FROM employees emp\n      JOIN (\n          SELECT department, AVG(salary) AS avg_salary\n          FROM employees\n          GROUP BY department\n      ) dept_avg ON emp.department = dept_avg.department\n      WHERE emp.salary > dept_avg.avg_salary;",
        "alternative_sql": "",
        "key_insight": "Queries comparing row values against group aggregates. Common pattern\n      for \"above average\" type queries.",
        "transforms": [
          "correlated_where_to_derived_table"
        ]
      },
      "metadata": {
        "pg_version": "All",
        "auto_applied_by_pg": "false",
        "research_source": "",
        "notes": ""
      },
      "dialect": "duckdb",
      "transforms": [
        "correlated_where_to_derived_table"
      ],
      "_match_score": 0.316
    },
    {
      "id": "TOP_N_PER_GROUP_ROW_NUMBER",
      "name": "Top N Per Group Row Number",
      "description": "Use ROW_NUMBER() window function instead of correlated subquery\n      COUNT for top-N-per-group patterns.",
      "category": "window_functions",
      "priority": "medium",
      "verified_speedup": "unknown",
      "example": {
        "before_sql": "SELECT * FROM items i\n      WHERE (\n          SELECT COUNT(*) FROM items i2\n          WHERE i2.category = i.category \n            AND i2.created_at > i.created_at\n      ) < 3;",
        "after_sql": "SELECT * FROM (\n          SELECT *, ROW_NUMBER() OVER (\n              PARTITION BY category ORDER BY created_at DESC\n          ) AS rank\n          FROM items\n      ) ranked WHERE rank <= 3;",
        "alternative_sql": "",
        "key_insight": "Retrieving multiple rows per group based on ranking.",
        "transforms": [
          "top_n_per_group_row_number"
        ]
      },
      "metadata": {
        "pg_version": "8.4+",
        "auto_applied_by_pg": "false",
        "research_source": "",
        "notes": ""
      },
      "dialect": "duckdb",
      "transforms": [
        "top_n_per_group_row_number"
      ],
      "_match_score": 0.316
    },
    {
      "id": "multi_dimension_prefetch",
      "name": "Multi Dimension Prefetch",
      "description": "Pre-filter multiple dimension tables (date + store) into separate CTEs before joining with fact table",
      "verified_speedup": "2.71x",
      "principle": "Multi-Dimension Prefetch: when multiple dimension tables have selective filters, pre-filter ALL of them into CTEs before the fact table join. Combined selectivity compounds \u2014 each dimension CTE reduces the fact scan further.",
      "example": {
        "opportunity": "MULTI DIMENSION PREFETCH",
        "input_slice": "SELECT s_store_name, s_store_id,\n  sum(CASE WHEN (d_day_name='Sunday') THEN ss_sales_price ELSE NULL END) sun_sales,\n  sum(CASE WHEN (d_day_name='Monday') THEN ss_sales_price ELSE NULL END) mon_sales,\n  sum(CASE WHEN (d_day_name='Tuesday') THEN ss_sales_price ELSE NULL END) tue_sales,\n  sum(CASE WHEN (d_day_name='Wednesday') THEN ss_sales_price ELSE NULL END) wed_sales,\n  sum(CASE WHEN (d_day_name='Thursday') THEN ss_sales_price ELSE NULL END) thu_sales,\n  sum(CASE WHEN (d_day_name='Friday') THEN ss_sales_price ELSE NULL END) fri_sales,\n  sum(CASE WHEN (d_day_name='Saturday') THEN ss_sales_price ELSE NULL END) sat_sales\nFROM date_dim, store_sales, store\nWHERE d_date_sk = ss_sold_date_sk AND s_store_sk = ss_store_sk\n  AND s_gmt_offset = -5 AND d_year = 2000\nGROUP BY s_store_name, s_store_id\nORDER BY s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales\nLIMIT 100",
        "output": {
          "rewrite_sets": [
            {
              "id": "rs_01",
              "transform": "multi_dimension_prefetch",
              "nodes": {
                "filtered_dates": "SELECT d_date_sk, d_day_name FROM date_dim WHERE d_year = 2000",
                "filtered_stores": "SELECT s_store_sk, s_store_name, s_store_id FROM store WHERE s_gmt_offset = -5",
                "main_query": "SELECT s_store_name, s_store_id, SUM(CASE WHEN (d_day_name = 'Sunday') THEN ss_sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN (d_day_name = 'Monday') THEN ss_sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN (d_day_name = 'Tuesday') THEN ss_sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN (d_day_name = 'Wednesday') THEN ss_sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN (d_day_name = 'Thursday') THEN ss_sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN (d_day_name = 'Friday') THEN ss_sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN (d_day_name = 'Saturday') THEN ss_sales_price ELSE NULL END) AS sat_sales FROM store_sales JOIN filtered_dates ON d_date_sk = ss_sold_date_sk JOIN filtered_stores ON s_store_sk = ss_store_sk GROUP BY s_store_name, s_store_id ORDER BY s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales LIMIT 100"
              },
              "invariants_kept": [
                "same result rows",
                "same ordering",
                "same column output"
              ],
              "expected_speedup": "2.71x",
              "risk": "low"
            }
          ]
        },
        "key_insight": "Principle: Multi-Dimension Prefetch \u2014 when multiple dimension tables have selective filters, pre-filter ALL of them into CTEs before the fact join. Each CTE creates a small hash table; the fact scan probes multiple tiny tables instead of large ones. Here: pre-filter both date_dim and store into separate CTEs with only the columns needed for join and grouping.",
        "when_not_to_use": "Do not create dimension CTEs without a WHERE clause that actually reduces rows \u2014 an unfiltered dimension CTE is pure overhead (full scan + materialization for zero selectivity benefit). Avoid on queries with 5+ tables and complex inter-table predicates where forcing join order via CTEs prevents the optimizer from choosing a better plan. Caused 0.85x in an unfiltered-dimension case and 0.77x in a complex multi-table join-reordering case."
      },
      "original_sql": "select s_store_name, s_store_id,\n        sum(case when (d_day_name='Sunday') then ss_sales_price else null end) sun_sales,\n        sum(case when (d_day_name='Monday') then ss_sales_price else null end) mon_sales,\n        sum(case when (d_day_name='Tuesday') then ss_sales_price else  null end) tue_sales,\n        sum(case when (d_day_name='Wednesday') then ss_sales_price else null end) wed_sales,\n        sum(case when (d_day_name='Thursday') then ss_sales_price else null end) thu_sales,\n        sum(case when (d_day_name='Friday') then ss_sales_price else null end) fri_sales,\n        sum(case when (d_day_name='Saturday') then ss_sales_price else null end) sat_sales\n from date_dim, store_sales, store\n where d_date_sk = ss_sold_date_sk and\n       s_store_sk = ss_store_sk and\n       s_gmt_offset = -5 and\n       d_year = 2000 \n group by s_store_name, s_store_id\n order by s_store_name, s_store_id,sun_sales,mon_sales,tue_sales,wed_sales,thu_sales,fri_sales,sat_sales\n LIMIT 100;",
      "optimized_sql": "WITH filtered_dates AS (SELECT d_date_sk, d_day_name FROM date_dim WHERE d_year = 2000), filtered_stores AS (SELECT s_store_sk, s_store_id, s_store_name FROM store WHERE s_gmt_offset = -5), filtered_sales AS (SELECT ss_sales_price, d_day_name, s_store_id, s_store_name FROM store_sales JOIN filtered_dates ON d_date_sk = ss_sold_date_sk JOIN filtered_stores ON s_store_sk = ss_store_sk)\nSELECT s_store_name, s_store_id, SUM(CASE WHEN (d_day_name = 'Sunday') THEN ss_sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN (d_day_name = 'Monday') THEN ss_sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN (d_day_name = 'Tuesday') THEN ss_sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN (d_day_name = 'Wednesday') THEN ss_sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN (d_day_name = 'Thursday') THEN ss_sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN (d_day_name = 'Friday') THEN ss_sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN (d_day_name = 'Saturday') THEN ss_sales_price ELSE NULL END) AS sat_sales FROM filtered_sales GROUP BY s_store_name, s_store_id ORDER BY s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales LIMIT 100;",
      "optimized_source": "dsr1",
      "sf10_rows_match": true,
      "family": "A",
      "patch_plan": {
        "plan_id": "gold_duckdb_multi_dimension_prefetch",
        "dialect": "duckdb",
        "description": "Pre-filter multiple dimension tables (date + store) into separate CTEs before joining with fact table",
        "preconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "postconditions": [
          {
            "kind": "parse_ok"
          }
        ],
        "steps": [
          {
            "step_id": "s1",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_dates",
              "cte_query_sql": "SELECT d_date_sk, d_day_name FROM date_dim WHERE d_year = 2000"
            },
            "description": "Insert CTE 'filtered_dates' for date dimension filtering"
          },
          {
            "step_id": "s2",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_stores",
              "cte_query_sql": "SELECT s_store_sk, s_store_id, s_store_name FROM store WHERE s_gmt_offset = -5"
            },
            "description": "Insert CTE 'filtered_stores'"
          },
          {
            "step_id": "s3",
            "op": "insert_cte",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "cte_name": "filtered_sales",
              "cte_query_sql": "SELECT ss_sales_price, d_day_name, s_store_id, s_store_name FROM store_sales JOIN filtered_dates ON d_date_sk = ss_sold_date_sk JOIN filtered_stores ON s_store_sk = ss_store_sk"
            },
            "description": "Insert CTE 'filtered_sales' for date dimension filtering"
          },
          {
            "step_id": "s4",
            "op": "replace_from",
            "target": {
              "by_node_id": "S0"
            },
            "payload": {
              "from_sql": "filtered_sales"
            },
            "description": "Replace FROM clause with optimized version"
          },
          {
            "step_id": "s5",
            "op": "delete_expr_subtree",
            "target": {
              "by_node_id": "S0",
              "by_anchor_hash": "834e9c75d01a8fa3"
            },
            "description": "Remove WHERE clause (conditions moved to CTEs)"
          }
        ]
      },
      "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: date_dim, store_sales, store\n    WHERE [834e9c75d01a8fa3]: d_date_sk = ss_sold_date_sk AND s_store_sk = ss_store_sk AND s_gmt_offset = -5 AND d_year = 2000\n    GROUP BY: s_store_name, s_store_id\n    ORDER BY: s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_dates  (via CTE_Q_S0_filtered_dates)\n    FROM: date_dim\n    WHERE [48b31a2bf2993b3d]: d_year = 2000\n  CTE: filtered_stores  (via CTE_Q_S0_filtered_stores)\n    FROM: store\n    WHERE [812f7299c6fba51b]: s_gmt_offset = -5\n  CTE: filtered_sales  (via CTE_Q_S0_filtered_sales)\n    FROM: store_sales, filtered_dates, filtered_stores\n  MAIN QUERY (via Q_S0)\n    FROM: filtered_sales\n    GROUP BY: s_store_name, s_store_id\n    ORDER BY: s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
      "dialect": "duckdb",
      "transforms": [
        "multi_dimension_prefetch"
      ],
      "families": [
        "A"
      ],
      "gap_ids": [
        "CROSS_CTE_PREDICATE_BLINDNESS"
      ],
      "_match_score": 0.316
    }
  ],
  "all_available_examples": [
    {
      "id": "aggregate_pushdown",
      "speedup": "42.90x",
      "description": "Pre-aggregate fact table by join key before dimension joins to reduce rows enter"
    },
    {
      "id": "channel_bitmap_aggregation",
      "speedup": "6.24x",
      "description": "Consolidate repeated scans of the same fact table (one per time/channel bucket) "
    },
    {
      "id": "composite_decorrelate_union",
      "speedup": "2.42x",
      "description": "Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT"
    },
    {
      "id": "date_cte_isolate",
      "speedup": "4.00x",
      "description": "Extract date filtering into a separate CTE to enable predicate pushdown and redu"
    },
    {
      "id": "decorrelate",
      "speedup": "2.92x",
      "description": "Convert correlated subquery to separate CTE with GROUP BY, then JOIN"
    },
    {
      "id": "deferred_window_aggregation",
      "speedup": "1.36x",
      "description": "When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joi"
    },
    {
      "id": "early_filter",
      "speedup": "4.00x",
      "description": "Filter dimension tables FIRST, then join to fact tables to reduce expensive join"
    },
    {
      "id": "inner_join_conversion",
      "speedup": "3.44x",
      "description": "Convert LEFT JOIN + right-table WHERE filter to INNER JOIN + early filter CTE wh"
    },
    {
      "id": "intersect_to_exists",
      "speedup": "1.83x",
      "description": "Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join pl"
    },
    {
      "id": "materialize_cte",
      "speedup": "1.37x",
      "description": "Extract repeated subquery patterns into a CTE to avoid recomputation"
    },
    {
      "id": "multi_date_range_cte",
      "speedup": "2.35x",
      "description": "When query uses multiple date_dim aliases with different filters (d1, d2, d3), c"
    },
    {
      "id": "multi_dimension_prefetch",
      "speedup": "2.71x",
      "description": "Pre-filter multiple dimension tables (date + store) into separate CTEs before jo"
    },
    {
      "id": "multi_intersect_exists_cte",
      "speedup": "2.39x",
      "description": "Convert cascading INTERSECT operations into correlated EXISTS subqueries with pr"
    },
    {
      "id": "or_to_union",
      "speedup": "3.17x",
      "description": "Split OR conditions on different columns into UNION ALL branches for better inde"
    },
    {
      "id": "rollup_to_union_windowing",
      "speedup": "2.47x",
      "description": "Replace GROUP BY ROLLUP with explicit UNION ALL of pre-aggregated CTEs at each h"
    },
    {
      "id": "self_join_decomposition",
      "speedup": "4.76x",
      "description": "Split self-joined CTE with different filter values into separate per-filter CTEs"
    },
    {
      "id": "shared_dimension_multi_channel",
      "speedup": "1.30x",
      "description": "Extract shared dimension filters (date, item, promotion) into CTEs when multiple"
    },
    {
      "id": "single_pass_aggregation",
      "speedup": "4.47x",
      "description": "Consolidate multiple subqueries scanning the same table into a single CTE with c"
    },
    {
      "id": "union_cte_split",
      "speedup": "1.36x",
      "description": "Split a generic UNION ALL CTE into specialized CTEs when the main query filters "
    }
  ],
  "engine_profile": {
    "version_tested": "1.1+",
    "profile_type": "engine_profile",
    "briefing_note": "Field intelligence from 88 TPC-DS queries at SF1-SF10. Use it to guide analysis but apply your own judgment \u2014 every query is different.",
    "strengths": [
      {
        "id": "INTRA_SCAN_PREDICATE_PUSHDOWN",
        "summary": "Pushes WHERE filters directly into SEQ_SCAN. Single-table predicates are applied at scan time, zero overhead.",
        "implication": "If EXPLAIN shows the filter inside the scan node, do not create a CTE to push it."
      },
      {
        "id": "SAME_COLUMN_OR",
        "summary": "OR on the SAME column handled in a single scan with range checks.",
        "implication": "Never split same-column ORs into UNION ALL. 0.59x and 0.23x observed."
      },
      {
        "id": "HASH_JOIN_SELECTION",
        "summary": "Selects hash joins automatically. Join ordering sound for 2-4 tables.",
        "implication": "Focus on reducing join inputs, not reordering joins."
      },
      {
        "id": "CTE_INLINING",
        "summary": "Single-reference CTEs inlined automatically. Multi-referenced CTEs may be materialized.",
        "implication": "Single-ref CTEs are free \u2014 use for clarity. CTE-based strategies are low-cost on DuckDB."
      },
      {
        "id": "COLUMNAR_PROJECTION",
        "summary": "Only referenced columns read. Unused columns have zero I/O cost.",
        "implication": "When creating pre-filter CTEs, only SELECT columns downstream needs."
      },
      {
        "id": "PARALLEL_AGGREGATION",
        "summary": "Scans and aggregations parallelized across threads. PERFECT_HASH_GROUP_BY efficient.",
        "implication": "Restructuring simple aggregation queries rarely helps unless reducing input rows."
      },
      {
        "id": "EXISTS_SEMI_JOIN",
        "summary": "EXISTS/NOT EXISTS uses semi-join with early termination.",
        "implication": "NEVER materialize EXISTS into CTEs. 0.14x and 0.54x from this mistake."
      }
    ],
    "gaps": [
      {
        "id": "CROSS_CTE_PREDICATE_BLINDNESS",
        "priority": "HIGH",
        "goal": "SMALLEST_SET_FIRST",
        "detect": "Row counts flat through CTE chain, sharp drop at late filter. 2+ stage CTE chain + late predicate with columns available earlier.",
        "gates": "Filter ratio >5:1 strong, 2:1-5:1 moderate if baseline >200ms. 1 fact = safe, 2 = careful, 3+ = STOP. ROLLUP/WINDOW downstream: CAUTION. CTE already filtered: skip.",
        "what": "Cannot push predicates from the outer query backward into CTE definitions.",
        "why": "CTEs are planned as independent subplans. The optimizer does not trace data lineage through CTE boundaries.",
        "opportunity": "Move selective predicates INTO the CTE definition. Pre-filter dimensions/facts before materialization.",
        "what_worked": [
          "4.76x \u2014 self-joined CTE split into per-month CTEs",
          "4.00x \u2014 date filter moved into CTE",
          "3.77x \u2014 pre-joined filtered dates with fact table",
          "2.97x \u2014 dimension filter applied before LEFT JOIN chain",
          "1.93x \u2014 all dimensions pre-filtered into separate CTEs",
          "1.80x \u2014 prefetch_fact_join on store_sales with date pre-filter"
        ],
        "what_didnt_work": [
          "0.0076x \u2014 cross-joined 3 dim CTEs: Cartesian product",
          "0.50x \u2014 3-way fact join locked optimizer order",
          "0.85x \u2014 CTE blocked ROLLUP pushdown",
          "0.71x \u2014 over-decomposed already-efficient query"
        ],
        "field_notes": [
          "~35% of all wins exploit this gap. Most productive on star-join queries with late dim filters.",
          "NEVER cross-join 3+ dim CTEs \u2014 join each filtered dimension directly to fact table.",
          "Max 2 cascading fact-table CTE chains. Every CTE MUST have a WHERE clause.",
          "Remove dead CTEs when restructuring \u2014 orphaned CTEs still get materialized."
        ]
      },
      {
        "id": "REDUNDANT_SCAN_ELIMINATION",
        "priority": "HIGH",
        "goal": "DONT_REPEAT_WORK",
        "detect": "N separate SEQ_SCAN nodes on same table, identical joins, different bucket filters.",
        "gates": "Identical join structure across all subqueries, max 8 branches, COUNT/SUM/AVG/MIN/MAX only (not STDDEV/VARIANCE/PERCENTILE).",
        "what": "Cannot detect when the same fact table is scanned N times with similar filters across subquery boundaries.",
        "why": "Common Subexpression Elimination doesn't cross scalar subquery boundaries.",
        "opportunity": "Consolidate N subqueries into 1 scan with CASE WHEN / FILTER() inside aggregates.",
        "what_worked": [
          "6.28x \u2014 8 time-bucket subqueries consolidated into 1 scan",
          "4.47x \u2014 15 separate scans consolidated into 1 with 5 CASE buckets",
          "2.27x \u2014 single_pass_aggregation consolidated channel subqueries"
        ],
        "what_didnt_work": [],
        "field_notes": [
          "ZERO REGRESSIONS. DuckDB supports native FILTER clause: COUNT(*) FILTER (WHERE cond).",
          "~37% of benchmark wins exploit this gap (tied with CROSS_CTE_PREDICATE_BLINDNESS)."
        ]
      },
      {
        "id": "CORRELATED_SUBQUERY_PARALYSIS",
        "priority": "LOW",
        "goal": "SETS_OVER_LOOPS",
        "detect": "Nested loop, inner re-executes aggregate per outer row. If hash join on correlation key \u2192 already decorrelated \u2192 STOP.",
        "gates": "NEVER decorrelate EXISTS (0.34x, 0.14x \u2014 semi-join destroyed). Preserve ALL WHERE filters. Check if outer <1000 rows after Phase 1.",
        "what": "Cannot decorrelate correlated aggregate subqueries into GROUP BY + JOIN.",
        "why": "Decorrelation requires recognizing correlated predicate = GROUP BY + JOIN equivalence.",
        "opportunity": "Convert correlated WHERE to CTE with GROUP BY on the correlation column, then JOIN back.",
        "what_worked": [
          "2.92x \u2014 correlated AVG converted to GROUP BY + JOIN"
        ],
        "what_didnt_work": [
          "0.34x \u2014 LEFT JOIN was already semi-join",
          "0.71x \u2014 already decorrelated"
        ],
        "field_notes": [
          "Only applies to correlated scalar subqueries with aggregates. EXISTS correlation handled by semi-join.",
          "When decorrelating, MUST preserve all WHERE filters from original subquery."
        ]
      },
      {
        "id": "CROSS_COLUMN_OR_DECOMPOSITION",
        "priority": "MEDIUM",
        "goal": "MINIMIZE_ROWS_TOUCHED",
        "detect": "Single scan, OR across DIFFERENT columns, 70%+ rows discarded. CRITICAL: same column in all OR arms \u2192 STOP.",
        "gates": "Max 3 branches, cross-column only, no self-join, no nested OR (multiplicative expansion).",
        "what": "Cannot decompose OR conditions spanning different columns into independent targeted scans.",
        "why": "The optimizer evaluates OR as a single filter.",
        "opportunity": "Split cross-column ORs into UNION ALL branches with targeted single-column filters.",
        "what_worked": [
          "6.28x \u2014 8 time-bucket subqueries with distinct hour ranges",
          "3.17x \u2014 (zip OR state OR price) split to 3 targeted branches"
        ],
        "what_didnt_work": [
          "0.23x \u2014 nested OR expansion (3x3=9 branches = 9 fact scans)",
          "0.59x \u2014 same-column OR (engine handles natively)",
          "0.51x \u2014 self-join re-executed per UNION branch"
        ],
        "field_notes": [
          "HIGHEST VARIANCE: biggest win (6.28x) and worst regressions (0.23x) both from or_to_union.",
          "Count resulting branches before committing. 6+ branches almost certainly harmful."
        ]
      },
      {
        "id": "LEFT_JOIN_FILTER_ORDER_RIGIDITY",
        "priority": "HIGH",
        "goal": "ARM_THE_OPTIMIZER",
        "detect": "LEFT JOIN + WHERE on right-table column (proves right non-null).",
        "gates": "No CASE WHEN IS NULL / COALESCE on right-table column.",
        "what": "Cannot infer LEFT JOIN \u2192 INNER when WHERE eliminates NULLs, and cannot reorder LEFT JOINs.",
        "why": "LEFT JOIN must preserve all left rows. Optimizer can't move dimension filter before LEFT JOIN.",
        "opportunity": "Convert LEFT\u2192INNER when WHERE proves right non-null, or pre-filter dimension into CTE.",
        "what_worked": [
          "3.44x \u2014 LEFT\u2192INNER + early filter CTE",
          "2.97x \u2014 filtered dimension FIRST, then LEFT JOIN",
          "1.89x \u2014 dimension isolation before fact join"
        ],
        "what_didnt_work": [],
        "field_notes": [
          "ZERO REGRESSIONS. Only applies to LEFT JOINs \u2014 INNER JOINs freely reordered."
        ]
      },
      {
        "id": "UNION_CTE_SELF_JOIN_DECOMPOSITION",
        "priority": "LOW",
        "goal": "SMALLEST_SET_FIRST",
        "detect": "CTE joined to itself with different WHERE per arm (e.g., period=1 vs period=2).",
        "gates": "2-4 discriminator values, MUST remove original combined CTE after splitting.",
        "what": "UNION ALL CTE self-joined N times \u2014 optimizer materializes full UNION once, probes N times discarding most rows.",
        "why": "Cannot recognize each probe only needs a partition of the UNION result.",
        "opportunity": "Split into N separate CTEs (one per discriminator value).",
        "what_worked": [
          "4.76x \u2014 self_join_decomposition",
          "2.47x \u2014 rollup_to_union_windowing",
          "1.72x avg \u2014 union_cte_split"
        ],
        "what_didnt_work": [
          "0.49x \u2014 orphaned CTE (double materialization)",
          "0.68x \u2014 original CTE kept alongside split"
        ],
        "field_notes": [
          "MUST remove original UNION CTE and redirect all references to split CTEs."
        ]
      },
      {
        "id": "AGGREGATE_BELOW_JOIN_BLINDNESS",
        "priority": "HIGH",
        "goal": "MINIMIZE_ROWS_TOUCHED",
        "detect": "GROUP BY input rows >> distinct keys, aggregate node sits after join.",
        "gates": "GROUP BY keys must be superset of join keys (CORRECTNESS). Reconstruct AVG from SUM/COUNT when pre-aggregating for ROLLUP.",
        "what": "Cannot push GROUP BY below joins when aggregation keys align with join keys.",
        "why": "Optimizer joins first then aggregates, even when pre-aggregating would reduce join input dramatically.",
        "opportunity": "Pre-aggregate fact table by join key BEFORE dimension join.",
        "what_worked": [
          "42.90x \u2014 pre-aggregated inventory by item_sk before item dimension join + ROLLUP"
        ],
        "what_didnt_work": [],
        "field_notes": [
          "ZERO REGRESSIONS. Produced single biggest individual win (42.90x). Check for join\u2192GROUP BY in every star-schema query."
        ]
      },
      {
        "id": "INTERSECT_MATERIALIZATION",
        "priority": "LOW",
        "goal": "SETS_OVER_LOOPS",
        "detect": "INTERSECT between 10K+ row result sets.",
        "gates": "Both sides >1K rows.",
        "what": "INTERSECT is implemented as set materialization + comparison, not as semi-join.",
        "why": "Optimizer doesn't recognize EXISTS semi-join is algebraically equivalent and can short-circuit.",
        "opportunity": "Replace INTERSECT with EXISTS semi-join.",
        "what_worked": [
          "2.7x \u2014 intersect_to_exists"
        ],
        "what_didnt_work": [],
        "field_notes": [
          "ZERO REGRESSIONS. Related: semi_join_exists (1.67x) for full JOIN where joined columns not in output."
        ]
      },
      {
        "id": "WINDOW_BEFORE_JOIN",
        "priority": "LOW",
        "goal": "MINIMIZE_ROWS_TOUCHED",
        "detect": "N WINDOW nodes inside CTEs, same ORDER BY key, CTEs then joined.",
        "gates": "Not LAG/LEAD (depends on pre-join row order), not ROWS BETWEEN with specific frame.",
        "what": "Cannot defer window computation past a join when partition/ordering is preserved.",
        "why": "Computes window in CTE because that's where SQL places it.",
        "opportunity": "Remove windows from CTEs, compute once on joined result.",
        "what_worked": [
          "1.4x \u2014 deferred_window_aggregation"
        ],
        "what_didnt_work": [],
        "field_notes": [
          "ZERO REGRESSIONS. SUM() OVER() naturally skips NULLs \u2014 handles FULL OUTER JOIN gaps."
        ]
      },
      {
        "id": "SHARED_SUBEXPRESSION",
        "priority": "LOW",
        "goal": "DONT_REPEAT_WORK",
        "detect": "Identical subtrees with identical costs scanning same tables. HARD STOP: EXISTS/NOT EXISTS \u2192 NEVER materialize (0.14x).",
        "gates": "NOT EXISTS, subquery is expensive (joins/aggregates), CTE must have WHERE.",
        "what": "May not CSE identical subqueries across different query branches.",
        "why": "Cost is N\u00d7 what single execution would be when CSE fails.",
        "opportunity": "Extract shared subexpression into CTE.",
        "what_worked": [
          "1.4x \u2014 materialize_cte"
        ],
        "what_didnt_work": [
          "0.14x \u2014 EXISTS materialized, semi-join destroyed",
          "0.54x \u2014 correlated EXISTS pairs broken"
        ],
        "field_notes": [
          "Semi-join short-circuit destroyed by CTE materialization. NEVER on EXISTS."
        ]
      }
    ],
    "dialect": "duckdb"
  },
  "constraints": [
    {
      "id": "COMPLETE_OUTPUT",
      "severity": "CRITICAL",
      "description": "The rewritten query must output ALL columns from the original SELECT. Never drop, rename, or reorder output columns.",
      "constraint_rules": [
        {
          "rule": "ALL_COLUMNS_PRESENT",
          "description": "Every column in the original SELECT list must appear in the rewritten SELECT list."
        },
        {
          "rule": "NO_COLUMN_RENAME",
          "description": "Column aliases must be preserved exactly. If the original says 'AS total_sales', the rewrite must use the same alias."
        },
        {
          "rule": "PRESERVE_COLUMN_ORDER",
          "description": "Columns must appear in the same order as the original SELECT list."
        }
      ],
      "prompt_instruction": "The rewritten query must output ALL columns from the original SELECT. Never drop, rename, or reorder output columns. Every column alias must be preserved exactly as in the original."
    },
    {
      "id": "CTE_COLUMN_COMPLETENESS",
      "severity": "CRITICAL",
      "description": "When creating or modifying a CTE, its SELECT list MUST include ALL columns that downstream nodes reference. Check the Node Contracts and Downstream Usage sections before writing any CTE.",
      "failure_rate": "Caused 54% of all execution errors (7 of 13 failures)",
      "observed_failures": [
        {
          "query": "Q21",
          "error": "prefetched_inventory CTE omits i_item_id but main query references it in SELECT and GROUP BY",
          "type": "MISSING_COLUMN_IN_CTE"
        },
        {
          "query": "Q76",
          "error": "filtered_store_dates CTE omits d_year and d_qoy but aggregation CTE uses them in GROUP BY",
          "type": "MISSING_COLUMN_IN_CTE"
        },
        {
          "query": "Q24",
          "error": "filtered_base CTE omits s_state, i_current_price, i_manager_id, i_units, i_size needed by downstream CTEs",
          "type": "MISSING_COLUMN_IN_CTE"
        },
        {
          "query": "Q64",
          "error": "filtered_store_sales CTE omits ss_sold_date_sk needed for JOIN in cross_sales CTE",
          "type": "MISSING_COLUMN_IN_CTE"
        },
        {
          "query": "Q60",
          "error": "ss/ws/cs CTEs reference item.i_item_sk and item.i_category in WHERE but item table not joined in CTE",
          "type": "MISSING_TABLE_IN_CTE"
        },
        {
          "query": "Q13",
          "error": "filtered_store_sales CTE references hd_demo_sk, cd_demo_sk from tables not joined in the CTE",
          "type": "MISSING_TABLE_IN_CTE"
        },
        {
          "query": "Q2",
          "error": "Ambiguous d_date_sk and d_week_seq columns between CTE and re-joined date_dim",
          "type": "AMBIGUOUS_COLUMN_REF"
        }
      ],
      "constraint_rules": [
        {
          "rule": "CHECK_DOWNSTREAM_REFS",
          "description": "Before writing a CTE, check the Downstream Usage section. Every column listed in downstream_refs for that node MUST appear in the CTE's SELECT list."
        },
        {
          "rule": "CHECK_JOIN_COLUMNS",
          "description": "If a downstream node JOINs on a column from this CTE (e.g., ON cte.d_date_sk = ...), that column MUST be in the CTE's SELECT."
        },
        {
          "rule": "CHECK_TABLE_PRESENCE",
          "description": "If a CTE's WHERE clause references columns from a table, that table MUST be in the CTE's FROM/JOIN clause."
        }
      ],
      "prompt_instruction": "CRITICAL: When creating or modifying a CTE, its SELECT list MUST include ALL columns referenced by downstream queries. Check the Node Contracts section: every column in downstream_refs MUST appear in the CTE output. Also ensure: (1) JOIN columns used by consumers are included in SELECT, (2) every table referenced in WHERE is present in FROM/JOIN, (3) no ambiguous column names between the CTE and re-joined tables. Dropping a column that a downstream node needs will cause an execution error."
    },
    {
      "id": "LITERAL_PRESERVATION",
      "severity": "CRITICAL",
      "description": "All literal values (strings, numbers, dates) from the original query MUST be preserved EXACTLY in the rewrite",
      "failure_rate": "100% of Q2-Q16 failures were caused by hallucinated literals",
      "observed_failures": [
        {
          "query": "Q2",
          "original": "d_year = 2001, d_year = 2002",
          "hallucinated": "d_year = 1998, d_year = 1999",
          "type": "YEAR_HALLUCINATION"
        },
        {
          "query": "Q7",
          "original": "cd_gender = 'M', cd_marital_status = 'S', d_year = 2000",
          "hallucinated": "cd_gender = 'F', cd_marital_status = 'W', d_year = 2001",
          "type": "MULTIPLE_LITERAL_HALLUCINATION"
        },
        {
          "query": "Q10",
          "original": "d_year = 2002, ca_county IN ('Rush County', 'Toole County', 'Jefferson County', 'Dona Ana County', 'La Porte County')",
          "hallucinated": "d_year = 2001, ca_county IN ('Storey County', 'Marquette County', 'Warren County', 'Cochran County', 'Kandiyohi County')",
          "type": "YEAR_AND_STRING_HALLUCINATION"
        },
        {
          "query": "Q13",
          "original": "cd_marital_status = 'M', cd_education_status = 'Advanced Degree'",
          "hallucinated": "cd_marital_status = 'D', cd_education_status = 'Unknown'",
          "type": "STRING_HALLUCINATION"
        },
        {
          "query": "Q16",
          "original": "ca_state = 'GA', cc_county = 'Williamson County', d_date BETWEEN '2002-02-01' AND '2002-04-02'",
          "hallucinated": "ca_state = 'WV', cc_county IN ('Ziebach County', ...), d_date BETWEEN '2002-4-01' AND ...",
          "type": "STATE_COUNTY_DATE_HALLUCINATION"
        }
      ],
      "constraint_rules": [
        {
          "rule": "EXACT_STRING_MATCH",
          "description": "String literals in WHERE clauses must be copied character-for-character",
          "examples": [
            "'M' not 'F'",
            "'GA' not 'WV'",
            "'Rush County' not 'Storey County'"
          ]
        },
        {
          "rule": "EXACT_NUMBER_MATCH",
          "description": "Numeric literals (years, amounts, counts) must be copied exactly",
          "examples": [
            "2000 not 2001",
            "2002 not 2001",
            "100.00 not 150.00"
          ]
        },
        {
          "rule": "EXACT_DATE_MATCH",
          "description": "Date literals must be copied exactly, including format",
          "examples": [
            "'2002-02-01' not '2002-4-01'"
          ]
        },
        {
          "rule": "EXACT_LIST_MATCH",
          "description": "IN lists must contain the exact same values in the same order",
          "examples": [
            "IN ('TX', 'OH', 'TX') not IN ('SD', 'KS', 'MI')"
          ]
        }
      ],
      "prompt_instruction": "CRITICAL: When rewriting SQL, you MUST copy ALL literal values (strings, numbers, dates) EXACTLY from the original query. Do NOT invent, substitute, or 'improve' any filter values. If the original says d_year = 2000, your rewrite MUST say d_year = 2000. If the original says ca_state = 'GA', your rewrite MUST say ca_state = 'GA'. Changing these values will produce WRONG RESULTS and the rewrite will be REJECTED."
    },
    {
      "id": "SEMANTIC_EQUIVALENCE",
      "severity": "CRITICAL",
      "description": "The rewritten query MUST return exactly the same rows, columns, and ordering as the original. This is the prime directive.",
      "constraint_rules": [
        {
          "rule": "SAME_ROWS",
          "description": "The rewritten query must produce the same set of rows as the original. No rows may be added or removed."
        },
        {
          "rule": "SAME_COLUMNS",
          "description": "The rewritten query must return the same columns in the same order with the same names and data types."
        },
        {
          "rule": "SAME_ORDERING",
          "description": "If the original query has an ORDER BY clause, the rewritten query must preserve the same ordering."
        }
      ],
      "prompt_instruction": "The rewritten query MUST return exactly the same rows, columns, and ordering as the original. This is the prime directive. Any rewrite that changes the result set \u2014 even by one row, one column, or a different sort order \u2014 is WRONG and will be REJECTED."
    },
    {
      "id": "KEEP_EXISTS_AS_EXISTS",
      "severity": "HIGH",
      "overridable": true,
      "description": "Prefer preserving EXISTS/NOT EXISTS subqueries. Converting to IN/NOT IN risks NULL-handling changes; converting to JOINs risks duplicate rows.",
      "observed_failures": [
        {
          "problem": "Converting NOT EXISTS to NOT IN changes behavior when the subquery column contains NULLs. NOT IN with NULLs returns no rows.",
          "type": "NULL_SEMANTIC_CHANGE"
        },
        {
          "problem": "Converting EXISTS to JOIN can produce duplicate rows when the subquery matches multiple rows per outer row.",
          "type": "DUPLICATE_ROW_INTRODUCTION"
        }
      ],
      "constraint_rules": [
        {
          "rule": "AVOID_EXISTS_TO_IN",
          "description": "Avoid converting EXISTS/NOT EXISTS to IN/NOT IN unless the subquery column is provably NOT NULL (has a NOT NULL constraint or is a primary key)."
        },
        {
          "rule": "EXISTS_TO_JOIN_NEEDS_DISTINCT",
          "description": "Converting EXISTS to JOIN requires SELECT DISTINCT or GROUP BY to prevent row duplication when the subquery matches multiple rows per outer row."
        }
      ],
      "override_conditions": [
        "The subquery join column has a NOT NULL constraint or is a primary key (safe for IN conversion)",
        "The subquery returns at most 1 row per outer row (1:1 relationship, safe for JOIN)",
        "EXISTS is converted to JOIN + DISTINCT/GROUP BY to explicitly handle duplicates"
      ],
      "prompt_instruction": "DEFAULT: Preserve EXISTS/NOT EXISTS as-is. NOT EXISTS\u2192NOT IN breaks with NULLs; EXISTS\u2192JOIN can duplicate rows. HOWEVER: if the join column is NOT NULL (PK or explicit constraint), EXISTS\u2192IN is safe. If the subquery is 1:1 with the outer query, EXISTS\u2192JOIN is safe. The exploration worker MAY convert EXISTS with written proof of NULL safety or 1:1 cardinality."
    },
    {
      "id": "NO_CROSS_JOIN_DIMENSIONS",
      "severity": "HIGH",
      "overridable": true,
      "description": "Avoid CROSS JOINing dimension tables into a single CTE. The Cartesian product can explode row counts and prevent index use on fact tables.",
      "failure_rate": "Caused 0.0076x regression on Q080 (132x slower) when 3 dimensions were cross-joined",
      "observed_failures": [
        {
          "query": "Q080_multi",
          "regression": "0.0076x (57ms -> 7500ms)",
          "broken_rewrite": "filtered_dims AS (SELECT d_date_sk, i_item_sk, p_promo_sk FROM date_dim CROSS JOIN item CROSS JOIN promotion WHERE ...)",
          "problem": "CROSS JOIN created 120K-row CTE (30 \u00d7 200 \u00d7 20), then 3-key join prevented index use on fact tables.",
          "type": "CROSS_JOIN_DIMENSION_EXPLOSION"
        }
      ],
      "constraint_rules": [
        {
          "rule": "PREFER_SEPARATE_DIMENSION_CTES",
          "description": "Each dimension table should generally be its own CTE with its own filter. Combining via CROSS JOIN risks Cartesian explosion."
        }
      ],
      "override_conditions": [
        "Only 2 dimensions are joined (not 3+) AND the product is <1000 rows",
        "The dimensions share a foreign key (not a true Cartesian \u2014 it's a filtered JOIN)",
        "The combined CTE replaces N separate semi-joins with 1 multi-key join on the fact table"
      ],
      "prompt_instruction": "DEFAULT: Keep each dimension as a SEPARATE CTE (filtered_date, filtered_item, etc.). Cross-joining 3 dimensions caused 0.0076x on Q080 (30\u00d7200\u00d720 = 120K rows). HOWEVER: joining exactly 2 small dimensions (<1000 row product) via a foreign key (not Cartesian) may be acceptable if it reduces total join count on the fact table. The exploration worker MAY attempt a 2-dimension join with size estimate. Never cross-join 3+ dimensions."
    },
    {
      "id": "NO_MATERIALIZE_EXISTS",
      "severity": "HIGH",
      "overridable": true,
      "description": "Avoid converting EXISTS/NOT EXISTS subqueries into materialized CTEs with full table scans. EXISTS uses semi-join short-circuiting which is typically more efficient.",
      "failure_rate": "Caused 0.14x and 0.54x regressions (7x and 2x slowdowns)",
      "observed_failures": [
        {
          "query": "Q16",
          "regression": "0.14x (18ms -> 126ms)",
          "original": "EXISTS (SELECT * FROM catalog_sales cs2 WHERE cs1.cs_order_number = cs2.cs_order_number AND cs1.cs_warehouse_sk <> cs2.cs_warehouse_sk)",
          "broken_rewrite": "WITH multi_warehouse_orders AS (SELECT DISTINCT cs_order_number FROM catalog_sales GROUP BY cs_order_number HAVING MIN(cs_warehouse_sk) <> MAX(cs_warehouse_sk))",
          "type": "EXISTS_TO_FULL_SCAN_CTE"
        },
        {
          "query": "Q95",
          "regression": "0.54x (390ms -> 728ms)",
          "original": "EXISTS(SELECT 1 FROM ws_wh WHERE ws_wh.ws_order_number = ws1.ws_order_number)",
          "broken_rewrite": "WITH multi_warehouse_orders AS (SELECT DISTINCT ws_order_number FROM ws_wh)",
          "type": "EXISTS_TO_MATERIALIZED_DISTINCT"
        }
      ],
      "observed_successes": [
        {
          "query": "Q14",
          "speedup": "1.83x",
          "context": "intersect_to_exists: INTERSECT converted to EXISTS for semi-join short-circuit. Shows EXISTS restructuring CAN help when applied in the right direction."
        }
      ],
      "constraint_rules": [
        {
          "rule": "PREFER_EXISTS_SEMI_JOIN",
          "description": "EXISTS and NOT EXISTS use semi-join optimization that short-circuits after finding the first match. Converting to materialized CTEs usually forces a full scan."
        },
        {
          "rule": "AVOID_FULL_TABLE_DISTINCT_CTE",
          "description": "Avoid creating CTEs like SELECT DISTINCT key FROM large_table to replace EXISTS. The CTE scans the entire table; EXISTS can stop after one match."
        }
      ],
      "override_conditions": [
        "The EXISTS subquery is correlated and executed many times (optimizer fails to decorrelate it)",
        "The CTE would be small (<10K rows) and probed multiple times, amortizing materialization cost",
        "The EXISTS is inside a UNION ALL branch where each branch re-executes the same correlated subquery"
      ],
      "prompt_instruction": "DEFAULT: Keep EXISTS/NOT EXISTS as-is \u2014 semi-join short-circuiting is usually faster than materialization. Converting to CTEs caused 0.14x on Q16 and 0.54x on Q95. HOWEVER: if the correlated EXISTS is executed many times and the optimizer fails to decorrelate it, materializing into a small CTE (<10K rows) probed via JOIN may help. The exploration worker MAY attempt this with reasoning about correlation frequency and CTE size."
    },
    {
      "id": "NO_UNFILTERED_DIMENSION_CTE",
      "severity": "HIGH",
      "description": "Never create a 'filtered' dimension CTE that has no WHERE clause. A CTE that selects all rows from a dimension table is pure materialization overhead with zero filtering benefit.",
      "failure_rate": "Caused 0.85x regression on Q67",
      "observed_failures": [
        {
          "query": "Q67",
          "regression": "0.85x (4509ms -> 5291ms)",
          "broken_rewrite": "filtered_stores AS (SELECT s_store_sk, s_store_id FROM store), filtered_items AS (SELECT i_item_sk, i_category, i_class, i_brand, i_product_name FROM item)",
          "problem": "Both CTEs select ALL rows - no WHERE clause, no filtering. Pure overhead.",
          "type": "UNFILTERED_DIMENSION_CTE"
        }
      ],
      "constraint_rules": [
        {
          "rule": "CTE_MUST_FILTER",
          "description": "Every dimension CTE you create MUST have a WHERE clause that reduces the row count. If a dimension table has no filter to apply, do NOT extract it into a CTE."
        },
        {
          "rule": "COLUMN_PROJECTION_IS_NOT_FILTERING",
          "description": "Selecting a subset of columns (SELECT a, b FROM table) is NOT filtering. The CTE still materializes all rows. Only a WHERE clause reduces rows."
        }
      ],
      "prompt_instruction": "Every CTE you create must include a WHERE clause that actually reduces row count. Selecting fewer columns is not filtering \u2014 the CTE still materializes every row. If a dimension table has no predicate to push down, leave it as a direct join in the main query instead of wrapping it in a CTE."
    },
    {
      "id": "OR_TO_UNION_GUARD",
      "severity": "HIGH",
      "overridable": true,
      "description": "Guard rails for or_to_union: branches should have different access paths (not same column) and be limited to 3 or fewer.",
      "observed_failures": [
        {
          "query": "Q90",
          "regression": "0.59x (16ms -> 27ms)",
          "original": "WHERE t.t_hour BETWEEN 10 AND 11 OR t.t_hour BETWEEN 16 AND 17",
          "broken_rewrite": "UNION ALL of two separate web_sales scans (one for AM hours, one for PM hours)",
          "problem": "Doubles the fact table scan. The OR on t_hour is trivial for the optimizer - it just checks two ranges on one column.",
          "type": "UNION_SAME_COLUMN_OR"
        },
        {
          "query": "Q13",
          "regression": "0.23x",
          "problem": "9 UNION branches from nested OR expansion (3 conditions x 3 values) caused 9x fact table scans.",
          "type": "UNION_BRANCH_EXPLOSION"
        },
        {
          "query": "Q48",
          "regression": "0.41x",
          "problem": "9 UNION branches from nested OR expansion caused severe regression from multiplied fact table scans.",
          "type": "UNION_BRANCH_EXPLOSION"
        }
      ],
      "observed_successes": [
        {
          "query": "Q88",
          "speedup": "6.28x",
          "context": "8 time-bucket subqueries on store_sales, each filtering distinct hour ranges via different WHERE clauses. Branches access genuinely different row subsets."
        },
        {
          "query": "Q10",
          "speedup": "1.49x",
          "context": "OR across different dimension table lookups creating distinct access paths."
        },
        {
          "query": "Q45",
          "speedup": "1.35x",
          "context": "OR conditions reference different tables/subqueries."
        }
      ],
      "constraint_rules": [
        {
          "rule": "OR_TO_UNION_REQUIRES_DIFFERENT_PATHS",
          "description": "or_to_union is most beneficial when OR conditions create fundamentally different access paths (e.g., across different tables or between a correlated subquery and a direct filter). Same-column ORs on trivial ranges are usually handled efficiently by the optimizer as a single scan."
        },
        {
          "rule": "OR_TO_UNION_PREFER_3_OR_FEWER",
          "description": "Prefer 3 or fewer UNION ALL branches. Nested ORs that expand into 9+ combinations are almost always harmful. 4-5 branches may be acceptable if each accesses genuinely different row subsets."
        }
      ],
      "override_conditions": [
        "Branches access genuinely different row subsets (different WHERE predicates, not just same-column ranges)",
        "Total branch count stays at 4-5 or fewer (not Cartesian expansion of nested ORs)",
        "EXPLAIN shows the fact table is already scanned N times in baseline, so splitting does not increase scan count",
        "Each branch filters to <20% of fact table rows (high selectivity per branch)"
      ],
      "prompt_instruction": "DEFAULT: Prefer 3 or fewer UNION ALL branches with different access paths per branch. Same-column ORs on simple ranges are usually handled efficiently by the optimizer. Nested ORs that expand into 4+ branches (e.g., 3 x 3 = 9 combinations) caused 0.23x-0.41x regressions. HOWEVER: or_to_union achieved 6.28x on Q88 where branches had genuinely different row subsets. The exploration worker MAY try 4-5 branches if each branch has distinct access paths and high selectivity. Provide reasoning."
    },
    {
      "id": "OR_TO_UNION_SELF_JOIN",
      "severity": "HIGH",
      "overridable": true,
      "description": "Avoid or_to_union on queries with self-joins. Splitting OR conditions on self-joined tables can create multiple independent scans that cannot share the self-join optimization.",
      "observed_failures": [
        {
          "query": "Q23",
          "regression": "0.51x",
          "problem": "Self-join on store_sales was split into separate UNION branches, each requiring its own full self-join, doubling execution time.",
          "type": "SELF_JOIN_SPLIT"
        }
      ],
      "constraint_rules": [
        {
          "rule": "AVOID_OR_TO_UNION_ON_SELF_JOINS",
          "description": "If a query contains a self-join (same table aliased twice), or_to_union is risky because the self-join must typically remain in a single query block to share the scan."
        }
      ],
      "override_conditions": [
        "The OR conditions are on a column NOT involved in the self-join predicate",
        "The self-join aliases have independent WHERE filters that make each branch selective",
        "EXPLAIN shows the self-join is already executed multiple times in baseline"
      ],
      "prompt_instruction": "DEFAULT: Avoid or_to_union when the query contains a self-join (same table with different aliases). Splitting forces each branch to independently perform the self-join (observed 0.51x on Q23). HOWEVER: if the OR conditions target a column not involved in the self-join predicate, or if each alias already has independent selective filters, splitting may still help. The exploration worker MAY attempt this with written reasoning about why the structural context differs from Q23."
    },
    {
      "id": "REMOVE_REPLACED_CTES",
      "severity": "HIGH",
      "description": "When creating replacement CTEs, always remove the original CTEs from the WITH clause. Leaving dead/unused CTEs causes unnecessary materialization overhead.",
      "failure_rate": "Contributed to 0.49x and 0.68x regressions",
      "observed_failures": [
        {
          "query": "Q31",
          "regression": "0.49x (99ms -> 201ms)",
          "problem": "Created new store_sales_agg and web_sales_agg CTEs but left the original ss and ws CTEs in the WITH clause. Both old and new CTEs coexist, wasting materialization.",
          "type": "DEAD_CTE_OVERHEAD"
        },
        {
          "query": "Q74",
          "regression": "0.68x (493ms -> 724ms)",
          "problem": "Created 4 new year-specific CTEs but left the original year_total, year_total_store, year_total_web CTEs. Total of 8 CTEs instead of 4.",
          "type": "DEAD_CTE_OVERHEAD"
        }
      ],
      "constraint_rules": [
        {
          "rule": "REPLACE_NOT_APPEND",
          "description": "When your rewrite replaces a CTE with a new version, the original CTE node must be removed or overwritten. Do not define both the old and new CTE."
        }
      ],
      "prompt_instruction": "When creating replacement CTEs, overwrite the original by using the same node_id in your rewrite_sets, or ensure the original is removed from the WITH clause. Every CTE in the final query should be actively used \u2014 dead CTEs still get materialized and waste resources (caused 0.49x on Q31, 0.68x on Q74)."
    },
    {
      "id": "UNION_CTE_SPLIT_MUST_REPLACE",
      "severity": "HIGH",
      "description": "When splitting a UNION into separate CTEs, the original UNION must be eliminated. Creating CTEs that duplicate the UNION branches while keeping the original UNION doubles the work.",
      "observed_failures": [
        {
          "query": "multiple",
          "problem": "UNION branches were extracted into CTEs but the original UNION ALL remained in the main query, causing each branch to be computed twice.",
          "type": "DUPLICATE_UNION"
        }
      ],
      "constraint_rules": [
        {
          "rule": "CTE_SPLIT_REPLACES_UNION",
          "description": "When applying union_cte_split, the final query must reference the CTEs instead of the original UNION. The total number of UNION ALL operations should not increase."
        }
      ],
      "prompt_instruction": "When applying union_cte_split (splitting UNION into CTEs), the original UNION must be eliminated from the main query. The main query should reference the split CTEs, not duplicate the UNION branches. If the rewritten query has more UNION ALL operations than the original, the rewrite is incorrect."
    },
    {
      "id": "DECORRELATE_MUST_FILTER_FIRST",
      "severity": "MEDIUM",
      "description": "When decorrelating a subquery into a JOIN, the replacement JOIN must include a selective filter. A decorrelation that produces an unfiltered cross-product is worse than the original correlated subquery.",
      "observed_failures": [
        {
          "query": "multiple",
          "problem": "Correlated subquery was converted to JOIN without carrying over the original WHERE filters, producing a much larger intermediate result than the correlated version.",
          "type": "UNFILTERED_DECORRELATION"
        }
      ],
      "constraint_rules": [
        {
          "rule": "DECORRELATE_PRESERVES_FILTERS",
          "description": "When converting a correlated subquery to a JOIN + GROUP BY CTE, all WHERE conditions from the original subquery must be preserved in the CTE or JOIN condition. The replacement must not produce more rows than the original correlated subquery."
        }
      ],
      "prompt_instruction": "When decorrelating a correlated subquery into a JOIN, ensure all original WHERE filters are preserved in the replacement CTE or JOIN condition. A decorrelation without selective filters creates a cross-product that is larger than the original per-row correlated execution. The replacement CTE must filter to at most the same cardinality as the original subquery."
    },
    {
      "id": "DIMENSION_CTE_SAME_COLUMN_OR",
      "severity": "MEDIUM",
      "description": "Do not extract dimension CTE filters when the WHERE clause has OR conditions on the same column. Same-column ORs are efficiently handled by the optimizer in a single scan; CTE extraction adds overhead without benefit.",
      "observed_failures": [
        {
          "query": "Q37",
          "regression": "0.89x",
          "problem": "OR conditions on item.i_current_price ranges were extracted into separate CTEs, adding CTE materialization overhead without improving selectivity.",
          "type": "SAME_COLUMN_OR_CTE"
        }
      ],
      "constraint_rules": [
        {
          "rule": "KEEP_SAME_COLUMN_OR_INLINE",
          "description": "When OR conditions filter the same column (e.g., i_current_price BETWEEN X AND Y OR i_current_price BETWEEN A AND B), keep them inline in WHERE. Only extract dimension CTEs when filters span different columns or tables."
        }
      ],
      "prompt_instruction": "Do not create dimension CTEs to isolate OR conditions that filter the same column. The optimizer handles same-column ORs efficiently in a single scan. Only apply dimension_cte_isolate when filters span different columns or different dimension tables."
    },
    {
      "id": "EARLY_FILTER_CTE_BEFORE_CHAIN",
      "severity": "MEDIUM",
      "description": "Early filter CTEs must be referenced by the main query chain. An orphaned CTE that pre-filters data but is never joined back into the main query wastes materialization effort.",
      "observed_failures": [
        {
          "query": "multiple",
          "problem": "Early filter CTEs were created but not referenced in subsequent JOINs, resulting in wasted CTE materialization plus the original unfiltered joins remaining.",
          "type": "ORPHANED_FILTER_CTE"
        }
      ],
      "constraint_rules": [
        {
          "rule": "FILTER_CTE_MUST_BE_REFERENCED",
          "description": "Every early_filter CTE must be referenced by at least one downstream CTE or the main query. If a filter CTE is created, the original unfiltered table reference must be replaced with the CTE reference."
        }
      ],
      "prompt_instruction": "When creating an early_filter CTE, ensure it is actually referenced in the main query chain. The original unfiltered table reference must be replaced with the CTE reference. Do not create CTEs that filter a table if the main query still joins the original unfiltered table \u2014 this adds overhead without benefit."
    },
    {
      "id": "EXPLICIT_JOINS",
      "severity": "MEDIUM",
      "description": "Convert comma-separated implicit joins to explicit JOIN ... ON syntax. This gives the optimizer better join-order freedom.",
      "constraint_rules": [
        {
          "rule": "PREFER_EXPLICIT_JOIN",
          "description": "When the original query uses comma-separated tables with WHERE conditions for joining, convert to explicit JOIN ... ON syntax."
        }
      ],
      "prompt_instruction": "Convert comma-separated implicit joins to explicit JOIN ... ON syntax. This gives the optimizer better join-order freedom."
    },
    {
      "id": "MIN_BASELINE_THRESHOLD",
      "severity": "MEDIUM",
      "overridable": true,
      "description": "Be conservative with CTE-based transforms on queries with very short baseline runtimes. CTE materialization overhead can dominate when the query is already fast.",
      "failure_rate": "Caused 0.14x-0.59x regressions on queries under 50ms",
      "observed_failures": [
        {
          "query": "Q25",
          "regression": "0.50x (31ms -> 62ms)",
          "baseline_ms": 31,
          "transform": "prefetch_fact_join with 6 CTEs",
          "type": "CTE_OVERHEAD_ON_FAST_QUERY"
        },
        {
          "query": "Q90",
          "regression": "0.59x (16ms -> 27ms)",
          "baseline_ms": 16,
          "transform": "multi_dimension_prefetch with 4 CTEs + UNION ALL",
          "type": "CTE_OVERHEAD_ON_FAST_QUERY"
        },
        {
          "query": "Q16",
          "regression": "0.14x (18ms -> 126ms)",
          "baseline_ms": 18,
          "transform": "materialize_cte with 2 full-scan CTEs",
          "type": "CTE_OVERHEAD_ON_FAST_QUERY"
        }
      ],
      "constraint_rules": [
        {
          "rule": "CHECK_BASELINE_RUNTIME",
          "description": "If the Execution Plan shows estimated or actual runtime under 50ms, prefer minimal rewrites. DuckDB already optimizes simple star-join patterns efficiently."
        }
      ],
      "override_conditions": [
        "The transform reduces scan count (e.g., 3 scans \u2192 1 scan) even on a fast query",
        "The query is a component of a larger pipeline where cumulative savings matter",
        "The transform simplifies the query structure without adding CTEs (e.g., pushdown, decorrelate)"
      ],
      "prompt_instruction": "DEFAULT: If baseline is under 100ms, prefer minimal rewrites. CTE materialization overhead (hash tables, intermediate storage) can exceed filtering benefit on fast queries. HOWEVER: transforms that reduce scan count without adding CTEs (pushdown, decorrelate) may still help. The exploration worker MAY attempt structural changes on fast queries if the transform is scan-reducing, not CTE-adding."
    },
    {
      "id": "PREFETCH_MULTI_FACT_CHAIN",
      "severity": "MEDIUM",
      "overridable": true,
      "description": "Prefer limiting cascading fact-table CTEs to 2. Each additional CTE materializes a large intermediate result.",
      "observed_failures": [
        {
          "query": "Q4",
          "regression": "0.78x",
          "problem": "3 cascading fact-table CTEs (store_sales -> catalog_sales -> web_sales) created excessive intermediate materialization.",
          "type": "FACT_CHAIN_OVERHEAD"
        }
      ],
      "constraint_rules": [
        {
          "rule": "PREFER_2_OR_FEWER_FACT_CTES",
          "description": "When pre-joining fact tables with filtered dimensions in CTEs, 2 cascading fact CTEs is safe. A third adds risk of excessive materialization."
        }
      ],
      "override_conditions": [
        "Each fact CTE has highly selective filters (<5% of rows survive), keeping intermediate sizes small",
        "The 3rd CTE reads from a dimension-filtered result, not a raw fact table",
        "The query already has 3+ separate fact table scans in baseline \u2014 chaining cannot be worse"
      ],
      "prompt_instruction": "DEFAULT: Limit to 2 cascading fact-table CTEs. A 3rd CTE caused 0.78x on Q4 from excessive materialization. HOWEVER: if each CTE applies highly selective filters (<5% row survival), the intermediate results stay small. The exploration worker MAY try a 3-CTE chain if filters are selective and baseline already has 3+ separate scans."
    },
    {
      "id": "SINGLE_PASS_AGGREGATION_LIMIT",
      "severity": "MEDIUM",
      "overridable": true,
      "description": "Prefer limiting single-pass aggregation to 8 CASE branches. Beyond 8, CASE evaluation overhead may reduce benefit.",
      "observed_failures": [
        {
          "query": "Q88",
          "note": "8 CASE branches (time slices) was the maximum tested that still showed improvement (6.28x). More branches are untested, not proven harmful.",
          "type": "CASE_BRANCH_LIMIT"
        }
      ],
      "observed_successes": [
        {
          "query": "Q88",
          "speedup": "6.28x",
          "context": "8 CASE branches consolidating 8 separate time-bucket subqueries into a single scan."
        },
        {
          "query": "Q9",
          "speedup": "4.47x",
          "context": "5 CASE branches consolidating repeated store_sales scans."
        }
      ],
      "constraint_rules": [
        {
          "rule": "PREFER_8_OR_FEWER_CASE_BRANCHES",
          "description": "When consolidating repeated scans into CASE WHEN aggregates, 8 or fewer branches is well-tested. More branches are untested territory."
        }
      ],
      "override_conditions": [
        "The original query has 9-12 repeated scans on the same fact table (high consolidation value)",
        "Each CASE branch is a simple equality check (low per-row overhead)",
        "The fact table is large (>1M rows) so scan reduction dominates CASE evaluation cost"
      ],
      "prompt_instruction": "DEFAULT: Use at most 8 CASE branches for single_pass_aggregation (tested up to 8 at 6.28x on Q88). HOWEVER: 9-12 branches with simple equality checks on large fact tables may still net positive. The exploration worker MAY try 9-12 branches if the scan reduction value is high. Beyond 12 branches is not recommended."
    }
  ],
  "regression_warnings": [
    {
      "id": "regression_over_decomposed_cte",
      "type": "regression",
      "name": "regression: pre-aggregated CTE over-decomposed (0.71x)",
      "description": "Do not pre-aggregate GROUP BY results into CTEs when the query uses them in a correlated comparison (e.g., customer return > 1.2x store average). The optimizer can compute aggregates incrementally with filter pushdown; materialization loses this.",
      "verified_speedup": "0.71x",
      "query_id": "",
      "transform_attempted": "decorrelate",
      "regression_mechanism": "Pre-computed customer_total_return (GROUP BY customer, store) and store_avg_return (GROUP BY store) as separate CTEs. The original correlated subquery computed the per-store average incrementally during the customer scan, filtering as it goes. Materializing forces full aggregation of ALL stores before any filtering.",
      "original_sql": "-- start query 1 in stream 0 using template query1.tpl\nwith customer_total_return as\n(select sr_customer_sk as ctr_customer_sk\n,sr_store_sk as ctr_store_sk\n,sum(SR_FEE) as ctr_total_return\nfrom store_returns\n,date_dim\nwhere sr_returned_date_sk = d_date_sk\nand d_year =2000\ngroup by sr_customer_sk\n,sr_store_sk)\n select c_customer_id\nfrom customer_total_return ctr1\n,store\n,customer\nwhere ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2\nfrom customer_total_return ctr2\nwhere ctr1.ctr_store_sk = ctr2.ctr_store_sk)\nand s_store_sk = ctr1.ctr_store_sk\nand s_state = 'SD'\nand ctr1.ctr_customer_sk = c_customer_sk\norder by c_customer_id\n LIMIT 100;\n\n-- end query 1 in stream 0 using template query1.tpl",
      "example": {
        "before_sql": "-- start query 1 in stream 0 using template query1.tpl\nwith customer_total_return as\n(select sr_customer_sk as ctr_customer_sk\n,sr_store_sk as ctr_store_sk\n,sum(SR_FEE) as ctr_total_return\nfrom store_returns\n,date_dim\nwhere sr_returned_date_sk = d_date_sk\nand d_year =2000\ngroup by sr_customer_sk\n,sr_store_sk)\n select c_customer_id\nfrom customer_total_return ctr1\n,store\n,customer\nwhere ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2\nfrom customer_total_return ctr2\nwhere ctr1.ctr_store_sk = ctr2.ctr_store_sk)\nand s_store_sk = ctr1.ctr_store_sk\nand s_state = 'SD'\nand ctr1.ctr_customer_sk = c_customer_sk\norder by c_customer_id\n LIMIT 100;\n\n-- end query 1 in stream 0 using template query1.tpl",
        "after_sql": "WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2000), filtered_stores AS (SELECT s_store_sk FROM store WHERE s_state = 'SD'), filtered_returns AS (SELECT sr.sr_customer_sk, sr.sr_store_sk, sr.SR_FEE FROM store_returns AS sr JOIN filtered_dates ON sr.sr_returned_date_sk = d_date_sk JOIN filtered_stores ON sr.sr_store_sk = s_store_sk), customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(SR_FEE) AS ctr_total_return FROM filtered_returns GROUP BY sr_customer_sk, sr_store_sk), store_avg_return AS (SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_return_threshold FROM customer_total_return GROUP BY ctr_store_sk)\nSELECT c.c_customer_id FROM customer_total_return AS ctr1 JOIN store_avg_return AS sar ON ctr1.ctr_store_sk = sar.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c.c_customer_sk WHERE ctr1.ctr_total_return > sar.avg_return_threshold ORDER BY c.c_customer_id LIMIT 100",
        "key_insight": "Do not pre-aggregate GROUP BY results into CTEs when the query uses them in a correlated comparison (e.g., customer return > 1.2x store average). The optimizer can compute aggregates incrementally with filter pushdown; materialization loses this."
      },
      "dialect": "duckdb",
      "transforms": [
        "decorrelate"
      ],
      "families": [
        "B"
      ],
      "family": "B",
      "gap_ids": [
        "CORRELATED_SUBQUERY_PARALYSIS"
      ],
      "_tag_score": 0.9473684210526315
    },
    {
      "id": "regression_window_bottleneck_cte",
      "type": "regression",
      "name": "regression: window bottleneck unaddressed by CTE (0.87x)",
      "description": "Do not materialize running/cumulative window aggregates into CTEs before joins that filter based on those aggregates. The optimizer can co-optimize window evaluation and join filtering together.",
      "verified_speedup": "0.87x",
      "query_id": "",
      "transform_attempted": "date_cte_isolate",
      "regression_mechanism": "Materialized cumulative window functions (SUM() OVER ORDER BY) into separate CTEs (web_v1, store_v1) before a FULL OUTER JOIN that filters on web_cumulative > store_cumulative. The original evaluates windows lazily during the join, co-optimizing window computation with the join filter. Materialization forces full window computation before filtering.",
      "original_sql": "-- start query 51 in stream 0 using template query51.tpl\nWITH web_v1 as (\nselect\n  ws_item_sk item_sk, d_date,\n  sum(sum(ws_sales_price))\n      over (partition by ws_item_sk order by d_date rows between unbounded preceding and current row) cume_sales\nfrom web_sales\n    ,date_dim\nwhere ws_sold_date_sk=d_date_sk\n  and d_month_seq between 1216 and 1216+11\n  and ws_item_sk is not NULL\ngroup by ws_item_sk, d_date),\nstore_v1 as (\nselect\n  ss_item_sk item_sk, d_date,\n  sum(sum(ss_sales_price))\n      over (partition by ss_item_sk order by d_date rows between unbounded preceding and current row) cume_sales\nfrom store_sales\n    ,date_dim\nwhere ss_sold_date_sk=d_date_sk\n  and d_month_seq between 1216 and 1216+11\n  and ss_item_sk is not NULL\ngroup by ss_item_sk, d_date)\n select *\nfrom (select item_sk\n     ,d_date\n     ,web_sales\n     ,store_sales\n     ,max(web_sales)\n         over (partition by item_sk order by d_date rows between unbounded preceding and current row) web_cumulative\n     ,max(store_sales)\n         over (partition by item_sk order by d_date rows between unbounded preceding and current row) store_cumulative\n     from (select case when web.item_sk is not null then web.item_sk else store.item_sk end item_sk\n                 ,case when web.d_date is not null then web.d_date else store.d_date end d_date\n                 ,web.cume_sales web_sales\n                 ,store.cume_sales store_sales\n           from web_v1 web full outer join store_v1 store on (web.item_sk = store.item_sk\n                                                          and web.d_date = store.d_date)\n          )x )y\nwhere web_cumulative > store_cumulative\norder by item_sk\n        ,d_date\n LIMIT 100;\n\n-- end query 51 in stream 0 using template query51.tpl",
      "example": {
        "before_sql": "-- start query 51 in stream 0 using template query51.tpl\nWITH web_v1 as (\nselect\n  ws_item_sk item_sk, d_date,\n  sum(sum(ws_sales_price))\n      over (partition by ws_item_sk order by d_date rows between unbounded preceding and current row) cume_sales\nfrom web_sales\n    ,date_dim\nwhere ws_sold_date_sk=d_date_sk\n  and d_month_seq between 1216 and 1216+11\n  and ws_item_sk is not NULL\ngroup by ws_item_sk, d_date),\nstore_v1 as (\nselect\n  ss_item_sk item_sk, d_date,\n  sum(sum(ss_sales_price))\n      over (partition by ss_item_sk order by d_date rows between unbounded preceding and current row) cume_sales\nfrom store_sales\n    ,date_dim\nwhere ss_sold_date_sk=d_date_sk\n  and d_month_seq between 1216 and 1216+11\n  and ss_item_sk is not NULL\ngroup by ss_item_sk, d_date)\n select *\nfrom (select item_sk\n     ,d_date\n     ,web_sales\n     ,store_sales\n     ,max(web_sales)\n         over (partition by item_sk order by d_date rows between unbounded preceding and current row) web_cumulative\n     ,max(store_sales)\n         over (partition by item_sk order by d_date rows between unbounded preceding and current row) store_cumulative\n     from (select case when web.item_sk is not null then web.item_sk else store.item_sk end item_sk\n                 ,case when web.d_date is not null then web.d_date else store.d_date end d_date\n                 ,web.cume_sales web_sales\n                 ,store.cume_sales store_sales\n           from web_v1 web full outer join store_v1 store on (web.item_sk = store.item_sk\n                                                          and web.d_date = store.d_date)\n          )x )y\nwhere web_cumulative > store_cumulative\norder by item_sk\n        ,d_date\n LIMIT 100;\n\n-- end query 51 in stream 0 using template query51.tpl",
        "after_sql": "WITH filtered_dates AS (SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1216 AND 1216 + 11), filtered_web_sales AS (SELECT ws_item_sk AS item_sk, d_date, ws_sales_price FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk WHERE NOT ws_item_sk IS NULL), filtered_store_sales AS (SELECT ss_item_sk AS item_sk, d_date, ss_sales_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk WHERE NOT ss_item_sk IS NULL), web_v1 AS (SELECT item_sk, d_date, SUM(SUM(ws_sales_price)) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS cume_sales FROM filtered_web_sales GROUP BY item_sk, d_date), store_v1 AS (SELECT item_sk, d_date, SUM(SUM(ss_sales_price)) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS cume_sales FROM filtered_store_sales GROUP BY item_sk, d_date)\nSELECT * FROM (SELECT item_sk, d_date, web_sales, store_sales, MAX(web_sales) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS web_cumulative, MAX(store_sales) OVER (PARTITION BY item_sk ORDER BY d_date rows BETWEEN UNBOUNDED preceding AND CURRENT ROW) AS store_cumulative FROM (SELECT CASE WHEN NOT web.item_sk IS NULL THEN web.item_sk ELSE store.item_sk END AS item_sk, CASE WHEN NOT web.d_date IS NULL THEN web.d_date ELSE store.d_date END AS d_date, web.cume_sales AS web_sales, store.cume_sales AS store_sales FROM web_v1 AS web FULL OUTER JOIN store_v1 AS store ON (web.item_sk = store.item_sk AND web.d_date = store.d_date)) AS x) AS y WHERE web_cumulative > store_cumulative ORDER BY item_sk, d_date LIMIT 100",
        "key_insight": "Do not materialize running/cumulative window aggregates into CTEs before joins that filter based on those aggregates. The optimizer can co-optimize window evaluation and join filtering together."
      },
      "dialect": "duckdb",
      "transforms": [
        "date_cte_isolate"
      ],
      "families": [
        "A"
      ],
      "family": "A",
      "gap_ids": [
        "CROSS_CTE_PREDICATE_BLINDNESS"
      ],
      "_tag_score": 0.5789473684210527
    },
    {
      "id": "regression_exists_pair_broken",
      "type": "regression",
      "name": "regression: correlated EXISTS pairs broken (0.54x)",
      "description": "Do not decompose tightly-correlated EXISTS/NOT EXISTS clause pairs into independent CTEs. Their cardinality estimates depend on each other; materializing them independently causes severe join cost misestimates.",
      "verified_speedup": "0.54x",
      "query_id": "",
      "transform_attempted": "materialize_cte",
      "regression_mechanism": "Materialized complex correlated EXISTS/NOT EXISTS logic into independent CTEs (multi_warehouse_orders, returned_multi_warehouse_orders). The original EXISTS clauses were tightly correlated and evaluated together. Decoupling them into CTEs severed their cardinality relationship, causing 4x+ join estimate errors.",
      "original_sql": "-- start query 95 in stream 0 using template query95.tpl\nwith ws_wh as\n(select ws1.ws_order_number,ws1.ws_warehouse_sk wh1,ws2.ws_warehouse_sk wh2\n from web_sales ws1,web_sales ws2\n where ws1.ws_order_number = ws2.ws_order_number\n   and ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)\n select \n   count(distinct ws_order_number) as \"order count\"\n  ,sum(ws_ext_ship_cost) as \"total shipping cost\"\n  ,sum(ws_net_profit) as \"total net profit\"\nfrom\n   web_sales ws1\n  ,date_dim\n  ,customer_address\n  ,web_site\nwhere\n    d_date between '1999-2-01' and \n           (cast('1999-2-01' as date) + INTERVAL 60 DAY)\nand ws1.ws_ship_date_sk = d_date_sk\nand ws1.ws_ship_addr_sk = ca_address_sk\nand ca_state = 'NC'\nand ws1.ws_web_site_sk = web_site_sk\nand web_company_name = 'pri'\nand ws1.ws_order_number in (select ws_order_number\n                            from ws_wh)\nand ws1.ws_order_number in (select wr_order_number\n                            from web_returns,ws_wh\n                            where wr_order_number = ws_wh.ws_order_number)\norder by count(distinct ws_order_number)\n LIMIT 100;\n\n-- end query 95 in stream 0 using template query95.tpl",
      "example": {
        "before_sql": "-- start query 95 in stream 0 using template query95.tpl\nwith ws_wh as\n(select ws1.ws_order_number,ws1.ws_warehouse_sk wh1,ws2.ws_warehouse_sk wh2\n from web_sales ws1,web_sales ws2\n where ws1.ws_order_number = ws2.ws_order_number\n   and ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)\n select \n   count(distinct ws_order_number) as \"order count\"\n  ,sum(ws_ext_ship_cost) as \"total shipping cost\"\n  ,sum(ws_net_profit) as \"total net profit\"\nfrom\n   web_sales ws1\n  ,date_dim\n  ,customer_address\n  ,web_site\nwhere\n    d_date between '1999-2-01' and \n           (cast('1999-2-01' as date) + INTERVAL 60 DAY)\nand ws1.ws_ship_date_sk = d_date_sk\nand ws1.ws_ship_addr_sk = ca_address_sk\nand ca_state = 'NC'\nand ws1.ws_web_site_sk = web_site_sk\nand web_company_name = 'pri'\nand ws1.ws_order_number in (select ws_order_number\n                            from ws_wh)\nand ws1.ws_order_number in (select wr_order_number\n                            from web_returns,ws_wh\n                            where wr_order_number = ws_wh.ws_order_number)\norder by count(distinct ws_order_number)\n LIMIT 100;\n\n-- end query 95 in stream 0 using template query95.tpl",
        "after_sql": "WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '1999-2-01' AND (CAST('1999-2-01' AS DATE) + INTERVAL '60' DAY)), ws_wh AS (SELECT ws1.ws_order_number, ws1.ws_warehouse_sk AS wh1, ws2.ws_warehouse_sk AS wh2 FROM web_sales AS ws1, web_sales AS ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk), multi_warehouse_orders AS (SELECT DISTINCT ws_order_number FROM ws_wh), returned_multi_warehouse_orders AS (SELECT DISTINCT wr_order_number FROM web_returns AS wr JOIN ws_wh ON wr.wr_order_number = ws_wh.ws_order_number)\nSELECT COUNT(DISTINCT ws1.ws_order_number) AS \"order count\", SUM(ws1.ws_ext_ship_cost) AS \"total shipping cost\", SUM(ws1.ws_net_profit) AS \"total net profit\" FROM web_sales AS ws1 JOIN filtered_dates AS fd ON ws1.ws_ship_date_sk = fd.d_date_sk JOIN customer_address AS ca ON ws1.ws_ship_addr_sk = ca.ca_address_sk JOIN web_site AS ws ON ws1.ws_web_site_sk = ws.web_site_sk JOIN multi_warehouse_orders AS mwo ON ws1.ws_order_number = mwo.ws_order_number JOIN returned_multi_warehouse_orders AS rmwo ON ws1.ws_order_number = rmwo.wr_order_number WHERE ca.ca_state = 'NC' AND ws.web_company_name = 'pri' ORDER BY COUNT(DISTINCT ws1.ws_order_number) LIMIT 100",
        "key_insight": "Do not decompose tightly-correlated EXISTS/NOT EXISTS clause pairs into independent CTEs. Their cardinality estimates depend on each other; materializing them independently causes severe join cost misestimates."
      },
      "dialect": "duckdb",
      "transforms": [
        "materialize_cte"
      ],
      "families": [
        "E"
      ],
      "family": "E",
      "_tag_score": 0.5263157894736842
    }
  ],
  "strategy_leaderboard": {
    "generated_at": "2026-02-08T14:17:06.364519+00:00",
    "total_attempts": 821,
    "total_queries": 101,
    "query_archetypes": {
      "query_1": "filter_pushdown",
      "query_10": "general",
      "query_11": "filter_pushdown",
      "query_12": "general",
      "query_13": "general",
      "query_14": "set_operations",
      "query_15": "general",
      "query_16": "general",
      "query_17": "general",
      "query_18": "aggregation_rewrite",
      "query_19": "general",
      "query_2": "filter_pushdown",
      "query_20": "general",
      "query_21": "aggregation_rewrite",
      "query_22": "aggregation_rewrite",
      "query_23": "set_operations",
      "query_23a": "set_operations",
      "query_23b": "set_operations",
      "query_24": "filter_pushdown",
      "query_25": "general",
      "query_26": "general",
      "query_27": "aggregation_rewrite",
      "query_28": "general",
      "query_29": "general",
      "query_3": "general",
      "query_30": "filter_pushdown",
      "query_31": "filter_pushdown",
      "query_32": "general",
      "query_33": "set_operations",
      "query_34": "aggregation_rewrite",
      "query_35": "general",
      "query_36": "aggregation_rewrite",
      "query_37": "general",
      "query_38": "set_operations",
      "query_39": "filter_pushdown",
      "query_4": "filter_pushdown",
      "query_40": "aggregation_rewrite",
      "query_41": "aggregation_rewrite",
      "query_42": "general",
      "query_43": "aggregation_rewrite",
      "query_44": "general",
      "query_45": "general",
      "query_46": "general",
      "query_47": "filter_pushdown",
      "query_48": "general",
      "query_49": "set_operations",
      "query_5": "aggregation_rewrite",
      "query_50": "aggregation_rewrite",
      "query_51": "filter_pushdown",
      "query_52": "general",
      "query_53": "aggregation_rewrite",
      "query_54": "set_operations",
      "query_55": "general",
      "query_56": "set_operations",
      "query_57": "filter_pushdown",
      "query_58": "filter_pushdown",
      "query_59": "filter_pushdown",
      "query_6": "general",
      "query_60": "set_operations",
      "query_61": "general",
      "query_62": "aggregation_rewrite",
      "query_63": "aggregation_rewrite",
      "query_64": "filter_pushdown",
      "query_65": "general",
      "query_66": "aggregation_rewrite",
      "query_67": "aggregation_rewrite",
      "query_68": "general",
      "query_69": "general",
      "query_7": "general",
      "query_70": "aggregation_rewrite",
      "query_71": "set_operations",
      "query_72": "aggregation_rewrite",
      "query_73": "aggregation_rewrite",
      "query_74": "filter_pushdown",
      "query_75": "set_operations",
      "query_76": "set_operations",
      "query_77": "aggregation_rewrite",
      "query_78": "filter_pushdown",
      "query_79": "general",
      "query_8": "set_operations",
      "query_80": "aggregation_rewrite",
      "query_81": "filter_pushdown",
      "query_82": "general",
      "query_83": "filter_pushdown",
      "query_84": "general",
      "query_85": "general",
      "query_86": "aggregation_rewrite",
      "query_87": "set_operations",
      "query_88": "general",
      "query_89": "aggregation_rewrite",
      "query_9": "aggregation_rewrite",
      "query_90": "general",
      "query_91": "general",
      "query_92": "general",
      "query_93": "aggregation_rewrite",
      "query_94": "general",
      "query_95": "filter_pushdown",
      "query_96": "general",
      "query_97": "filter_pushdown",
      "query_98": "general",
      "query_99": "aggregation_rewrite"
    },
    "archetype_summary": {
      "aggregation_rewrite": {
        "query_count": 26,
        "total_attempts": 211,
        "queries": [
          "query_18",
          "query_21",
          "query_22",
          "query_27",
          "query_34",
          "query_36",
          "query_40",
          "query_41",
          "query_43",
          "query_5",
          "query_50",
          "query_53",
          "query_62",
          "query_63",
          "query_66",
          "query_67",
          "query_70",
          "query_72",
          "query_73",
          "query_77",
          "query_80",
          "query_86",
          "query_89",
          "query_9",
          "query_93",
          "query_99"
        ],
        "win_rate": 0.284,
        "avg_speedup": 1.169
      },
      "filter_pushdown": {
        "query_count": 20,
        "total_attempts": 144,
        "queries": [
          "query_1",
          "query_11",
          "query_2",
          "query_24",
          "query_30",
          "query_31",
          "query_39",
          "query_4",
          "query_47",
          "query_51",
          "query_57",
          "query_58",
          "query_59",
          "query_64",
          "query_74",
          "query_78",
          "query_81",
          "query_83",
          "query_95",
          "query_97"
        ],
        "win_rate": 0.396,
        "avg_speedup": 1.122
      },
      "general": {
        "query_count": 40,
        "total_attempts": 347,
        "queries": [
          "query_10",
          "query_12",
          "query_13",
          "query_15",
          "query_16",
          "query_17",
          "query_19",
          "query_20",
          "query_25",
          "query_26",
          "query_28",
          "query_29",
          "query_3",
          "query_32",
          "query_35",
          "query_37",
          "query_42",
          "query_44",
          "query_45",
          "query_46",
          "query_48",
          "query_52",
          "query_55",
          "query_6",
          "query_61",
          "query_65",
          "query_68",
          "query_69",
          "query_7",
          "query_79",
          "query_82",
          "query_84",
          "query_85",
          "query_88",
          "query_90",
          "query_91",
          "query_92",
          "query_94",
          "query_96",
          "query_98"
        ],
        "win_rate": 0.248,
        "avg_speedup": 1.041
      },
      "set_operations": {
        "query_count": 15,
        "total_attempts": 119,
        "queries": [
          "query_14",
          "query_23",
          "query_23a",
          "query_23b",
          "query_33",
          "query_38",
          "query_49",
          "query_54",
          "query_56",
          "query_60",
          "query_71",
          "query_75",
          "query_76",
          "query_8",
          "query_87"
        ],
        "win_rate": 0.345,
        "avg_speedup": 1.026
      }
    },
    "transform_by_archetype": {
      "aggregation_rewrite": {
        "date_cte_isolate": {
          "attempts": 86,
          "successes": 40,
          "success_rate": 0.465,
          "avg_speedup_when_successful": 2.208,
          "avg_speedup_all": 1.483,
          "regressions": 16,
          "regression_rate": 0.186,
          "queries_won": [
            "query_18",
            "query_21",
            "query_22",
            "query_27",
            "query_36",
            "query_40",
            "query_43",
            "query_5",
            "query_53",
            "query_62",
            "query_63",
            "query_67",
            "query_72",
            "query_73",
            "query_77",
            "query_80",
            "query_86",
            "query_99"
          ]
        },
        "decorrelate": {
          "attempts": 17,
          "successes": 8,
          "success_rate": 0.471,
          "avg_speedup_when_successful": 1.369,
          "avg_speedup_all": 1.057,
          "regressions": 3,
          "regression_rate": 0.176,
          "queries_won": [
            "query_21",
            "query_41",
            "query_53",
            "query_63",
            "query_67",
            "query_73",
            "query_86",
            "query_93"
          ]
        },
        "dimension_cte_isolate": {
          "attempts": 38,
          "successes": 9,
          "success_rate": 0.237,
          "avg_speedup_when_successful": 1.498,
          "avg_speedup_all": 1.071,
          "regressions": 4,
          "regression_rate": 0.105,
          "queries_won": [
            "query_18",
            "query_21",
            "query_27",
            "query_41",
            "query_5",
            "query_53",
            "query_67",
            "query_80",
            "query_93"
          ]
        },
        "early_filter": {
          "attempts": 49,
          "successes": 8,
          "success_rate": 0.163,
          "avg_speedup_when_successful": 1.584,
          "avg_speedup_all": 1.019,
          "regressions": 12,
          "regression_rate": 0.245,
          "queries_won": [
            "query_18",
            "query_27",
            "query_62",
            "query_66",
            "query_70",
            "query_72",
            "query_93"
          ]
        },
        "intersect_to_exists": {
          "attempts": 21,
          "successes": 1,
          "success_rate": 0.048,
          "avg_speedup_when_successful": 1.818,
          "avg_speedup_all": 0.904,
          "regressions": 8,
          "regression_rate": 0.381,
          "queries_won": [
            "query_80"
          ]
        },
        "materialize_cte": {
          "attempts": 31,
          "successes": 3,
          "success_rate": 0.097,
          "avg_speedup_when_successful": 1.736,
          "avg_speedup_all": 0.949,
          "regressions": 9,
          "regression_rate": 0.29,
          "queries_won": [
            "query_27",
            "query_70",
            "query_72"
          ]
        },
        "multi_date_range_cte": {
          "attempts": 7,
          "successes": 0,
          "success_rate": 0.0,
          "avg_speedup_when_successful": 0,
          "avg_speedup_all": 0.764,
          "regressions": 2,
          "regression_rate": 0.286,
          "queries_won": []
        },
        "multi_dimension_prefetch": {
          "attempts": 35,
          "successes": 9,
          "success_rate": 0.257,
          "avg_speedup_when_successful": 1.917,
          "avg_speedup_all": 1.153,
          "regressions": 6,
          "regression_rate": 0.171,
          "queries_won": [
            "query_27",
            "query_36",
            "query_40",
            "query_41",
            "query_53",
            "query_63",
            "query_73",
            "query_80"
          ]
        },
        "or_to_union": {
          "attempts": 40,
          "successes": 4,
          "success_rate": 0.1,
          "avg_speedup_when_successful": 1.523,
          "avg_speedup_all": 0.774,
          "regressions": 20,
          "regression_rate": 0.5,
          "queries_won": [
            "query_41",
            "query_53",
            "query_63",
            "query_80"
          ]
        },
        "prefetch_fact_join": {
          "attempts": 32,
          "successes": 9,
          "success_rate": 0.281,
          "avg_speedup_when_successful": 1.872,
          "avg_speedup_all": 1.218,
          "regressions": 3,
          "regression_rate": 0.094,
          "queries_won": [
            "query_21",
            "query_27",
            "query_40",
            "query_53",
            "query_80",
            "query_86",
            "query_93",
            "query_99"
          ]
        },
        "pushdown": {
          "attempts": 41,
          "successes": 8,
          "success_rate": 0.195,
          "avg_speedup_when_successful": 2.438,
          "avg_speedup_all": 1.175,
          "regressions": 10,
          "regression_rate": 0.244,
          "queries_won": [
            "query_22",
            "query_27",
            "query_41",
            "query_63",
            "query_70",
            "query_72",
            "query_9",
            "query_93"
          ]
        },
        "single_pass_aggregation": {
          "attempts": 23,
          "successes": 7,
          "success_rate": 0.304,
          "avg_speedup_when_successful": 2.107,
          "avg_speedup_all": 1.319,
          "regressions": 2,
          "regression_rate": 0.087,
          "queries_won": [
            "query_27",
            "query_36",
            "query_40",
            "query_41",
            "query_80",
            "query_93",
            "query_99"
          ]
        },
        "union_cte_split": {
          "attempts": 3,
          "successes": 0,
          "success_rate": 0.0,
          "avg_speedup_when_successful": 0,
          "avg_speedup_all": 0.598,
          "regressions": 2,
          "regression_rate": 0.667,
          "queries_won": []
        }
      },
      "filter_pushdown": {
        "date_cte_isolate": {
          "attempts": 52,
          "successes": 23,
          "success_rate": 0.442,
          "avg_speedup_when_successful": 1.759,
          "avg_speedup_all": 1.191,
          "regressions": 15,
          "regression_rate": 0.288,
          "queries_won": [
            "query_1",
            "query_30",
            "query_39",
            "query_4",
            "query_51",
            "query_57",
            "query_58",
            "query_59",
            "query_64",
            "query_74",
            "query_78",
            "query_83",
            "query_97"
          ]
        },
        "decorrelate": {
          "attempts": 22,
          "successes": 10,
          "success_rate": 0.455,
          "avg_speedup_when_successful": 1.711,
          "avg_speedup_all": 1.196,
          "regressions": 4,
          "regression_rate": 0.182,
          "queries_won": [
            "query_1",
            "query_30",
            "query_51",
            "query_57",
            "query_58",
            "query_74",
            "query_81",
            "query_83"
          ]
        },
        "dimension_cte_isolate": {
          "attempts": 18,
          "successes": 9,
          "success_rate": 0.5,
          "avg_speedup_when_successful": 1.304,
          "avg_speedup_all": 1.107,
          "regressions": 2,
          "regression_rate": 0.111,
          "queries_won": [
            "query_1",
            "query_30",
            "query_4",
            "query_51",
            "query_57",
            "query_59",
            "query_64",
            "query_74",
            "query_95"
          ]
        },
        "early_filter": {
          "attempts": 25,
          "successes": 5,
          "success_rate": 0.2,
          "avg_speedup_when_successful": 1.294,
          "avg_speedup_all": 1.014,
          "regressions": 8,
          "regression_rate": 0.32,
          "queries_won": [
            "query_4",
            "query_51",
            "query_57",
            "query_59",
            "query_95"
          ]
        },
        "intersect_to_exists": {
          "attempts": 15,
          "successes": 4,
          "success_rate": 0.267,
          "avg_speedup_when_successful": 1.188,
          "avg_speedup_all": 0.854,
          "regressions": 7,
          "regression_rate": 0.467,
          "queries_won": [
            "query_30",
            "query_59",
            "query_74",
            "query_83"
          ]
        },
        "materialize_cte": {
          "attempts": 22,
          "successes": 6,
          "success_rate": 0.273,
          "avg_speedup_when_successful": 1.22,
          "avg_speedup_all": 0.97,
          "regressions": 6,
          "regression_rate": 0.273,
          "queries_won": [
            "query_30",
            "query_57",
            "query_58",
            "query_59",
            "query_81"
          ]
        },
        "multi_date_range_cte": {
          "attempts": 6,
          "successes": 5,
          "success_rate": 0.833,
          "avg_speedup_when_successful": 1.206,
          "avg_speedup_all": 1.179,
          "regressions": 0,
          "regression_rate": 0.0,
          "queries_won": [
            "query_11",
            "query_30",
            "query_4",
            "query_64"
          ]
        },
        "multi_dimension_prefetch": {
          "attempts": 14,
          "successes": 7,
          "success_rate": 0.5,
          "avg_speedup_when_successful": 1.929,
          "avg_speedup_all": 1.435,
          "regressions": 4,
          "regression_rate": 0.286,
          "queries_won": [
            "query_1",
            "query_11",
            "query_4",
            "query_59",
            "query_64",
            "query_83",
            "query_95"
          ]
        },
        "or_to_union": {
          "attempts": 27,
          "successes": 8,
          "success_rate": 0.296,
          "avg_speedup_when_successful": 1.947,
          "avg_speedup_all": 1.067,
          "regressions": 15,
          "regression_rate": 0.556,
          "queries_won": [
            "query_30",
            "query_57",
            "query_59",
            "query_74",
            "query_78",
            "query_83"
          ]
        },
        "prefetch_fact_join": {
          "attempts": 30,
          "successes": 12,
          "success_rate": 0.4,
          "avg_speedup_when_successful": 1.695,
          "avg_speedup_all": 1.139,
          "regressions": 12,
          "regression_rate": 0.4,
          "queries_won": [
            "query_1",
            "query_11",
            "query_4",
            "query_57",
            "query_59",
            "query_64",
            "query_74",
            "query_83",
            "query_95"
          ]
        },
        "pushdown": {
          "attempts": 40,
          "successes": 12,
          "success_rate": 0.3,
          "avg_speedup_when_successful": 1.448,
          "avg_speedup_all": 0.991,
          "regressions": 14,
          "regression_rate": 0.35,
          "queries_won": [
            "query_2",
            "query_39",
            "query_4",
            "query_57",
            "query_58",
            "query_59",
            "query_74",
            "query_78",
            "query_83",
            "query_95"
          ]
        },
        "single_pass_aggregation": {
          "attempts": 15,
          "successes": 5,
          "success_rate": 0.333,
          "avg_speedup_when_successful": 2.278,
          "avg_speedup_all": 1.198,
          "regressions": 7,
          "regression_rate": 0.467,
          "queries_won": [
            "query_1",
            "query_4",
            "query_59",
            "query_64",
            "query_95"
          ]
        },
        "union_cte_split": {
          "attempts": 5,
          "successes": 3,
          "success_rate": 0.6,
          "avg_speedup_when_successful": 1.21,
          "avg_speedup_all": 1.01,
          "regressions": 1,
          "regression_rate": 0.2,
          "queries_won": [
            "query_4",
            "query_74",
            "query_83"
          ]
        }
      },
      "general": {
        "date_cte_isolate": {
          "attempts": 127,
          "successes": 36,
          "success_rate": 0.283,
          "avg_speedup_when_successful": 1.6,
          "avg_speedup_all": 1.016,
          "regressions": 53,
          "regression_rate": 0.417,
          "queries_won": [
            "query_10",
            "query_12",
            "query_15",
            "query_16",
            "query_19",
            "query_26",
            "query_3",
            "query_37",
            "query_42",
            "query_45",
            "query_52",
            "query_6",
            "query_65",
            "query_68",
            "query_69",
            "query_7",
            "query_79",
            "query_82",
            "query_85",
            "query_88",
            "query_92",
            "query_94",
            "query_98"
          ]
        },
        "decorrelate": {
          "attempts": 40,
          "successes": 15,
          "success_rate": 0.375,
          "avg_speedup_when_successful": 1.462,
          "avg_speedup_all": 0.947,
          "regressions": 15,
          "regression_rate": 0.375,
          "queries_won": [
            "query_32",
            "query_44",
            "query_45",
            "query_6",
            "query_65",
            "query_68",
            "query_79",
            "query_90",
            "query_92",
            "query_96"
          ]
        },
        "dimension_cte_isolate": {
          "attempts": 65,
          "successes": 13,
          "success_rate": 0.2,
          "avg_speedup_when_successful": 1.685,
          "avg_speedup_all": 1.029,
          "regressions": 22,
          "regression_rate": 0.338,
          "queries_won": [
            "query_10",
            "query_13",
            "query_15",
            "query_45",
            "query_6",
            "query_65",
            "query_68",
            "query_79",
            "query_82",
            "query_84",
            "query_88"
          ]
        },
        "early_filter": {
          "attempts": 72,
          "successes": 17,
          "success_rate": 0.236,
          "avg_speedup_when_successful": 1.563,
          "avg_speedup_all": 1.049,
          "regressions": 20,
          "regression_rate": 0.278,
          "queries_won": [
            "query_12",
            "query_29",
            "query_35",
            "query_37",
            "query_42",
            "query_48",
            "query_65",
            "query_68",
            "query_79",
            "query_84",
            "query_88",
            "query_90",
            "query_96"
          ]
        },
        "intersect_to_exists": {
          "attempts": 30,
          "successes": 9,
          "success_rate": 0.3,
          "avg_speedup_when_successful": 1.274,
          "avg_speedup_all": 0.903,
          "regressions": 12,
          "regression_rate": 0.4,
          "queries_won": [
            "query_15",
            "query_35",
            "query_37",
            "query_44",
            "query_45",
            "query_6",
            "query_65",
            "query_7",
            "query_84"
          ]
        },
        "materialize_cte": {
          "attempts": 43,
          "successes": 8,
          "success_rate": 0.186,
          "avg_speedup_when_successful": 1.837,
          "avg_speedup_all": 1.024,
          "regressions": 13,
          "regression_rate": 0.302,
          "queries_won": [
            "query_44",
            "query_48",
            "query_65",
            "query_68",
            "query_79",
            "query_88",
            "query_92",
            "query_98"
          ]
        },
        "multi_date_range_cte": {
          "attempts": 21,
          "successes": 4,
          "success_rate": 0.19,
          "avg_speedup_when_successful": 2.466,
          "avg_speedup_all": 1.095,
          "regressions": 7,
          "regression_rate": 0.333,
          "queries_won": [
            "query_37",
            "query_65",
            "query_79",
            "query_88"
          ]
        },
        "multi_dimension_prefetch": {
          "attempts": 51,
          "successes": 14,
          "success_rate": 0.275,
          "avg_speedup_when_successful": 1.347,
          "avg_speedup_all": 0.992,
          "regressions": 17,
          "regression_rate": 0.333,
          "queries_won": [
            "query_13",
            "query_16",
            "query_42",
            "query_44",
            "query_45",
            "query_46",
            "query_61",
            "query_65",
            "query_68",
            "query_79",
            "query_82",
            "query_90",
            "query_94"
          ]
        },
        "or_to_union": {
          "attempts": 89,
          "successes": 23,
          "success_rate": 0.258,
          "avg_speedup_when_successful": 2.473,
          "avg_speedup_all": 1.125,
          "regressions": 48,
          "regression_rate": 0.539,
          "queries_won": [
            "query_10",
            "query_13",
            "query_15",
            "query_26",
            "query_35",
            "query_37",
            "query_44",
            "query_6",
            "query_65",
            "query_68",
            "query_7",
            "query_79",
            "query_84",
            "query_85",
            "query_88"
          ]
        },
        "prefetch_fact_join": {
          "attempts": 55,
          "successes": 12,
          "success_rate": 0.218,
          "avg_speedup_when_successful": 1.87,
          "avg_speedup_all": 1.059,
          "regressions": 20,
          "regression_rate": 0.364,
          "queries_won": [
            "query_15",
            "query_32",
            "query_35",
            "query_44",
            "query_6",
            "query_61",
            "query_65",
            "query_68",
            "query_7",
            "query_82",
            "query_88"
          ]
        },
        "pushdown": {
          "attempts": 53,
          "successes": 11,
          "success_rate": 0.208,
          "avg_speedup_when_successful": 1.82,
          "avg_speedup_all": 1.025,
          "regressions": 17,
          "regression_rate": 0.321,
          "queries_won": [
            "query_13",
            "query_37",
            "query_48",
            "query_65",
            "query_68",
            "query_7",
            "query_79",
            "query_85",
            "query_88"
          ]
        },
        "single_pass_aggregation": {
          "attempts": 34,
          "successes": 7,
          "success_rate": 0.206,
          "avg_speedup_when_successful": 2.206,
          "avg_speedup_all": 1.106,
          "regressions": 13,
          "regression_rate": 0.382,
          "queries_won": [
            "query_35",
            "query_44",
            "query_61",
            "query_65",
            "query_82",
            "query_88",
            "query_90"
          ]
        },
        "union_cte_split": {
          "attempts": 2,
          "successes": 1,
          "success_rate": 0.5,
          "avg_speedup_when_successful": 6.105,
          "avg_speedup_all": 3.564,
          "regressions": 0,
          "regression_rate": 0.0,
          "queries_won": [
            "query_88"
          ]
        }
      },
      "set_operations": {
        "date_cte_isolate": {
          "attempts": 62,
          "successes": 26,
          "success_rate": 0.419,
          "avg_speedup_when_successful": 1.466,
          "avg_speedup_all": 1.066,
          "regressions": 23,
          "regression_rate": 0.371,
          "queries_won": [
            "query_14",
            "query_23a",
            "query_23b",
            "query_33",
            "query_38",
            "query_49",
            "query_54",
            "query_56",
            "query_60",
            "query_71",
            "query_75",
            "query_8",
            "query_87"
          ]
        },
        "decorrelate": {
          "attempts": 25,
          "successes": 12,
          "success_rate": 0.48,
          "avg_speedup_when_successful": 1.442,
          "avg_speedup_all": 1.17,
          "regressions": 6,
          "regression_rate": 0.24,
          "queries_won": [
            "query_14",
            "query_23a",
            "query_23b",
            "query_33",
            "query_54",
            "query_56",
            "query_60",
            "query_75",
            "query_87"
          ]
        },
        "dimension_cte_isolate": {
          "attempts": 18,
          "successes": 7,
          "success_rate": 0.389,
          "avg_speedup_when_successful": 1.5,
          "avg_speedup_all": 1.176,
          "regressions": 4,
          "regression_rate": 0.222,
          "queries_won": [
            "query_14",
            "query_49",
            "query_56",
            "query_60",
            "query_75",
            "query_87"
          ]
        },
        "early_filter": {
          "attempts": 21,
          "successes": 6,
          "success_rate": 0.286,
          "avg_speedup_when_successful": 1.346,
          "avg_speedup_all": 1.009,
          "regressions": 6,
          "regression_rate": 0.286,
          "queries_won": [
            "query_14",
            "query_23a",
            "query_54",
            "query_56",
            "query_75"
          ]
        },
        "intersect_to_exists": {
          "attempts": 16,
          "successes": 8,
          "success_rate": 0.5,
          "avg_speedup_when_successful": 1.427,
          "avg_speedup_all": 1.188,
          "regressions": 4,
          "regression_rate": 0.25,
          "queries_won": [
            "query_14",
            "query_23a",
            "query_23b",
            "query_38",
            "query_56",
            "query_75",
            "query_76"
          ]
        },
        "materialize_cte": {
          "attempts": 20,
          "successes": 6,
          "success_rate": 0.3,
          "avg_speedup_when_successful": 1.548,
          "avg_speedup_all": 1.083,
          "regressions": 8,
          "regression_rate": 0.4,
          "queries_won": [
            "query_14",
            "query_23a",
            "query_56",
            "query_75"
          ]
        },
        "multi_date_range_cte": {
          "attempts": 1,
          "successes": 1,
          "success_rate": 1.0,
          "avg_speedup_when_successful": 2.395,
          "avg_speedup_all": 2.395,
          "regressions": 0,
          "regression_rate": 0.0,
          "queries_won": [
            "query_14"
          ]
        },
        "multi_dimension_prefetch": {
          "attempts": 17,
          "successes": 5,
          "success_rate": 0.294,
          "avg_speedup_when_successful": 1.188,
          "avg_speedup_all": 1.022,
          "regressions": 7,
          "regression_rate": 0.412,
          "queries_won": [
            "query_33",
            "query_56",
            "query_60",
            "query_76"
          ]
        },
        "or_to_union": {
          "attempts": 15,
          "successes": 4,
          "success_rate": 0.267,
          "avg_speedup_when_successful": 1.209,
          "avg_speedup_all": 1.012,
          "regressions": 5,
          "regression_rate": 0.333,
          "queries_won": [
            "query_23a",
            "query_56",
            "query_75",
            "query_76"
          ]
        },
        "prefetch_fact_join": {
          "attempts": 21,
          "successes": 8,
          "success_rate": 0.381,
          "avg_speedup_when_successful": 1.427,
          "avg_speedup_all": 1.131,
          "regressions": 7,
          "regression_rate": 0.333,
          "queries_won": [
            "query_14",
            "query_23a",
            "query_23b",
            "query_38",
            "query_56",
            "query_75",
            "query_76"
          ]
        },
        "pushdown": {
          "attempts": 32,
          "successes": 11,
          "success_rate": 0.344,
          "avg_speedup_when_successful": 1.409,
          "avg_speedup_all": 1.085,
          "regressions": 9,
          "regression_rate": 0.281,
          "queries_won": [
            "query_14",
            "query_23a",
            "query_56",
            "query_60",
            "query_75",
            "query_76",
            "query_8"
          ]
        },
        "single_pass_aggregation": {
          "attempts": 11,
          "successes": 2,
          "success_rate": 0.182,
          "avg_speedup_when_successful": 1.293,
          "avg_speedup_all": 1.011,
          "regressions": 5,
          "regression_rate": 0.455,
          "queries_won": [
            "query_56",
            "query_75"
          ]
        },
        "union_cte_split": {
          "attempts": 6,
          "successes": 3,
          "success_rate": 0.5,
          "avg_speedup_when_successful": 1.399,
          "avg_speedup_all": 1.186,
          "regressions": 1,
          "regression_rate": 0.167,
          "queries_won": [
            "query_23a",
            "query_75"
          ]
        }
      }
    },
    "elimination_table": {
      "aggregation_rewrite": {
        "avoid": [
          "intersect_to_exists",
          "materialize_cte",
          "multi_date_range_cte",
          "or_to_union"
        ],
        "reason": {
          "materialize_cte": "3/31 successes, 9 regressions (avg 0.95x)",
          "or_to_union": "4/40 successes, 20 regressions (avg 0.77x)",
          "intersect_to_exists": "1/21 successes, 8 regressions (avg 0.90x)",
          "multi_date_range_cte": "0/7 successes, 2 regressions (avg 0.76x)"
        }
      }
    },
    "top_transforms_by_archetype": {
      "aggregation_rewrite": [
        {
          "transform": "decorrelate",
          "success_rate": 0.471,
          "avg_speedup": 1.057,
          "attempts": 17
        },
        {
          "transform": "date_cte_isolate",
          "success_rate": 0.465,
          "avg_speedup": 1.483,
          "attempts": 86
        },
        {
          "transform": "single_pass_aggregation",
          "success_rate": 0.304,
          "avg_speedup": 1.319,
          "attempts": 23
        },
        {
          "transform": "prefetch_fact_join",
          "success_rate": 0.281,
          "avg_speedup": 1.218,
          "attempts": 32
        },
        {
          "transform": "multi_dimension_prefetch",
          "success_rate": 0.257,
          "avg_speedup": 1.153,
          "attempts": 35
        },
        {
          "transform": "dimension_cte_isolate",
          "success_rate": 0.237,
          "avg_speedup": 1.071,
          "attempts": 38
        },
        {
          "transform": "pushdown",
          "success_rate": 0.195,
          "avg_speedup": 1.175,
          "attempts": 41
        },
        {
          "transform": "early_filter",
          "success_rate": 0.163,
          "avg_speedup": 1.019,
          "attempts": 49
        },
        {
          "transform": "or_to_union",
          "success_rate": 0.1,
          "avg_speedup": 0.774,
          "attempts": 40
        },
        {
          "transform": "materialize_cte",
          "success_rate": 0.097,
          "avg_speedup": 0.949,
          "attempts": 31
        },
        {
          "transform": "intersect_to_exists",
          "success_rate": 0.048,
          "avg_speedup": 0.904,
          "attempts": 21
        },
        {
          "transform": "multi_date_range_cte",
          "success_rate": 0.0,
          "avg_speedup": 0.764,
          "attempts": 7
        },
        {
          "transform": "union_cte_split",
          "success_rate": 0.0,
          "avg_speedup": 0.598,
          "attempts": 3
        }
      ],
      "filter_pushdown": [
        {
          "transform": "multi_date_range_cte",
          "success_rate": 0.833,
          "avg_speedup": 1.179,
          "attempts": 6
        },
        {
          "transform": "union_cte_split",
          "success_rate": 0.6,
          "avg_speedup": 1.01,
          "attempts": 5
        },
        {
          "transform": "multi_dimension_prefetch",
          "success_rate": 0.5,
          "avg_speedup": 1.435,
          "attempts": 14
        },
        {
          "transform": "dimension_cte_isolate",
          "success_rate": 0.5,
          "avg_speedup": 1.107,
          "attempts": 18
        },
        {
          "transform": "decorrelate",
          "success_rate": 0.455,
          "avg_speedup": 1.196,
          "attempts": 22
        },
        {
          "transform": "date_cte_isolate",
          "success_rate": 0.442,
          "avg_speedup": 1.191,
          "attempts": 52
        },
        {
          "transform": "prefetch_fact_join",
          "success_rate": 0.4,
          "avg_speedup": 1.139,
          "attempts": 30
        },
        {
          "transform": "single_pass_aggregation",
          "success_rate": 0.333,
          "avg_speedup": 1.198,
          "attempts": 15
        },
        {
          "transform": "pushdown",
          "success_rate": 0.3,
          "avg_speedup": 0.991,
          "attempts": 40
        },
        {
          "transform": "or_to_union",
          "success_rate": 0.296,
          "avg_speedup": 1.067,
          "attempts": 27
        },
        {
          "transform": "materialize_cte",
          "success_rate": 0.273,
          "avg_speedup": 0.97,
          "attempts": 22
        },
        {
          "transform": "intersect_to_exists",
          "success_rate": 0.267,
          "avg_speedup": 0.854,
          "attempts": 15
        },
        {
          "transform": "early_filter",
          "success_rate": 0.2,
          "avg_speedup": 1.014,
          "attempts": 25
        }
      ],
      "general": [
        {
          "transform": "decorrelate",
          "success_rate": 0.375,
          "avg_speedup": 0.947,
          "attempts": 40
        },
        {
          "transform": "intersect_to_exists",
          "success_rate": 0.3,
          "avg_speedup": 0.903,
          "attempts": 30
        },
        {
          "transform": "date_cte_isolate",
          "success_rate": 0.283,
          "avg_speedup": 1.016,
          "attempts": 127
        },
        {
          "transform": "multi_dimension_prefetch",
          "success_rate": 0.275,
          "avg_speedup": 0.992,
          "attempts": 51
        },
        {
          "transform": "or_to_union",
          "success_rate": 0.258,
          "avg_speedup": 1.125,
          "attempts": 89
        },
        {
          "transform": "early_filter",
          "success_rate": 0.236,
          "avg_speedup": 1.049,
          "attempts": 72
        },
        {
          "transform": "prefetch_fact_join",
          "success_rate": 0.218,
          "avg_speedup": 1.059,
          "attempts": 55
        },
        {
          "transform": "pushdown",
          "success_rate": 0.208,
          "avg_speedup": 1.025,
          "attempts": 53
        },
        {
          "transform": "single_pass_aggregation",
          "success_rate": 0.206,
          "avg_speedup": 1.106,
          "attempts": 34
        },
        {
          "transform": "dimension_cte_isolate",
          "success_rate": 0.2,
          "avg_speedup": 1.029,
          "attempts": 65
        },
        {
          "transform": "multi_date_range_cte",
          "success_rate": 0.19,
          "avg_speedup": 1.095,
          "attempts": 21
        },
        {
          "transform": "materialize_cte",
          "success_rate": 0.186,
          "avg_speedup": 1.024,
          "attempts": 43
        }
      ],
      "set_operations": [
        {
          "transform": "intersect_to_exists",
          "success_rate": 0.5,
          "avg_speedup": 1.188,
          "attempts": 16
        },
        {
          "transform": "union_cte_split",
          "success_rate": 0.5,
          "avg_speedup": 1.186,
          "attempts": 6
        },
        {
          "transform": "decorrelate",
          "success_rate": 0.48,
          "avg_speedup": 1.17,
          "attempts": 25
        },
        {
          "transform": "date_cte_isolate",
          "success_rate": 0.419,
          "avg_speedup": 1.066,
          "attempts": 62
        },
        {
          "transform": "dimension_cte_isolate",
          "success_rate": 0.389,
          "avg_speedup": 1.176,
          "attempts": 18
        },
        {
          "transform": "prefetch_fact_join",
          "success_rate": 0.381,
          "avg_speedup": 1.131,
          "attempts": 21
        },
        {
          "transform": "pushdown",
          "success_rate": 0.344,
          "avg_speedup": 1.085,
          "attempts": 32
        },
        {
          "transform": "materialize_cte",
          "success_rate": 0.3,
          "avg_speedup": 1.083,
          "attempts": 20
        },
        {
          "transform": "multi_dimension_prefetch",
          "success_rate": 0.294,
          "avg_speedup": 1.022,
          "attempts": 17
        },
        {
          "transform": "early_filter",
          "success_rate": 0.286,
          "avg_speedup": 1.009,
          "attempts": 21
        },
        {
          "transform": "or_to_union",
          "success_rate": 0.267,
          "avg_speedup": 1.012,
          "attempts": 15
        },
        {
          "transform": "single_pass_aggregation",
          "success_rate": 0.182,
          "avg_speedup": 1.011,
          "attempts": 11
        }
      ]
    }
  },
  "query_archetype": "subquery_elimination",
  "resource_envelope": null,
  "exploit_algorithm_text": "# DuckDB Rewrite Playbook\n# TPC-DS SF1\u2013SF10 field intelligence\n\n## ENGINE STRENGTHS \u2014 do NOT rewrite\n\n1. **Predicate pushdown**: filter inside scan node \u2192 leave it.\n2. **Same-column OR**: handled natively in one scan. Splitting = lethal (0.23x observed).\n3. **Hash join selection**: sound for 2\u20134 tables. Reduce inputs, not order.\n4. **CTE inlining**: single-ref CTEs inlined automatically (zero overhead).\n5. **Columnar projection**: only referenced columns read.\n6. **Parallel aggregation**: scans and aggregations parallelized across threads.\n7. **EXISTS semi-join**: early termination. **Never materialize** (0.14x observed).\n\n## GLOBAL GUARDS\n\n1. EXISTS/NOT EXISTS \u2192 never materialize (0.14x, 0.54x \u2014 semi-join destroyed)\n2. Same-column OR \u2192 never split to UNION (0.23x, 0.59x \u2014 native OR handling)\n3. Baseline < 100ms \u2192 skip CTE-based rewrites (overhead exceeds savings)\n4. 3+ fact table joins \u2192 do not pre-materialize facts (locks join order)\n5. Every CTE MUST have a WHERE clause (0.85x observed)\n6. No orphaned CTEs \u2014 remove original after splitting (0.49x, 0.68x \u2014 double materialization)\n7. No cross-joining 3+ dimension CTEs (0.0076x \u2014 Cartesian product)\n8. Max 2 cascading fact-table CTE chains (0.78x observed)\n9. Convert comma joins to explicit JOIN...ON\n10. NOT EXISTS \u2192 NOT IN breaks with NULLs \u2014 preserve EXISTS form\n\n---\n\n## DOCUMENTED CASES\n\nCases ordered by safety (zero-regression cases first, then by decreasing risk).\n\n**P0: Predicate Chain Pushback** (SMALLEST SET FIRST) \u2014 ~35% of wins\n\n| Aspect | Detail |\n|---|---|\n| Detect | Row counts flat through CTE chain, sharp drop at late filter. 2+ stage CTE chain + late predicate with columns available earlier. |\n| Gates | Filter ratio >5:1 strong, 2:1\u20135:1 moderate if baseline >200ms, <2:1 skip. 1 fact = safe, 2 = careful, 3+ = STOP (0.50x). ROLLUP/WINDOW downstream: CAUTION (0.85x). CTE already filtered on this predicate: skip (0.71x). |\n| Treatments | date_cte_isolate (12 wins, 1.34x avg), prefetch_fact_join (4 wins, 1.89x avg), multi_dimension_prefetch (3 wins, 1.55x avg), multi_date_range_cte (3 wins, 1.42x avg), shared_dimension_multi_channel (1 win, 1.40x), self_join_decomposition (1 win, 4.76x) |\n| Failures | 0.0076x (3 dim CTE cross-join \u2192 Cartesian), 0.50x (3-fact join lock), 0.85x (ROLLUP blocked), 0.71x (over-decomposed) |\n\n**P1: Repeated Scans of Same Table** (DON'T REPEAT WORK) \u2014 ZERO REGRESSIONS\n\n| Aspect | Detail |\n|---|---|\n| Detect | N separate SEQ_SCAN nodes on same table, identical joins, different bucket filters. |\n| Gates | Identical join structure across all subqueries, max 8 branches, COUNT/SUM/AVG/MIN/MAX only (not STDDEV/VARIANCE/PERCENTILE). |\n| Treatments | single_pass_aggregation (8 wins, 1.88x avg), channel_bitmap_aggregation (1 win, 6.24x) |\n| Failures | None observed. |\n\n**P3: Aggregation After Join** (MINIMIZE ROWS TOUCHED) \u2014 ZERO REGRESSIONS\n\n| Aspect | Detail |\n|---|---|\n| Detect | GROUP BY input rows >> distinct keys, aggregate node sits after join. |\n| Gates | GROUP BY keys \u2287 join keys (CORRECTNESS). Reconstruct AVG from SUM/COUNT when pre-aggregating for ROLLUP. |\n| Treatments | aggregate_pushdown, star_join_prefetch. 3 wins (1.3x\u201342.9x, avg 15.3x). |\n| Failures | None observed. |\n\n**P5: LEFT JOIN + NULL-Eliminating WHERE** (ARM THE OPTIMIZER) \u2014 ZERO REGRESSIONS\n\n| Aspect | Detail |\n|---|---|\n| Detect | LEFT JOIN + WHERE on right-table column (proves right non-null). |\n| Gates | No CASE WHEN IS NULL / COALESCE on right-table column. |\n| Treatments | inner_join_conversion. 2 wins (1.9x\u20133.4x, avg 2.7x). |\n| Failures | None observed. |\n\n**P6: INTERSECT Materializing Both Sides** (SETS OVER LOOPS) \u2014 ZERO REGRESSIONS\n\n| Aspect | Detail |\n|---|---|\n| Detect | INTERSECT between 10K+ row result sets. |\n| Gates | Both sides >1K rows. |\n| Treatments | intersect_to_exists, multi_intersect_exists_cte. 1 win (2.7x). Related: semi_join_exists (1.67x). |\n| Failures | None observed. |\n\n**P8: Window Functions in CTEs Before Join** (MINIMIZE ROWS TOUCHED) \u2014 ZERO REGRESSIONS\n\n| Aspect | Detail |\n|---|---|\n| Detect | N WINDOW nodes inside CTEs, same ORDER BY key, CTEs then joined. |\n| Gates | Not LAG/LEAD (depends on pre-join row order), not ROWS BETWEEN with specific frame. SUM() OVER() naturally skips NULLs. |\n| Treatments | deferred_window_aggregation. 1 win (1.4x). |\n| Failures | None observed. |\n\n**P7: Self-Joined CTE Materialized for All Values** (SMALLEST SET FIRST)\n\n| Aspect | Detail |\n|---|---|\n| Detect | CTE joined to itself with different WHERE per arm (e.g., period=1 vs period=2). |\n| Gates | 2\u20134 discriminator values, MUST remove original combined CTE after splitting. |\n| Treatments | self_join_decomposition (1 win, 4.76x), union_cte_split (2 wins, 1.72x avg), rollup_to_union_windowing (1 win, 2.47x) |\n| Failures | 0.49x (orphaned CTE \u2192 double materialization), 0.68x (orphaned variant) |\n\n**P2: Correlated Subquery Nested Loop** (SETS OVER LOOPS)\n\n| Aspect | Detail |\n|---|---|\n| Detect | Nested loop, inner re-executes aggregate per outer row. If EXPLAIN shows hash join on correlation key \u2192 already decorrelated \u2192 STOP. |\n| Gates | NEVER decorrelate EXISTS (0.34x, 0.14x \u2014 semi-join destroyed). Preserve ALL WHERE filters. Check if Phase 1 reduced outer to <1000 rows (nested loop may be fast enough). |\n| Treatments | decorrelate (3 wins, 2.45x avg), composite_decorrelate_union (1 win, 2.42x) |\n| Failures | 0.34x (semi-join destroyed), 0.71x (already decorrelated) |\n\n**P9: Shared Subexpression Executed Multiple Times** (DON'T REPEAT WORK)\n\n| Aspect | Detail |\n|---|---|\n| Detect | Identical subtrees with identical costs scanning same tables. HARD STOP: EXISTS/NOT EXISTS \u2192 NEVER materialize (0.14x). |\n| Gates | NOT EXISTS, subquery is expensive (joins/aggregates), CTE must have WHERE. |\n| Treatments | materialize_cte. 1 win (1.4x). |\n| Failures | 0.14x (EXISTS materialized \u2192 semi-join destroyed), 0.54x (correlated EXISTS pairs broken) |\n\n**P4: Cross-Column OR Forcing Full Scan** (MINIMIZE ROWS TOUCHED) \u2014 HIGHEST VARIANCE\n\n| Aspect | Detail |\n|---|---|\n| Detect | Single scan, OR across DIFFERENT columns, 70%+ rows discarded. CRITICAL: same column in all OR arms \u2192 STOP (engine handles natively). |\n| Gates | Max 3 branches, cross-column only, no self-join, no nested OR (multiplicative expansion). |\n| Treatments | or_to_union. 4 wins (1.4x\u20136.3x, avg 3.1x). |\n| Failures | 0.23x (9 branches from nested OR), 0.41x (nested OR expansion), 0.59x (same-col split), 0.51x (self-join re-executed per branch) |\n\n---\n\n## PRUNING GUIDE\n\n| Plan shows | Skip |\n|---|---|\n| No nested loops | P2 (decorrelation) |\n| Each table appears once | P1 (repeated scans) |\n| No LEFT JOIN | P5 (INNER conversion) |\n| No OR predicates | P4 (OR decomposition) |\n| No GROUP BY | P3 (aggregate pushdown) |\n| No WINDOW/OVER | P8 (deferred window) |\n| No INTERSECT/EXCEPT | P6 (set rewrite) |\n| Baseline < 50ms | ALL CTE-based transforms |\n| Row counts monotonically decreasing | P0 (predicate pushback) |\n\n## REGRESSION REGISTRY\n\n| Severity | Transform | Result | Root cause |\n|----------|-----------|--------|------------|\n| CATASTROPHIC | dimension_cte_isolate | 0.0076x | Cross-joined 3 dim CTEs: Cartesian product |\n| CATASTROPHIC | materialize_cte | 0.14x | Materialized EXISTS \u2192 semi-join destroyed |\n| SEVERE | or_to_union | 0.23x | 9 UNION branches from nested OR |\n| SEVERE | decorrelate | 0.34x | LEFT JOIN was already semi-join |\n| MAJOR | union_cte_split | 0.49x | Original CTE kept \u2192 double materialization |\n| MAJOR | date_cte_isolate | 0.50x | 3-way fact join locked optimizer order |\n| MAJOR | or_to_union | 0.51x | Self-join re-executed per branch |\n| MAJOR | semantic_rewrite | 0.54x | Correlated EXISTS pairs broken |\n| MODERATE | or_to_union | 0.59x | Split same-column OR |\n| MODERATE | union_cte_split | 0.68x | Original CTE kept alongside split |\n| MODERATE | decorrelate | 0.71x | Pre-aggregated ALL stores when only subset needed |\n| MODERATE | prefetch_fact_join | 0.78x | 3rd cascading CTE chain |\n| MINOR | multi_dimension_prefetch | 0.77x | Forced suboptimal join order |\n| MINOR | date_cte_isolate | 0.85x | CTE blocked ROLLUP pushdown |\n",
  "detected_transforms": "[TransformMatch(id='decorrelate', overlap_ratio=1.0, matched_features=['AGG_AVG', 'AGG_SUM', 'CORRELATED_SUB', 'CTE', 'DATE_DIM', 'GROUP_BY'], missing_features=[], total_required=6, gap='CORRELATED_SUBQUERY_PARALYSIS', engines=['duckdb'], contraindications=[{'id': 'MISSING_FILTER', 'instruction': 'Preserve ALL WHERE filters from original subquery \u2014 missing filter = cross-product', 'severity': 'CRITICAL', 'worst_ratio': 0.34}, {'id': 'ALREADY_DECORRELATED', 'instruction': 'Check EXPLAIN \u2014 if hash join (not nested loop), optimizer already decorrelated', 'severity': 'MEDIUM', 'worst_ratio': None}]), TransformMatch(id='prefetch_fact_join', overlap_ratio=1.0, matched_features=['AGG_SUM', 'DATE_DIM', 'GROUP_BY', 'STAR_JOIN'], missing_features=[], total_required=4, gap='CROSS_CTE_PREDICATE_BLINDNESS', engines=['duckdb'], contraindications=[{'id': 'MAX_2_CHAINS', 'instruction': 'Max 2 cascading fact-table CTE chains \u2014 3rd causes excessive materialization', 'severity': 'MEDIUM', 'worst_ratio': 0.78}]), TransformMatch(id='dimension_cte_isolate', overlap_ratio=1.0, matched_features=['DATE_DIM', 'GROUP_BY', 'MULTI_TABLE_5+'], missing_features=[], total_required=3, gap='CROSS_CTE_PREDICATE_BLINDNESS', engines=['duckdb'], contraindications=[{'id': 'CROSS_JOIN_3_DIMS', 'instruction': 'NEVER cross-join 3+ dimension CTEs \u2014 Cartesian explosion', 'severity': 'CRITICAL', 'worst_ratio': 0.0076}, {'id': 'UNFILTERED_CTE', 'instruction': 'Every CTE must have a WHERE clause \u2014 unfiltered CTE = pure overhead', 'severity': 'HIGH', 'worst_ratio': None}]), TransformMatch(id='self_join_decomposition', overlap_ratio=1.0, matched_features=['AGG_AVG', 'CTE', 'GROUP_BY'], missing_features=[], total_required=3, gap='CROSS_CTE_PREDICATE_BLINDNESS', engines=['duckdb'], contraindications=[]), TransformMatch(id='multi_dimension_prefetch', overlap_ratio=0.75, matched_features=['AGG_SUM', 'DATE_DIM', 'GROUP_BY'], missing_features=['CASE_EXPR'], total_required=4, gap='CROSS_CTE_PREDICATE_BLINDNESS', engines=['duckdb'], contraindications=[])]",
  "qerror_analysis": "QErrorAnalysis(signals=[QErrorSignal(node_type='HASH_JOIN', estimated=1, actual=157800, q_error=157800.0, direction='UNDER_EST', timing_ms=2.8957389999999994), QErrorSignal(node_type='PROJECTION', estimated=0, actual=157800, q_error=157800.0, direction='ZERO_EST', timing_ms=0.10308200000000001), QErrorSignal(node_type='HASH_JOIN', estimated=0, actual=157800, q_error=157800.0, direction='ZERO_EST', timing_ms=3.678885), QErrorSignal(node_type='HASH_JOIN', estimated=1, actual=157785, q_error=157785.0, direction='UNDER_EST', timing_ms=24.617302000000002), QErrorSignal(node_type='HASH_JOIN', estimated=0, actual=157785, q_error=157785.0, direction='ZERO_EST', timing_ms=14.798226000000003), QErrorSignal(node_type='COLUMN_DATA_SCAN', estimated=0, actual=157785, q_error=157785.0, direction='ZERO_EST', timing_ms=0.36453500000000005), QErrorSignal(node_type='PROJECTION', estimated=1, actual=61974, q_error=61974.0, direction='UNDER_EST', timing_ms=0.02986400000000001), QErrorSignal(node_type='FILTER', estimated=1, actual=61974, q_error=61974.0, direction='UNDER_EST', timing_ms=5.078829), QErrorSignal(node_type='PROJECTION', estimated=23044, actual=557705, q_error=24.201744488804028, direction='UNDER_EST', timing_ms=0.33539099999999994), QErrorSignal(node_type='PROJECTION', estimated=23044, actual=557705, q_error=24.201744488804028, direction='UNDER_EST', timing_ms=3.4699750000000007), QErrorSignal(node_type='HASH_JOIN', estimated=23044, actual=557705, q_error=24.201744488804028, direction='UNDER_EST', timing_ms=5.765125), QErrorSignal(node_type='PROJECTION', estimated=23035, actual=539331, q_error=23.413544606034296, direction='UNDER_EST', timing_ms=0.794467), QErrorSignal(node_type='HASH_GROUP_BY', estimated=23035, actual=539331, q_error=23.413544606034296, direction='UNDER_EST', timing_ms=124.628903), QErrorSignal(node_type='CTE_SCAN', estimated=23035, actual=539331, q_error=23.413544606034296, direction='UNDER_EST', timing_ms=1.787963), QErrorSignal(node_type='CTE_SCAN', estimated=23035, actual=539331, q_error=23.413544606034296, direction='UNDER_EST', timing_ms=1.381954), QErrorSignal(node_type='PROJECTION', estimated=0, actual=15, q_error=15.0, direction='ZERO_EST', timing_ms=0.02392), QErrorSignal(node_type='HASH_GROUP_BY', estimated=0, actual=15, q_error=15.0, direction='ZERO_EST', timing_ms=15.185523), QErrorSignal(node_type='HASH_GROUP_BY', estimated=0, actual=15, q_error=15.0, direction='ZERO_EST', timing_ms=0.9951250000000001), QErrorSignal(node_type='SEQ_SCAN ', estimated=2877532, actual=557705, q_error=5.159595126455743, direction='OVER_EST', timing_ms=23.717715000000002)], max_q_error=157800.0, severity='S1', direction='UNDER_EST', locus='JOIN', magnitude='EXTREME', structural_flags=['EST_ONE_NONLEAF', 'EST_ZERO', 'DELIM_SCAN', 'LEFT_JOIN'], pathology_candidates=['P2', 'P0', 'P6', 'P5'])"
}