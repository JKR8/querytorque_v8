### What went wrong
The optimization incorrectly reordered the ROLLUP aggregation and ranking operations, changing query semantics. In the original query, the ROLLUP generates super-aggregate rows (e.g., subtotals by category) from the full dataset before ranking. The ranking is then computed over these aggregated rows (including super-aggregates) within each category. The attempted optimization first ranks detailed rows (pre-aggregation), filters to top 100 per category, then applies ROLLUPâ€”causing super-aggregate rows to be computed only from filtered data. This alters results because:
1. Super-aggregate rows in the original could rank high even if their constituent detailed rows don't individually make the top 100.
2. The final ROLLUP in the attempt generates new super-aggregate rows absent from the original ranking.

### Why speedup was insufficient
Even if semantics were preserved, the dominant cost center remains the initial aggregation (detailed_sales CTE at 85% cost). This step still performs a full join and GROUP BY on the entire store_sales dataset for the 12-month date range. The subsequent ranking and filtering are cheap, but the heavy aggregation is unchanged. The final ROLLUP on filtered data is minimal (15% cost) but doesn't offset the initial overhead. The bottleneck persists because the optimization failed to reduce the volume of data processed in the primary aggregation.

### Next approach
Propose a **novel pushdown with partial pre-aggregation**:
1. Pre-aggregate sales at the **date-store-item** granularity using a CTE that sums sales per day, store, and item.
2. Join this pre-aggregated data with dimension tables (item, store, date_dim) to attach category, class, etc.
3. Apply ROLLUP on the joined result (which now has far fewer rows than raw store_sales).
4. Rank and filter as in the original order.

**Example structure**:
```sql
WITH daily_agg AS (
    SELECT 
        ss_item_sk,
        ss_store_sk,
        ss_sold_date_sk,
        SUM(ss_sales_price * ss_quantity) AS daily_sales
    FROM store_sales
    GROUP BY ss_item_sk, ss_store_sk, ss_sold_date_sk
)
SELECT /* rest of original query joining daily_agg with dims and applying ROLLUP */ 
```
This reduces the rows fed into the expensive ROLLUP by orders of magnitude (since sales are pre-aggregated daily). The joins become cheaper due to fewer rows, and the ROLLUP operates on a condensed dataset while preserving semantics.

### Learned constraints
- **Never reorder ROLLUP and ranking**: Super-aggregate rows must be included in ranking input.
- **Avoid filtering before ROLLUP**: Any reduction before ROLLUP changes super-aggregate values and ranking outcomes.
- **Pre-aggregate at the finest safe granularity**: Push aggregation earlier only at levels that don't affect later grouping columns (e.g., daily before rolling up to month/year).
- **Preserve all grouping columns for ROLLUP**: Pre-aggregation must retain all columns needed for the final ROLLUP dimensions (item, store, date) to avoid semantic drift.