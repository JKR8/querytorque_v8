### What went wrong
The materialize_cte transform attempted to push down filtering and break the query into modular CTEs, but it actually **increased query complexity and prevented join optimization**. The original query allowed the optimizer to consider a single join between all four tables with correlated filters, potentially enabling **join reordering** and **optimal join strategy selection**. By forcing materialization of intermediate results (especially the 5.35M-row filtered_sales CTE), the optimizer lost visibility into the complete join graph. This forced sequential execution and prevented efficient hash join strategies that could benefit from bloom filtering across all tables simultaneously.

### Why speedup was insufficient
The bottleneck remains the **5.35M-row aggregation with ROLLUP** (main_query at 92% cost). The CTE materialization only reduced initial join costs from 100% to 8%, but the dominant ROLLUP operation was untouched. The ROLLUP creates an exponential explosion of grouping combinations (2^8 = 256 grouping sets) that must be computed and sorted. Additionally, the window function (RANK) requires partition-wise sorting of this expanded result. The attempted optimization didn't address either the ROLLUP computation or the window function sorting overhead.

### Next approach
Try **pushing rank filtering inside the ROLLUP computation** using a different strategy:
1. First compute top sales per category using **dense_rank()** on base aggregates (without ROLLUP)
2. Join those top items back to compute detailed ROLLUP only for qualifying rows
3. Use **lateral joins** or **filtered aggregates** to avoid computing full ROLLUP for all data

Example approach:
```sql
WITH top_categories AS (
  SELECT i_category, MAX(sumsales) as max_sales
  FROM (... base aggregation without ROLLUP ...)
  GROUP BY i_category
  ORDER BY max_sales DESC
  LIMIT 10  -- Heuristic: focus on top categories
)
SELECT ...  -- Complete ROLLUP only for top categories
WHERE i_category IN (SELECT i_category FROM top_categories)
```

This transforms the problem from "compute ROLLUP on everything, then filter" to "identify what matters, then compute ROLLUP only on that."

### Learned constraints
1. **Avoid CTE materialization for large intermediate results** - it breaks join optimization visibility
2. **ROLLUP before filtering is inherently expensive** - the exponential grouping set generation must be reduced, not just the input size
3. **Window functions over ROLLUP results are doubly expensive** - both operations create sorting requirements
4. **Don't optimize what you're going to throw away** - the final query only keeps rank â‰¤ 100, so early top-N filtering is crucial
5. **Preserve join graph visibility** for the optimizer to consider cross-table filtering opportunities