You are an expert database performance analyst. Your job is to deeply analyze a slow SQL query, identify the root cause of its performance problems, and propose specific structural changes.

You follow a rigorous methodology: understand the structure, profile the costs, identify the mechanism (not just the symptom), propose changes with correctness reasoning, and learn from past failures.

## Query: query_4
## Dialect: duckdb

```sql
WITH year_total AS (
  SELECT
    c_customer_id AS customer_id,
    c_first_name AS customer_first_name,
    c_last_name AS customer_last_name,
    c_preferred_cust_flag AS customer_preferred_cust_flag,
    c_birth_country AS customer_birth_country,
    c_login AS customer_login,
    c_email_address AS customer_email_address,
    d_year AS dyear,
    SUM(
      (
        (
          ss_ext_list_price - ss_ext_wholesale_cost - ss_ext_discount_amt
        ) + ss_ext_sales_price
      ) / 2
    ) AS year_total,
    's' AS sale_type
  FROM customer, store_sales, date_dim
  WHERE
    c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk
  GROUP BY
    c_customer_id,
    c_first_name,
    c_last_name,
    c_preferred_cust_flag,
    c_birth_country,
    c_login,
    c_email_address,
    d_year
  UNION ALL
  SELECT
    c_customer_id AS customer_id,
    c_first_name AS customer_first_name,
    c_last_name AS customer_last_name,
    c_preferred_cust_flag AS customer_preferred_cust_flag,
    c_birth_country AS customer_birth_country,
    c_login AS customer_login,
    c_email_address AS customer_email_address,
    d_year AS dyear,
    SUM(
      (
        (
          (
            cs_ext_list_price - cs_ext_wholesale_cost - cs_ext_discount_amt
          ) + cs_ext_sales_price
        ) / 2
      )
    ) AS year_total,
    'c' AS sale_type
  FROM customer, catalog_sales, date_dim
  WHERE
    c_customer_sk = cs_bill_customer_sk AND cs_sold_date_sk = d_date_sk
  GROUP BY
    c_customer_id,
    c_first_name,
    c_last_name,
    c_preferred_cust_flag,
    c_birth_country,
    c_login,
    c_email_address,
    d_year
  UNION ALL
  SELECT
    c_customer_id AS customer_id,
    c_first_name AS customer_first_name,
    c_last_name AS customer_last_name,
    c_preferred_cust_flag AS customer_preferred_cust_flag,
    c_birth_country AS customer_birth_country,
    c_login AS customer_login,
    c_email_address AS customer_email_address,
    d_year AS dyear,
    SUM(
      (
        (
          (
            ws_ext_list_price - ws_ext_wholesale_cost - ws_ext_discount_amt
          ) + ws_ext_sales_price
        ) / 2
      )
    ) AS year_total,
    'w' AS sale_type
  FROM customer, web_sales, date_dim
  WHERE
    c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk
  GROUP BY
    c_customer_id,
    c_first_name,
    c_last_name,
    c_preferred_cust_flag,
    c_birth_country,
    c_login,
    c_email_address,
    d_year
)
SELECT
  t_s_secyear.customer_id,
  t_s_secyear.customer_first_name,
  t_s_secyear.customer_last_name,
  t_s_secyear.customer_birth_country
FROM year_total AS t_s_firstyear, year_total AS t_s_secyear, year_total AS t_c_firstyear, year_total AS t_c_secyear, year_total AS t_w_firstyear, year_total AS t_w_secyear
WHERE
  t_s_secyear.customer_id = t_s_firstyear.customer_id
  AND t_s_firstyear.customer_id = t_c_secyear.customer_id
  AND t_s_firstyear.customer_id = t_c_firstyear.customer_id
  AND t_s_firstyear.customer_id = t_w_firstyear.customer_id
  AND t_s_firstyear.customer_id = t_w_secyear.customer_id
  AND t_s_firstyear.sale_type = 's'
  AND t_c_firstyear.sale_type = 'c'
  AND t_w_firstyear.sale_type = 'w'
  AND t_s_secyear.sale_type = 's'
  AND t_c_secyear.sale_type = 'c'
  AND t_w_secyear.sale_type = 'w'
  AND t_s_firstyear.dyear = 1999
  AND t_s_secyear.dyear = 1999 + 1
  AND t_c_firstyear.dyear = 1999
  AND t_c_secyear.dyear = 1999 + 1
  AND t_w_firstyear.dyear = 1999
  AND t_w_secyear.dyear = 1999 + 1
  AND t_s_firstyear.year_total > 0
  AND t_c_firstyear.year_total > 0
  AND t_w_firstyear.year_total > 0
  AND CASE
    WHEN t_c_firstyear.year_total > 0
    THEN t_c_secyear.year_total / t_c_firstyear.year_total
    ELSE NULL
  END > CASE
    WHEN t_s_firstyear.year_total > 0
    THEN t_s_secyear.year_total / t_s_firstyear.year_total
    ELSE NULL
  END
  AND CASE
    WHEN t_c_firstyear.year_total > 0
    THEN t_c_secyear.year_total / t_c_firstyear.year_total
    ELSE NULL
  END > CASE
    WHEN t_w_firstyear.year_total > 0
    THEN t_w_secyear.year_total / t_w_firstyear.year_total
    ELSE NULL
  END
ORDER BY
  t_s_secyear.customer_id,
  t_s_secyear.customer_first_name,
  t_s_secyear.customer_last_name,
  t_s_secyear.customer_birth_country
LIMIT 100
```

## Query Structure (DAG)

### 1. year_total
**Role**: CTE (Definition Order: 0)
**Stats**: 50% Cost | ~1k rows
**Flags**: GROUP_BY, UNION_ALL
**Outputs**: [customer_id, customer_first_name, customer_last_name, customer_preferred_cust_flag, customer_birth_country, customer_login, customer_email_address, dyear, year_total, sale_type]
**Dependencies**: customer, web_sales (join), date_dim (join), store_sales (join), catalog_sales (join)
**Joins**: c_customer_sk = ws_bill_customer_sk | ws_sold_date_sk = d_date_sk
**Operators**: HASH_GROUP_BY, SEQ_SCAN[customer], SEQ_SCAN[web_sales], SEQ_SCAN[date_dim]
**Key Logic (SQL)**:
```sql
SELECT
  c_customer_id AS customer_id,
  c_first_name AS customer_first_name,
  c_last_name AS customer_last_name,
  c_preferred_cust_flag AS customer_preferred_cust_flag,
  c_birth_country AS customer_birth_country,
  c_login AS customer_login,
  c_email_address AS customer_email_address,
  d_year AS dyear,
  SUM(
    (
      (
        ss_ext_list_price - ss_ext_wholesale_cost - ss_ext_discount_amt
      ) + ss_ext_sales_price
    ) / 2
  ) AS year_total,
  's' AS sale_type
FROM customer, store_sales, date_dim
WHERE
  c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk
...
```

### 2. main_query
**Role**: Root / Output (Definition Order: 1)
**Stats**: 50% Cost | ~1k rows processed → 100 rows output
**Flags**: GROUP_BY, ORDER_BY, LIMIT(100)
**Outputs**: [customer_id, customer_first_name, customer_last_name, customer_birth_country] — ordered by t_s_secyear.customer_id ASC, t_s_secyear.customer_first_name ASC, t_s_secyear.customer_last_name ASC, t_s_secyear.customer_birth_country ASC
**Dependencies**: year_total AS t_s_firstyear (join), year_total AS t_s_secyear (join), year_total AS t_c_firstyear (join), year_total AS t_c_secyear (join), year_total AS t_w_firstyear (join), year_total AS t_w_secyear (join)
**Joins**: t_s_secyear.customer_id = t_s_firstyear.customer_id | t_s_firstyear.customer_id = t_c_secyear.customer_id | t_s_firstyear.customer_id = t_c_firstyear.customer_id | t_s_firstyear.customer_id = t_w_firstyear.customer_id | t_s_firstyear.customer_id = t_w_secyear.customer_id
**Filters**: t_s_firstyear.sale_type = 's' | t_c_firstyear.sale_type = 'c' | t_w_firstyear.sale_type = 'w' | t_s_secyear.sale_type = 's' | t_c_secyear.sale_type = 'c' | t_w_secyear.sale_type = 'w' | t_s_firstyear.dyear = 1999 | t_s_secyear.dyear = 1999 + 1 | t_c_firstyear.dyear = 1999 | t_c_secyear.dyear = 1999 + 1 | t_w_firstyear.dyear = 1999 | t_w_secyear.dyear = 1999 + 1 | t_s_firstyear.year_total > 0 | t_c_firstyear.year_total > 0 | t_w_firstyear.year_total > 0 | CASE WHEN t_c_firstyear.year_total > 0 THEN t_c_secyear.year_total / t_c_firstyear.year_total ELSE NULL END > CASE WHEN t_s_firstyear.year_total > 0 THEN t_s_secyear.year_total / t_s_firstyear.year_total ELSE NULL END | CASE WHEN t_c_firstyear.year_total > 0 THEN t_c_secyear.year_total / t_c_firstyear.year_total ELSE NULL END > CASE WHEN t_w_firstyear.year_total > 0 THEN t_w_secyear.year_total / t_w_firstyear.year_total ELSE NULL END
**Operators**: HASH_GROUP_BY, HASH_JOIN, SEQ_SCAN[year_total], SEQ_SCAN[year_total], SEQ_SCAN[year_total]
**Key Logic (SQL)**:
```sql
SELECT
  t_s_secyear.customer_id,
  t_s_secyear.customer_first_name,
  t_s_secyear.customer_last_name,
  t_s_secyear.customer_birth_country
FROM year_total AS t_s_firstyear, year_total AS t_s_secyear, year_total AS t_c_firstyear, year_total AS t_c_secyear, year_total AS t_w_firstyear, year_total AS t_w_secyear
WHERE
  t_s_secyear.customer_id = t_s_firstyear.customer_id
  AND t_s_firstyear.customer_id = t_c_secyear.customer_id
  AND t_s_firstyear.customer_id = t_c_firstyear.customer_id
  AND t_s_firstyear.customer_id = t_w_firstyear.customer_id
  AND t_s_firstyear.customer_id = t_w_secyear.customer_id
  AND t_s_firstyear.sale_type = 's'
  AND t_c_firstyear.sale_type = 'c'
  AND t_w_firstyear.sale_type = 'w'
  AND t_s_secyear.sale_type = 's'
  AND t_c_secyear.sale_type = 'c'
  AND t_w_secyear.sale_type = 'w'
  AND t_s_firstyear.dyear = 1999
  AND t_s_secyear.dyear = 1999 + 1
...
```

### Edges
- year_total → main_query
- year_total → main_query
- year_total → main_query
- year_total → main_query
- year_total → main_query
- year_total → main_query


## Reference Examples

**FAISS selected (by structural similarity):** union_cte_split, intersect_to_exists, shared_dimension_multi_channel

**All available gold examples:**

- **composite_decorrelate_union** (2.42xx) — Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT
- **date_cte_isolate** (4.00xx) — Extract date filtering into a separate CTE to enable predicate pushdown and redu
- **decorrelate** (2.92xx) — Convert correlated subquery to separate CTE with GROUP BY, then JOIN
- **deferred_window_aggregation** (1.36xx) — When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joi
- **dimension_cte_isolate** (1.93xx) — Pre-filter ALL dimension tables into CTEs before joining with fact table, not ju
- **early_filter** (4.00xx) — Filter dimension tables FIRST, then join to fact tables to reduce expensive join
- **intersect_to_exists** (1.83xx) — Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join pl
- **materialize_cte** (1.37xx) — Extract repeated subquery patterns into a CTE to avoid recomputation
- **multi_date_range_cte** (2.35xx) — When query uses multiple date_dim aliases with different filters (d1, d2, d3), c
- **multi_dimension_prefetch** (2.71xx) — Pre-filter multiple dimension tables (date + store) into separate CTEs before jo
- **or_to_union** (3.17xx) — Split OR conditions on different columns into UNION ALL branches for better inde
- **prefetch_fact_join** (3.77xx) — Pre-filter dimension table into CTE, then pre-join with fact table in second CTE
- **pushdown** (2.11xx) — Push filters from outer query into CTEs/subqueries to reduce intermediate result
- **shared_dimension_multi_channel** (1.30xx) — Extract shared dimension filters (date, item, promotion) into CTEs when multiple
- **single_pass_aggregation** (4.47xx) — Consolidate multiple subqueries scanning the same table into a single CTE with c
- **union_cte_split** (1.36xx) — Split a generic UNION ALL CTE into specialized CTEs when the main query filters 

## Your Task

Analyze this query following these steps IN ORDER:

### 1. STRUCTURAL BREAKDOWN
For each CTE/subquery/block, explain in 1-2 sentences:
- What it computes (in plain language)
- What tables it reads and approximately how many rows
- What it outputs (cardinality estimate)

### 2. BOTTLENECK IDENTIFICATION
Using the DAG costs above, identify the dominant cost center.
Don't just name it — explain the MECHANISM:
- Is it a full table scan that could be filtered?
- Is it a sort for a window function that could be deferred?
- Is it a hash join on a large build side that could be pre-filtered?
- Is it scanning the same table multiple times when once would suffice?

### 3. PROPOSED OPTIMIZATION
Propose 1-3 specific structural changes. For EACH one:
- **What**: Exactly what to change (e.g., 'merge CTEs X and Y into one scan')
- **Why**: The performance mechanism (e.g., 'eliminates a 28M-row rescan of store_sales')
- **Risk**: What semantic constraint could break (e.g., 'the HAVING filter must be preserved')
- **Estimated impact**: minor / moderate / significant

### 5. RECOMMENDED STRATEGY
Synthesize everything into a single recommended optimization approach.
Be specific enough that another engineer could implement it from your description.

### 6. EXAMPLE SELECTION
FAISS selected these examples: union_cte_split, intersect_to_exists, shared_dimension_multi_channel
Review the FAISS picks against the available examples above.
If you think different examples would be more relevant for this query,
list your preferred examples. Otherwise confirm the FAISS picks are good.

```
EXAMPLES: example_id_1, example_id_2, example_id_3
```

Use exact IDs from the available examples list above.
