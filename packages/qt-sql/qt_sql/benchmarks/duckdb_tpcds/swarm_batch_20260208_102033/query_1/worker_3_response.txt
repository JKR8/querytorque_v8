```sql
WITH filtered_date AS (
    SELECT d_date_sk
    FROM date_dim
    WHERE d_year = 2000
),
filtered_store AS (
    SELECT s_store_sk
    FROM store
    WHERE s_state = 'SD'
),
store_returns_filtered AS (
    SELECT 
        sr.sr_customer_sk,
        sr.sr_store_sk,
        sr.SR_FEE
    FROM store_returns sr
    INNER JOIN filtered_date fd ON sr.sr_returned_date_sk = fd.d_date_sk
    INNER JOIN filtered_store fs ON sr.sr_store_sk = fs.s_store_sk
),
customer_store_returns AS (
    SELECT
        sr_customer_sk AS ctr_customer_sk,
        sr_store_sk AS ctr_store_sk,
        SUM(SR_FEE) AS ctr_total_return,
        AVG(SUM(SR_FEE)) OVER (PARTITION BY sr_store_sk) AS store_avg_return
    FROM store_returns_filtered
    GROUP BY sr_customer_sk, sr_store_sk
)
SELECT
    c.c_customer_id
FROM customer_store_returns ctr1
INNER JOIN customer c ON ctr1.ctr_customer_sk = c.c_customer_sk
WHERE ctr1.ctr_total_return > ctr1.store_avg_return * 1.2
ORDER BY c.c_customer_id
LIMIT 100
```

```
Changes: Pre-filtered date and store dimensions, pre-joined with store_returns in a single pass, computed store averages using window function to eliminate correlated subquery.
Expected speedup: 2-3x by reducing fact table scans, eliminating correlation, and filtering dimensions early.
```

**Explanation of rewrite:**

1. **Applied `prefetch_fact_join` strategy**: Created `filtered_date` and `filtered_store` CTEs to isolate dimension filters early, then joined them with `store_returns` in `store_returns_filtered`. This reduces the fact table scan to only rows matching both date and store criteria.

2. **Eliminated correlated subquery**: Instead of computing store averages in a correlated subquery, used a window function (`AVG() OVER (PARTITION BY sr_store_sk)`) in the aggregation CTE. This computes all store averages in a single pass over the already-filtered data.

3. **Maintained semantic equivalence**: 
   - The `WHERE s_state = 'SD'` filter is applied in `filtered_store` CTE
   - The `d_year = 2000` filter is applied in `filtered_date` CTE  
   - The comparison `ctr_total_return > store_avg_return * 1.2` uses the same 1.2 multiplier
   - Output column `c_customer_id` and ordering remain unchanged

4. **Preserved all required columns**: Each CTE includes all columns needed by downstream joins, ensuring no execution errors.

This rewrite follows the `aggressive_multi_cte_prefetch` strategy by filtering dimensions early and computing aggregates in a single pass, eliminating the expensive correlated subquery execution pattern.