{
  "principles": [
    {
      "id": "dimension_cte_isolate",
      "name": "Dimension Cte Isolate",
      "what": "Applied dimension_cte_isolate, date_cte_isolate achieving 6.24x speedup",
      "why": "Pre-filtering all dimension tables into CTEs avoids repeated full-table scans; Pre-filtering date dimension into CTE reduces hash join probe table from 73K to ~365 rows",
      "when": "Query joins 2+ dimension tables that could each be pre-filtered independently",
      "when_not": "Caused regression on query_12, query_16, query_25, query_31, query_32, query_33, query_34, query_37, query_44, query_5, query_54, query_55, query_61, query_69, query_74, query_75, query_82, query_89, query_9, query_90, query_91, query_92, query_94, query_96 (worst: 0.02x); Materialized date, store, and item dimension filters into CTEs before a ROLLUP aggregation with window functions (RANK() OVER). CTE materialization prevents the optimizer from pushing the ROLLUP and w",
      "verified_speedups": [
        6.2373882475101565,
        1.5658230001570317,
        1.3792819616907084,
        1.2765588616238608,
        1.2487192322686953,
        1.2110840731577763
      ],
      "avg_speedup": 2.153,
      "queries": [
        "query_13",
        "query_18",
        "query_41",
        "query_80",
        "query_84",
        "query_88"
      ],
      "transforms": [
        "date_cte_isolate",
        "dimension_cte_isolate",
        "multi_dimension_prefetch",
        "single_pass_aggregation"
      ]
    },
    {
      "id": "single_pass_aggregation",
      "name": "Single Pass Aggregation",
      "what": "Applied single_pass_aggregation, prefetch_fact_join, multi_date_range_cte achieving 5.85x speedup",
      "why": "Consolidating repeated scans into CASE aggregates reduces I/O from N scans to 1; Pre-joining filtered dimensions with fact table before aggregation reduces join input; Separate CTEs for each date alias avoids ambiguous multi-way date joins",
      "when": "Query has repeated scans of the same fact table with different WHERE filters",
      "when_not": "Caused regression on query_1, query_10, query_11, query_12, query_13, query_14, query_16, query_20, query_23b, query_26, query_28, query_29, query_3, query_31, query_32, query_37, query_42, query_44, query_45, query_46, query_47, query_48, query_5, query_51, query_52, query_55, query_57, query_58, query_61, query_63, query_69, query_7, query_71, query_73, query_74, query_75, query_76, query_78, query_8, query_87, query_89, query_9, query_90, query_91, query_92, query_93, query_94, query_96, query_97 (worst: 0.02x); Pre-computed customer_total_return (GROUP BY customer, store) and store_avg_return (GROUP BY store) as separate CTEs. The original correlated subquery computed the per-store average incrementally duri",
      "verified_speedups": [
        5.853343016368592,
        2.4685052157379332,
        2.3948739526422065,
        2.2287417513388745,
        1.913449880267697,
        1.8164371139891216,
        1.812632729371977,
        1.639086389443567,
        1.6143809499293833,
        1.5010104736396839,
        1.4301197404500123,
        1.3892667039364608,
        1.2577225864588806,
        1.2056217519258987,
        1.1968409607938995,
        1.1784537748926223,
        1.1478163977683398,
        1.1258139731498285
      ],
      "avg_speedup": 1.843,
      "queries": [
        "query_14",
        "query_23a",
        "query_32",
        "query_36",
        "query_38",
        "query_4",
        "query_44",
        "query_53",
        "query_57",
        "query_59",
        "query_60",
        "query_67",
        "query_79",
        "query_86",
        "query_87",
        "query_88",
        "query_90",
        "query_92"
      ],
      "transforms": [
        "decorrelate",
        "dimension_cte_isolate",
        "early_filter",
        "intersect_to_exists",
        "materialize_cte",
        "multi_date_range_cte",
        "multi_dimension_prefetch",
        "or_to_union",
        "prefetch_fact_join",
        "pushdown",
        "single_pass_aggregation",
        "union_cte_split"
      ]
    },
    {
      "id": "prefetch_fact_join",
      "name": "Prefetch Fact Join",
      "what": "Applied prefetch_fact_join, multi_dimension_prefetch, single_pass_aggregation: Applied aggressive multi-CTE prefetch by creating staged CTEs for filtered dimensions (item and date_dim) before joining with the fact table. This reduces the catalog_sales scan early by pushing down selective filters. The conditional aggregations remain consolidated in a single scan.",
      "why": "Pre-joining filtered dimensions with fact table before aggregation reduces join input; Pre-filtering multiple dimension tables in parallel reduces join fan-out; Consolidating repeated scans into CASE aggregates reduces I/O from N scans to 1",
      "when": "Query joins filtered dates/dims with large fact table; pre-join reduces probe size",
      "when_not": "Caused regression on query_1, query_10, query_13, query_14, query_23b, query_26, query_28, query_29, query_3, query_31, query_32, query_42, query_45, query_46, query_47, query_48, query_5, query_52, query_55, query_58, query_69, query_7, query_71, query_72, query_73, query_78, query_8, query_87, query_9, query_90, query_91, query_92, query_93, query_96 (worst: 0.02x); Pre-computed customer_total_return (GROUP BY customer, store) and store_avg_return (GROUP BY store) as separate CTEs. The original correlated subquery computed the per-store average incrementally duri",
      "verified_speedups": [
        5.232336625346366,
        4.686728778957299,
        2.361866531556997,
        2.332325366042106,
        1.855037150982724,
        1.8448737327854032,
        1.7397191441331323,
        1.6469458482745085,
        1.6196398374168426,
        1.5562075695450637,
        1.4869344075425184,
        1.3391566430721515,
        1.3389607915897253,
        1.3239256610840502,
        1.2435931071893527,
        1.240353076721837,
        1.2280077773449636,
        1.2160281675930091,
        1.2057587102326572,
        1.1899987535971144,
        1.1819139994000887,
        1.1806021162452764,
        1.1453033174235459,
        1.107053079181335
      ],
      "avg_speedup": 1.763,
      "queries": [
        "query_1",
        "query_11",
        "query_27",
        "query_35",
        "query_40",
        "query_43",
        "query_45",
        "query_53",
        "query_56",
        "query_57",
        "query_6",
        "query_61",
        "query_64",
        "query_65",
        "query_7",
        "query_74",
        "query_80",
        "query_82",
        "query_83",
        "query_95",
        "query_99"
      ],
      "transforms": [
        "decorrelate",
        "dimension_cte_isolate",
        "early_filter",
        "materialize_cte",
        "multi_dimension_prefetch",
        "or_to_union",
        "prefetch_fact_join",
        "pushdown",
        "single_pass_aggregation"
      ]
    },
    {
      "id": "early_filter",
      "name": "Early Filter",
      "what": "Applied early_filter, pushdown, materialize_cte achieving 5.27x speedup",
      "why": "Applying selective filters early reduces intermediate row counts before expensive operations; Pushing predicates closer to table scans reduces data volume in upper operators; Materializing a CTE used multiple times prevents redundant re-computation",
      "when": "Selective filters on dimension tables are applied late, after expensive joins",
      "when_not": "Caused regression on query_10, query_11, query_23b, query_25, query_28, query_29, query_3, query_31, query_32, query_37, query_42, query_48, query_5, query_52, query_53, query_58, query_61, query_63, query_69, query_71, query_75, query_77, query_81, query_82, query_9, query_91, query_92, query_93, query_94, query_96, query_97 (worst: 0.02x); Pre-filtered and joined store_sales to date CTE BEFORE the 3-way fact table join (store_sales <- store_returns <- catalog_sales). By materializing the date-filtered store_sales early, the optimizer lo",
      "verified_speedups": [
        5.269233093530888,
        2.521264513337834,
        2.017311322590128,
        1.6152624818577372,
        1.5140584817912317,
        1.1614768623993075,
        1.1543625651784728,
        1.1340154958553943,
        1.1309813140521074,
        1.1202902969718573,
        1.1158868699509712,
        1.1126856837322663,
        1.1024179410220403
      ],
      "avg_speedup": 1.69,
      "queries": [
        "query_27",
        "query_37",
        "query_48",
        "query_57",
        "query_62",
        "query_68",
        "query_70",
        "query_72",
        "query_75",
        "query_79",
        "query_88",
        "query_93",
        "query_95"
      ],
      "transforms": [
        "date_cte_isolate",
        "dimension_cte_isolate",
        "early_filter",
        "materialize_cte",
        "prefetch_fact_join",
        "pushdown",
        "single_pass_aggregation"
      ]
    },
    {
      "id": "or_to_union",
      "name": "Or To Union",
      "what": "Applied or_to_union, union_cte_split achieving 6.10x speedup",
      "why": "Converting OR to UNION ALL lets optimizer choose independent index paths per branch; Splitting complex UNION into separate CTEs enables per-branch optimization",
      "when": "WHERE clause has OR conditions over different dimension keys (\u22643 branches)",
      "when_not": "Caused regression on query_11, query_12, query_13, query_16, query_18, query_19, query_20, query_26, query_28, query_29, query_33, query_36, query_38, query_40, query_41, query_45, query_47, query_48, query_52, query_53, query_57, query_61, query_63, query_64, query_68, query_7, query_78, query_8, query_82, query_87, query_89, query_9, query_92, query_93, query_95, query_97 (worst: 0.02x); Created year-specific CTEs (store_sales_1999, store_sales_2000, etc.) but KEPT the original year_total union CTE alongside them. The optimizer materializes both the split versions and the original uni",
      "verified_speedups": [
        6.104619135142192,
        2.1306854692331143,
        1.8183483771040496,
        1.7875141190130917,
        1.283458551687203,
        1.255391547621421,
        1.215936679110929,
        1.195762461654057,
        1.1878234463253028,
        1.1421064087031998,
        1.1323627963163856,
        1.1218212452710785,
        1.1088930774161783,
        1.108791460815752,
        1.102811023014969
      ],
      "avg_speedup": 1.646,
      "queries": [
        "query_15",
        "query_35",
        "query_37",
        "query_56",
        "query_59",
        "query_65",
        "query_7",
        "query_74",
        "query_76",
        "query_79",
        "query_80",
        "query_83",
        "query_84",
        "query_88"
      ],
      "transforms": [
        "date_cte_isolate",
        "decorrelate",
        "dimension_cte_isolate",
        "intersect_to_exists",
        "multi_date_range_cte",
        "or_to_union",
        "prefetch_fact_join",
        "union_cte_split"
      ]
    },
    {
      "id": "union_cte_split",
      "name": "Union Cte Split",
      "what": "Applied union_cte_split, single_pass_aggregation, prefetch_fact_join: Split UNION into separate per-channel CTEs with pre-filtered dimension tables (date_dim, item) and early year filtering, then union aggregated results.",
      "why": "Splitting complex UNION into separate CTEs enables per-branch optimization; Consolidating repeated scans into CASE aggregates reduces I/O from N scans to 1; Pre-joining filtered dimensions with fact table before aggregation reduces join input",
      "when": "Query has UNION/UNION ALL of complex subqueries that share common table references",
      "when_not": "Caused regression on query_11, query_36, query_41, query_51 (worst: 0.35x); Created year-specific CTEs (store_sales_1999, store_sales_2000, etc.) but KEPT the original year_total union CTE alongside them. The optimizer materializes both the split versions and the original uni",
      "verified_speedups": [
        1.403346973764742
      ],
      "avg_speedup": 1.403,
      "queries": [
        "query_75"
      ],
      "transforms": [
        "prefetch_fact_join",
        "single_pass_aggregation",
        "union_cte_split"
      ]
    },
    {
      "id": "pushdown",
      "name": "Pushdown",
      "what": "Applied pushdown, early_filter, materialize_cte achieving 1.79x speedup",
      "why": "Pushing predicates closer to table scans reduces data volume in upper operators; Applying selective filters early reduces intermediate row counts before expensive operations; Materializing a CTE used multiple times prevents redundant re-computation",
      "when": "WHERE predicates reference columns from tables deep in the join tree",
      "when_not": "Caused regression on query_23b, query_25, query_26, query_28, query_3, query_31, query_32, query_47, query_53, query_58, query_61, query_69, query_71, query_73, query_75, query_76, query_77, query_81, query_82, query_85, query_9, query_91, query_92, query_93 (worst: 0.18x); Created year-specific CTEs (store_sales_1999, store_sales_2000, etc.) but KEPT the original year_total union CTE alongside them. The optimizer materializes both the split versions and the original uni",
      "verified_speedups": [
        1.790164901076323,
        1.7405828777308419,
        1.5352754187065603,
        1.223390916715014,
        1.1915897057130815,
        1.139666337832002,
        1.1073640014931196
      ],
      "avg_speedup": 1.39,
      "queries": [
        "query_14",
        "query_23a",
        "query_4",
        "query_41",
        "query_56",
        "query_59",
        "query_65"
      ],
      "transforms": [
        "dimension_cte_isolate",
        "early_filter",
        "materialize_cte",
        "pushdown"
      ]
    },
    {
      "id": "date_cte_isolate",
      "name": "Date Cte Isolate",
      "what": "Applied date_cte_isolate, dimension_cte_isolate: Extracted shared dimension filters (date, item, promotion) into separate CTEs to enable predicate pushdown and avoid redundant joins across channels. Converted implicit joins to explicit JOIN syntax for clarity and optimizer flexibility.",
      "why": "Pre-filtering date dimension into CTE reduces hash join probe table from 73K to ~365 rows; Pre-filtering all dimension tables into CTEs avoids repeated full-table scans",
      "when": "Query joins date_dim on multiple conditions (year, month, etc.) with fact tables",
      "when_not": "Caused regression on query_1, query_3, query_31, query_32, query_33, query_51, query_54, query_61, query_69, query_74, query_78, query_82, query_87, query_91, query_92, query_94, query_96 (worst: 0.02x); Pre-computed customer_total_return (GROUP BY customer, store) and store_avg_return (GROUP BY store) as separate CTEs. The original correlated subquery computed the per-store average incrementally duri",
      "verified_speedups": [
        1.9121582527989138,
        1.8027040998221822,
        1.7389502737366156,
        1.621577277686975,
        1.5831926754693433,
        1.504349354318293,
        1.4948841007596256,
        1.3618019143409292,
        1.2815615118789596,
        1.2526541714671922,
        1.250473647747917,
        1.2166799951058316,
        1.2159707620662126,
        1.2076039099615592,
        1.1683145915473911,
        1.1663518863559634,
        1.1458077765946144,
        1.1389774037337557,
        1.1380110263953256,
        1.1275792400086502,
        1.1092558471117924,
        1.1092221064259817,
        1.1064978075553307,
        1.1052671983232194,
        1.1044555215937641
      ],
      "avg_speedup": 1.315,
      "queries": [
        "query_1",
        "query_10",
        "query_14",
        "query_16",
        "query_27",
        "query_30",
        "query_45",
        "query_49",
        "query_5",
        "query_51",
        "query_56",
        "query_57",
        "query_59",
        "query_65",
        "query_68",
        "query_74",
        "query_75",
        "query_79",
        "query_80",
        "query_82",
        "query_86",
        "query_94",
        "query_97",
        "query_99"
      ],
      "transforms": [
        "date_cte_isolate",
        "dimension_cte_isolate",
        "multi_date_range_cte",
        "multi_dimension_prefetch",
        "union_cte_split"
      ]
    },
    {
      "id": "decorrelate",
      "name": "Decorrelate",
      "what": "Applied decorrelate, date_cte_isolate: ** Converted nested subqueries to a single CTE using window functions, eliminating redundant scans of store_sales and date_dim. Applied explicit joins and pushed date filter early into a CTE.\n\n**Expected speedup:** ~2.5x by reducing table scans from 3 to 1 and avoiding correlated aggregations.",
      "why": "Correlated subqueries re-execute per outer row; converting to JOIN eliminates per-row overhead; Pre-filtering date dimension into CTE reduces hash join probe table from 73K to ~365 rows",
      "when": "Query has correlated subquery in WHERE or SELECT that references outer table",
      "when_not": "Caused regression on query_10, query_16, query_28, query_29, query_33, query_37, query_45, query_54, query_63, query_64, query_68, query_75, query_78, query_9, query_90, query_92, query_94 (worst: 0.02x); Pre-filtered and joined store_sales to date CTE BEFORE the 3-way fact table join (store_sales <- store_returns <- catalog_sales). By materializing the date-filtered store_sales early, the optimizer lo",
      "verified_speedups": [
        1.7268574193043773,
        1.5797328430054858,
        1.4286262786356203,
        1.3526863954165276,
        1.275470311582983,
        1.2667200354869352,
        1.243821973819773,
        1.2390352919494787,
        1.2309031652125118,
        1.191719916932481,
        1.1786867079531627,
        1.1753249873132035,
        1.1715753433352998,
        1.1694504884907846,
        1.1592810341128084,
        1.151017370732424,
        1.1482033872005448,
        1.1448221267562546,
        1.1273954652635738,
        1.1198315895962039
      ],
      "avg_speedup": 1.254,
      "queries": [
        "query_21",
        "query_23a",
        "query_23b",
        "query_30",
        "query_33",
        "query_41",
        "query_44",
        "query_51",
        "query_56",
        "query_58",
        "query_6",
        "query_60",
        "query_63",
        "query_65",
        "query_68",
        "query_73",
        "query_75",
        "query_81",
        "query_82",
        "query_83"
      ],
      "transforms": [
        "date_cte_isolate",
        "decorrelate",
        "dimension_cte_isolate",
        "early_filter",
        "intersect_to_exists",
        "materialize_cte",
        "multi_dimension_prefetch",
        "prefetch_fact_join",
        "single_pass_aggregation",
        "union_cte_split"
      ]
    },
    {
      "id": "intersect_to_exists",
      "name": "Intersect To Exists",
      "what": "Applied intersect_to_exists, decorrelate, or_to_union: Transformed the self-join on `all_sales` into a single-pass aggregation that computes both 1998 and 1999 metrics in conditional sums. This eliminates the expensive self-join and pushes year filters down into the UNION branches. Also changed UNION to UNION ALL for efficiency since duplicates are eliminated by later aggregation.",
      "why": "Replacing INTERSECT with EXISTS avoids materializing full intermediate sets; Correlated subqueries re-execute per outer row; converting to JOIN eliminates per-row overhead; Converting OR to UNION ALL lets optimizer choose independent index paths per branch",
      "when": "Query uses INTERSECT or EXCEPT to combine subquery results",
      "when_not": "Caused regression on query_11, query_12, query_13, query_16, query_18, query_19, query_26, query_28, query_33, query_36, query_38, query_40, query_41, query_45, query_47, query_48, query_52, query_53, query_57, query_61, query_63, query_64, query_78, query_8, query_82, query_87, query_9, query_93, query_94, query_95, query_97 (worst: 0.02x); Created year-specific CTEs (store_sales_1999, store_sales_2000, etc.) but KEPT the original year_total union CTE alongside them. The optimizer materializes both the split versions and the original uni",
      "verified_speedups": [
        1.4042826037161327,
        1.2203256368194746,
        1.2159670898043362,
        1.2131770475981971,
        1.1544592249945018
      ],
      "avg_speedup": 1.242,
      "queries": [
        "query_23a",
        "query_30",
        "query_44",
        "query_6",
        "query_75"
      ],
      "transforms": [
        "decorrelate",
        "intersect_to_exists",
        "or_to_union",
        "union_cte_split"
      ]
    },
    {
      "id": "multi_date_range_cte",
      "name": "Multi Date Range Cte",
      "what": "Applied multi_date_range_cte, multi_dimension_prefetch, prefetch_fact_join achieving 1.27x speedup",
      "why": "Separate CTEs for each date alias avoids ambiguous multi-way date joins; Pre-filtering multiple dimension tables in parallel reduces join fan-out; Pre-joining filtered dimensions with fact table before aggregation reduces join input",
      "when": "Query uses the same date_dim table under 2+ aliases (d1, d2, d3) with different filters",
      "when_not": "Caused regression on query_13, query_25, query_9, query_90, query_92 (worst: 0.07x); Worker 1 failed due to incorrect column isolation - they created filtered CTEs that selected only primary keys, losing necessary filter columns (cd_marital_status, cd_education_status, ca_state) that ",
      "verified_speedups": [
        1.2689008923388794,
        1.2445054289041746,
        1.2353550946624476,
        1.1133538416013442
      ],
      "avg_speedup": 1.216,
      "queries": [
        "query_11",
        "query_4",
        "query_64"
      ],
      "transforms": [
        "multi_date_range_cte",
        "multi_dimension_prefetch",
        "prefetch_fact_join",
        "union_cte_split"
      ]
    },
    {
      "id": "multi_dimension_prefetch",
      "name": "Multi Dimension Prefetch",
      "what": "Applied multi_dimension_prefetch, prefetch_fact_join: Restructured query using aggressive multi-CTE approach: created separate filtered CTEs for each fact table (store_sales, web_sales, catalog_sales) with NULL filters applied early, isolated dimension tables (item, date_dim) into separate CTEs, then created channel-specific CTEs that join only the necessary pre-filtered results. This reduces the amount of data scanned in each UNION branch and allows DuckDB to optimize each channel path independ",
      "why": "Pre-filtering multiple dimension tables in parallel reduces join fan-out; Pre-joining filtered dimensions with fact table before aggregation reduces join input",
      "when": "Query references multiple dimension tables (date + store, date + item, etc.)",
      "when_not": "Caused regression on query_14, query_23b, query_26, query_29, query_31, query_32, query_37, query_45, query_46, query_47, query_55, query_58, query_71, query_72, query_76, query_8, query_87, query_9, query_91, query_93, query_96 (worst: 0.02x); Created year-specific CTEs (store_sales_1999, store_sales_2000, etc.) but KEPT the original year_total union CTE alongside them. The optimizer materializes both the split versions and the original uni",
      "verified_speedups": [
        1.1048099190949936
      ],
      "avg_speedup": 1.105,
      "queries": [
        "query_76"
      ],
      "transforms": [
        "multi_dimension_prefetch",
        "prefetch_fact_join"
      ]
    }
  ],
  "anti_patterns": [
    {
      "id": "regression_date_cte_isolate",
      "name": "Regression: Date Cte Isolate",
      "mechanism": "All workers fell short due to improper join ordering and missed opportunities to reduce the largest fact table early. Worker 1-2 isolated dimension filtering but still joined all filtered dimensions to customer before joining to catalog_returns, forcing unnecessary work on the customer table. Worker 3's cross join between customer_demographics and household_demographics was catastrophic. Worker 4's UNION ALL approach fragmented the query but still processed the large fact table through multiple ",
      "observed_regressions": [
        0.6229034870731597,
        0.6564740937079243,
        0.7711302612751842,
        0.7721820913956727,
        0.8421776677180195,
        0.889148132665114,
        0.9096366489530499,
        0.9141370495165347,
        0.9186795453472819,
        0.9289896620777872
      ],
      "queries": [
        "query_31",
        "query_51",
        "query_69",
        "query_78",
        "query_87",
        "query_91",
        "query_92",
        "query_94",
        "query_96"
      ],
      "avoid_when": "Applying date_cte_isolate to queries similar to query_31, query_51, query_69, query_78, query_87, query_91, query_92, query_94, query_96"
    },
    {
      "id": "regression_decorrelate",
      "name": "Regression: Decorrelate",
      "mechanism": "Split a simple OR condition (t_hour BETWEEN 10 AND 11 OR t_hour BETWEEN 16 AND 17) into UNION ALL of two separate web_sales scans. This doubles the fact table scan. DuckDB handles same-column OR ranges efficiently in a single scan \u2014 the UNION ALL adds materialization overhead with zero selectivity benefit.",
      "observed_regressions": [
        0.11197021859295196,
        0.3665666448411192,
        0.40983809602022186,
        0.48615970172674206,
        0.6638767824067862,
        0.9306594845682643,
        0.932984308259224
      ],
      "queries": [
        "query_16",
        "query_28",
        "query_33",
        "query_54",
        "query_9",
        "query_90",
        "query_94"
      ],
      "avoid_when": "Applying decorrelate to queries similar to query_16, query_28, query_33, query_54, query_9, query_90, query_94"
    },
    {
      "id": "regression_dimension_cte_isolate",
      "name": "Regression: Dimension Cte Isolate",
      "mechanism": "Split a simple OR condition (t_hour BETWEEN 10 AND 11 OR t_hour BETWEEN 16 AND 17) into UNION ALL of two separate web_sales scans. This doubles the fact table scan. DuckDB handles same-column OR ranges efficiently in a single scan \u2014 the UNION ALL adds materialization overhead with zero selectivity benefit.",
      "observed_regressions": [
        0.01932495312400238,
        0.390444506762746,
        0.6103817120018427,
        0.8170364191969884,
        0.9027980275534887,
        0.9127926277854175,
        0.9220667110100963,
        0.9312183437405103,
        0.9479106388726983
      ],
      "queries": [
        "query_32",
        "query_33",
        "query_34",
        "query_37",
        "query_55",
        "query_61",
        "query_82",
        "query_9",
        "query_91"
      ],
      "avoid_when": "Applying dimension_cte_isolate to queries similar to query_32, query_33, query_34, query_37, query_55, query_61, query_82, query_9, query_91"
    },
    {
      "id": "regression_early_filter",
      "name": "Regression: Early Filter",
      "mechanism": "Split a simple OR condition (t_hour BETWEEN 10 AND 11 OR t_hour BETWEEN 16 AND 17) into UNION ALL of two separate web_sales scans. This doubles the fact table scan. DuckDB handles same-column OR ranges efficiently in a single scan \u2014 the UNION ALL adds materialization overhead with zero selectivity benefit.",
      "observed_regressions": [
        0.02005576119057537,
        0.537430720643162,
        0.6673587095757484,
        0.7040641626513594,
        0.7102028647624241,
        0.7567459027281345,
        0.8014895834850009,
        0.8129970277935269,
        0.8316176495897339,
        0.8744089051196285,
        0.9117479850880859,
        0.935124140382492,
        0.9394047166342461,
        0.9436712757404857,
        0.9483652617861749
      ],
      "queries": [
        "query_10",
        "query_23b",
        "query_3",
        "query_31",
        "query_32",
        "query_37",
        "query_48",
        "query_53",
        "query_69",
        "query_82",
        "query_91",
        "query_92",
        "query_93",
        "query_94"
      ],
      "avoid_when": "Applying early_filter to queries similar to query_10, query_23b, query_3, query_31, query_32, query_37, query_48, query_53, query_69, query_82, query_91, query_92, query_93, query_94"
    },
    {
      "id": "regression_intersect_to_exists",
      "name": "Regression: Intersect To Exists",
      "mechanism": "Created both filtered (store_sales_agg, web_sales_agg) AND original (ss, ws) versions of the same aggregations. The query does a 6-way self-join matching quarterly patterns (Q1->Q2->Q3). Duplicate CTEs doubled materialization and confused the optimizer's cardinality estimates for the multi-self-join.",
      "observed_regressions": [
        0.3729444333094838,
        0.7375362028322698,
        0.7941431990172766,
        0.8745298983255388,
        0.9100556729798698
      ],
      "queries": [
        "query_38",
        "query_64",
        "query_8",
        "query_87",
        "query_95"
      ],
      "avoid_when": "Applying intersect_to_exists to queries similar to query_38, query_64, query_8, query_87, query_95"
    },
    {
      "id": "regression_multi_date_range_cte",
      "name": "Regression: Multi Date Range Cte",
      "mechanism": "Pre-filtered and joined store_sales to date CTE BEFORE the 3-way fact table join (store_sales <- store_returns <- catalog_sales). By materializing the date-filtered store_sales early, the optimizer loses the ability to push filters across the multi-way fact join and reorder joins optimally.",
      "observed_regressions": [
        0.2777433493196165,
        0.8719752750878528
      ],
      "queries": [
        "query_25",
        "query_92"
      ],
      "avoid_when": "Applying multi_date_range_cte to queries similar to query_25, query_92"
    },
    {
      "id": "regression_multi_dimension_prefetch",
      "name": "Regression: Multi Dimension Prefetch",
      "mechanism": "All workers fell short because they implemented essentially the same optimization: early filtering of dimension tables via CTEs followed by fact table joins. This approach fails because:\n1. DuckDB's optimizer already performs predicate pushdown automatically in the original star-join pattern.\n2. CTEs may force materialization or disrupt join reordering optimization, preventing DuckDB from selecting optimal join orders.\n3. The critical bottleneck is scanning the massive store_sales table\u2014all atte",
      "observed_regressions": [
        0.1787451907807794,
        0.7708460898027261
      ],
      "queries": [
        "query_31",
        "query_96"
      ],
      "avoid_when": "Applying multi_dimension_prefetch to queries similar to query_31, query_96"
    },
    {
      "id": "regression_or_to_union",
      "name": "Regression: Or To Union",
      "mechanism": "Materialized a GROUP BY self-join (HAVING MIN() <> MAX()) on the entire fact table BEFORE applying date/address/call_center filters. The original query filters catalog_sales first via correlated EXISTS clauses, then checks warehouse conditions. Pre-materializing the unfiltered self-join creates a massive intermediate result the optimizer cannot cost-estimate correctly.",
      "observed_regressions": [
        0.018305693460334036,
        0.25991769868590203,
        0.3500425293594371,
        0.37085632010087327,
        0.3929450197037755,
        0.42718345987060785,
        0.4458549699028839,
        0.47057944597765383,
        0.5096135106412799,
        0.5133205238739086,
        0.5662636980293042,
        0.5715978844087075,
        0.588612773001455,
        0.6740961641464521,
        0.6770930306538144,
        0.7159104228373429,
        0.7478064713060996,
        0.7823452987767606,
        0.7988912344999219,
        0.8182382336609387,
        0.8295900419560737,
        0.8355409729733358,
        0.8675362677150643,
        0.9218121054119779
      ],
      "queries": [
        "query_12",
        "query_13",
        "query_16",
        "query_18",
        "query_19",
        "query_26",
        "query_28",
        "query_36",
        "query_40",
        "query_41",
        "query_45",
        "query_47",
        "query_48",
        "query_52",
        "query_53",
        "query_57",
        "query_61",
        "query_63",
        "query_68",
        "query_78",
        "query_82",
        "query_9",
        "query_93",
        "query_97"
      ],
      "avoid_when": "Applying or_to_union to queries similar to query_12, query_13, query_16, query_18, query_19, query_26, query_28, query_36, query_40, query_41, query_45, query_47, query_48, query_52, query_53, query_57, query_61, query_63, query_68, query_78, query_82, query_9, query_93, query_97"
    },
    {
      "id": "regression_prefetch_fact_join",
      "name": "Regression: Prefetch Fact Join",
      "mechanism": "All workers fell short due to improper join ordering and missed opportunities to reduce the largest fact table early. Worker 1-2 isolated dimension filtering but still joined all filtered dimensions to customer before joining to catalog_returns, forcing unnecessary work on the customer table. Worker 3's cross join between customer_demographics and household_demographics was catastrophic. Worker 4's UNION ALL approach fragmented the query but still processed the large fact table through multiple ",
      "observed_regressions": [
        0.02378715331595073,
        0.06609768032897448,
        0.2737191519859518,
        0.40888260144075916,
        0.4148215522518359,
        0.4383791726004965,
        0.5847422845091331,
        0.7605598272779096,
        0.7657519193654806,
        0.7673710605756556,
        0.7952378346037556,
        0.8060756907086735,
        0.8453297426969942,
        0.8663232174945078,
        0.8888041222575703,
        0.8949193586213647,
        0.9288059608826069,
        0.9294859456578749,
        0.935171798375209,
        0.939112719194515,
        0.9391534520661379,
        0.9412084328869753,
        0.9460228278501602,
        0.9474074220776305
      ],
      "queries": [
        "query_1",
        "query_13",
        "query_23b",
        "query_26",
        "query_29",
        "query_31",
        "query_32",
        "query_42",
        "query_45",
        "query_46",
        "query_47",
        "query_52",
        "query_55",
        "query_58",
        "query_71",
        "query_72",
        "query_8",
        "query_9",
        "query_90",
        "query_91",
        "query_93",
        "query_96"
      ],
      "avoid_when": "Applying prefetch_fact_join to queries similar to query_1, query_13, query_23b, query_26, query_29, query_31, query_32, query_42, query_45, query_46, query_47, query_52, query_55, query_58, query_71, query_72, query_8, query_9, query_90, query_91, query_93, query_96"
    },
    {
      "id": "regression_pushdown",
      "name": "Regression: Pushdown",
      "mechanism": "Pre-filtered and joined store_sales to date CTE BEFORE the 3-way fact table join (store_sales <- store_returns <- catalog_sales). By materializing the date-filtered store_sales early, the optimizer loses the ability to push filters across the multi-way fact join and reorder joins optimally.",
      "observed_regressions": [
        0.27308371347813115,
        0.28046725155592,
        0.3229199365398751,
        0.4244512598812492,
        0.5385947431743382,
        0.9031767365939561,
        0.9170169665641419,
        0.9362745705042335,
        0.9424943442606806
      ],
      "queries": [
        "query_25",
        "query_58",
        "query_61",
        "query_71",
        "query_77",
        "query_81",
        "query_85",
        "query_9"
      ],
      "avoid_when": "Applying pushdown to queries similar to query_25, query_58, query_61, query_71, query_77, query_81, query_85, query_9"
    },
    {
      "id": "regression_single_pass_aggregation",
      "name": "Regression: Single Pass Aggregation",
      "mechanism": "Pre-filtered and joined store_sales to date CTE BEFORE the 3-way fact table join (store_sales <- store_returns <- catalog_sales). By materializing the date-filtered store_sales early, the optimizer loses the ability to push filters across the multi-way fact join and reorder joins optimally.",
      "observed_regressions": [
        0.04952674768985023,
        0.06379772950465294,
        0.09100442704457776,
        0.18055958112121248,
        0.30417633743931327,
        0.34516313848691815,
        0.3943031952256471,
        0.5543247273702756,
        0.5734448387365535,
        0.5954831943501389,
        0.6032950870148343,
        0.6673221626826688,
        0.6834313107635834,
        0.7058878723464658,
        0.7265263857529253,
        0.7846985263859467,
        0.813655431665708,
        0.8994974596514503,
        0.9046572187225531,
        0.9150122039319587,
        0.9251978374944853,
        0.9308993211395007,
        0.9343497560793093,
        0.9378652321371421,
        0.9440504599640206
      ],
      "queries": [
        "query_11",
        "query_12",
        "query_14",
        "query_20",
        "query_28",
        "query_29",
        "query_3",
        "query_31",
        "query_44",
        "query_47",
        "query_5",
        "query_61",
        "query_63",
        "query_7",
        "query_71",
        "query_73",
        "query_74",
        "query_75",
        "query_76",
        "query_78",
        "query_87",
        "query_89",
        "query_92",
        "query_97"
      ],
      "avoid_when": "Applying single_pass_aggregation to queries similar to query_11, query_12, query_14, query_20, query_28, query_29, query_3, query_31, query_44, query_47, query_5, query_61, query_63, query_7, query_71, query_73, query_74, query_75, query_76, query_78, query_87, query_89, query_92, query_97"
    },
    {
      "id": "regression_union_cte_split",
      "name": "Regression: Union Cte Split",
      "mechanism": "Created year-specific CTEs (store_sales_1999, store_sales_2000, etc.) but KEPT the original year_total union CTE alongside them. The optimizer materializes both the split versions and the original union, resulting in redundant computation. Projection cardinality estimates show 10^16x errors from the confused CTE graph.",
      "observed_regressions": [
        0.45372288795293997
      ],
      "queries": [
        "query_11"
      ],
      "avoid_when": "Applying union_cte_split to queries similar to query_11"
    },
    {
      "id": "error_execution",
      "name": "Error Pattern: Execution",
      "mechanism": "Not implemented Error: Non-inner join on correlated columns not supported",
      "observed_regressions": [
        0.0
      ],
      "queries": [
        "query_31"
      ],
      "avoid_when": "Watch for execution errors when rewriting queries with complex joins/aliases"
    },
    {
      "id": "error_semantic",
      "name": "Error Pattern: Semantic",
      "mechanism": "Binder Error: Referenced column \"ss_net_profit\" not found in FROM clause!\nCandidate bindings: \"ca_gmt_offset\", \"ca_suite_number\", \"ca_location_type\", \"ca_street_type\", \"ca_street_number\"\n\nLINE 11:         (ca_state IN ('SD', 'KS', 'MI') AND ss_net_profit BETWEEN 100 AND 200)\n                                                     ^",
      "observed_regressions": [
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0
      ],
      "queries": [
        "query_10",
        "query_13",
        "query_14",
        "query_15",
        "query_16",
        "query_17",
        "query_18",
        "query_23",
        "query_23a",
        "query_23b",
        "query_24",
        "query_25",
        "query_27",
        "query_29",
        "query_30",
        "query_32",
        "query_34",
        "query_39",
        "query_4",
        "query_44",
        "query_45",
        "query_46",
        "query_48",
        "query_5",
        "query_50",
        "query_54",
        "query_56",
        "query_58",
        "query_6",
        "query_61",
        "query_67",
        "query_70",
        "query_72",
        "query_74",
        "query_77",
        "query_8",
        "query_81",
        "query_85",
        "query_89",
        "query_9",
        "query_90",
        "query_92",
        "query_93"
      ],
      "avoid_when": "Watch for semantic errors when rewriting queries with complex joins/aliases"
    },
    {
      "id": "error_syntax",
      "name": "Error Pattern: Syntax",
      "mechanism": "Parser Error: syntax error at or near \"WHERE\"\n\nLINE 22:     WHERE cd_marital_status IN ('D', 'S', 'M')\n             ^",
      "observed_regressions": [
        0.0,
        0.0
      ],
      "queries": [
        "query_13",
        "query_22"
      ],
      "avoid_when": "Watch for syntax errors when rewriting queries with complex joins/aliases"
    },
    {
      "id": "semantic_mismatch_date_cte_isolate",
      "name": "Semantic Mismatch: Date Cte Isolate",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0
      ],
      "queries": [
        "query_23",
        "query_37",
        "query_39",
        "query_64",
        "query_81"
      ],
      "avoid_when": "Applying date_cte_isolate to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_decorrelate",
      "name": "Semantic Mismatch: Decorrelate",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0
      ],
      "queries": [
        "query_30"
      ],
      "avoid_when": "Applying decorrelate to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_dimension_cte_isolate",
      "name": "Semantic Mismatch: Dimension Cte Isolate",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0
      ],
      "queries": [
        "query_24"
      ],
      "avoid_when": "Applying dimension_cte_isolate to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_early_filter",
      "name": "Semantic Mismatch: Early Filter",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0,
        0.0,
        0.0
      ],
      "queries": [
        "query_2",
        "query_23",
        "query_41",
        "query_6"
      ],
      "avoid_when": "Applying early_filter to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_intersect_to_exists",
      "name": "Semantic Mismatch: Intersect To Exists",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0
      ],
      "queries": [
        "query_23"
      ],
      "avoid_when": "Applying intersect_to_exists to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_materialize_cte",
      "name": "Semantic Mismatch: Materialize Cte",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0
      ],
      "queries": [
        "query_2",
        "query_24"
      ],
      "avoid_when": "Applying materialize_cte to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_or_to_union",
      "name": "Semantic Mismatch: Or To Union",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0,
        0.0
      ],
      "queries": [
        "query_39",
        "query_85",
        "query_91"
      ],
      "avoid_when": "Applying or_to_union to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_prefetch_fact_join",
      "name": "Semantic Mismatch: Prefetch Fact Join",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0
      ],
      "queries": [
        "query_2",
        "query_23",
        "query_24",
        "query_39",
        "query_49"
      ],
      "avoid_when": "Applying prefetch_fact_join to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_pushdown",
      "name": "Semantic Mismatch: Pushdown",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0,
        0.0
      ],
      "queries": [
        "query_24",
        "query_30",
        "query_39"
      ],
      "avoid_when": "Applying pushdown to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_single_pass_aggregation",
      "name": "Semantic Mismatch: Single Pass Aggregation",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0,
        0.0,
        0.0,
        0.0
      ],
      "queries": [
        "query_2",
        "query_25",
        "query_49",
        "query_84",
        "query_98"
      ],
      "avoid_when": "Applying single_pass_aggregation to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_union_cte_split",
      "name": "Semantic Mismatch: Union Cte Split",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0
      ],
      "queries": [
        "query_2"
      ],
      "avoid_when": "Applying union_cte_split to queries where semantic equivalence is hard to verify"
    }
  ],
  "summary": {
    "n_principles": 12,
    "n_anti_patterns": 26,
    "total_wins": 14,
    "total_improved": 125,
    "total_neutral": 221,
    "total_regression": 133,
    "total_error": 65,
    "total_fail": 34
  }
}