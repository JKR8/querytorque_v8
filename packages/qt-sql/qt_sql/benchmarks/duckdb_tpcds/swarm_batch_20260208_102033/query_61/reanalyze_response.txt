FAILURE_ANALYSIS:
Worker 1-4 achieved only modest speedups (0.02x-1.34x) because they focused on dimension pre-filtering but missed the critical bottleneck: dual full scans of the massive store_sales fact table. Worker 3's "single-pass aggregation" (1.34x) showed promise but failed to reach 2.0x due to suboptimal join ordering and missing transformation of the OR condition. Worker 5's error stemmed from incomplete CTE column selection during customer-customer_address pre-joining. All attempts missed DuckDB's strength: vectorized execution and join reordering. The fundamental issue is that the original query scans store_sales twice with near-identical joins—once with promotion table (promotional_sales), once without (all_sales)—doubling the heaviest I/O/CPU work.

UNEXPLORED_OPPORTUNITIES:
1. **Promotion OR transformation**: Convert `(p_channel_dmail='Y' OR p_channel_email='Y' OR p_channel_tv='Y')` to UNION ALL or bitmap semijoin
2. **Fact table single-scan with conditional aggregation**: Compute both promotions and total in one pass using CASE/SUM
3. **Materialized dimension pre-join**: Create a fully filtered dimension "lookup" CTE with all required keys (store, date, customer, address, item)
4. **DuckDB-specific join hints**: Use lateral joins or ASOF joins for gmt_offset matching
5. **Aggressive column pruning**: Select only necessary columns early in the pipeline

REFINED_STRATEGY:
Implement a three-phase approach: (1) Create a fully denormalized dimension CTE pre-joining all dimension tables with filters applied; (2) Join this dimension CTE once with store_sales in a single pass; (3) Use conditional aggregation to compute both promotional and total sales simultaneously, transforming the OR condition to UNION ALL subqueries for better predicate pushdown. This eliminates the duplicate fact table scan while enabling optimal join ordering and vectorized execution.

EXAMPLES: single_pass_aggregation, or_to_union, dimension_cte_isolate
HINT: Pre-join all dimension tables (date_dim, store, customer+customer_address, item) into a single filtered CTE containing all foreign keys. Then join this CTE once with store_sales, compute total sales unconditionally and promotional sales via CASE checking ss_promo_sk IN (filtered promotion UNION). Use UNION ALL for promotion channels.