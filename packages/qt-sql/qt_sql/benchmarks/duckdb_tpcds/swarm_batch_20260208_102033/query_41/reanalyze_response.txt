FAILURE_ANALYSIS:
All workers attempted decorrelation but fell short due to three key issues:
1. **Inefficient manufacturer filtering**: Workers 1-3 and 5 still scan the entire item table for qualifying manufacturers, missing the opportunity to leverage the i_manufact_id range constraint to drastically reduce the search space.
2. **Double-scan penalty**: Most attempts scan item twice - once for manufacturer qualification and once for product name selection. Worker 4's complex UNION structure with nested EXISTS queries introduced excessive overhead (0.35x).
3. **Missing strategic column projection**: No attempt exploited the fact that only i_manufact and i_product_name are needed for the final result, allowing for aggressive column pruning.

UNEXPLORED_OPPORTUNITIES:
1. **Multi-stage progressive filtering**: First filter by i_manufact_id range, then check conditions only within that subset.
2. **Column projection optimization**: Select only needed columns (i_manufact, i_product_name) early to reduce memory/IO.
3. **Condition factorization**: Factor out common patterns (i_category, i_size) from the complex OR conditions.
4. **Early aggregation by manufacturer**: Count qualifying items per manufacturer in a single pass, then filter.
5. **DuckDB-specific optimizations**: Use DuckDB's ability to create filtered aggregates with CASE statements.

REFINED_STRATEGY:
Implement a three-stage progressive filtering approach:
1. **Stage 1**: Filter items by i_manufact_id range and project only needed columns.
2. **Stage 2**: Compute per-manufacturer qualification using a single-pass conditional aggregation with CASE statements.
3. **Stage 3**: Join qualified manufacturers back to get product names with DISTINCT.

The key insight: The condition "i_manufact between 748 and 788" on i_manufact_id is highly selective. By applying it first, we reduce the working set dramatically before evaluating the complex conditions.

EXAMPLES: early_filter, single_pass_aggregation, pushdown
HINT: Use a single CTE that filters by i_manufact_id first, then computes manufacturer qualification via conditional SUM(CASE...), then filter manufacturers with SUM>0 before final DISTINCT projection.