[
  {
    "worker_id": 1,
    "strategy": "conservative_single_pass",
    "examples": [
      "pushdown",
      "single_pass_aggregation",
      "materialize_cte"
    ],
    "hint": "Consolidate the five independent store_sales scans into a single pass with conditional aggregates using CASE statements, then push filters and materialize the results to avoid redundant computation."
  },
  {
    "worker_id": 2,
    "strategy": "moderate_dimension_prefilter",
    "examples": [
      "dimension_cte_isolate",
      "early_filter",
      "shared_dimension_multi_channel"
    ],
    "hint": "Pre-filter the reason table first into a CTE, then compute all bucket aggregates from store_sales in a separate CTE, ensuring dimension filtering happens early and shared across all calculations."
  },
  {
    "worker_id": 3,
    "strategy": "aggressive_fact_prefetch",
    "examples": [
      "prefetch_fact_join",
      "multi_dimension_prefetch",
      "multi_date_range_cte"
    ],
    "hint": "Create a pre-filtered fact CTE first, then compute all conditional aggregates from it, optimizing for fact table scan efficiency even though no join exists in the original query."
  },
  {
    "worker_id": 4,
    "strategy": "novel_structural_transform",
    "examples": [
      "or_to_union",
      "intersect_to_exists",
      "composite_decorrelate_union"
    ],
    "hint": "Transform the CASE/WHEN logic into UNION ALL branches for each quantity range threshold condition, then use EXISTS-style logic to simulate the conditional aggregation behavior."
  }
]