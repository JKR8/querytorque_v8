FAILURE_ANALYSIS:
All attempts fell short because they focused solely on predicate pushdown through CTE isolation, which DuckDB's optimizer already handles well in the original query. Worker 4's UNION ALL approach (0.68x) failed catastrophically because it doubled the fact table joins and eliminated join-order flexibility. The modest gains (1.06-1.18x) came from minor syntactic restructuring without addressing the real bottlenecks: (1) The window function `avg(sum(ss_sales_price)) over (partition by i_manufact_id)` forces a two-stage aggregation that can't be optimized away, requiring all qualified sales data to be materialized before filtering. (2) No attempt exploited DuckDB's strength with early aggregation before joins. (3) The store table join adds no filtering value but was retained in all attempts. (4) The CASE-based final filter prevents predicate pushdown into the window computation.

UNEXPLORED_OPPORTUNITIES:
1. **Aggregate-early strategy**: Pre-aggregate store_sales by item and date before joining dimensions.
2. **Store table elimination**: Since store has no filters and only provides s_store_sk for join integrity, it could be removed if ss_store_sk is non-null.
3. **Window function decomposition**: Compute manufacturer averages via separate aggregation and join, enabling earlier filtering.
4. **Materialized pre-filtering**: Use a temporary table for filtered items to avoid repeated OR evaluation.
5. **Date range simplification**: Replace IN-list with BETWEEN for better predicate optimization.

REFINED_STRATEGY:
1. Remove unnecessary store join (foreign key constraint ensures integrity).
2. Pre-aggregate store_sales at (ss_item_sk, ss_sold_date_sk) level before joining to reduce data volume early.
3. Compute manufacturer quarterly averages via separate aggregation, then join to individual quarter sums, enabling early filtering of the 10% deviation before final ordering.
4. Use BETWEEN for date range and materialize filtered items in a CTE with distinct UNION branches for better predicate optimization.
5. Apply limit pushdown to the outermost query to minimize window computation on filtered results.

EXAMPLES: single_pass_aggregation, early_filter, or_to_union
HINT: Remove store join, pre-aggregate fact table, split window function into separate aggregate CTE, use UNION ALL for item conditions, apply deviation filter before sorting, and use LIMIT 100 early.