## Part 1: Modified Logic Tree

```
QUERY: (WITH block)
├── [~] CTE date_seq_cte
│   └── SCAN date_dim → d_month_seq (distinct, filtered to March 2002)
├── [+] CTE filtered_dates
│   └── JOIN date_dim with date_seq_cte on d_month_seq
├── [~] CTE item_avg_cte
│   └── SCAN item → per-category average (no extra group by columns)
├── [+] CTE filtered_items
│   └── JOIN item with item_avg_cte + price filter (1.2×)
├── [+] CTE prefetch_core
│   └── JOIN store_sales with filtered_dates and filtered_items
└── [~] MAIN final_agg
    ├── JOIN prefetch_core with customer and customer_address
    ├── GROUP BY ca_state
    ├── HAVING cnt ≥10
    ├── ORDER BY cnt, state
    └── LIMIT 100
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Extract date sequence for March 2002 into CTE", "applied_to": ["date_seq_cte"]},
    {"id": "R2", "type": "dimension_cte_isolate", "description": "Extract date keys for that month sequence", "applied_to": ["filtered_dates"]},
    {"id": "R3", "type": "correlated_subquery_decorrelate", "description": "Compute per-category average price as independent CTE", "applied_to": ["item_avg_cte"]},
    {"id": "R4", "type": "dimension_cte_isolate", "description": "Filter items where price > 120% category average", "applied_to": ["filtered_items"]},
    {"id": "R5", "type": "prefetch_fact_join", "description": "Pre-join fact table with filtered dimensions before customer joins", "applied_to": ["prefetch_core"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_seq_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3",
        "interfaces": {"outputs": ["d_month_seq"], "consumes": []}
      },
      "filtered_dates": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d.d_date_sk FROM date_dim d INNER JOIN date_seq_cte ds ON d.d_month_seq = ds.d_month_seq",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": ["date_seq_cte"]}
      },
      "item_avg_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_category, AVG(i_current_price) AS avg_price FROM item GROUP BY i_category",
        "interfaces": {"outputs": ["i_category", "avg_price"], "consumes": []}
      },
      "filtered_items": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i.i_item_sk, i.i_category FROM item i INNER JOIN item_avg_cte ia ON i.i_category = ia.i_category WHERE i.i_current_price > 1.2 * ia.avg_price",
        "interfaces": {"outputs": ["i_item_sk", "i_category"], "consumes": ["item_avg_cte"]}
      },
      "prefetch_core": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s.ss_customer_sk, fi.i_category FROM store_sales s INNER JOIN filtered_dates fd ON s.ss_sold_date_sk = fd.d_date_sk INNER JOIN filtered_items fi ON s.ss_item_sk = fi.i_item_sk",
        "interfaces": {"outputs": ["ss_customer_sk", "i_category"], "consumes": ["filtered_dates", "filtered_items"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT a.ca_state AS state, COUNT(*) AS cnt FROM prefetch_core pc INNER JOIN customer c ON pc.ss_customer_sk = c.c_customer_sk INNER JOIN customer_address a ON c.c_current_addr_sk = a.ca_address_sk GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100",
        "interfaces": {"outputs": ["state", "cnt"], "consumes": ["prefetch_core"]}
      }
    },
    "reconstruction_order": ["date_seq_cte", "filtered_dates", "item_avg_cte", "filtered_items", "prefetch_core", "main_query"],
    "assembly_template": "WITH date_seq_cte AS ({date_seq_cte}), filtered_dates AS ({filtered_dates}), item_avg_cte AS ({item_avg_cte}), filtered_items AS ({filtered_items}), prefetch_core AS ({prefetch_core}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured the query using a staged CTE pipeline that first isolates filtered dimension keys (dates and items), then pre-joins them with the fact table before attaching customer dimensions. This allows DuckDB to build small hash tables from the filtered dimensions and apply them early in the join order.

**Expected speedup**: 2-3x, based on similar patterns where dimension pre-filtering reduces the fact table probe size early, and decorrelating the category average eliminates per-row subquery evaluation.