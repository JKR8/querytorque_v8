**Part 1: Modified Logic Tree**

```
QUERY: (single statement)
└── [MAIN] main_query_with_date_cte  [~]  Cost: 100%  Rows: ~1K — Extracted month sequence filter into CTE; otherwise unchanged joins/subquery.
    ├── [CTE] date_seq_cte  [+]  — Isolates March 2002 month sequence lookup
    │   └── SCAN date_dim → DISTINCT d_month_seq WHERE d_year=2002 AND d_moy=3
    └── [MAIN] main_query  [~] — Same joins/filters but references CTE instead of subquery
        ├── SCAN (customer_address AS a, customer AS c, store_sales AS s, date_dim AS d, item AS i)
        ├── JOIN (a.ca_address_sk = c.c_current_addr_sk)
        ├── JOIN (c.c_customer_sk = s.ss_customer_sk)
        ├── JOIN (s.ss_sold_date_sk = d.d_date_sk)
        ├── JOIN (s.ss_item_sk = i.i_item_sk)
        ├── JOIN (d.d_month_seq = ds.d_month_seq)  [~] — Changed from subquery to CTE reference
        ├── FILTER (i.i_current_price > 1.2 * (correlated subquery))
        ├── AGG (GROUP BY a.ca_state)
        ├── HAVING (COUNT(*) >= 10)
        ├── SORT (cnt ASC, state ASC)
        └── OUTPUT (state, cnt)
```

**Part 2: Component Payload JSON**

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "date_cte_isolate",
      "description": "Extract month sequence lookup into materialized CTE to avoid repeated subquery execution",
      "applied_to": ["date_seq_cte", "main_query"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "date_seq_cte": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3",
          "interfaces": {
            "outputs": ["d_month_seq"],
            "consumes": []
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address a, customer c, store_sales s, date_dim d, item i, date_seq_cte ds WHERE a.ca_address_sk = c.c_current_addr_sk AND c.c_customer_sk = s.ss_customer_sk AND s.ss_sold_date_sk = d.d_date_sk AND s.ss_item_sk = i.i_item_sk AND d.d_month_seq = ds.d_month_seq AND i.i_current_price > 1.2 * (SELECT AVG(j.i_current_price) FROM item j WHERE j.i_category = i.i_category) GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100",
          "interfaces": {
            "outputs": ["state", "cnt"],
            "consumes": ["date_seq_cte"]
          }
        }
      },
      "reconstruction_order": ["date_seq_cte", "main_query"],
      "assembly_template": "WITH date_seq_cte AS ({date_seq_cte}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Isolated the month sequence lookup into a materialized CTE (`date_seq_cte`) that scans `date_dim` once, then joined directly in the main query. The correlated subquery for item category average remains unchanged to preserve semantic equivalence and avoid decorrelation risks.

**Expected speedup**: 1.2-1.5× (moderate) from eliminating repeated subquery execution and allowing better join reordering with a small, fixed CTE.