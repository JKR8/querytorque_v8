## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K
    ├── [=] OUTPUT (c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number, extended_price, extended_tax, list_price)
    ├── [~] SORT (c_last_name ASC, ss_ticket_number ASC)
    ├── [~] TOP_N (LIMIT 100)
    ├── [~] JOIN (customer_address current_addr ON c_current_addr_sk = ca_address_sk AND ca_city <> bought_city)
    ├── [~] JOIN (customer ON ss_customer_sk = c_customer_sk)
    ├── [~] AGG (GROUP BY ss_ticket_number, ss_customer_sk, bought_city)
    ├── [~] JOIN (store_sales ↔ dimension CTEs via filtered keys)
    │   ├── [=] SCAN store_sales (partial columns)
    │   ├── [+] CTE filtered_date (d_date_sk)
    │   ├── [+] CTE filtered_store (s_store_sk)
    │   ├── [+] CTE filtered_hd (hd_demo_sk)
    │   └── [~] filtered_ca_bought (ca_address_sk, ca_city) - as inline subquery
    └── [=] LITERAL_PRESERVATION (all original constants intact)
```

**Changes:**
- **Added 3 dimension CTEs** (filtered_date, filtered_store, filtered_hd) for selective pre-filtering
- **Made filtered_ca_bought an inline subquery** in the main fact join to avoid materializing 750K rows
- **Preserved the original join/dimension structure** but with early key filtering
- **Maintained the same aggregation, customer, and address join sequence**

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "multi_dimension_prefetch", "description": "Pre-filter date_dim, store, household_demographics into separate CTEs for selective hash tables", "applied_to": ["filtered_date", "filtered_store", "filtered_hd"]},
    {"id": "R2", "type": "hazard_mitigation", "description": "Avoid materializing full customer_address CTE by making it an inline subquery in the fact join", "applied_to": ["fact_prejoin"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_dom BETWEEN 1 AND 2 AND d_year IN (1998, 1999, 2000)",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_store": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT s_store_sk FROM store WHERE s_city IN ('Pleasant Hill', 'Five Points')",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "filtered_hd": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE hd_dep_count = 8 OR hd_vehicle_count = -1",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "agg": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_ticket_number, ss_customer_sk, bought_city, SUM(ss_ext_sales_price) AS extended_price, SUM(ss_ext_list_price) AS list_price, SUM(ss_ext_tax) AS extended_tax FROM (SELECT ss_ticket_number, ss_customer_sk, ca_city AS bought_city, ss_ext_sales_price, ss_ext_list_price, ss_ext_tax FROM store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk JOIN filtered_store ON ss_store_sk = s_store_sk JOIN filtered_hd ON ss_hdemo_sk = hd_demo_sk JOIN (SELECT ca_address_sk, ca_city FROM customer_address) AS filtered_ca_bought ON ss_addr_sk = ca_address_sk) AS fact_prejoin GROUP BY ss_ticket_number, ss_customer_sk, bought_city",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "bought_city", "extended_price", "list_price", "extended_tax"], "consumes": ["filtered_date", "filtered_store", "filtered_hd"]}
      },
      "join_customer": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_last_name, c_first_name, bought_city, ss_ticket_number, extended_price, extended_tax, list_price, c_current_addr_sk FROM agg JOIN customer ON ss_customer_sk = c_customer_sk",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "bought_city", "ss_ticket_number", "extended_price", "extended_tax", "list_price", "c_current_addr_sk"], "consumes": ["agg"]}
      },
      "join_current_addr": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number, extended_price, extended_tax, list_price FROM join_customer JOIN customer_address current_addr ON c_current_addr_sk = ca_address_sk AND ca_city <> bought_city",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "ca_city", "bought_city", "ss_ticket_number", "extended_price", "extended_tax", "list_price"], "consumes": ["join_customer"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number, extended_price, extended_tax, list_price FROM join_current_addr ORDER BY c_last_name ASC, ss_ticket_number ASC LIMIT 100",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "ca_city", "bought_city", "ss_ticket_number", "extended_price", "extended_tax", "list_price"], "consumes": ["join_current_addr"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_store", "filtered_hd", "agg", "join_customer", "join_current_addr", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_store AS ({filtered_store}), filtered_hd AS ({filtered_hd}), agg AS ({agg}), join_customer AS ({join_customer}), join_current_addr AS ({join_current_addr}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": [
    {"check": "column_completeness", "status": "passed", "note": "Final output columns match required 8 columns in exact order"},
    {"check": "semantic_equivalence", "status": "verified", "note": "All joins are INNER, same filters, same grouping, same city mismatch condition"},
    {"check": "hazard_flags", "status": "addressed", "note": "filtered_ca_bought is inline subquery, not materialized CTE with 750K rows"}
  ]
}
```

## Complete SQL Rewrite

```sql
WITH filtered_date AS (
  SELECT d_date_sk
  FROM date_dim
  WHERE d_dom BETWEEN 1 AND 2
    AND d_year IN (1998, 1999, 2000)
),
filtered_store AS (
  SELECT s_store_sk
  FROM store
  WHERE s_city IN ('Pleasant Hill', 'Five Points')
),
filtered_hd AS (
  SELECT hd_demo_sk
  FROM household_demographics
  WHERE hd_dep_count = 8
     OR hd_vehicle_count = -1
),
agg AS (
  SELECT
    ss_ticket_number,
    ss_customer_sk,
    bought_city,
    SUM(ss_ext_sales_price) AS extended_price,
    SUM(ss_ext_list_price) AS list_price,
    SUM(ss_ext_tax) AS extended_tax
  FROM (
    SELECT
      ss_ticket_number,
      ss_customer_sk,
      ca_city AS bought_city,
      ss_ext_sales_price,
      ss_ext_list_price,
      ss_ext_tax
    FROM store_sales
    JOIN filtered_date ON ss_sold_date_sk = d_date_sk
    JOIN filtered_store ON ss_store_sk = s_store_sk
    JOIN filtered_hd ON ss_hdemo_sk = hd_demo_sk
    JOIN (SELECT ca_address_sk, ca_city FROM customer_address) AS filtered_ca_bought
      ON ss_addr_sk = ca_address_sk
  ) AS fact_prejoin
  GROUP BY ss_ticket_number, ss_customer_sk, bought_city
),
join_customer AS (
  SELECT
    c_last_name,
    c_first_name,
    bought_city,
    ss_ticket_number,
    extended_price,
    extended_tax,
    list_price,
    c_current_addr_sk
  FROM agg
  JOIN customer ON ss_customer_sk = c_customer_sk
),
join_current_addr AS (
  SELECT
    c_last_name,
    c_first_name,
    ca_city,
    bought_city,
    ss_ticket_number,
    extended_price,
    extended_tax,
    list_price
  FROM join_customer
  JOIN customer_address current_addr
    ON c_current_addr_sk = ca_address_sk
   AND ca_city <> bought_city
)
SELECT
  c_last_name,
  c_first_name,
  ca_city,
  bought_city,
  ss_ticket_number,
  extended_price,
  extended_tax,
  list_price
FROM join_current_addr
ORDER BY c_last_name ASC, ss_ticket_number ASC
LIMIT 100;
```

**Changes:** Applied multi-dimension prefetch pattern: created separate CTEs for filtered date, store, and household_demographics to build small hash tables before the large fact table join. This reduces the store_sales scan by applying dimension filters early. The customer_address is kept as an inline subquery to avoid materializing 750K rows in a CTE. The rest of the pipeline follows the original semantic order.

**Expected speedup:** ~2-3x, based on the multi_dimension_prefetch example (2.71x), as we're applying the same principle of pre-filtering multiple selective dimensions.