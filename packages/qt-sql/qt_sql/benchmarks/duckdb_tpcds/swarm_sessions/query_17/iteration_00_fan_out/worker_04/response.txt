## Modified Logic Tree

```
QUERY: (single statement)
├── [MAIN] main_query
│   ├── [~] CTE: d1_cte
│   │   └── FILTER (d_quarter_name = '2001Q1')
│   ├── [~] CTE: d2_cte
│   │   └── FILTER (d_quarter_name IN ('2001Q1','2001Q2','2001Q3'))
│   ├── [~] CTE: d3_cte
│   │   └── FILTER (d_quarter_name IN ('2001Q1','2001Q2','2001Q3'))
│   ├── [+] CTE: channel_labeled
│   │   ├── UNION ALL (3 branches)
│   │   ├── SCAN store_sales + JOIN d1_cte
│   │   ├── SCAN store_returns + JOIN d2_cte
│   │   └── SCAN catalog_sales + JOIN d3_cte
│   ├── [~] CTE: pivot_agg
│   │   ├── JOIN channel_labeled (as cl) + store + item
│   │   ├── LEFT JOIN channel_labeled (as ss) ON cl.item_sk=ss.item_sk AND cl.customer_sk=ss.customer_sk AND cl.ticket_number=ss.ticket_number AND ss.channel='store_sales'
│   │   ├── LEFT JOIN channel_labeled (as sr) ON cl.item_sk=sr.item_sk AND cl.customer_sk=sr.customer_sk AND cl.ticket_number=sr.ticket_number AND sr.channel='store_returns'
│   │   ├── LEFT JOIN channel_labeled (as cs) ON cl.item_sk=cs.item_sk AND cl.customer_sk=cs.customer_sk AND cs.channel='catalog_sales'
│   │   ├── FILTER (ss.item_sk IS NOT NULL AND sr.item_sk IS NOT NULL AND cs.item_sk IS NOT NULL)
│   │   └── AGG (GROUP BY i_item_id, i_item_desc, s_state)
│   └── [=] SORT/LIMIT (i_item_id, i_item_desc, s_state, LIMIT 100)
└── OUTPUT (15 columns)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "union_cte_consolidation",
      "description": "Consolidate three fact table scans into single UNION ALL CTE with channel labeling, then rejoin for 3-way matching",
      "applied_to": ["d1_cte", "d2_cte", "d3_cte", "channel_labeled", "pivot_agg"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "d1_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_quarter_name = '2001Q1'",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "d2_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_quarter_name IN ('2001Q1', '2001Q2', '2001Q3')",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "d3_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_quarter_name IN ('2001Q1', '2001Q2', '2001Q3')",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "channel_labeled": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_item_sk AS item_sk, ss_store_sk AS store_sk, ss_customer_sk AS customer_sk, ss_ticket_number AS ticket_number, ss_quantity AS quantity, 'store_sales' AS channel FROM store_sales JOIN d1_cte ON ss_sold_date_sk = d_date_sk UNION ALL SELECT sr_item_sk, NULL AS store_sk, sr_customer_sk, sr_ticket_number, sr_return_quantity, 'store_returns' FROM store_returns JOIN d2_cte ON sr_returned_date_sk = d_date_sk UNION ALL SELECT cs_item_sk, NULL AS store_sk, cs_bill_customer_sk, NULL AS ticket_number, cs_quantity, 'catalog_sales' FROM catalog_sales JOIN d3_cte ON cs_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["item_sk", "store_sk", "customer_sk", "ticket_number", "quantity", "channel"], "consumes": ["d1_cte", "d2_cte", "d3_cte"]}
      },
      "pivot_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_state, COUNT(ss.quantity) AS store_sales_quantitycount, AVG(ss.quantity) AS store_sales_quantityave, STDDEV_SAMP(ss.quantity) AS store_sales_quantitystdev, CASE WHEN AVG(ss.quantity) > 0 THEN STDDEV_SAMP(ss.quantity)/AVG(ss.quantity) END AS store_sales_quantitycov, COUNT(sr.quantity) AS store_returns_quantitycount, AVG(sr.quantity) AS store_returns_quantityave, STDDEV_SAMP(sr.quantity) AS store_returns_quantitystdev, CASE WHEN AVG(sr.quantity) > 0 THEN STDDEV_SAMP(sr.quantity)/AVG(sr.quantity) END AS store_returns_quantitycov, COUNT(cs.quantity) AS catalog_sales_quantitycount, AVG(cs.quantity) AS catalog_sales_quantityave, STDDEV_SAMP(cs.quantity) AS catalog_sales_quantitystdev, CASE WHEN AVG(cs.quantity) > 0 THEN STDDEV_SAMP(cs.quantity)/AVG(cs.quantity) END AS catalog_sales_quantitycov FROM channel_labeled AS cl JOIN store ON cl.store_sk = s_store_sk JOIN item ON cl.item_sk = i_item_sk LEFT JOIN channel_labeled AS ss ON cl.item_sk = ss.item_sk AND cl.customer_sk = ss.customer_sk AND cl.ticket_number = ss.ticket_number AND ss.channel = 'store_sales' LEFT JOIN channel_labeled AS sr ON cl.item_sk = sr.item_sk AND cl.customer_sk = sr.customer_sk AND cl.ticket_number = sr.ticket_number AND sr.channel = 'store_returns' LEFT JOIN channel_labeled AS cs ON cl.item_sk = cs.item_sk AND cl.customer_sk = cs.customer_sk AND cs.channel = 'catalog_sales' WHERE ss.item_sk IS NOT NULL AND sr.item_sk IS NOT NULL AND cs.item_sk IS NOT NULL GROUP BY i_item_id, i_item_desc, s_state",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_state", "store_sales_quantitycount", "store_sales_quantityave", "store_sales_quantitystdev", "store_sales_quantitycov", "store_returns_quantitycount", "store_returns_quantityave", "store_returns_quantitystdev", "store_returns_quantitycov", "catalog_sales_quantitycount", "catalog_sales_quantityave", "catalog_sales_quantitystdev", "catalog_sales_quantitycov"], "consumes": ["channel_labeled"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_state, store_sales_quantitycount, store_sales_quantityave, store_sales_quantitystdev, store_sales_quantitycov, store_returns_quantitycount, store_returns_quantityave, store_returns_quantitystdev, store_returns_quantitycov, catalog_sales_quantitycount, catalog_sales_quantityave, catalog_sales_quantitystdev, catalog_sales_quantitycov FROM pivot_agg ORDER BY i_item_id, i_item_desc, s_state LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_state", "store_sales_quantitycount", "store_sales_quantityave", "store_sales_quantitystdev", "store_sales_quantitycov", "store_returns_quantitycount", "store_returns_quantityave", "store_returns_quantitystdev", "store_returns_quantitycov", "catalog_sales_quantitycount", "catalog_sales_quantityave", "catalog_sales_quantitystdev", "catalog_sales_quantitycov"], "consumes": ["pivot_agg"]}
      }
    },
    "reconstruction_order": ["d1_cte", "d2_cte", "d3_cte", "channel_labeled", "pivot_agg", "main_query"],
    "assembly_template": "WITH d1_cte AS ({d1_cte}), d2_cte AS ({d2_cte}), d3_cte AS ({d3_cte}), channel_labeled AS ({channel_labeled}), pivot_agg AS ({pivot_agg}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

## Changes & Expected Speedup

**Changes**: Consolidated three separate fact table scans into a single UNION ALL CTE with channel labeling, then used self-LEFT JOINs with NULL filtering to enforce 3-way matching semantics while maintaining columnar scan efficiency. Preserved defensive division guards.

**Expected speedup**: ~1.3-1.8x due to reduced redundant date_dim scans and better columnar projection in the UNION ALL structure, though the self-join pattern may add some overhead compared to direct multi-table joins.