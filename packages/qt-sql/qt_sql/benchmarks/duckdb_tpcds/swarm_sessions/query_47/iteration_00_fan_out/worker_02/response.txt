### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] fact_agg [+] Cost: 10% Rows: ~6.6M — Pre-aggregate sales by item/store/date keys before dimension joins
│   ├── SCAN (store_sales)
│   ├── AGG (GROUP BY ss_item_sk, ss_store_sk, ss_sold_date_sk)
│   └── OUTPUT (ss_item_sk, ss_store_sk, ss_sold_date_sk, sum_sales)
├── [CTE] v1_enhanced [~] Cost: 25% Rows: ~105K — Same window logic but sourced from fact_agg CTE instead of raw tables
│   ├── SCAN (fact_agg)
│   ├── JOIN (INNER date_dim ON ss_sold_date_sk = d_date_sk)
│   ├── JOIN (INNER store ON ss_store_sk = s_store_sk)
│   ├── JOIN (INNER item ON ss_item_sk = i_item_sk)
│   ├── FILTER ((d_year = 2001) OR (d_year = 2000 AND d_moy = 12) OR (d_year = 2002 AND d_moy = 1))
│   ├── AGG (GROUP BY i_category, i_brand, s_store_name, s_company_name, d_year, d_moy)
│   ├── WINDOW (AVG over partition by i_category, i_brand, s_store_name, s_company_name, d_year)
│   ├── WINDOW (RANK over partition by i_category, i_brand, s_store_name, s_company_name ORDER BY d_year, d_moy)
│   └── OUTPUT (i_category, i_brand, s_store_name, s_company_name, d_year, d_moy, sum_sales, avg_monthly_sales, rn)
├── [CTE] v2 [=] Cost: 33% Rows: ~1K — Unchanged self-join
├── [MAIN] main_query [=] Cost: 33% Rows: ~1K — Unchanged final filter/order
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "single_pass_aggregation", "description": "Pre-aggregate fact table by surrogate keys before dimension joins", "applied_to": ["fact_agg"]},
    {"id": "R2", "type": "prefetch_fact_join", "description": "Join pre-aggregated fact with dimensions in staged pipeline", "applied_to": ["v1_enhanced"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "fact_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_item_sk, ss_store_sk, ss_sold_date_sk, SUM(ss_sales_price) AS sum_sales FROM store_sales GROUP BY ss_item_sk, ss_store_sk, ss_sold_date_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_store_sk", "ss_sold_date_sk", "sum_sales"], "consumes": []}
      },
      "v1_enhanced": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i.i_category, i.i_brand, s.s_store_name, s.s_company_name, d.d_year, d.d_moy, SUM(fa.sum_sales) AS sum_sales, AVG(SUM(fa.sum_sales)) OVER (PARTITION BY i.i_category, i.i_brand, s.s_store_name, s.s_company_name, d.d_year) AS avg_monthly_sales, RANK() OVER (PARTITION BY i.i_category, i.i_brand, s.s_store_name, s.s_company_name ORDER BY d.d_year, d.d_moy) AS rn FROM fact_agg fa INNER JOIN date_dim d ON fa.ss_sold_date_sk = d.d_date_sk INNER JOIN store s ON fa.ss_store_sk = s.s_store_sk INNER JOIN item i ON fa.ss_item_sk = i.i_item_sk WHERE (d.d_year = 2001) OR (d.d_year = 2000 AND d.d_moy = 12) OR (d.d_year = 2002 AND d.d_moy = 1) GROUP BY i.i_category, i.i_brand, s.s_store_name, s.s_company_name, d.d_year, d.d_moy",
        "interfaces": {"outputs": ["i_category", "i_brand", "s_store_name", "s_company_name", "d_year", "d_moy", "sum_sales", "avg_monthly_sales", "rn"], "consumes": ["fact_agg"]}
      },
      "v2": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["s_store_name", "d_year", "avg_monthly_sales", "sum_sales", "psum", "nsum"], "consumes": ["v1_enhanced"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["s_store_name", "d_year", "avg_monthly_sales", "sum_sales", "psum", "nsum"], "consumes": ["v2"]}
      }
    },
    "reconstruction_order": ["fact_agg", "v1_enhanced", "v2", "main_query"],
    "assembly_template": "WITH fact_agg AS ({fact_agg}), v1_enhanced AS ({v1_enhanced}), v2 AS (SELECT v1.s_store_name, v1.d_year, v1.avg_monthly_sales, v1.sum_sales, v1_lag.sum_sales AS psum, v1_lead.sum_sales AS nsum FROM v1_enhanced v1, v1_enhanced v1_lag, v1_enhanced v1_lead WHERE v1.i_category = v1_lag.i_category AND v1.i_category = v1_lead.i_category AND v1.i_brand = v1_lag.i_brand AND v1.i_brand = v1_lead.i_brand AND v1.s_store_name = v1_lag.s_store_name AND v1.s_store_name = v1_lead.s_store_name AND v1.s_company_name = v1_lag.s_company_name AND v1.s_company_name = v1_lead.s_company_name AND v1.rn = v1_lag.rn + 1 AND v1.rn = v1_lead.rn - 1) SELECT * FROM v2 WHERE d_year = 2001 AND avg_monthly_sales > 0 AND CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 ORDER BY sum_sales - avg_monthly_sales, nsum LIMIT 100"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Added `fact_agg` CTE to pre-aggregate sales before dimension joins, reducing data volume before expensive multi-way joins. Modified `v1_enhanced` to source from `fact_agg` instead of raw `store_sales`, preserving all original window semantics and date filters.

**Expected speedup**: ~2-3x from reducing dimension join cardinality early while maintaining exact semantic equivalence and defensive guards.