### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_filter  [+]  Cost: 5%  Rows: 427 — Filter date_dim for 2001 plus adjacent months Dec-2000 and Jan-2002
│   └── OUTPUT (d_date_sk, d_year, d_moy)
├── [CTE] store_filter  [+]  Cost: 1%  Rows: 102 — All stores (no filter)
│   └── OUTPUT (s_store_sk, s_store_name, s_company_name)
├── [CTE] item_all  [+]  Cost: 3%  Rows: 102K — All items (no filter)
│   └── OUTPUT (i_item_sk, i_category, i_brand)
├── [CTE] fact_join  [+]  Cost: 30%  Rows: 6.6M — Join store_sales with filtered dimensions
│   ├── SCAN (store_sales)
│   ├── JOIN (ss_sold_date_sk = date_filter.d_date_sk)
│   ├── JOIN (ss_store_sk = store_filter.s_store_sk)
│   └── JOIN (ss_item_sk = item_all.i_item_sk)
├── [CTE] v1_enhanced  [~]  Cost: 25%  Rows: 105K — Aggregate and compute window functions (now fed from fact_join CTE)
│   ├── SCAN (fact_join)
│   ├── AGG (GROUP BY i_category, i_brand, s_store_name, s_company_name, d_year, d_moy)
│   ├── WINDOW (avg_monthly_sales)
│   ├── WINDOW (rn)
│   └── OUTPUT (i_category, i_brand, s_store_name, s_company_name, d_year, d_moy, sum_sales, avg_monthly_sales, rn)
├── [CTE] v2  [=]  Cost: 20%  Rows: 73K — Self-join to get prior/next month sales
│   ├── SCAN (v1_enhanced AS v1, v1_enhanced AS v1_lag, v1_enhanced AS v1_lead)
│   ├── JOIN (5 equality joins on category/brand/store/company)
│   └── JOIN (rn = lag.rn+1 AND rn = lead.rn-1)
└── [MAIN] main_query  [=]  Cost: 15%  Rows: 100 — Filter 2001 outliers, order, limit
    ├── SCAN (v2)
    ├── FILTER (d_year=2001 AND avg_monthly_sales>0 AND deviation>0.1)
    ├── SORT (sum_sales - avg_monthly_sales, nsum)
    └── OUTPUT (s_store_name, d_year, avg_monthly_sales, sum_sales, psum, nsum)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Extract date/store/item filters into separate CTEs before joining with fact table", "applied_to": ["date_filter", "store_filter", "item_all"]},
    {"id": "R2", "type": "prefetch_fact_join", "description": "Build fact_join CTE that joins store_sales with all filtered dimension CTEs", "applied_to": ["fact_join"]},
    {"id": "R3", "type": "cte_pipeline", "description": "Replace original v1 CTE with v1_enhanced that consumes fact_join CTE", "applied_to": ["v1_enhanced"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filter": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_year, d_moy FROM date_dim WHERE (d_year = 2001) OR (d_year = 2000 AND d_moy = 12) OR (d_year = 2002 AND d_moy = 1)",
        "interfaces": {"outputs": ["d_date_sk", "d_year", "d_moy"], "consumes": []}
      },
      "store_filter": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s_store_sk, s_store_name, s_company_name FROM store",
        "interfaces": {"outputs": ["s_store_sk", "s_store_name", "s_company_name"], "consumes": []}
      },
      "item_all": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_category, i_brand FROM item",
        "interfaces": {"outputs": ["i_item_sk", "i_category", "i_brand"], "consumes": []}
      },
      "fact_join": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i.i_category, i.i_brand, s.s_store_name, s.s_company_name, d.d_year, d.d_moy, ss.ss_sales_price FROM store_sales ss INNER JOIN date_filter d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN store_filter s ON ss.ss_store_sk = s.s_store_sk INNER JOIN item_all i ON ss.ss_item_sk = i.i_item_sk",
        "interfaces": {"outputs": ["i_category", "i_brand", "s_store_name", "s_company_name", "d_year", "d_moy", "ss_sales_price"], "consumes": ["date_filter", "store_filter", "item_all"]}
      },
      "v1_enhanced": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_category, i_brand, s_store_name, s_company_name, d_year, d_moy, SUM(ss_sales_price) AS sum_sales, AVG(SUM(ss_sales_price)) OVER (PARTITION BY i_category, i_brand, s_store_name, s_company_name, d_year) AS avg_monthly_sales, RANK() OVER (PARTITION BY i_category, i_brand, s_store_name, s_company_name ORDER BY d_year, d_moy) AS rn FROM fact_join GROUP BY i_category, i_brand, s_store_name, s_company_name, d_year, d_moy",
        "interfaces": {"outputs": ["i_category", "i_brand", "s_store_name", "s_company_name", "d_year", "d_moy", "sum_sales", "avg_monthly_sales", "rn"], "consumes": ["fact_join"]}
      },
      "v2": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": [], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": [], "consumes": []}
      }
    },
    "reconstruction_order": ["date_filter", "store_filter", "item_all", "fact_join", "v1_enhanced", "v2", "main_query"],
    "assembly_template": "WITH date_filter AS ({date_filter}), store_filter AS ({store_filter}), item_all AS ({item_all}), fact_join AS ({fact_join}), v1_enhanced AS ({v1_enhanced}), v2 AS (SELECT v1.s_store_name, v1.d_year, v1.avg_monthly_sales, v1.sum_sales, v1_lag.sum_sales AS psum, v1_lead.sum_sales AS nsum FROM v1_enhanced AS v1, v1_enhanced AS v1_lag, v1_enhanced AS v1_lead WHERE v1.i_category = v1_lag.i_category AND v1.i_category = v1_lead.i_category AND v1.i_brand = v1_lag.i_brand AND v1.i_brand = v1_lead.i_brand AND v1.s_store_name = v1_lag.s_store_name AND v1.s_store_name = v1_lead.s_store_name AND v1.s_company_name = v1_lag.s_company_name AND v1.s_company_name = v1_lead.s_company_name AND v1.rn = v1_lag.rn + 1 AND v1.rn = v1_lead.rn - 1) SELECT * FROM v2 WHERE d_year = 2001 AND avg_monthly_sales > 0 AND CASE WHEN avg_monthly_sales > 0 THEN abs(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 ORDER BY sum_sales - avg_monthly_sales, nsum LIMIT 100"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured query into a CTE pipeline where dimension tables are filtered first into small CTEs, then joined once with the fact table. This allows DuckDB to build small hash tables for the dimension lookups and avoids Cartesian explosion from cross-joining dimension CTEs. The window function logic remains unchanged.

**Expected speedup:** 1.5-2x from reduced join complexity and better hash join planning.