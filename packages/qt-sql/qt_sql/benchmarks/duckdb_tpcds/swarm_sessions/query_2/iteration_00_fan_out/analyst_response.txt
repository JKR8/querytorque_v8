<reasoning>
1. **CLASSIFY**: This query is a multi-channel UNION ALL (web and catalog) aggregated by week and day of week, then self-joined (via two subqueries on the same CTE) to compare two years (1998 and 1999) and compute ratios. It is a channel-comparison self-join with a UNION ALL CTE.

2. **EXPLAIN PLAN ANALYSIS**:
   - Total runtime: 1974ms.
   - Dominant cost: catalog_sales scan (720.8ms, 37%) and HASH_GROUP_BY (606.7ms, 31%).
   - Row counts:
     - web_sales scan: 7.2M rows (out of 86.4M) – 43.9ms.
     - catalog_sales scan: 14.3M rows (out of 172.8M) – 720.8ms.
     - UNION result: 0 rows (not materialized).
     - Join with date_dim: 21.5M rows – 60.6ms.
     - Aggregation to weekly buckets: 263 rows – 606.7ms.
     - Main query joins: 365 rows each side, final result 2,513 rows – 0.7ms.
   - The optimizer pushes the date_dim join into the UNION (no separate wscs materialization). The CTE wswscs is materialized (263 rows) and scanned twice in the main query (once for 1998, once for 1999). The year filter (d_year=1998/1999) is applied late in the main query by re-joining wswscs with date_dim, which is redundant because wswscs already contains d_week_seq from the first date_dim join. The optimizer does NOT push the year filter into the CTE aggregation.
   - Scans per base table:
     - web_sales: 1 scan (in UNION).
     - catalog_sales: 1 scan (in UNION).
     - date_dim: 3 scans (one in CTE wswscs, two in main query for 1998 and 1999).
   - CTE wswscs is materialized once and probed twice (good). However, the year filter is applied after the CTE scan, forcing a join with date_dim again.

3. **GAP MATCHING**:
   - **CROSS_CTE_PREDICATE_BLINDNESS**: Yes. The year filter is not pushed into the CTE wswscs. The CTE aggregates all weeks, but only two years are needed. Opportunity: push year filter into CTE or split CTE by year.
   - **REDUNDANT_SCAN_ELIMINATION**: The date_dim is scanned 3 times. Could be reduced to 2 (one for 1998, one for 1999) by pushing year filter earlier.
   - **UNION_CTE_SELF_JOIN_DECOMPOSITION**: The CTE wswscs is self-joined twice with different year filters. Matches union_cte_split pattern.
   - **SINGLE_PASS_AGGREGATION**: Already done (conditional aggregation for days). No gap.
   - **OR_TO_UNION**: Not applicable (no OR).
   - **DECORRELATION**: Not applicable (no correlated subqueries).
   - **ENGINE STRENGTHS**: The optimizer already pushes the date_dim join into the UNION (good). It does NOT push the year filter into the CTE (gap).

4. **AGGREGATION TRAP CHECK**: Aggregates are SUM with CASE. No sensitive aggregates (STDDEV_SAMP, etc.). Splitting by year preserves grouping because each week belongs to a specific year (d_week_seq is unique per week? Actually, week sequences repeat across years? The query joins on d_week_seq1 = d_week_seq2 - 53, implying consecutive numbering across years. So filtering by year and grouping by d_week_seq is safe because each d_week_seq belongs to exactly one year? Not necessarily – week sequence numbers could repeat every few years? In the TPC-DS schema, d_week_seq is a unique identifier for a week across the entire date dimension. So each d_week_seq is associated with a single year. Therefore, filtering by year and grouping by d_week_seq is safe.

5. **TRANSFORM SELECTION** (ranked by expected value):
   - **union_cte_split**: Split wswscs into 1998 and 1999 CTEs. Eliminates redundant date_dim joins and reduces aggregation input. Historical speedup 1.36x (but with risk of regression if original CTE kept). Expected high impact because aggregation is 31% cost.
   - **date_cte_isolate**: Pre-filter date_dim for 1998 and 1999 into CTEs, then join with wscs. Reduces date_dim scans from 3 to 2 and reduces join input. Historical speedup 4.00x (but baseline here is 1974ms, so safe).
   - **star_join_prefetch**: Pre-filter date_dim, pre-join with fact tables, then aggregate. Reduces fact table scan size by pushing date filter early. Historical speedup 3.77x.
   - **single_pass_aggregation**: Already done, but we can explore consolidating the two year aggregations into one pass with a pivot (scan_consolidation_pivot). Novel combination.

6. **LOGICAL TREE DESIGN**:
   - For union_cte_split: Create wswscs_1998 and wswscs_1999 CTEs that include the year filter. Then main query joins them directly.
   - For date_cte_isolate: Create date_1998 and date_1999 CTEs, then join with wscs and aggregate per year.
   - For star_join_prefetch: Chain: date_1998 CTE -> join with web_sales and catalog_sales -> aggregate -> output as wswscs_1998. Same for 1999.
   - For exploration: Combine union_cte_split with single_pass_aggregation: one CTE that aggregates both years in a single scan with a pivot.

Check column completeness: Each CTE must output d_week_seq and the 7 day sales columns.
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
Compare day-of-week sales between 1998 and 1999 by week sequence using combined web and catalog sales, returning per-day sales ratios for week pairs exactly 53 weeks apart. All joins are INNER (intersection). Aggregates are SUM with CASE; no grouping-sensitive functions. The year filters (d_year=1998 and d_year=1999) must be preserved exactly; removing either changes result.

BOTTLENECK_DIAGNOSIS:
Scan-bound (catalog_sales scan 720.8ms, 37%) and aggregation-bound (HASH_GROUP_BY 606.7ms, 31%). Cardinality: 21.5M rows from fact-date join reduced to 263 weekly aggregates, then filtered to 365 rows per year. The optimizer already pushes date_dim join into the UNION (no wscs materialization) but does NOT push year filters into the CTE, causing redundant date_dim scans and aggregating unnecessary weeks.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output d_week_seq1 and 7 rounded ratios in original order.
- CTE_COLUMN_COMPLETENESS: Every CTE must output d_week_seq and all 7 day sales columns (sun_sales..sat_sales).
- LITERAL_PRESERVATION: Must keep d_year=1998 and d_year=1999 exactly.
- SEMANTIC_EQUIVALENCE: Must return same 2,513 rows ordered by d_week_seq1.
- CROSS_CTE_PREDICATE_BLINDNESS: Year filter applied after CTE aggregation (EXPLAIN shows date_dim re-join).
- UNION_CTE_SELF_JOIN_DECOMPOSITION: CTE wswscs scanned twice with different year filters.

REGRESSION_WARNINGS:
1. union_cte_split (0.49x on Q74):
   CAUSE: Kept original UNION CTE alongside specialized CTEs, causing redundant materialization.
   RULE: When splitting wswscs by year, ELIMINATE the original wswscs CTE entirely.
2. date_cte_isolate (0.49x on Q31):
   CAUSE: Baseline <100ms, CTE overhead dominated savings.
   RULE: Acceptable here because baseline is 1974ms (>100ms).
3. multi_dimension_prefetch (0.85x on Q67):
   CAUSE: Unfiltered dimension CTEs added overhead.
   RULE: Every dimension CTE must have a WHERE clause (d_year=1998 or 1999).

=== WORKER 1 BRIEFING ===

STRATEGY: union_cte_split
TARGET_LOGICAL_TREE:
  date_1998 -> wscs join date_1998 -> aggregate -> wswscs_1998
  date_1999 -> wscs join date_1999 -> aggregate -> wswscs_1999
  main query: join wswscs_1998 and wswscs_1999 on d_week_seq1 = d_week_seq2 - 53
NODE_CONTRACTS:
  date_1998:
    FROM: date_dim
    WHERE: d_year = 1998
    OUTPUT: d_date_sk, d_week_seq
    EXPECTED_ROWS: 365
    CONSUMERS: wswscs_1998
  date_1999:
    FROM: date_dim
    WHERE: d_year = 1999
    OUTPUT: d_date_sk, d_week_seq
    EXPECTED_ROWS: 365
    CONSUMERS: wswscs_1999
  wswscs_1998:
    FROM: (SELECT ws_sold_date_sk, ws_ext_sales_price FROM web_sales UNION ALL SELECT cs_sold_date_sk, cs_ext_sales_price FROM catalog_sales) AS wscs
    JOIN: date_1998 ON date_1998.d_date_sk = wscs.sold_date_sk
    GROUP BY: date_1998.d_week_seq
    AGGREGATE: SUM(CASE WHEN d_day_name='Sunday' THEN sales_price END) AS sun_sales, ... (all 7 days)
    OUTPUT: d_week_seq, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales
    EXPECTED_ROWS: 263 (but filtered to 1998 weeks only)
    CONSUMERS: main query
  wswscs_1999:
    FROM: wscs (same UNION as above)
    JOIN: date_1999 ON date_1999.d_date_sk = wscs.sold_date_sk
    GROUP BY: date_1999.d_week_seq
    AGGREGATE: same 7 sums
    OUTPUT: d_week_seq, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales
    EXPECTED_ROWS: 263 (1999 weeks only)
    CONSUMERS: main query
  main_query:
    FROM: wswscs_1998 AS y, wswscs_1999 AS z
    WHERE: y.d_week_seq = z.d_week_seq - 53
    OUTPUT: y.d_week_seq AS d_week_seq1, ROUND(y.sun_sales / z.sun_sales, 2), ... (all 7 ratios)
    ORDER BY: d_week_seq1
    EXPECTED_ROWS: 2,513
    CONSUMERS: final output
EXAMPLES: union_cte_split, pushdown, date_cte_isolate
EXAMPLE_ADAPTATION:
- union_cte_split (Q74): Apply splitting of wswscs into year-specific CTEs; ignore the decorrelation aspect (no correlated subquery).
- pushdown (Q9): Push year filter into the CTE definition; ignore the scalar subquery consolidation.
- date_cte_isolate (Q6): Create filtered date CTEs; ignore the single-pass aggregation (already done).
HAZARD_FLAGS:
- Must eliminate original wswscs CTE to avoid redundant materialization.
- Ensure wscs UNION is not duplicated (reference same UNION in both year CTEs? Better to define wscs as a CTE to avoid duplication).

=== WORKER 2 BRIEFING ===

STRATEGY: date_cte_isolate
TARGET_LOGICAL_TREE:
  wscs (unchanged) -> join with date_1998 -> aggregate -> wswscs_1998
  wscs -> join with date_1999 -> aggregate -> wswscs_1999
  main query: join wswscs_1998 and wswscs_1999 on d_week_seq1 = d_week_seq2 - 53
NODE_CONTRACTS:
  wscs:
    FROM: (SELECT ws_sold_date_sk AS sold_date_sk, ws_ext_sales_price AS sales_price FROM web_sales UNION ALL SELECT cs_sold_date_sk, cs_ext_sales_price FROM catalog_sales)
    OUTPUT: sold_date_sk, sales_price
    EXPECTED_ROWS: 21.5M (after date join? Actually wscs is just the UNION, no filter)
    CONSUMERS: wswscs_1998, wswscs_1999
  date_1998:
    FROM: date_dim
    WHERE: d_year = 1998
    OUTPUT: d_date_sk, d_week_seq
    EXPECTED_ROWS: 365
    CONSUMERS: wswscs_1998
  date_1999:
    FROM: date_dim
    WHERE: d_year = 1999
    OUTPUT: d_date_sk, d_week_seq
    EXPECTED_ROWS: 365
    CONSUMERS: wswscs_1999
  wswscs_1998:
    FROM: wscs
    JOIN: date_1998 ON date_1998.d_date_sk = wscs.sold_date_sk
    GROUP BY: date_1998.d_week_seq
    AGGREGATE: same 7 sums as original
    OUTPUT: d_week_seq, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales
    EXPECTED_ROWS: 263 (1998 weeks only)
    CONSUMERS: main query
  wswscs_1999:
    FROM: wscs
    JOIN: date_1999 ON date_1999.d_date_sk = wscs.sold_date_sk
    GROUP BY: date_1999.d_week_seq
    AGGREGATE: same 7 sums
    OUTPUT: d_week_seq, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales
    EXPECTED_ROWS: 263 (1999 weeks only)
    CONSUMERS: main query
  main_query: same as Worker 1
EXAMPLES: date_cte_isolate, early_filter, dimension_cte_isolate
EXAMPLE_ADAPTATION:
- date_cte_isolate (Q6): Create filtered date CTE and join with fact; ignore the single-pass aggregation.
- early_filter (Q11): Filter date_dim first; ignore the reason table filter.
- dimension_cte_isolate (Q26): Isolate date_dim with filter; ignore other dimensions (promotion, demographics).
HAZARD_FLAGS:
- wscs is referenced twice (by wswscs_1998 and wswscs_1999). If materialized, good; if inlined, may cause duplicate scans. Consider materializing wscs as a CTE.

=== WORKER 3 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  date_1998 -> join with web_sales and catalog_sales separately -> union -> aggregate -> wswscs_1998
  date_1999 -> join with web_sales and catalog_sales separately -> union -> aggregate -> wswscs_1999
  main query: join wswscs_1998 and wswscs_1999 on d_week_seq1 = d_week_seq2 - 53
NODE_CONTRACTS:
  date_1998:
    FROM: date_dim
    WHERE: d_year = 1998
    OUTPUT: d_date_sk, d_week_seq
    EXPECTED_ROWS: 365
    CONSUMERS: ws_1998, cs_1998
  ws_1998:
    FROM: web_sales
    JOIN: date_1998 ON date_1998.d_date_sk = web_sales.ws_sold_date_sk
    OUTPUT: ws_sold_date_sk, ws_ext_sales_price, date_1998.d_week_seq
    EXPECTED_ROWS: 7.2M (filtered by 1998 dates)
    CONSUMERS: union_1998
  cs_1998:
    FROM: catalog_sales
    JOIN: date_1998 ON date_1998.d_date_sk = catalog_sales.cs_sold_date_sk
    OUTPUT: cs_sold_date_sk, cs_ext_sales_price, date_1998.d_week_seq
    EXPECTED_ROWS: 14.3M (filtered by 1998 dates)
    CONSUMERS: union_1998
  union_1998:
    FROM: ws_1998 UNION ALL cs_1998
    OUTPUT: sold_date_sk, sales_price, d_week_seq
    EXPECTED_ROWS: 21.5M (but filtered to 1998 only)
    CONSUMERS: agg_1998
  agg_1998:
    FROM: union_1998
    GROUP BY: d_week_seq
    AGGREGATE: SUM(CASE WHEN d_day_name='Sunday' THEN sales_price END) AS sun_sales, ... (all 7)
    OUTPUT: d_week_seq, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales
    EXPECTED_ROWS: 263 (1998 weeks only)
    CONSUMERS: main query
  (Repeat similarly for 1999: date_1999, ws_1999, cs_1999, union_1999, agg_1999)
  main_query: same as Worker 1
EXAMPLES: prefetch_fact_join, multi_dimension_prefetch, early_filter
EXAMPLE_ADAPTATION:
- prefetch_fact_join (Q63): Pre-join filtered date with fact tables; ignore the subsequent dimension joins.
- multi_dimension_prefetch (Q43): Pre-filter date and store; here only date.
- early_filter (Q11): Filter date first; ignore reason table.
HAZARD_FLAGS:
- Complex CTE chain may introduce materialization overhead. Keep chain shallow.
- Ensure date_dim is not scanned multiple times per branch (should be materialized once per year).

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: scan_consolidation_pivot
TARGET_LOGICAL_TREE:
  date_both (1998 and 1999) -> join with wscs -> aggregate by d_week_seq, d_year -> pivot to columns per year -> main query compute ratios
NODE_CONTRACTS:
  date_both:
    FROM: date_dim
    WHERE: d_year IN (1998, 1999)
    OUTPUT: d_date_sk, d_week_seq, d_year
    EXPECTED_ROWS: 730
    CONSUMERS: wswscs_both
  wswscs_both:
    FROM: wscs (same UNION)
    JOIN: date_both ON date_both.d_date_sk = wscs.sold_date_sk
    GROUP BY: date_both.d_week_seq, date_both.d_year
    AGGREGATE: same 7 sums
    OUTPUT: d_week_seq, d_year, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales
    EXPECTED_ROWS: 526 (263 per year)
    CONSUMERS: pivot
  pivot:
    FROM: wswscs_both
    GROUP BY: d_week_seq
    AGGREGATE: MAX(CASE WHEN d_year=1998 THEN sun_sales END) AS sun_sales_1998, MAX(CASE WHEN d_year=1999 THEN sun_sales END) AS sun_sales_1999, ... (all 7 days each year)
    OUTPUT: d_week_seq, sun_sales_1998, mon_sales_1998, ..., sat_sales_1998, sun_sales_1999, ..., sat_sales_1999
    EXPECTED_ROWS: 263 (one row per week, with both years)
    CONSUMERS: main query
  main_query:
    FROM: pivot
    WHERE: sun_sales_1999 IS NOT NULL AND sun_sales_1998 IS NOT NULL (implicitly, because we need both years)
    OUTPUT: d_week_seq AS d_week_seq1, ROUND(sun_sales_1998 / sun_sales_1999, 2), ... (ratios of 1998/1999)
    ORDER BY: d_week_seq
    EXPECTED_ROWS: 2,513
    CONSUMERS: final output
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation, union_cte_split
EXAMPLE_ADAPTATION:
- single_pass_aggregation (Q9): Aggregate both years in one pass with CASE; ignore the scalar subquery consolidation.
- channel_bitmap_aggregation (Q88): Consolidate multiple scans into one; here consolidate two year aggregations.
- union_cte_split (Q74): Split by year but then pivot; ignore the separate CTEs.
HAZARD_FLAGS:
- Pivot uses MAX(CASE) which is safe because d_year is in GROUP BY, so exactly one row per (week, year). However, if a week appears only in one year, MAX will produce NULL for the other year, which may affect ratios (but original query only outputs weeks where both years exist? Actually original join condition d_week_seq1 = d_week_seq2 - 53 ensures both years exist). Must ensure weeks without both years are filtered out.
- The join condition d_week_seq1 = d_week_seq2 - 53 is now implicit: we need to align weeks 53 apart. The pivot loses the week offset relationship. Must adjust: compute d_week_seq_1999 = d_week_seq + 53? Actually original: 1998 week = 1999 week - 53. So for a given 1998 week X, the corresponding 1999 week is X+53. In pivot, we have both years per row, but they are for the same d_week_seq value (which is the week sequence number for that year). We need to align 1998 week X with 1999 week X+53. Therefore pivot won't work directly. Need to self-join pivot on d_week_seq_1998 = d_week_seq_1999 - 53. So pivot must output d_week_seq as the week for that year, then main query joins on offset.

CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: The exploration tries a novel combination (single-pass aggregation with pivot) but must preserve the week offset join. The pivot output must include d_week_seq per year, then join appropriately.
EXPLORATION_TYPE: novel_combination