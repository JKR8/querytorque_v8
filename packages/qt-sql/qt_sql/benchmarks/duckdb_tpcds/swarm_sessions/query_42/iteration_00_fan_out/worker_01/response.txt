### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ≤11 — CTE-driven pipeline following target logical tree
    ├── [~] date_dim_cte  [=]  — CTE filtering date_dim
    │   └── SCAN (date_dim) with early filter (d_moy=11, d_year=2002)
    ├── [~] item_cte  [=]  — CTE filtering item
    │   └── SCAN (item) with early filter (i_manager_id=1)
    ├── [~] joined_fact  [+]  — CTE joining store_sales with both dimension CTEs
    │   ├── SCAN (store_sales)
    │   ├── JOIN (INNER with date_dim_cte on ss_sold_date_sk = d_date_sk)
    │   └── JOIN (INNER with item_cte on ss_item_sk = i_item_sk)
    ├── [~] aggregate  [+]  — CTE aggregating by category
    │   └── AGG (GROUP BY d_year, i_category_id, i_category; SUM(ss_ext_sales_price) as sum_sales)
    └── [~] top_n  [+]  — Final ordering and limit
        ├── SORT (sum_sales DESC, d_year, i_category_id, i_category)
        └── LIMIT (100)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter date_dim and item into separate CTEs before joining with fact table", "applied_to": ["date_dim_cte", "item_cte"]},
    {"id": "R2", "type": "early_filter", "description": "Push filters down to dimension scans, reducing fact table join size", "applied_to": ["date_dim_cte", "item_cte"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_dim_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_moy = 11 AND d_year = 2002",
        "interfaces": {"outputs": ["d_date_sk", "d_year"], "consumes": []}
      },
      "item_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_category_id, i_category FROM item WHERE i_manager_id = 1",
        "interfaces": {"outputs": ["i_item_sk", "i_category_id", "i_category"], "consumes": []}
      },
      "joined_fact": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d.d_year, i.i_category_id, i.i_category, ss.ss_ext_sales_price FROM store_sales ss INNER JOIN date_dim_cte d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN item_cte i ON ss.ss_item_sk = i.i_item_sk",
        "interfaces": {"outputs": ["d_year", "i_category_id", "i_category", "ss_ext_sales_price"], "consumes": ["date_dim_cte", "item_cte"]}
      },
      "aggregate": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_year, i_category_id, i_category, SUM(ss_ext_sales_price) AS sum_sales FROM joined_fact GROUP BY d_year, i_category_id, i_category",
        "interfaces": {"outputs": ["d_year", "i_category_id", "i_category", "sum_sales"], "consumes": ["joined_fact"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT d_year, i_category_id, i_category, sum_sales AS \"sum(ss_ext_sales_price)\" FROM aggregate ORDER BY sum_sales DESC, d_year, i_category_id, i_category LIMIT 100",
        "interfaces": {"outputs": ["d_year", "i_category_id", "i_category", "sum(ss_ext_sales_price)"], "consumes": ["aggregate"]}
      }
    },
    "reconstruction_order": ["date_dim_cte", "item_cte", "joined_fact", "aggregate", "main_query"],
    "assembly_template": "WITH date_dim_cte AS ({date_dim_cte}), item_cte AS ({item_cte}), joined_fact AS ({joined_fact}), aggregate AS ({aggregate}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Restructured original implicit joins into explicit CTE pipeline, isolating dimension filtering before joining with fact table. Each CTE outputs only required columns for downstream consumption.

Expected speedup: 1.5–2x due to reduced fact table scan size via early dimension filtering and smaller hash tables for joins.