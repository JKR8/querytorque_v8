<reasoning>
1. **CLASSIFY**: This is a "correlated-aggregate filter" query. A fact table (catalog_sales) is joined with dimensions (item, date_dim), filtered by manufacturer and date window, then each row is compared against 1.3× the item-specific average discount computed over the same date window via a correlated subquery.

2. **EXPLAIN PLAN ANALYSIS**:
   - Total time: 23ms
   - Cost distribution: catalog_sales scans dominate (38% + 14% = 52% of time). Two separate catalog_sales scans: 403K rows (8.8ms) for main path, 397K rows (3.1ms) for subquery path.
   - Row reduction: item scan reduces from 102K→193 rows (i_manufact_id=29). date_dim reduces from 73K→91 rows (date range). Both dimensions are already well-filtered.
   - The optimizer already decorrelates the subquery! The EXPLAIN shows RIGHT_DELIM_JOIN and HASH_GROUP_BY computing average per item (96 groups) once, not re-executing per outer row.
   - The main bottleneck is scanning catalog_sales twice (once for outer rows, once for averages). This is 172.8M total rows, but only ~400K rows match the date window (0.23% selectivity).
   - The two scans read similar row counts (403K vs 397K) because both use the same date window filter.
   - date_dim is scanned twice (91 rows each, 0.5ms + 0.4ms). Small but redundant.

3. **GAP MATCHING**:
   - CORRELATED_SUBQUERY_PARALYSIS: NOT APPLICABLE - optimizer already decorrelates (RIGHT_DELIM_JOIN with HASH_GROUP_BY).
   - CROSS_CTE_PREDICATE_BLINDNESS: PARTIAL - date_dim scanned twice. Could pre-materialize date keys.
   - REDUNDANT_SCAN_ELIMINATION: YES - catalog_sales scanned twice with same date filter. Could consolidate into single scan.
   - CROSS_COLUMN_OR_DECOMPOSITION: NOT APPLICABLE - no OR conditions.

4. **AGGREGATION TRAP CHECK**:
   - Only AVG(cs_ext_discount_amt) in subquery, SUM(cs_ext_discount_amt) in main.
   - The correlation is by i_item_sk, so average is per item. Any rewrite must preserve item-level grouping.
   - Since catalog_sales joins with item (one-to-many?), but i_item_sk is unique in item after i_manufact_id=29 filter, each item has multiple sales. The correlation groups by i_item_sk, which is correct.

5. **TRANSFORM SELECTION**:
   - Worker 1: **single_pass_aggregation** - Consolidate two catalog_sales scans into one with conditional aggregation.
   - Worker 2: **date_cte_isolate** + **dimension_cte_isolate** - Pre-filter date and item into CTEs, then single catalog_sales scan.
   - Worker 3: **prefetch_fact_join** - Chain: filter date→join catalog_sales→filter item→compute averages.
   - Worker 4: **EXPLORATION** - Window function to compute item average in same scan as outer rows (novel combination).

6. **LOGICAL TREE DESIGN**:
   - Need to preserve: i_manufact_id=29, date range, correlation by i_item_sk.
   - Output columns: sum(cs_ext_discount_amt) as "excess discount amount".
   - All CTEs must include necessary columns: cs_item_sk, cs_sold_date_sk, cs_ext_discount_amt, d_date_sk, i_item_sk, i_manufact_id, d_date.
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT: Sum catalog discount amounts for manufacturer 29 items sold in a 90-day window from 1999-01-07 where each row's discount exceeds 130% of that item's average discount in the same window. JOIN semantics are INNER (all three tables must match). The subquery's AVG is grouping-sensitive - must be computed per item within the date window. The outer filter depends on the correlated subquery result, which itself depends on the outer i_item_sk via correlation.

BOTTLENECK_DIAGNOSIS:
Scan-bound: two separate catalog_sales scans consume 52% of runtime (403K+397K rows from 172.8M table). Row reduction: item (102K→193), date_dim (73K→91). The optimizer already decorrelates the subquery (RIGHT_DELIM_JOIN with HASH_GROUP_BY computing 96 item groups once). Logical-tree costs are misleading - the 38% cost on catalog_sales scan understates the total I/O cost of scanning same table twice.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output exactly one column "excess discount amount" as SUM(cs_ext_discount_amt).
- CTE_COLUMN_COMPLETENESS: Any CTE must include cs_item_sk, cs_sold_date_sk, cs_ext_discount_amt for downstream joins and aggregates.
- LITERAL_PRESERVATION: Must preserve i_manufact_id=29, date range '1999-01-07' to +90 days.
- SEMANTIC_EQUIVALENCE: Must return same sum of qualifying discounts.
- REDUNDANT_SCAN_ELIMINATION: catalog_sales scanned twice with same date filter (403K+397K rows).
- CROSS_CTE_PREDICATE_BLINDNESS: date_dim scanned twice (91 rows each).

REGRESSION_WARNINGS:
1. materialize_cte (0.14x on Q16):
   CAUSE: Converted EXISTS to materialized CTE, forcing full scan instead of semi-join short-circuit.
   RULE: Do NOT convert correlated subquery to materialized CTE if it would scan entire fact table.
2. prefetch_fact_join (0.50x on Q25):
   CAUSE: Pre-joined fact table with dimension CTE before multi-way fact join, preventing optimizer reordering.
   RULE: Keep join order flexible when query has complex multi-table joins.
3. union_cte_split (0.49x on Q74):
   CAUSE: Kept both original UNION and specialized CTEs, duplicating work.
   RULE: When splitting, eliminate the original generic CTE entirely.

=== WORKER 1 BRIEFING ===

STRATEGY: single_pass_aggregation
TARGET_LOGICAL_TREE:
filtered_dates -> filtered_items -> consolidated_sales -> final_aggregation
NODE_CONTRACTS:
  filtered_dates:
    FROM: date_dim
    WHERE: d_date BETWEEN '1999-01-07' AND (CAST('1999-01-07' AS DATE) + INTERVAL 90 DAY)
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 91
    CONSUMERS: consolidated_sales
  filtered_items:
    FROM: item
    WHERE: i_manufact_id = 29
    OUTPUT: i_item_sk
    EXPECTED_ROWS: 193
    CONSUMERS: consolidated_sales
  consolidated_sales:
    FROM: catalog_sales cs
    JOIN: INNER JOIN filtered_dates d ON cs.cs_sold_date_sk = d.d_date_sk
    JOIN: INNER JOIN filtered_items i ON cs.cs_item_sk = i.i_item_sk
    GROUP BY: cs.cs_item_sk, cs.cs_sold_date_sk, cs.cs_ext_discount_amt
    AGGREGATE: AVG(cs.cs_ext_discount_amt) OVER (PARTITION BY cs.cs_item_sk) as item_avg_discount
    OUTPUT: cs.cs_item_sk, cs.cs_sold_date_sk, cs.cs_ext_discount_amt, item_avg_discount
    EXPECTED_ROWS: ~753 (matches EXPLAIN)
    CONSUMERS: final_aggregation
  final_aggregation:
    FROM: consolidated_sales
    WHERE: cs_ext_discount_amt > 1.3 * item_avg_discount
    AGGREGATE: SUM(cs_ext_discount_amt) as "excess discount amount"
    OUTPUT: "excess discount amount"
    EXPECTED_ROWS: 1
    CONSUMERS: none
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation, pushdown
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Apply CASE/OVER pattern to compute item average in same scan as outer rows; ignore that Q9 had multiple scalar subqueries - we have one correlated subquery.
- channel_bitmap_aggregation: Use window function (PARTITION BY cs_item_sk) instead of CASE; ignore the multiple channel buckets - we have one bucket.
- pushdown: Consolidate two catalog_sales scans into one; ignore that Q9 had 15+ subqueries.
HAZARD_FLAGS:
- Window function may materialize all rows before filtering; verify EXPLAIN doesn't show huge intermediate.
- Must ensure AVG is computed over same date window as outer rows (already filtered by date join).

=== WORKER 2 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
filtered_dates -> filtered_items -> prefetched_sales -> item_averages -> final_join_and_filter
NODE_CONTRACTS:
  filtered_dates:
    FROM: date_dim
    WHERE: d_date BETWEEN '1999-01-07' AND (CAST('1999-01-07' AS DATE) + INTERVAL 90 DAY)
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 91
    CONSUMERS: prefetched_sales
  filtered_items:
    FROM: item
    WHERE: i_manufact_id = 29
    OUTPUT: i_item_sk
    EXPECTED_ROWS: 193
    CONSUMERS: prefetched_sales, item_averages
  prefetched_sales:
    FROM: catalog_sales cs
    JOIN: INNER JOIN filtered_dates d ON cs.cs_sold_date_sk = d.d_date_sk
    JOIN: INNER JOIN filtered_items i ON cs.cs_item_sk = i.i_item_sk
    OUTPUT: cs.cs_item_sk, cs.cs_ext_discount_amt
    EXPECTED_ROWS: ~753
    CONSUMERS: item_averages, final_join_and_filter
  item_averages:
    FROM: prefetched_sales ps
    GROUP BY: ps.cs_item_sk
    AGGREGATE: AVG(ps.cs_ext_discount_amt) as item_avg_discount
    OUTPUT: ps.cs_item_sk, item_avg_discount
    EXPECTED_ROWS: ~96 (matches HASH_GROUP_BY 96 rows)
    CONSUMERS: final_join_and_filter
  final_join_and_filter:
    FROM: prefetched_sales ps
    JOIN: INNER JOIN item_averages ia ON ps.cs_item_sk = ia.cs_item_sk
    WHERE: ps.cs_ext_discount_amt > 1.3 * ia.item_avg_discount
    AGGREGATE: SUM(ps.cs_ext_discount_amt) as "excess discount amount"
    OUTPUT: "excess discount amount"
    EXPECTED_ROWS: 1
    CONSUMERS: none
EXAMPLES: dimension_cte_isolate, date_cte_isolate, prefetch_fact_join
EXAMPLE_ADAPTATION:
- dimension_cte_isolate: Pre-filter item and date into CTEs; ignore the promotion/demographics CTEs - we only have two dimensions.
- date_cte_isolate: Extract date filter into CTE; ignore that Q6 used scalar subquery - we use CTE join.
- prefetch_fact_join: Chain: filter dates→join catalog_sales→then compute aggregates; ignore multi-fact join complexity.
HAZARD_FLAGS:
- Must not cross-join dimension CTEs (only 2 dimensions, safe).
- item_averages CTE must GROUP BY cs_item_sk to preserve correlation semantics.

=== WORKER 3 BRIEFING ===

STRATEGY: decorrelation_plus_early_filter
TARGET_LOGICAL_TREE:
filtered_dates -> filtered_items -> sales_with_dates -> item_averages -> final_calculation
NODE_CONTRACTS:
  filtered_dates:
    FROM: date_dim
    WHERE: d_date BETWEEN '1999-01-07' AND (CAST('1999-01-07' AS DATE) + INTERVAL 90 DAY)
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 91
    CONSUMERS: sales_with_dates
  filtered_items:
    FROM: item
    WHERE: i_manufact_id = 29
    OUTPUT: i_item_sk
    EXPECTED_ROWS: 193
    CONSUMERS: sales_with_dates, item_averages
  sales_with_dates:
    FROM: catalog_sales cs
    JOIN: INNER JOIN filtered_dates d ON cs.cs_sold_date_sk = d.d_date_sk
    JOIN: INNER JOIN filtered_items i ON cs.cs_item_sk = i.i_item_sk
    OUTPUT: cs.cs_item_sk, cs.cs_ext_discount_amt
    EXPECTED_ROWS: ~753
    CONSUMERS: item_averages, final_calculation
  item_averages:
    FROM: sales_with_dates sd
    GROUP BY: sd.cs_item_sk
    AGGREGATE: AVG(sd.cs_ext_discount_amt) as item_avg_discount
    OUTPUT: sd.cs_item_sk, item_avg_discount
    EXPECTED_ROWS: ~96
    CONSUMERS: final_calculation
  final_calculation:
    FROM: sales_with_dates sd
    JOIN: INNER JOIN item_averages ia ON sd.cs_item_sk = ia.cs_item_sk
    WHERE: sd.cs_ext_discount_amt > 1.3 * ia.item_avg_discount
    AGGREGATE: SUM(sd.cs_ext_discount_amt) as "excess discount amount"
    OUTPUT: "excess discount amount"
    EXPECTED_ROWS: 1
    CONSUMERS: none
EXAMPLES: decorrelate, early_filter, pushdown
EXAMPLE_ADAPTATION:
- decorrelate: Convert correlated subquery to standalone CTE with GROUP BY; ignore that Q1 had s_state filter - we have manufacturer filter.
- early_filter: Filter small dimension tables (item, date_dim) first; ignore that Q93 had reason table - we have item and date.
- pushdown: Push date and manufacturer filters into CTEs; ignore consolidation of multiple subqueries.
HAZARD_FLAGS:
- Baseline already decorrelates (RIGHT_DELIM_JOIN), but explicit CTEs may help predicate pushdown.
- Must preserve LIMIT 100 (though aggregate returns single row).

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: window_function_consolidation
TARGET_LOGICAL_TREE:
filtered_dates -> filtered_items -> sales_window_agg -> final_filter
NODE_CONTRACTS:
  filtered_dates:
    FROM: date_dim
    WHERE: d_date BETWEEN '1999-01-07' AND (CAST('1999-01-07' AS DATE) + INTERVAL 90 DAY)
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 91
    CONSUMERS: sales_window_agg
  filtered_items:
    FROM: item
    WHERE: i_manufact_id = 29
    OUTPUT: i_item_sk
    EXPECTED_ROWS: 193
    CONSUMERS: sales_window_agg
  sales_window_agg:
    FROM: catalog_sales cs
    JOIN: INNER JOIN filtered_dates d ON cs.cs_sold_date_sk = d.d_date_sk
    JOIN: INNER JOIN filtered_items i ON cs.cs_item_sk = i.i_item_sk
    WINDOW: AVG(cs.cs_ext_discount_amt) OVER (PARTITION BY cs.cs_item_sk) as item_avg_discount
    OUTPUT: cs.cs_ext_discount_amt, item_avg_discount
    EXPECTED_ROWS: ~753
    CONSUMERS: final_filter
  final_filter:
    FROM: sales_window_agg
    WHERE: cs_ext_discount_amt > 1.3 * item_avg_discount
    AGGREGATE: SUM(cs_ext_discount_amt) as "excess discount amount"
    OUTPUT: "excess discount amount"
    EXPECTED_ROWS: 1
    CONSUMERS: none
EXAMPLES: single_pass_aggregation, deferred_window_aggregation, SELF_JOIN_TO_WINDOW
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Use window function instead of CASE aggregates; ignore CASE structure.
- deferred_window_aggregation: Compute window function after joins reduce dataset; ignore the FULL OUTER JOIN complexity.
- SELF_JOIN_TO_WINDOW: Replace self-join (correlated subquery) with window function; ignore that example used group-level values.
HAZARD_FLAGS:
- Window function may compute average over entire partition before filtering by date (but date filter applied before window via join).
- Must ensure window function partitions by cs_item_sk only, not by date range (average should be over same date window as outer row).
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: novel_combination (window function + early dimension filtering to eliminate redundant scan while maintaining correlation semantics)