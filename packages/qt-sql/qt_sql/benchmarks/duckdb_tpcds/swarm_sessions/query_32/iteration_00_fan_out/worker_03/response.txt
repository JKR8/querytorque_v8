### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [~] WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '1999-01-07' AND (CAST('1999-01-07' AS DATE) + INTERVAL 90 DAY))
├── [~] WITH filtered_items AS (SELECT i_item_sk FROM item WHERE i_manufact_id = 29)
├── [~] WITH sales_with_dates AS (SELECT cs.cs_item_sk, cs.cs_ext_discount_amt FROM catalog_sales cs INNER JOIN filtered_dates d ON cs.cs_sold_date_sk = d.d_date_sk INNER JOIN filtered_items i ON cs.cs_item_sk = i.i_item_sk)
├── [~] WITH item_averages AS (SELECT cs_item_sk, AVG(cs_ext_discount_amt) AS item_avg_discount FROM sales_with_dates GROUP BY cs_item_sk)
└── [~] main_query: SELECT SUM(sd.cs_ext_discount_amt) AS "excess discount amount" FROM sales_with_dates sd INNER JOIN item_averages ia ON sd.cs_item_sk = ia.cs_item_sk WHERE sd.cs_ext_discount_amt > 1.3 * ia.item_avg_discount LIMIT 100
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "decorrelate", "description": "Convert correlated subquery to standalone CTE with GROUP BY, enabling single-pass computation of per-item average discounts.", "applied_to": ["item_averages", "final_calculation"]},
    {"id": "R2", "type": "early_filter", "description": "Push date and manufacturer filters into early CTEs to reduce fact table scan early.", "applied_to": ["filtered_dates", "filtered_items", "sales_with_dates"]},
    {"id": "R3", "type": "scan_consolidation", "description": "Consolidate duplicate catalog_sales scans (original + subquery) into single CTE sales_with_dates.", "applied_to": ["sales_with_dates"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '1999-01-07' AND (CAST('1999-01-07' AS DATE) + INTERVAL 90 DAY)",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_items": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk FROM item WHERE i_manufact_id = 29",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "sales_with_dates": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs.cs_item_sk, cs.cs_ext_discount_amt FROM catalog_sales cs INNER JOIN filtered_dates d ON cs.cs_sold_date_sk = d.d_date_sk INNER JOIN filtered_items i ON cs.cs_item_sk = i.i_item_sk",
        "interfaces": {"outputs": ["cs_item_sk", "cs_ext_discount_amt"], "consumes": ["filtered_dates", "filtered_items"]}
      },
      "item_averages": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs_item_sk, AVG(cs_ext_discount_amt) AS item_avg_discount FROM sales_with_dates GROUP BY cs_item_sk",
        "interfaces": {"outputs": ["cs_item_sk", "item_avg_discount"], "consumes": ["sales_with_dates"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT SUM(sd.cs_ext_discount_amt) AS \"excess discount amount\" FROM sales_with_dates sd INNER JOIN item_averages ia ON sd.cs_item_sk = ia.cs_item_sk WHERE sd.cs_ext_discount_amt > 1.3 * ia.item_avg_discount LIMIT 100",
        "interfaces": {"outputs": ["excess discount amount"], "consumes": ["sales_with_dates", "item_averages"]}
      }
    },
    "reconstruction_order": ["filtered_dates", "filtered_items", "sales_with_dates", "item_averages", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), filtered_items AS ({filtered_items}), sales_with_dates AS ({sales_with_dates}), item_averages AS ({item_averages}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Decorrelated the subquery by precomputing per-item average discounts in a CTE, then joining and filtering in the main query. Early filtering on date and manufacturer reduces fact table scan.

Expected speedup: 2-3x (eliminates correlated execution and redundant fact table scan).