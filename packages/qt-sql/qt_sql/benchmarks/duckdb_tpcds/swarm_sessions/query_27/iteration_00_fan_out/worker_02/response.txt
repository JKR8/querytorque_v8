## Part 1: Modified Logic Tree

```
QUERY: (multi-statement CTE)
├── [+] base_joined CTE  — Join all five tables with filters, output only needed columns
├── [+] level2_agg CTE  — Group by i_item_id, s_state (detail level)
├── [+] level1_agg CTE  — Group by i_item_id only (state aggregated)
├── [+] level0_agg CTE  — Grand total (no grouping)
├── [+] union_all CTE   — UNION ALL of three aggregation levels
└── [+] main_query      — Order, compute g_state, apply limit
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "rollup_to_union_windowing",
      "description": "Replace GROUP BY ROLLUP with explicit UNION ALL of three aggregation levels",
      "applied_to": ["base_joined", "level2_agg", "level1_agg", "level0_agg", "union_all", "main_query"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "base_joined": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i.i_item_id, s.s_state, ss.ss_quantity, ss.ss_list_price, ss.ss_coupon_amt, ss.ss_sales_price FROM store_sales ss INNER JOIN customer_demographics cd ON ss.ss_cdemo_sk = cd.cd_demo_sk INNER JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN store s ON ss.ss_store_sk = s.s_store_sk INNER JOIN item i ON ss.ss_item_sk = i.i_item_sk WHERE cd.cd_gender = 'F' AND cd.cd_marital_status = 'D' AND cd.cd_education_status = 'Secondary' AND d.d_year = 1999 AND s.s_state IN ('MO','AL','MI','TN','LA','SC')",
          "interfaces": {
            "outputs": ["i_item_id", "s_state", "ss_quantity", "ss_list_price", "ss_coupon_amt", "ss_sales_price"],
            "consumes": []
          }
        },
        "level2_agg": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i_item_id, s_state, 0 AS grouping_level, AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4 FROM base_joined GROUP BY i_item_id, s_state",
          "interfaces": {
            "outputs": ["i_item_id", "s_state", "grouping_level", "agg1", "agg2", "agg3", "agg4"],
            "consumes": ["base_joined"]
          }
        },
        "level1_agg": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i_item_id, NULL AS s_state, 1 AS grouping_level, AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4 FROM base_joined GROUP BY i_item_id",
          "interfaces": {
            "outputs": ["i_item_id", "s_state", "grouping_level", "agg1", "agg2", "agg3", "agg4"],
            "consumes": ["base_joined"]
          }
        },
        "level0_agg": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT NULL AS i_item_id, NULL AS s_state, 2 AS grouping_level, AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4 FROM base_joined",
          "interfaces": {
            "outputs": ["i_item_id", "s_state", "grouping_level", "agg1", "agg2", "agg3", "agg4"],
            "consumes": ["base_joined"]
          }
        },
        "union_all": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT * FROM level2_agg UNION ALL SELECT * FROM level1_agg UNION ALL SELECT * FROM level0_agg",
          "interfaces": {
            "outputs": ["i_item_id", "s_state", "grouping_level", "agg1", "agg2", "agg3", "agg4"],
            "consumes": ["level2_agg", "level1_agg", "level0_agg"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_item_id, s_state, CASE WHEN grouping_level IN (1, 2) THEN 1 ELSE 0 END AS g_state, agg1, agg2, agg3, agg4 FROM union_all ORDER BY i_item_id, s_state LIMIT 100",
          "interfaces": {
            "outputs": ["i_item_id", "s_state", "g_state", "agg1", "agg2", "agg3", "agg4"],
            "consumes": ["union_all"]
          }
        }
      },
      "reconstruction_order": ["base_joined", "level2_agg", "level1_agg", "level0_agg", "union_all", "main_query"],
      "assembly_template": "WITH base_joined AS ({base_joined}), level2_agg AS ({level2_agg}), level1_agg AS ({level1_agg}), level0_agg AS ({level0_agg}), union_all AS ({union_all}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Replaced single-query GROUP BY ROLLUP with explicit CTEs that compute three aggregation levels via UNION ALL, preserving the exact output columns and semantics while enabling DuckDB's optimizer to push filters into the base_joined scan.

**Expected speedup:** 1.2-1.5x due to elimination of ROLLUP overhead and better predicate pushdown into the fact table scan.