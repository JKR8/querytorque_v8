## Part 1: Modified Logic Tree

```
QUERY: (single statement with CTE chain)
└── [MAIN] main_query [~] Cost: 100% Rows: ~1K — Restructured into explicit CTE chain per target logical tree.
    ├── [~] date_triplet [CTE] — Extract date triplets with sold/ship/inv dates
    │   ├── FROM: date_dim d1 CROSS JOIN date_dim d3 LEFT JOIN date_dim d2
    │   ├── WHERE: d1.d_year=2002 AND d3.d_date > d1.d_date + 5
    │   └── OUTPUT: sold_date_sk, d_week_seq, ship_date_sk, inv_date_sk
    ├── [~] filtered_cs [CTE] — Filter catalog sales by date triplets and demographics
    │   ├── FROM: catalog_sales JOIN date_triplet JOIN customer_demographics JOIN household_demographics
    │   ├── WHERE: cd_marital_status='W' AND hd_buy_potential='501-1000'
    │   └── OUTPUT: cs_item_sk, cs_order_number, cs_quantity, cs_promo_sk, inv_date_sk, d_week_seq
    ├── [~] join_with_inventory [CTE] — Join with inventory for stockout condition
    │   ├── FROM: filtered_cs JOIN inventory
    │   ├── ON: item match, date match, and inv_quantity_on_hand < cs_quantity
    │   └── OUTPUT: cs_item_sk, cs_order_number, cs_promo_sk, inv_warehouse_sk, d_week_seq
    ├── [~] dim_joins [CTE] — Join dimensions and optional tables, aggregate
    │   ├── FROM: join_with_inventory JOIN item JOIN warehouse LEFT JOIN promotion LEFT JOIN catalog_returns
    │   ├── GROUP BY: i_item_desc, w_warehouse_name, d_week_seq
    │   ├── AGGREGATE: SUM(CASE promo) AS no_promo/promo, COUNT(*) AS total_cnt
    │   └── OUTPUT: i_item_desc, w_warehouse_name, d_week_seq, no_promo, promo, total_cnt
    └── [=] final — Order and limit
        ├── ORDER BY: total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq
        └── LIMIT 100
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "multi_date_range_cte", "description": "Extract date triplet CTE to pre-join three date_dim aliases with their relationships", "applied_to": ["date_triplet"]},
    {"id": "R2", "type": "prefiltered_fact_cte", "description": "Create filtered_cs CTE to apply date joins and demographic filters early", "applied_to": ["filtered_cs"]},
    {"id": "R3", "type": "inventory_join_cte", "description": "Isolate inventory join with stockout condition in separate CTE", "applied_to": ["join_with_inventory"]},
    {"id": "R4", "type": "dimension_aggregate_cte", "description": "Group dimension joins and aggregation in final CTE before ordering", "applied_to": ["dim_joins"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_triplet": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d1.d_date_sk AS sold_date_sk, d1.d_week_seq, d3.d_date_sk AS ship_date_sk, d2.d_date_sk AS inv_date_sk FROM date_dim d1 CROSS JOIN date_dim d3 LEFT JOIN date_dim d2 ON d2.d_week_seq = d1.d_week_seq WHERE d1.d_year = 2002 AND d3.d_date > d1.d_date + 5",
        "interfaces": {"outputs": ["sold_date_sk", "d_week_seq", "ship_date_sk", "inv_date_sk"], "consumes": []}
      },
      "filtered_cs": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs.cs_item_sk, cs.cs_order_number, cs.cs_quantity, cs.cs_promo_sk, dt.inv_date_sk, dt.d_week_seq FROM catalog_sales cs JOIN date_triplet dt ON cs.cs_sold_date_sk = dt.sold_date_sk AND cs.cs_ship_date_sk = dt.ship_date_sk JOIN customer_demographics cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk JOIN household_demographics hd ON cs.cs_bill_hdemo_sk = hd.hd_demo_sk WHERE cd.cd_marital_status = 'W' AND hd.hd_buy_potential = '501-1000'",
        "interfaces": {"outputs": ["cs_item_sk", "cs_order_number", "cs_quantity", "cs_promo_sk", "inv_date_sk", "d_week_seq"], "consumes": ["date_triplet"]}
      },
      "join_with_inventory": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs.cs_item_sk, cs.cs_order_number, cs.cs_promo_sk, inv.inv_warehouse_sk, cs.d_week_seq FROM filtered_cs cs JOIN inventory inv ON cs.cs_item_sk = inv.inv_item_sk AND inv.inv_date_sk = cs.inv_date_sk AND inv.inv_quantity_on_hand < cs.cs_quantity",
        "interfaces": {"outputs": ["cs_item_sk", "cs_order_number", "cs_promo_sk", "inv_warehouse_sk", "d_week_seq"], "consumes": ["filtered_cs"]}
      },
      "dim_joins": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i.i_item_desc, w.w_warehouse_name, jwi.d_week_seq, SUM(CASE WHEN p.p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN p.p_promo_sk IS NOT NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM join_with_inventory jwi JOIN item i ON i.i_item_sk = jwi.cs_item_sk JOIN warehouse w ON w.w_warehouse_sk = jwi.inv_warehouse_sk LEFT JOIN promotion p ON p.p_promo_sk = jwi.cs_promo_sk LEFT JOIN catalog_returns cr ON cr.cr_item_sk = jwi.cs_item_sk AND cr.cr_order_number = jwi.cs_order_number GROUP BY i.i_item_desc, w.w_warehouse_name, jwi.d_week_seq",
        "interfaces": {"outputs": ["i_item_desc", "w_warehouse_name", "d_week_seq", "no_promo", "promo", "total_cnt"], "consumes": ["join_with_inventory"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_desc, w_warehouse_name, d_week_seq, no_promo, promo, total_cnt FROM dim_joins ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100",
        "interfaces": {"outputs": ["i_item_desc", "w_warehouse_name", "d_week_seq", "no_promo", "promo", "total_cnt"], "consumes": ["dim_joins"]}
      }
    },
    "reconstruction_order": ["date_triplet", "filtered_cs", "join_with_inventory", "dim_joins", "main_query"],
    "assembly_template": "WITH date_triplet AS ({date_triplet}), filtered_cs AS ({filtered_cs}), join_with_inventory AS ({join_with_inventory}), dim_joins AS ({dim_joins}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured into explicit CTE chain following target logical tree: date triplet → filtered catalog sales → inventory join → dimension joins & aggregation → final ordering. This isolates complex date relationships and allows predicate pushdown into each stage.

**Expected speedup:** ~1.8-2.5x from reduced intermediate row counts and better join ordering, while preserving exact semantics and defensive guards.