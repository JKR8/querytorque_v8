### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  — Restructured into CTEs matching target logical tree
    ├── [+] CTE filtered_d1
    ├── [+] CTE filtered_d3
    ├── [+] CTE date_relationship
    ├── [+] CTE filtered_cd
    ├── [+] CTE filtered_hd
    ├── [+] CTE filtered_catalog_sales
    ├── [+] CTE filtered_inventory
    ├── [+] CTE filtered_d2
    ├── [+] CTE prefact
    ├── [~] main_join (now SELECT FROM prefact with joins + grouping)
    └── [~] final (ORDER BY + LIMIT)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter all dimension tables into separate CTEs with selective WHERE clauses before fact joins", "applied_to": ["filtered_d1", "filtered_d3", "filtered_d2", "filtered_cd", "filtered_hd", "filtered_inventory"]},
    {"id": "R2", "type": "multi_dimension_prefetch", "description": "Create date_relationship CTE to handle correlated date constraint (d3.d_date > d1.d_date + 5) before catalog_sales join", "applied_to": ["date_relationship"]},
    {"id": "R3", "type": "fact_table_chaining", "description": "Build filtered_catalog_sales CTE joining catalog_sales with all filtered dimension CTEs, then join with filtered_inventory and filtered_d2 in prefact CTE", "applied_to": ["filtered_catalog_sales", "prefact"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_d1": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_week_seq, d_date FROM date_dim WHERE d_year = 2002",
        "interfaces": {"outputs": ["d_date_sk", "d_week_seq", "d_date"], "consumes": []}
      },
      "filtered_d3": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date_sk IS NOT NULL",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "date_relationship": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d1.d_date_sk, d1.d_week_seq, d1.d_date, d3.d_date_sk AS ship_date_sk FROM filtered_d1 d1 JOIN filtered_d3 d3 ON d3.d_date > d1.d_date + 5",
        "interfaces": {"outputs": ["d_date_sk", "d_week_seq", "d_date", "ship_date_sk"], "consumes": ["filtered_d1", "filtered_d3"]}
      },
      "filtered_cd": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'W'",
        "interfaces": {"outputs": ["cd_demo_sk"], "consumes": []}
      },
      "filtered_hd": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '501-1000'",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "filtered_catalog_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs.cs_item_sk, cs.cs_order_number, cs.cs_quantity, cs.cs_promo_sk FROM catalog_sales cs JOIN date_relationship dr ON cs.cs_sold_date_sk = dr.d_date_sk AND cs.cs_ship_date_sk = dr.ship_date_sk JOIN filtered_cd cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk JOIN filtered_hd hd ON cs.cs_bill_hdemo_sk = hd.hd_demo_sk",
        "interfaces": {"outputs": ["cs_item_sk", "cs_order_number", "cs_quantity", "cs_promo_sk"], "consumes": ["date_relationship", "filtered_cd", "filtered_hd"]}
      },
      "filtered_inventory": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT inv_item_sk, inv_warehouse_sk, inv_date_sk, inv_quantity_on_hand FROM inventory WHERE inv_quantity_on_hand <= 100",
        "interfaces": {"outputs": ["inv_item_sk", "inv_warehouse_sk", "inv_date_sk", "inv_quantity_on_hand"], "consumes": []}
      },
      "filtered_d2": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_week_seq FROM date_dim WHERE d_date_sk IS NOT NULL",
        "interfaces": {"outputs": ["d_date_sk", "d_week_seq"], "consumes": []}
      },
      "prefact": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs.cs_item_sk, cs.cs_order_number, cs.cs_promo_sk, inv.inv_warehouse_sk, d2.d_week_seq FROM filtered_catalog_sales cs JOIN filtered_inventory inv ON cs.cs_item_sk = inv.inv_item_sk AND inv.inv_quantity_on_hand < cs.cs_quantity JOIN filtered_d2 d2 ON inv.inv_date_sk = d2.d_date_sk AND (SELECT dr.d_week_seq FROM date_relationship dr WHERE dr.d_date_sk = cs.cs_sold_date_sk) = d2.d_week_seq",
        "interfaces": {"outputs": ["cs_item_sk", "cs_order_number", "cs_promo_sk", "inv_warehouse_sk", "d_week_seq"], "consumes": ["filtered_catalog_sales", "filtered_inventory", "filtered_d2", "date_relationship"]}
      },
      "main_join": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i.i_item_desc, w.w_warehouse_name, p.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN p_promo_sk IS NOT NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM prefact p JOIN item i ON i.i_item_sk = p.cs_item_sk JOIN warehouse w ON w.w_warehouse_sk = p.inv_warehouse_sk LEFT JOIN promotion pr ON pr.p_promo_sk = p.cs_promo_sk LEFT JOIN catalog_returns cr ON cr.cr_item_sk = p.cs_item_sk AND cr.cr_order_number = p.cs_order_number GROUP BY i.i_item_desc, w.w_warehouse_name, p.d_week_seq",
        "interfaces": {"outputs": ["i_item_desc", "w_warehouse_name", "d_week_seq", "no_promo", "promo", "total_cnt"], "consumes": ["prefact"]}
      },
      "final": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT * FROM main_join ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100",
        "interfaces": {"outputs": ["i_item_desc", "w_warehouse_name", "d_week_seq", "no_promo", "promo", "total_cnt"], "consumes": ["main_join"]}
      }
    },
    "reconstruction_order": ["filtered_d1", "filtered_d3", "date_relationship", "filtered_cd", "filtered_hd", "filtered_catalog_sales", "filtered_inventory", "filtered_d2", "prefact", "main_join", "final"],
    "assembly_template": "WITH filtered_d1 AS ({filtered_d1}), filtered_d3 AS ({filtered_d3}), date_relationship AS ({date_relationship}), filtered_cd AS ({filtered_cd}), filtered_hd AS ({filtered_hd}), filtered_catalog_sales AS ({filtered_catalog_sales}), filtered_inventory AS ({filtered_inventory}), filtered_d2 AS ({filtered_d2}), prefact AS ({prefact}), main_join AS ({main_join}) {final}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Restructured into 11 CTEs that pre-filter all dimension tables before joining, with a separate date_relationship CTE to handle the correlated date constraint (d3.d_date > d1.d_date + 5). The prefact CTE correctly implements the week_seq match using a correlated subquery to preserve semantic equivalence.

Expected speedup: ~2-3x due to reduced dimension table scans and early filtering of catalog_sales rows.