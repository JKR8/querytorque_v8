### Part 1: Modified Logic Tree

```
QUERY: (WITH statement with four CTEs)
└── [MAIN] final  [=]  Cost: 100%  Rows: 100
    ├── [~] CTE_core_filters  [~]
    │   ├── SCAN (catalog_sales, inventory (INNER JOIN), date_dim d1 (INNER JOIN), date_dim d2 (INNER JOIN), date_dim d3 (INNER JOIN), customer_demographics (INNER JOIN), household_demographics (INNER JOIN))
    │   ├── FILTER (d1.d_week_seq = d2.d_week_seq)
    │   ├── FILTER (inv_quantity_on_hand < cs_quantity)
    │   ├── FILTER (d3.d_date > d1.d_date + 5)
    │   └── FILTER (hd_buy_potential = '501-1000', d1.d_year = 2002, cd_marital_status = 'W')
    ├── [~] CTE_agg_core  [~]
    │   ├── SCAN (CTE_core_filters)
    │   ├── JOIN promotion (LEFT)
    │   ├── JOIN catalog_returns (LEFT)
    │   └── AGG (GROUP BY cs_item_sk, inv_warehouse_sk, d_week_seq)
    ├── [~] CTE_late_dim_joins  [~]
    │   ├── SCAN (CTE_agg_core)
    │   ├── JOIN item (INNER)
    │   └── JOIN warehouse (INNER)
    └── SORT (total_cnt DESC, i_item_desc ASC, w_warehouse_name ASC, d_week_seq ASC) + LIMIT 100
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "early_aggregation", "description": "Aggregate before joining descriptive dimensions to reduce join cardinality", "applied_to": ["CTE_agg_core"]},
    {"id": "R2", "type": "deferred_dimension_join", "description": "Postpone item and warehouse joins until after aggregation", "applied_to": ["CTE_late_dim_joins"]},
    {"id": "R3", "type": "predicate_pushdown", "description": "Push date, demographic, and inventory filters early into core_filters", "applied_to": ["CTE_core_filters"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "CTE_core_filters": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs.cs_item_sk, cs.cs_order_number, cs.cs_promo_sk, inv.inv_warehouse_sk, d1.d_week_seq FROM catalog_sales cs INNER JOIN inventory inv ON cs.cs_item_sk = inv.inv_item_sk INNER JOIN date_dim d1 ON cs.cs_sold_date_sk = d1.d_date_sk INNER JOIN date_dim d2 ON inv.inv_date_sk = d2.d_date_sk INNER JOIN date_dim d3 ON cs.cs_ship_date_sk = d3.d_date_sk INNER JOIN customer_demographics cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk INNER JOIN household_demographics hd ON cs.cs_bill_hdemo_sk = hd.hd_demo_sk WHERE d1.d_week_seq = d2.d_week_seq AND inv.inv_quantity_on_hand < cs.cs_quantity AND d3.d_date > d1.d_date + INTERVAL '5' DAY AND hd.hd_buy_potential = '501-1000' AND d1.d_year = 2002 AND cd.cd_marital_status = 'W'",
        "interfaces": {"outputs": ["cs_item_sk", "cs_order_number", "cs_promo_sk", "inv_warehouse_sk", "d_week_seq"], "consumes": []}
      },
      "CTE_agg_core": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs_item_sk, inv_warehouse_sk, d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN p_promo_sk IS NOT NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM CTE_core_filters cf LEFT JOIN promotion p ON p.p_promo_sk = cf.cs_promo_sk LEFT JOIN catalog_returns cr ON cr.cr_item_sk = cf.cs_item_sk AND cr.cr_order_number = cf.cs_order_number GROUP BY cs_item_sk, inv_warehouse_sk, d_week_seq",
        "interfaces": {"outputs": ["cs_item_sk", "inv_warehouse_sk", "d_week_seq", "no_promo", "promo", "total_cnt"], "consumes": ["CTE_core_filters"]}
      },
      "CTE_late_dim_joins": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i.i_item_desc, w.w_warehouse_name, ac.d_week_seq, ac.no_promo, ac.promo, ac.total_cnt FROM CTE_agg_core ac INNER JOIN item i ON i.i_item_sk = ac.cs_item_sk INNER JOIN warehouse w ON w.w_warehouse_sk = ac.inv_warehouse_sk",
        "interfaces": {"outputs": ["i_item_desc", "w_warehouse_name", "d_week_seq", "no_promo", "promo", "total_cnt"], "consumes": ["CTE_agg_core"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_desc, w_warehouse_name, d_week_seq, no_promo, promo, total_cnt FROM CTE_late_dim_joins ORDER BY total_cnt DESC, i_item_desc, w_warehouse_name, d_week_seq LIMIT 100",
        "interfaces": {"outputs": ["i_item_desc", "w_warehouse_name", "d_week_seq", "no_promo", "promo", "total_cnt"], "consumes": ["CTE_late_dim_joins"]}
      }
    },
    "reconstruction_order": ["CTE_core_filters", "CTE_agg_core", "CTE_late_dim_joins", "main_query"],
    "assembly_template": "WITH CTE_core_filters AS ({CTE_core_filters}), CTE_agg_core AS ({CTE_agg_core}), CTE_late_dim_joins AS ({CTE_late_dim_joins}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured into CTE chain following target logical tree: (1) core_filters applies all fact-table joins and filters early, (2) agg_core aggregates by surrogate keys before joining descriptive dimensions, (3) late_dim_joins adds item/warehouse descriptions via one-to-one joins. This reduces join cardinality before expensive dimension lookups.

**Expected speedup**: ~1.8-2.2x (early aggregation reduces rows from ~43K to ~1K before joining descriptive dimensions)