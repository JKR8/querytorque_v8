## Part 1: Modified Logic Tree

```
QUERY:
└── [MAIN] main_query  [~]  Structural change: Now built from CTE chain
    ├── [~] filtered_date  [+] New CTE replacing inline filter
    ├── [~] filtered_cd1  [+] New CTE replacing inline filter
    ├── [~] filtered_customer_chain  [+] New CTE replacing inline join+filter
    ├── [~] prefact  [+] New CTE for early fact table joins
    ├── [~] fact_join_item  [+] New CTE for item join
    ├── [~] rollup_agg  [+] New CTE for aggregation
    └── [=] ORDER BY/LIMIT preserved
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Extract selective dimension filters into CTEs to create small hash tables", "applied_to": ["filtered_date", "filtered_cd1"]},
    {"id": "R2", "type": "multi_dimension_prefetch", "description": "Pre-filter customer+demographics+address chain into single CTE", "applied_to": ["filtered_customer_chain"]},
    {"id": "R3", "type": "fact_table_early_join", "description": "Join fact table with dimension CTEs sequentially, preserving row multiplicity", "applied_to": ["prefact"]},
    {"id": "R4", "type": "late_item_join", "description": "Defer item table join until after fact table joins", "applied_to": ["fact_join_item"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1998",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_cd1": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cd_demo_sk, cd_dep_count FROM customer_demographics WHERE cd_gender = 'F' AND cd_education_status = 'Advanced Degree'",
        "interfaces": {"outputs": ["cd_demo_sk", "cd_dep_count"], "consumes": []}
      },
      "filtered_customer_chain": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, c.c_birth_year, ca.ca_country, ca.ca_state, ca.ca_county FROM customer c INNER JOIN customer_demographics cd2 ON c.c_current_cdemo_sk = cd2.cd_demo_sk INNER JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE c.c_birth_month IN (10,7,8,4,1,2) AND ca.ca_state IN ('WA','GA','NC','ME','WY','OK','IN')",
        "interfaces": {"outputs": ["c_customer_sk", "c_birth_year", "ca_country", "ca_state", "ca_county"], "consumes": []}
      },
      "prefact": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cs.cs_item_sk, cc.c_birth_year, cc.ca_country, cc.ca_state, cc.ca_county, cs.cs_quantity, cs.cs_list_price, cs.cs_coupon_amt, cs.cs_sales_price, cs.cs_net_profit, fcd1.cd_dep_count FROM catalog_sales cs INNER JOIN filtered_date fd ON cs.cs_sold_date_sk = fd.d_date_sk INNER JOIN filtered_cd1 fcd1 ON cs.cs_bill_cdemo_sk = fcd1.cd_demo_sk INNER JOIN filtered_customer_chain cc ON cs.cs_bill_customer_sk = cc.c_customer_sk",
        "interfaces": {"outputs": ["cs_item_sk", "c_birth_year", "ca_country", "ca_state", "ca_county", "cs_quantity", "cs_list_price", "cs_coupon_amt", "cs_sales_price", "cs_net_profit", "cd_dep_count"], "consumes": ["filtered_date", "filtered_cd1", "filtered_customer_chain"]}
      },
      "fact_join_item": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i.i_item_id, pf.ca_country, pf.ca_state, pf.ca_county, pf.cs_quantity, pf.cs_list_price, pf.cs_coupon_amt, pf.cs_sales_price, pf.cs_net_profit, pf.c_birth_year, pf.cd_dep_count FROM prefact pf INNER JOIN item i ON pf.cs_item_sk = i.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "cs_quantity", "cs_list_price", "cs_coupon_amt", "cs_sales_price", "cs_net_profit", "c_birth_year", "cd_dep_count"], "consumes": ["prefact"]}
      },
      "rollup_agg": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, ca_country, ca_state, ca_county, AVG(CAST(cs_quantity AS DECIMAL(12,2))) AS agg1, AVG(CAST(cs_list_price AS DECIMAL(12,2))) AS agg2, AVG(CAST(cs_coupon_amt AS DECIMAL(12,2))) AS agg3, AVG(CAST(cs_sales_price AS DECIMAL(12,2))) AS agg4, AVG(CAST(cs_net_profit AS DECIMAL(12,2))) AS agg5, AVG(CAST(c_birth_year AS DECIMAL(12,2))) AS agg6, AVG(CAST(cd_dep_count AS DECIMAL(12,2))) AS agg7 FROM fact_join_item GROUP BY ROLLUP (i_item_id, ca_country, ca_state, ca_county)",
        "interfaces": {"outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6", "agg7"], "consumes": ["fact_join_item"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, ca_country, ca_state, ca_county, agg1, agg2, agg3, agg4, agg5, agg6, agg7 FROM rollup_agg ORDER BY ca_country, ca_state, ca_county, i_item_id LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "ca_country", "ca_state", "ca_county", "agg1", "agg2", "agg3", "agg4", "agg5", "agg6", "agg7"], "consumes": ["rollup_agg"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_cd1", "filtered_customer_chain", "prefact", "fact_join_item", "rollup_agg", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_cd1 AS ({filtered_cd1}), filtered_customer_chain AS ({filtered_customer_chain}), prefact AS ({prefact}), fact_join_item AS ({fact_join_item}), rollup_agg AS ({rollup_agg}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Restructured the query into a CTE pipeline that isolates dimension table filtering, then sequentially joins them to the fact table, preserving the original star join semantics exactly. This enables DuckDB to build small hash tables from selective dimension filters (date: 365 rows, cd1: 137K rows, customer chain: 15K rows) before probing the large fact table.

Expected speedup: ~2-3x due to reduced hash table build costs and better predicate pushdown opportunities through the CTE boundary.