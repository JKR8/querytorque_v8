### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_cte [+] Added pre-filtered date dimension CTE
│   └── OUTPUT: d_date_sk, d_year, d_moy
├── [CTE] call_center_cte [+] Added pre-filtered call center CTE
│   └── OUTPUT: cc_call_center_sk, cc_name
├── [CTE] item_cte [+] Added pre-filtered item CTE
│   └── OUTPUT: i_item_sk, i_category, i_brand
├── [CTE] filtered_fact [+] Added fact join with filtered dimensions
│   └── OUTPUT: i_category, i_brand, cc_name, d_year, d_moy, cs_sales_price
├── [CTE] monthly_sales [+] Added monthly aggregation
│   └── OUTPUT: i_category, i_brand, cc_name, d_year, d_moy, sum_sales
├── [CTE] yearly_avg [+] Added yearly average computation
│   └── OUTPUT: i_category, i_brand, cc_name, d_year, avg_monthly_sales
├── [CTE] v1_lag_lead [~] Modified: replaced RANK + self-join with LAG/LEAD window functions
│   └── OUTPUT: i_category, i_brand, cc_name, d_year, d_moy, sum_sales, avg_monthly_sales, prev_sum_sales, next_sum_sales
├── [CTE] v2_simple [~] Modified: simplified from self-join to direct column selection
│   └── OUTPUT: i_brand, d_year, avg_monthly_sales, sum_sales, prev_sum_sales AS psum, next_sum_sales AS nsum
└── [MAIN] main_query [=] Preserved original logic
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter dimension tables into small CTEs before fact join", "applied_to": ["date_cte", "call_center_cte", "item_cte"]},
    {"id": "R2", "type": "self_join_to_window", "description": "Replace self-join for adjacency with LAG/LEAD window functions", "applied_to": ["v1_lag_lead"]},
    {"id": "R3", "type": "deferred_aggregation", "description": "Separate monthly aggregation from yearly average computation", "applied_to": ["monthly_sales", "yearly_avg"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_year, d_moy FROM date_dim WHERE (d_year = 1999 OR (d_year = 1998 AND d_moy = 12) OR (d_year = 2000 AND d_moy = 1))",
        "interfaces": {"outputs": ["d_date_sk", "d_year", "d_moy"], "consumes": []}
      },
      "call_center_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cc_call_center_sk, cc_name FROM call_center",
        "interfaces": {"outputs": ["cc_call_center_sk", "cc_name"], "consumes": []}
      },
      "item_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_category, i_brand FROM item",
        "interfaces": {"outputs": ["i_item_sk", "i_category", "i_brand"], "consumes": []}
      },
      "filtered_fact": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i.i_category, i.i_brand, cc.cc_name, d.d_year, d.d_moy, cs.cs_sales_price FROM catalog_sales cs JOIN date_cte d ON cs.cs_sold_date_sk = d.d_date_sk JOIN call_center_cte cc ON cs.cs_call_center_sk = cc.cc_call_center_sk JOIN item_cte i ON cs.cs_item_sk = i.i_item_sk",
        "interfaces": {"outputs": ["i_category", "i_brand", "cc_name", "d_year", "d_moy", "cs_sales_price"], "consumes": ["date_cte", "call_center_cte", "item_cte"]}
      },
      "monthly_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_category, i_brand, cc_name, d_year, d_moy, SUM(cs_sales_price) AS sum_sales FROM filtered_fact GROUP BY i_category, i_brand, cc_name, d_year, d_moy",
        "interfaces": {"outputs": ["i_category", "i_brand", "cc_name", "d_year", "d_moy", "sum_sales"], "consumes": ["filtered_fact"]}
      },
      "yearly_avg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_category, i_brand, cc_name, d_year, AVG(sum_sales) AS avg_monthly_sales FROM monthly_sales GROUP BY i_category, i_brand, cc_name, d_year",
        "interfaces": {"outputs": ["i_category", "i_brand", "cc_name", "d_year", "avg_monthly_sales"], "consumes": ["monthly_sales"]}
      },
      "v1_lag_lead": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT m.i_category, m.i_brand, m.cc_name, m.d_year, m.d_moy, m.sum_sales, y.avg_monthly_sales, LAG(m.sum_sales, 1) OVER (PARTITION BY m.i_category, m.i_brand, m.cc_name ORDER BY m.d_year, m.d_moy) AS prev_sum_sales, LEAD(m.sum_sales, 1) OVER (PARTITION BY m.i_category, m.i_brand, m.cc_name ORDER BY m.d_year, m.d_moy) AS next_sum_sales FROM monthly_sales m JOIN yearly_avg y ON m.i_category = y.i_category AND m.i_brand = y.i_brand AND m.cc_name = y.cc_name AND m.d_year = y.d_year",
        "interfaces": {"outputs": ["i_category", "i_brand", "cc_name", "d_year", "d_moy", "sum_sales", "avg_monthly_sales", "prev_sum_sales", "next_sum_sales"], "consumes": ["monthly_sales", "yearly_avg"]}
      },
      "v2_simple": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_brand, d_year, avg_monthly_sales, sum_sales, prev_sum_sales AS psum, next_sum_sales AS nsum FROM v1_lag_lead",
        "interfaces": {"outputs": ["i_brand", "d_year", "avg_monthly_sales", "sum_sales", "psum", "nsum"], "consumes": ["v1_lag_lead"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["*"], "consumes": ["v2_simple"]}
      }
    },
    "reconstruction_order": ["date_cte", "call_center_cte", "item_cte", "filtered_fact", "monthly_sales", "yearly_avg", "v1_lag_lead", "v2_simple", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), call_center_cte AS ({call_center_cte}), item_cte AS ({item_cte}), filtered_fact AS ({filtered_fact}), monthly_sales AS ({monthly_sales}), yearly_avg AS ({yearly_avg}), v1_lag_lead AS ({v1_lag_lead}), v2_simple AS ({v2_simple}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** The rewrite isolates dimension filtering into CTEs (date_cte, call_center_cte, item_cte), then joins them with the fact table (filtered_fact). Monthly aggregation is computed (monthly_sales), then yearly averages (yearly_avg), followed by window functions for adjacency (v1_lag_lead) instead of self-join. The original self-join elimination and dimension pre-filtering reduce join cardinalities and materialization overhead.

**Expected speedup:** ~2x (due to dimension pre-filtering reducing fact table probe cost, elimination of expensive self-join, and better columnar scan efficiency by selecting only needed columns early).