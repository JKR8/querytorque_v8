## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Replaced inline ROLLUP with explicit CTE structure following target logical tree
    ├── [~] CTE base_agg  [NEW] — Single-pass aggregation with joins and filters
    │   ├── SCAN (store_sales, date_dim, store, item)
    │   ├── FILTER (d_month_seq BETWEEN 1206 AND 1217 AND s_store_sk <= 100)
    │   └── AGG (GROUP BY 8 columns, SUM with coalesce guard)
    ├── [~] CTE rollup_union  [NEW] — Explicit 9-level UNION ALL replacing ROLLUP
    │   ├── FROM base_agg (scanned 9 times via UNION ALL)
    │   ├── UNION ALL level 0: base rows
    │   ├── UNION ALL level 1: GROUP BY 7 columns
    │   ├── UNION ALL level 2: GROUP BY 6 columns
    │   ├── UNION ALL level 3: GROUP BY 5 columns
    │   ├── UNION ALL level 4: GROUP BY 4 columns
    │   ├── UNION ALL level 5: GROUP BY 3 columns
    │   ├── UNION ALL level 6: GROUP BY 2 columns
    │   ├── UNION ALL level 7: GROUP BY 1 column
    │   └── UNION ALL level 8: grand total
    ├── [~] CTE window_rank  [NEW] — Compute rank partitioned by i_category
    │   └── WINDOW (rank() OVER (PARTITION BY i_category ORDER BY sumsales DESC))
    ├── FILTER (rk <= 100)
    ├── SORT (i_category ASC, i_class ASC, i_brand ASC, i_product_name ASC, d_year ASC, d_qoy ASC, d_moy ASC, s_store_id ASC, sumsales ASC, rk ASC)
    └── OUTPUT (*)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "rollup_to_union_windowing", "description": "Replace ROLLUP with explicit 9-level UNION ALL of grouping sets", "applied_to": ["rollup_union"]},
    {"id": "R2", "type": "cte_structure", "description": "Decompose into target logical tree nodes (base_agg → rollup_union → window_rank → filter_rank → order_limit)", "applied_to": ["base_agg", "rollup_union", "window_rank", "filter_rank", "order_limit"]},
    {"id": "R3", "type": "single_pass_aggregation", "description": "Compute base aggregation once with all joins/filters before UNION ALL", "applied_to": ["base_agg"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "base_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, SUM(COALESCE(ss_sales_price * ss_quantity, 0)) AS sumsales FROM store_sales JOIN date_dim ON ss_sold_date_sk = d_date_sk JOIN store ON ss_store_sk = s_store_sk JOIN item ON ss_item_sk = i_item_sk WHERE d_month_seq BETWEEN 1206 AND 1206+11 AND s_store_sk <= 100 GROUP BY i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales"], "consumes": []}
      },
      "rollup_union": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales FROM base_agg UNION ALL SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, NULL AS s_store_id, SUM(sumsales) FROM base_agg GROUP BY i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy UNION ALL SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, NULL AS d_moy, NULL AS s_store_id, SUM(sumsales) FROM base_agg GROUP BY i_category, i_class, i_brand, i_product_name, d_year, d_qoy UNION ALL SELECT i_category, i_class, i_brand, i_product_name, d_year, NULL AS d_qoy, NULL AS d_moy, NULL AS s_store_id, SUM(sumsales) FROM base_agg GROUP BY i_category, i_class, i_brand, i_product_name, d_year UNION ALL SELECT i_category, i_class, i_brand, i_product_name, NULL AS d_year, NULL AS d_qoy, NULL AS d_moy, NULL AS s_store_id, SUM(sumsales) FROM base_agg GROUP BY i_category, i_class, i_brand, i_product_name UNION ALL SELECT i_category, i_class, i_brand, NULL AS i_product_name, NULL AS d_year, NULL AS d_qoy, NULL AS d_moy, NULL AS s_store_id, SUM(sumsales) FROM base_agg GROUP BY i_category, i_class, i_brand UNION ALL SELECT i_category, i_class, NULL AS i_brand, NULL AS i_product_name, NULL AS d_year, NULL AS d_qoy, NULL AS d_moy, NULL AS s_store_id, SUM(sumsales) FROM base_agg GROUP BY i_category, i_class UNION ALL SELECT i_category, NULL AS i_class, NULL AS i_brand, NULL AS i_product_name, NULL AS d_year, NULL AS d_qoy, NULL AS d_moy, NULL AS s_store_id, SUM(sumsales) FROM base_agg GROUP BY i_category UNION ALL SELECT NULL AS i_category, NULL AS i_class, NULL AS i_brand, NULL AS i_product_name, NULL AS d_year, NULL AS d_qoy, NULL AS d_moy, NULL AS s_store_id, SUM(sumsales) FROM base_agg",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales"], "consumes": ["base_agg"]}
      },
      "window_rank": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, RANK() OVER (PARTITION BY i_category ORDER BY sumsales DESC) AS rk FROM rollup_union",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales", "rk"], "consumes": ["rollup_union"]}
      },
      "filter_rank": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, rk FROM window_rank WHERE rk <= 100",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales", "rk"], "consumes": ["window_rank"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT * FROM filter_rank ORDER BY i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, rk LIMIT 100",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales", "rk"], "consumes": ["filter_rank"]}
      }
    },
    "reconstruction_order": ["base_agg", "rollup_union", "window_rank", "filter_rank", "main_query"],
    "assembly_template": "WITH base_agg AS ({base_agg}), rollup_union AS ({rollup_union}), window_rank AS ({window_rank}), filter_rank AS ({filter_rank}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Replaced the inline ROLLUP with an explicit 9-level UNION ALL structure as specified in the target logical tree, maintaining exact semantic equivalence. The rewrite computes base aggregation once, then builds the rollup via UNION ALL, ranks within i_category, filters top 100 per category, and orders/limits.

Expected speedup: 2.5x (similar to rollup_to_union_windowing pattern) due to explicit control over aggregation levels and avoidance of ROLLUP optimizer issues.