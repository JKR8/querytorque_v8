## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_cte  [+]
│   ├── SCAN date_dim
│   └── FILTER (d_month_seq BETWEEN 1206 AND 1206+11)
├── [CTE] store_cte  [+]
│   ├── SCAN store
│   └── FILTER (s_store_sk <= 100)
├── [CTE] item_cte  [+]
│   └── SCAN item
├── [CTE] fact_with_dims  [+]
│   ├── SCAN store_sales
│   ├── JOIN date_cte (INNER ON ss_sold_date_sk = d_date_sk)
│   ├── JOIN store_cte (INNER ON ss_store_sk = s_store_sk)
│   └── JOIN item_cte (INNER ON ss_item_sk = i_item_sk)
├── [CTE] rollup_agg  [+]
│   ├── SCAN fact_with_dims
│   ├── GROUP BY ROLLUP(i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id)
│   └── AGG sum(coalesce(ss_sales_price * ss_quantity, 0)) AS sumsales
├── [CTE] window_rank  [+]
│   ├── SCAN rollup_agg
│   └── WINDOW rank() OVER (PARTITION BY i_category ORDER BY sumsales DESC) AS rk
├── [CTE] filter_rank  [+]
│   ├── SCAN window_rank
│   └── FILTER (rk <= 100)
├── [MAIN] main_query  [~]
│   ├── SCAN filter_rank
│   ├── SORT (i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, rk)
│   ├── LIMIT 100
│   └── OUTPUT (i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, rk)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "prefetch_fact_join", "description": "Stage dimension filters into CTEs before joining with fact table", "applied_to": ["date_cte", "store_cte", "item_cte", "fact_with_dims"]},
    {"id": "R2", "type": "pipeline_separation", "description": "Separate ROLLUP aggregation, window ranking, and filtering into distinct CTEs per logical tree", "applied_to": ["rollup_agg", "window_rank", "filter_rank"]},
    {"id": "R3", "type": "defensive_guard_preservation", "description": "Preserve COALESCE in sum aggregation even though filters guarantee non-null", "applied_to": ["rollup_agg"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_year, d_qoy, d_moy FROM date_dim WHERE d_month_seq BETWEEN 1206 AND 1206+11",
        "interfaces": {"outputs": ["d_date_sk", "d_year", "d_qoy", "d_moy"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk, s_store_id FROM store WHERE s_store_sk <= 100",
        "interfaces": {"outputs": ["s_store_sk", "s_store_id"], "consumes": []}
      },
      "item_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk, i_category, i_class, i_brand, i_product_name FROM item",
        "interfaces": {"outputs": ["i_item_sk", "i_category", "i_class", "i_brand", "i_product_name"], "consumes": []}
      },
      "fact_with_dims": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i.i_category, i.i_class, i.i_brand, i.i_product_name, d.d_year, d.d_qoy, d.d_moy, s.s_store_id, ss.ss_sales_price, ss.ss_quantity FROM store_sales ss INNER JOIN date_cte d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN store_cte s ON ss.ss_store_sk = s.s_store_sk INNER JOIN item_cte i ON ss.ss_item_sk = i.i_item_sk",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "ss_sales_price", "ss_quantity"], "consumes": ["date_cte", "store_cte", "item_cte"]}
      },
      "rollup_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, SUM(COALESCE(ss_sales_price * ss_quantity, 0)) AS sumsales FROM fact_with_dims GROUP BY ROLLUP(i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id)",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales"], "consumes": ["fact_with_dims"]}
      },
      "window_rank": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, RANK() OVER (PARTITION BY i_category ORDER BY sumsales DESC) AS rk FROM rollup_agg",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales", "rk"], "consumes": ["rollup_agg"]}
      },
      "filter_rank": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, rk FROM window_rank WHERE rk <= 100",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales", "rk"], "consumes": ["window_rank"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, rk FROM filter_rank ORDER BY i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, rk LIMIT 100",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales", "rk"], "consumes": ["filter_rank"]}
      }
    },
    "reconstruction_order": ["date_cte", "store_cte", "item_cte", "fact_with_dims", "rollup_agg", "window_rank", "filter_rank", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), store_cte AS ({store_cte}), item_cte AS ({item_cte}), fact_with_dims AS ({fact_with_dims}), rollup_agg AS ({rollup_agg}), window_rank AS ({window_rank}), filter_rank AS ({filter_rank}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured the original flat query into a staged CTE pipeline that pre-filters dimensions (date, store) before joining with the fact table, then performs ROLLUP aggregation, window ranking, filtering, and final ordering in separate logical stages. This follows the exact target logical tree while preserving all semantics.

**Expected speedup**: ~2.0x (dimension isolation reduces hash table build cost; staged pipeline enables better predicate pushdown despite CTE boundaries).