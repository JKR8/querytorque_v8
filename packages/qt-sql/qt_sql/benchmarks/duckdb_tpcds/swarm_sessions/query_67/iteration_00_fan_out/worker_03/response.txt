## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K
    ├── [~] CTE: joined (replaces inline join)
    ├── [~] CTE: rollup_agg (replaces inline subquery)
    ├── [~] CTE: window_rank (replaces inline window)
    ├── [=] FILTER (rk <= 100)
    ├── [=] SORT (i_category ASC, i_class ASC, i_brand ASC, i_product_name ASC, d_year ASC, d_qoy ASC, d_moy ASC, s_store_id ASC, sumsales ASC, rk ASC)
    └── [=] OUTPUT (*)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "explicit_cte_breakdown", "description": "Replace nested subqueries with explicit CTEs matching target logical tree", "applied_to": ["joined", "rollup_agg", "window_rank"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "joined": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i.i_category, i.i_class, i.i_brand, i.i_product_name, d.d_year, d.d_qoy, d.d_moy, s.s_store_id, ss.ss_sales_price, ss.ss_quantity FROM store_sales AS ss INNER JOIN date_dim AS d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN store AS s ON ss.ss_store_sk = s.s_store_sk INNER JOIN item AS i ON ss.ss_item_sk = i.i_item_sk WHERE d.d_month_seq BETWEEN 1206 AND 1206+11 AND s.s_store_sk <= 100",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "ss_sales_price", "ss_quantity"], "consumes": []}
      },
      "rollup_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, SUM(COALESCE(ss_sales_price * ss_quantity, 0)) AS sumsales FROM joined GROUP BY ROLLUP(i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id)",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales"], "consumes": ["joined"]}
      },
      "window_rank": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, RANK() OVER (PARTITION BY i_category ORDER BY sumsales DESC) AS rk FROM rollup_agg",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales", "rk"], "consumes": ["rollup_agg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, rk FROM window_rank WHERE rk <= 100 ORDER BY i_category, i_class, i_brand, i_product_name, d_year, d_qoy, d_moy, s_store_id, sumsales, rk LIMIT 100",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "i_product_name", "d_year", "d_qoy", "d_moy", "s_store_id", "sumsales", "rk"], "consumes": ["window_rank"]}
      }
    },
    "reconstruction_order": ["joined", "rollup_agg", "window_rank", "main_query"],
    "assembly_template": "WITH joined AS ({joined}), rollup_agg AS ({rollup_agg}), window_rank AS ({window_rank}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured the original nested subqueries into explicit CTEs following the target logical tree (joined → rollup_agg → window_rank → filter + order/limit). Preserves all joins, filters, rollup grouping, window ranking, and defensive COALESCE exactly as in the original.

**Expected speedup**: Minimal (≈1.0x) – this is primarily a structural rewrite for clarity and to match the requested tree. The DuckDB optimizer will likely flatten these CTEs anyway, but we maintain semantic equivalence with the original.