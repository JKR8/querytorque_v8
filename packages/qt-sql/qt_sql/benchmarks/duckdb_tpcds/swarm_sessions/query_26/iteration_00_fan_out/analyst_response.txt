<reasoning>
1. **CLASSIFY**: This is a star-join with late dim filter. Single fact table (catalog_sales) joined with 4 dimension tables (customer_demographics, date_dim, item, promotion) with filters on dimensions, then grouped by item.

2. **EXPLAIN PLAN ANALYSIS**:
   - Total time: 654ms
   - Biggest costs: catalog_sales scan (344.7ms, 53%) and hash join with customer_demographics (256.9ms, 39%)
   - Row count flow:
     - catalog_sales: 172.8M → 2.9M after date filter (98.3% reduction)
     - customer_demographics: 23.0M → 27K (99.9% reduction)
     - date_dim: 73K → 365 (99.5% reduction)
     - promotion: unknown → 500 rows after OR filter
     - After joins: 2.9M → 40K → 27K groups → TOP 100
   - The optimizer already pushes predicates into scans (date_dim, customer_demographics, promotion)
   - Fact table scanned only once (good)
   - No CTEs in original query

3. **GAP MATCHING**:
   - **CROSS_COLUMN_OR_DECOMPOSITION**: OR condition on promotion table (p_channel_email='N' OR p_channel_event='N') - could split into UNION
   - **CROSS_CTE_PREDICATE_BLINDNESS**: No CTEs currently, so no cross-CTE pushdown issues. But opportunity to create dimension CTEs for early filtering
   - **REDUNDANT_SCAN_ELIMINATION**: Only one fact scan, so no consolidation needed
   - Engine strengths already handle: intra-scan pushdown (filters pushed into scans), hash join selection

4. **AGGREGATION TRAP CHECK**: Only AVG functions. If join duplication changes, AVG changes. Must preserve join semantics.

5. **TRANSFORM SELECTION** (ranked by potential):
   a. **or_to_union**: OR on different columns in promotion table (email vs event). Could split into 2 UNION branches.
   b. **star_join_prefetch** (dimension_cte_isolate + multi_dimension_prefetch): Pre-filter all dimensions into CTEs before joining with fact.
   c. **early_filter**: Filter dimensions first, then join to fact.
   d. **single_pass_aggregation**: Not applicable - only one fact scan.
   e. **prefetch_fact_join**: Build CTE chain: filter date, pre-join with fact, then join other dims.

   Choose 4 diverse strategies:
   1. **or_to_union** - split OR condition
   2. **star_join_prefetch** - pre-filter all dimensions
   3. **prefetch_fact_join** - staged join pipeline
   4. **early_filter** + **materialize_cte** - exploration combining early filter with CTE materialization for multi-reference

6. **LOGICAL TREE DESIGN**:
   - For each strategy, design CTE structure with exhaustive output columns
   - Check downstream column references
   - Avoid cross-joining 3+ dimension CTEs (regression warning)
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
Compute per-item average metrics for 2001 catalog sales to male, single customers with unknown education under promotions where email or event channel is disabled. All joins are INNER (intersection semantics) requiring matches on all 5 tables. AVG aggregates are sensitive to row duplication from joins; any rewrite must preserve the exact join cardinality per item. The OR condition on promotion channels must evaluate per promotion row before joining to catalog_sales.

BOTTLENECK_DIAGNOSIS:
Scan-bound on catalog_sales (344.7ms, 53% of runtime) followed by hash join with customer_demographics (256.9ms, 39%). The date filter reduces fact rows from 172.8M to 2.9M (98.3% reduction), but the subsequent join with customer_demographics still probes 2.9M rows against a 27K hash table. Cardinality flow: 2.9M fact rows → 40K after customer join → 27K groups. The optimizer already handles predicate pushdown into dimension scans efficiently (date_dim, customer_demographics, promotion). Logical-tree cost percentages are misleading - the EXPLAIN timings show catalog_sales scan dominates.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output i_item_id, agg1, agg2, agg3, agg4 in same order
- CTE_COLUMN_COMPLETENESS: Any CTE must include all columns referenced downstream (join keys, grouping columns, aggregates)
- LITERAL_PRESERVATION: Must preserve 'M', 'S', 'Unknown', 'N', 2001 exactly
- SEMANTIC_EQUIVALENCE: Must return same rows with same averages
- CROSS_COLUMN_OR_DECOMPOSITION: OR on p_channel_email and p_channel_event in promotion table
- CROSS_CTE_PREDICATE_BLINDNESS: No CTEs in original, opportunity to create filtered dimension CTEs

REGRESSION_WARNINGS:
1. dimension_cte_isolate (0.0076x):
   CAUSE: Cross-joined 3+ dimension CTEs causing Cartesian explosion
   RULE: Never cross-join 3+ dimension CTEs; join dimensions sequentially to fact table
2. or_to_union (0.59x):
   CAUSE: Split same-column time range OR, duplicating fact scans
   RULE: Only split OR on different columns/tables, not same-column ranges
3. prefetch_fact_join (0.50x):
   CAUSE: Baseline <50ms, CTE overhead dominated savings
   RULE: This query baseline is 654ms, so CTE overhead acceptable

=== WORKER 1 BRIEFING ===

STRATEGY: or_to_union
TARGET_LOGICAL_TREE:
  promotion_email_cte -> join_with_other_dims -> union_all <- promotion_event_cte -> join_with_other_dims -> final_aggregation
NODE_CONTRACTS:
  promotion_email_cte:
    FROM: promotion
    WHERE: p_channel_email = 'N'
    OUTPUT: p_promo_sk
    EXPECTED_ROWS: ~250 (half of 500)
    CONSUMERS: branch1_joined
  promotion_event_cte:
    FROM: promotion
    WHERE: p_channel_event = 'N'
    OUTPUT: p_promo_sk
    EXPECTED_ROWS: ~250
    CONSUMERS: branch2_joined
  branch1_joined:
    FROM: catalog_sales, date_dim, customer_demographics, item, promotion_email_cte
    JOIN: cs_sold_date_sk = d_date_sk AND cs_item_sk = i_item_sk AND cs_bill_cdemo_sk = cd_demo_sk AND cs_promo_sk = p_promo_sk
    WHERE: cd_gender = 'M' AND cd_marital_status = 'S' AND cd_education_status = 'Unknown' AND d_year = 2001
    OUTPUT: i_item_id, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price
    EXPECTED_ROWS: ~20K (half of 40K)
    CONSUMERS: union_all
  branch2_joined:
    FROM: catalog_sales, date_dim, customer_demographics, item, promotion_event_cte
    JOIN: cs_sold_date_sk = d_date_sk AND cs_item_sk = i_item_sk AND cs_bill_cdemo_sk = cd_demo_sk AND cs_promo_sk = p_promo_sk
    WHERE: cd_gender = 'M' AND cd_marital_status = 'S' AND cd_education_status = 'Unknown' AND d_year = 2001
    OUTPUT: i_item_id, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price
    EXPECTED_ROWS: ~20K
    CONSUMERS: union_all
  final_aggregation:
    FROM: union_all of branch1_joined and branch2_joined
    GROUP BY: i_item_id
    AGGREGATE: AVG(cs_quantity), AVG(cs_list_price), AVG(cs_coupon_amt), AVG(cs_sales_price)
    OUTPUT: i_item_id, agg1, agg2, agg3, agg4
    ORDER BY: i_item_id
    LIMIT: 100
    EXPECTED_ROWS: 27K → 100
    CONSUMERS: output
EXAMPLES: or_to_union, channel_bitmap_aggregation, single_pass_aggregation
EXAMPLE_ADAPTATION:
- or_to_union: Apply splitting OR on different promotion columns into UNION ALL; ignore the 3-branch structure (we only have 2)
- channel_bitmap_aggregation: Ignore the CASE aggregation part; focus on splitting different channel conditions
- single_pass_aggregation: Ignore the scalar subquery consolidation; focus on handling OR via branching
HAZARD_FLAGS:
- Duplicate rows if same promotion satisfies both conditions (but UNION ALL preserves duplicates correctly)
- Must ensure both branches have identical column lists for UNION ALL

=== WORKER 2 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  date_cte -> customer_cte -> promotion_cte -> prefact_cte (join all dim CTEs) -> fact_with_dims -> item_join -> aggregation
NODE_CONTRACTS:
  date_cte:
    FROM: date_dim
    WHERE: d_year = 2001
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 365
    CONSUMERS: prefact_cte
  customer_cte:
    FROM: customer_demographics
    WHERE: cd_gender = 'M' AND cd_marital_status = 'S' AND cd_education_status = 'Unknown'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: 27K
    CONSUMERS: prefact_cte
  promotion_cte:
    FROM: promotion
    WHERE: p_channel_email = 'N' OR p_channel_event = 'N'
    OUTPUT: p_promo_sk
    EXPECTED_ROWS: 500
    CONSUMERS: prefact_cte
  prefact_cte:
    FROM: date_cte, customer_cte, promotion_cte
    JOIN: CROSS JOIN (but implement as nested joins with fact table)
    OUTPUT: d_date_sk, cd_demo_sk, p_promo_sk
    EXPECTED_ROWS: 365 * 27K * 500 = too large (4.9B) but will be reduced by fact join
    CONSUMERS: fact_with_dims
  fact_with_dims:
    FROM: catalog_sales JOIN prefact_cte ON cs_sold_date_sk = d_date_sk AND cs_bill_cdemo_sk = cd_demo_sk AND cs_promo_sk = p_promo_sk
    OUTPUT: cs_item_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price
    EXPECTED_ROWS: 40K
    CONSUMERS: item_join
  item_join:
    FROM: fact_with_dims JOIN item ON cs_item_sk = i_item_sk
    OUTPUT: i_item_id, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price
    EXPECTED_ROWS: 40K
    CONSUMERS: aggregation
  aggregation:
    FROM: item_join
    GROUP BY: i_item_id
    AGGREGATE: AVG(cs_quantity), AVG(cs_list_price), AVG(cs_coupon_amt), AVG(cs_sales_price)
    OUTPUT: i_item_id, agg1, agg2, agg3, agg4
    ORDER BY: i_item_id
    LIMIT: 100
    EXPECTED_ROWS: 27K → 100
    CONSUMERS: output
EXAMPLES: dimension_cte_isolate, multi_dimension_prefetch, date_cte_isolate
EXAMPLE_ADAPTATION:
- dimension_cte_isolate: Apply pre-filtering all dimension tables into CTEs; ignore the cross-join warning (we'll join sequentially)
- multi_dimension_prefetch: Apply pre-filtering date, customer, promotion; ensure each CTE has WHERE clause
- date_cte_isolate: Apply date filtering into CTE; ignore the scalar subquery pattern
HAZARD_FLAGS:
- Cross-joining 3 dimension CTEs could cause Cartesian explosion if not properly joined with fact table
- Must join dimensions sequentially to fact table, not cross-join them first

=== WORKER 3 BRIEFING ===

STRATEGY: prefetch_fact_join
TARGET_LOGICAL_TREE:
  date_cte -> fact_date_join -> customer_join -> promotion_join -> item_join -> aggregation
NODE_CONTRACTS:
  date_cte:
    FROM: date_dim
    WHERE: d_year = 2001
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 365
    CONSUMERS: fact_date_join
  fact_date_join:
    FROM: catalog_sales JOIN date_cte ON cs_sold_date_sk = d_date_sk
    OUTPUT: cs_item_sk, cs_bill_cdemo_sk, cs_promo_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price
    EXPECTED_ROWS: 2.9M
    CONSUMERS: customer_join
  customer_join:
    FROM: fact_date_join JOIN customer_demographics ON cs_bill_cdemo_sk = cd_demo_sk
    WHERE: cd_gender = 'M' AND cd_marital_status = 'S' AND cd_education_status = 'Unknown'
    OUTPUT: cs_item_sk, cs_promo_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price
    EXPECTED_ROWS: 40K
    CONSUMERS: promotion_join
  promotion_join:
    FROM: customer_join JOIN promotion ON cs_promo_sk = p_promo_sk
    WHERE: p_channel_email = 'N' OR p_channel_event = 'N'
    OUTPUT: cs_item_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price
    EXPECTED_ROWS: 40K
    CONSUMERS: item_join
  item_join:
    FROM: promotion_join JOIN item ON cs_item_sk = i_item_sk
    OUTPUT: i_item_id, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price
    EXPECTED_ROWS: 40K
    CONSUMERS: aggregation
  aggregation:
    FROM: item_join
    GROUP BY: i_item_id
    AGGREGATE: AVG(cs_quantity), AVG(cs_list_price), AVG(cs_coupon_amt), AVG(cs_sales_price)
    OUTPUT: i_item_id, agg1, agg2, agg3, agg4
    ORDER BY: i_item_id
    LIMIT: 100
    EXPECTED_ROWS: 27K → 100
    CONSUMERS: output
EXAMPLES: prefetch_fact_join, early_filter, pushdown
EXAMPLE_ADAPTATION:
- prefetch_fact_join: Apply staged CTE chain: date filter → fact join → other dims; ignore the 2+ fact table chains (only one fact)
- early_filter: Apply dimension filtering early in CTEs; join sequentially to fact
- pushdown: Push date filter into CTE, then join with fact; ignore the scalar subquery consolidation
HAZARD_FLAGS:
- Must ensure all necessary columns flow through each CTE (cs_item_sk for item join, etc.)
- CTE materialization overhead may offset benefits if optimizer already efficient

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: early_filter_with_materialized_or_cte
TARGET_LOGICAL_TREE:
  date_cte -> customer_cte -> promotion_or_cte -> fact_join_all -> item_join -> aggregation
NODE_CONTRACTS:
  date_cte:
    FROM: date_dim
    WHERE: d_year = 2001
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 365
    CONSUMERS: fact_join_all
  customer_cte:
    FROM: customer_demographics
    WHERE: cd_gender = 'M' AND cd_marital_status = 'S' AND cd_education_status = 'Unknown'
    OUTPUT: cd_demo_sk
    EXPECTED_ROWS: 27K
    CONSUMERS: fact_join_all
  promotion_or_cte:
    FROM: promotion
    WHERE: p_channel_email = 'N' OR p_channel_event = 'N'
    OUTPUT: p_promo_sk
    EXPECTED_ROWS: 500
    CONSUMERS: fact_join_all
  fact_join_all:
    FROM: catalog_sales 
    JOIN date_cte ON cs_sold_date_sk = d_date_sk
    JOIN customer_cte ON cs_bill_cdemo_sk = cd_demo_sk
    JOIN promotion_or_cte ON cs_promo_sk = p_promo_sk
    OUTPUT: cs_item_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price
    EXPECTED_ROWS: 40K
    CONSUMERS: item_join
  item_join:
    FROM: fact_join_all JOIN item ON cs_item_sk = i_item_sk
    OUTPUT: i_item_id, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price
    EXPECTED_ROWS: 40K
    CONSUMERS: aggregation
  aggregation:
    FROM: item_join
    GROUP BY: i_item_id
    AGGREGATE: AVG(cs_quantity), AVG(cs_list_price), AVG(cs_coupon_amt), AVG(cs_sales_price)
    OUTPUT: i_item_id, agg1, agg2, agg3, agg4
    ORDER BY: i_item_id
    LIMIT: 100
    EXPECTED_ROWS: 27K → 100
    CONSUMERS: output
EXAMPLES: early_filter, materialize_cte, dimension_cte_isolate
EXAMPLE_ADAPTATION:
- early_filter: Apply pre-filtering all dimensions into CTEs; join fact with all dimension CTEs
- materialize_cte: Materialize promotion OR filter into CTE to avoid recomputation; but we only reference once so no sharing benefit
- dimension_cte_isolate: Apply dimension isolation; but join all 3 dim CTEs directly to fact (not cross-joined)
HAZARD_FLAGS:
- Risk of Cartesian explosion if JOIN conditions omitted between dimension CTEs and fact
- Must use explicit JOIN syntax with ON conditions, not comma joins
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: This strategy avoids the cross-join of 3+ dimension CTEs by joining them sequentially to the fact table, not to each other.
EXPLORATION_TYPE: compound_strategy