### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Restructured into CTE pipeline with early filtering
    ├── [~] filtered_date  [=]  — Date CTE reused for both sales and returns date filtering
    │   └── FILTER (d_date BETWEEN (CAST('2001-04-02' AS DATE) - INTERVAL 30 DAY) AND (CAST('2001-04-02' AS DATE) + INTERVAL 30 DAY))
    ├── [~] filtered_item  [=]  — Early item price filter
    │   └── FILTER (i_current_price BETWEEN 0.99 AND 1.49)
    ├── [+] returns_with_date  — NEW: Returns pre-joined with date filter on return date
    │   └── JOIN (catalog_returns INNER JOIN filtered_date ON cr_returned_date_sk = d_date_sk)
    ├── [~] sales_with_filtered_returns  — Modified: Uses CTEs instead of raw tables
    │   ├── JOIN (catalog_sales INNER JOIN filtered_date ON cs_sold_date_sk = d_date_sk)
    │   ├── JOIN (catalog_sales INNER JOIN filtered_item ON cs_item_sk = i_item_sk)
    │   ├── JOIN (catalog_sales LEFT JOIN returns_with_date ON cs_order_number = cr_order_number AND cs_item_sk = cr_item_sk)
    │   └── JOIN (catalog_sales INNER JOIN warehouse ON cs_warehouse_sk = w_warehouse_sk)
    ├── [~] final_aggregation  [=]  — Now sourced from CTE
    │   ├── AGG (GROUP BY w_state, i_item_id)
    │   ├── CASE-WHEN (sales_before)
    │   ├── CASE-WHEN (sales_after)
    │   ├── SORT (w_state ASC, i_item_id ASC)
    │   └── OUTPUT (w_state, i_item_id, sales_before, sales_after)
    └── LIMIT 100
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter", "description": "Filter date_dim and item into CTEs before joining to fact tables", "applied_to": ["filtered_date", "filtered_item"]},
    {"id": "R2", "type": "prefetch_fact_join", "description": "Pre-join catalog_returns with date CTE to filter returns by return date", "applied_to": ["returns_with_date"]},
    {"id": "R3", "type": "staged_join_pipeline", "description": "Build sales CTE by sequentially joining filtered dimensions and pre-filtered returns", "applied_to": ["sales_with_filtered_returns"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN (CAST('2001-04-02' AS DATE) - INTERVAL 30 DAY) AND (CAST('2001-04-02' AS DATE) + INTERVAL 30 DAY)",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_id FROM item WHERE i_current_price BETWEEN 0.99 AND 1.49",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id"], "consumes": []}
      },
      "returns_with_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cr_order_number, cr_item_sk, cr_refunded_cash FROM catalog_returns INNER JOIN filtered_date ON cr_returned_date_sk = d_date_sk",
        "interfaces": {"outputs": ["cr_order_number", "cr_item_sk", "cr_refunded_cash"], "consumes": ["filtered_date"]}
      },
      "sales_with_filtered_returns": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT w.w_state, i.i_item_id, d.d_date, cs.cs_sales_price, COALESCE(cr.cr_refunded_cash, 0) AS cr_refunded_cash FROM catalog_sales cs INNER JOIN filtered_date d ON cs.cs_sold_date_sk = d.d_date_sk INNER JOIN filtered_item i ON cs.cs_item_sk = i.i_item_sk LEFT JOIN returns_with_date cr ON cs.cs_order_number = cr.cr_order_number AND cs.cs_item_sk = cr.cr_item_sk INNER JOIN warehouse w ON cs.cs_warehouse_sk = w.w_warehouse_sk",
        "interfaces": {"outputs": ["w_state", "i_item_id", "d_date", "cs_sales_price", "cr_refunded_cash"], "consumes": ["filtered_date", "filtered_item", "returns_with_date"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT w_state, i_item_id, SUM(CASE WHEN d_date < CAST('2001-04-02' AS DATE) THEN cs_sales_price - cr_refunded_cash ELSE 0 END) AS sales_before, SUM(CASE WHEN d_date >= CAST('2001-04-02' AS DATE) THEN cs_sales_price - cr_refunded_cash ELSE 0 END) AS sales_after FROM sales_with_filtered_returns GROUP BY w_state, i_item_id ORDER BY w_state, i_item_id LIMIT 100",
        "interfaces": {"outputs": ["w_state", "i_item_id", "sales_before", "sales_after"], "consumes": ["sales_with_filtered_returns"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_item", "returns_with_date", "sales_with_filtered_returns", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_item AS ({filtered_item}), returns_with_date AS ({returns_with_date}), sales_with_filtered_returns AS ({sales_with_filtered_returns}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured into CTE pipeline with early filtering of dimensions and pre-filtering of returns by return date (novel semantic change). The staged join reduces intermediate row counts before the final aggregation.

**Expected speedup**: ~1.5-2x due to reduced catalog_returns scan from pre-filtering by date, though dependent on data distribution and return date clustering.