You are a SQL rewrite engine for DuckDB v1.4.3. Follow the Target Logical Tree structure below. Your job is to write correct, executable SQL for each node — not to decide whether to restructure. Preserve exact semantic equivalence (same rows, same columns, same ordering). Preserve defensive guards: if the original uses CASE WHEN x > 0 THEN y/x END around a division, keep it — even when a WHERE clause makes the zero case unreachable. Guards prevent silent breakage if filters change upstream. Strip benchmark comments (-- start query, -- end query) from your output.

DuckDB specifics: columnar storage (SELECT only needed columns). CTEs referenced once are typically inlined; CTEs referenced multiple times may be materialized. FILTER clause is native (`COUNT(*) FILTER (WHERE cond)`). Predicate pushdown stops at UNION ALL boundaries and multi-level CTE references.

## Semantic Contract (MUST preserve)

Segment customers by follow-on store revenue after they bought Women/maternity items via catalog or web in May 1998, using revenue bands of size 50. All joins are INNER (intersection) requiring matches on both sides. Aggregations are SUM and COUNT, which are duplicate-safe but must preserve original join semantics where store_sales may duplicate if multiple stores match customer's county/state. Filter dependencies: date_dim filters (d_moy=5, d_year=1998) appear in my_customers and two scalar subqueries; item filters (i_category='Women', i_class='maternity') apply only to my_customers.

## Target Logical Tree + Node Contracts

Build your rewrite following this CTE structure. Each node's OUTPUT list is exhaustive — your SQL must produce exactly those columns.

TARGET_LOGICAL_TREE:
filtered_items_dates -> sales_union -> my_customers -> my_revenue -> segments -> main_query
NODE_CONTRACTS:
  filtered_items_dates:
    FROM: item, date_dim
    JOIN: i_item_sk = d_date_sk? Wait: item and date_dim are not directly joinable. Actually we need to filter both independently.
    Correction:
    FROM: item, date_dim
    WHERE: i_category = 'Women' AND i_class = 'maternity' AND d_year = 1998 AND d_moy = 5
    OUTPUT: i_item_sk, d_date_sk
    EXPECTED_ROWS: ~80 (2,566 items * 31 dates? Actually cross product is wrong. They are independent dimensions. Need separate CTEs? But example shared_dimension_multi_channel extracts shared filters into one CTE for both dimensions. However item and date_dim are not joined in the original query until joined with sales. So we can create two CTEs and cross-join? Better: create two separate CTEs and join sales with both.
    Revised approach: Create two CTEs (filtered_items, filtered_dates) then join sales with both.
    Let's restructure:
    filtered_items:
      FROM: item
      WHERE: i_category = 'Women' AND i_class = 'maternity'
      OUTPUT: i_item_sk
    filtered_dates:
      FROM: date_dim
      WHERE: d_year = 1998 AND d_moy = 5
      OUTPUT: d_date_sk
    Then sales_union joins catalog_sales with filtered_items and filtered_dates.
  filtered_items:
    FROM: item
    WHERE: i_category = 'Women' AND i_class = 'maternity'
    OUTPUT: i_item_sk
    EXPECTED_ROWS: 2,566
    CONSUMERS: sales_union
  filtered_dates:
    FROM: date_dim
    WHERE: d_year = 1998 AND d_moy = 5
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 31
    CONSUMERS: sales_union
  sales_union:
    FROM: 
      (SELECT cs_sold_date_sk AS sold_date_sk, cs_bill_customer_sk AS customer_sk, cs_item_sk AS item_sk FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN filtered_items ON cs_item_sk = i_item_sk)
      UNION ALL
      (SELECT ws_sold_date_sk AS sold_date_sk, ws_bill_customer_sk AS customer_sk, ws_item_sk AS item_sk FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_items ON ws_item_sk = i_item_sk)
    OUTPUT: sold_date_sk, customer_sk, item_sk
    EXPECTED_ROWS: 5,281 (as per EXPLAIN)
    CONSUMERS: my_customers
  my_customers:
    FROM: sales_union, customer
    JOIN: c_customer_sk = customer_sk
    OUTPUT: c_customer_sk, c_current_addr_sk
    EXPECTED_ROWS: 5,270
    CONSUMERS: my_revenue
  my_revenue: (same as original, but using my_customers)
    FROM: my_customers, store_sales, customer_address, store, date_dim
    JOIN: c_current_addr_sk = ca_address_sk AND ca_county = s_county AND ca_state = s_state AND ss_sold_date_sk = d_date_sk AND c_customer_sk = ss_customer_sk
    WHERE: d_month_seq BETWEEN (SELECT DISTINCT d_month_seq+1 FROM date_dim WHERE d_year=1998 AND d_moy=5) AND (SELECT DISTINCT d_month_seq+3 FROM date_dim WHERE d_year=1998 AND d_moy=5)
    GROUP BY: c_customer_sk
    AGGREGATE: SUM(ss_ext_sales_price) AS revenue
    OUTPUT: c_customer_sk, revenue
    EXPECTED_ROWS: 4,605
    CONSUMERS: segments
  segments and main_query as before.

NODE_CONTRACTS:
filtered_items_dates:
    FROM: item, date_dim
    JOIN: i_item_sk = d_date_sk? Wait: item and date_dim are not directly joinable. Actually we need to filter both independently.
    Correction:
    FROM: item, date_dim
    WHERE: i_category = 'Women' AND i_class = 'maternity' AND d_year = 1998 AND d_moy = 5
    OUTPUT: i_item_sk, d_date_sk
    EXPECTED_ROWS: ~80 (2,566 items * 31 dates? Actually cross product is wrong. They are independent dimensions. Need separate CTEs? But example shared_dimension_multi_channel extracts shared filters into one CTE for both dimensions. However item and date_dim are not joined in the original query until joined with sales. So we can create two CTEs and cross-join? Better: create two separate CTEs and join sales with both.
    Revised approach: Create two CTEs (filtered_items, filtered_dates) then join sales with both.
    Let's restructure:
    filtered_items:
      FROM: item
      WHERE: i_category = 'Women' AND i_class = 'maternity'
      OUTPUT: i_item_sk
    filtered_dates:
      FROM: date_dim
      WHERE: d_year = 1998 AND d_moy = 5
      OUTPUT: d_date_sk
    Then sales_union joins catalog_sales with filtered_items and filtered_dates.
  filtered_items:
    FROM: item
    WHERE: i_category = 'Women' AND i_class = 'maternity'
    OUTPUT: i_item_sk
    EXPECTED_ROWS: 2,566
    CONSUMERS: sales_union
  filtered_dates:
    FROM: date_dim
    WHERE: d_year = 1998 AND d_moy = 5
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 31
    CONSUMERS: sales_union
  sales_union:
    FROM: 
      (SELECT cs_sold_date_sk AS sold_date_sk, cs_bill_customer_sk AS customer_sk, cs_item_sk AS item_sk FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN filtered_items ON cs_item_sk = i_item_sk)
      UNION ALL
      (SELECT ws_sold_date_sk AS sold_date_sk, ws_bill_customer_sk AS customer_sk, ws_item_sk AS item_sk FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_items ON ws_item_sk = i_item_sk)
    OUTPUT: sold_date_sk, customer_sk, item_sk
    EXPECTED_ROWS: 5,281 (as per EXPLAIN)
    CONSUMERS: my_customers
  my_customers:
    FROM: sales_union, customer
    JOIN: c_customer_sk = customer_sk
    OUTPUT: c_customer_sk, c_current_addr_sk
    EXPECTED_ROWS: 5,270
    CONSUMERS: my_revenue
  my_revenue: (same as original, but using my_customers)
    FROM: my_customers, store_sales, customer_address, store, date_dim
    JOIN: c_current_addr_sk = ca_address_sk AND ca_county = s_county AND ca_state = s_state AND ss_sold_date_sk = d_date_sk AND c_customer_sk = ss_customer_sk
    WHERE: d_month_seq BETWEEN (SELECT DISTINCT d_month_seq+1 FROM date_dim WHERE d_year=1998 AND d_moy=5) AND (SELECT DISTINCT d_month_seq+3 FROM date_dim WHERE d_year=1998 AND d_moy=5)
    GROUP BY: c_customer_sk
    AGGREGATE: SUM(ss_ext_sales_price) AS revenue
    OUTPUT: c_customer_sk, revenue
    EXPECTED_ROWS: 4,605
    CONSUMERS: segments
  segments and main_query as before.

## Hazard Flags (avoid these specific risks)

- Ensure sales_union joins with filtered_items and filtered_dates correctly; note that original query also joins with customer later.
- The date_dim subqueries in my_revenue remain; could be further optimized but out of scope for this strategy.

## Regression Warnings (observed failures on similar queries)

1. prefetch_fact_join (0.50x on Q25):
   CAUSE: Pre-filtered and joined store_sales to date CTE BEFORE multi-way fact table join, losing optimizer reordering freedom.
   RULE: Avoid pre-joining fact tables in CTEs when query has 3+ fact table joins (this query has only store_sales as single fact in my_revenue, so safe).
2. dimension_cte_isolate (0.0076x on Q26):
   CAUSE: Cross-joined 3+ dimension CTEs caused Cartesian explosion.
   RULE: Never cross-join 3+ dimension CTEs; ensure each CTE has WHERE clause (our transforms have selective filters).
3. materialize_cte (0.14x on Q16):
   CAUSE: Converted EXISTS to materialized CTE, forcing full scan.
   RULE: Do not convert EXISTS/NOT EXISTS subqueries to materialized CTEs (query has no EXISTS, so safe).

## Constraints (analyst-filtered for this query)

- COMPLETE_OUTPUT: Must output segment, num_customers, segment_base in same order.
- CTE_COLUMN_COMPLETENESS: Each CTE must output all columns referenced downstream (c_customer_sk, c_current_addr_sk, revenue, segment).
- LITERAL_PRESERVATION: Must keep exact literals: 'Women', 'maternity', 5, 1998, 50, 1, 3.
- SEMANTIC_EQUIVALENCE: Result rows must match original exactly.
- CROSS_CTE_PREDICATE_BLINDNESS: EXPLAIN shows date_dim scanned 4 times with same/similar filters (d_moy=5, d_year=1998).
- REDUNDANT_SCAN_ELIMINATION: Multiple date_dim scans (4) for same filter pattern.
- UNION_CTE_SELF_JOIN_DECOMPOSITION: UNION of catalog_sales and web_sales shares identical dimension filters (item, date_dim).

## Example Adaptation Notes

For each example: what to apply to your rewrite, and what to ignore.

- shared_dimension_multi_channel (Q80): Extract shared dimension filters (date, item, promotion) into CTEs; apply to both catalog_sales and web_sales branches.
- dimension_cte_isolate (Q26): Pre-filter dimension tables (item, date_dim) into CTEs; ignore the cross-join of 3+ CTEs warning (we only have two).

## Reference Examples

Pattern reference only — do not copy table/column names or literals.

### 1. shared_dimension_multi_channel (1.30x)

**Principle:** Shared Dimension Extraction: when multiple channel CTEs (store/catalog/web) apply identical dimension filters, extract those shared filters into one CTE and reference it from each channel. Avoids redundant dimension scans.

**BEFORE (slow):**
```sql
with ssr as
 (select  s_store_id as store_id,
          sum(ss_ext_sales_price) as sales,
          sum(coalesce(sr_return_amt, 0)) as "returns",
          sum(ss_net_profit - coalesce(sr_net_loss, 0)) as profit
  from store_sales left outer join store_returns on
         (ss_item_sk = sr_item_sk and ss_ticket_number = sr_ticket_number),
     date_dim,
     store,
     item,
     promotion
 where ss_sold_date_sk = d_date_sk
       and d_date between cast('1998-08-28' as date) 
                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)
       and ss_store_sk = s_store_sk
       and ss_item_sk = i_item_sk
       and i_current_price > 50
       and ss_promo_sk = p_promo_sk
       and p_channel_tv = 'N'
 group by s_store_id)
 ,
 csr as
 (select  cp_catalog_page_id as catalog_page_id,
          sum(cs_ext_sales_price) as sales,
          sum(coalesce(cr_return_amount, 0)) as "returns",
          sum(cs_net_profit - coalesce(cr_net_loss, 0)) as profit
  from catalog_sales left outer join catalog_returns on
         (cs_item_sk = cr_item_sk and cs_order_number = cr_order_number),
     date_dim,
     catalog_page,
     item,
     promotion
 where cs_sold_date_sk = d_date_sk
       and d_date between cast('1998-08-28' as date)
                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)
        and cs_catalog_page_sk = cp_catalog_page_sk
       and cs_item_sk = i_item_sk
       and i_current_price > 50
       and cs_promo_sk = p_promo_sk
       and p_channel_tv = 'N'
group by cp_catalog_page_id)
 ,
 wsr as
 (select  web_site_id,
          sum(ws_ext_sales_price) as sales,
          sum(coalesce(wr_return_amt, 0)) as "returns",
          sum(ws_net_profit - coalesce(wr_net_loss, 0)) as profit
  from web_sales left outer join web_returns on
         (ws_item_sk = wr_item_sk and ws_order_number = wr_order_number),
     date_dim,
     web_site,
     item,
     promotion
 where ws_sold_date_sk = d_date_sk
       and d_date between cast('1998-08-28' as date)
                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)
        and ws_web_site_sk = web_site_sk
       and ws_item_sk = i_item_sk
       and i_current_price > 50
       and ws_promo_sk = p_promo_sk
       and p_channel_tv = 'N'
group by web_site_id)
  select channel
        , id
        , sum(sales) as sales
        , sum("returns") as "returns"
        , sum(profit) as profit
 from 
 (select 'store channel' as channel
        , 'store' || store_id as id
        , sales
        , "returns"
        , profit
 from   ssr
 union all
 select 'catalog channel' as channel
        , 'catalog_page' || catalog_page_id as id
        , sales
        , "returns"
        , profit
 from  csr
 union all
 select 'web channel' as channel
        , 'web_site' || web_site_id as id
        , sales
        , "returns"
        , profit
 from   wsr
 ) x
 group by rollup (channel, id)
 order by channel
         ,id
 LIMIT 100;
```

**AFTER (fast):**
[filtered_dates]:
```sql
SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' AS DATE) + INTERVAL '30' DAY)
```
[filtered_items]:
```sql
SELECT i_item_sk FROM item WHERE i_current_price > 50
```
[filtered_promotions]:
```sql
SELECT p_promo_sk FROM promotion WHERE p_channel_tv = 'N'
```
[prefiltered_store_sales]:
```sql
SELECT ss_item_sk, ss_store_sk, ss_ticket_number, ss_ext_sales_price, ss_net_profit FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_items ON ss_item_sk = i_item_sk JOIN filtered_promotions ON ss_promo_sk = p_promo_sk
```
[prefiltered_web_sales]:
```sql
SELECT ws_item_sk, ws_web_site_sk, ws_order_number, ws_ext_sales_price, ws_net_profit FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_items ON ws_item_sk = i_item_sk JOIN filtered_promotions ON ws_promo_sk = p_promo_sk
```
[ssr]:
```sql
SELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, SUM(COALESCE(sr_return_amt, 0)) AS returns, SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit FROM prefiltered_store_sales LEFT OUTER JOIN store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number) JOIN store ON ss_store_sk = s_store_sk GROUP BY s_store_id
```
[wsr]:
```sql
SELECT web_site_id, SUM(ws_ext_sales_price) AS sales, SUM(COALESCE(wr_return_amt, 0)) AS returns, SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit FROM prefiltered_web_sales LEFT OUTER JOIN web_returns ON (ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number) JOIN web_site ON ws_web_site_sk = web_site_sk GROUP BY web_site_id
```

### 2. dimension_cte_isolate (1.93x)

**Principle:** Early Selection: pre-filter dimension tables into CTEs returning only surrogate keys before joining with fact tables. Each dimension CTE is tiny, creating small hash tables that speed up the fact table probe.

**BEFORE (slow):**
```sql
select i_item_id, 
        avg(cs_quantity) agg1,
        avg(cs_list_price) agg2,
        avg(cs_coupon_amt) agg3,
        avg(cs_sales_price) agg4 
 from catalog_sales, customer_demographics, date_dim, item, promotion
 where cs_sold_date_sk = d_date_sk and
       cs_item_sk = i_item_sk and
       cs_bill_cdemo_sk = cd_demo_sk and
       cs_promo_sk = p_promo_sk and
       cd_gender = 'M' and 
       cd_marital_status = 'S' and
       cd_education_status = 'Unknown' and
       (p_channel_email = 'N' or p_channel_event = 'N') and
       d_year = 2001 
 group by i_item_id
 order by i_item_id
 LIMIT 100;
```

**AFTER (fast):**
[filtered_dates]:
```sql
SELECT d_date_sk FROM date_dim WHERE d_year = 2000
```
[filtered_customer_demographics]:
```sql
SELECT cd_demo_sk FROM customer_demographics WHERE cd_gender = 'M' AND cd_marital_status = 'S' AND cd_education_status = 'College'
```
[filtered_promotions]:
```sql
SELECT p_promo_sk FROM promotion WHERE p_channel_email = 'N' OR p_channel_event = 'N'
```
[joined_facts]:
```sql
SELECT cs_item_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price FROM catalog_sales AS cs JOIN filtered_dates AS fd ON cs.cs_sold_date_sk = fd.d_date_sk JOIN filtered_customer_demographics AS fcd ON cs.cs_bill_cdemo_sk = fcd.cd_demo_sk JOIN filtered_promotions AS fp ON cs.cs_promo_sk = fp.p_promo_sk
```
[main_query]:
```sql
SELECT i_item_id, AVG(cs_quantity) AS agg1, AVG(cs_list_price) AS agg2, AVG(cs_coupon_amt) AS agg3, AVG(cs_sales_price) AS agg4 FROM joined_facts AS jf JOIN item AS i ON jf.cs_item_sk = i.i_item_sk GROUP BY i_item_id ORDER BY i_item_id LIMIT 100
```

## Original SQL

```sql
-- start query 54 in stream 0 using template query54.tpl
with my_customers as (
 select distinct c_customer_sk
        , c_current_addr_sk
 from   
        ( select cs_sold_date_sk sold_date_sk,
                 cs_bill_customer_sk customer_sk,
                 cs_item_sk item_sk
          from   catalog_sales
          union all
          select ws_sold_date_sk sold_date_sk,
                 ws_bill_customer_sk customer_sk,
                 ws_item_sk item_sk
          from   web_sales
         ) cs_or_ws_sales,
         item,
         date_dim,
         customer
 where   sold_date_sk = d_date_sk
         and item_sk = i_item_sk
         and i_category = 'Women'
         and i_class = 'maternity'
         and c_customer_sk = cs_or_ws_sales.customer_sk
         and d_moy = 5
         and d_year = 1998
 )
 , my_revenue as (
 select c_customer_sk,
        sum(ss_ext_sales_price) as revenue
 from   my_customers,
        store_sales,
        customer_address,
        store,
        date_dim
 where  c_current_addr_sk = ca_address_sk
        and ca_county = s_county
        and ca_state = s_state
        and ss_sold_date_sk = d_date_sk
        and c_customer_sk = ss_customer_sk
        and d_month_seq between (select distinct d_month_seq+1
                                 from   date_dim where d_year = 1998 and d_moy = 5)
                           and  (select distinct d_month_seq+3
                                 from   date_dim where d_year = 1998 and d_moy = 5)
 group by c_customer_sk
 )
 , segments as
 (select cast((revenue/50) as int) as segment
  from   my_revenue
 )
  select segment, count(*) as num_customers, segment*50 as segment_base
 from segments
 group by segment
 order by segment, num_customers
 LIMIT 100;

-- end query 54 in stream 0 using template query54.tpl
```

## Rewrite Checklist (must pass before final SQL)

- Follow every node in `TARGET_LOGICAL_TREE` and produce each `NODE_CONTRACT` output column exactly.
- Keep all semantic invariants from `Semantic Contract` and `Constraints` (including join/null behavior).
- Preserve all literals and the exact final output schema/order.
- Apply `Hazard Flags` and `Regression Warnings` as hard guards against known failure modes.

### Column Completeness Contract

Your `main_query` component MUST produce **exactly** these output columns (same names, same order):

  1. `segment`
  2. `num_customers`
  3. `segment_base`

Do NOT add, remove, or rename any output columns. The result set schema must be identical to the original query.

## Original Query Structure

This is the current query structure. All nodes are `[=]` (unchanged). Your modified Logic Tree below should show which nodes you changed.

```
QUERY: (single statement)
├── [CTE] my_customers  [=]  Cost: 25%  Rows: ~1K  — Collect distinct customers who purchased Women/maternity items via catalog or web in May 1998 and carry their current address keys.
│   ├── SCAN (catalog_sales, web_sales, item (join), date_dim (join), customer (join))
│   ├── JOIN (sold_date_sk = d_date_sk)
│   ├── JOIN (item_sk = i_item_sk)
│   ├── JOIN (+1 more)
│   ├── FILTER (i_category = 'Women')
│   ├── FILTER (i_class = 'maternity')
│   ├── FILTER (+2 more)
│   ├── UNION
│   └── OUTPUT (c_customer_sk, c_current_addr_sk)
├── [CTE] my_revenue  [=]  Cost: 25%  Rows: ~1K  — For those customers, sum store-sales extended price in the next three month sequences where customer county/state matches store county/state.
│   ├── SCAN (my_customers, store_sales (join), customer_address (join), store (join), date_dim (join))
│   ├── JOIN (c_current_addr_sk = ca_address_sk)
│   ├── JOIN (ca_county = s_county)
│   ├── JOIN (+3 more)
│   ├── FILTER (? op d_month_seq + 1)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (c_customer_sk, revenue)
├── [CTE] segments  [=]  Cost: 25%  Rows: ~1K  — Convert each customer revenue into an integer segment bucket by dividing by 50.
│   ├── SCAN (my_revenue)
│   └── OUTPUT (segment)
└── [MAIN] main_query  [=]  Cost: 25%  Rows: ~1K  — Count customers per revenue segment and report segment id with segment base amount.
    ├── SCAN (segments)
    ├── AGG (GROUP BY)
    ├── SORT (segment ASC, num_customers ASC)
    └── OUTPUT (segment, num_customers, segment_base)
```

## Output Format

Your response has **two parts** in order:

### Part 1: Modified Logic Tree

Show what changed using change markers. Generate the tree BEFORE writing SQL.

Change markers:
- `[+]` — New component added
- `[-]` — Component removed
- `[~]` — Component modified (describe what changed)
- `[=]` — Unchanged (no children needed)
- `[!]` — Structural change (e.g. CTE → subquery)

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "<dialect>",
  "rewrite_rules": [
    {"id": "R1", "type": "<transform_name>", "description": "<what changed>", "applied_to": ["<component_id>"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "<cte_name>": {
        "type": "cte",
        "change": "modified",
        "sql": "<complete SQL for this CTE body>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<upstream_id>"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "<final SELECT>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<cte_name>"]}
      }
    },
    "reconstruction_order": ["<cte_name>", "main_query"],
    "assembly_template": "WITH <cte_name> AS ({<cte_name>}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Rules
- **Tree first, always.** Generate the Logic Tree before writing any SQL
- **One component at a time.** When writing SQL for component X, treat others as opaque interfaces
- **No ellipsis.** Every `sql` value must be complete, executable SQL
- **Frozen blocks are copy-paste.** Large CASE-WHEN lookups must be verbatim
- **Validate interfaces.** Verify every `consumes` reference exists in upstream `outputs`
- Only include components you **changed or added** — set unchanged components to `"change": "unchanged"` with `"sql": ""`
- `main_query` output columns must match the Column Completeness Contract above
- `reconstruction_order`: topological order of components for assembly

After the JSON, explain the mechanism:

```
Changes: <1-2 sentences: what structural change + the expected mechanism>
Expected speedup: <estimate>
```

Now output your Logic Tree and Component Payload JSON: