### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_range  [+]  Cost: low  Rows: 31  — Filter date_dim for May 1998 to get d_month_seq.
├── [CTE] store_sales_with_date  [+]  Cost: medium  Rows: 1.1M  — Filter store_sales for the next three month sequences after May 1998.
├── [CTE] my_customers  [~]  Cost: medium  Rows: 5,270  — Same semantic filter, now isolated as separate CTE.
├── [CTE] my_revenue  [~]  Cost: high  Rows: 4,605  — Now joins my_customers with store_sales_with_date and other dimensions.
├── [CTE] segments  [=]  Cost: low  Rows: ~1K  — Unchanged.
└── [MAIN] main_query  [=]  Cost: low  Rows: ~1K  — Unchanged.
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "prefetch_fact_join", "description": "Pre-filter date_dim into CTE, then pre-join with store_sales before multi-dimension join in my_revenue.", "applied_to": ["date_range", "store_sales_with_date"]},
    {"id": "R2", "type": "dimension_cte_isolate", "description": "Isolate my_customers as separate CTE with its own date_dim scan, enabling predicate pushdown and reuse.", "applied_to": ["my_customers"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_range": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_month_seq FROM date_dim WHERE d_year = 1998 AND d_moy = 5",
        "interfaces": {"outputs": ["d_month_seq"], "consumes": []}
      },
      "store_sales_with_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_customer_sk, ss_ext_sales_price, ss_sold_date_sk FROM store_sales INNER JOIN date_dim d ON store_sales.ss_sold_date_sk = d.d_date_sk WHERE d.d_month_seq BETWEEN (SELECT d_month_seq + 1 FROM date_range) AND (SELECT d_month_seq + 3 FROM date_range)",
        "interfaces": {"outputs": ["ss_customer_sk", "ss_ext_sales_price", "ss_sold_date_sk"], "consumes": ["date_range"]}
      },
      "my_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT c_customer_sk, c_current_addr_sk FROM (SELECT cs_sold_date_sk AS sold_date_sk, cs_bill_customer_sk AS customer_sk, cs_item_sk AS item_sk FROM catalog_sales UNION ALL SELECT ws_sold_date_sk AS sold_date_sk, ws_bill_customer_sk AS customer_sk, ws_item_sk AS item_sk FROM web_sales) cs_or_ws_sales INNER JOIN item ON cs_or_ws_sales.item_sk = item.i_item_sk INNER JOIN date_dim ON cs_or_ws_sales.sold_date_sk = date_dim.d_date_sk INNER JOIN customer ON cs_or_ws_sales.customer_sk = customer.c_customer_sk WHERE item.i_category = 'Women' AND item.i_class = 'maternity' AND date_dim.d_moy = 5 AND date_dim.d_year = 1998",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": []}
      },
      "my_revenue": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT my_customers.c_customer_sk, SUM(store_sales_with_date.ss_ext_sales_price) AS revenue FROM my_customers INNER JOIN store_sales_with_date ON my_customers.c_customer_sk = store_sales_with_date.ss_customer_sk INNER JOIN customer_address ON my_customers.c_current_addr_sk = customer_address.ca_address_sk INNER JOIN store ON (customer_address.ca_county = store.s_county AND customer_address.ca_state = store.s_state) GROUP BY my_customers.c_customer_sk",
        "interfaces": {"outputs": ["c_customer_sk", "revenue"], "consumes": ["my_customers", "store_sales_with_date"]}
      },
      "segments": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["segment"], "consumes": ["my_revenue"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["segment", "num_customers", "segment_base"], "consumes": ["segments"]}
      }
    },
    "reconstruction_order": ["date_range", "store_sales_with_date", "my_customers", "my_revenue", "segments", "main_query"],
    "assembly_template": "WITH date_range AS ({date_range}), store_sales_with_date AS ({store_sales_with_date}), my_customers AS ({my_customers}), my_revenue AS ({my_revenue}), segments AS ({segments}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Introduced date_range and store_sales_with_date CTEs to pre-filter and pre-join the date range condition with store_sales, reducing the fact table scan before the multi-dimension join in my_revenue. Isolated my_customers as a separate CTE with its own date_dim scan.

Expected speedup: ~2–4× due to reduced data movement and earlier predicate application. The largest table (store_sales) is filtered by date before joining with multiple dimensions.