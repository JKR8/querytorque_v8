## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] year_total  [-] — REMOVED entirely (replaced by specialized CTEs)
├── [+] date_filter  — New CTE filtering date_dim for years 1999,2000
│   └── SCAN (date_dim with d_year filter)
├── [~] store_agg  — Modified from original UNION branch to standalone CTE with single-pass aggregation
│   ├── SCAN (customer, store_sales, date_filter)
│   ├── JOIN (c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk)
│   ├── AGG (GROUP BY customer attributes with CASE WHEN d_year=1999/2000)
│   └── OUTPUT (c_customer_id, c_first_name, c_last_name, c_birth_country, year_total_1999, year_total_2000, 's')
├── [~] catalog_agg  — Modified from original UNION branch to standalone CTE with single-pass aggregation
│   ├── SCAN (customer, catalog_sales, date_filter)
│   ├── JOIN (c_customer_sk = cs_bill_customer_sk AND cs_sold_date_sk = d_date_sk)
│   ├── AGG (GROUP BY customer attributes with CASE WHEN d_year=1999/2000)
│   └── OUTPUT (c_customer_id, c_first_name, c_last_name, c_birth_country, year_total_1999, year_total_2000, 'c')
├── [~] web_agg  — Modified from original UNION branch to standalone CTE with single-pass aggregation
│   ├── SCAN (customer, web_sales, date_filter)
│   ├── JOIN (c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk)
│   ├── AGG (GROUP BY customer attributes with CASE WHEN d_year=1999/2000)
│   └── OUTPUT (c_customer_id, c_first_name, c_last_name, c_birth_country, year_total_1999, year_total_2000, 'w')
└── [~] main_query  — Modified from 6 self-joins to 3 CTE joins
    ├── SCAN (store_agg AS s, catalog_agg AS c, web_agg AS w)
    ├── JOIN (s.c_customer_id = c.c_customer_id AND s.c_customer_id = w.c_customer_id)
    ├── FILTER (year_total_1999 > 0 for all three AND catalog growth > store AND catalog growth > web)
    ├── SORT (customer_id, first_name, last_name, birth_country)
    └── OUTPUT (customer_id, customer_first_name, customer_last_name, customer_birth_country)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "single_pass_aggregation", "description": "Replace UNION CTE with separate per-channel CTEs that compute 1999 and 2000 totals in one pass using CASE aggregation", "applied_to": ["store_agg", "catalog_agg", "web_agg"]},
    {"id": "R2", "type": "date_filter_pushdown", "description": "Create shared date_filter CTE to push year filter into each channel scan", "applied_to": ["date_filter"]},
    {"id": "R3", "type": "union_cte_split", "description": "Eliminate original year_total CTE and replace with three specialized CTEs, then join directly", "applied_to": ["main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filter": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year IN (1999, 2000)",
        "interfaces": {"outputs": ["d_date_sk", "d_year"], "consumes": []}
      },
      "store_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c.c_customer_id, c.c_first_name, c.c_last_name, c.c_birth_country, SUM(CASE WHEN d.d_year = 1999 THEN ((ss_ext_list_price - ss_ext_wholesale_cost - ss_ext_discount_amt) + ss_ext_sales_price) / 2 END) AS year_total_1999, SUM(CASE WHEN d.d_year = 2000 THEN ((ss_ext_list_price - ss_ext_wholesale_cost - ss_ext_discount_amt) + ss_ext_sales_price) / 2 END) AS year_total_2000, 's' AS sale_type FROM customer c JOIN store_sales ss ON c.c_customer_sk = ss.ss_customer_sk JOIN date_filter d ON ss.ss_sold_date_sk = d.d_date_sk GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, c.c_birth_country",
        "interfaces": {"outputs": ["c_customer_id", "c_first_name", "c_last_name", "c_birth_country", "year_total_1999", "year_total_2000", "sale_type"], "consumes": ["date_filter"]}
      },
      "catalog_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c.c_customer_id, c.c_first_name, c.c_last_name, c.c_birth_country, SUM(CASE WHEN d.d_year = 1999 THEN ((cs_ext_list_price - cs_ext_wholesale_cost - cs_ext_discount_amt) + cs_ext_sales_price) / 2 END) AS year_total_1999, SUM(CASE WHEN d.d_year = 2000 THEN ((cs_ext_list_price - cs_ext_wholesale_cost - cs_ext_discount_amt) + cs_ext_sales_price) / 2 END) AS year_total_2000, 'c' AS sale_type FROM customer c JOIN catalog_sales cs ON c.c_customer_sk = cs.cs_bill_customer_sk JOIN date_filter d ON cs.cs_sold_date_sk = d.d_date_sk GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, c.c_birth_country",
        "interfaces": {"outputs": ["c_customer_id", "c_first_name", "c_last_name", "c_birth_country", "year_total_1999", "year_total_2000", "sale_type"], "consumes": ["date_filter"]}
      },
      "web_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c.c_customer_id, c.c_first_name, c.c_last_name, c.c_birth_country, SUM(CASE WHEN d.d_year = 1999 THEN ((ws_ext_list_price - ws_ext_wholesale_cost - ws_ext_discount_amt) + ws_ext_sales_price) / 2 END) AS year_total_1999, SUM(CASE WHEN d.d_year = 2000 THEN ((ws_ext_list_price - ws_ext_wholesale_cost - ws_ext_discount_amt) + ws_ext_sales_price) / 2 END) AS year_total_2000, 'w' AS sale_type FROM customer c JOIN web_sales ws ON c.c_customer_sk = ws.ws_bill_customer_sk JOIN date_filter d ON ws.ws_sold_date_sk = d.d_date_sk GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, c.c_birth_country",
        "interfaces": {"outputs": ["c_customer_id", "c_first_name", "c_last_name", "c_birth_country", "year_total_1999", "year_total_2000", "sale_type"], "consumes": ["date_filter"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT s.c_customer_id AS customer_id, s.c_first_name AS customer_first_name, s.c_last_name AS customer_last_name, s.c_birth_country AS customer_birth_country FROM store_agg s JOIN catalog_agg c ON s.c_customer_id = c.c_customer_id JOIN web_agg w ON s.c_customer_id = w.c_customer_id WHERE s.year_total_1999 > 0 AND c.year_total_1999 > 0 AND w.year_total_1999 > 0 AND (c.year_total_2000 / c.year_total_1999) > (s.year_total_2000 / s.year_total_1999) AND (c.year_total_2000 / c.year_total_1999) > (w.year_total_2000 / w.year_total_1999) ORDER BY s.c_customer_id, s.c_first_name, s.c_last_name, s.c_birth_country LIMIT 100",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_birth_country"], "consumes": ["store_agg", "catalog_agg", "web_agg"]}
      }
    },
    "reconstruction_order": ["date_filter", "store_agg", "catalog_agg", "web_agg", "main_query"],
    "assembly_template": "WITH date_filter AS ({date_filter}), store_agg AS ({store_agg}), catalog_agg AS ({catalog_agg}), web_agg AS ({web_agg}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Replaced the original UNION ALL CTE + 6 self-joins with separate per-channel CTEs that compute 1999 and 2000 totals in a single aggregation pass, then join the three CTEs directly. This reduces 6 scans of the same data (3 channels × 2 years) down to 3 scans total.

**Expected speedup**: ~3-4x (reduces data scans by half while eliminating the massive self-join explosion).