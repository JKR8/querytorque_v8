**Part 1: Modified Logic Tree**

```
QUERY: (single statement)
├── [+] date_cte [new] — Filter date_dim for years 1999-2000
│   ├── SCAN (date_dim)
│   ├── FILTER (d_year IN (1999,2000))
│   └── OUTPUT (d_date_sk, d_year)
├── [+] store_sales_cte [new] — Aggregate store sales with customer attributes
│   ├── SCAN (customer, store_sales)
│   ├── JOIN (c_customer_sk = ss_customer_sk)
│   ├── JOIN (ss_sold_date_sk = date_cte.d_date_sk)
│   ├── AGG (GROUP BY customer attrs + d_year)
│   └── OUTPUT (c_customer_id, c_first_name, ..., d_year, year_total, 's')
├── [+] catalog_sales_cte [new] — Aggregate catalog sales with customer attributes
│   ├── SCAN (customer, catalog_sales)
│   ├── JOIN (c_customer_sk = cs_bill_customer_sk)
│   ├── JOIN (cs_sold_date_sk = date_cte.d_date_sk)
│   ├── AGG (GROUP BY customer attrs + d_year)
│   └── OUTPUT (c_customer_id, c_first_name, ..., d_year, year_total, 'c')
├── [+] web_sales_cte [new] — Aggregate web sales with customer attributes
│   ├── SCAN (customer, web_sales)
│   ├── JOIN (c_customer_sk = ws_bill_customer_sk)
│   ├── JOIN (ws_sold_date_sk = date_cte.d_date_sk)
│   ├── AGG (GROUP BY customer attrs + d_year)
│   └── OUTPUT (c_customer_id, c_first_name, ..., d_year, year_total, 'w')
├── [~] year_total_cte [modified] — UNION ALL of three channel-specific CTEs
│   ├── UNION ALL (store_sales_cte, catalog_sales_cte, web_sales_cte)
│   └── OUTPUT (customer_id, customer_first_name, ..., dyear, year_total, sale_type)
└── [=] main_query [unchanged] — Self-join year_total_cte 6 times with filters
    ├── SCAN (year_total_cte AS t_s_firstyear, ..., year_total_cte AS t_w_secyear)
    ├── JOIN (5 equality joins on customer_id)
    ├── FILTER (15 filters on sale_type, dyear, year_total>0, growth ratios)
    ├── SORT (t_s_secyear.customer_id, customer_first_name, customer_last_name, customer_birth_country)
    └── OUTPUT (customer_id, customer_first_name, customer_last_name, customer_birth_country)
```

**Part 2: Component Payload JSON**

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "date_cte_isolate", "description": "Extract date_dim filter into reusable CTE for all three sales channels", "applied_to": ["date_cte"]},
    {"id": "R2", "type": "early_filter", "description": "Apply date filter before joining to large fact tables in each channel CTE", "applied_to": ["store_sales_cte", "catalog_sales_cte", "web_sales_cte"]},
    {"id": "R3", "type": "union_cte_split", "description": "Split original year_total CTE into three channel-specific CTEs before union", "applied_to": ["store_sales_cte", "catalog_sales_cte", "web_sales_cte", "year_total_cte"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year IN (1999, 2000)",
        "interfaces": {"outputs": ["d_date_sk", "d_year"], "consumes": []}
      },
      "store_sales_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, c.c_preferred_cust_flag AS customer_preferred_cust_flag, c.c_birth_country AS customer_birth_country, c.c_login AS customer_login, c.c_email_address AS customer_email_address, d.d_year AS dyear, SUM(((ss_ext_list_price-ss_ext_wholesale_cost-ss_ext_discount_amt)+ss_ext_sales_price)/2) AS year_total, 's' AS sale_type FROM customer c, store_sales ss, date_cte d WHERE c.c_customer_sk = ss.ss_customer_sk AND ss.ss_sold_date_sk = d.d_date_sk GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, c.c_preferred_cust_flag, c.c_birth_country, c.c_login, c.c_email_address, d.d_year",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_preferred_cust_flag", "customer_birth_country", "customer_login", "customer_email_address", "dyear", "year_total", "sale_type"], "consumes": ["date_cte"]}
      },
      "catalog_sales_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, c.c_preferred_cust_flag AS customer_preferred_cust_flag, c.c_birth_country AS customer_birth_country, c.c_login AS customer_login, c.c_email_address AS customer_email_address, d.d_year AS dyear, SUM(((cs_ext_list_price-cs_ext_wholesale_cost-cs_ext_discount_amt)+cs_ext_sales_price)/2) AS year_total, 'c' AS sale_type FROM customer c, catalog_sales cs, date_cte d WHERE c.c_customer_sk = cs.cs_bill_customer_sk AND cs.cs_sold_date_sk = d.d_date_sk GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, c.c_preferred_cust_flag, c.c_birth_country, c.c_login, c.c_email_address, d.d_year",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_preferred_cust_flag", "customer_birth_country", "customer_login", "customer_email_address", "dyear", "year_total", "sale_type"], "consumes": ["date_cte"]}
      },
      "web_sales_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, c.c_preferred_cust_flag AS customer_preferred_cust_flag, c.c_birth_country AS customer_birth_country, c.c_login AS customer_login, c.c_email_address AS customer_email_address, d.d_year AS dyear, SUM(((ws_ext_list_price-ws_ext_wholesale_cost-ws_ext_discount_amt)+ws_ext_sales_price)/2) AS year_total, 'w' AS sale_type FROM customer c, web_sales ws, date_cte d WHERE c.c_customer_sk = ws.ws_bill_customer_sk AND ws.ws_sold_date_sk = d.d_date_sk GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, c.c_preferred_cust_flag, c.c_birth_country, c.c_login, c.c_email_address, d.d_year",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_preferred_cust_flag", "customer_birth_country", "customer_login", "customer_email_address", "dyear", "year_total", "sale_type"], "consumes": ["date_cte"]}
      },
      "year_total_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT * FROM store_sales_cte UNION ALL SELECT * FROM catalog_sales_cte UNION ALL SELECT * FROM web_sales_cte",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_preferred_cust_flag", "customer_birth_country", "customer_login", "customer_email_address", "dyear", "year_total", "sale_type"], "consumes": ["store_sales_cte", "catalog_sales_cte", "web_sales_cte"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_birth_country"], "consumes": ["year_total_cte"]}
      }
    },
    "reconstruction_order": ["date_cte", "store_sales_cte", "catalog_sales_cte", "web_sales_cte", "year_total_cte", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), store_sales_cte AS ({store_sales_cte}), catalog_sales_cte AS ({catalog_sales_cte}), web_sales_cte AS ({web_sales_cte}), year_total_cte AS ({year_total_cte}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** The rewrite decomposes the original single UNION ALL CTE into three channel-specific CTEs that each pre-filter date_dim through a shared date_cte. This isolates the small date_dim scan (730 rows) and allows each channel to join with a tiny hash table, reducing the predicate evaluation overhead across 6 self-joins.

**Expected speedup:** 1.5-2.0x (moderate) due to eliminating redundant date_dim scans and predicate pushdown stopping at UNION boundaries. The main bottleneck remains the 6 self-joins on the ~958K row union.