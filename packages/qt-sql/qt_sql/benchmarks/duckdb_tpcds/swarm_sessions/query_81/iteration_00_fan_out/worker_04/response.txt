## Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] ca_customers [=]
├── [CTE] customer_total_return_all [~] 
│   ├── SCAN (catalog_returns, date_dim (join), customer_address (join))
│   ├── JOIN (cr_returned_date_sk = d_date_sk)
│   ├── JOIN (cr_returning_addr_sk = ca_address_sk)
│   ├── FILTER (d_year = 2002)
│   ├── AGG (GROUP BY cr_returning_customer_sk, ca_state)
│   └── OUTPUT (ctr_customer_sk, ctr_state, ctr_total_return)
├── [CTE] state_averages [+] 
│   ├── SCAN (customer_total_return_all)
│   ├── AGG (GROUP BY ctr_state)
│   └── OUTPUT (ctr_state, state_avg)
├── [CTE] ctr_joined [~] 
│   ├── SCAN (ca_customers, customer_total_return_all (join), state_averages (join))
│   ├── JOIN (c_customer_sk = ctr_customer_sk)
│   ├── JOIN (ctr_state = state_averages.ctr_state)
│   ├── OUTPUT (all ca_customers columns, ctr_total_return, state_avg, ctr_state)
│   └── No window function; uses joined state_averages
└── [MAIN] main_filter [~]
    ├── SCAN (ctr_joined)
    ├── FILTER (ctr_total_return > state_avg * 1.2)
    ├── ORDER BY (15 customer/address columns, ctr_total_return)
    └── OUTPUT (15 customer/address columns, ctr_total_return)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "hazard_fix",
      "description": "Fixed semantic break: state average must be computed over all customers, not just CA customers. Split original customer_total_return into two CTEs: one for all customer returns and one for state averages.",
      "applied_to": ["customer_total_return_all", "state_averages", "ctr_joined"]
    },
    {
      "id": "R2",
      "type": "early_filter",
      "description": "Filter CA customers first in ca_customers CTE before joining with returns data.",
      "applied_to": ["ca_customers"]
    },
    {
      "id": "R3",
      "type": "prefetch_fact_join",
      "description": "Create chain: filtered CA customers → join with pre-aggregated returns (customer_total_return_all) → join with state averages.",
      "applied_to": ["ctr_joined"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "ca_customers": {
          "type": "cte",
          "change": "unchanged",
          "sql": "SELECT c_customer_sk, c_customer_id, c_salutation, c_first_name, c_last_name, ca_address_sk, ca_street_number, ca_street_name, ca_street_type, ca_suite_number, ca_city, ca_county, ca_state, ca_zip, ca_country, ca_gmt_offset, ca_location_type FROM customer INNER JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE ca_state = 'CA'",
          "interfaces": {
            "outputs": ["c_customer_sk", "c_customer_id", "c_salutation", "c_first_name", "c_last_name", "ca_address_sk", "ca_street_number", "ca_street_name", "ca_street_type", "ca_suite_number", "ca_city", "ca_county", "ca_state", "ca_zip", "ca_country", "ca_gmt_offset", "ca_location_type"],
            "consumes": []
          }
        },
        "customer_total_return_all": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT cr_returning_customer_sk AS ctr_customer_sk, ca_state AS ctr_state, SUM(cr_return_amt_inc_tax) AS ctr_total_return FROM catalog_returns INNER JOIN date_dim ON cr_returned_date_sk = d_date_sk INNER JOIN customer_address ON cr_returning_addr_sk = ca_address_sk WHERE d_year = 2002 GROUP BY cr_returning_customer_sk, ca_state",
          "interfaces": {
            "outputs": ["ctr_customer_sk", "ctr_state", "ctr_total_return"],
            "consumes": []
          }
        },
        "state_averages": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT ctr_state, AVG(ctr_total_return) AS state_avg FROM customer_total_return_all GROUP BY ctr_state",
          "interfaces": {
            "outputs": ["ctr_state", "state_avg"],
            "consumes": ["customer_total_return_all"]
          }
        },
        "ctr_joined": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT cc.c_customer_sk, cc.c_customer_id, cc.c_salutation, cc.c_first_name, cc.c_last_name, cc.ca_street_number, cc.ca_street_name, cc.ca_street_type, cc.ca_suite_number, cc.ca_city, cc.ca_county, cc.ca_state, cc.ca_zip, cc.ca_country, cc.ca_gmt_offset, cc.ca_location_type, ctra.ctr_total_return, sa.state_avg, ctra.ctr_state FROM ca_customers cc INNER JOIN customer_total_return_all ctra ON cc.c_customer_sk = ctra.ctr_customer_sk INNER JOIN state_averages sa ON ctra.ctr_state = sa.ctr_state",
          "interfaces": {
            "outputs": ["c_customer_sk", "c_customer_id", "c_salutation", "c_first_name", "c_last_name", "ca_street_number", "ca_street_name", "ca_street_type", "ca_suite_number", "ca_city", "ca_county", "ca_state", "ca_zip", "ca_country", "ca_gmt_offset", "ca_location_type", "ctr_total_return", "state_avg", "ctr_state"],
            "consumes": ["ca_customers", "customer_total_return_all", "state_averages"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT c_customer_id, c_salutation, c_first_name, c_last_name, ca_street_number, ca_street_name, ca_street_type, ca_suite_number, ca_city, ca_county, ca_state, ca_zip, ca_country, ca_gmt_offset, ca_location_type, ctr_total_return FROM ctr_joined WHERE ctr_total_return > state_avg * 1.2 ORDER BY c_customer_id, c_salutation, c_first_name, c_last_name, ca_street_number, ca_street_name, ca_street_type, ca_suite_number, ca_city, ca_county, ca_state, ca_zip, ca_country, ca_gmt_offset, ca_location_type, ctr_total_return LIMIT 100",
          "interfaces": {
            "outputs": ["c_customer_id", "c_salutation", "c_first_name", "c_last_name", "ca_street_number", "ca_street_name", "ca_street_type", "ca_suite_number", "ca_city", "ca_county", "ca_state", "ca_zip", "ca_country", "ca_gmt_offset", "ca_location_type", "ctr_total_return"],
            "consumes": ["ctr_joined"]
          }
        }
      },
      "reconstruction_order": ["ca_customers", "customer_total_return_all", "state_averages", "ctr_joined", "main_query"],
      "assembly_template": "WITH ca_customers AS ({ca_customers}), customer_total_return_all AS ({customer_total_return_all}), state_averages AS ({state_averages}), ctr_joined AS ({ctr_joined}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Fixed semantic hazard by computing state averages over all customers (not just CA) using a separate `state_averages` CTE, then joining it with filtered CA customer returns. Maintains early filtering of CA customers while preserving correct average calculation.

**Expected speedup:** 2-3x from reduced window computation complexity and better predicate pushdown.