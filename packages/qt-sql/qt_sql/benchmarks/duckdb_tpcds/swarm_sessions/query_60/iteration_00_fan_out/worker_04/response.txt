## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_item  [+]
│   └── SCAN (item)
│       └── FILTER (i_category='Children')
├── [CTE] ss  [~]
│   ├── SCAN (store_sales, date_dim (join), customer_address (join), filtered_item (join))
│   ├── JOIN (ss_item_sk = i_item_sk)
│   ├── JOIN (ss_sold_date_sk = d_date_sk)
│   ├── JOIN (ss_addr_sk = ca_address_sk)
│   ├── FILTER (d_year=2000, d_moy=8, ca_gmt_offset=-7)
│   └── OUTPUT (i_item_id, ss_ext_sales_price AS total_sales)
├── [CTE] cs  [~]
│   ├── SCAN (catalog_sales, date_dim (join), customer_address (join), filtered_item (join))
│   ├── JOIN (cs_item_sk = i_item_sk)
│   ├── JOIN (cs_sold_date_sk = d_date_sk)
│   ├── JOIN (cs_bill_addr_sk = ca_address_sk)
│   ├── FILTER (d_year=2000, d_moy=8, ca_gmt_offset=-7)
│   └── OUTPUT (i_item_id, cs_ext_sales_price AS total_sales)
├── [CTE] ws  [~]
│   ├── SCAN (web_sales, date_dim (join), customer_address (join), filtered_item (join))
│   ├── JOIN (ws_item_sk = i_item_sk)
│   ├── JOIN (ws_sold_date_sk = d_date_sk)
│   ├── JOIN (ws_bill_addr_sk = ca_address_sk)
│   ├── FILTER (d_year=2000, d_moy=8, ca_gmt_offset=-7)
│   └── OUTPUT (i_item_id, ws_ext_sales_price AS total_sales)
├── [CTE] union_all  [=]
│   └── UNION ALL (ss, cs, ws)
└── [MAIN] main_query  [~]
    ├── SCAN (union_all)
    ├── AGG (GROUP BY i_item_id, SUM(total_sales))
    ├── SORT (i_item_id ASC, total_sales ASC)
    ├── LIMIT 100
    └── OUTPUT (i_item_id, total_sales)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter", "description": "Isolate filtered item dimension into CTE to avoid redundant scans and IN subqueries", "applied_to": ["filtered_item"]},
    {"id": "R2", "type": "dimension_cte_isolate", "description": "Replace item IN subqueries with direct JOINs to filtered_item CTE", "applied_to": ["ss", "cs", "ws"]},
    {"id": "R3", "type": "remove_redundant_aggregation", "description": "Remove per-channel aggregation (was in original) to match Target Logical Tree row expectations", "applied_to": ["ss", "cs", "ws"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_item": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, i_item_sk FROM item WHERE i_category = 'Children'",
        "interfaces": {"outputs": ["i_item_id", "i_item_sk"], "consumes": []}
      },
      "ss": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT fi.i_item_id, ss.ss_ext_sales_price AS total_sales FROM store_sales ss JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk AND d.d_year = 2000 AND d.d_moy = 8 JOIN customer_address ca ON ss.ss_addr_sk = ca.ca_address_sk AND ca.ca_gmt_offset = -7 JOIN filtered_item fi ON ss.ss_item_sk = fi.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["filtered_item"]}
      },
      "cs": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT fi.i_item_id, cs.cs_ext_sales_price AS total_sales FROM catalog_sales cs JOIN date_dim d ON cs.cs_sold_date_sk = d.d_date_sk AND d.d_year = 2000 AND d.d_moy = 8 JOIN customer_address ca ON cs.cs_bill_addr_sk = ca.ca_address_sk AND ca.ca_gmt_offset = -7 JOIN filtered_item fi ON cs.cs_item_sk = fi.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["filtered_item"]}
      },
      "ws": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT fi.i_item_id, ws.ws_ext_sales_price AS total_sales FROM web_sales ws JOIN date_dim d ON ws.ws_sold_date_sk = d.d_date_sk AND d.d_year = 2000 AND d.d_moy = 8 JOIN customer_address ca ON ws.ws_bill_addr_sk = ca.ca_address_sk AND ca.ca_gmt_offset = -7 JOIN filtered_item fi ON ws.ws_item_sk = fi.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["filtered_item"]}
      },
      "union_all": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, SUM(total_sales) AS total_sales FROM (SELECT i_item_id, total_sales FROM ss UNION ALL SELECT i_item_id, total_sales FROM cs UNION ALL SELECT i_item_id, total_sales FROM ws) AS union_all GROUP BY i_item_id ORDER BY i_item_id ASC, total_sales ASC LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["ss", "cs", "ws"]}
      }
    },
    "reconstruction_order": ["filtered_item", "ss", "cs", "ws", "main_query"],
    "assembly_template": "WITH filtered_item AS ({filtered_item}), ss AS ({ss}), cs AS ({cs}), ws AS ({ws}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Isolated the filtered item dimension into a CTE to eliminate redundant item table scans and IN subqueries, then joined directly in each channel CTE while preserving all original filters inline. Removed per-channel aggregation to match Target Logical Tree expectations (outputting individual sales rows rather than pre-aggregated totals).

**Expected speedup**: ~2-3x from eliminating 5 redundant item table scans and converting semi-joins to direct hash joins. The filtered_item CTE (~10K rows) creates a small hash table for efficient probing across all three channels.