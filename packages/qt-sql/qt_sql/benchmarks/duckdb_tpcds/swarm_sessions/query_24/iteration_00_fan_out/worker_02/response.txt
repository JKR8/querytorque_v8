### Part 1: Modified Logic Tree

```
QUERY (single statement)
├── [CTE] ssales_all  [+]  New base CTE grouping all colors
│   ├── SCAN (store_sales, store_returns, store, item, customer, customer_address)
│   ├── JOIN (ss_ticket_number = sr_ticket_number)
│   ├── JOIN (ss_item_sk = sr_item_sk)
│   ├── JOIN (ss_customer_sk = c_customer_sk)
│   ├── JOIN (ss_item_sk = i_item_sk)
│   ├── JOIN (ss_store_sk = s_store_sk)
│   ├── JOIN (c_current_addr_sk = ca_address_sk)
│   ├── FILTER (c_birth_country <> UPPER(ca_country))
│   ├── FILTER (s_zip = ca_zip)
│   ├── FILTER (s_market_id = 8)
│   ├── AGG (GROUP BY c_last_name, c_first_name, s_store_name, ca_state, s_state, i_color, i_current_price, i_manager_id, i_units, i_size)
│   └── OUTPUT (c_last_name, c_first_name, s_store_name, ca_state, s_state, i_color, i_current_price, i_manager_id, i_units, i_size, netpaid)
├── [CTE] threshold_cte  [+]  Decouple correlated subquery
│   ├── SCAN (ssales_all)
│   ├── AGG (0.05 * AVG(netpaid))
│   └── OUTPUT (threshold)
├── [CTE] ssales_beige  [+]  Filter to beige only
│   ├── SCAN (ssales_all)
│   ├── FILTER (i_color = 'beige')
│   └── OUTPUT (c_last_name, c_first_name, s_store_name, ca_state, s_state, i_color, i_current_price, i_manager_id, i_units, i_size, netpaid)
├── [MAIN] final_beige  [~]  Replace correlated subquery with CROSS JOIN
│   ├── SCAN (ssales_beige)
│   ├── CROSS JOIN (threshold_cte)
│   ├── AGG (GROUP BY c_last_name, c_first_name, s_store_name, threshold)
│   ├── FILTER/HAVING (SUM(netpaid) > threshold)
│   ├── SORT (c_last_name, c_first_name, s_store_name)
│   └── OUTPUT (c_last_name, c_first_name, s_store_name, paid)
├── [CTE] ssales_blue  [+]  Filter to blue only
│   ├── SCAN (ssales_all)
│   ├── FILTER (i_color = 'blue')
│   └── OUTPUT (c_last_name, c_first_name, s_store_name, ca_state, s_state, i_color, i_current_price, i_manager_id, i_units, i_size, netpaid)
└── [MAIN] final_blue  [~]  Replace correlated subquery with CROSS JOIN
    ├── SCAN (ssales_blue)
    ├── CROSS JOIN (threshold_cte)
    ├── AGG (GROUP BY c_last_name, c_first_name, s_store_name, threshold)
    ├── FILTER/HAVING (SUM(netpaid) > threshold)
    ├── SORT (c_last_name, c_first_name, s_store_name)
    └── OUTPUT (c_last_name, c_first_name, s_store_name, paid)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "decorrelate",
      "description": "Extract correlated HAVING subquery into standalone threshold_cte, then CROSS JOIN",
      "applied_to": ["threshold_cte", "final_beige", "final_blue"]
    },
    {
      "id": "R2",
      "type": "materialize_cte",
      "description": "Create shared base CTE (ssales_all) for all consumers, eliminating redundant base table scans",
      "applied_to": ["ssales_all"]
    },
    {
      "id": "R3",
      "type": "union_cte_split",
      "description": "Split original UNION pattern into parallel color-specific CTEs (ssales_beige, ssales_blue), eliminating generic CTE",
      "applied_to": ["ssales_beige", "ssales_blue"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "ssales_all": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT c_last_name, c_first_name, s_store_name, ca_state, s_state, i_color, i_current_price, i_manager_id, i_units, i_size, SUM(ss_net_profit) AS netpaid FROM store_sales JOIN store_returns ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk JOIN store ON ss_store_sk = s_store_sk JOIN item ON ss_item_sk = i_item_sk JOIN customer ON ss_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE c_birth_country <> UPPER(ca_country) AND s_zip = ca_zip AND s_market_id = 8 GROUP BY c_last_name, c_first_name, s_store_name, ca_state, s_state, i_color, i_current_price, i_manager_id, i_units, i_size",
          "interfaces": {
            "outputs": ["c_last_name", "c_first_name", "s_store_name", "ca_state", "s_state", "i_color", "i_current_price", "i_manager_id", "i_units", "i_size", "netpaid"],
            "consumes": []
          }
        },
        "threshold_cte": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT 0.05 * AVG(netpaid) AS threshold FROM ssales_all",
          "interfaces": {
            "outputs": ["threshold"],
            "consumes": ["ssales_all"]
          }
        },
        "ssales_beige": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT c_last_name, c_first_name, s_store_name, ca_state, s_state, i_color, i_current_price, i_manager_id, i_units, i_size, netpaid FROM ssales_all WHERE i_color = 'beige'",
          "interfaces": {
            "outputs": ["c_last_name", "c_first_name", "s_store_name", "ca_state", "s_state", "i_color", "i_current_price", "i_manager_id", "i_units", "i_size", "netpaid"],
            "consumes": ["ssales_all"]
          }
        },
        "ssales_blue": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT c_last_name, c_first_name, s_store_name, ca_state, s_state, i_color, i_current_price, i_manager_id, i_units, i_size, netpaid FROM ssales_all WHERE i_color = 'blue'",
          "interfaces": {
            "outputs": ["c_last_name", "c_first_name", "s_store_name", "ca_state", "s_state", "i_color", "i_current_price", "i_manager_id", "i_units", "i_size", "netpaid"],
            "consumes": ["ssales_all"]
          }
        },
        "final_beige": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT c_last_name, c_first_name, s_store_name, SUM(netpaid) AS paid FROM ssales_beige CROSS JOIN threshold_cte GROUP BY c_last_name, c_first_name, s_store_name, threshold HAVING SUM(netpaid) > threshold ORDER BY c_last_name, c_first_name, s_store_name",
          "interfaces": {
            "outputs": ["c_last_name", "c_first_name", "s_store_name", "paid"],
            "consumes": ["ssales_beige", "threshold_cte"]
          }
        },
        "final_blue": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT c_last_name, c_first_name, s_store_name, SUM(netpaid) AS paid FROM ssales_blue CROSS JOIN threshold_cte GROUP BY c_last_name, c_first_name, s_store_name, threshold HAVING SUM(netpaid) > threshold ORDER BY c_last_name, c_first_name, s_store_name",
          "interfaces": {
            "outputs": ["c_last_name", "c_first_name", "s_store_name", "paid"],
            "consumes": ["ssales_blue", "threshold_cte"]
          }
        }
      },
      "reconstruction_order": ["ssales_all", "threshold_cte", "ssales_beige", "ssales_blue", "final_beige", "final_blue"],
      "assembly_template": "WITH ssales_all AS ({ssales_all}), threshold_cte AS ({threshold_cte}), ssales_beige AS ({ssales_beige}), ssales_blue AS ({ssales_blue}) {final_beige}; WITH ssales_all AS ({ssales_all}), threshold_cte AS ({threshold_cte}), ssales_beige AS ({ssales_beige}), ssales_blue AS ({ssales_blue}) {final_blue};"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Decorrelated the HAVING subquery into a shared threshold CTE, materialized the base aggregation once for all color branches, and split the original UNION pattern into parallel color-specific CTEs. This eliminates redundant base table scans and removes the correlated execution penalty.

**Expected speedup:** 2.5-3x (eliminates 2x base table scans + decorrelation overhead)