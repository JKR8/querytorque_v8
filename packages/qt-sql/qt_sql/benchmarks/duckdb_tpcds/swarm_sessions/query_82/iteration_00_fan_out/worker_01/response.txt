## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [~] MAIN: main_query
│   ├── [+] WITH filtered_item AS (SELECT ...)
│   ├── [+] WITH inventory_date_exists AS (SELECT ...)
│   ├── [+] WITH store_sales_exists AS (SELECT ...)
│   └── [+] final_select (FROM store_sales_exists)
└── NODE HIERARCHY:
    ├── filtered_item [=]
    ├── inventory_date_exists [~] (changed from multi-join to correlated EXISTS)
    ├── store_sales_exists [~] (changed from INNER JOIN to correlated EXISTS)
    └── final_select [=]
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "correlated_exists", "description": "Replace INNER JOIN inventory/date_dim with EXISTS subquery to enable semi-join optimization", "applied_to": ["inventory_date_exists"]},
    {"id": "R2", "type": "correlated_exists", "description": "Replace INNER JOIN store_sales with EXISTS subquery to prevent row inflation before GROUP BY", "applied_to": ["store_sales_exists"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk, i_item_id, i_item_desc, i_current_price FROM item WHERE i_current_price BETWEEN 17 AND 47 AND i_manufact_id IN (639, 169, 138, 339)",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_current_price"], "consumes": []}
      },
      "inventory_date_exists": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk, i_item_id, i_item_desc, i_current_price FROM filtered_item WHERE EXISTS (SELECT 1 FROM inventory JOIN date_dim ON inv_date_sk = d_date_sk WHERE inv_item_sk = filtered_item.i_item_sk AND d_date BETWEEN CAST('1999-07-09' AS DATE) AND (CAST('1999-07-09' AS DATE) + INTERVAL 60 DAY) AND inv_quantity_on_hand BETWEEN 100 AND 500)",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_current_price"], "consumes": ["filtered_item"]}
      },
      "store_sales_exists": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_id, i_item_desc, i_current_price FROM inventory_date_exists WHERE EXISTS (SELECT 1 FROM store_sales WHERE ss_item_sk = inventory_date_exists.i_item_sk)",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "i_current_price"], "consumes": ["inventory_date_exists"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, i_current_price FROM store_sales_exists GROUP BY i_item_id, i_item_desc, i_current_price ORDER BY i_item_id LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "i_current_price"], "consumes": ["store_sales_exists"]}
      }
    },
    "reconstruction_order": ["filtered_item", "inventory_date_exists", "store_sales_exists", "main_query"],
    "assembly_template": "WITH filtered_item AS ({filtered_item}), inventory_date_exists AS ({inventory_date_exists}), store_sales_exists AS ({store_sales_exists}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Replaced original multi-way INNER JOIN with sequential correlated EXISTS subqueries following the target logical tree. This enables DuckDB to use efficient semi-joins (avoiding row inflation from many-to-many relationships) while preserving exact semantic equivalence.

**Expected speedup**: 1.5-2x due to elimination of unnecessary joins before filtering and reduced intermediate result sizes. The EXISTS pattern allows early exit on first match and avoids materializing full join results.