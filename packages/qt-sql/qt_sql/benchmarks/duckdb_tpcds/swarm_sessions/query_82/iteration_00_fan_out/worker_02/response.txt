## Modified Logic Tree

```
QUERY:
└── [MAIN] main_query [~]
    ├── [~] CTE dim_item [=]
    │   ├── SCAN item
    │   ├── FILTER i_current_price BETWEEN 17 AND 17+30
    │   └── FILTER i_manufact_id IN (639,169,138,339)
    ├── [+] CTE dim_inventory_date [=]
    │   ├── SCAN inventory
    │   ├── SCAN date_dim
    │   ├── JOIN inventory.inv_date_sk = date_dim.d_date_sk
    │   ├── FILTER d_date BETWEEN CAST('1999-07-09' AS DATE) AND (CAST('1999-07-09' AS DATE) + INTERVAL 60 DAY)
    │   └── FILTER inv_quantity_on_hand BETWEEN 100 AND 500
    ├── [~] CTE prefetched_fact [=]
    │   ├── JOIN dim_inventory_date.inv_item_sk = dim_item.i_item_sk
    │   └── JOIN store_sales.ss_item_sk = dim_item.i_item_sk
    └── [~] final_aggregation [=]
        ├── AGG GROUP BY i_item_id, i_item_desc, i_current_price
        ├── SORT i_item_id ASC
        └── LIMIT 100
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter item and inventory+date dimensions into separate CTEs before fact join", "applied_to": ["dim_item", "dim_inventory_date"]},
    {"id": "R2", "type": "prefetch_fact_join", "description": "Build CTE chain that progressively reduces data before final grouping", "applied_to": ["prefetched_fact"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "dim_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_id, i_item_desc, i_current_price FROM item WHERE i_current_price BETWEEN 17 AND 17+30 AND i_manufact_id IN (639,169,138,339)",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_current_price"], "consumes": []}
      },
      "dim_inventory_date": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT inv_item_sk FROM inventory JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_date BETWEEN CAST('1999-07-09' AS DATE) AND (CAST('1999-07-09' AS DATE) + INTERVAL 60 DAY) AND inv_quantity_on_hand BETWEEN 100 AND 500",
        "interfaces": {"outputs": ["inv_item_sk"], "consumes": []}
      },
      "prefetched_fact": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT di.i_item_id, di.i_item_desc, di.i_current_price FROM dim_inventory_date did JOIN dim_item di ON did.inv_item_sk = di.i_item_sk JOIN store_sales ss ON ss.ss_item_sk = di.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "i_current_price"], "consumes": ["dim_item", "dim_inventory_date"]}
      },
      "final_aggregation": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, i_current_price FROM prefetched_fact GROUP BY i_item_id, i_item_desc, i_current_price ORDER BY i_item_id LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "i_current_price"], "consumes": ["prefetched_fact"]}
      }
    },
    "reconstruction_order": ["dim_item", "dim_inventory_date", "prefetched_fact", "final_aggregation"],
    "assembly_template": "WITH dim_item AS ({dim_item}), dim_inventory_date AS ({dim_inventory_date}), prefetched_fact AS ({prefetched_fact}) {final_aggregation}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Isolated dimension filters into separate CTEs (item and inventory+date) before joining with store_sales, creating a progressive reduction pipeline that minimizes data before the many-to-many fact join. This follows the dimension_cte_isolate and prefetch_fact_join patterns.

**Expected speedup**: 1.5-3x from early filtering and reduced join cardinality.