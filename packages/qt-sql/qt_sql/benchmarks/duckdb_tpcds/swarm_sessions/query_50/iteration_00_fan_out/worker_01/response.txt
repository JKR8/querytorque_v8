### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [MAIN] main_query
│   ├── [~] WITH d2_filtered (CTE)
│   │   └── SCAN date_dim → filtered to d_year=2001, d_moy=8
│   ├── [~] WITH returns_filtered (CTE)
│   │   └── JOIN store_returns ⋈ d2_filtered (sr_returned_date_sk = d_date_sk)
│   ├── [~] WITH d1_all (CTE)
│   │   └── SCAN date_dim (full)
│   ├── [~] WITH store_all (CTE)
│   │   └── SCAN store (full)
│   ├── [~] WITH sales_returns (CTE)
│   │   └── JOIN store_sales ⋈ returns_filtered ⋈ d1_all
│   │       ├── store_sales ⇔ returns_filtered (ticket, item, customer)
│   │       └── store_sales ⇔ d1_all (ss_sold_date_sk = d_date_sk)
│   ├── [~] WITH aggregation (CTE)
│   │   └── JOIN sales_returns ⋈ store_all
│   │       └── AGGREGATE (group by store attributes) → compute 5 buckets
│   └── [~] sort_limit
│       ├── FROM aggregation
│       ├── ORDER BY (store attributes)
│       └── LIMIT 100
└── OUTPUT (15 columns exactly as in Column Completeness Contract)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "multi_date_cte", "description": "Split date_dim aliases into separate CTEs: filtered for d2, unfiltered for d1", "applied_to": ["d2_filtered", "d1_all"]},
    {"id": "R2", "type": "early_fact_filter", "description": "Pre-join store_returns with filtered d2 to reduce rows before main fact join", "applied_to": ["returns_filtered"]},
    {"id": "R3", "type": "isolated_store_scan", "description": "Separate store dimension into standalone CTE to allow join order flexibility", "applied_to": ["store_all"]},
    {"id": "R4", "type": "fact_join_cte", "description": "Create sales_returns CTE joining store_sales with filtered returns and d1 date dimension", "applied_to": ["sales_returns"]},
    {"id": "R5", "type": "aggregation_cte", "description": "Aggregate in separate CTE before final sort/limit", "applied_to": ["aggregation"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "d2_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_moy = 8",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "returns_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT sr_ticket_number, sr_item_sk, sr_customer_sk, sr_returned_date_sk FROM store_returns JOIN d2_filtered ON sr_returned_date_sk = d2_filtered.d_date_sk",
        "interfaces": {"outputs": ["sr_ticket_number", "sr_item_sk", "sr_customer_sk", "sr_returned_date_sk"], "consumes": ["d2_filtered"]}
      },
      "d1_all": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_all": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk, s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip FROM store",
        "interfaces": {"outputs": ["s_store_sk", "s_store_name", "s_company_id", "s_street_number", "s_street_name", "s_street_type", "s_suite_number", "s_city", "s_county", "s_state", "s_zip"], "consumes": []}
      },
      "sales_returns": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_store_sk, ss_sold_date_sk, sr_returned_date_sk FROM store_sales JOIN returns_filtered ON ss_ticket_number = sr_ticket_number AND ss_item_sk = sr_item_sk AND ss_customer_sk = sr_customer_sk JOIN d1_all ON ss_sold_date_sk = d1_all.d_date_sk",
        "interfaces": {"outputs": ["ss_store_sk", "ss_sold_date_sk", "sr_returned_date_sk"], "consumes": ["returns_filtered", "d1_all"]}
      },
      "aggregation": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip, SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk <= 30) THEN 1 ELSE 0 END) AS \"30 days\", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 30 AND sr_returned_date_sk - ss_sold_date_sk <= 60) THEN 1 ELSE 0 END) AS \"31-60 days\", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 60 AND sr_returned_date_sk - ss_sold_date_sk <= 90) THEN 1 ELSE 0 END) AS \"61-90 days\", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 90 AND sr_returned_date_sk - ss_sold_date_sk <= 120) THEN 1 ELSE 0 END) AS \"91-120 days\", SUM(CASE WHEN (sr_returned_date_sk - ss_sold_date_sk > 120) THEN 1 ELSE 0 END) AS \">120 days\" FROM sales_returns JOIN store_all ON ss_store_sk = s_store_sk GROUP BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip",
        "interfaces": {"outputs": ["s_store_name", "s_company_id", "s_street_number", "s_street_name", "s_street_type", "s_suite_number", "s_city", "s_county", "s_state", "s_zip", "30 days", "31-60 days", "61-90 days", "91-120 days", ">120 days"], "consumes": ["sales_returns", "store_all"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT * FROM aggregation ORDER BY s_store_name, s_company_id, s_street_number, s_street_name, s_street_type, s_suite_number, s_city, s_county, s_state, s_zip LIMIT 100",
        "interfaces": {"outputs": ["s_store_name", "s_company_id", "s_street_number", "s_street_name", "s_street_type", "s_suite_number", "s_city", "s_county", "s_state", "s_zip", "30 days", "31-60 days", "61-90 days", "91-120 days", ">120 days"], "consumes": ["aggregation"]}
      }
    },
    "reconstruction_order": ["d2_filtered", "returns_filtered", "d1_all", "store_all", "sales_returns", "aggregation", "main_query"],
    "assembly_template": "WITH d2_filtered AS ({d2_filtered}), returns_filtered AS ({returns_filtered}), d1_all AS ({d1_all}), store_all AS ({store_all}), sales_returns AS ({sales_returns}), aggregation AS ({aggregation}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured the original implicit join into explicit CTEs that isolate each date dimension scan and filter, allowing DuckDB's optimizer to push predicates independently and reduce rows before the large fact-table join.

**Expected speedup:** ~2x-3x due to early filtering of store_returns via d2_filtered CTE (reduces from ~29K rows) and columnar projection in each CTE.