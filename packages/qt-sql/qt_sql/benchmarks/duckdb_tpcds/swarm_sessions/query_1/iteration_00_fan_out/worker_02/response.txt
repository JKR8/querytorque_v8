## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] customer_total_return  [=]
│   ├── SCAN (store_returns, date_dim (join))
│   ├── JOIN (sr_returned_date_sk = d_date_sk)
│   ├── FILTER (d_year = 2000)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (ctr_customer_sk, ctr_store_sk, ctr_total_return)
├── [CTE] store_averages  [+]
│   ├── SCAN (customer_total_return)
│   ├── AGG (GROUP BY ctr_store_sk)
│   └── OUTPUT (ctr_store_sk, store_avg_return)
├── [CTE] main_join  [+]
│   ├── SCAN (customer_total_return AS ctr1 (join), store (join), store_averages (join))
│   ├── JOIN (s_store_sk = ctr1.ctr_store_sk AND ctr1.ctr_store_sk = store_averages.ctr_store_sk)
│   ├── FILTER (s_state = 'SD' AND ctr1.ctr_total_return > store_avg_return * 1.2)
│   └── OUTPUT (ctr_customer_sk)
├── [CTE] customer  [+]
│   ├── SCAN (main_join, customer (join))
│   ├── JOIN (ctr_customer_sk = c_customer_sk)
│   └── OUTPUT (c_customer_id)
└── [MAIN] limit  [+]
    ├── SCAN (customer)
    ├── SORT (c_customer_id ASC)
    ├── LIMIT (100)
    └── OUTPUT (c_customer_id)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "decorrelate",
      "description": "Convert correlated subquery to separate CTE with GROUP BY, then JOIN",
      "applied_to": ["store_averages", "main_join"]
    },
    {
      "id": "R2",
      "type": "materialize_cte",
      "description": "Extract repeated subquery pattern (store average) into reusable CTE",
      "applied_to": ["store_averages"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "customer_total_return": {
          "type": "cte",
          "change": "unchanged",
          "sql": "",
          "interfaces": {
            "outputs": ["ctr_customer_sk", "ctr_store_sk", "ctr_total_return"],
            "consumes": []
          }
        },
        "store_averages": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT ctr_store_sk, AVG(ctr_total_return) AS store_avg_return FROM customer_total_return GROUP BY ctr_store_sk",
          "interfaces": {
            "outputs": ["ctr_store_sk", "store_avg_return"],
            "consumes": ["customer_total_return"]
          }
        },
        "main_join": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT ctr1.ctr_customer_sk FROM customer_total_return ctr1 JOIN store ON s_store_sk = ctr1.ctr_store_sk JOIN store_averages ON ctr1.ctr_store_sk = store_averages.ctr_store_sk WHERE s_state = 'SD' AND ctr1.ctr_total_return > store_averages.store_avg_return * 1.2",
          "interfaces": {
            "outputs": ["ctr_customer_sk"],
            "consumes": ["customer_total_return", "store_averages"]
          }
        },
        "customer": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT c_customer_id FROM main_join JOIN customer ON ctr_customer_sk = c_customer_sk",
          "interfaces": {
            "outputs": ["c_customer_id"],
            "consumes": ["main_join"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT c_customer_id FROM customer ORDER BY c_customer_id ASC LIMIT 100",
          "interfaces": {
            "outputs": ["c_customer_id"],
            "consumes": ["customer"]
          }
        }
      },
      "reconstruction_order": ["customer_total_return", "store_averages", "main_join", "customer", "main_query"],
      "assembly_template": "WITH customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(SR_FEE) AS ctr_total_return FROM store_returns, date_dim WHERE sr_returned_date_sk = d_date_sk AND d_year = 2000 GROUP BY sr_customer_sk, sr_store_sk), store_averages AS ({store_averages}), main_join AS ({main_join}), customer AS ({customer}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Decorrelated the original subquery by extracting store averages into a separate CTE, then joining it with customer returns and store filter in main_join. This eliminates the per-row correlated subquery execution.

Expected speedup: ~2-3x based on decorrelation pattern from reference examples.