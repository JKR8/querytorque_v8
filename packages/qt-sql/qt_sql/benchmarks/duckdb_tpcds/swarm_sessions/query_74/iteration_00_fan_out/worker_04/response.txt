## Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_filter  [+]
│   ├── SCAN (date_dim)
│   ├── FILTER (d_year IN (1999, 2000))
│   └── OUTPUT (d_date_sk, d_year)
├── [CTE] customer_store  [+]
│   ├── SCAN (customer, store_sales, date_filter)
│   ├── JOIN (c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk)
│   ├── AGG (GROUP BY c_customer_sk, c_customer_id, c_first_name, c_last_name)
│   └── OUTPUT (c_customer_sk, c_customer_id, c_first_name, c_last_name)
├── [CTE] store_agg  [+]
│   ├── SCAN (customer_store, store_sales, date_filter)
│   ├── JOIN (c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk)
│   ├── AGG (GROUP BY c_customer_id, c_first_name, c_last_name, d_year)
│   ├── AGG FUNCTION (STDDEV_SAMP(ss_net_paid) AS year_total)
│   └── OUTPUT (customer_id, customer_first_name, customer_last_name, year, year_total, sale_type)
├── [CTE] customer_web  [+]
│   ├── SCAN (customer, web_sales, date_filter)
│   ├── JOIN (c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk)
│   ├── AGG (GROUP BY c_customer_sk, c_customer_id, c_first_name, c_last_name)
│   └── OUTPUT (c_customer_sk, c_customer_id, c_first_name, c_last_name)
├── [CTE] web_agg  [+]
│   ├── SCAN (customer_web, web_sales, date_filter)
│   ├── JOIN (c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk)
│   ├── AGG (GROUP BY c_customer_id, c_first_name, c_last_name, d_year)
│   ├── AGG FUNCTION (STDDEV_SAMP(ws_net_paid) AS year_total)
│   └── OUTPUT (customer_id, customer_first_name, customer_last_name, year, year_total, sale_type)
├── [CTE] year_total  [-]
│   └── REMOVED: Original UNION CTE eliminated; replaced by specialized store_agg and web_agg CTEs
└── [MAIN] main_query  [~]
    ├── SCAN (store_agg AS s1999, store_agg AS s2000, web_agg AS w1999, web_agg AS w2000)
    ├── JOIN (s1999.customer_id = s2000.customer_id = w1999.customer_id = w2000.customer_id)
    ├── FILTER (s1999.year=1999 AND s2000.year=2000 AND w1999.year=1999 AND w2000.year=2000)
    ├── FILTER (s1999.year_total > 0 AND w1999.year_total > 0)
    ├── FILTER (w2000.year_total/w1999.year_total > s2000.year_total/s1999.year_total)
    ├── SORT (customer_first_name, customer_id, customer_last_name)
    └── OUTPUT (customer_id, customer_first_name, customer_last_name)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "union_cte_split", "description": "Split original UNION CTE into separate store_agg and web_agg CTEs by channel", "applied_to": ["store_agg", "web_agg"]},
    {"id": "R2", "type": "prefetch_fact_join", "description": "Add date_filter CTE and staged customer filtering CTEs to reduce fact table scans", "applied_to": ["date_filter", "customer_store", "customer_web"]},
    {"id": "R3", "type": "single_pass_aggregation", "description": "Consolidate per-year aggregates into single GROUP BY with d_year dimension", "applied_to": ["store_agg", "web_agg"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filter": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year IN (1999, 2000)",
        "interfaces": {"outputs": ["d_date_sk", "d_year"], "consumes": []}
      },
      "customer_store": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c.c_customer_sk, c.c_customer_id, c.c_first_name, c.c_last_name FROM customer c JOIN store_sales ss ON c.c_customer_sk = ss.ss_customer_sk JOIN date_filter d ON ss.ss_sold_date_sk = d.d_date_sk GROUP BY c.c_customer_sk, c.c_customer_id, c.c_first_name, c.c_last_name",
        "interfaces": {"outputs": ["c_customer_sk", "c_customer_id", "c_first_name", "c_last_name"], "consumes": ["date_filter"]}
      },
      "store_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cs.c_customer_id AS customer_id, cs.c_first_name AS customer_first_name, cs.c_last_name AS customer_last_name, d.d_year AS year, STDDEV_SAMP(ss.ss_net_paid) AS year_total, 's' AS sale_type FROM customer_store cs JOIN store_sales ss ON cs.c_customer_sk = ss.ss_customer_sk JOIN date_filter d ON ss.ss_sold_date_sk = d.d_date_sk GROUP BY cs.c_customer_id, cs.c_first_name, cs.c_last_name, d.d_year",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "year", "year_total", "sale_type"], "consumes": ["customer_store", "date_filter"]}
      },
      "customer_web": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c.c_customer_sk, c.c_customer_id, c.c_first_name, c.c_last_name FROM customer c JOIN web_sales ws ON c.c_customer_sk = ws.ws_bill_customer_sk JOIN date_filter d ON ws.ws_sold_date_sk = d.d_date_sk GROUP BY c.c_customer_sk, c.c_customer_id, c.c_first_name, c.c_last_name",
        "interfaces": {"outputs": ["c_customer_sk", "c_customer_id", "c_first_name", "c_last_name"], "consumes": ["date_filter"]}
      },
      "web_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cw.c_customer_id AS customer_id, cw.c_first_name AS customer_first_name, cw.c_last_name AS customer_last_name, d.d_year AS year, STDDEV_SAMP(ws.ws_net_paid) AS year_total, 'w' AS sale_type FROM customer_web cw JOIN web_sales ws ON cw.c_customer_sk = ws.ws_bill_customer_sk JOIN date_filter d ON ws.ws_sold_date_sk = d.d_date_sk GROUP BY cw.c_customer_id, cw.c_first_name, cw.c_last_name, d.d_year",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "year", "year_total", "sale_type"], "consumes": ["customer_web", "date_filter"]}
      },
      "year_total": {
        "type": "cte",
        "change": "removed",
        "sql": "",
        "interfaces": {"outputs": [], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT s2000.customer_id, s2000.customer_first_name, s2000.customer_last_name FROM store_agg s1999, store_agg s2000, web_agg w1999, web_agg w2000 WHERE s1999.customer_id = s2000.customer_id AND s1999.customer_id = w1999.customer_id AND s1999.customer_id = w2000.customer_id AND s1999.year = 1999 AND s2000.year = 2000 AND w1999.year = 1999 AND w2000.year = 2000 AND s1999.year_total > 0 AND w1999.year_total > 0 AND (w2000.year_total / w1999.year_total) > (s2000.year_total / s1999.year_total) ORDER BY s2000.customer_first_name ASC, s2000.customer_id ASC, s2000.customer_last_name ASC LIMIT 100",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name"], "consumes": ["store_agg", "web_agg"]}
      }
    },
    "reconstruction_order": ["date_filter", "customer_store", "store_agg", "customer_web", "web_agg", "main_query"],
    "assembly_template": "WITH date_filter AS ({date_filter}), customer_store AS ({customer_store}), store_agg AS ({store_agg}), customer_web AS ({customer_web}), web_agg AS ({web_agg}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

## Changes and Expected Speedup

**Changes:** Split original UNION CTE into separate channel-specific CTEs with staged filtering (customer pre-filtering + date pre-filtering) and consolidated per-year aggregates in single passes. Eliminated 4 self-joins of the generic UNION CTE, replacing with specialized CTEs that are each scanned exactly once.

**Expected speedup:** ~1.5-2x due to elimination of redundant fact table scans and predicate pushdown to specialized CTEs. Each fact table is now scanned only twice (once for customer filtering, once for aggregation) instead of 4 times via UNION CTE self-joins.