## Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] year_total  [-]
├── [CTE] store_agg  [+]  — Compute per-customer yearly standard deviation for store sales in 1999 and 2000.
│   ├── SCAN (customer, store_sales, date_dim)
│   ├── JOIN (c_customer_sk = ss_customer_sk, ss_sold_date_sk = d_date_sk)
│   ├── FILTER (d_year IN (1999, 2000))
│   ├── AGG (GROUP BY c_customer_id, c_first_name, c_last_name, d_year)
│   └── OUTPUT (customer_id, customer_first_name, customer_last_name, year, year_total, sale_type)
├── [CTE] web_agg  [+]  — Compute per-customer yearly standard deviation for web sales in 1999 and 2000.
│   ├── SCAN (customer, web_sales, date_dim)
│   ├── JOIN (c_customer_sk = ws_bill_customer_sk, ws_sold_date_sk = d_date_sk)
│   ├── FILTER (d_year IN (1999, 2000))
│   ├── AGG (GROUP BY c_customer_id, c_first_name, c_last_name, d_year)
│   └── OUTPUT (customer_id, customer_first_name, customer_last_name, year, year_total, sale_type)
└── [MAIN] main_query  [~]  — Self-join customer/channel/year variability rows from separate CTEs.
    ├── SCAN (store_agg AS s1999, store_agg AS s2000, web_agg AS w1999, web_agg AS w2000)
    ├── JOIN (s1999.customer_id = s2000.customer_id = w1999.customer_id = w2000.customer_id)
    ├── FILTER (year=1999/2000, sale_type='s'/'w', year_total>0, ratio comparison)
    ├── SORT (customer_first_name ASC, customer_id ASC, customer_last_name ASC)
    └── OUTPUT (customer_id, customer_first_name, customer_last_name)
```

**Changes:**
- `[-]` Removed original `year_total` CTE that unioned store and web sales
- `[+]` Added `store_agg` CTE computing STDDEV_SAMP per customer/year for store sales only
- `[+]` Added `web_agg` CTE computing STDDEV_SAMP per customer/year for web sales only  
- `[~]` Modified main query to join the four specific filtered CTE instances directly

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "union_cte_split",
      "description": "Split the UNION ALL year_total CTE into separate store_agg and web_agg CTEs to eliminate redundant materialization of the unioned result",
      "applied_to": ["year_total"]
    },
    {
      "id": "R2", 
      "type": "single_pass_aggregation",
      "description": "Consolidate multiple year scans (1999, 2000) into single GROUP BY with d_year column for each channel CTE",
      "applied_to": ["store_agg", "web_agg"]
    },
    {
      "id": "R3",
      "type": "cross_cte_predicate_pushdown",
      "description": "Move year and channel filters from main query WHERE clause into CTE definitions, but preserve year filter in CTE (IN (1999,2000)) for single-pass aggregation",
      "applied_to": ["store_agg", "web_agg"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "store_agg": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_id AS customer_id,\n       c.c_first_name AS customer_first_name,\n       c.c_last_name AS customer_last_name,\n       d.d_year AS year,\n       STDDEV_SAMP(ss.ss_net_paid) AS year_total,\n       's' AS sale_type\nFROM customer c\nJOIN store_sales ss ON c.c_customer_sk = ss.ss_customer_sk\nJOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk\nWHERE d.d_year IN (1999, 2000)\nGROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, d.d_year",
        "interfaces": {
          "outputs": ["customer_id", "customer_first_name", "customer_last_name", "year", "year_total", "sale_type"],
          "consumes": []
        }
      },
      "web_agg": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_id AS customer_id,\n       c.c_first_name AS customer_first_name,\n       c.c_last_name AS customer_last_name,\n       d.d_year AS year,\n       STDDEV_SAMP(ws.ws_net_paid) AS year_total,\n       'w' AS sale_type\nFROM customer c\nJOIN web_sales ws ON c.c_customer_sk = ws.ws_bill_customer_sk\nJOIN date_dim d ON ws.ws_sold_date_sk = d.d_date_sk\nWHERE d.d_year IN (1999, 2000)\nGROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, d.d_year",
        "interfaces": {
          "outputs": ["customer_id", "customer_first_name", "customer_last_name", "year", "year_total", "sale_type"],
          "consumes": []
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT s2000.customer_id,\n       s2000.customer_first_name,\n       s2000.customer_last_name\nFROM store_agg s1999\nJOIN store_agg s2000 ON s1999.customer_id = s2000.customer_id\nJOIN web_agg w1999 ON s1999.customer_id = w1999.customer_id\nJOIN web_agg w2000 ON s1999.customer_id = w2000.customer_id\nWHERE s1999.year = 1999 AND s1999.sale_type = 's'\n  AND s2000.year = 2000 AND s2000.sale_type = 's'\n  AND w1999.year = 1999 AND w1999.sale_type = 'w'\n  AND w2000.year = 2000 AND w2000.sale_type = 'w'\n  AND s1999.year_total > 0\n  AND w1999.year_total > 0\n  AND (w2000.year_total / w1999.year_total) > (s2000.year_total / s1999.year_total)\nORDER BY s2000.customer_first_name ASC,\n         s2000.customer_id ASC,\n         s2000.customer_last_name ASC\nLIMIT 100",
        "interfaces": {
          "outputs": ["customer_id", "customer_first_name", "customer_last_name"],
          "consumes": ["store_agg", "web_agg"]
        }
      }
    },
    "reconstruction_order": ["store_agg", "web_agg", "main_query"],
    "assembly_template": "WITH store_agg AS ({store_agg}),\n     web_agg AS ({web_agg})\n{main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** The rewrite splits the original UNION ALL CTE into separate channel-specific CTEs (store_agg and web_agg) that each compute STDDEV_SAMP per customer/year in a single pass. The main query joins four filtered instances of these CTEs directly. This eliminates the redundant materialization of the unioned result and allows predicate pushdown to each channel's fact table scan.

**Expected speedup:** ~4-5x due to eliminating redundant UNION materialization and enabling predicate pushdown to separate channel tables.