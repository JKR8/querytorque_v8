## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [!] date_filter  [+]
│   ├── SCAN (date_dim)
│   ├── FILTER (d_year IN (1999,2000))
│   └── OUTPUT (d_date_sk, d_year)
├── [!] store_1999   [+]
│   ├── SCAN (customer, store_sales, date_filter)
│   ├── JOIN (c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk)
│   ├── FILTER (d_year = 1999)
│   ├── AGG (GROUP BY c_customer_id, c_first_name, c_last_name)
│   └── OUTPUT (customer_id, customer_first_name, customer_last_name, year=1999, year_total, sale_type='s')
├── [!] store_2000   [+]
│   ├── SCAN (customer, store_sales, date_filter)
│   ├── JOIN (c_customer_sk = ss_customer_sk AND ss_sold_date_sk = d_date_sk)
│   ├── FILTER (d_year = 2000)
│   ├── AGG (GROUP BY c_customer_id, c_first_name, c_last_name)
│   └── OUTPUT (customer_id, customer_first_name, customer_last_name, year=2000, year_total, sale_type='s')
├── [!] web_1999     [+]
│   ├── SCAN (customer, web_sales, date_filter)
│   ├── JOIN (c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk)
│   ├── FILTER (d_year = 1999)
│   ├── AGG (GROUP BY c_customer_id, c_first_name, c_last_name)
│   └── OUTPUT (customer_id, customer_first_name, customer_last_name, year=1999, year_total, sale_type='w')
├── [!] web_2000     [+]
│   ├── SCAN (customer, web_sales, date_filter)
│   ├── JOIN (c_customer_sk = ws_bill_customer_sk AND ws_sold_date_sk = d_date_sk)
│   ├── FILTER (d_year = 2000)
│   ├── AGG (GROUP BY c_customer_id, c_first_name, c_last_name)
│   └── OUTPUT (customer_id, customer_first_name, customer_last_name, year=2000, year_total, sale_type='w')
├── [-] year_total   [-]
└── [~] main_query   [!]
    ├── SCAN (store_1999 AS s99, store_2000 AS s00, web_1999 AS w99, web_2000 AS w00)
    ├── JOIN (s99.customer_id = s00.customer_id AND s99.customer_id = w99.customer_id AND s99.customer_id = w00.customer_id)
    ├── FILTER (s99.year_total > 0 AND w99.year_total > 0)
    ├── FILTER ((w00.year_total / w99.year_total) > (s00.year_total / s99.year_total))
    ├── SORT (customer_first_name ASC, customer_id ASC, customer_last_name ASC)
    └── OUTPUT (customer_id, customer_first_name, customer_last_name)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_specialization",
      "description": "Split generic year_total CTE into 4 specialized CTEs (store_1999, store_2000, web_1999, web_2000) with embedded year filters",
      "applied_to": ["date_filter", "store_1999", "store_2000", "web_1999", "web_2000", "main_query"]
    },
    {
      "id": "R2",
      "type": "redundant_scan_elimination",
      "description": "Remove original year_total CTE entirely to avoid redundant materialization",
      "applied_to": ["year_total"]
    },
    {
      "id": "R3",
      "type": "early_selection",
      "description": "Create date_filter CTE to reduce rows before joins with fact tables",
      "applied_to": ["date_filter"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "date_filter": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year IN (1999, 2000)",
          "interfaces": {
            "outputs": ["d_date_sk", "d_year"],
            "consumes": []
          }
        },
        "store_1999": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, 1999 AS year, STDDEV_SAMP(ss.ss_net_paid) AS year_total, 's' AS sale_type FROM customer c INNER JOIN store_sales ss ON c.c_customer_sk = ss.ss_customer_sk INNER JOIN date_filter d ON ss.ss_sold_date_sk = d.d_date_sk WHERE d.d_year = 1999 GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name",
          "interfaces": {
            "outputs": ["customer_id", "customer_first_name", "customer_last_name", "year", "year_total", "sale_type"],
            "consumes": ["date_filter"]
          }
        },
        "store_2000": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, 2000 AS year, STDDEV_SAMP(ss.ss_net_paid) AS year_total, 's' AS sale_type FROM customer c INNER JOIN store_sales ss ON c.c_customer_sk = ss.ss_customer_sk INNER JOIN date_filter d ON ss.ss_sold_date_sk = d.d_date_sk WHERE d.d_year = 2000 GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name",
          "interfaces": {
            "outputs": ["customer_id", "customer_first_name", "customer_last_name", "year", "year_total", "sale_type"],
            "consumes": ["date_filter"]
          }
        },
        "web_1999": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, 1999 AS year, STDDEV_SAMP(ws.ws_net_paid) AS year_total, 'w' AS sale_type FROM customer c INNER JOIN web_sales ws ON c.c_customer_sk = ws.ws_bill_customer_sk INNER JOIN date_filter d ON ws.ws_sold_date_sk = d.d_date_sk WHERE d.d_year = 1999 GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name",
          "interfaces": {
            "outputs": ["customer_id", "customer_first_name", "customer_last_name", "year", "year_total", "sale_type"],
            "consumes": ["date_filter"]
          }
        },
        "web_2000": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, 2000 AS year, STDDEV_SAMP(ws.ws_net_paid) AS year_total, 'w' AS sale_type FROM customer c INNER JOIN web_sales ws ON c.c_customer_sk = ws.ws_bill_customer_sk INNER JOIN date_filter d ON ws.ws_sold_date_sk = d.d_date_sk WHERE d.d_year = 2000 GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name",
          "interfaces": {
            "outputs": ["customer_id", "customer_first_name", "customer_last_name", "year", "year_total", "sale_type"],
            "consumes": ["date_filter"]
          }
        },
        "year_total": {
          "type": "cte",
          "change": "removed",
          "sql": "",
          "interfaces": {
            "outputs": [],
            "consumes": []
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT s00.customer_id, s00.customer_first_name, s00.customer_last_name FROM store_1999 s99 INNER JOIN store_2000 s00 ON s99.customer_id = s00.customer_id INNER JOIN web_1999 w99 ON s99.customer_id = w99.customer_id INNER JOIN web_2000 w00 ON s99.customer_id = w00.customer_id WHERE s99.year_total > 0 AND w99.year_total > 0 AND (w00.year_total / w99.year_total) > (s00.year_total / s99.year_total) ORDER BY s00.customer_first_name ASC, s00.customer_id ASC, s00.customer_last_name ASC LIMIT 100",
          "interfaces": {
            "outputs": ["customer_id", "customer_first_name", "customer_last_name"],
            "consumes": ["store_1999", "store_2000", "web_1999", "web_2000"]
          }
        }
      },
      "reconstruction_order": ["date_filter", "store_1999", "store_2000", "web_1999", "web_2000", "main_query"],
      "assembly_template": "WITH date_filter AS ({date_filter}), store_1999 AS ({store_1999}), store_2000 AS ({store_2000}), web_1999 AS ({web_1999}), web_2000 AS ({web_2000}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Split the generic `year_total` CTE into four specialized CTEs (store_1999, store_2000, web_1999, web_2000) with embedded year filters, removed the original union CTE entirely, and added a shared `date_filter` CTE for early selection.

**Expected speedup**: ~2.35x (based on multi_date_range_cte pattern). Each fact table (store_sales, web_sales) now scans only its required year's data once per channel-year combination, eliminating redundant scans through the generic CTE.