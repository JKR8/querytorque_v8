<reasoning>
1. CLASSIFY: This is a multi-channel UNION ALL CTE (store and web) scanned 4 times (store 1999, store 2000, web 1999, web 2000) with self-joins to compare year-over-year variability ratios. It's a channel-comparison self-join with repeated fact scans.

2. EXPLAIN PLAN ANALYSIS:
   - Total runtime: 3537ms
   - Largest cost: HASH_JOIN INNER on customer+store_sales (2 instances: 598.3ms + 601.4ms = ~1200ms) and HASH_JOIN INNER on customer+web_sales (2 instances: 141.3ms + 149.4ms = ~290ms). These are the fact table joins.
   - Store_sales scanned twice (5.5M rows each, 206.9ms + 218.6ms = ~425ms total)
   - Web_sales scanned twice (1.4M rows each, 40.9ms + 44.1ms = ~85ms total)
   - Date_dim scanned 4 times (~365 rows each, minimal time)
   - Customer scanned 4 times (500K rows each, ~30ms each = ~120ms total)
   - Aggregations: store channel group bys take ~380ms + ~360ms = ~740ms, web channel group bys take ~120ms + ~101ms = ~221ms
   - Main query joins are cheap (~20ms each)
   - Row count drops:
     * Store_sales: 5.5M rows → 5.4M after join with customer → 308K after group by
     * Web_sales: 1.4M rows → 1.4M after join with customer → 107K after group by
   - The optimizer already pushes year filters into date_dim scans (d_year=1999/d_year=2000) and uses hash joins. It does NOT consolidate the repeated scans of store_sales and web_sales - each year is scanned separately.
   - CTE appears to be inlined (not materialized once) since we see separate scans for each reference.

3. GAP MATCHING:
   - REDUNDANT_SCAN_ELIMINATION: Present. Store_sales scanned twice, web_sales scanned twice.
   - CROSS_CTE_PREDICATE_BLINDNESS: Present. Year filters are inside CTE but same fact table scanned multiple times.
   - UNION_CTE_SELF_JOIN_DECOMPOSITION: Present. Generic CTE (year_total) scanned 4 times with different year/channel filters.
   - No correlated subqueries (no CORRELATED_SUBQUERY_PARALYSIS)
   - No OR conditions (no CROSS_COLUMN_OR_DECOMPOSITION)

4. AGGREGATION TRAP CHECK:
   - STDDEV_SAMP is grouping-sensitive. Grouping by (customer, year) ensures each year's stddev is computed over only that year's rows.
   - If we consolidate scans using CASE/conditional aggregation, we must still compute stddev per year. STDDEV_SAMP with FILTER (WHERE year=1999) over a combined (1999,2000) group is NOT equivalent. However, we can GROUP BY customer, year and then pivot - that's safe because GROUP BY includes year.

5. TRANSFORM SELECTION (ranked by expected value):
   a) Single-pass aggregation (scan_consolidation_pivot): Merge store_sales scans for 1999+2000 into one pass, same for web_sales. Expected high value (reduces 2 store_sales scans to 1, 2 web_sales scans to 1).
   b) Union CTE split (self_join_elimination): Split year_total into 4 specialized CTEs (store_1999, store_2000, web_1999, web_2000). Expected medium value (eliminates discriminator filters).
   c) Star join prefetch (multi_dimension_prefetch): Pre-filter date_dim and customer into CTEs, then join with fact tables. Expected medium value.
   d) Exploration: Novel combination of single-pass aggregation with early customer filtering.

6. LOGICAL TREE DESIGN:
   For each strategy, design CTEs with exhaustive output columns.
   Check CTE_COLUMN_COMPLETENESS: Each CTE must output all columns needed by consumers.
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
Find customers whose year-over-year increase in web-payment variability (1999→2000) exceeds their store-payment variability increase. INNER JOIN semantics require customers to have both store and web sales in both years with positive variability. STDDEV_SAMP requires ≥2 non-NULL values per (customer, year, channel) group; changing group membership breaks equivalence. Filter dependencies: year=1999 and year=2000 filters must stay with their respective aggregates; positive year_total checks must remain after aggregation.

BOTTLENECK_DIAGNOSIS:
Scan-bound: 4 separate fact table scans (store_sales 2×, web_sales 2×) dominate runtime (~510ms of 3537ms). Cardinality: store_sales scans 5.5M rows each → 308K after aggregation; web_sales scans 1.4M rows each → 107K after aggregation. The optimizer already pushes year filters into date_dim scans and uses efficient hash joins, but misses consolidation of repeated fact scans. Logical-tree costs (50% each) are misleading—actual bottleneck is redundant I/O.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output customer_id, customer_first_name, customer_last_name in same order.
- CTE_COLUMN_COMPLETENESS: Any new CTE must include all columns referenced downstream (customer_id, first_name, last_name, year, sale_type, year_total).
- LITERAL_PRESERVATION: Must preserve literal values 1999, 2000, 's', 'w'.
- SEMANTIC_EQUIVALENCE: Row count and ordering must match exactly.
- REDUNDANT_SCAN_ELIMINATION: Store_sales and web_sales scanned twice each (EXPLAIN shows separate SEQ_SCAN nodes).
- UNION_CTE_SELF_JOIN_DECOMPOSITION: Generic year_total CTE scanned 4 times with different year/channel filters (EXPLAIN shows separate expansions).
- CROSS_CTE_PREDICATE_BLINDNESS: Year filters inside CTE cause repeated scans (EXPLAIN shows same fact table scanned multiple times).

REGRESSION_WARNINGS:
1. union_cte_split (0.68x on Q74):
   CAUSE: Created year-specific CTEs but kept original UNION CTE, causing redundant materialization and cardinality errors.
   RULE: When splitting UNION CTE by year, REMOVE the original union CTE entirely.
2. pushdown (0.49x on Q31):
   CAUSE: Created filtered AND original versions of same aggregations, doubling materialization.
   RULE: When creating filtered CTEs, remove unfiltered originals used in same self-join.

=== WORKER 1 BRIEFING ===

STRATEGY: single_pass_aggregation
TARGET_LOGICAL_TREE:
  store_agg -> web_agg -> main_join
NODE_CONTRACTS:
  store_agg:
    FROM: customer c, store_sales ss, date_dim d
    JOIN: c.c_customer_sk = ss.ss_customer_sk AND ss.ss_sold_date_sk = d.d_date_sk
    WHERE: d.d_year IN (1999, 2000)
    GROUP BY: c.c_customer_id, c.c_first_name, c.c_last_name, d.d_year
    AGGREGATE: STDDEV_SAMP(ss.ss_net_paid) AS year_total
    OUTPUT: c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, year_total, 's' AS sale_type
    EXPECTED_ROWS: ~616K (308K per year combined)
    CONSUMERS: main_join
  web_agg:
    FROM: customer c, web_sales ws, date_dim d
    JOIN: c.c_customer_sk = ws.ws_bill_customer_sk AND ws.ws_sold_date_sk = d.d_date_sk
    WHERE: d.d_year IN (1999, 2000)
    GROUP BY: c.c_customer_id, c.c_first_name, c.c_last_name, d.d_year
    AGGREGATE: STDDEV_SAMP(ws.ws_net_paid) AS year_total
    OUTPUT: c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, year_total, 'w' AS sale_type
    EXPECTED_ROWS: ~214K (107K per year combined)
    CONSUMERS: main_join
  main_join:
    FROM: store_agg s1999, store_agg s2000, web_agg w1999, web_agg w2000
    JOIN: s1999.customer_id = s2000.customer_id AND s1999.customer_id = w1999.customer_id AND s1999.customer_id = w2000.customer_id
    WHERE: s1999.year = 1999 AND s1999.sale_type = 's' AND s2000.year = 2000 AND s2000.sale_type = 's'
          AND w1999.year = 1999 AND w1999.sale_type = 'w' AND w2000.year = 2000 AND w2000.sale_type = 'w'
          AND s1999.year_total > 0 AND w1999.year_total > 0
          AND (w2000.year_total / w1999.year_total) > (s2000.year_total / s1999.year_total)
    ORDER BY: customer_first_name ASC, customer_id ASC, customer_last_name ASC
    LIMIT: 100
    OUTPUT: s2000.customer_id, s2000.customer_first_name, s2000.customer_last_name
    EXPECTED_ROWS: ≤100
    CONSUMERS: final output
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Apply consolidation of multiple year scans into single GROUP BY with year column; ignore the CASE aggregation pattern because we need per-year STDDEV_SAMP.
- channel_bitmap_aggregation: Apply single scan per channel for both years; ignore bitmap technique as we use regular GROUP BY.
HAZARD_FLAGS:
- Must ensure GROUP BY includes d_year so STDDEV_SAMP is computed per-year.
- The main_join must filter to specific years after aggregation (cannot use conditional aggregation for ratios).

=== WORKER 2 BRIEFING ===

STRATEGY: union_cte_split
TARGET_LOGICAL_TREE:
  date_filter -> store_1999 -> store_2000 -> web_1999 -> web_2000 -> main_join
NODE_CONTRACTS:
  date_filter:
    FROM: date_dim
    WHERE: d_year IN (1999, 2000)
    OUTPUT: d_date_sk, d_year
    EXPECTED_ROWS: ~730
    CONSUMERS: store_1999, store_2000, web_1999, web_2000
  store_1999:
    FROM: customer c, store_sales ss, date_filter d
    JOIN: c.c_customer_sk = ss.ss_customer_sk AND ss.ss_sold_date_sk = d.d_date_sk
    WHERE: d.d_year = 1999
    GROUP BY: c.c_customer_id, c.c_first_name, c.c_last_name
    AGGREGATE: STDDEV_SAMP(ss.ss_net_paid) AS year_total
    OUTPUT: c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, 1999 AS year, year_total, 's' AS sale_type
    EXPECTED_ROWS: ~308K
    CONSUMERS: main_join
  store_2000:
    FROM: customer c, store_sales ss, date_filter d
    JOIN: c.c_customer_sk = ss.ss_customer_sk AND ss.ss_sold_date_sk = d.d_date_sk
    WHERE: d.d_year = 2000
    GROUP BY: c.c_customer_id, c.c_first_name, c.c_last_name
    AGGREGATE: STDDEV_SAMP(ss.ss_net_paid) AS year_total
    OUTPUT: c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, 2000 AS year, year_total, 's' AS sale_type
    EXPECTED_ROWS: ~308K
    CONSUMERS: main_join
  web_1999:
    FROM: customer c, web_sales ws, date_filter d
    JOIN: c.c_customer_sk = ws.ws_bill_customer_sk AND ws.ws_sold_date_sk = d.d_date_sk
    WHERE: d.d_year = 1999
    GROUP BY: c.c_customer_id, c.c_first_name, c.c_last_name
    AGGREGATE: STDDEV_SAMP(ws.ws_net_paid) AS year_total
    OUTPUT: c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, 1999 AS year, year_total, 'w' AS sale_type
    EXPECTED_ROWS: ~107K
    CONSUMERS: main_join
  web_2000:
    FROM: customer c, web_sales ws, date_filter d
    JOIN: c.c_customer_sk = ws.ws_bill_customer_sk AND ws.ws_sold_date_sk = d.d_date_sk
    WHERE: d.d_year = 2000
    GROUP BY: c.c_customer_id, c.c_first_name, c.c_last_name
    AGGREGATE: STDDEV_SAMP(ws.ws_net_paid) AS year_total
    OUTPUT: c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, 2000 AS year, year_total, 'w' AS sale_type
    EXPECTED_ROWS: ~107K
    CONSUMERS: main_join
  main_join:
    FROM: store_1999 s99, store_2000 s00, web_1999 w99, web_2000 w00
    JOIN: s99.customer_id = s00.customer_id AND s99.customer_id = w99.customer_id AND s99.customer_id = w00.customer_id
    WHERE: s99.year_total > 0 AND w99.year_total > 0
          AND (w00.year_total / w99.year_total) > (s00.year_total / s99.year_total)
    ORDER BY: s00.customer_first_name ASC, s00.customer_id ASC, s00.customer_last_name ASC
    LIMIT: 100
    OUTPUT: s00.customer_id, s00.customer_first_name, s00.customer_last_name
    EXPECTED_ROWS: ≤100
    CONSUMERS: final output
EXAMPLES: union_cte_split, multi_date_range_cte
EXAMPLE_ADAPTATION:
- union_cte_split: Split generic CTE into year/channel-specific CTEs; ignore the union aspect as we create separate CTEs not a union.
- multi_date_range_cte: Create separate date-filtered CTEs for each year; apply to both store and web channels.
HAZARD_FLAGS:
- Must remove original year_total CTE entirely to avoid redundant scans.
- Each specialized CTE must include all output columns (including year literal).

=== WORKER 3 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  date_filter -> customer_filter -> store_fact -> store_agg -> web_fact -> web_agg -> main_join
NODE_CONTRACTS:
  date_filter:
    FROM: date_dim
    WHERE: d_year IN (1999, 2000)
    OUTPUT: d_date_sk, d_year
    EXPECTED_ROWS: ~730
    CONSUMERS: store_fact, web_fact
  customer_filter:
    FROM: customer
    WHERE: EXISTS (SELECT 1 FROM store_sales WHERE ss_customer_sk = c_customer_sk AND ss_sold_date_sk IN (SELECT d_date_sk FROM date_filter))
       OR EXISTS (SELECT 1 FROM web_sales WHERE ws_bill_customer_sk = c_customer_sk AND ws_sold_date_sk IN (SELECT d_date_sk FROM date_filter))
    OUTPUT: c_customer_sk, c_customer_id, c_first_name, c_last_name
    EXPECTED_ROWS: ≤500K (reduced by semi-join)
    CONSUMERS: store_fact, web_fact
  store_fact:
    FROM: customer_filter c, store_sales ss, date_filter d
    JOIN: c.c_customer_sk = ss.ss_customer_sk AND ss.ss_sold_date_sk = d.d_date_sk
    OUTPUT: c.c_customer_id, c.c_first_name, c.c_last_name, d.d_year, ss.ss_net_paid
    EXPECTED_ROWS: ≤5.4M (reduced by pre-filtered customer)
    CONSUMERS: store_agg
  store_agg:
    FROM: store_fact
    GROUP BY: customer_id, customer_first_name, customer_last_name, d_year
    AGGREGATE: STDDEV_SAMP(ss_net_paid) AS year_total
    OUTPUT: customer_id, customer_first_name, customer_last_name, d_year AS year, year_total, 's' AS sale_type
    EXPECTED_ROWS: ≤616K
    CONSUMERS: main_join
  web_fact:
    FROM: customer_filter c, web_sales ws, date_filter d
    JOIN: c.c_customer_sk = ws.ws_bill_customer_sk AND ws.ws_sold_date_sk = d.d_date_sk
    OUTPUT: c.c_customer_id, c.c_first_name, c.c_last_name, d.d_year, ws.ws_net_paid
    EXPECTED_ROWS: ≤1.4M (reduced by pre-filtered customer)
    CONSUMERS: web_agg
  web_agg:
    FROM: web_fact
    GROUP BY: customer_id, customer_first_name, customer_last_name, d_year
    AGGREGATE: STDDEV_SAMP(ws_net_paid) AS year_total
    OUTPUT: customer_id, customer_first_name, customer_last_name, d_year AS year, year_total, 'w' AS sale_type
    EXPECTED_ROWS: ≤214K
    CONSUMERS: main_join
  main_join:
    FROM: store_agg s1999, store_agg s2000, web_agg w1999, web_agg w2000
    JOIN: s1999.customer_id = s2000.customer_id AND s1999.customer_id = w1999.customer_id AND s1999.customer_id = w2000.customer_id
    WHERE: s1999.year = 1999 AND s2000.year = 2000 AND w1999.year = 1999 AND w2000.year = 2000
          AND s1999.year_total > 0 AND w1999.year_total > 0
          AND (w2000.year_total / w1999.year_total) > (s2000.year_total / s1999.year_total)
    ORDER BY: s2000.customer_first_name ASC, s2000.customer_id ASC, s2000.customer_last_name ASC
    LIMIT: 100
    OUTPUT: s2000.customer_id, s2000.customer_first_name, s2000.customer_last_name
    EXPECTED_ROWS: ≤100
    CONSUMERS: final output
EXAMPLES: prefetch_fact_join, multi_dimension_prefetch, dimension_cte_isolate
EXAMPLE_ADAPTATION:
- prefetch_fact_join: Filter date_dim first, then pre-join with fact tables; apply to both store and web.
- multi_dimension_prefetch: Pre-filter both date_dim and customer; ignore the fact that customer filter uses semi-joins.
- dimension_cte_isolate: Isolate date_dim and customer into CTEs; ensure customer CTE has WHERE clause (semi-join).
HAZARD_FLAGS:
- Semi-joins in customer_filter may force full scans of store_sales/web_sales if not optimized.
- Must ensure customer_filter includes all needed columns (c_customer_sk, c_customer_id, c_first_name, c_last_name).

=== WORKER 4 BRIEFING ===

STRATEGY: compound_single_pass_early_customer
TARGET_LOGICAL_TREE:
  date_filter -> customer_store -> store_agg -> customer_web -> web_agg -> main_join
NODE_CONTRACTS:
  date_filter:
    FROM: date_dim
    WHERE: d_year IN (1999, 2000)
    OUTPUT: d_date_sk, d_year
    EXPECTED_ROWS: ~730
    CONSUMERS: customer_store, customer_web, store_agg, web_agg
  customer_store:
    FROM: customer c, store_sales ss, date_filter d
    JOIN: c.c_customer_sk = ss.ss_customer_sk AND ss.ss_sold_date_sk = d.d_date_sk
    GROUP BY: c.c_customer_sk, c.c_customer_id, c.c_first_name, c.c_last_name
    OUTPUT: c_customer_sk, c_customer_id, c_first_name, c_last_name
    EXPECTED_ROWS: ≤500K (customers with store sales in 1999/2000)
    CONSUMERS: store_agg
  store_agg:
    FROM: customer_store c, store_sales ss, date_filter d
    JOIN: c.c_customer_sk = ss.ss_customer_sk AND ss.ss_sold_date_sk = d.d_date_sk
    GROUP BY: c.c_customer_id, c.c_first_name, c.c_last_name, d.d_year
    AGGREGATE: STDDEV_SAMP(ss.ss_net_paid) AS year_total
    OUTPUT: c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, year_total, 's' AS sale_type
    EXPECTED_ROWS: ≤616K
    CONSUMERS: main_join
  customer_web:
    FROM: customer c, web_sales ws, date_filter d
    JOIN: c.c_customer_sk = ws.ws_bill_customer_sk AND ws.ws_sold_date_sk = d.d_date_sk
    GROUP BY: c.c_customer_sk, c.c_customer_id, c.c_first_name, c.c_last_name
    OUTPUT: c_customer_sk, c_customer_id, c_first_name, c_last_name
    EXPECTED_ROWS: ≤500K (customers with web sales in 1999/2000)
    CONSUMERS: web_agg
  web_agg:
    FROM: customer_web c, web_sales ws, date_filter d
    JOIN: c.c_customer_sk = ws.ws_bill_customer_sk AND ws.ws_sold_date_sk = d.d_date_sk
    GROUP BY: c.c_customer_id, c.c_first_name, c.c_last_name, d.d_year
    AGGREGATE: STDDEV_SAMP(ws.ws_net_paid) AS year_total
    OUTPUT: c_customer_id AS customer_id, c_first_name AS customer_first_name, c_last_name AS customer_last_name, d_year AS year, year_total, 'w' AS sale_type
    EXPECTED_ROWS: ≤214K
    CONSUMERS: main_join
  main_join:
    FROM: store_agg s1999, store_agg s2000, web_agg w1999, web_agg w2000
    JOIN: s1999.customer_id = s2000.customer_id AND s1999.customer_id = w1999.customer_id AND s1999.customer_id = w2000.customer_id
    WHERE: s1999.year = 1999 AND s2000.year = 2000 AND w1999.year = 1999 AND w2000.year = 2000
          AND s1999.year_total > 0 AND w1999.year_total > 0
          AND (w2000.year_total / w1999.year_total) > (s2000.year_total / s1999.year_total)
    ORDER BY: s2000.customer_first_name ASC, s2000.customer_id ASC, s2000.customer_last_name ASC
    LIMIT: 100
    OUTPUT: s2000.customer_id, s2000.customer_first_name, s2000.customer_last_name
    EXPECTED_ROWS: ≤100
    CONSUMERS: final output
EXAMPLES: single_pass_aggregation, prefetch_fact_join, union_cte_split
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Consolidate years in store_agg/web_agg via GROUP BY with d_year.
- prefetch_fact_join: Use date_filter CTE and pre-join with fact tables; add customer pre-filtering via separate CTEs.
- union_cte_split: Split by channel but keep single-pass per channel; ignore year splitting.
HAZARD_FLAGS:
- customer_store and customer_web may still scan store_sales/web_sales fully; benefit depends on join reduction.
- Risk of double-joining customer with fact tables (once in customer_*, once in *_agg).
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy