## Part 1: Modified Logic Tree

```
QUERY: (CTE-based)
├── [~] main_query → now assembles CTEs
│   ├── [+] date_cte [=]
│   ├── [+] store_cte [=]
│   ├── [+] hd_branch1 [=]
│   ├── [+] hd_branch2 [=]
│   ├── [+] hd_union [=]
│   ├── [+] addr_cte [=]
│   ├── [+] filtered_fact [=]
│   ├── [+] agg [=]
│   ├── [+] late_customer_join [=]
│   └── [+] output [=] (ORDER BY + LIMIT)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "or_to_union", "description": "Split OR condition on household_demographics into UNION DISTINCT branches", "applied_to": ["hd_branch1", "hd_branch2", "hd_union"]},
    {"id": "R2", "type": "multi_dimension_prefetch", "description": "Pre-filter all dimension tables into CTEs before fact join", "applied_to": ["date_cte", "store_cte", "hd_union", "addr_cte", "filtered_fact"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_dow IN (6,0) AND d_year BETWEEN 1999 AND 2001",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk FROM store WHERE s_city IN ('Five Points','Centerville','Oak Grove','Fairview','Liberty')",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "hd_branch1": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE hd_dep_count = 6",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "hd_branch2": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE hd_vehicle_count = 0",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "hd_union": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT hd_demo_sk FROM hd_branch1 UNION DISTINCT SELECT hd_demo_sk FROM hd_branch2",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": ["hd_branch1", "hd_branch2"]}
      },
      "addr_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ca_address_sk, ca_city FROM customer_address",
        "interfaces": {"outputs": ["ca_address_sk", "ca_city"], "consumes": []}
      },
      "filtered_fact": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_ticket_number, ss_customer_sk, ss_addr_sk, ca_city AS bought_city, ss_coupon_amt, ss_net_profit FROM store_sales INNER JOIN date_cte ON ss_sold_date_sk = d_date_sk INNER JOIN store_cte ON ss_store_sk = s_store_sk INNER JOIN hd_union ON ss_hdemo_sk = hd_demo_sk INNER JOIN addr_cte ON ss_addr_sk = ca_address_sk",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "ss_addr_sk", "bought_city", "ss_coupon_amt", "ss_net_profit"], "consumes": ["date_cte", "store_cte", "hd_union", "addr_cte"]}
      },
      "agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_ticket_number, ss_customer_sk, ss_addr_sk, bought_city, SUM(ss_coupon_amt) AS amt, SUM(ss_net_profit) AS profit FROM filtered_fact GROUP BY ss_ticket_number, ss_customer_sk, ss_addr_sk, bought_city",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "ss_addr_sk", "bought_city", "amt", "profit"], "consumes": ["filtered_fact"]}
      },
      "late_customer_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c_last_name, c_first_name, current_addr.ca_city, agg.bought_city, agg.ss_ticket_number, agg.amt, agg.profit FROM agg INNER JOIN customer ON agg.ss_customer_sk = customer.c_customer_sk INNER JOIN customer_address current_addr ON customer.c_current_addr_sk = current_addr.ca_address_sk WHERE current_addr.ca_city <> agg.bought_city",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "ca_city", "bought_city", "ss_ticket_number", "amt", "profit"], "consumes": ["agg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number, amt, profit FROM late_customer_join ORDER BY c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number LIMIT 100",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "ca_city", "bought_city", "ss_ticket_number", "amt", "profit"], "consumes": ["late_customer_join"]}
      }
    },
    "reconstruction_order": ["date_cte", "store_cte", "hd_branch1", "hd_branch2", "hd_union", "addr_cte", "filtered_fact", "agg", "late_customer_join", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), store_cte AS ({store_cte}), hd_branch1 AS ({hd_branch1}), hd_branch2 AS ({hd_branch2}), hd_union AS ({hd_union}), addr_cte AS ({addr_cte}), filtered_fact AS ({filtered_fact}), agg AS ({agg}), late_customer_join AS ({late_customer_join}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured the original monolithic query into a CTE pipeline following the target logical tree. Applied OR-to-UNION decomposition on household_demographics (split hd_dep_count=6 and hd_vehicle_count=0 into separate branches) and multi-dimension prefetch (pre-filtered date, store, household, and address dimensions before joining with the large fact table).

**Expected speedup**: ~2.5-3x due to: 1) UNION DISTINCT allows separate scan strategies for each household branch, 2) Pre-filtered dimension CTEs reduce fact table scan volume, 3) Early filtering of weekend dates and specific store cities significantly reduces fact rows before joins.