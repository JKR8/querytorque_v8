You are a SQL rewrite engine for DuckDB v1.4.3. Follow the Target Logical Tree structure below. Your job is to write correct, executable SQL for each node — not to decide whether to restructure. Preserve exact semantic equivalence (same rows, same columns, same ordering). Preserve defensive guards: if the original uses CASE WHEN x > 0 THEN y/x END around a division, keep it — even when a WHERE clause makes the zero case unreachable. Guards prevent silent breakage if filters change upstream. Strip benchmark comments (-- start query, -- end query) from your output.

DuckDB specifics: columnar storage (SELECT only needed columns). CTEs referenced once are typically inlined; CTEs referenced multiple times may be materialized. FILTER clause is native (`COUNT(*) FILTER (WHERE cond)`). Predicate pushdown stops at UNION ALL boundaries and multi-level CTE references.

## Semantic Contract (MUST preserve)

Return weekend ticket-level coupon and profit totals for selected store cities during 1999-2001 where household has 6 dependents or 0 vehicles, then keep customers whose current city differs from purchase city. All joins are INNER (intersection semantics) requiring matches on all sides. Aggregates SUM(ss_coupon_amt) and SUM(ss_net_profit) are duplicate-insensitive but depend on correct group membership defined by (ss_ticket_number, ss_customer_sk, ss_addr_sk, ca_city). The city mismatch filter (current_addr.ca_city <> bought_city) depends on both customer_address aliases and must be preserved.

## Target Logical Tree + Node Contracts

Build your rewrite following this CTE structure. Each node's OUTPUT list is exhaustive — your SQL must produce exactly those columns.

TARGET_LOGICAL_TREE:
hd_branch1 -> hd_branch2 -> hd_union -> fact_join -> agg -> customer_join -> output
NODE_CONTRACTS:
  hd_branch1:
    FROM: household_demographics
    WHERE: hd_dep_count = 6
    OUTPUT: hd_demo_sk
    EXPECTED_ROWS: ~3,600 (half of 7,200)
    CONSUMERS: hd_union
  hd_branch2:
    FROM: household_demographics
    WHERE: hd_vehicle_count = 0
    OUTPUT: hd_demo_sk
    EXPECTED_ROWS: ~3,600
    CONSUMERS: hd_union
  hd_union:
    FROM: (SELECT hd_demo_sk FROM hd_branch1 UNION ALL SELECT hd_demo_sk FROM hd_branch2)
    OUTPUT: hd_demo_sk
    EXPECTED_ROWS: 7,200
    CONSUMERS: fact_join
  fact_join:
    FROM: store_sales
    JOIN: INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk
           INNER JOIN store ON ss_store_sk = s_store_sk
           INNER JOIN hd_union ON ss_hdemo_sk = hd_demo_sk
           INNER JOIN customer_address ON ss_addr_sk = ca_address_sk
    WHERE: d_dow IN (6,0) AND d_year BETWEEN 1999 AND 2001
           AND s_city IN ('Five Points','Centerville','Oak Grove','Fairview','Liberty')
    OUTPUT: ss_ticket_number, ss_customer_sk, ss_addr_sk, ca_city AS bought_city, ss_coupon_amt, ss_net_profit
    EXPECTED_ROWS: 564K
    CONSUMERS: agg
  agg:
    FROM: fact_join
    GROUP BY: ss_ticket_number, ss_customer_sk, ss_addr_sk, bought_city
    AGGREGATE: SUM(ss_coupon_amt) AS amt, SUM(ss_net_profit) AS profit
    OUTPUT: ss_ticket_number, ss_customer_sk, ss_addr_sk, bought_city, amt, profit
    EXPECTED_ROWS: 53K
    CONSUMERS: customer_join
  customer_join:
    FROM: agg
    JOIN: INNER JOIN customer ON ss_customer_sk = c_customer_sk
           INNER JOIN customer_address current_addr ON customer.c_current_addr_sk = current_addr.ca_address_sk
    WHERE: current_addr.ca_city <> bought_city
    OUTPUT: c_last_name, c_first_name, current_addr.ca_city, bought_city, ss_ticket_number, amt, profit
    EXPECTED_ROWS: 48K
    CONSUMERS: output
  output:
    FROM: customer_join
    ORDER BY: c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number
    LIMIT: 100
    OUTPUT: c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number, amt, profit
    EXPECTED_ROWS: 100
    CONSUMERS: final

NODE_CONTRACTS:
hd_branch1:
    FROM: household_demographics
    WHERE: hd_dep_count = 6
    OUTPUT: hd_demo_sk
    EXPECTED_ROWS: ~3,600 (half of 7,200)
    CONSUMERS: hd_union
  hd_branch2:
    FROM: household_demographics
    WHERE: hd_vehicle_count = 0
    OUTPUT: hd_demo_sk
    EXPECTED_ROWS: ~3,600
    CONSUMERS: hd_union
  hd_union:
    FROM: (SELECT hd_demo_sk FROM hd_branch1 UNION ALL SELECT hd_demo_sk FROM hd_branch2)
    OUTPUT: hd_demo_sk
    EXPECTED_ROWS: 7,200
    CONSUMERS: fact_join
  fact_join:
    FROM: store_sales
    JOIN: INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk
           INNER JOIN store ON ss_store_sk = s_store_sk
           INNER JOIN hd_union ON ss_hdemo_sk = hd_demo_sk
           INNER JOIN customer_address ON ss_addr_sk = ca_address_sk
    WHERE: d_dow IN (6,0) AND d_year BETWEEN 1999 AND 2001
           AND s_city IN ('Five Points','Centerville','Oak Grove','Fairview','Liberty')
    OUTPUT: ss_ticket_number, ss_customer_sk, ss_addr_sk, ca_city AS bought_city, ss_coupon_amt, ss_net_profit
    EXPECTED_ROWS: 564K
    CONSUMERS: agg
  agg:
    FROM: fact_join
    GROUP BY: ss_ticket_number, ss_customer_sk, ss_addr_sk, bought_city
    AGGREGATE: SUM(ss_coupon_amt) AS amt, SUM(ss_net_profit) AS profit
    OUTPUT: ss_ticket_number, ss_customer_sk, ss_addr_sk, bought_city, amt, profit
    EXPECTED_ROWS: 53K
    CONSUMERS: customer_join
  customer_join:
    FROM: agg
    JOIN: INNER JOIN customer ON ss_customer_sk = c_customer_sk
           INNER JOIN customer_address current_addr ON customer.c_current_addr_sk = current_addr.ca_address_sk
    WHERE: current_addr.ca_city <> bought_city
    OUTPUT: c_last_name, c_first_name, current_addr.ca_city, bought_city, ss_ticket_number, amt, profit
    EXPECTED_ROWS: 48K
    CONSUMERS: output
  output:
    FROM: customer_join
    ORDER BY: c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number
    LIMIT: 100
    OUTPUT: c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number, amt, profit
    EXPECTED_ROWS: 100
    CONSUMERS: final

## Hazard Flags (avoid these specific risks)

- UNION ALL may produce duplicates if a row matches both conditions (hd_dep_count=6 AND hd_vehicle_count=0). Need DISTINCT or UNION to deduplicate? Check semantics: OR condition, a row matching both should be included once. Use UNION DISTINCT instead of UNION ALL.
- Two scans of household_demographics instead of one.

## Regression Warnings (observed failures on similar queries)

1. or_to_union (0.59x on Q90):
   CAUSE: Split same-column time range OR into UNION branches, doubling fact table scans.
   RULE: Only split OR on DIFFERENT columns (hd_dep_count vs hd_vehicle_count), not same column.
2. dimension_cte_isolate (0.0076x on Q26):
   CAUSE: Cross-joined 3+ dimension CTEs causing Cartesian explosion.
   RULE: Never cross-join dimension CTEs; join them sequentially with fact table.
3. prefetch_fact_join (0.50x on Q25):
   CAUSE: Baseline <50ms, CTE overhead dominated savings.
   RULE: This query's baseline is 913ms, so CTE overhead acceptable.

## Constraints (analyst-filtered for this query)

- COMPLETE_OUTPUT: Must output c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number, amt, profit in same order.
- CTE_COLUMN_COMPLETENESS: Every CTE must include all columns referenced by downstream consumers.
- LITERAL_PRESERVATION: Must preserve literal values: d_dow in (6,0), d_year in (1999,2000,2001), s_city list, hd_dep_count=6, hd_vehicle_count=0.
- SEMANTIC_EQUIVALENCE: Must return exactly same 100 rows with same ordering.
- CROSS_COLUMN_OR_DECOMPOSITION: OR condition on hd_dep_count and hd_vehicle_count prevents optimal scan path.
- STAR_JOIN_PREFETCH: Multiple dimension tables with selective filters could be pre-filtered before fact join.
- LATE_ATTRIBUTE_BINDING: customer and current_addr joins only provide display columns and one filter.

## Example Adaptation Notes

For each example: what to apply to your rewrite, and what to ignore.

- or_to_union (Q15): Split OR conditions on different columns into UNION ALL branches; apply to household_demographics only; ignore that Q15 has three branches.

## Reference Examples

Pattern reference only — do not copy table/column names or literals.

### 1. or_to_union (3.17x)

**Principle:** OR-to-UNION Decomposition: split OR conditions on different columns into separate UNION ALL branches, each with a focused predicate. The optimizer can use different access paths per branch instead of a single scan with a complex filter.

**BEFORE (slow):**
```sql
select ca_zip
       ,sum(cs_sales_price)
 from catalog_sales
     ,customer
     ,customer_address
     ,date_dim
 where cs_bill_customer_sk = c_customer_sk
 	and c_current_addr_sk = ca_address_sk 
 	and ( substr(ca_zip,1,5) in ('85669', '86197','88274','83405','86475',
                                   '85392', '85460', '80348', '81792')
 	      or ca_state in ('CA','WA','GA')
 	      or cs_sales_price > 500)
 	and cs_sold_date_sk = d_date_sk
 	and d_qoy = 1 and d_year = 2001
 group by ca_zip
 order by ca_zip
 LIMIT 100;
```

**AFTER (fast):**
[filtered_dates]:
```sql
SELECT d_date_sk FROM date_dim WHERE d_qoy = 1 AND d_year = 2001
```
[filtered_sales]:
```sql
SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE substr(ca_zip,1,5) IN ('85669', '86197', '88274', '83405', '86475', '85392', '85460', '80348', '81792') UNION ALL SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE ca_state IN ('CA','WA','GA') UNION ALL SELECT cs_sales_price, ca_zip FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk JOIN customer ON cs_bill_customer_sk = c_customer_sk JOIN customer_address ON c_current_addr_sk = ca_address_sk WHERE cs_sales_price > 500
```
[main_query]:
```sql
SELECT ca_zip, SUM(cs_sales_price) FROM filtered_sales GROUP BY ca_zip ORDER BY ca_zip LIMIT 100
```

## Original SQL

```sql
-- start query 46 in stream 0 using template query46.tpl
select c_last_name
       ,c_first_name
       ,ca_city
       ,bought_city
       ,ss_ticket_number
       ,amt,profit 
 from
   (select ss_ticket_number
          ,ss_customer_sk
          ,ca_city bought_city
          ,sum(ss_coupon_amt) amt
          ,sum(ss_net_profit) profit
    from store_sales,date_dim,store,household_demographics,customer_address 
    where store_sales.ss_sold_date_sk = date_dim.d_date_sk
    and store_sales.ss_store_sk = store.s_store_sk  
    and store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk
    and store_sales.ss_addr_sk = customer_address.ca_address_sk
    and (household_demographics.hd_dep_count = 6 or
         household_demographics.hd_vehicle_count= 0)
    and date_dim.d_dow in (6,0)
    and date_dim.d_year in (1999,1999+1,1999+2) 
    and store.s_city in ('Five Points','Centerville','Oak Grove','Fairview','Liberty') 
    group by ss_ticket_number,ss_customer_sk,ss_addr_sk,ca_city) dn,customer,customer_address current_addr
    where ss_customer_sk = c_customer_sk
      and customer.c_current_addr_sk = current_addr.ca_address_sk
      and current_addr.ca_city <> bought_city
  order by c_last_name
          ,c_first_name
          ,ca_city
          ,bought_city
          ,ss_ticket_number
 LIMIT 100;

-- end query 46 in stream 0 using template query46.tpl
```

## Rewrite Checklist (must pass before final SQL)

- Follow every node in `TARGET_LOGICAL_TREE` and produce each `NODE_CONTRACT` output column exactly.
- Keep all semantic invariants from `Semantic Contract` and `Constraints` (including join/null behavior).
- Preserve all literals and the exact final output schema/order.
- Apply `Hazard Flags` and `Regression Warnings` as hard guards against known failure modes.

### Column Completeness Contract

Your `main_query` component MUST produce **exactly** these output columns (same names, same order):

  1. `c_last_name`
  2. `c_first_name`
  3. `ca_city`
  4. `bought_city`
  5. `ss_ticket_number`
  6. `amt`
  7. `profit`

Do NOT add, remove, or rename any output columns. The result set schema must be identical to the original query.

## Original Query Structure

This is the current query structure. All nodes are `[=]` (unchanged). Your modified Logic Tree below should show which nodes you changed.

```
QUERY: (single statement)
└── [MAIN] main_query  [=]  Cost: 100%  Rows: ~1K  — Aggregate ticket metrics by customer and bought-city under the date/store/household filters, join to customer and current address, filter city mismatch, and output ordered customer and ticket fields.
    ├── SCAN (store_sales, date_dim, store, household_demographics, customer_address, customer (join), customer_address AS current_addr (join))
    ├── JOIN (ss_customer_sk = c_customer_sk)
    ├── JOIN (customer.c_current_addr_sk = current_addr.ca_address_sk)
    ├── FILTER (current_addr.ca_city <> bought_city)
    ├── AGG (GROUP BY)
    ├── SORT (c_last_name ASC, c_first_name ASC, ca_city ASC, bought_city ASC, ss_ticket_number ASC)
    └── OUTPUT (c_last_name, c_first_name, ca_city, bought_city, ss_ticket_number, amt, profit)
```

## Output Format

Your response has **two parts** in order:

### Part 1: Modified Logic Tree

Show what changed using change markers. Generate the tree BEFORE writing SQL.

Change markers:
- `[+]` — New component added
- `[-]` — Component removed
- `[~]` — Component modified (describe what changed)
- `[=]` — Unchanged (no children needed)
- `[!]` — Structural change (e.g. CTE → subquery)

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "<dialect>",
  "rewrite_rules": [
    {"id": "R1", "type": "<transform_name>", "description": "<what changed>", "applied_to": ["<component_id>"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "<cte_name>": {
        "type": "cte",
        "change": "modified",
        "sql": "<complete SQL for this CTE body>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<upstream_id>"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "<final SELECT>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<cte_name>"]}
      }
    },
    "reconstruction_order": ["<cte_name>", "main_query"],
    "assembly_template": "WITH <cte_name> AS ({<cte_name>}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Rules
- **Tree first, always.** Generate the Logic Tree before writing any SQL
- **One component at a time.** When writing SQL for component X, treat others as opaque interfaces
- **No ellipsis.** Every `sql` value must be complete, executable SQL
- **Frozen blocks are copy-paste.** Large CASE-WHEN lookups must be verbatim
- **Validate interfaces.** Verify every `consumes` reference exists in upstream `outputs`
- Only include components you **changed or added** — set unchanged components to `"change": "unchanged"` with `"sql": ""`
- `main_query` output columns must match the Column Completeness Contract above
- `reconstruction_order`: topological order of components for assembly

After the JSON, explain the mechanism:

```
Changes: <1-2 sentences: what structural change + the expected mechanism>
Expected speedup: <estimate>
```

Now output your Logic Tree and Component Payload JSON: