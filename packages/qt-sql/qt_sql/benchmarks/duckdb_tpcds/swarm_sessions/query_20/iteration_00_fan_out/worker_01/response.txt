## Part 1: Modified Logic Tree

```
QUERY: (CTE-based)
├── [~] filtered_dates [=]
├── [~] filtered_items [=]  
├── [~] joined_sales [=]
├── [+] item_aggregates [NEW - replaces direct GROUP BY]
├── [+] class_aggregates [NEW - replaces window function partition]
├── [~] final_join [=]
└── [=] top_n [=] (absorbed into final_join LIMIT)
```

**Changes:**
- `item_aggregates`: NEW - materializes per-item revenue aggregates (GROUP BY i_item_id, i_item_desc, i_category, i_class, i_current_price)
- `class_aggregates`: NEW - materializes per-class revenue aggregates (GROUP BY i_class)
- `final_join`: MODIFIED - now joins item_aggregates with class_aggregates and computes revenueratio via direct division instead of window function
- Original window function `SUM(cs_ext_sales_price)*100/SUM(SUM(cs_ext_sales_price)) OVER (PARTITION BY i_class)` replaced with join-based computation `itemrevenue * 100 / classrevenue`

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "deferred_window_aggregation",
      "description": "Replace window function partitioning by i_class with materialized class aggregates CTE, then join to compute ratio",
      "applied_to": ["class_aggregates", "final_join"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_dates": {
          "type": "cte",
          "change": "unchanged",
          "sql": "",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "filtered_items": {
          "type": "cte",
          "change": "unchanged",
          "sql": "",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_category", "i_class", "i_current_price"],
            "consumes": []
          }
        },
        "joined_sales": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT \n    i.i_item_sk,\n    i.i_item_id,\n    i.i_item_desc,\n    i.i_category,\n    i.i_class,\n    i.i_current_price,\n    cs.cs_ext_sales_price\nFROM catalog_sales cs\nINNER JOIN filtered_dates d ON cs.cs_sold_date_sk = d.d_date_sk\nINNER JOIN filtered_items i ON cs.cs_item_sk = i.i_item_sk",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_category", "i_class", "i_current_price", "cs_ext_sales_price"],
            "consumes": ["filtered_dates", "filtered_items"]
          }
        },
        "item_aggregates": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT \n    i_item_id,\n    i_item_desc,\n    i_category,\n    i_class,\n    i_current_price,\n    SUM(cs_ext_sales_price) AS itemrevenue\nFROM joined_sales\nGROUP BY \n    i_item_id,\n    i_item_desc,\n    i_category,\n    i_class,\n    i_current_price",
          "interfaces": {
            "outputs": ["i_item_id", "i_item_desc", "i_category", "i_class", "i_current_price", "itemrevenue"],
            "consumes": ["joined_sales"]
          }
        },
        "class_aggregates": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT \n    i.i_class,\n    SUM(js.cs_ext_sales_price) AS classrevenue\nFROM filtered_items i\nINNER JOIN joined_sales js ON i.i_item_sk = js.i_item_sk\nGROUP BY i.i_class",
          "interfaces": {
            "outputs": ["i_class", "classrevenue"],
            "consumes": ["filtered_items", "joined_sales"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT \n    ia.i_item_id,\n    ia.i_item_desc,\n    ia.i_category,\n    ia.i_class,\n    ia.i_current_price,\n    ia.itemrevenue,\n    ia.itemrevenue * 100 / ca.classrevenue AS revenueratio\nFROM item_aggregates ia\nINNER JOIN class_aggregates ca ON ia.i_class = ca.i_class\nORDER BY \n    ia.i_category,\n    ia.i_class,\n    ia.i_item_id,\n    ia.i_item_desc,\n    revenueratio\nLIMIT 100",
          "interfaces": {
            "outputs": ["i_item_id", "i_item_desc", "i_category", "i_class", "i_current_price", "itemrevenue", "revenueratio"],
            "consumes": ["item_aggregates", "class_aggregates"]
          }
        }
      },
      "reconstruction_order": ["filtered_dates", "filtered_items", "joined_sales", "item_aggregates", "class_aggregates", "main_query"],
      "assembly_template": "WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('2002-01-26' AS DATE) AND (CAST('2002-01-26' AS DATE) + INTERVAL 30 DAY)),\n     filtered_items AS (SELECT i_item_sk, i_item_id, i_item_desc, i_category, i_class, i_current_price FROM item WHERE i_category IN ('Shoes', 'Books', 'Women')),\n     joined_sales AS ({joined_sales}),\n     item_aggregates AS ({item_aggregates}),\n     class_aggregates AS ({class_aggregates})\n{main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** The window function that computed class-level totals (partition by i_class) has been replaced with a materialized CTE `class_aggregates` that computes the same totals via GROUP BY. The revenue ratio is then computed via a simple join and division instead of a window function over 14K rows.

**Expected speedup:** 1.2-1.5x due to eliminating window function computation over the 14K-row result set and replacing it with hash aggregations and joins.