## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Extract shared dimension filters into CTEs, build distinct customer/date sets via CTEs, perform EXCEPT chain, and return count.
    ├── [+] filtered_date CTE
    │   └── SCAN date_dim  [~]  — Pre-filtered small date dimension (365 rows)
    ├── [+] filtered_customer CTE
    │   └── SCAN customer  [~]  — Unfiltered customer dimension (500K rows)
    ├── [~] store_sales_cte CTE
    │   ├── SCAN store_sales
    │   ├── JOIN filtered_date (INNER)
    │   └── JOIN filtered_customer (INNER)
    ├── [~] catalog_sales_cte CTE
    │   ├── SCAN catalog_sales
    │   ├── JOIN filtered_date (INNER)
    │   └── JOIN filtered_customer (INNER)
    ├── [~] web_sales_cte CTE
    │   ├── SCAN web_sales
    │   ├── JOIN filtered_date (INNER)
    │   └── JOIN filtered_customer (INNER)
    ├── [~] except_chain CTE
    │   └── SET OPERATION (EXCEPT)
    └── [~] count  [=]  — COUNT(*) final aggregation
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "shared_dimension_extraction", "description": "Extract shared date_dim filter into reusable CTE", "applied_to": ["filtered_date"]},
    {"id": "R2", "type": "shared_dimension_extraction", "description": "Extract customer dimension into reusable CTE", "applied_to": ["filtered_customer"]},
    {"id": "R3", "type": "cte_restructure", "description": "Convert each channel's distinct selection to explicit CTE with GROUP BY", "applied_to": ["store_sales_cte", "catalog_sales_cte", "web_sales_cte"]},
    {"id": "R4", "type": "except_chain_preservation", "description": "Preserve EXCEPT semantics via CTE-based set difference", "applied_to": ["except_chain"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1184 AND 1184+11",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "filtered_customer": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c_customer_sk, c_last_name, c_first_name FROM customer",
        "interfaces": {"outputs": ["c_customer_sk", "c_last_name", "c_first_name"], "consumes": []}
      },
      "store_sales_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, d_date FROM store_sales INNER JOIN filtered_date ON store_sales.ss_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_customer ON store_sales.ss_customer_sk = filtered_customer.c_customer_sk GROUP BY c_last_name, c_first_name, d_date",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_date", "filtered_customer"]}
      },
      "catalog_sales_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, d_date FROM catalog_sales INNER JOIN filtered_date ON catalog_sales.cs_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_customer ON catalog_sales.cs_bill_customer_sk = filtered_customer.c_customer_sk GROUP BY c_last_name, c_first_name, d_date",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_date", "filtered_customer"]}
      },
      "web_sales_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, d_date FROM web_sales INNER JOIN filtered_date ON web_sales.ws_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_customer ON web_sales.ws_bill_customer_sk = filtered_customer.c_customer_sk GROUP BY c_last_name, c_first_name, d_date",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_date", "filtered_customer"]}
      },
      "except_chain": {
        "type": "cte",
        "change": "modified",
        "sql": "(SELECT c_last_name, c_first_name, d_date FROM store_sales_cte EXCEPT SELECT c_last_name, c_first_name, d_date FROM catalog_sales_cte EXCEPT SELECT c_last_name, c_first_name, d_date FROM web_sales_cte)",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["store_sales_cte", "catalog_sales_cte", "web_sales_cte"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT COUNT(*) AS count FROM except_chain",
        "interfaces": {"outputs": ["count"], "consumes": ["except_chain"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_customer", "store_sales_cte", "catalog_sales_cte", "web_sales_cte", "except_chain", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_customer AS ({filtered_customer}), store_sales_cte AS ({store_sales_cte}), catalog_sales_cte AS ({catalog_sales_cte}), web_sales_cte AS ({web_sales_cte}), except_chain AS ({except_chain}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured query to use CTEs for shared dimension filtering (date_dim, customer), which reduces redundant dimension scans from 3x each to 1x each. Each channel CTE now explicitly uses GROUP BY for distinctness (semantically equivalent to DISTINCT) and feeds into the EXCEPT chain. This follows the target logical tree while preserving exact semantic equivalence.

**Expected speedup**: ~1.3-1.5x due to reduced dimension scan overhead and better join planning through shared CTEs.