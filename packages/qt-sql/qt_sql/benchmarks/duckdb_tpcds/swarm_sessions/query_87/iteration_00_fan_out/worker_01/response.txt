## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Single-pass aggregation for channel presence detection
    ├── [CTE] date_filtered  [+]  Rows: 365 — Date dimension filtered for 12-month period
    │   └── SCAN (date_dim)
    │       └── FILTER (d_month_seq BETWEEN 1184 AND 1184+11)
    ├── [CTE] sales_unified  [+]  Rows: ~9.6M — Unified sales from all channels with date and customer joins
    │   ├── UNION ALL (store_sales, catalog_sales, web_sales)
    │   ├── JOIN (INNER) date_filtered ON sold_date_sk = d_date_sk
    │   └── JOIN (INNER) customer ON unified customer key
    ├── [CTE] channel_presence  [+]  Rows: ~500K — Channel presence bitmap via single-pass aggregation
    │   └── GROUP BY (c_last_name, c_first_name, d_date)
    │       └── AGGREGATE (MAX(CASE) for store/catalog/web channels)
    ├── [CTE] store_only  [+]  Rows: ~463K — Filter for store-only customers
    │   └── FILTER (has_store=1 AND has_catalog=0 AND has_web=0)
    └── [CTE] count  [+]  Rows: 1 — Final count of store-only customer/date combinations
        └── AGGREGATE (COUNT(*))
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "single_pass_aggregation",
      "description": "Convert three separate EXCEPT operations to unified channel presence detection via CASE expressions in aggregates",
      "applied_to": ["sales_unified", "channel_presence"]
    },
    {
      "id": "R2", 
      "type": "date_filter_pushdown",
      "description": "Extract date filter to separate CTE and push to all three sales tables",
      "applied_to": ["date_filtered", "sales_unified"]
    },
    {
      "id": "R3",
      "type": "unified_customer_join",
      "description": "Replace three separate customer joins with unified join using channel-specific keys in UNION ALL",
      "applied_to": ["sales_unified"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1184 AND 1184 + 11",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "sales_unified": {
        "type": "cte", 
        "change": "new",
        "sql": "SELECT customer.c_last_name, customer.c_first_name, date_filtered.d_date, sales.channel FROM (SELECT ss_sold_date_sk AS sold_date_sk, ss_customer_sk AS customer_sk, 'store' AS channel FROM store_sales UNION ALL SELECT cs_sold_date_sk AS sold_date_sk, cs_bill_customer_sk AS customer_sk, 'catalog' AS channel FROM catalog_sales UNION ALL SELECT ws_sold_date_sk AS sold_date_sk, ws_bill_customer_sk AS customer_sk, 'web' AS channel FROM web_sales) sales INNER JOIN date_filtered ON sales.sold_date_sk = date_filtered.d_date_sk INNER JOIN customer ON sales.customer_sk = customer.c_customer_sk",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date", "channel"], "consumes": ["date_filtered"]}
      },
      "channel_presence": {
        "type": "cte",
        "change": "new", 
        "sql": "SELECT c_last_name, c_first_name, d_date, MAX(CASE WHEN channel = 'store' THEN 1 ELSE 0 END) AS has_store, MAX(CASE WHEN channel = 'catalog' THEN 1 ELSE 0 END) AS has_catalog, MAX(CASE WHEN channel = 'web' THEN 1 ELSE 0 END) AS has_web FROM sales_unified GROUP BY c_last_name, c_first_name, d_date",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date", "has_store", "has_catalog", "has_web"], "consumes": ["sales_unified"]}
      },
      "store_only": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c_last_name, c_first_name, d_date FROM channel_presence WHERE has_store = 1 AND has_catalog = 0 AND has_web = 0",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["channel_presence"]}
      },
      "count": {
        "type": "cte",
        "change": "new", 
        "sql": "SELECT COUNT(*) AS \"count(*)\" FROM store_only",
        "interfaces": {"outputs": ["count(*)"], "consumes": ["store_only"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT \"count(*)\" FROM count",
        "interfaces": {"outputs": ["count(*)"], "consumes": ["count"]}
      }
    },
    "reconstruction_order": ["date_filtered", "sales_unified", "channel_presence", "store_only", "count", "main_query"],
    "assembly_template": "WITH date_filtered AS ({date_filtered}), sales_unified AS ({sales_unified}), channel_presence AS ({channel_presence}), store_only AS ({store_only}), count AS ({count}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Replaced three separate EXCEPT branches with single-pass aggregation over unified sales data, applying channel presence detection via CASE expressions in MAX aggregates. This reduces 9 table scans (3x date_dim, 3x customer, 3x sales) to 4 scans (1x date_dim, 1x customer, 3x sales) while maintaining exact semantic equivalence.

**Expected speedup**: 2-4x from eliminating redundant date_dim and customer scans, plus vectorized aggregation on unified data.