## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~4  — Restructured to staged CTE pipeline with isolated date filters
    ├── [+] CTE d1_cte: filter date_dim for April 1999 (d_moy=4, d_year=1999)
    ├── [+] CTE store_sales_pre: join store_sales with d1_cte on date key
    ├── [+] CTE d2_cte: filter date_dim for months 4-7, 1999
    ├── [+] CTE store_returns_pre: join store_returns with d2_cte on date key
    ├── [+] CTE d3_cte: filter date_dim for years 1999-2001
    ├── [+] CTE catalog_sales_pre: join catalog_sales with d3_cte on date key
    ├── [+] CTE combined_facts: 3-way inner join of pre-filtered fact CTEs
    ├── [+] CTE store_item_join: join combined_facts with store and item tables
    ├── [+] CTE aggregate: group by item/store and compute averages
    ├── [+] CTE order_limit: order and limit final results
    └── OUTPUT (i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_quantity, store_returns_quantity, catalog_sales_quantity)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "staged_cte_pipeline", "description": "Decomposed monolithic join into sequenced CTEs with isolated date filters", "applied_to": ["d1_cte", "store_sales_pre", "d2_cte", "store_returns_pre", "d3_cte", "catalog_sales_pre", "combined_facts", "store_item_join", "aggregate", "order_limit"]},
    {"id": "R2", "type": "predicate_early_reduction", "description": "Applied date filters in dedicated CTEs before fact table joins", "applied_to": ["d1_cte", "d2_cte", "d3_cte"]},
    {"id": "R3", "type": "join_cardinality_preservation", "description": "Maintained INNER JOIN semantics across all three fact tables via multi-way join in combined_facts", "applied_to": ["combined_facts"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "d1_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 4 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_sales_pre": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_item_sk, ss_customer_sk, ss_ticket_number, ss_store_sk, ss_quantity FROM store_sales JOIN d1_cte ON ss_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_customer_sk", "ss_ticket_number", "ss_store_sk", "ss_quantity"], "consumes": ["d1_cte"]}
      },
      "d2_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 4 AND 7 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_returns_pre": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT sr_item_sk, sr_customer_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN d2_cte ON sr_returned_date_sk = d_date_sk",
        "interfaces": {"outputs": ["sr_item_sk", "sr_customer_sk", "sr_ticket_number", "sr_return_quantity"], "consumes": ["d2_cte"]}
      },
      "d3_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year IN (1999, 2000, 2001)",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "catalog_sales_pre": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cs_item_sk, cs_bill_customer_sk, cs_quantity FROM catalog_sales JOIN d3_cte ON cs_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["cs_item_sk", "cs_bill_customer_sk", "cs_quantity"], "consumes": ["d3_cte"]}
      },
      "combined_facts": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss.ss_item_sk, ss.ss_store_sk, ss.ss_quantity, sr.sr_return_quantity, cs.cs_quantity FROM store_sales_pre ss JOIN store_returns_pre sr ON ss.ss_customer_sk = sr.sr_customer_sk AND ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number JOIN catalog_sales_pre cs ON sr.sr_customer_sk = cs.cs_bill_customer_sk AND sr.sr_item_sk = cs.cs_item_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_store_sk", "ss_quantity", "sr_return_quantity", "cs_quantity"], "consumes": ["store_sales_pre", "store_returns_pre", "catalog_sales_pre"]}
      },
      "store_item_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i.i_item_id, i.i_item_desc, s.s_store_id, s.s_store_name, cf.ss_quantity, cf.sr_return_quantity, cf.cs_quantity FROM combined_facts cf JOIN store s ON cf.ss_store_sk = s.s_store_sk JOIN item i ON cf.ss_item_sk = i.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "ss_quantity", "sr_return_quantity", "cs_quantity"], "consumes": ["combined_facts"]}
      },
      "aggregate": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, AVG(ss_quantity) AS store_sales_quantity, AVG(sr_return_quantity) AS store_returns_quantity, AVG(cs_quantity) AS catalog_sales_quantity FROM store_item_join GROUP BY i_item_id, i_item_desc, s_store_id, s_store_name",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_quantity", "store_returns_quantity", "catalog_sales_quantity"], "consumes": ["store_item_join"]}
      },
      "order_limit": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_quantity, store_returns_quantity, catalog_sales_quantity FROM aggregate ORDER BY i_item_id, i_item_desc, s_store_id, s_store_name LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_quantity", "store_returns_quantity", "catalog_sales_quantity"], "consumes": ["aggregate"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_quantity, store_returns_quantity, catalog_sales_quantity FROM order_limit",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_quantity", "store_returns_quantity", "catalog_sales_quantity"], "consumes": ["order_limit"]}
      }
    },
    "reconstruction_order": ["d1_cte", "store_sales_pre", "d2_cte", "store_returns_pre", "d3_cte", "catalog_sales_pre", "combined_facts", "store_item_join", "aggregate", "order_limit", "main_query"],
    "assembly_template": "WITH d1_cte AS ({d1_cte}), store_sales_pre AS ({store_sales_pre}), d2_cte AS ({d2_cte}), store_returns_pre AS ({store_returns_pre}), d3_cte AS ({d3_cte}), catalog_sales_pre AS ({catalog_sales_pre}), combined_facts AS ({combined_facts}), store_item_join AS ({store_item_join}), aggregate AS ({aggregate}), order_limit AS ({order_limit}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured the monolithic 8-table join into a staged CTE pipeline that isolates date filters into dedicated CTEs before joining with fact tables, then performs the 3-way fact table join in `combined_facts` before adding dimensions. This preserves the exact INNER JOIN semantics while enabling predicate pushdown.

**Expected speedup**: 3-5x by reducing the 8.5M row catalog_sales scan via early date filtering and enabling join reordering within the combined_facts CTE while maintaining the required cardinality.