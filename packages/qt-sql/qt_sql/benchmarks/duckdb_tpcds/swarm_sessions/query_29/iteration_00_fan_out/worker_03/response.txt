## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ~1K  — Join April 1999 store sales to related returns in the following 4-month window and to catalog sales for the same customer/item across 1999-2001, then compute channel-specific average quantities by item/store.
    ├── [CTE] d1_cte  [+]  FROM: date_dim WHERE: d_moy=4 AND d_year=1999 OUTPUT: d_date_sk
    ├── [CTE] d2_cte  [+]  FROM: date_dim WHERE: d_moy BETWEEN 4 AND 7 AND d_year=1999 OUTPUT: d_date_sk
    ├── [CTE] d3_cte  [+]  FROM: date_dim WHERE: d_year IN (1999,2000,2001) OUTPUT: d_date_sk
    ├── [CTE] store_cte  [+]  FROM: store WHERE: s_store_sk <= 100 OUTPUT: s_store_sk, s_store_id, s_store_name
    ├── [CTE] item_cte  [+]  FROM: item OUTPUT: i_item_sk, i_item_id, i_item_desc
    ├── [CTE] fact_join_all  [!]  FROM: store_sales JOIN d1_cte ON ss_sold_date_sk = d1_cte.d_date_sk JOIN store_cte ON ss_store_sk = store_cte.s_store_sk JOIN item_cte ON ss_item_sk = item_cte.i_item_sk JOIN store_returns ON ss_customer_sk = sr_customer_sk AND ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number JOIN d2_cte ON sr_returned_date_sk = d2_cte.d_date_sk JOIN catalog_sales ON sr_customer_sk = cs_bill_customer_sk AND sr_item_sk = cs_item_sk JOIN d3_cte ON cs_sold_date_sk = d3_cte.d_date_sk
    ├── [CTE] aggregate  [!]  FROM: fact_join_all GROUP BY: i_item_id, i_item_desc, s_store_id, s_store_name AGGREGATE: AVG(ss_quantity), AVG(sr_return_quantity), AVG(cs_quantity)
    ├── [=] SORT (i_item_id ASC, i_item_desc ASC, s_store_id ASC, s_store_name ASC)
    └── [=] OUTPUT (i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_quantity, store_returns_quantity, catalog_sales_quantity)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter all dimension tables (date_dim for d1/d2/d3, store, item) into separate CTEs before the main fact table join", "applied_to": ["d1_cte", "d2_cte", "d3_cte", "store_cte", "item_cte"]},
    {"id": "R2", "type": "cte_based_fact_join", "description": "Replaced original WHERE-clause joins with explicit JOIN syntax using pre-filtered dimension CTEs", "applied_to": ["fact_join_all"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "d1_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 4 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "d2_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 4 AND 7 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "d3_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year IN (1999, 2000, 2001)",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s_store_sk, s_store_id, s_store_name FROM store WHERE s_store_sk <= 100",
        "interfaces": {"outputs": ["s_store_sk", "s_store_id", "s_store_name"], "consumes": []}
      },
      "item_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_id, i_item_desc FROM item",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id", "i_item_desc"], "consumes": []}
      },
      "fact_join_all": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT item_cte.i_item_id, item_cte.i_item_desc, store_cte.s_store_id, store_cte.s_store_name, ss_quantity, sr_return_quantity, cs_quantity FROM store_sales JOIN d1_cte ON store_sales.ss_sold_date_sk = d1_cte.d_date_sk JOIN store_cte ON store_sales.ss_store_sk = store_cte.s_store_sk JOIN item_cte ON store_sales.ss_item_sk = item_cte.i_item_sk JOIN store_returns ON store_sales.ss_customer_sk = store_returns.sr_customer_sk AND store_sales.ss_item_sk = store_returns.sr_item_sk AND store_sales.ss_ticket_number = store_returns.sr_ticket_number JOIN d2_cte ON store_returns.sr_returned_date_sk = d2_cte.d_date_sk JOIN catalog_sales ON store_returns.sr_customer_sk = catalog_sales.cs_bill_customer_sk AND store_returns.sr_item_sk = catalog_sales.cs_item_sk JOIN d3_cte ON catalog_sales.cs_sold_date_sk = d3_cte.d_date_sk",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "ss_quantity", "sr_return_quantity", "cs_quantity"], "consumes": ["d1_cte", "d2_cte", "d3_cte", "store_cte", "item_cte"]}
      },
      "aggregate": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, AVG(ss_quantity) AS store_sales_quantity, AVG(sr_return_quantity) AS store_returns_quantity, AVG(cs_quantity) AS catalog_sales_quantity FROM fact_join_all GROUP BY i_item_id, i_item_desc, s_store_id, s_store_name",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_quantity", "store_returns_quantity", "catalog_sales_quantity"], "consumes": ["fact_join_all"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_quantity, store_returns_quantity, catalog_sales_quantity FROM aggregate ORDER BY i_item_id, i_item_desc, s_store_id, s_store_name LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_quantity", "store_returns_quantity", "catalog_sales_quantity"], "consumes": ["aggregate"]}
      }
    },
    "reconstruction_order": ["d1_cte", "d2_cte", "d3_cte", "store_cte", "item_cte", "fact_join_all", "aggregate", "main_query"],
    "assembly_template": "WITH d1_cte AS ({d1_cte}), d2_cte AS ({d2_cte}), d3_cte AS ({d3_cte}), store_cte AS ({store_cte}), item_cte AS ({item_cte}), fact_join_all AS ({fact_join_all}), aggregate AS ({aggregate}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured original WHERE-clause joins into explicit CTE-based joins with pre-filtered dimension tables (date_dim for d1/d2/d3, store, item). This isolates dimension filtering early, creating small hash tables that speed up fact table probes while preserving exact semantic equivalence.

**Expected speedup:** 1.5-2.0x due to reduced dimension table scan costs and better join ordering control, though item_cte (102K rows) remains unfiltered as per requirements.