## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [~] CTE: d1_cte  [=]  Cost: 0%  Rows: 30 — Filter date_dim for April 1999
├── [~] CTE: d2_cte  [=]  Cost: 0%  Rows: 122 — Filter date_dim for months 4-7 of 1999
├── [~] CTE: d3_cte  [=]  Cost: 0%  Rows: 1096 — Filter date_dim for years 1999-2001
├── [+] CTE: store_cte  [!]  Cost: 0%  Rows: 100 — Pre-filter store dimension with s_store_sk <= 100
├── [~] CTE: filtered_store_sales  [!] — Now joins d1_cte and store_cte (instead of base tables)
├── [~] CTE: filtered_store_returns  [!] — Now joins d2_cte (instead of base table)
├── [~] CTE: filtered_catalog_sales  [!] — Now joins d3_cte (instead of base table)
├── [~] CTE: fact_join  [!] — Now joins filtered CTEs (instead of base tables) + item table
├── [~] AGGREGATE: aggregate  [=] — Same aggregation logic, now on fact_join CTE
├── [~] ORDER/LIMIT: order_limit  [=] — Same ordering and limit
└── OUTPUT: (same 7 columns as original)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "multi_dimension_prefetch", "description": "Pre-filter all three date_dim aliases and store dimension into separate CTEs before fact table joins", "applied_to": ["d1_cte", "d2_cte", "d3_cte", "store_cte"]},
    {"id": "R2", "type": "dimension_cte_isolate", "description": "Create filtered CTEs for each fact table using the pre-filtered dimension CTEs", "applied_to": ["filtered_store_sales", "filtered_store_returns", "filtered_catalog_sales"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "d1_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 4 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "d2_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 4 AND 7 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "d3_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year IN (1999, 2000, 2001)",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT s_store_sk, s_store_id, s_store_name FROM store WHERE s_store_sk <= 100",
        "interfaces": {"outputs": ["s_store_sk", "s_store_id", "s_store_name"], "consumes": []}
      },
      "filtered_store_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_item_sk, ss_customer_sk, ss_ticket_number, ss_store_sk, ss_quantity, store_cte.s_store_id, store_cte.s_store_name FROM store_sales JOIN d1_cte ON ss_sold_date_sk = d1_cte.d_date_sk JOIN store_cte ON ss_store_sk = store_cte.s_store_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_customer_sk", "ss_ticket_number", "ss_store_sk", "ss_quantity", "s_store_id", "s_store_name"], "consumes": ["d1_cte", "store_cte"]}
      },
      "filtered_store_returns": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT sr_item_sk, sr_customer_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN d2_cte ON sr_returned_date_sk = d2_cte.d_date_sk",
        "interfaces": {"outputs": ["sr_item_sk", "sr_customer_sk", "sr_ticket_number", "sr_return_quantity"], "consumes": ["d2_cte"]}
      },
      "filtered_catalog_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs_item_sk, cs_bill_customer_sk, cs_quantity FROM catalog_sales JOIN d3_cte ON cs_sold_date_sk = d3_cte.d_date_sk",
        "interfaces": {"outputs": ["cs_item_sk", "cs_bill_customer_sk", "cs_quantity"], "consumes": ["d3_cte"]}
      },
      "fact_join": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i.i_item_id, i.i_item_desc, fss.s_store_id, fss.s_store_name, fss.ss_quantity, fsr.sr_return_quantity, fcs.cs_quantity FROM filtered_store_sales fss JOIN filtered_store_returns fsr ON fss.ss_customer_sk = fsr.sr_customer_sk AND fss.ss_item_sk = fsr.sr_item_sk AND fss.ss_ticket_number = fsr.sr_ticket_number JOIN filtered_catalog_sales fcs ON fsr.sr_customer_sk = fcs.cs_bill_customer_sk AND fsr.sr_item_sk = fcs.cs_item_sk JOIN item i ON fss.ss_item_sk = i.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "ss_quantity", "sr_return_quantity", "cs_quantity"], "consumes": ["filtered_store_sales", "filtered_store_returns", "filtered_catalog_sales"]}
      },
      "aggregate": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, AVG(ss_quantity) AS store_sales_quantity, AVG(sr_return_quantity) AS store_returns_quantity, AVG(cs_quantity) AS catalog_sales_quantity FROM fact_join GROUP BY i_item_id, i_item_desc, s_store_id, s_store_name",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_quantity", "store_returns_quantity", "catalog_sales_quantity"], "consumes": ["fact_join"]}
      },
      "order_limit": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_quantity, store_returns_quantity, catalog_sales_quantity FROM aggregate ORDER BY i_item_id, i_item_desc, s_store_id, s_store_name LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_quantity", "store_returns_quantity", "catalog_sales_quantity"], "consumes": ["aggregate"]}
      }
    },
    "reconstruction_order": ["d1_cte", "d2_cte", "d3_cte", "store_cte", "filtered_store_sales", "filtered_store_returns", "filtered_catalog_sales", "fact_join", "aggregate", "order_limit"],
    "assembly_template": "WITH d1_cte AS ({d1_cte}), d2_cte AS ({d2_cte}), d3_cte AS ({d3_cte}), store_cte AS ({store_cte}), filtered_store_sales AS ({filtered_store_sales}), filtered_store_returns AS ({filtered_store_returns}), filtered_catalog_sales AS ({filtered_catalog_sales}), fact_join AS ({fact_join}), aggregate AS ({aggregate}) {order_limit}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Applied multi-dimension prefetch by isolating all three date_dim aliases and store dimension into selective CTEs before fact table joins, then built filtered fact CTEs using those dimension CTEs. This creates small hash tables for dimension lookups while preserving the original join semantics.

Expected speedup: 2-3x from reduced fact table scans and efficient dimension lookups via pre-filtered CTEs.