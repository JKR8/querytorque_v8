## Part 1: Modified Logic Tree

```
QUERY: (CTE pipeline)
├── [+] d1_cte
│   └── SCAN date_dim → FILTER (d_moy = 4 AND d_year = 1999)
├── [+] store_sales_d1
│   ├── SCAN store_sales
│   └── JOIN d1_cte ON ss_sold_date_sk = d_date_sk
├── [+] d2_cte
│   └── SCAN date_dim → FILTER (d_moy BETWEEN 4 AND 7 AND d_year = 1999)
├── [+] store_returns_d2
│   ├── SCAN store_returns
│   └── JOIN d2_cte ON sr_returned_date_sk = d_date_sk
├── [+] d3_cte
│   └── SCAN date_dim → FILTER (d_year IN (1999, 2000, 2001))
├── [+] catalog_sales_d3
│   ├── SCAN catalog_sales
│   └── JOIN d3_cte ON cs_sold_date_sk = d_date_sk
├── [+] fact_join
│   ├── JOIN store_sales_d1 ⇔ store_returns_d2 ON ss_customer_sk = sr_customer_sk AND ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number
│   └── JOIN ⇔ catalog_sales_d3 ON sr_customer_sk = cs_bill_customer_sk AND sr_item_sk = cs_item_sk
├── [+] store_item_join
│   ├── JOIN store ON ss_store_sk = s_store_sk
│   └── JOIN item ON ss_item_sk = i_item_sk
├── [+] aggregate
│   ├── GROUP BY i_item_id, i_item_desc, s_store_id, s_store_name
│   └── AGGREGATE AVG(ss_quantity), AVG(sr_return_quantity), AVG(cs_quantity)
└── [+] order_limit
    ├── SORT i_item_id, i_item_desc, s_store_id, s_store_name
    └── LIMIT 100
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "multi_date_range_cte", "description": "Separate date_dim aliases into isolated CTEs with their filters and pre-join with corresponding fact tables", "applied_to": ["d1_cte", "store_sales_d1", "d2_cte", "store_returns_d2", "d3_cte", "catalog_sales_d3"]},
    {"id": "R2", "type": "predicate_pushdown", "description": "Push date filters into CTEs to reduce rows before multi-way join", "applied_to": ["d1_cte", "d2_cte", "d3_cte"]},
    {"id": "R3", "type": "cte_column_completeness", "description": "Ensure CTEs include all required join keys for downstream joins", "applied_to": ["store_sales_d1", "store_returns_d2", "catalog_sales_d3"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "d1_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 4 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_sales_d1": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_item_sk, ss_customer_sk, ss_ticket_number, ss_store_sk, ss_quantity FROM store_sales JOIN d1_cte ON ss_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_customer_sk", "ss_ticket_number", "ss_store_sk", "ss_quantity"], "consumes": ["d1_cte"]}
      },
      "d2_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 4 AND 7 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_returns_d2": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT sr_item_sk, sr_customer_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN d2_cte ON sr_returned_date_sk = d_date_sk",
        "interfaces": {"outputs": ["sr_item_sk", "sr_customer_sk", "sr_ticket_number", "sr_return_quantity"], "consumes": ["d2_cte"]}
      },
      "d3_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year IN (1999, 2000, 2001)",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "catalog_sales_d3": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cs_item_sk, cs_bill_customer_sk, cs_quantity FROM catalog_sales JOIN d3_cte ON cs_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["cs_item_sk", "cs_bill_customer_sk", "cs_quantity"], "consumes": ["d3_cte"]}
      },
      "fact_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_item_sk, ss_store_sk, ss_quantity, sr_return_quantity, cs_quantity FROM store_sales_d1 JOIN store_returns_d2 ON ss_customer_sk = sr_customer_sk AND ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number JOIN catalog_sales_d3 ON sr_customer_sk = cs_bill_customer_sk AND sr_item_sk = cs_item_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_store_sk", "ss_quantity", "sr_return_quantity", "cs_quantity"], "consumes": ["store_sales_d1", "store_returns_d2", "catalog_sales_d3"]}
      },
      "store_item_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, ss_quantity, sr_return_quantity, cs_quantity FROM fact_join JOIN store ON ss_store_sk = s_store_sk JOIN item ON ss_item_sk = i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "ss_quantity", "sr_return_quantity", "cs_quantity"], "consumes": ["fact_join"]}
      },
      "aggregate": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, AVG(ss_quantity) AS store_sales_quantity, AVG(sr_return_quantity) AS store_returns_quantity, AVG(cs_quantity) AS catalog_sales_quantity FROM store_item_join GROUP BY i_item_id, i_item_desc, s_store_id, s_store_name",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_quantity", "store_returns_quantity", "catalog_sales_quantity"], "consumes": ["store_item_join"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, s_store_id, s_store_name, store_sales_quantity, store_returns_quantity, catalog_sales_quantity FROM aggregate ORDER BY i_item_id, i_item_desc, s_store_id, s_store_name LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_quantity", "store_returns_quantity", "catalog_sales_quantity"], "consumes": ["aggregate"]}
      }
    },
    "reconstruction_order": ["d1_cte", "store_sales_d1", "d2_cte", "store_returns_d2", "d3_cte", "catalog_sales_d3", "fact_join", "store_item_join", "aggregate", "main_query"],
    "assembly_template": "WITH d1_cte AS ({d1_cte}), store_sales_d1 AS ({store_sales_d1}), d2_cte AS ({d2_cte}), store_returns_d2 AS ({store_returns_d2}), d3_cte AS ({d3_cte}), catalog_sales_d3 AS ({catalog_sales_d3}), fact_join AS ({fact_join}), store_item_join AS ({store_item_join}), aggregate AS ({aggregate}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

## Changes & Mechanism
**Structural change**: Decomposed the single large implicit join into explicit CTEs that isolate each date_dim alias with its specific filter, pre-joining each with its corresponding fact table before the multi-way fact join.

**Expected mechanism**: By pushing date filters into early CTEs, each fact table scan is reduced before entering the expensive 3-way join. This eliminates the Cartesian product risk of joining all three date_dim instances with all fact rows, while maintaining exact semantic equivalence through preserving all join keys and duplicate-sensitive averages.

**Expected speedup**: 2-3x from eliminating Cartesian blowup and enabling predicate pushdown to each fact table independently.