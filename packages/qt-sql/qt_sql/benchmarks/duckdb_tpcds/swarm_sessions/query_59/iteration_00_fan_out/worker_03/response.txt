### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_periods_cte  [+]  — Filter date_dim to 24-month range, assign period 1 (first 12 months) and period 2 (next 12 months)
├── [CTE] sales_aggregates_cte  [+]  — Join store_sales with date_periods_cte, group by adjusted week (period2 weeks offset by -52), store, period
├── [CTE] period_pivot_cte  [+]  — Pivot sales aggregates by period into separate columns, join with store, filter weeks with data in both periods
└── [MAIN] final_select  [+]  — Compute day-of-week sales ratios, order by store name/id/week, limit 100
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "union_cte_split", "description": "Split generic wss CTE into specialized period-based aggregation with week alignment", "applied_to": ["date_periods_cte", "sales_aggregates_cte"]},
    {"id": "R2", "type": "rollup_to_union_windowing", "description": "Replace self-join with explicit pivoting and week offset adjustment", "applied_to": ["period_pivot_cte", "final_select"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_periods_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_week_seq, d_month_seq, d_day_name, CASE WHEN d_month_seq BETWEEN 1196 AND 1196 + 11 THEN 1 ELSE 2 END AS period FROM date_dim WHERE d_month_seq BETWEEN 1196 AND 1196 + 23",
        "interfaces": {"outputs": ["d_date_sk", "d_week_seq", "d_month_seq", "d_day_name", "period"], "consumes": []}
      },
      "sales_aggregates_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT CASE WHEN period = 2 THEN d_week_seq - 52 ELSE d_week_seq END AS d_week_seq, ss_store_sk, period, SUM(CASE WHEN d_day_name = 'Sunday' THEN ss_sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN d_day_name = 'Monday' THEN ss_sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN d_day_name = 'Tuesday' THEN ss_sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN d_day_name = 'Wednesday' THEN ss_sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN d_day_name = 'Thursday' THEN ss_sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN d_day_name = 'Friday' THEN ss_sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN d_day_name = 'Saturday' THEN ss_sales_price ELSE NULL END) AS sat_sales FROM store_sales JOIN date_periods_cte ON ss_sold_date_sk = d_date_sk GROUP BY CASE WHEN period = 2 THEN d_week_seq - 52 ELSE d_week_seq END, ss_store_sk, period",
        "interfaces": {"outputs": ["d_week_seq", "ss_store_sk", "period", "sun_sales", "mon_sales", "tue_sales", "wed_sales", "thu_sales", "fri_sales", "sat_sales"], "consumes": ["date_periods_cte"]}
      },
      "period_pivot_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_name, s_store_id, pivoted.d_week_seq, sun_sales1, mon_sales1, tue_sales1, wed_sales1, thu_sales1, fri_sales1, sat_sales1, sun_sales2, mon_sales2, tue_sales2, wed_sales2, thu_sales2, fri_sales2, sat_sales2 FROM (SELECT ss_store_sk, d_week_seq, MAX(CASE WHEN period = 1 THEN sun_sales END) AS sun_sales1, MAX(CASE WHEN period = 1 THEN mon_sales END) AS mon_sales1, MAX(CASE WHEN period = 1 THEN tue_sales END) AS tue_sales1, MAX(CASE WHEN period = 1 THEN wed_sales END) AS wed_sales1, MAX(CASE WHEN period = 1 THEN thu_sales END) AS thu_sales1, MAX(CASE WHEN period = 1 THEN fri_sales END) AS fri_sales1, MAX(CASE WHEN period = 1 THEN sat_sales END) AS sat_sales1, MAX(CASE WHEN period = 2 THEN sun_sales END) AS sun_sales2, MAX(CASE WHEN period = 2 THEN mon_sales END) AS mon_sales2, MAX(CASE WHEN period = 2 THEN tue_sales END) AS tue_sales2, MAX(CASE WHEN period = 2 THEN wed_sales END) AS wed_sales2, MAX(CASE WHEN period = 2 THEN thu_sales END) AS thu_sales2, MAX(CASE WHEN period = 2 THEN fri_sales END) AS fri_sales2, MAX(CASE WHEN period = 2 THEN sat_sales END) AS sat_sales2 FROM sales_aggregates_cte GROUP BY ss_store_sk, d_week_seq) pivoted JOIN store ON pivoted.ss_store_sk = store.s_store_sk WHERE sun_sales1 IS NOT NULL AND sun_sales2 IS NOT NULL",
        "interfaces": {"outputs": ["s_store_name", "s_store_id", "d_week_seq", "sun_sales1", "mon_sales1", "tue_sales1", "wed_sales1", "thu_sales1", "fri_sales1", "sat_sales1", "sun_sales2", "mon_sales2", "tue_sales2", "wed_sales2", "thu_sales2", "fri_sales2", "sat_sales2"], "consumes": ["sales_aggregates_cte"]}
      },
      "final_select": {
        "type": "main_query",
        "change": "new",
        "sql": "SELECT s_store_name AS s_store_name1, s_store_id AS s_store_id1, d_week_seq AS d_week_seq1, CASE WHEN sun_sales2 > 0 THEN sun_sales1 / sun_sales2 ELSE NULL END, CASE WHEN mon_sales2 > 0 THEN mon_sales1 / mon_sales2 ELSE NULL END, CASE WHEN tue_sales2 > 0 THEN tue_sales1 / tue_sales2 ELSE NULL END, CASE WHEN wed_sales2 > 0 THEN wed_sales1 / wed_sales2 ELSE NULL END, CASE WHEN thu_sales2 > 0 THEN thu_sales1 / thu_sales2 ELSE NULL END, CASE WHEN fri_sales2 > 0 THEN fri_sales1 / fri_sales2 ELSE NULL END, CASE WHEN sat_sales2 > 0 THEN sat_sales1 / sat_sales2 ELSE NULL END FROM period_pivot_cte ORDER BY s_store_name1 ASC, s_store_id1 ASC, d_week_seq1 ASC LIMIT 100",
        "interfaces": {"outputs": ["s_store_name1", "s_store_id1", "d_week_seq1", "sun_sales1/sun_sales2", "mon_sales1/mon_sales2", "tue_sales1/tue_sales2", "wed_sales1/wed_sales2", "thu_sales1/thu_sales2", "fri_sales1/fri_sales2", "sat_sales1/sat_sales2"], "consumes": ["period_pivot_cte"]}
      }
    },
    "reconstruction_order": ["date_periods_cte", "sales_aggregates_cte", "period_pivot_cte", "final_select"],
    "assembly_template": "WITH date_periods_cte AS ({date_periods_cte}), sales_aggregates_cte AS ({sales_aggregates_cte}), period_pivot_cte AS ({period_pivot_cte}) {final_select}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Replaced the original wss CTE and self-join with explicit period-based CTEs and pivoting. Added week offset adjustment (-52) in the sales_aggregates_cte to align weeks between periods before pivoting. Maintained all original division guards (CASE WHEN denominator > 0).

**Expected speedup:** ~1.5-2x due to elimination of redundant date_dim scans, better predicate pushdown into date_periods_cte, and more efficient week alignment via arithmetic rather than join condition.