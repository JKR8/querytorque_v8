### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_date  [+]
│   └── SCAN date_dim → d_date_sk
├── [CTE] filtered_customer  [+]
│   └── SCAN customer_address → ca_address_sk
├── [CTE] filtered_item  [+]
│   └── SCAN item → i_item_sk, i_item_id
├── [CTE] ss_joined  [~]  (replaces ss CTE)
│   ├── SCAN store_sales
│   ├── JOIN filtered_date (ss_sold_date_sk = d_date_sk)
│   ├── JOIN filtered_customer (ss_addr_sk = ca_address_sk)
│   └── JOIN filtered_item (ss_item_sk = i_item_sk)
├── [CTE] ss_agg  [~]  (replaces ss CTE aggregation)
│   ├── SCAN ss_joined
│   └── AGG GROUP BY i_item_id → SUM(ss_ext_sales_price)
├── [CTE] cs_joined  [~]  (replaces cs CTE)
│   ├── SCAN catalog_sales
│   ├── JOIN filtered_date (cs_sold_date_sk = d_date_sk)
│   ├── JOIN filtered_customer (cs_bill_addr_sk = ca_address_sk)
│   └── JOIN filtered_item (cs_item_sk = i_item_sk)
├── [CTE] cs_agg  [~]  (replaces cs CTE aggregation)
│   ├── SCAN cs_joined
│   └── AGG GROUP BY i_item_id → SUM(cs_ext_sales_price)
├── [CTE] ws_joined  [~]  (replaces ws CTE)
│   ├── SCAN web_sales
│   ├── JOIN filtered_date (ws_sold_date_sk = d_date_sk)
│   ├── JOIN filtered_customer (ws_bill_addr_sk = ca_address_sk)
│   └── JOIN filtered_item (ws_item_sk = i_item_sk)
├── [CTE] ws_agg  [~]  (replaces ws CTE aggregation)
│   ├── SCAN ws_joined
│   └── AGG GROUP BY i_item_id → SUM(ws_ext_sales_price)
├── [CTE] union_all  [+]
│   └── UNION ALL (ss_agg, cs_agg, ws_agg)
└── [MAIN] main_query  [~]  (modified to consume union_all CTE)
    ├── SCAN union_all
    ├── AGG GROUP BY i_item_id → SUM(total_sales)
    ├── SORT total_sales ASC, i_item_id ASC
    └── OUTPUT i_item_id, total_sales
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Extract date_dim filter into dedicated CTE", "applied_to": ["filtered_date"]},
    {"id": "R2", "type": "dimension_cte_isolate", "description": "Extract customer_address filter into dedicated CTE", "applied_to": ["filtered_customer"]},
    {"id": "R3", "type": "dimension_cte_isolate", "description": "Extract item filter into dedicated CTE", "applied_to": ["filtered_item"]},
    {"id": "R4", "type": "prefetch_fact_join", "description": "Stage joins: first join filtered_date with fact table, then other dimensions", "applied_to": ["ss_joined", "cs_joined", "ws_joined"]},
    {"id": "R5", "type": "materialize_cte", "description": "Replace original channel CTEs with staged pipeline CTEs", "applied_to": ["ss_joined", "ss_agg", "cs_joined", "cs_agg", "ws_joined", "ws_agg"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2000 AND d_moy = 2",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_customer": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -6",
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_item_id FROM item WHERE i_color IN ('powder', 'green', 'cyan')",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id"], "consumes": []}
      },
      "ss_joined": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT filtered_item.i_item_id, store_sales.ss_ext_sales_price FROM store_sales INNER JOIN filtered_date ON store_sales.ss_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_customer ON store_sales.ss_addr_sk = filtered_customer.ca_address_sk INNER JOIN filtered_item ON store_sales.ss_item_sk = filtered_item.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "ss_ext_sales_price"], "consumes": ["filtered_date", "filtered_customer", "filtered_item"]}
      },
      "ss_agg": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, SUM(ss_ext_sales_price) AS total_sales FROM ss_joined GROUP BY i_item_id",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["ss_joined"]}
      },
      "cs_joined": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT filtered_item.i_item_id, catalog_sales.cs_ext_sales_price FROM catalog_sales INNER JOIN filtered_date ON catalog_sales.cs_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_customer ON catalog_sales.cs_bill_addr_sk = filtered_customer.ca_address_sk INNER JOIN filtered_item ON catalog_sales.cs_item_sk = filtered_item.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "cs_ext_sales_price"], "consumes": ["filtered_date", "filtered_customer", "filtered_item"]}
      },
      "cs_agg": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, SUM(cs_ext_sales_price) AS total_sales FROM cs_joined GROUP BY i_item_id",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["cs_joined"]}
      },
      "ws_joined": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT filtered_item.i_item_id, web_sales.ws_ext_sales_price FROM web_sales INNER JOIN filtered_date ON web_sales.ws_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_customer ON web_sales.ws_bill_addr_sk = filtered_customer.ca_address_sk INNER JOIN filtered_item ON web_sales.ws_item_sk = filtered_item.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "ws_ext_sales_price"], "consumes": ["filtered_date", "filtered_customer", "filtered_item"]}
      },
      "ws_agg": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, SUM(ws_ext_sales_price) AS total_sales FROM ws_joined GROUP BY i_item_id",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["ws_joined"]}
      },
      "union_all": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, total_sales FROM ss_agg UNION ALL SELECT i_item_id, total_sales FROM cs_agg UNION ALL SELECT i_item_id, total_sales FROM ws_agg",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["ss_agg", "cs_agg", "ws_agg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, SUM(total_sales) AS total_sales FROM union_all GROUP BY i_item_id ORDER BY total_sales ASC, i_item_id ASC LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["union_all"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_customer", "filtered_item", "ss_joined", "ss_agg", "cs_joined", "cs_agg", "ws_joined", "ws_agg", "union_all", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_customer AS ({filtered_customer}), filtered_item AS ({filtered_item}), ss_joined AS ({ss_joined}), ss_agg AS ({ss_agg}), cs_joined AS ({cs_joined}), cs_agg AS ({cs_agg}), ws_joined AS ({ws_joined}), ws_agg AS ({ws_agg}), union_all AS ({union_all}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Changes & Mechanism

**Changes:** Restructured original three monolithic channel CTEs into a staged pipeline: first pre-filter dimension tables into tiny CTEs (date, customer, item), then join each fact table sequentially with those filtered dimensions, followed by per-channel aggregation, union, and final aggregation.

**Expected speedup:** 2-4x. The rewrite isolates dimension filters into materializable CTEs that create small hash tables for joins, avoiding repeated full table scans. Each fact table joins only with pre-filtered dimension keys, significantly reducing probe cost. DuckDB can push predicates within each CTE chain but not across CTE boundaries, making this explicit staging optimal for its optimizer.