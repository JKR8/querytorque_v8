### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_date [+]
│   └── SCAN date_dim → OUTPUT d_date_sk
├── [CTE] filtered_customer [+]
│   └── SCAN customer_address → OUTPUT ca_address_sk
├── [CTE] filtered_item [+]
│   └── SCAN item → OUTPUT i_item_sk, i_item_id
├── [CTE] ss_filtered [+]
│   ├── SCAN store_sales → ss_item_sk, ss_ext_sales_price
│   ├── JOIN filtered_date ON ss_sold_date_sk = d_date_sk
│   └── JOIN filtered_customer ON ss_addr_sk = ca_address_sk
├── [CTE] ss_with_item [+]
│   ├── SCAN ss_filtered
│   └── JOIN filtered_item ON ss_item_sk = i_item_sk
├── [CTE] ss_agg [+]
│   └── AGG (GROUP BY i_item_id) → OUTPUT i_item_id, total_sales
├── [CTE] cs_filtered [+]
│   ├── SCAN catalog_sales → cs_item_sk, cs_ext_sales_price
│   ├── JOIN filtered_date ON cs_sold_date_sk = d_date_sk
│   └── JOIN filtered_customer ON cs_bill_addr_sk = ca_address_sk
├── [CTE] cs_with_item [+]
│   ├── SCAN cs_filtered
│   └── JOIN filtered_item ON cs_item_sk = i_item_sk
├── [CTE] cs_agg [+]
│   └── AGG (GROUP BY i_item_id) → OUTPUT i_item_id, total_sales
├── [CTE] ws_filtered [+]
│   ├── SCAN web_sales → ws_item_sk, ws_ext_sales_price
│   ├── JOIN filtered_date ON ws_sold_date_sk = d_date_sk
│   └── JOIN filtered_customer ON ws_bill_addr_sk = ca_address_sk
├── [CTE] ws_with_item [+]
│   ├── SCAN ws_filtered
│   └── JOIN filtered_item ON ws_item_sk = i_item_sk
├── [CTE] ws_agg [+]
│   └── AGG (GROUP BY i_item_id) → OUTPUT i_item_id, total_sales
├── [CTE] union_all [+]
│   └── UNION ALL (ss_agg, cs_agg, ws_agg)
└── [MAIN] main_query [~]
    ├── SCAN union_all
    ├── AGG (GROUP BY i_item_id) → SUM(total_sales) AS total_sales
    ├── SORT (total_sales ASC, i_item_id ASC)
    └── OUTPUT (i_item_id, total_sales) LIMIT 100
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb_v1.4.3",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter date_dim, customer_address, item into separate CTEs before joining with fact tables", "applied_to": ["filtered_date", "filtered_customer", "filtered_item"]},
    {"id": "R2", "type": "prefetch_fact_join", "description": "Staged join pipeline: filter date/customer first, join with fact table, then join item", "applied_to": ["ss_filtered", "cs_filtered", "ws_filtered"]},
    {"id": "R3", "type": "early_filter", "description": "Apply all dimension filters early before aggregation", "applied_to": ["filtered_date", "filtered_customer", "filtered_item"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2000 AND d_moy = 2",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_customer": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -6",
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_id FROM item WHERE i_color IN ('powder', 'green', 'cyan')",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id"], "consumes": []}
      },
      "ss_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss.ss_item_sk, ss.ss_ext_sales_price FROM store_sales ss INNER JOIN filtered_date fd ON ss.ss_sold_date_sk = fd.d_date_sk INNER JOIN filtered_customer fc ON ss.ss_addr_sk = fc.ca_address_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_ext_sales_price"], "consumes": ["filtered_date", "filtered_customer"]}
      },
      "ss_with_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT fi.i_item_id, sf.ss_ext_sales_price FROM ss_filtered sf INNER JOIN filtered_item fi ON sf.ss_item_sk = fi.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "ss_ext_sales_price"], "consumes": ["ss_filtered", "filtered_item"]}
      },
      "ss_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id, SUM(ss_ext_sales_price) AS total_sales FROM ss_with_item GROUP BY i_item_id",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["ss_with_item"]}
      },
      "cs_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cs.cs_item_sk, cs.cs_ext_sales_price FROM catalog_sales cs INNER JOIN filtered_date fd ON cs.cs_sold_date_sk = fd.d_date_sk INNER JOIN filtered_customer fc ON cs.cs_bill_addr_sk = fc.ca_address_sk",
        "interfaces": {"outputs": ["cs_item_sk", "cs_ext_sales_price"], "consumes": ["filtered_date", "filtered_customer"]}
      },
      "cs_with_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT fi.i_item_id, cf.cs_ext_sales_price FROM cs_filtered cf INNER JOIN filtered_item fi ON cf.cs_item_sk = fi.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "cs_ext_sales_price"], "consumes": ["cs_filtered", "filtered_item"]}
      },
      "cs_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id, SUM(cs_ext_sales_price) AS total_sales FROM cs_with_item GROUP BY i_item_id",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["cs_with_item"]}
      },
      "ws_filtered": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ws.ws_item_sk, ws.ws_ext_sales_price FROM web_sales ws INNER JOIN filtered_date fd ON ws.ws_sold_date_sk = fd.d_date_sk INNER JOIN filtered_customer fc ON ws.ws_bill_addr_sk = fc.ca_address_sk",
        "interfaces": {"outputs": ["ws_item_sk", "ws_ext_sales_price"], "consumes": ["filtered_date", "filtered_customer"]}
      },
      "ws_with_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT fi.i_item_id, wf.ws_ext_sales_price FROM ws_filtered wf INNER JOIN filtered_item fi ON wf.ws_item_sk = fi.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "ws_ext_sales_price"], "consumes": ["ws_filtered", "filtered_item"]}
      },
      "ws_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id, SUM(ws_ext_sales_price) AS total_sales FROM ws_with_item GROUP BY i_item_id",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["ws_with_item"]}
      },
      "union_all": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id, total_sales FROM ss_agg UNION ALL SELECT i_item_id, total_sales FROM cs_agg UNION ALL SELECT i_item_id, total_sales FROM ws_agg",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["ss_agg", "cs_agg", "ws_agg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, SUM(total_sales) AS total_sales FROM union_all GROUP BY i_item_id ORDER BY total_sales, i_item_id LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "total_sales"], "consumes": ["union_all"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_customer", "filtered_item", "ss_filtered", "ss_with_item", "ss_agg", "cs_filtered", "cs_with_item", "cs_agg", "ws_filtered", "ws_with_item", "ws_agg", "union_all", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_customer AS ({filtered_customer}), filtered_item AS ({filtered_item}), ss_filtered AS ({ss_filtered}), ss_with_item AS ({ss_with_item}), ss_agg AS ({ss_agg}), cs_filtered AS ({cs_filtered}), cs_with_item AS ({cs_with_item}), cs_agg AS ({cs_agg}), ws_filtered AS ({ws_filtered}), ws_with_item AS ({ws_with_item}), ws_agg AS ({ws_agg}), union_all AS ({union_all}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured to pre-filter dimensions into CTEs and use staged join pipeline (date/customer → fact table → item), eliminating cross-joins of dimension tables while preserving INNER JOIN semantics. Each sales channel follows the same isolated pipeline.

**Expected speedup**: 3-4x (similar to early_filter and prefetch_fact_join examples) by reducing fact table scans via early dimension filtering and avoiding Cartesian explosion.