## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_dates  [+]  — Extract date keys for weeks containing three reference dates
│   ├── SCAN (date_dim)
│   ├── FILTER (d_week_seq IN (subquery))
│   └── OUTPUT (d_date_sk, d_date)
├── [CTE] sr_items  [~]  — Aggregate store returns filtered through filtered_dates
│   ├── SCAN (store_returns, item, filtered_dates)
│   ├── JOIN (sr_returned_date_sk = d_date_sk)
│   ├── JOIN (sr_item_sk = i_item_sk)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (item_id, sr_item_qty)
├── [CTE] cr_items  [~]  — Aggregate catalog returns filtered through filtered_dates
│   ├── SCAN (catalog_returns, item, filtered_dates)
│   ├── JOIN (cr_returned_date_sk = d_date_sk)
│   ├── JOIN (cr_item_sk = i_item_sk)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (item_id, cr_item_qty)
├── [CTE] wr_items  [~]  — Aggregate web returns filtered through filtered_dates
│   ├── SCAN (web_returns, item, filtered_dates)
│   ├── JOIN (wr_returned_date_sk = d_date_sk)
│   ├── JOIN (wr_item_sk = i_item_sk)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (item_id, wr_item_qty)
└── [MAIN] main_query  [=]  — Join channel aggregates and compute deviations
    ├── SCAN (sr_items, cr_items, wr_items)
    ├── JOIN (sr_items.item_id = cr_items.item_id)
    ├── JOIN (sr_items.item_id = wr_items.item_id)
    ├── SORT (sr_items.item_id, sr_item_qty)
    └── OUTPUT (item_id, sr_item_qty, sr_dev, cr_item_qty, cr_dev, wr_item_qty, wr_dev, average)
```

**Changes:**
- Added `filtered_dates` CTE that isolates the date filter (replaces nested subqueries)
- Modified `sr_items`, `cr_items`, `wr_items` CTEs to join with `filtered_dates` instead of repeating date subqueries
- Kept all other logic identical (joins, grouping, output expressions, ordering)

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "date_cte_isolate", "description": "Extract recurring date filter into reusable CTE", "applied_to": ["filtered_dates", "sr_items", "cr_items", "wr_items"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_week_seq IN (SELECT d_week_seq FROM date_dim WHERE d_date IN ('2001-06-06','2001-09-02','2001-11-11'))",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "sr_items": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id AS item_id, SUM(sr_return_quantity) AS sr_item_qty FROM store_returns JOIN filtered_dates ON sr_returned_date_sk = d_date_sk JOIN item ON sr_item_sk = i_item_sk GROUP BY i_item_id",
        "interfaces": {"outputs": ["item_id", "sr_item_qty"], "consumes": ["filtered_dates"]}
      },
      "cr_items": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id AS item_id, SUM(cr_return_quantity) AS cr_item_qty FROM catalog_returns JOIN filtered_dates ON cr_returned_date_sk = d_date_sk JOIN item ON cr_item_sk = i_item_sk GROUP BY i_item_id",
        "interfaces": {"outputs": ["item_id", "cr_item_qty"], "consumes": ["filtered_dates"]}
      },
      "wr_items": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_id AS item_id, SUM(wr_return_quantity) AS wr_item_qty FROM web_returns JOIN filtered_dates ON wr_returned_date_sk = d_date_sk JOIN item ON wr_item_sk = i_item_sk GROUP BY i_item_id",
        "interfaces": {"outputs": ["item_id", "wr_item_qty"], "consumes": ["filtered_dates"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["item_id", "sr_item_qty", "sr_dev", "cr_item_qty", "cr_dev", "wr_item_qty", "wr_dev", "average"], "consumes": ["sr_items", "cr_items", "wr_items"]}
      }
    },
    "reconstruction_order": ["filtered_dates", "sr_items", "cr_items", "wr_items", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), sr_items AS ({sr_items}), cr_items AS ({cr_items}), wr_items AS ({wr_items}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Final SQL Assembly:**
```sql
WITH filtered_dates AS (
  SELECT d_date_sk, d_date 
  FROM date_dim 
  WHERE d_week_seq IN (
    SELECT d_week_seq 
    FROM date_dim 
    WHERE d_date IN ('2001-06-06','2001-09-02','2001-11-11')
  )
), 
sr_items AS (
  SELECT i_item_id AS item_id, 
         SUM(sr_return_quantity) AS sr_item_qty
  FROM store_returns 
  JOIN filtered_dates ON sr_returned_date_sk = d_date_sk 
  JOIN item ON sr_item_sk = i_item_sk
  GROUP BY i_item_id
), 
cr_items AS (
  SELECT i_item_id AS item_id, 
         SUM(cr_return_quantity) AS cr_item_qty
  FROM catalog_returns 
  JOIN filtered_dates ON cr_returned_date_sk = d_date_sk 
  JOIN item ON cr_item_sk = i_item_sk
  GROUP BY i_item_id
), 
wr_items AS (
  SELECT i_item_id AS item_id, 
         SUM(wr_return_quantity) AS wr_item_qty
  FROM web_returns 
  JOIN filtered_dates ON wr_returned_date_sk = d_date_sk 
  JOIN item ON wr_item_sk = i_item_sk
  GROUP BY i_item_id
)
SELECT sr_items.item_id,
       sr_item_qty,
       sr_item_qty/(sr_item_qty+cr_item_qty+wr_item_qty)/3.0 * 100 AS sr_dev,
       cr_item_qty,
       cr_item_qty/(sr_item_qty+cr_item_qty+wr_item_qty)/3.0 * 100 AS cr_dev,
       wr_item_qty,
       wr_item_qty/(sr_item_qty+cr_item_qty+wr_item_qty)/3.0 * 100 AS wr_dev,
       (sr_item_qty+cr_item_qty+wr_item_qty)/3.0 AS average
FROM sr_items
JOIN cr_items ON sr_items.item_id = cr_items.item_id
JOIN wr_items ON sr_items.item_id = wr_items.item_id
ORDER BY sr_items.item_id, sr_item_qty
LIMIT 100;
```

**Changes:** Isolated the recurring date filter (scanned 9 times in original) into a single CTE that's reused by all three channel aggregations, eliminating redundant date_dim scans while preserving the exact same date semantics and output.

**Expected speedup:** 1.5-2.0x - Reduces 9 date_dim scans to 1, and enables predicate pushdown into fact table joins via the small filtered_dates CTE (21 rows). CTE overhead minimal due to small size and multiple references.