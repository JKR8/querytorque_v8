You are coordinating a swarm of 4 optimization specialists. Each specialist will attempt to optimize the same query using a DIFFERENT strategy and set of examples.

Your job: analyze the query structure, identify 4 diverse optimization angles, and assign each specialist a unique strategy with 3 relevant examples. Maximize diversity to cover the optimization space.

## Query: q35
## Dialect: duckdb

```sql
-- start query 35 in stream 0 using template query35.tpl
select  
  ca_state,
  cd_gender,
  cd_marital_status,
  cd_dep_count,
  count(*) cnt1,
  max(cd_dep_count),
  sum(cd_dep_count),
  max(cd_dep_count),
  cd_dep_employed_count,
  count(*) cnt2,
  max(cd_dep_employed_count),
  sum(cd_dep_employed_count),
  max(cd_dep_employed_count),
  cd_dep_college_count,
  count(*) cnt3,
  max(cd_dep_college_count),
  sum(cd_dep_college_count),
  max(cd_dep_college_count)
 from
  customer c,customer_address ca,customer_demographics
 where
  c.c_current_addr_sk = ca.ca_address_sk and
  cd_demo_sk = c.c_current_cdemo_sk and 
  exists (select *
          from store_sales,date_dim
          where c.c_customer_sk = ss_customer_sk and
                ss_sold_date_sk = d_date_sk and
                d_year = 2001 and
                d_qoy < 4) and
   (exists (select *
            from web_sales,date_dim
            where c.c_customer_sk = ws_bill_customer_sk and
                  ws_sold_date_sk = d_date_sk and
                  d_year = 2001 and
                  d_qoy < 4) or 
    exists (select * 
            from catalog_sales,date_dim
            where c.c_customer_sk = cs_ship_customer_sk and
                  cs_sold_date_sk = d_date_sk and
                  d_year = 2001 and
                  d_qoy < 4))
 group by ca_state,
          cd_gender,
          cd_marital_status,
          cd_dep_count,
          cd_dep_employed_count,
          cd_dep_college_count
 order by ca_state,
          cd_gender,
          cd_marital_status,
          cd_dep_count,
          cd_dep_employed_count,
          cd_dep_college_count
 LIMIT 100;

-- end query 35 in stream 0 using template query35.tpl
```

## DAG Structure & Bottlenecks

| Node | Role | Cost % | Key Operations |
|------|------|-------:|----------------|
| main_query |  | 0.0% | — |

## Top 12 Matched Examples (by structural similarity)

1. **composite_decorrelate_union** (2.42x) — Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT customer CTEs with a shared date filter
2. **or_to_union** (3.17x) — Split OR conditions on different columns into UNION ALL branches for better index usage
3. **intersect_to_exists** (1.83x) — Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join planning
4. **multi_intersect_exists_cte** (2.39x) — Convert cascading INTERSECT operations into correlated EXISTS subqueries with pre-materialized date and channel CTEs
5. **union_cte_split** (1.36x) — Split a generic UNION ALL CTE into specialized CTEs when the main query filters by year or discriminator - eliminates re
6. **date_cte_isolate** (4.00x) — Extract date filtering into a separate CTE to enable predicate pushdown and reduce scans
7. **dimension_cte_isolate** (1.93x) — Pre-filter ALL dimension tables into CTEs before joining with fact table, not just date_dim
8. **multi_date_range_cte** (2.35x) — When query uses multiple date_dim aliases with different filters (d1, d2, d3), create separate CTEs for each date range 
9. **prefetch_fact_join** (3.77x) — Pre-filter dimension table into CTE, then pre-join with fact table in second CTE before joining other dimensions
10. **shared_dimension_multi_channel** (1.30x) — Extract shared dimension filters (date, item, promotion) into CTEs when multiple channel CTEs (store/catalog/web) apply 
11. **deferred_window_aggregation** (1.36x) — When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joined with FULL OUTER JOIN followed by ano
12. **materialize_cte** (1.37x) — Extract repeated subquery patterns into a CTE to avoid recomputation

## All Available Examples (full catalog — can swap if needed)

- **channel_bitmap_aggregation** (6.24x) — Consolidate repeated scans of the same fact table (one per time/channel bucket) 
- **composite_decorrelate_union** (2.42x) — Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT
- **date_cte_isolate** (4.00x) — Extract date filtering into a separate CTE to enable predicate pushdown and redu
- **decorrelate** (2.92x) — Convert correlated subquery to separate CTE with GROUP BY, then JOIN
- **deferred_window_aggregation** (1.36x) — When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joi
- **dimension_cte_isolate** (1.93x) — Pre-filter ALL dimension tables into CTEs before joining with fact table, not ju
- **early_filter** (4.00x) — Filter dimension tables FIRST, then join to fact tables to reduce expensive join
- **intersect_to_exists** (1.83x) — Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join pl
- **materialize_cte** (1.37x) — Extract repeated subquery patterns into a CTE to avoid recomputation
- **multi_date_range_cte** (2.35x) — When query uses multiple date_dim aliases with different filters (d1, d2, d3), c
- **multi_dimension_prefetch** (2.71x) — Pre-filter multiple dimension tables (date + store) into separate CTEs before jo
- **multi_intersect_exists_cte** (2.39x) — Convert cascading INTERSECT operations into correlated EXISTS subqueries with pr
- **or_to_union** (3.17x) — Split OR conditions on different columns into UNION ALL branches for better inde
- **prefetch_fact_join** (3.77x) — Pre-filter dimension table into CTE, then pre-join with fact table in second CTE
- **pushdown** (2.11x) — Push filters from outer query into CTEs/subqueries to reduce intermediate result
- **rollup_to_union_windowing** (2.47x) — Replace GROUP BY ROLLUP with explicit UNION ALL of pre-aggregated CTEs at each h
- **shared_dimension_multi_channel** (1.30x) — Extract shared dimension filters (date, item, promotion) into CTEs when multiple
- **single_pass_aggregation** (4.47x) — Consolidate multiple subqueries scanning the same table into a single CTE with c
- **union_cte_split** (1.36x) — Split a generic UNION ALL CTE into specialized CTEs when the main query filters 

## Regression Warnings (review relevance to THIS query)

These transforms caused regressions on structurally similar queries. Review each — if relevant to this query, AVOID the listed transform. If not relevant (different structure/bottleneck), you may ignore.

- **regression_q31_pushdown** (0.49x) — Created both filtered (store_sales_agg, web_sales_agg) AND original (ss, ws) versions of the same aggregations. The quer
- **regression_q74_pushdown** (0.68x) — Created year-specific CTEs (store_sales_1999, store_sales_2000, etc.) but KEPT the original year_total union CTE alongsi
- **regression_q16_semantic_rewrite** (0.14x) — Materialized a GROUP BY self-join (HAVING MIN() <> MAX()) on the entire fact table BEFORE applying date/address/call_cen

## Your Task

Design 4 DIFFERENT optimization strategies exploring diverse approaches. You may keep the matched recommendations OR swap examples from the catalog.

**Constraints**:
- Each worker gets exactly 3 examples
- No duplicate examples across workers (12 total, 3 per worker)
- If fewer than 12 unique examples are available, reuse is allowed

**Diversity guidelines**:
- Worker 1: Conservative — proven patterns, low risk (e.g., pushdown, early filter)
- Worker 2: Moderate — date/dimension isolation, CTE restructuring
- Worker 3: Aggressive — multi-CTE restructuring, prefetch patterns
- Worker 4: Novel — OR-to-UNION, structural transforms, intersect-to-exists

For each worker, specify:
1. **Strategy name** (e.g., `aggressive_date_prefetch`)
2. **3 examples** to use (from matched picks or catalog)
3. **Strategy hint** (1-2 sentences guiding the optimization approach)

### Output Format (follow EXACTLY)

```
WORKER_1:
STRATEGY: <strategy_name>
EXAMPLES: <ex1>, <ex2>, <ex3>
HINT: <strategy guidance>

WORKER_2:
STRATEGY: <strategy_name>
EXAMPLES: <ex4>, <ex5>, <ex6>
HINT: <strategy guidance>

WORKER_3:
STRATEGY: <strategy_name>
EXAMPLES: <ex7>, <ex8>, <ex9>
HINT: <strategy guidance>

WORKER_4:
STRATEGY: <strategy_name>
EXAMPLES: <ex10>, <ex11>, <ex12>
HINT: <strategy guidance>
```