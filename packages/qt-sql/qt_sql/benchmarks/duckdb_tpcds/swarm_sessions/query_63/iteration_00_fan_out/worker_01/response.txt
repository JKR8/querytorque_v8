### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query [~] Cost: 100% Rows: ~1K — Restructured into explicit CTE chain per target logical tree
    ├── [~] filtered_date (CTE) — FROM date_dim with month sequence filter
    ├── [~] filtered_item (CTE) — FROM item with original OR condition
    ├── [~] filtered_store (CTE) — FROM store with s_store_sk ≤ 100
    ├── [~] prefetched_sales (CTE) — INNER JOIN of store_sales with three filtered CTEs
    ├── [~] aggregated_sales (CTE) — GROUP BY i_manager_id, d_moy with SUM(ss_sales_price)
    ├── [~] windowed (CTE) — WINDOW AVG(sum_sales) OVER (PARTITION BY i_manager_id)
    ├── [=] FILTER (CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1)
    ├── [=] SORT (i_manager_id ASC, avg_monthly_sales ASC, sum_sales ASC)
    ├── [=] LIMIT 100
    └── OUTPUT (*)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "prefetch_fact_join",
      "description": "Materialize filtered dimension tables (date_dim, item, store) into CTEs before joining with fact table store_sales, enabling predicate pushdown",
      "applied_to": ["filtered_date", "filtered_item", "filtered_store", "prefetched_sales", "aggregated_sales", "windowed"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_date": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT d_date_sk, d_moy FROM date_dim WHERE d_month_seq IN (1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192)",
          "interfaces": {
            "outputs": ["d_date_sk", "d_moy"],
            "consumes": []
          }
        },
        "filtered_item": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i_item_sk, i_manager_id FROM item WHERE ((i_category IN ('Books','Children','Electronics') AND i_class IN ('personal','portable','reference','self-help') AND i_brand IN ('scholaramalgamalg #14','scholaramalgamalg #7','exportiunivamalg #9','scholaramalgamalg #9')) OR (i_category IN ('Women','Music','Men') AND i_class IN ('accessories','classical','fragrances','pants') AND i_brand IN ('amalgimporto #1','edu packscholar #1','exportiimporto #1','importoamalg #1')))",
          "interfaces": {
            "outputs": ["i_item_sk", "i_manager_id"],
            "consumes": []
          }
        },
        "filtered_store": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT s_store_sk FROM store WHERE s_store_sk <= 100",
          "interfaces": {
            "outputs": ["s_store_sk"],
            "consumes": []
          }
        },
        "prefetched_sales": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT it.i_manager_id, fd.d_moy, ss.ss_sales_price FROM store_sales ss INNER JOIN filtered_date fd ON ss.ss_sold_date_sk = fd.d_date_sk INNER JOIN filtered_item it ON ss.ss_item_sk = it.i_item_sk INNER JOIN filtered_store fs ON ss.ss_store_sk = fs.s_store_sk",
          "interfaces": {
            "outputs": ["i_manager_id", "d_moy", "ss_sales_price"],
            "consumes": ["filtered_date", "filtered_item", "filtered_store"]
          }
        },
        "aggregated_sales": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i_manager_id, d_moy, SUM(ss_sales_price) AS sum_sales FROM prefetched_sales GROUP BY i_manager_id, d_moy",
          "interfaces": {
            "outputs": ["i_manager_id", "d_moy", "sum_sales"],
            "consumes": ["prefetched_sales"]
          }
        },
        "windowed": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT i_manager_id, sum_sales, AVG(sum_sales) OVER (PARTITION BY i_manager_id) AS avg_monthly_sales, d_moy FROM aggregated_sales",
          "interfaces": {
            "outputs": ["i_manager_id", "sum_sales", "avg_monthly_sales", "d_moy"],
            "consumes": ["aggregated_sales"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_manager_id, sum_sales, avg_monthly_sales FROM windowed WHERE CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1 ORDER BY i_manager_id ASC, avg_monthly_sales ASC, sum_sales ASC LIMIT 100",
          "interfaces": {
            "outputs": ["i_manager_id", "sum_sales", "avg_monthly_sales"],
            "consumes": ["windowed"]
          }
        }
      },
      "reconstruction_order": ["filtered_date", "filtered_item", "filtered_store", "prefetched_sales", "aggregated_sales", "windowed", "main_query"],
      "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_item AS ({filtered_item}), filtered_store AS ({filtered_store}), prefetched_sales AS ({prefetched_sales}), aggregated_sales AS ({aggregated_sales}), windowed AS ({windowed}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured original four-table join into a CTE chain that prefilters dimensions before joining with the fact table. This enables predicate pushdown into dimension scans while preserving exact semantics (INNER JOINs, original OR condition, defensive division guard, window partitioning, and final ordering/limit).

**Expected speedup:** ~1.5–2× due to reduced fact table scan cost from early dimension filtering (baseline 438 ms).