You are a SQL rewrite engine for DuckDB v1.4.3. Follow the Target Logical Tree structure below. Your job is to write correct, executable SQL for each node — not to decide whether to restructure. Preserve exact semantic equivalence (same rows, same columns, same ordering). Preserve defensive guards: if the original uses CASE WHEN x > 0 THEN y/x END around a division, keep it — even when a WHERE clause makes the zero case unreachable. Guards prevent silent breakage if filters change upstream. Strip benchmark comments (-- start query, -- end query) from your output.

DuckDB specifics: columnar storage (SELECT only needed columns). CTEs referenced once are typically inlined; CTEs referenced multiple times may be materialized. FILTER clause is native (`COUNT(*) FILTER (WHERE cond)`). Predicate pushdown stops at UNION ALL boundaries and multi-level CTE references.

## Semantic Contract (MUST preserve)

Find item managers with monthly sales volatility over month sequence 1181-1192 for selected item attribute bundles by flagging months that differ more than 10% from the manager's average monthly sales. All joins are INNER (intersection), requiring matches in all four tables. The AVG(SUM(...)) OVER window function is grouping-sensitive but safe because partition column (i_manager_id) is in GROUP BY; any rewrite must preserve exact (i_manager_id, d_moy) groups and row membership. The outer filter depends on avg_monthly_sales being computed per i_manager_id; splitting the window function incorrectly would break the deviation calculation.

## Target Logical Tree + Node Contracts

Build your rewrite following this CTE structure. Each node's OUTPUT list is exhaustive — your SQL must produce exactly those columns.

TARGET_LOGICAL_TREE:
filtered_date -> filtered_item -> filtered_store -> prefetched_sales -> aggregated_sales -> windowed -> filtered -> ordered -> limited
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_month_seq IN (1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192)
    OUTPUT: d_date_sk, d_moy
    EXPECTED_ROWS: 365
    CONSUMERS: prefetched_sales
  filtered_item:
    FROM: item
    WHERE: ((i_category IN ('Books','Children','Electronics') AND i_class IN ('personal','portable','reference','self-help') AND i_brand IN ('scholaramalgamalg #14','scholaramalgamalg #7','exportiunivamalg #9','scholaramalgamalg #9')) OR (i_category IN ('Women','Music','Men') AND i_class IN ('accessories','classical','fragrances','pants') AND i_brand IN ('amalgimporto #1','edu packscholar #1','exportiimporto #1','importoamalg #1')))
    OUTPUT: i_item_sk, i_manager_id
    EXPECTED_ROWS: 5,279
    CONSUMERS: prefetched_sales
  filtered_store:
    FROM: store
    WHERE: s_store_sk <= 100
    OUTPUT: s_store_sk
    EXPECTED_ROWS: 100
    CONSUMERS: prefetched_sales
  prefetched_sales:
    FROM: store_sales
    JOIN: INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk
          INNER JOIN filtered_item ON ss_item_sk = i_item_sk
          INNER JOIN filtered_store ON ss_store_sk = s_store_sk
    OUTPUT: i_manager_id, d_moy, ss_sales_price
    EXPECTED_ROWS: 373K
    CONSUMERS: aggregated_sales
  aggregated_sales:
    FROM: prefetched_sales
    GROUP BY: i_manager_id, d_moy
    AGGREGATE: sum(ss_sales_price) AS sum_sales
    OUTPUT: i_manager_id, d_moy, sum_sales
    EXPECTED_ROWS: 1,200
    CONSUMERS: windowed
  windowed:
    FROM: aggregated_sales
    WINDOW: AVG(sum_sales) OVER (PARTITION BY i_manager_id) AS avg_monthly_sales
    OUTPUT: i_manager_id, sum_sales, avg_monthly_sales, d_moy
    EXPECTED_ROWS: 1,200
    CONSUMERS: filtered
  filtered:
    FROM: windowed
    WHERE: CASE WHEN avg_monthly_sales > 0 THEN abs(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1
    OUTPUT: i_manager_id, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: ~1K
    CONSUMERS: ordered
  ordered:
    FROM: filtered
    ORDER BY: i_manager_id ASC, avg_monthly_sales ASC, sum_sales ASC
    OUTPUT: i_manager_id, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: ~1K
    CONSUMERS: limited
  limited:
    FROM: ordered
    LIMIT: 100
    OUTPUT: i_manager_id, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 100
    CONSUMERS: final

NODE_CONTRACTS:
filtered_date:
    FROM: date_dim
    WHERE: d_month_seq IN (1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192)
    OUTPUT: d_date_sk, d_moy
    EXPECTED_ROWS: 365
    CONSUMERS: prefetched_sales
  filtered_item:
    FROM: item
    WHERE: ((i_category IN ('Books','Children','Electronics') AND i_class IN ('personal','portable','reference','self-help') AND i_brand IN ('scholaramalgamalg #14','scholaramalgamalg #7','exportiunivamalg #9','scholaramalgamalg #9')) OR (i_category IN ('Women','Music','Men') AND i_class IN ('accessories','classical','fragrances','pants') AND i_brand IN ('amalgimporto #1','edu packscholar #1','exportiimporto #1','importoamalg #1')))
    OUTPUT: i_item_sk, i_manager_id
    EXPECTED_ROWS: 5,279
    CONSUMERS: prefetched_sales
  filtered_store:
    FROM: store
    WHERE: s_store_sk <= 100
    OUTPUT: s_store_sk
    EXPECTED_ROWS: 100
    CONSUMERS: prefetched_sales
  prefetched_sales:
    FROM: store_sales
    JOIN: INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk
          INNER JOIN filtered_item ON ss_item_sk = i_item_sk
          INNER JOIN filtered_store ON ss_store_sk = s_store_sk
    OUTPUT: i_manager_id, d_moy, ss_sales_price
    EXPECTED_ROWS: 373K
    CONSUMERS: aggregated_sales
  aggregated_sales:
    FROM: prefetched_sales
    GROUP BY: i_manager_id, d_moy
    AGGREGATE: sum(ss_sales_price) AS sum_sales
    OUTPUT: i_manager_id, d_moy, sum_sales
    EXPECTED_ROWS: 1,200
    CONSUMERS: windowed
  windowed:
    FROM: aggregated_sales
    WINDOW: AVG(sum_sales) OVER (PARTITION BY i_manager_id) AS avg_monthly_sales
    OUTPUT: i_manager_id, sum_sales, avg_monthly_sales, d_moy
    EXPECTED_ROWS: 1,200
    CONSUMERS: filtered
  filtered:
    FROM: windowed
    WHERE: CASE WHEN avg_monthly_sales > 0 THEN abs(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1
    OUTPUT: i_manager_id, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: ~1K
    CONSUMERS: ordered
  ordered:
    FROM: filtered
    ORDER BY: i_manager_id ASC, avg_monthly_sales ASC, sum_sales ASC
    OUTPUT: i_manager_id, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: ~1K
    CONSUMERS: limited
  limited:
    FROM: ordered
    LIMIT: 100
    OUTPUT: i_manager_id, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 100
    CONSUMERS: final

## Hazard Flags (avoid these specific risks)

- Overhead of materializing three dimension CTEs may not outweigh benefit if fact table join is already fast.
- Must preserve original OR condition in filtered_item CTE exactly.

## Regression Warnings (observed failures on similar queries)

1. or_to_union (observed regression 0.59x):
   CAUSE: Splitting same-column OR conditions (time range) duplicated fact table scans with no selectivity benefit.
   RULE: Do NOT split OR on same table (item) into UNION ALL for this query; keep original OR.
2. date_cte_isolate (observed regression 0.5x):
   CAUSE: Baseline query <100ms, CTE materialization overhead dominated savings.
   RULE: This query baseline is 438ms (>100ms), so CTE overhead acceptable.
3. prefetch_fact_join (observed regression 0.5x):
   CAUSE: Baseline <50ms, CTE overhead dominated.
   RULE: Baseline 438ms, safe to apply.

## Constraints (analyst-filtered for this query)

- COMPLETE_OUTPUT: Must output all columns from original SELECT (*) which expands to i_manager_id, sum_sales, avg_monthly_sales.
- CTE_COLUMN_COMPLETENESS: Any CTE must include all columns referenced downstream: ss_item_sk, ss_sold_date_sk, ss_store_sk, i_item_sk, i_manager_id, d_date_sk, d_moy, s_store_sk, ss_sales_price.
- LITERAL_PRESERVATION: Must preserve exact literal values in d_month_seq (1181..1192) and item category/class/brand strings.
- SEMANTIC_EQUIVALENCE: Must return same rows, columns, and ordering.
- CROSS_CTE_PREDICATE_BLINDNESS: EXPLAIN shows store_sales scanned fully before dimension filters applied; pre-filtering dimensions into CTEs can push predicates earlier.
- REDUNDANT_SCAN_ELIMINATION: Single fact scan; no redundancy.

## Example Adaptation Notes

For each example: what to apply to your rewrite, and what to ignore.

- Apply the prefetch_fact_join pattern exactly as in Q63: create CTEs for filtered dimensions, then join with fact table. Ignore that Q63 already is this query; use the pattern from the example's structure.

## Original SQL

```sql
-- start query 63 in stream 0 using template query63.tpl
select * 
from (select i_manager_id
             ,sum(ss_sales_price) sum_sales
             ,avg(sum(ss_sales_price)) over (partition by i_manager_id) avg_monthly_sales
      from item
          ,store_sales
          ,date_dim
          ,store
      where ss_item_sk = i_item_sk
        and ss_sold_date_sk = d_date_sk
        and ss_store_sk = s_store_sk
        and d_month_seq in (1181,1181+1,1181+2,1181+3,1181+4,1181+5,1181+6,1181+7,1181+8,1181+9,1181+10,1181+11)
        and ((    i_category in ('Books','Children','Electronics')
              and i_class in ('personal','portable','reference','self-help')
              and i_brand in ('scholaramalgamalg #14','scholaramalgamalg #7',
		                  'exportiunivamalg #9','scholaramalgamalg #9'))
           or(    i_category in ('Women','Music','Men')
              and i_class in ('accessories','classical','fragrances','pants')
              and i_brand in ('amalgimporto #1','edu packscholar #1','exportiimporto #1',
		                 'importoamalg #1')))
group by i_manager_id, d_moy) tmp1
where case when avg_monthly_sales > 0 then abs (sum_sales - avg_monthly_sales) / avg_monthly_sales else null end > 0.1
order by i_manager_id
        ,avg_monthly_sales
        ,sum_sales
 LIMIT 100;

-- end query 63 in stream 0 using template query63.tpl
```

## Rewrite Checklist (must pass before final SQL)

- Follow every node in `TARGET_LOGICAL_TREE` and produce each `NODE_CONTRACT` output column exactly.
- Keep all semantic invariants from `Semantic Contract` and `Constraints` (including join/null behavior).
- Preserve all literals and the exact final output schema/order.
- Apply `Hazard Flags` and `Regression Warnings` as hard guards against known failure modes.

### Column Completeness Contract

Your `main_query` component MUST produce **exactly** these output columns (same names, same order):

  1. `*`

Do NOT add, remove, or rename any output columns. The result set schema must be identical to the original query.

## Original Query Structure

This is the current query structure. All nodes are `[=]` (unchanged). Your modified Logic Tree below should show which nodes you changed.

```
QUERY: (single statement)
└── [MAIN] main_query  [=]  Cost: 100%  Rows: ~1K  — Aggregate store sales by manager and month under the category/class/brand filters, compute manager-level average monthly sales with a window function, and keep rows with >10% relative deviation.
    ├── SCAN (item, store_sales, date_dim, store)
    ├── FILTER (CASE WHEN avg_monthly_sales > 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1)
    ├── AGG (GROUP BY)
    ├── SORT (i_manager_id ASC, avg_monthly_sales ASC, sum_sales ASC)
    └── OUTPUT (*)
```

## Output Format

Your response has **two parts** in order:

### Part 1: Modified Logic Tree

Show what changed using change markers. Generate the tree BEFORE writing SQL.

Change markers:
- `[+]` — New component added
- `[-]` — Component removed
- `[~]` — Component modified (describe what changed)
- `[=]` — Unchanged (no children needed)
- `[!]` — Structural change (e.g. CTE → subquery)

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "<dialect>",
  "rewrite_rules": [
    {"id": "R1", "type": "<transform_name>", "description": "<what changed>", "applied_to": ["<component_id>"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "<cte_name>": {
        "type": "cte",
        "change": "modified",
        "sql": "<complete SQL for this CTE body>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<upstream_id>"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "<final SELECT>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<cte_name>"]}
      }
    },
    "reconstruction_order": ["<cte_name>", "main_query"],
    "assembly_template": "WITH <cte_name> AS ({<cte_name>}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Rules
- **Tree first, always.** Generate the Logic Tree before writing any SQL
- **One component at a time.** When writing SQL for component X, treat others as opaque interfaces
- **No ellipsis.** Every `sql` value must be complete, executable SQL
- **Frozen blocks are copy-paste.** Large CASE-WHEN lookups must be verbatim
- **Validate interfaces.** Verify every `consumes` reference exists in upstream `outputs`
- Only include components you **changed or added** — set unchanged components to `"change": "unchanged"` with `"sql": ""`
- `main_query` output columns must match the Column Completeness Contract above
- `reconstruction_order`: topological order of components for assembly

After the JSON, explain the mechanism:

```
Changes: <1-2 sentences: what structural change + the expected mechanism>
Expected speedup: <estimate>
```

Now output your Logic Tree and Component Payload JSON: