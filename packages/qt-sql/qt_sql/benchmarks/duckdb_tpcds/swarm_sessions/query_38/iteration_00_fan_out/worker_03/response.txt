### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Structural change: Converted INTERSECT to EXISTS with web_distinct driver
    ├── [~] filtered_dates  [=]  CTE: pre-filter date_dim for 12-month sequence
    ├── [~] web_distinct  [=]  DISTINCT web sales customer/date combos
    ├── [~] exists_catalog  [!]  Correlated EXISTS subquery (not CTE)
    ├── [~] exists_store  [!]  Correlated EXISTS subquery (not CTE)
    └── [~] count  [=]  COUNT(*) with EXISTS filters
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "intersect_to_exists",
      "description": "Replaced INTERSECT of three full distinct sets with EXISTS semi-joins using web_distinct as driver",
      "applied_to": ["web_distinct", "exists_catalog", "exists_store", "count"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_dates": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1183 AND 1183 + 11",
          "interfaces": {
            "outputs": ["d_date_sk", "d_date"],
            "consumes": []
          }
        },
        "web_distinct": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT DISTINCT customer.c_last_name, customer.c_first_name, filtered_dates.d_date FROM web_sales INNER JOIN filtered_dates ON web_sales.ws_sold_date_sk = filtered_dates.d_date_sk INNER JOIN customer ON web_sales.ws_bill_customer_sk = customer.c_customer_sk",
          "interfaces": {
            "outputs": ["c_last_name", "c_first_name", "d_date"],
            "consumes": ["filtered_dates"]
          }
        },
        "count": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT COUNT(*) FROM web_distinct wd WHERE EXISTS (SELECT 1 FROM catalog_sales INNER JOIN filtered_dates fd1 ON catalog_sales.cs_sold_date_sk = fd1.d_date_sk INNER JOIN customer cust1 ON catalog_sales.cs_bill_customer_sk = cust1.c_customer_sk WHERE cust1.c_last_name = wd.c_last_name AND cust1.c_first_name = wd.c_first_name AND fd1.d_date = wd.d_date) AND EXISTS (SELECT 1 FROM store_sales INNER JOIN filtered_dates fd2 ON store_sales.ss_sold_date_sk = fd2.d_date_sk INNER JOIN customer cust2 ON store_sales.ss_customer_sk = cust2.c_customer_sk WHERE cust2.c_last_name = wd.c_last_name AND cust2.c_first_name = wd.c_first_name AND fd2.d_date = wd.d_date) LIMIT 100",
          "interfaces": {
            "outputs": ["count(*)"],
            "consumes": ["web_distinct", "filtered_dates"]
          }
        }
      },
      "reconstruction_order": ["filtered_dates", "web_distinct", "count"],
      "assembly_template": "WITH filtered_dates AS ({filtered_dates}), web_distinct AS ({web_distinct}) {count}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Converted three-way INTERSECT to EXISTS semi-joins with web_distinct as the driver, preserving exact set matching via correlated subqueries on customer name and date columns.

Expected speedup: 1.5-2x (avoids materializing and sorting full distinct sets for catalog_sales and store_sales, enables semi-join short-circuiting).