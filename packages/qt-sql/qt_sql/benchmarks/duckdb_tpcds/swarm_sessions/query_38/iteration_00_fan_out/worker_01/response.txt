## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Build distinct customer/date sets per channel over the 12-month sequence, intersect the three sets, and return the final count of shared customer shopping dates.
    ├── WITH filtered_dates  [+]  — Pre-filter date_dim to month sequence 1183-1194
    │   ├── SCAN (date_dim)
    │   └── FILTER (d_month_seq BETWEEN 1183 AND 1183 + 11)
    ├── CTE store_channel  [+]  — Distinct customer/date combos from store sales
    │   ├── SCAN (store_sales, filtered_dates, customer)
    │   ├── JOIN (store_sales.ss_sold_date_sk = filtered_dates.d_date_sk)
    │   ├── JOIN (store_sales.ss_customer_sk = customer.c_customer_sk)
    │   └── DISTINCT (c_last_name, c_first_name, d_date)
    ├── CTE catalog_channel  [+]  — Distinct customer/date combos from catalog sales
    │   ├── SCAN (catalog_sales, filtered_dates, customer)
    │   ├── JOIN (catalog_sales.cs_sold_date_sk = filtered_dates.d_date_sk)
    │   ├── JOIN (catalog_sales.cs_bill_customer_sk = customer.c_customer_sk)
    │   └── DISTINCT (c_last_name, c_first_name, d_date)
    ├── CTE web_channel  [+]  — Distinct customer/date combos from web sales
    │   ├── SCAN (web_sales, filtered_dates, customer)
    │   ├── JOIN (web_sales.ws_sold_date_sk = filtered_dates.d_date_sk)
    │   ├── JOIN (web_sales.ws_bill_customer_sk = customer.c_customer_sk)
    │   └── DISTINCT (c_last_name, c_first_name, d_date)
    ├── CTE intersect_sets  [+]  — Triple intersection of channel sets
    │   └── INTERSECT (store_channel, catalog_channel, web_channel)
    └── OUTPUT (COUNT(*) as count) with LIMIT 100
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "shared_dimension_extraction",
      "description": "Extract date_dim filter into reusable CTE to avoid three redundant scans",
      "applied_to": ["filtered_dates", "store_channel", "catalog_channel", "web_channel"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1183 AND 1183 + 11",
        "interfaces": {
          "outputs": ["d_date_sk", "d_date"],
          "consumes": []
        }
      },
      "store_channel": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT DISTINCT customer.c_last_name, customer.c_first_name, filtered_dates.d_date FROM store_sales INNER JOIN filtered_dates ON store_sales.ss_sold_date_sk = filtered_dates.d_date_sk INNER JOIN customer ON store_sales.ss_customer_sk = customer.c_customer_sk",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": ["filtered_dates"]
        }
      },
      "catalog_channel": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT DISTINCT customer.c_last_name, customer.c_first_name, filtered_dates.d_date FROM catalog_sales INNER JOIN filtered_dates ON catalog_sales.cs_sold_date_sk = filtered_dates.d_date_sk INNER JOIN customer ON catalog_sales.cs_bill_customer_sk = customer.c_customer_sk",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": ["filtered_dates"]
        }
      },
      "web_channel": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT DISTINCT customer.c_last_name, customer.c_first_name, filtered_dates.d_date FROM web_sales INNER JOIN filtered_dates ON web_sales.ws_sold_date_sk = filtered_dates.d_date_sk INNER JOIN customer ON web_sales.ws_bill_customer_sk = customer.c_customer_sk",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": ["filtered_dates"]
        }
      },
      "intersect_sets": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT * FROM store_channel INTERSECT SELECT * FROM catalog_channel INTERSECT SELECT * FROM web_channel",
        "interfaces": {
          "outputs": ["c_last_name", "c_first_name", "d_date"],
          "consumes": ["store_channel", "catalog_channel", "web_channel"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT COUNT(*) AS count FROM intersect_sets LIMIT 100",
        "interfaces": {
          "outputs": ["count"],
          "consumes": ["intersect_sets"]
        }
      }
    },
    "reconstruction_order": ["filtered_dates", "store_channel", "catalog_channel", "web_channel", "intersect_sets", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), store_channel AS ({store_channel}), catalog_channel AS ({catalog_channel}), web_channel AS ({web_channel}), intersect_sets AS ({intersect_sets}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Extracted shared date filter into single CTE reused by all three channel subqueries, preserving original INTERSECT semantics and defensive guards. Customer table still scanned 3 times (unavoidable per contract). Expected speedup: 1.3x (eliminates redundant date_dim scans while maintaining same logical plan).