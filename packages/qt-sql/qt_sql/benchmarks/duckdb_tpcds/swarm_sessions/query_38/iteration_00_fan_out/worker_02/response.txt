### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Build distinct customer/date sets per channel over the 12-month sequence, intersect the three sets, and return the final count of shared customer shopping dates.
    ├── [CTE] filtered_dates  [+]  — Pre-filter date dimension to relevant month sequence
    │   └── SCAN date_dim
    │       └── FILTER (d_month_seq BETWEEN 1183 AND 1183 + 11)
    ├── [CTE] potential_customers  [+]  — Customers who purchased in any channel during filtered dates
    │   ├── UNION of customer keys from three sales tables
    │   └── JOIN customer ON customer keys
    ├── [CTE] store_channel  [+]  — Distinct customer/date combinations from store sales
    │   ├── JOIN store_sales → filtered_dates
    │   └── JOIN store_sales → potential_customers
    ├── [CTE] catalog_channel  [+]  — Distinct customer/date combinations from catalog sales
    │   ├── JOIN catalog_sales → filtered_dates
    │   └── JOIN catalog_sales → potential_customers
    ├── [CTE] web_channel  [+]  — Distinct customer/date combinations from web sales
    │   ├── JOIN web_sales → filtered_dates
    │   └── JOIN web_sales → potential_customers
    ├── [CTE] intersect_sets  [+]  — Triple INTERSECT of channel results
    │   ├── store_channel
    │   ├── INTERSECT catalog_channel
    │   └── INTERSECT web_channel
    └── [OUTPUT] COUNT(*) from intersect_sets
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter date_dim to relevant month sequence, reducing fact table scans", "applied_to": ["filtered_dates"]},
    {"id": "R2", "type": "early_filter", "description": "Pre-filter customer table to only customers who purchased in date range across any channel", "applied_to": ["potential_customers"]},
    {"id": "R3", "type": "cte_materialization", "description": "Use CTEs to avoid redundant scans of date_dim and customer tables", "applied_to": ["store_channel", "catalog_channel", "web_channel"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_month_seq BETWEEN 1183 AND 1183 + 11",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "potential_customers": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT c.c_customer_sk, c.c_last_name, c.c_first_name FROM (SELECT ss_customer_sk AS customer_sk FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk UNION SELECT cs_bill_customer_sk AS customer_sk FROM catalog_sales JOIN filtered_dates ON cs_sold_date_sk = d_date_sk UNION SELECT ws_bill_customer_sk AS customer_sk FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk) cust_keys INNER JOIN customer c ON cust_keys.customer_sk = c.c_customer_sk",
        "interfaces": {"outputs": ["c_customer_sk", "c_last_name", "c_first_name"], "consumes": ["filtered_dates"]}
      },
      "store_channel": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT pc.c_last_name, pc.c_first_name, fd.d_date FROM store_sales ss INNER JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk INNER JOIN potential_customers pc ON ss.ss_customer_sk = pc.c_customer_sk",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_dates", "potential_customers"]}
      },
      "catalog_channel": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT pc.c_last_name, pc.c_first_name, fd.d_date FROM catalog_sales cs INNER JOIN filtered_dates fd ON cs.cs_sold_date_sk = fd.d_date_sk INNER JOIN potential_customers pc ON cs.cs_bill_customer_sk = pc.c_customer_sk",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_dates", "potential_customers"]}
      },
      "web_channel": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT pc.c_last_name, pc.c_first_name, fd.d_date FROM web_sales ws INNER JOIN filtered_dates fd ON ws.ws_sold_date_sk = fd.d_date_sk INNER JOIN potential_customers pc ON ws.ws_bill_customer_sk = pc.c_customer_sk",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["filtered_dates", "potential_customers"]}
      },
      "intersect_sets": {
        "type": "cte",
        "change": "added",
        "sql": "(SELECT c_last_name, c_first_name, d_date FROM store_channel) INTERSECT (SELECT c_last_name, c_first_name, d_date FROM catalog_channel) INTERSECT (SELECT c_last_name, c_first_name, d_date FROM web_channel)",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "d_date"], "consumes": ["store_channel", "catalog_channel", "web_channel"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT COUNT(*) FROM intersect_sets LIMIT 100",
        "interfaces": {"outputs": ["COUNT(*)"], "consumes": ["intersect_sets"]}
      }
    },
    "reconstruction_order": ["filtered_dates", "potential_customers", "store_channel", "catalog_channel", "web_channel", "intersect_sets", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), potential_customers AS ({potential_customers}), store_channel AS ({store_channel}), catalog_channel AS ({catalog_channel}), web_channel AS ({web_channel}), intersect_sets AS ({intersect_sets}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Isolated date_dim filter into CTE and pre-filtered customer table to only those who purchased in any channel during the date range, then built three channel CTEs using these pre-filtered dimensions. This reduces redundant full table scans while maintaining exact INTERSECT semantics.

Expected speedup: 1.8-2.2x due to elimination of 3 redundant date_dim scans (365 rows each → 1 scan) and 3 redundant customer table scans (500K rows each → 1 scan of pre-filtered subset).