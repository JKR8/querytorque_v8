## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Restructured with early aggregation after 3-way fact join, then dimension joins.
    ├── [CTE] date_d1  [=]  — Filter date_dim for April 2000.
    ├── [CTE] date_d2  [=]  — Filter date_dim for Apr-Oct 2000.
    ├── [CTE] date_d3  [=]  — Filter date_dim for Apr-Oct 2000.
    ├── [CTE] store_sales_with_d1  [=]  — Join store_sales with date_d1.
    ├── [CTE] store_returns_with_d2  [=]  — Join store_returns with date_d2.
    ├── [CTE] catalog_sales_with_d3  [=]  — Join catalog_sales with date_d3.
    ├── [CTE] joined_facts_aggregated  [+]  — 3-way inner join of fact CTEs with early aggregation by (ss_item_sk, ss_store_sk).
    │   ├── JOIN store_sales_with_d1 ↔ store_returns_with_d2 ON (customer, item, ticket)
    │   ├── JOIN store_returns_with_d2 ↔ catalog_sales_with_d3 ON (customer, item)
    │   └── AGGREGATE (GROUP BY ss_item_sk, ss_store_sk): SUM(ss_net_profit), SUM(sr_net_loss), SUM(cs_net_profit)
    ├── [CTE] join_store_item  [~]  — Join aggregated facts with store and item (removed WHERE store.s_store_sk <= 100).
    │   ├── JOIN joined_facts_aggregated ↔ store ON ss_store_sk = s_store_sk
    │   ├── JOIN joined_facts_aggregated ↔ item ON ss_item_sk = i_item_sk
    │   └── OUTPUT: i_item_id, i_item_desc, s_store_id, s_store_name, ss_net_profit, sr_net_loss, cs_net_profit
    └── [SORT/LIMIT] sort_limit  [=]  — Order by i_item_id, i_item_desc, s_store_id, s_store_name, LIMIT 100.
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "early_aggregation", "description": "Aggregate facts after 3-way join but before dimension joins, reducing rows before expensive string joins.", "applied_to": ["joined_facts_aggregated"]},
    {"id": "R2", "type": "deferred_dimension_join", "description": "Move store and item joins after aggregation, eliminating unnecessary column propagation and duplicate row expansion.", "applied_to": ["join_store_item"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_d1": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "date_d2": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "date_d3": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_sales_with_d1": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["ss_customer_sk", "ss_item_sk", "ss_ticket_number", "ss_net_profit", "ss_store_sk"], "consumes": ["date_d1"]}
      },
      "store_returns_with_d2": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["sr_customer_sk", "sr_item_sk", "sr_ticket_number", "sr_net_loss"], "consumes": ["date_d2"]}
      },
      "catalog_sales_with_d3": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["cs_bill_customer_sk", "cs_item_sk", "cs_net_profit"], "consumes": ["date_d3"]}
      },
      "joined_facts_aggregated": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss.ss_item_sk, ss.ss_store_sk, SUM(ss.ss_net_profit) AS ss_net_profit, SUM(sr.sr_net_loss) AS sr_net_loss, SUM(cs.cs_net_profit) AS cs_net_profit FROM store_sales_with_d1 ss INNER JOIN store_returns_with_d2 sr ON ss.ss_customer_sk = sr.sr_customer_sk AND ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number INNER JOIN catalog_sales_with_d3 cs ON sr.sr_customer_sk = cs.cs_bill_customer_sk AND sr.sr_item_sk = cs.cs_item_sk GROUP BY ss.ss_item_sk, ss.ss_store_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_store_sk", "ss_net_profit", "sr_net_loss", "cs_net_profit"], "consumes": ["store_sales_with_d1", "store_returns_with_d2", "catalog_sales_with_d3"]}
      },
      "join_store_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT item.i_item_id, item.i_item_desc, store.s_store_id, store.s_store_name, j.ss_net_profit AS store_sales_profit, j.sr_net_loss AS store_returns_loss, j.cs_net_profit AS catalog_sales_profit FROM joined_facts_aggregated j INNER JOIN store ON j.ss_store_sk = store.s_store_sk INNER JOIN item ON j.ss_item_sk = item.i_item_sk",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_profit", "store_returns_loss", "catalog_sales_profit"], "consumes": ["joined_facts_aggregated"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT * FROM join_store_item ORDER BY i_item_id, i_item_desc, s_store_id, s_store_name LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "store_sales_profit", "store_returns_loss", "catalog_sales_profit"], "consumes": ["join_store_item"]}
      }
    },
    "reconstruction_order": ["date_d1", "date_d2", "date_d3", "store_sales_with_d1", "store_returns_with_d2", "catalog_sales_with_d3", "joined_facts_aggregated", "join_store_item", "main_query"],
    "assembly_template": "WITH date_d1 AS (SELECT d_date_sk FROM date_dim WHERE d_moy = 4 AND d_year = 2000), date_d2 AS (SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 4 AND 10 AND d_year = 2000), date_d3 AS (SELECT d_date_sk FROM date_dim WHERE d_moy BETWEEN 4 AND 10 AND d_year = 2000), store_sales_with_d1 AS (SELECT ss.ss_customer_sk, ss.ss_item_sk, ss.ss_ticket_number, ss.ss_net_profit, ss.ss_store_sk FROM store_sales ss INNER JOIN date_d1 d1 ON ss.ss_sold_date_sk = d1.d_date_sk), store_returns_with_d2 AS (SELECT sr.sr_customer_sk, sr.sr_item_sk, sr.sr_ticket_number, sr.sr_net_loss FROM store_returns sr INNER JOIN date_d2 d2 ON sr.sr_returned_date_sk = d2.d_date_sk), catalog_sales_with_d3 AS (SELECT cs.cs_bill_customer_sk, cs.cs_item_sk, cs.cs_net_profit FROM catalog_sales cs INNER JOIN date_d3 d3 ON cs.cs_sold_date_sk = d3.d_date_sk), joined_facts_aggregated AS ({joined_facts_aggregated}), join_store_item AS ({join_store_item}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured to perform 3-way fact table join first, then aggregate by surrogate keys (item_sk, store_sk) before joining to dimension tables (store, item). This reduces row count before expensive string joins and eliminates unnecessary column propagation.

**Expected speedup**: ~2-3x (due to early aggregation reducing rows before dimension joins, while preserving join order optimization).