## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Materialize web_sales_filtered CTE referenced twice; restructure joins sequentially per target logical tree
    ├── WITH filtered_item AS (...)  [+]
    ├── WITH filtered_date AS (...)  [+]
    ├── WITH web_sales_filtered AS (...)  [+]  — Materialized due to multiple consumers
    ├── WITH item_avg_discount AS (...)  [+]
    ├── WITH main_join AS (...)  [+]
    ├── WITH filter_agg AS (...)  [+]
    ├── CTE top_n  [+]
    ├── SORT (SUM(ws_ext_discount_amt) ASC)
    └── OUTPUT (Excess Discount Amount)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter dimension tables (item, date_dim) into separate CTEs before joining with fact table", "applied_to": ["filtered_item", "filtered_date"]},
    {"id": "R2", "type": "prefetch_fact_join", "description": "Join filtered dimensions with fact table in a single CTE to reduce fact scan size", "applied_to": ["web_sales_filtered"]},
    {"id": "R3", "type": "materialize_reused_cte", "description": "Materialize web_sales_filtered CTE to avoid rescanning fact table for aggregate subquery", "applied_to": ["web_sales_filtered"]},
    {"id": "R4", "type": "correlated_aggregate_decoupling", "description": "Replace correlated subquery with explicit CTE computing per-item average using same filtered data", "applied_to": ["item_avg_discount", "main_join"]},
    {"id": "R5", "type": "staged_aggregation", "description": "Split aggregation pipeline into separate CTEs for clarity and potential optimization boundaries", "applied_to": ["filter_agg", "top_n"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk, i_manufact_id FROM item WHERE i_manufact_id = 320",
        "interfaces": {"outputs": ["i_item_sk", "i_manufact_id"], "consumes": []}
      },
      "filtered_date": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN '2002-02-26' AND (CAST('2002-02-26' AS DATE) + INTERVAL 90 DAY)",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "web_sales_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ws_ext_discount_amt, ws_item_sk, ws_sold_date_sk FROM web_sales INNER JOIN filtered_date ON d_date_sk = ws_sold_date_sk INNER JOIN filtered_item ON i_item_sk = ws_item_sk",
        "interfaces": {"outputs": ["ws_ext_discount_amt", "ws_item_sk", "ws_sold_date_sk"], "consumes": ["filtered_date", "filtered_item"]}
      },
      "item_avg_discount": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ws_item_sk, avg(ws_ext_discount_amt) AS avg_disc FROM web_sales_filtered GROUP BY ws_item_sk",
        "interfaces": {"outputs": ["ws_item_sk", "avg_disc"], "consumes": ["web_sales_filtered"]}
      },
      "main_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ws_ext_discount_amt FROM web_sales_filtered INNER JOIN item_avg_discount ON web_sales_filtered.ws_item_sk = item_avg_discount.ws_item_sk WHERE ws_ext_discount_amt > 1.3 * avg_disc",
        "interfaces": {"outputs": ["ws_ext_discount_amt"], "consumes": ["web_sales_filtered", "item_avg_discount"]}
      },
      "filter_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT sum(ws_ext_discount_amt) AS \"Excess Discount Amount\" FROM main_join",
        "interfaces": {"outputs": ["Excess Discount Amount"], "consumes": ["main_join"]}
      },
      "top_n": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT \"Excess Discount Amount\" FROM filter_agg ORDER BY \"Excess Discount Amount\" ASC LIMIT 100",
        "interfaces": {"outputs": ["Excess Discount Amount"], "consumes": ["filter_agg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT \"Excess Discount Amount\" FROM top_n",
        "interfaces": {"outputs": ["Excess Discount Amount"], "consumes": ["top_n"]}
      }
    },
    "reconstruction_order": ["filtered_item", "filtered_date", "web_sales_filtered", "item_avg_discount", "main_join", "filter_agg", "top_n", "main_query"],
    "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_date AS ({filtered_date}), web_sales_filtered AS ({web_sales_filtered}), item_avg_discount AS ({item_avg_discount}), main_join AS ({main_join}), filter_agg AS ({filter_agg}), top_n AS ({top_n}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Replaced original 3-table join with correlated subquery using staged CTE pipeline that isolates dimension filtering first, then materializes the filtered fact table for reuse in both the main query and aggregate computation. The rewrite eliminates redundant scans of all three tables and decouples the correlated aggregate.

**Expected speedup**: ~2-3x due to single fact table scan with pre-joined dimension filters and materialized CTE avoiding correlated subquery overhead.