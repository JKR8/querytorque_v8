### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_filter_4year  [+]  — Filter date_dim to 2000-2003
│   └── OUTPUT (d_date_sk, d_date)
├── [CTE] date_filter_may2000  [+]  — Filter date_dim to May 2000  
│   └── OUTPUT (d_date_sk, d_date)
├── [CTE] customer_all  [+]  — All customers with name columns
│   └── OUTPUT (c_customer_sk, c_last_name, c_first_name)
├── [CTE] item_all  [+]  — All items with description
│   └── OUTPUT (i_item_sk, i_item_desc)
├── [CTE] store_sales_base  [+]  — Join store_sales with filtered dimensions
│   └── OUTPUT (ss_item_sk, i_item_desc, ss_customer_sk, ss_quantity, ss_sales_price, d_date)
├── [CTE] frequent_ss_items  [~]  — Now sourced from store_sales_base instead of raw joins
│   └── OUTPUT (itemdesc, item_sk, solddate, cnt)
├── [CTE] max_store_sales  [~]  — Now sourced from store_sales_base instead of raw joins
│   └── OUTPUT (tpcds_cmax)
├── [CTE] best_ss_customer  [~]  — Now sourced from store_sales_base instead of raw joins
│   └── OUTPUT (c_customer_sk, ssales)
├── [CTE] catalog_sales_filtered  [+]  — Filtered catalog sales for May 2000
│   └── OUTPUT (cs_bill_customer_sk, cs_quantity, cs_list_price)
├── [CTE] web_sales_filtered  [+]  — Filtered web sales for May 2000
│   └── OUTPUT (ws_bill_customer_sk, ws_quantity, ws_list_price)
└── [MAIN] main_union  [~]  — Union of catalog and web sales aggregated by customer
    ├── JOIN (catalog_sales_filtered + customer_all, web_sales_filtered + customer_all)
    ├── AGG (GROUP BY)
    ├── SORT (c_last_name, c_first_name, sales)
    └── OUTPUT (c_last_name, c_first_name, sales)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter date_dim and customer into CTEs before fact joins", "applied_to": ["date_filter_4year", "date_filter_may2000", "customer_all", "item_all"]},
    {"id": "R2", "type": "prefetch_fact_join", "description": "Build store_sales_base CTE that joins pre-filtered dimensions to reduce fact table scan size", "applied_to": ["store_sales_base"]},
    {"id": "R3", "type": "multi_dimension_prefetch", "description": "Use pre-filtered dimension CTEs for all fact table joins", "applied_to": ["frequent_ss_items", "max_store_sales", "best_ss_customer", "catalog_sales_filtered", "web_sales_filtered"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filter_4year": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_year IN (2000, 2001, 2002, 2003)",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "date_filter_may2000": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_year = 2000 AND d_moy = 5",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "customer_all": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_customer_sk, c_last_name, c_first_name FROM customer",
        "interfaces": {"outputs": ["c_customer_sk", "c_last_name", "c_first_name"], "consumes": []}
      },
      "item_all": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_item_desc FROM item",
        "interfaces": {"outputs": ["i_item_sk", "i_item_desc"], "consumes": []}
      },
      "store_sales_base": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss.ss_item_sk, ia.i_item_desc, ss.ss_customer_sk, ss.ss_quantity, ss.ss_sales_price, df.d_date FROM store_sales ss INNER JOIN date_filter_4year df ON ss.ss_sold_date_sk = df.d_date_sk INNER JOIN customer_all ca ON ss.ss_customer_sk = ca.c_customer_sk INNER JOIN item_all ia ON ss.ss_item_sk = ia.i_item_sk",
        "interfaces": {"outputs": ["ss_item_sk", "i_item_desc", "ss_customer_sk", "ss_quantity", "ss_sales_price", "d_date"], "consumes": ["date_filter_4year", "customer_all", "item_all"]}
      },
      "frequent_ss_items": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT SUBSTR(i_item_desc, 1, 30) AS itemdesc, ss_item_sk AS item_sk, d_date AS solddate, COUNT(*) AS cnt FROM store_sales_base GROUP BY SUBSTR(i_item_desc, 1, 30), ss_item_sk, d_date HAVING COUNT(*) > 4",
        "interfaces": {"outputs": ["itemdesc", "item_sk", "solddate", "cnt"], "consumes": ["store_sales_base"]}
      },
      "max_store_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT MAX(csales) AS tpcds_cmax FROM (SELECT ss_customer_sk, SUM(ss_quantity * ss_sales_price) AS csales FROM store_sales_base GROUP BY ss_customer_sk)",
        "interfaces": {"outputs": ["tpcds_cmax"], "consumes": ["store_sales_base"]}
      },
      "best_ss_customer": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_customer_sk AS c_customer_sk, SUM(ss_quantity * ss_sales_price) AS ssales FROM store_sales_base GROUP BY ss_customer_sk HAVING SUM(ss_quantity * ss_sales_price) > (95/100.0) * (SELECT tpcds_cmax FROM max_store_sales)",
        "interfaces": {"outputs": ["c_customer_sk", "ssales"], "consumes": ["store_sales_base", "max_store_sales"]}
      },
      "catalog_sales_filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cs.cs_bill_customer_sk, cs.cs_quantity, cs.cs_list_price FROM catalog_sales cs INNER JOIN date_filter_may2000 df ON cs.cs_sold_date_sk = df.d_date_sk WHERE cs.cs_item_sk IN (SELECT item_sk FROM frequent_ss_items) AND cs.cs_bill_customer_sk IN (SELECT c_customer_sk FROM best_ss_customer)",
        "interfaces": {"outputs": ["cs_bill_customer_sk", "cs_quantity", "cs_list_price"], "consumes": ["date_filter_may2000", "frequent_ss_items", "best_ss_customer"]}
      },
      "web_sales_filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ws.ws_bill_customer_sk, ws.ws_quantity, ws.ws_list_price FROM web_sales ws INNER JOIN date_filter_may2000 df ON ws.ws_sold_date_sk = df.d_date_sk WHERE ws.ws_item_sk IN (SELECT item_sk FROM frequent_ss_items) AND ws.ws_bill_customer_sk IN (SELECT c_customer_sk FROM best_ss_customer)",
        "interfaces": {"outputs": ["ws_bill_customer_sk", "ws_quantity", "ws_list_price"], "consumes": ["date_filter_may2000", "frequent_ss_items", "best_ss_customer"]}
      },
      "main_union": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, sales FROM (SELECT ca.c_last_name, ca.c_first_name, SUM(cs.cs_quantity * cs.cs_list_price) AS sales FROM catalog_sales_filtered cs JOIN customer_all ca ON cs.cs_bill_customer_sk = ca.c_customer_sk GROUP BY ca.c_last_name, ca.c_first_name UNION ALL SELECT ca.c_last_name, ca.c_first_name, SUM(ws.ws_quantity * ws.ws_list_price) AS sales FROM web_sales_filtered ws JOIN customer_all ca ON ws.ws_bill_customer_sk = ca.c_customer_sk GROUP BY ca.c_last_name, ca.c_first_name) ORDER BY c_last_name, c_first_name, sales LIMIT 100",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "sales"], "consumes": ["catalog_sales_filtered", "web_sales_filtered", "customer_all"]}
      }
    },
    "reconstruction_order": ["date_filter_4year", "date_filter_may2000", "customer_all", "item_all", "store_sales_base", "frequent_ss_items", "max_store_sales", "best_ss_customer", "catalog_sales_filtered", "web_sales_filtered", "main_union"],
    "assembly_template": "WITH date_filter_4year AS ({date_filter_4year}), date_filter_may2000 AS ({date_filter_may2000}), customer_all AS ({customer_all}), item_all AS ({item_all}), store_sales_base AS ({store_sales_base}), frequent_ss_items AS ({frequent_ss_items}), max_store_sales AS ({max_store_sales}), best_ss_customer AS ({best_ss_customer}), catalog_sales_filtered AS ({catalog_sales_filtered}), web_sales_filtered AS ({web_sales_filtered}) {main_union}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Restructured original query into staged CTE pipeline that pre-filters dimension tables (date, customer, item) before joining with fact tables, reducing the store_sales scan from 4 overlapping scans to 1 filtered scan. 

Expected speedup: 2.5-3.0x from eliminating redundant store_sales scans and creating small hash tables for dimension lookups.