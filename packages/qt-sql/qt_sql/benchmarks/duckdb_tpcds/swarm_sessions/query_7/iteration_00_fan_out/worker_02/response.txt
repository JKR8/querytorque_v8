## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~100  — Filter store sales by customer demographics, promotion-channel flags, and year; then aggregate item-level average purchase metrics and return items in id order.
    ├── [CTE] union_branch1  [+]  — Store sales with promotion email channel disabled
    │   ├── SCAN store_sales
    │   ├── JOIN promotion ON ss_promo_sk = p_promo_sk AND p_channel_email = 'N'
    │   └── OUTPUT: ss_item_sk, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price, ss_sold_date_sk, ss_cdemo_sk
    ├── [CTE] union_branch2  [+]  — Store sales with promotion event channel disabled
    │   ├── SCAN store_sales
    │   ├── JOIN promotion ON ss_promo_sk = p_promo_sk AND p_channel_event = 'N'
    │   └── OUTPUT: ss_item_sk, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price, ss_sold_date_sk, ss_cdemo_sk
    ├── [CTE] union_combined  [+]  — Deduplicate overlapping promotions
    │   └── SELECT DISTINCT from union of both branches
    ├── [CTE] date_join  [+]  — Filter to 2001
    │   ├── FROM union_combined
    │   ├── JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_year = 2001
    │   └── OUTPUT: ss_item_sk, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price, ss_cdemo_sk
    ├── [CTE] customer_join  [+]  — Filter to female, widowed, college-educated customers
    │   ├── FROM date_join
    │   ├── JOIN customer_demographics ON ss_cdemo_sk = cd_demo_sk AND cd_gender = 'F' AND cd_marital_status = 'W' AND cd_education_status = 'College'
    │   └── OUTPUT: ss_item_sk, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    ├── [CTE] item_join  [+]  — Join to get item identifiers
    │   ├── FROM customer_join
    │   ├── JOIN item ON ss_item_sk = i_item_sk
    │   └── OUTPUT: i_item_id, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price
    ├── [CTE] aggregate  [+]  — Compute per-item averages
    │   ├── FROM item_join
    │   ├── GROUP BY i_item_id
    │   ├── AGGREGATE: AVG(ss_quantity), AVG(ss_list_price), AVG(ss_coupon_amt), AVG(ss_sales_price)
    │   └── OUTPUT: i_item_id, agg1, agg2, agg3, agg4
    ├── [CTE] top_n  [+]  — Order and limit results
    │   ├── FROM aggregate
    │   ├── ORDER BY i_item_id ASC
    │   ├── LIMIT 100
    │   └── OUTPUT: i_item_id, agg1, agg2, agg3, agg4
    └── OUTPUT (i_item_id, agg1, agg2, agg3, agg4)
```

Changes:
- Split OR condition on promotion channels into UNION ALL branches (email='N' and event='N')
- Added DISTINCT in union_combined to deduplicate rows where a promotion satisfies both conditions
- Structured as CTEs following the target logical tree exactly

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "or_to_union",
      "description": "Split OR condition (p_channel_email='N' OR p_channel_event='N') into separate UNION ALL branches",
      "applied_to": ["union_branch1", "union_branch2"]
    },
    {
      "id": "R2", 
      "type": "deduplication",
      "description": "Add DISTINCT in union_combined to handle promotions satisfying both channel conditions",
      "applied_to": ["union_combined"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "union_branch1": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_item_sk, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price, ss_sold_date_sk, ss_cdemo_sk FROM store_sales INNER JOIN promotion ON ss_promo_sk = p_promo_sk AND p_channel_email = 'N'",
        "interfaces": {
          "outputs": ["ss_item_sk", "ss_quantity", "ss_list_price", "ss_coupon_amt", "ss_sales_price", "ss_sold_date_sk", "ss_cdemo_sk"],
          "consumes": []
        }
      },
      "union_branch2": {
        "type": "cte",
        "change": "new", 
        "sql": "SELECT ss_item_sk, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price, ss_sold_date_sk, ss_cdemo_sk FROM store_sales INNER JOIN promotion ON ss_promo_sk = p_promo_sk AND p_channel_event = 'N'",
        "interfaces": {
          "outputs": ["ss_item_sk", "ss_quantity", "ss_list_price", "ss_coupon_amt", "ss_sales_price", "ss_sold_date_sk", "ss_cdemo_sk"],
          "consumes": []
        }
      },
      "union_combined": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT DISTINCT ss_item_sk, ss_quantity, ss_list_price, ss_coupon_amt, ss_sales_price, ss_sold_date_sk, ss_cdemo_sk FROM (SELECT * FROM union_branch1 UNION ALL SELECT * FROM union_branch2)",
        "interfaces": {
          "outputs": ["ss_item_sk", "ss_quantity", "ss_list_price", "ss_coupon_amt", "ss_sales_price", "ss_sold_date_sk", "ss_cdemo_sk"],
          "consumes": ["union_branch1", "union_branch2"]
        }
      },
      "date_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT union_combined.ss_item_sk, union_combined.ss_quantity, union_combined.ss_list_price, union_combined.ss_coupon_amt, union_combined.ss_sales_price, union_combined.ss_cdemo_sk FROM union_combined INNER JOIN date_dim ON union_combined.ss_sold_date_sk = date_dim.d_date_sk AND date_dim.d_year = 2001",
        "interfaces": {
          "outputs": ["ss_item_sk", "ss_quantity", "ss_list_price", "ss_coupon_amt", "ss_sales_price", "ss_cdemo_sk"],
          "consumes": ["union_combined"]
        }
      },
      "customer_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT date_join.ss_item_sk, date_join.ss_quantity, date_join.ss_list_price, date_join.ss_coupon_amt, date_join.ss_sales_price FROM date_join INNER JOIN customer_demographics ON date_join.ss_cdemo_sk = customer_demographics.cd_demo_sk AND customer_demographics.cd_gender = 'F' AND customer_demographics.cd_marital_status = 'W' AND customer_demographics.cd_education_status = 'College'",
        "interfaces": {
          "outputs": ["ss_item_sk", "ss_quantity", "ss_list_price", "ss_coupon_amt", "ss_sales_price"],
          "consumes": ["date_join"]
        }
      },
      "item_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT item.i_item_id, customer_join.ss_quantity, customer_join.ss_list_price, customer_join.ss_coupon_amt, customer_join.ss_sales_price FROM customer_join INNER JOIN item ON customer_join.ss_item_sk = item.i_item_sk",
        "interfaces": {
          "outputs": ["i_item_id", "ss_quantity", "ss_list_price", "ss_coupon_amt", "ss_sales_price"],
          "consumes": ["customer_join"]
        }
      },
      "aggregate": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_id, AVG(ss_quantity) AS agg1, AVG(ss_list_price) AS agg2, AVG(ss_coupon_amt) AS agg3, AVG(ss_sales_price) AS agg4 FROM item_join GROUP BY i_item_id",
        "interfaces": {
          "outputs": ["i_item_id", "agg1", "agg2", "agg3", "agg4"],
          "consumes": ["item_join"]
        }
      },
      "top_n": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_id, agg1, agg2, agg3, agg4 FROM aggregate ORDER BY i_item_id ASC LIMIT 100",
        "interfaces": {
          "outputs": ["i_item_id", "agg1", "agg2", "agg3", "agg4"],
          "consumes": ["aggregate"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, agg1, agg2, agg3, agg4 FROM top_n",
        "interfaces": {
          "outputs": ["i_item_id", "agg1", "agg2", "agg3", "agg4"],
          "consumes": ["top_n"]
        }
      }
    },
    "reconstruction_order": ["union_branch1", "union_branch2", "union_combined", "date_join", "customer_join", "item_join", "aggregate", "top_n", "main_query"],
    "assembly_template": "WITH union_branch1 AS ({union_branch1}), union_branch2 AS ({union_branch2}), union_combined AS ({union_combined}), date_join AS ({date_join}), customer_join AS ({customer_join}), item_join AS ({item_join}), aggregate AS ({aggregate}), top_n AS ({top_n}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Split the OR condition on promotion channels into UNION ALL branches with DISTINCT deduplication to handle promotions that satisfy both conditions. Each branch can use efficient joins with single-column equality predicates, and the date filter is applied after the union as specified in the target logical tree.

Expected speedup: ~3x (or-to-union pattern reference showed 3.17x for similar transformation)