You are a SQL rewrite engine for DuckDB v1.4.3. Follow the Target Logical Tree structure below. Your job is to write correct, executable SQL for each node — not to decide whether to restructure. Preserve exact semantic equivalence (same rows, same columns, same ordering). Preserve defensive guards: if the original uses CASE WHEN x > 0 THEN y/x END around a division, keep it — even when a WHERE clause makes the zero case unreachable. Guards prevent silent breakage if filters change upstream. Strip benchmark comments (-- start query, -- end query) from your output.

DuckDB specifics: columnar storage (SELECT only needed columns). CTEs referenced once are typically inlined; CTEs referenced multiple times may be materialized. FILTER clause is native (`COUNT(*) FILTER (WHERE cond)`). Predicate pushdown stops at UNION ALL boundaries and multi-level CTE references.

## Semantic Contract (MUST preserve)

Summarize 30-day performance from 1998-08-05 across store, catalog, and web channels by combining sales, returns, and net profit at channel entity level with rollup subtotals. Store and web channels use LEFT JOIN between sales and returns on entity key (store_sk, web_page_sk); catalog channel uses CROSS JOIN between sales and returns aggregates (potential Cartesian product if key sets differ). All aggregates are SUMs, no duplicate-sensitivity traps. Date filter is identical across all CTEs; dimension tables (store, web_page) are joined only for store and web channels.

## Target Logical Tree + Node Contracts

Build your rewrite following this CTE structure. Each node's OUTPUT list is exhaustive — your SQL must produce exactly those columns.

TARGET_LOGICAL_TREE:
date_range -> store_filtered -> web_page_filtered -> ss -> sr -> cs -> cr -> ws -> wr -> main_query
NODE_CONTRACTS:
  date_range:
    FROM: date_dim
    WHERE: d_date BETWEEN CAST('1998-08-05' AS DATE) AND (CAST('1998-08-05' AS DATE) + INTERVAL 30 DAY)
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 31
    CONSUMERS: ss, sr, cs, cr, ws, wr
  store_filtered:
    FROM: store
    WHERE: s_store_sk <= 100 (from EXPLAIN filter)
    OUTPUT: s_store_sk
    EXPECTED_ROWS: 100
    CONSUMERS: ss, sr
  web_page_filtered:
    FROM: web_page
    OUTPUT: wp_web_page_sk
    EXPECTED_ROWS: 200
    CONSUMERS: ws, wr
  ss:
    FROM: store_sales, date_range, store_filtered
    JOIN: ss_sold_date_sk = date_range.d_date_sk AND ss_store_sk = store_filtered.s_store_sk
    GROUP BY: s_store_sk
    AGGREGATE: SUM(ss_ext_sales_price) AS sales, SUM(ss_net_profit) AS profit
    OUTPUT: s_store_sk, sales, profit
    EXPECTED_ROWS: 51
    CONSUMERS: main_query
  sr:
    FROM: store_returns, date_range, store_filtered
    JOIN: sr_returned_date_sk = date_range.d_date_sk AND sr_store_sk = store_filtered.s_store_sk
    GROUP BY: s_store_sk
    AGGREGATE: SUM(sr_return_amt) AS returns, SUM(sr_net_loss) AS profit_loss
    OUTPUT: s_store_sk, returns, profit_loss
    EXPECTED_ROWS: 51
    CONSUMERS: main_query
  cs:
    FROM: catalog_sales, date_range
    JOIN: cs_sold_date_sk = date_range.d_date_sk
    GROUP BY: cs_call_center_sk
    AGGREGATE: SUM(cs_ext_sales_price) AS sales, SUM(cs_net_profit) AS profit
    OUTPUT: cs_call_center_sk, sales, profit
    EXPECTED_ROWS: 13
    CONSUMERS: main_query
  cr:
    FROM: catalog_returns, date_range
    JOIN: cr_returned_date_sk = date_range.d_date_sk
    GROUP BY: cr_call_center_sk
    AGGREGATE: SUM(cr_return_amount) AS returns, SUM(cr_net_loss) AS profit_loss
    OUTPUT: cr_call_center_sk, returns, profit_loss
    EXPECTED_ROWS: 13
    CONSUMERS: main_query
  ws:
    FROM: web_sales, date_range, web_page_filtered
    JOIN: ws_sold_date_sk = date_range.d_date_sk AND ws_web_page_sk = web_page_filtered.wp_web_page_sk
    GROUP BY: wp_web_page_sk
    AGGREGATE: SUM(ws_ext_sales_price) AS sales, SUM(ws_net_profit) AS profit
    OUTPUT: wp_web_page_sk, sales, profit
    EXPECTED_ROWS: 101
    CONSUMERS: main_query
  wr:
    FROM: web_returns, date_range, web_page_filtered
    JOIN: wr_returned_date_sk = date_range.d_date_sk AND wr_web_page_sk = web_page_filtered.wp_web_page_sk
    GROUP BY: wp_web_page_sk
    AGGREGATE: SUM(wr_return_amt) AS returns, SUM(wr_net_loss) AS profit_loss
    OUTPUT: wp_web_page_sk, returns, profit_loss
    EXPECTED_ROWS: 101
    CONSUMERS: main_query

NODE_CONTRACTS:
date_range:
    FROM: date_dim
    WHERE: d_date BETWEEN CAST('1998-08-05' AS DATE) AND (CAST('1998-08-05' AS DATE) + INTERVAL 30 DAY)
    OUTPUT: d_date_sk, d_date
    EXPECTED_ROWS: 31
    CONSUMERS: ss, sr, cs, cr, ws, wr
  store_filtered:
    FROM: store
    WHERE: s_store_sk <= 100 (from EXPLAIN filter)
    OUTPUT: s_store_sk
    EXPECTED_ROWS: 100
    CONSUMERS: ss, sr
  web_page_filtered:
    FROM: web_page
    OUTPUT: wp_web_page_sk
    EXPECTED_ROWS: 200
    CONSUMERS: ws, wr
  ss:
    FROM: store_sales, date_range, store_filtered
    JOIN: ss_sold_date_sk = date_range.d_date_sk AND ss_store_sk = store_filtered.s_store_sk
    GROUP BY: s_store_sk
    AGGREGATE: SUM(ss_ext_sales_price) AS sales, SUM(ss_net_profit) AS profit
    OUTPUT: s_store_sk, sales, profit
    EXPECTED_ROWS: 51
    CONSUMERS: main_query
  sr:
    FROM: store_returns, date_range, store_filtered
    JOIN: sr_returned_date_sk = date_range.d_date_sk AND sr_store_sk = store_filtered.s_store_sk
    GROUP BY: s_store_sk
    AGGREGATE: SUM(sr_return_amt) AS returns, SUM(sr_net_loss) AS profit_loss
    OUTPUT: s_store_sk, returns, profit_loss
    EXPECTED_ROWS: 51
    CONSUMERS: main_query
  cs:
    FROM: catalog_sales, date_range
    JOIN: cs_sold_date_sk = date_range.d_date_sk
    GROUP BY: cs_call_center_sk
    AGGREGATE: SUM(cs_ext_sales_price) AS sales, SUM(cs_net_profit) AS profit
    OUTPUT: cs_call_center_sk, sales, profit
    EXPECTED_ROWS: 13
    CONSUMERS: main_query
  cr:
    FROM: catalog_returns, date_range
    JOIN: cr_returned_date_sk = date_range.d_date_sk
    GROUP BY: cr_call_center_sk
    AGGREGATE: SUM(cr_return_amount) AS returns, SUM(cr_net_loss) AS profit_loss
    OUTPUT: cr_call_center_sk, returns, profit_loss
    EXPECTED_ROWS: 13
    CONSUMERS: main_query
  ws:
    FROM: web_sales, date_range, web_page_filtered
    JOIN: ws_sold_date_sk = date_range.d_date_sk AND ws_web_page_sk = web_page_filtered.wp_web_page_sk
    GROUP BY: wp_web_page_sk
    AGGREGATE: SUM(ws_ext_sales_price) AS sales, SUM(ws_net_profit) AS profit
    OUTPUT: wp_web_page_sk, sales, profit
    EXPECTED_ROWS: 101
    CONSUMERS: main_query
  wr:
    FROM: web_returns, date_range, web_page_filtered
    JOIN: wr_returned_date_sk = date_range.d_date_sk AND wr_web_page_sk = web_page_filtered.wp_web_page_sk
    GROUP BY: wp_web_page_sk
    AGGREGATE: SUM(wr_return_amt) AS returns, SUM(wr_net_loss) AS profit_loss
    OUTPUT: wp_web_page_sk, returns, profit_loss
    EXPECTED_ROWS: 101
    CONSUMERS: main_query

## Hazard Flags (avoid these specific risks)

- Must ensure date_range CTE includes all d_date_sk needed for all joins (already covered by filter).
- store_filtered must include s_store_sk <= 100 filter from EXPLAIN to match original row count.

## Regression Warnings (observed failures on similar queries)

1. date_cte_isolate (0.49x on Q31):
   CAUSE: Pre-filtered and joined fact table before multi-way fact joins, preventing optimizer reordering.
   RULE: Do not pre-join fact tables with date CTE if there are multiple fact table joins (this query has no multi-way fact joins, safe).
2. prefetch_fact_join (0.50x on Q25):
   CAUSE: Baseline runtime <50ms, CTE overhead dominated.
   RULE: This query baseline is 486ms, so CTE overhead acceptable.
3. dimension_cte_isolate (0.0076x on Q26):
   CAUSE: Cross-joined 3+ dimension CTEs causing Cartesian explosion.
   RULE: Never cross-join dimension CTEs; join them sequentially with fact tables.

## Constraints (analyst-filtered for this query)

- COMPLETE_OUTPUT: Must output channel, id, sales, returns, profit ordered by channel, id with LIMIT 100.
- CTE_COLUMN_COMPLETENESS: Each CTE must output all columns referenced by downstream joins and selects (e.g., s_store_sk, sales, returns, profit_loss).
- LITERAL_PRESERVATION: Date literal '1998-08-05' and interval '30 DAY' must be preserved exactly.
- SEMANTIC_EQUIVALENCE: Must preserve LEFT JOIN semantics for store/web channels and CROSS JOIN for catalog channel.
- CROSS_CTE_PREDICATE_BLINDNESS: Evidence: date_dim scanned 6 times with same filter (EXPLAIN shows 6 separate SEQ_SCAN date_dim nodes).
- REDUNDANT_SCAN_ELIMINATION: Not active (each fact table scanned once).
- UNION_CTE_SELF_JOIN_DECOMPOSITION: Not active.

## Example Adaptation Notes

For each example: what to apply to your rewrite, and what to ignore.

- date_cte_isolate: Apply the single date_range CTE pattern; ignore the decorrelation aspect (no correlated subqueries).
- dimension_cte_isolate: Apply filtered store and web_page CTEs; ignore cross-joining them (join them only with fact tables).
- shared_dimension_multi_channel: Extract shared date filter across all channel CTEs; ignore item/promotion filters (not present).

## Reference Examples

Pattern reference only — do not copy table/column names or literals.

### 1. date_cte_isolate (4.00x)

**Principle:** Dimension Isolation: extract small dimension lookups into CTEs so they materialize once and subsequent joins probe a tiny hash table instead of rescanning.

**BEFORE (slow):**
```sql
select a.ca_state state, count(*) cnt
 from customer_address a
     ,customer c
     ,store_sales s
     ,date_dim d
     ,item i
 where       a.ca_address_sk = c.c_current_addr_sk
 	and c.c_customer_sk = s.ss_customer_sk
 	and s.ss_sold_date_sk = d.d_date_sk
 	and s.ss_item_sk = i.i_item_sk
 	and d.d_month_seq = 
 	     (select distinct (d_month_seq)
 	      from date_dim
               where d_year = 2002
 	        and d_moy = 3 )
 	and i.i_current_price > 1.2 * 
             (select avg(j.i_current_price) 
 	     from item j 
 	     where j.i_category = i.i_category)
 group by a.ca_state
 having count(*) >= 10
 order by cnt, a.ca_state
 LIMIT 100;
```

**AFTER (fast):**
[target_month]:
```sql
SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2000 AND d_moy = 1
```
[category_avg_price]:
```sql
SELECT i_category, AVG(i_current_price) * 1.2 AS avg_threshold FROM item GROUP BY i_category
```
[filtered_dates]:
```sql
SELECT d_date_sk FROM date_dim JOIN target_month ON d_month_seq = target_month.d_month_seq
```
[filtered_sales]:
```sql
SELECT ss_customer_sk, ss_item_sk FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk
```
[main_query]:
```sql
SELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address a JOIN customer c ON a.ca_address_sk = c.c_current_addr_sk JOIN filtered_sales s ON c.c_customer_sk = s.ss_customer_sk JOIN item i ON s.ss_item_sk = i.i_item_sk JOIN category_avg_price cap ON i.i_category = cap.i_category WHERE i.i_current_price > cap.avg_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100
```

### 2. dimension_cte_isolate (1.93x)

**Principle:** Early Selection: pre-filter dimension tables into CTEs returning only surrogate keys before joining with fact tables. Each dimension CTE is tiny, creating small hash tables that speed up the fact table probe.

**BEFORE (slow):**
```sql
select i_item_id, 
        avg(cs_quantity) agg1,
        avg(cs_list_price) agg2,
        avg(cs_coupon_amt) agg3,
        avg(cs_sales_price) agg4 
 from catalog_sales, customer_demographics, date_dim, item, promotion
 where cs_sold_date_sk = d_date_sk and
       cs_item_sk = i_item_sk and
       cs_bill_cdemo_sk = cd_demo_sk and
       cs_promo_sk = p_promo_sk and
       cd_gender = 'M' and 
       cd_marital_status = 'S' and
       cd_education_status = 'Unknown' and
       (p_channel_email = 'N' or p_channel_event = 'N') and
       d_year = 2001 
 group by i_item_id
 order by i_item_id
 LIMIT 100;
```

**AFTER (fast):**
[filtered_dates]:
```sql
SELECT d_date_sk FROM date_dim WHERE d_year = 2000
```
[filtered_customer_demographics]:
```sql
SELECT cd_demo_sk FROM customer_demographics WHERE cd_gender = 'M' AND cd_marital_status = 'S' AND cd_education_status = 'College'
```
[filtered_promotions]:
```sql
SELECT p_promo_sk FROM promotion WHERE p_channel_email = 'N' OR p_channel_event = 'N'
```
[joined_facts]:
```sql
SELECT cs_item_sk, cs_quantity, cs_list_price, cs_coupon_amt, cs_sales_price FROM catalog_sales AS cs JOIN filtered_dates AS fd ON cs.cs_sold_date_sk = fd.d_date_sk JOIN filtered_customer_demographics AS fcd ON cs.cs_bill_cdemo_sk = fcd.cd_demo_sk JOIN filtered_promotions AS fp ON cs.cs_promo_sk = fp.p_promo_sk
```
[main_query]:
```sql
SELECT i_item_id, AVG(cs_quantity) AS agg1, AVG(cs_list_price) AS agg2, AVG(cs_coupon_amt) AS agg3, AVG(cs_sales_price) AS agg4 FROM joined_facts AS jf JOIN item AS i ON jf.cs_item_sk = i.i_item_sk GROUP BY i_item_id ORDER BY i_item_id LIMIT 100
```

### 3. shared_dimension_multi_channel (1.30x)

**Principle:** Shared Dimension Extraction: when multiple channel CTEs (store/catalog/web) apply identical dimension filters, extract those shared filters into one CTE and reference it from each channel. Avoids redundant dimension scans.

**BEFORE (slow):**
```sql
with ssr as
 (select  s_store_id as store_id,
          sum(ss_ext_sales_price) as sales,
          sum(coalesce(sr_return_amt, 0)) as "returns",
          sum(ss_net_profit - coalesce(sr_net_loss, 0)) as profit
  from store_sales left outer join store_returns on
         (ss_item_sk = sr_item_sk and ss_ticket_number = sr_ticket_number),
     date_dim,
     store,
     item,
     promotion
 where ss_sold_date_sk = d_date_sk
       and d_date between cast('1998-08-28' as date) 
                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)
       and ss_store_sk = s_store_sk
       and ss_item_sk = i_item_sk
       and i_current_price > 50
       and ss_promo_sk = p_promo_sk
       and p_channel_tv = 'N'
 group by s_store_id)
 ,
 csr as
 (select  cp_catalog_page_id as catalog_page_id,
          sum(cs_ext_sales_price) as sales,
          sum(coalesce(cr_return_amount, 0)) as "returns",
          sum(cs_net_profit - coalesce(cr_net_loss, 0)) as profit
  from catalog_sales left outer join catalog_returns on
         (cs_item_sk = cr_item_sk and cs_order_number = cr_order_number),
     date_dim,
     catalog_page,
     item,
     promotion
 where cs_sold_date_sk = d_date_sk
       and d_date between cast('1998-08-28' as date)
                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)
        and cs_catalog_page_sk = cp_catalog_page_sk
       and cs_item_sk = i_item_sk
       and i_current_price > 50
       and cs_promo_sk = p_promo_sk
       and p_channel_tv = 'N'
group by cp_catalog_page_id)
 ,
 wsr as
 (select  web_site_id,
          sum(ws_ext_sales_price) as sales,
          sum(coalesce(wr_return_amt, 0)) as "returns",
          sum(ws_net_profit - coalesce(wr_net_loss, 0)) as profit
  from web_sales left outer join web_returns on
         (ws_item_sk = wr_item_sk and ws_order_number = wr_order_number),
     date_dim,
     web_site,
     item,
     promotion
 where ws_sold_date_sk = d_date_sk
       and d_date between cast('1998-08-28' as date)
                  and (cast('1998-08-28' as date) + INTERVAL 30 DAY)
        and ws_web_site_sk = web_site_sk
       and ws_item_sk = i_item_sk
       and i_current_price > 50
       and ws_promo_sk = p_promo_sk
       and p_channel_tv = 'N'
group by web_site_id)
  select channel
        , id
        , sum(sales) as sales
        , sum("returns") as "returns"
        , sum(profit) as profit
 from 
 (select 'store channel' as channel
        , 'store' || store_id as id
        , sales
        , "returns"
        , profit
 from   ssr
 union all
 select 'catalog channel' as channel
        , 'catalog_page' || catalog_page_id as id
        , sales
        , "returns"
        , profit
 from  csr
 union all
 select 'web channel' as channel
        , 'web_site' || web_site_id as id
        , sales
        , "returns"
        , profit
 from   wsr
 ) x
 group by rollup (channel, id)
 order by channel
         ,id
 LIMIT 100;
```

**AFTER (fast):**
[filtered_dates]:
```sql
SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1998-08-28' AS DATE) AND (CAST('1998-08-28' AS DATE) + INTERVAL '30' DAY)
```
[filtered_items]:
```sql
SELECT i_item_sk FROM item WHERE i_current_price > 50
```
[filtered_promotions]:
```sql
SELECT p_promo_sk FROM promotion WHERE p_channel_tv = 'N'
```
[prefiltered_store_sales]:
```sql
SELECT ss_item_sk, ss_store_sk, ss_ticket_number, ss_ext_sales_price, ss_net_profit FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_items ON ss_item_sk = i_item_sk JOIN filtered_promotions ON ss_promo_sk = p_promo_sk
```
[prefiltered_web_sales]:
```sql
SELECT ws_item_sk, ws_web_site_sk, ws_order_number, ws_ext_sales_price, ws_net_profit FROM web_sales JOIN filtered_dates ON ws_sold_date_sk = d_date_sk JOIN filtered_items ON ws_item_sk = i_item_sk JOIN filtered_promotions ON ws_promo_sk = p_promo_sk
```
[ssr]:
```sql
SELECT s_store_id AS store_id, SUM(ss_ext_sales_price) AS sales, SUM(COALESCE(sr_return_amt, 0)) AS returns, SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit FROM prefiltered_store_sales LEFT OUTER JOIN store_returns ON (ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number) JOIN store ON ss_store_sk = s_store_sk GROUP BY s_store_id
```
[wsr]:
```sql
SELECT web_site_id, SUM(ws_ext_sales_price) AS sales, SUM(COALESCE(wr_return_amt, 0)) AS returns, SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit FROM prefiltered_web_sales LEFT OUTER JOIN web_returns ON (ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number) JOIN web_site ON ws_web_site_sk = web_site_sk GROUP BY web_site_id
```

## Original SQL

```sql
-- start query 77 in stream 0 using template query77.tpl
with ss as
 (select s_store_sk,
         sum(ss_ext_sales_price) as sales,
         sum(ss_net_profit) as profit
 from store_sales,
      date_dim,
      store
 where ss_sold_date_sk = d_date_sk
       and d_date between cast('1998-08-05' as date) 
                  and (cast('1998-08-05' as date) + INTERVAL 30 DAY) 
       and ss_store_sk = s_store_sk
 group by s_store_sk)
 ,
 sr as
 (select s_store_sk,
         sum(sr_return_amt) as "returns",
         sum(sr_net_loss) as profit_loss
 from store_returns,
      date_dim,
      store
 where sr_returned_date_sk = d_date_sk
       and d_date between cast('1998-08-05' as date)
                  and (cast('1998-08-05' as date) + INTERVAL 30 DAY)
       and sr_store_sk = s_store_sk
 group by s_store_sk), 
 cs as
 (select cs_call_center_sk,
        sum(cs_ext_sales_price) as sales,
        sum(cs_net_profit) as profit
 from catalog_sales,
      date_dim
 where cs_sold_date_sk = d_date_sk
       and d_date between cast('1998-08-05' as date)
                  and (cast('1998-08-05' as date) + INTERVAL 30 DAY)
 group by cs_call_center_sk 
 ), 
 cr as
 (select cr_call_center_sk,
         sum(cr_return_amount) as "returns",
         sum(cr_net_loss) as profit_loss
 from catalog_returns,
      date_dim
 where cr_returned_date_sk = d_date_sk
       and d_date between cast('1998-08-05' as date)
                  and (cast('1998-08-05' as date) + INTERVAL 30 DAY)
 group by cr_call_center_sk
 ), 
 ws as
 ( select wp_web_page_sk,
        sum(ws_ext_sales_price) as sales,
        sum(ws_net_profit) as profit
 from web_sales,
      date_dim,
      web_page
 where ws_sold_date_sk = d_date_sk
       and d_date between cast('1998-08-05' as date)
                  and (cast('1998-08-05' as date) + INTERVAL 30 DAY)
       and ws_web_page_sk = wp_web_page_sk
 group by wp_web_page_sk), 
 wr as
 (select wp_web_page_sk,
        sum(wr_return_amt) as "returns",
        sum(wr_net_loss) as profit_loss
 from web_returns,
      date_dim,
      web_page
 where wr_returned_date_sk = d_date_sk
       and d_date between cast('1998-08-05' as date)
                  and (cast('1998-08-05' as date) + INTERVAL 30 DAY)
       and wr_web_page_sk = wp_web_page_sk
 group by wp_web_page_sk)
  select channel
        , id
        , sum(sales) as sales
        , sum("returns") as "returns"
        , sum(profit) as profit
 from 
 (select 'store channel' as channel
        , ss.s_store_sk as id
        , sales
        , coalesce("returns", 0) as "returns"
        , (profit - coalesce(profit_loss,0)) as profit
 from   ss left join sr
        on  ss.s_store_sk = sr.s_store_sk
 union all
 select 'catalog channel' as channel
        , cs_call_center_sk as id
        , sales
        , "returns"
        , (profit - profit_loss) as profit
 from  cs
       , cr
 union all
 select 'web channel' as channel
        , ws.wp_web_page_sk as id
        , sales
        , coalesce("returns", 0) AS "returns"
        , (profit - coalesce(profit_loss,0)) as profit
 from   ws left join wr
        on  ws.wp_web_page_sk = wr.wp_web_page_sk
 ) x
 group by rollup (channel, id)
 order by channel
         ,id
 LIMIT 100;

-- end query 77 in stream 0 using template query77.tpl
```

## Rewrite Checklist (must pass before final SQL)

- Follow every node in `TARGET_LOGICAL_TREE` and produce each `NODE_CONTRACT` output column exactly.
- Keep all semantic invariants from `Semantic Contract` and `Constraints` (including join/null behavior).
- Preserve all literals and the exact final output schema/order.
- Apply `Hazard Flags` and `Regression Warnings` as hard guards against known failure modes.

### Column Completeness Contract

Your `main_query` component MUST produce **exactly** these output columns (same names, same order):

  1. `channel`
  2. `id`
  3. `sales`
  4. `returns`
  5. `profit`

Do NOT add, remove, or rename any output columns. The result set schema must be identical to the original query.

## Original Query Structure

This is the current query structure. All nodes are `[=]` (unchanged). Your modified Logic Tree below should show which nodes you changed.

```
QUERY: (single statement)
├── [CTE] cr  [=]  Cost: 14%  Rows: ~1K  — Aggregate catalog returns and net loss by call center for the window.
│   ├── SCAN (catalog_returns, date_dim (join))
│   ├── JOIN (cr_returned_date_sk = d_date_sk)
│   ├── FILTER (d_date BETWEEN CAST('1998-08-05' AS DATE) AND (CAST('1998-08-05' AS DATE) + INTERVAL '30' DAY))
│   ├── AGG (GROUP BY)
│   └── OUTPUT (cr_call_center_sk, returns, profit_loss)
├── [CTE] cs  [=]  Cost: 14%  Rows: ~1K  — Aggregate catalog sales and profit by call center for the window.
│   ├── SCAN (catalog_sales, date_dim (join))
│   ├── JOIN (cs_sold_date_sk = d_date_sk)
│   ├── FILTER (d_date BETWEEN CAST('1998-08-05' AS DATE) AND (CAST('1998-08-05' AS DATE) + INTERVAL '30' DAY))
│   ├── AGG (GROUP BY)
│   └── OUTPUT (cs_call_center_sk, sales, profit)
├── [CTE] sr  [=]  Cost: 14%  Rows: ~1K  — Aggregate store return amount and net loss by store for the same window.
│   ├── SCAN (store_returns, date_dim (join), store (join))
│   ├── JOIN (sr_returned_date_sk = d_date_sk)
│   ├── JOIN (sr_store_sk = s_store_sk)
│   ├── FILTER (d_date BETWEEN CAST('1998-08-05' AS DATE) AND (CAST('1998-08-05' AS DATE) + INTERVAL '30' DAY))
│   ├── AGG (GROUP BY)
│   └── OUTPUT (s_store_sk, returns, profit_loss)
├── [CTE] ss  [=]  Cost: 14%  Rows: ~1K  — Aggregate store sales and profit by store for the 30-day window.
│   ├── SCAN (store_sales, date_dim (join), store (join))
│   ├── JOIN (ss_sold_date_sk = d_date_sk)
│   ├── JOIN (ss_store_sk = s_store_sk)
│   ├── FILTER (d_date BETWEEN CAST('1998-08-05' AS DATE) AND (CAST('1998-08-05' AS DATE) + INTERVAL '30' DAY))
│   ├── AGG (GROUP BY)
│   └── OUTPUT (s_store_sk, sales, profit)
├── [CTE] wr  [=]  Cost: 14%  Rows: ~1K  — Aggregate web returns and net loss by web page for the window.
│   ├── SCAN (web_returns, date_dim (join), web_page (join))
│   ├── JOIN (wr_returned_date_sk = d_date_sk)
│   ├── JOIN (wr_web_page_sk = wp_web_page_sk)
│   ├── FILTER (d_date BETWEEN CAST('1998-08-05' AS DATE) AND (CAST('1998-08-05' AS DATE) + INTERVAL '30' DAY))
│   ├── AGG (GROUP BY)
│   └── OUTPUT (wp_web_page_sk, returns, profit_loss)
├── [CTE] ws  [=]  Cost: 14%  Rows: ~1K  — Aggregate web sales and profit by web page for the window.
│   ├── SCAN (web_sales, date_dim (join), web_page (join))
│   ├── JOIN (ws_sold_date_sk = d_date_sk)
│   ├── JOIN (ws_web_page_sk = wp_web_page_sk)
│   ├── FILTER (d_date BETWEEN CAST('1998-08-05' AS DATE) AND (CAST('1998-08-05' AS DATE) + INTERVAL '30' DAY))
│   ├── AGG (GROUP BY)
│   └── OUTPUT (wp_web_page_sk, sales, profit)
└── [MAIN] main_query  [=]  Cost: 14%  Rows: ~1K  — Combine channel aggregates, net profits against losses, and produce rollup totals by channel and channel-specific id.
    ├── SCAN (ws, wr, ss, sr, cs, cr)
    ├── AGG (GROUP BY)
    ├── SORT (channel ASC, id ASC)
    └── OUTPUT (channel, id, sales, returns, profit)
```

## Output Format

Your response has **two parts** in order:

### Part 1: Modified Logic Tree

Show what changed using change markers. Generate the tree BEFORE writing SQL.

Change markers:
- `[+]` — New component added
- `[-]` — Component removed
- `[~]` — Component modified (describe what changed)
- `[=]` — Unchanged (no children needed)
- `[!]` — Structural change (e.g. CTE → subquery)

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "<dialect>",
  "rewrite_rules": [
    {"id": "R1", "type": "<transform_name>", "description": "<what changed>", "applied_to": ["<component_id>"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "<cte_name>": {
        "type": "cte",
        "change": "modified",
        "sql": "<complete SQL for this CTE body>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<upstream_id>"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "<final SELECT>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<cte_name>"]}
      }
    },
    "reconstruction_order": ["<cte_name>", "main_query"],
    "assembly_template": "WITH <cte_name> AS ({<cte_name>}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Rules
- **Tree first, always.** Generate the Logic Tree before writing any SQL
- **One component at a time.** When writing SQL for component X, treat others as opaque interfaces
- **No ellipsis.** Every `sql` value must be complete, executable SQL
- **Frozen blocks are copy-paste.** Large CASE-WHEN lookups must be verbatim
- **Validate interfaces.** Verify every `consumes` reference exists in upstream `outputs`
- Only include components you **changed or added** — set unchanged components to `"change": "unchanged"` with `"sql": ""`
- `main_query` output columns must match the Column Completeness Contract above
- `reconstruction_order`: topological order of components for assembly

After the JSON, explain the mechanism:

```
Changes: <1-2 sentences: what structural change + the expected mechanism>
Expected speedup: <estimate>
```

Now output your Logic Tree and Component Payload JSON: