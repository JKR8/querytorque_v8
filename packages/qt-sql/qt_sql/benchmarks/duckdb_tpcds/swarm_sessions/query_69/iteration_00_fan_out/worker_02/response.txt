## Part 1: Modified Logic Tree

```
QUERY: (multiple statements with CTEs)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~4.3K  — Build staged CTE pipeline with dimension isolation and fact prefetching
    ├── [=] CTE date_range
    │   └── [~] FROM: date_dim → Filtered for d_year=2000, d_moy 1-3
    ├── [+] CTE store_sales_with_date
    │   └── [~] FROM: store_sales JOIN date_range → Pre-join fact with date dimension
    ├── [+] CTE web_sales_with_date  
    │   └── [~] FROM: web_sales JOIN date_range → Pre-join fact with date dimension
    ├── [+] CTE catalog_sales_with_date
    │   └── [~] FROM: catalog_sales JOIN date_range → Pre-join fact with date dimension
    ├── [+] CTE customer_base
    │   └── [~] FROM: customer JOIN address JOIN demographics → Early filter on state and join dimensions
    ├── [~] CTE progressive_joins (was: implicit EXISTS/NOT EXISTS)
    │   └── FROM: customer_base
    │       ├── SEMI JOIN store_sales_with_date (via WHERE EXISTS)
    │       ├── ANTI JOIN web_sales_with_date (via WHERE NOT EXISTS)  
    │       └── ANTI JOIN catalog_sales_with_date (via WHERE NOT EXISTS)
    ├── [=] AGG (GROUP BY)
    ├── [=] SORT (same columns)
    └── [=] OUTPUT (same columns)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Extract customer, address, demographics join into early-filtered CTE", "applied_to": ["customer_base"]},
    {"id": "R2", "type": "prefetch_fact_join", "description": "Pre-join each sales fact table with date_range CTE to create filtered fact sets", "applied_to": ["store_sales_with_date", "web_sales_with_date", "catalog_sales_with_date"]},
    {"id": "R3", "type": "semantic_preservation", "description": "Convert original EXISTS/NOT EXISTS to semi/anti joins using WHERE subqueries to preserve early termination", "applied_to": ["progressive_joins"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_range": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2000 AND d_moy BETWEEN 1 AND 3",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_sales_with_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_customer_sk FROM store_sales JOIN date_range ON ss_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["ss_customer_sk"], "consumes": ["date_range"]}
      },
      "web_sales_with_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ws_bill_customer_sk FROM web_sales JOIN date_range ON ws_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["ws_bill_customer_sk"], "consumes": ["date_range"]}
      },
      "catalog_sales_with_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cs_ship_customer_sk FROM catalog_sales JOIN date_range ON cs_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["cs_ship_customer_sk"], "consumes": ["date_range"]}
      },
      "customer_base": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, cd.cd_gender, cd.cd_marital_status, cd.cd_education_status, cd.cd_purchase_estimate, cd.cd_credit_rating FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk WHERE ca.ca_state IN ('TX', 'VA', 'MI')",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": []}
      },
      "progressive_joins": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating FROM customer_base cb WHERE EXISTS (SELECT 1 FROM store_sales_with_date ss WHERE ss.ss_customer_sk = cb.c_customer_sk) AND NOT EXISTS (SELECT 1 FROM web_sales_with_date ws WHERE ws.ws_bill_customer_sk = cb.c_customer_sk) AND NOT EXISTS (SELECT 1 FROM catalog_sales_with_date cs WHERE cs.cs_ship_customer_sk = cb.c_customer_sk)",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["customer_base", "store_sales_with_date", "web_sales_with_date", "catalog_sales_with_date"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM progressive_joins GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"], "consumes": ["progressive_joins"]}
      }
    },
    "reconstruction_order": ["date_range", "store_sales_with_date", "web_sales_with_date", "catalog_sales_with_date", "customer_base", "progressive_joins", "main_query"],
    "assembly_template": "WITH date_range AS ({date_range}), store_sales_with_date AS ({store_sales_with_date}), web_sales_with_date AS ({web_sales_with_date}), catalog_sales_with_date AS ({catalog_sales_with_date}), customer_base AS ({customer_base}), progressive_joins AS ({progressive_joins}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Converted original query into staged CTE pipeline: date_range dimension filtered once, each sales fact pre-joined with dates, customer dimensions filtered and joined early, then progressive filtering via EXISTS/NOT EXISTS subqueries (preserving semi/anti join semantics) before aggregation. This isolates date scans to a single CTE and builds small dimension hash tables early.

**Expected speedup:** ~2-4x (dimension isolation + fact prefetching).