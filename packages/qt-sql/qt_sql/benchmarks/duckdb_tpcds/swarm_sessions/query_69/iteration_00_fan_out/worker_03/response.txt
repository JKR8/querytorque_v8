## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K
    ├── CTE date_range  [+]
    │   ├── SCAN date_dim
    │   ├── FILTER (d_year = 2000 AND d_moy BETWEEN 1 AND 3)
    │   └── OUTPUT d_date_sk
    ├── CTE address_filter  [+]
    │   ├── SCAN customer_address
    │   ├── FILTER (ca_state IN ('TX', 'VA', 'MI'))
    │   └── OUTPUT ca_address_sk
    ├── CTE demographics_filter  [+]
    │   ├── SCAN customer_demographics
    │   └── OUTPUT cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    ├── CTE customer_base  [+]
    │   ├── SCAN customer c
    │   ├── JOIN address_filter a ON c.c_current_addr_sk = a.ca_address_sk
    │   ├── JOIN demographics_filter d ON c.c_current_cdemo_sk = d.cd_demo_sk
    │   └── OUTPUT c_customer_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    ├── CTE channel_checks  [+]
    │   ├── SCAN customer_base cb
    │   ├── FILTER EXISTS (store_sales + date_range)
    │   ├── FILTER NOT EXISTS (web_sales + date_range)
    │   ├── FILTER NOT EXISTS (catalog_sales + date_range)
    │   └── OUTPUT c_customer_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    ├── CTE group_by  [+]
    │   ├── SCAN channel_checks
    │   ├── AGG GROUP BY (cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating)
    │   ├── AGG COUNT(*) AS cnt1, COUNT(*) AS cnt2, COUNT(*) AS cnt3
    │   └── OUTPUT cd_gender, cd_marital_status, cd_education_status, cnt1, cd_purchase_estimate, cnt2, cd_credit_rating, cnt3
    ├── SELECT FROM group_by  [=]
    ├── SORT (cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating)  [=]
    └── OUTPUT (cd_gender, cd_marital_status, cd_education_status, cnt1, cd_purchase_estimate, cnt2, cd_credit_rating, cnt3)  [=]
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter date_dim into date_range CTE to isolate date filter", "applied_to": ["date_range"]},
    {"id": "R2", "type": "early_filter", "description": "Filter customer_address by state early in address_filter CTE", "applied_to": ["address_filter"]},
    {"id": "R3", "type": "dimension_cte_isolate", "description": "Select only needed columns from customer_demographics early", "applied_to": ["demographics_filter"]},
    {"id": "R4", "type": "join_dimension_ctes", "description": "Join filtered dimension CTEs through customer table to create customer_base", "applied_to": ["customer_base"]},
    {"id": "R5", "type": "preserve_semi_anti_joins", "description": "Keep EXISTS/NOT EXISTS as semi/anti joins with date_range CTE referenced 3 times", "applied_to": ["channel_checks"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_range": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2000 AND d_moy BETWEEN 1 AND 3",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "address_filter": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_state IN ('TX', 'VA', 'MI')",
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "demographics_filter": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cd_demo_sk, cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating FROM customer_demographics",
        "interfaces": {"outputs": ["cd_demo_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": []}
      },
      "customer_base": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, d.cd_gender, d.cd_marital_status, d.cd_education_status, d.cd_purchase_estimate, d.cd_credit_rating FROM customer c JOIN address_filter a ON c.c_current_addr_sk = a.ca_address_sk JOIN demographics_filter d ON c.c_current_cdemo_sk = d.cd_demo_sk",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["address_filter", "demographics_filter"]}
      },
      "channel_checks": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cb.c_customer_sk, cb.cd_gender, cb.cd_marital_status, cb.cd_education_status, cb.cd_purchase_estimate, cb.cd_credit_rating FROM customer_base cb WHERE EXISTS (SELECT 1 FROM store_sales ss JOIN date_range dr ON ss.ss_sold_date_sk = dr.d_date_sk WHERE ss.ss_customer_sk = cb.c_customer_sk) AND NOT EXISTS (SELECT 1 FROM web_sales ws JOIN date_range dr ON ws.ws_sold_date_sk = dr.d_date_sk WHERE ws.ws_bill_customer_sk = cb.c_customer_sk) AND NOT EXISTS (SELECT 1 FROM catalog_sales cs JOIN date_range dr ON cs.cs_sold_date_sk = dr.d_date_sk WHERE cs.cs_ship_customer_sk = cb.c_customer_sk)",
        "interfaces": {"outputs": ["c_customer_sk", "cd_gender", "cd_marital_status", "cd_education_status", "cd_purchase_estimate", "cd_credit_rating"], "consumes": ["customer_base", "date_range"]}
      },
      "group_by": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, COUNT(*) AS cnt1, cd_purchase_estimate, COUNT(*) AS cnt2, cd_credit_rating, COUNT(*) AS cnt3 FROM channel_checks GROUP BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"], "consumes": ["channel_checks"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT cd_gender, cd_marital_status, cd_education_status, cnt1, cd_purchase_estimate, cnt2, cd_credit_rating, cnt3 FROM group_by ORDER BY cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating LIMIT 100",
        "interfaces": {"outputs": ["cd_gender", "cd_marital_status", "cd_education_status", "cnt1", "cd_purchase_estimate", "cnt2", "cd_credit_rating", "cnt3"], "consumes": ["group_by"]}
      }
    },
    "reconstruction_order": ["date_range", "address_filter", "demographics_filter", "customer_base", "channel_checks", "group_by", "main_query"],
    "assembly_template": "WITH date_range AS ({date_range}), address_filter AS ({address_filter}), demographics_filter AS ({demographics_filter}), customer_base AS ({customer_base}), channel_checks AS ({channel_checks}), group_by AS ({group_by}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured query into 6 CTEs following target logical tree: date_range isolates date filter, address_filter applies state filter early, demographics_filter selects needed columns, customer_base joins through customer table, channel_checks preserves EXISTS/NOT EXISTS semi/anti joins, group_by aggregates with three counts.

**Expected speedup:** ~1.5-2.0x from dimension pre-filtering and preserving semi/anti join short-circuiting while avoiding materialization of full fact tables.