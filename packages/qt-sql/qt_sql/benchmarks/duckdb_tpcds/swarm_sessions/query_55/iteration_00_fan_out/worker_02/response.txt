### Part 1: Modified Logic Tree

```
QUERY: (multiple statements)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~100 — Uses materialized CTEs for dimension isolation and early filtering
    ├── [CTE] filtered_date  [+]  — Isolate date filter to small lookup
    ├── [CTE] filtered_item  [+]  — Isolate item filter to small lookup  
    ├── [CTE] joined_sales  [+]   — Join fact table with filtered dimensions
    ├── [CTE] aggregated  [+]     — Aggregate after joins
    ├── SORT (ext_price DESC, i_brand_id ASC)
    └── OUTPUT (brand_id, brand, ext_price)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb_v1.4.3",
  "rewrite_rules": [
    {"id": "R1", "type": "date_cte_isolate", "description": "Extract date filter into CTE for dimension isolation", "applied_to": ["filtered_date"]},
    {"id": "R2", "type": "dimension_cte_isolate", "description": "Extract item filter into CTE for dimension isolation", "applied_to": ["filtered_item"]},
    {"id": "R3", "type": "early_filter", "description": "Apply dimension filters before joining with large fact table", "applied_to": ["joined_sales"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 12 AND d_year = 2000",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_brand_id, i_brand FROM item WHERE i_manager_id = 100",
        "interfaces": {"outputs": ["i_item_sk", "i_brand_id", "i_brand"], "consumes": []}
      },
      "joined_sales": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT filtered_item.i_brand_id, filtered_item.i_brand, store_sales.ss_ext_sales_price FROM store_sales INNER JOIN filtered_date ON store_sales.ss_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_item ON store_sales.ss_item_sk = filtered_item.i_item_sk",
        "interfaces": {"outputs": ["i_brand_id", "i_brand", "ss_ext_sales_price"], "consumes": ["filtered_date", "filtered_item"]}
      },
      "aggregated": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_brand_id, i_brand, SUM(ss_ext_sales_price) AS ext_price FROM joined_sales GROUP BY i_brand_id, i_brand",
        "interfaces": {"outputs": ["i_brand_id", "i_brand", "ext_price"], "consumes": ["joined_sales"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, ext_price FROM aggregated ORDER BY ext_price DESC, i_brand_id LIMIT 100",
        "interfaces": {"outputs": ["brand_id", "brand", "ext_price"], "consumes": ["aggregated"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_item", "joined_sales", "aggregated", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_item AS ({filtered_item}), joined_sales AS ({joined_sales}), aggregated AS ({aggregated}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured into explicit CTEs for early dimension filtering and materialization, isolating date and item lookups into small hash tables before joining with the large fact table. This forces predicate pushdown at CTE boundaries.

**Expected speedup**: 2-4× due to reduced fact table scan (from 100% to ~0.27% matching rows) and smaller hash tables for dimension joins.