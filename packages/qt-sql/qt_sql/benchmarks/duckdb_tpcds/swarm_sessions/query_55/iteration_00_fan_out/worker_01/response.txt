### Modified Logic Tree

```
[+] filtered_date
    ├── FROM: date_dim
    ├── WHERE: d_moy = 12 AND d_year = 2000
    └── OUTPUT: d_date_sk
[+] filtered_item
    ├── FROM: item
    ├── WHERE: i_manager_id = 100
    └── OUTPUT: i_item_sk, i_brand_id, i_brand
[+] fact_with_dims
    ├── FROM: store_sales
    ├── JOIN: INNER JOIN filtered_date ON store_sales.ss_sold_date_sk = filtered_date.d_date_sk
    ├── JOIN: INNER JOIN filtered_item ON store_sales.ss_item_sk = filtered_item.i_item_sk
    └── OUTPUT: i_brand_id, i_brand, ss_ext_sales_price
[+] aggregated
    ├── FROM: fact_with_dims
    ├── GROUP BY: i_brand_id, i_brand
    ├── AGGREGATE: SUM(ss_ext_sales_price) AS ext_price
    └── OUTPUT: i_brand_id, i_brand, ext_price
[~] main_query (renamed from original)
    ├── FROM: aggregated
    ├── ORDER BY: ext_price DESC, i_brand_id ASC
    ├── LIMIT: 100
    ├── OUTPUT: brand_id (i_brand_id), brand (i_brand), ext_price
    └── [STRUCTURAL CHANGE] Replaced single SELECT with staged CTE pipeline
```

### Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_isolation", "description": "Extracted date dimension filter into separate CTE", "applied_to": ["filtered_date"]},
    {"id": "R2", "type": "dimension_isolation", "description": "Extracted item dimension filter into separate CTE", "applied_to": ["filtered_item"]},
    {"id": "R3", "type": "staged_join_pipeline", "description": "Pre-joined filtered dimensions with fact table in CTE chain", "applied_to": ["fact_with_dims", "aggregated", "main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 12 AND d_year = 2000",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_brand_id, i_brand FROM item WHERE i_manager_id = 100",
        "interfaces": {"outputs": ["i_item_sk", "i_brand_id", "i_brand"], "consumes": []}
      },
      "fact_with_dims": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT filtered_item.i_brand_id, filtered_item.i_brand, store_sales.ss_ext_sales_price FROM store_sales INNER JOIN filtered_date ON store_sales.ss_sold_date_sk = filtered_date.d_date_sk INNER JOIN filtered_item ON store_sales.ss_item_sk = filtered_item.i_item_sk",
        "interfaces": {"outputs": ["i_brand_id", "i_brand", "ss_ext_sales_price"], "consumes": ["filtered_date", "filtered_item"]}
      },
      "aggregated": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_brand_id, i_brand, SUM(ss_ext_sales_price) AS ext_price FROM fact_with_dims GROUP BY i_brand_id, i_brand",
        "interfaces": {"outputs": ["i_brand_id", "i_brand", "ext_price"], "consumes": ["fact_with_dims"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, ext_price FROM aggregated ORDER BY ext_price DESC, i_brand_id ASC LIMIT 100",
        "interfaces": {"outputs": ["brand_id", "brand", "ext_price"], "consumes": ["aggregated"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_item", "fact_with_dims", "aggregated", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_item AS ({filtered_item}), fact_with_dims AS ({fact_with_dims}), aggregated AS ({aggregated}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Replaced the original single SELECT with a staged CTE pipeline that first isolates dimension filters (date_dim, item), then joins them with the fact table, aggregates, and finally orders/limits. This creates small hash tables for dimension lookups and pushes filters before joins.

**Expected speedup**: 2-4x due to reduced hash table build size for dimension lookups and better predicate pushdown isolation.