## Part 1: Modified Logic Tree

```
[~] main_query  [restructured into explicit CTE chain per target logical tree]
    ├── [+] filtered_item (CTE)
    ├── [+] filtered_inventory_date_with_catalog (CTE)
    ├── [+] early_group (CTE)
    └── [=] final_select (SELECT from early_group with ORDER BY/LIMIT)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_decomposition",
      "description": "Break original monolithic join into explicit CTEs matching target logical tree",
      "applied_to": ["filtered_item", "filtered_inventory_date_with_catalog", "early_group"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_item": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT i_item_sk, i_item_id, i_item_desc, i_current_price FROM item WHERE i_current_price BETWEEN 45 AND 45 + 30 AND i_manufact_id IN (856, 707, 1000, 747)",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_current_price"],
            "consumes": []
          }
        },
        "filtered_inventory_date_with_catalog": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT fi.i_item_sk, fi.i_item_id, fi.i_item_desc, fi.i_current_price, cs.cs_item_sk FROM inventory inv INNER JOIN filtered_item fi ON inv.inv_item_sk = fi.i_item_sk INNER JOIN date_dim d ON inv.inv_date_sk = d.d_date_sk INNER JOIN catalog_sales cs ON cs.cs_item_sk = fi.i_item_sk WHERE inv.inv_quantity_on_hand BETWEEN 100 AND 500 AND d.d_date BETWEEN CAST('1999-02-21' AS DATE) AND (CAST('1999-02-21' AS DATE) + INTERVAL 60 DAY)",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_current_price", "cs_item_sk"],
            "consumes": ["filtered_item"]
          }
        },
        "early_group": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT i_item_id, i_item_desc, i_current_price FROM filtered_inventory_date_with_catalog GROUP BY i_item_id, i_item_desc, i_current_price",
          "interfaces": {
            "outputs": ["i_item_id", "i_item_desc", "i_current_price"],
            "consumes": ["filtered_inventory_date_with_catalog"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_item_id, i_item_desc, i_current_price FROM early_group ORDER BY i_item_id LIMIT 100",
          "interfaces": {
            "outputs": ["i_item_id", "i_item_desc", "i_current_price"],
            "consumes": ["early_group"]
          }
        }
      },
      "reconstruction_order": ["filtered_item", "filtered_inventory_date_with_catalog", "early_group", "main_query"],
      "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_inventory_date_with_catalog AS ({filtered_inventory_date_with_catalog}), early_group AS ({early_group}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured the original implicit join query into an explicit CTE chain following the target logical tree, maintaining exact semantic equivalence while enabling potential join order control and predicate pushdown optimization.

**Expected speedup:** ~1.2-1.5x through explicit join order control and reduced intermediate result sizes via early filtering in CTEs, while avoiding regression risks by preserving all original guard conditions and literals.