## Part 1: Modified Logic Tree

```
QUERY: (with CTEs)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~3  — Restructured as CTE chain per Target Logical Tree
    ├── [~] CTE filtered_item  [=]  Rows: 3,410 — Isolated item filters into standalone CTE
    │   ├── SCAN (item)
    │   └── FILTER (i_current_price BETWEEN 45 AND 75 AND i_manufact_id IN (856,707,1000,747))
    ├── [~] CTE filtered_inventory_date  [~]  Rows: 98 — INNER JOIN replaces Cartesian join; filters moved
    │   ├── JOIN (INNER inventory ↔ filtered_item ON inv_item_sk = i_item_sk)
    │   ├── JOIN (INNER date_dim ON inv_date_sk = d_date_sk)
    │   ├── FILTER (inv_quantity_on_hand BETWEEN 100 AND 500)
    │   └── FILTER (d_date BETWEEN CAST('1999-02-21' AS DATE) AND (CAST('1999-02-21' AS DATE) + INTERVAL 60 DAY))
    ├── [~] CTE exists_check  [+]  Rows: 3 — EXISTS replaces INNER JOIN with catalog_sales
    │   ├── SEMI-JOIN (EXISTS with catalog_sales ON cs_item_sk = i_item_sk)
    │   └── Preserves same rows as original INNER JOIN + GROUP BY dedup
    ├── [=] final_group  [=]  Rows: 3 — Maintains GROUP BY for safety with same columns
    │   ├── AGG (GROUP BY i_item_id, i_item_desc, i_current_price)
    │   ├── SORT (i_item_id ASC)
    │   └── LIMIT 100
    └── OUTPUT (i_item_id, i_item_desc, i_current_price)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_breakout", "description": "Isolate item scan with price/manufacturer filters into standalone CTE", "applied_to": ["filtered_item"]},
    {"id": "R2", "type": "cte_breakout", "description": "Isolate inventory-date join with quantity and date window filters", "applied_to": ["filtered_inventory_date"]},
    {"id": "R3", "type": "semi_join_exists", "description": "Replace INNER JOIN with catalog_sales with EXISTS subquery for semi-join optimization", "applied_to": ["exists_check"]},
    {"id": "R4", "type": "group_by_preserve", "description": "Keep GROUP BY to deduplicate potential multiple inventory rows per item", "applied_to": ["final_group"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_item": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_id, i_item_desc, i_current_price FROM item WHERE i_current_price BETWEEN 45 AND 75 AND i_manufact_id IN (856,707,1000,747)",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_current_price"], "consumes": []}
      },
      "filtered_inventory_date": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT fi.i_item_sk, fi.i_item_id, fi.i_item_desc, fi.i_current_price FROM inventory inv INNER JOIN filtered_item fi ON inv.inv_item_sk = fi.i_item_sk INNER JOIN date_dim dd ON inv.inv_date_sk = dd.d_date_sk WHERE inv.inv_quantity_on_hand BETWEEN 100 AND 500 AND dd.d_date BETWEEN CAST('1999-02-21' AS DATE) AND (CAST('1999-02-21' AS DATE) + INTERVAL 60 DAY)",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id", "_item_desc", "i_current_price"], "consumes": ["filtered_item"]}
      },
      "exists_check": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_item_sk, i_item_id, i_item_desc, i_current_price FROM filtered_inventory_date fid WHERE EXISTS (SELECT 1 FROM catalog_sales cs WHERE cs.cs_item_sk = fid.i_item_sk)",
        "interfaces": {"outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_current_price"], "consumes": ["filtered_inventory_date"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, i_current_price FROM exists_check GROUP BY i_item_id, i_item_desc, i_current_price ORDER BY i_item_id LIMIT 100",
        "interfaces": {"outputs": ["i_item_id", "i_item_desc", "i_current_price"], "consumes": ["exists_check"]}
      }
    },
    "reconstruction_order": ["filtered_item", "filtered_inventory_date", "exists_check", "main_query"],
    "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_inventory_date AS ({filtered_inventory_date}), exists_check AS ({exists_check}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": [
    "Output columns match original: i_item_id, i_item_desc, i_current_price",
    "Preserved all literals: price band 45-75, manufacturers (856,707,1000,747), date '1999-02-21' + 60 days, quantity 100-500",
    "GROUP BY maintained for deduplication safety",
    "EXISTS used instead of INNER JOIN for semi-join optimization"
  ]
}
```

Changes: Restructured original flat query into CTE chain following Target Logical Tree, replacing INNER JOIN with catalog_sales with EXISTS subquery for semi-join optimization while preserving all filters and output columns.

Expected speedup: 1.5-2x due to early filtering in CTEs, predicate pushdown opportunities, and EXISTS short-circuiting vs full join materialization.