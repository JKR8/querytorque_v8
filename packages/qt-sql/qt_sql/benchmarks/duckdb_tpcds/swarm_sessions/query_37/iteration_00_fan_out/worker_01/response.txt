## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [+] filtered_item
│   ├── SCAN (item)
│   └── FILTER (i_current_price BETWEEN 45 AND 75 AND i_manufact_id IN (856,707,1000,747))
├── [+] filtered_date
│   ├── SCAN (date_dim)
│   └── FILTER (d_date BETWEEN CAST('1999-02-21' AS DATE) AND (CAST('1999-02-21' AS DATE) + INTERVAL 60 DAY))
├── [+] filtered_inventory
│   ├── SCAN (inventory)
│   └── FILTER (inv_quantity_on_hand BETWEEN 100 AND 500)
├── [+] prejoined_inv_item_date
│   ├── SCAN (filtered_inventory)
│   ├── JOIN (INNER) filtered_item ON inv_item_sk = i_item_sk
│   └── JOIN (INNER) filtered_date ON inv_date_sk = d_date_sk
└── [~] main_query
    ├── SCAN (prejoined_inv_item_date)
    ├── FILTER (EXISTS (SELECT 1 FROM catalog_sales WHERE cs_item_sk = i_item_sk))
    ├── AGG (GROUP BY i_item_id, i_item_desc, i_current_price)
    ├── SORT (i_item_id ASC)
    └── OUTPUT (i_item_id, i_item_desc, i_current_price)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "dimension_cte_isolate",
      "description": "Pre-filter dimension tables (item, date_dim) into separate CTEs returning only needed columns",
      "applied_to": ["filtered_item", "filtered_date"]
    },
    {
      "id": "R2",
      "type": "prefetch_fact_join",
      "description": "Stage join pipeline: filter fact table (inventory), then join with filtered dimensions in separate CTE",
      "applied_to": ["filtered_inventory", "prejoined_inv_item_date"]
    },
    {
      "id": "R3",
      "type": "early_filter",
      "description": "Apply dimension filters before joining with large fact tables",
      "applied_to": ["filtered_item", "filtered_date", "filtered_inventory"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_item": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT i_item_sk, i_item_id, i_item_desc, i_current_price FROM item WHERE i_current_price BETWEEN 45 AND 75 AND i_manufact_id IN (856, 707, 1000, 747)",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_current_price"],
            "consumes": []
          }
        },
        "filtered_date": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1999-02-21' AS DATE) AND (CAST('1999-02-21' AS DATE) + INTERVAL 60 DAY)",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "filtered_inventory": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT inv_item_sk, inv_date_sk FROM inventory WHERE inv_quantity_on_hand BETWEEN 100 AND 500",
          "interfaces": {
            "outputs": ["inv_item_sk", "inv_date_sk"],
            "consumes": []
          }
        },
        "prejoined_inv_item_date": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT fi.i_item_sk, fi.i_item_id, fi.i_item_desc, fi.i_current_price FROM filtered_inventory inv INNER JOIN filtered_item fi ON inv.inv_item_sk = fi.i_item_sk INNER JOIN filtered_date fd ON inv.inv_date_sk = fd.d_date_sk",
          "interfaces": {
            "outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_current_price"],
            "consumes": ["filtered_inventory", "filtered_item", "filtered_date"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_item_id, i_item_desc, i_current_price FROM prejoined_inv_item_date WHERE EXISTS (SELECT 1 FROM catalog_sales WHERE cs_item_sk = i_item_sk) GROUP BY i_item_id, i_item_desc, i_current_price ORDER BY i_item_id LIMIT 100",
          "interfaces": {
            "outputs": ["i_item_id", "i_item_desc", "i_current_price"],
            "consumes": ["prejoined_inv_item_date"]
          }
        }
      },
      "reconstruction_order": ["filtered_item", "filtered_date", "filtered_inventory", "prejoined_inv_item_date", "main_query"],
      "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_date AS ({filtered_date}), filtered_inventory AS ({filtered_inventory}), prejoined_inv_item_date AS ({prejoined_inv_item_date}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured the flat join into a staged CTE pipeline: first isolate dimension filters (item, date), then filter inventory, join them together, and finally apply the catalog_sales existence check. This creates small hash tables for early joins and reduces the working set before the EXISTS semi-join.

**Expected speedup:** 1.8-2.5x due to reduced intermediate data volume and better predicate pushdown to dimension scans. The baseline of 128ms suggests CTE overhead is acceptable for this data reduction benefit.