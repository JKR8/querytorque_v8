## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [+] date_2000  [~]  Cost: 0%  Rows: 366 — Filter date_dim for year 2000 and output date keys.
│   └── OUTPUT (d_date_sk, d_year)
├── [-] ws  [REMOVED]
├── [-] cs  [REMOVED]
├── [-] ss  [REMOVED]
├── [+] sales_prejoined  [~]  Cost: 60%  Rows: ≤5.5M — Single pass joining store_sales to filtered dates, left-joining returns and other channels, then filtering out returned transactions.
│   ├── SCAN (store_sales, store_returns (left join), web_sales (left join), web_returns (left join), catalog_sales (left join), catalog_returns (left join))
│   ├── JOIN (date_2000)
│   ├── FILTER (sr_ticket_number IS NULL AND wr_order_number IS NULL AND cr_order_number IS NULL)
│   └── OUTPUT (d_year, item_sk, customer_sk, ss_quantity, ss_wholesale_cost, ss_sales_price, ws_quantity, ws_wholesale_cost, ws_sales_price, cs_quantity, cs_wholesale_cost, cs_sales_price)
├── [+] channel_aggregates  [~]  Cost: 30%  Rows: ~4.9M — Aggregate pre-joined sales by year, item, customer across all channels.
│   ├── SCAN (sales_prejoined)
│   ├── AGG (GROUP BY d_year, item_sk, customer_sk)
│   └── OUTPUT (sold_year, item_sk, customer_sk, ss_qty, ss_wc, ss_sp, ws_qty, ws_wc, ws_sp, cs_qty, cs_wc, cs_sp)
└── [~] main_query  [~]  Cost: 10%  Rows: 100 — Filter for items with web/catalog activity, compute ratios, and order by 8‑column sort.
    ├── SCAN (channel_aggregates)
    ├── FILTER ((COALESCE(ws_qty,0) > 0 OR COALESCE(cs_qty,0) > 0))
    ├── SORT (item_sk ASC, ss_qty DESC, ss_wc DESC, ss_sp DESC, other_chan_qty ASC, other_chan_wholesale_cost ASC, other_chan_sales_price ASC, ratio ASC)
    └── OUTPUT (ss_item_sk, ratio, store_qty, store_wholesale_cost, store_sales_price, other_chan_qty, other_chan_wholesale_cost, other_chan_sales_price)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "prefetch_fact_join", "description": "Replaced three separate channel CTEs with a single pre-joined CTE that filters date_dim once and joins all channels in a single pass, reducing redundant date scans and enabling early return filtering.", "applied_to": ["date_2000", "sales_prejoined"]},
    {"id": "R2", "type": "deferred_aggregation", "description": "Aggregated channel metrics after joining, eliminating duplicate aggregation of same rows across separate CTEs and reducing intermediate data volume.", "applied_to": ["channel_aggregates"]},
    {"id": "R3", "type": "predicate_pushdown", "description": "Pushed year=2000 filter into date_2000 CTE; pushed return‑null filters into sales_prejoined WHERE clause, eliminating returned rows before aggregation.", "applied_to": ["date_2000", "sales_prejoined"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_2000": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year = 2000",
        "interfaces": {"outputs": ["d_date_sk", "d_year"], "consumes": []}
      },
      "sales_prejoined": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_year, ss_item_sk AS item_sk, ss_customer_sk AS customer_sk, ss_quantity, ss_wholesale_cost, ss_sales_price, ws_quantity, ws_wholesale_cost, ws_sales_price, cs_quantity, cs_wholesale_cost, cs_sales_price FROM store_sales LEFT JOIN store_returns ON sr_ticket_number = ss_ticket_number AND ss_item_sk = sr_item_sk LEFT JOIN web_sales ON ws_sold_date_sk = d_date_sk AND ws_item_sk = ss_item_sk AND ws_bill_customer_sk = ss_customer_sk LEFT JOIN web_returns ON wr_order_number = ws_order_number AND ws_item_sk = wr_item_sk LEFT JOIN catalog_sales ON cs_sold_date_sk = d_date_sk AND cs_item_sk = ss_item_sk AND cs_bill_customer_sk = ss_customer_sk LEFT JOIN catalog_returns ON cr_order_number = cs_order_number AND cs_item_sk = cr_item_sk JOIN date_2000 ON ss_sold_date_sk = d_date_sk WHERE sr_ticket_number IS NULL AND wr_order_number IS NULL AND cr_order_number IS NULL",
        "interfaces": {"outputs": ["d_year", "item_sk", "customer_sk", "ss_quantity", "ss_wholesale_cost", "ss_sales_price", "ws_quantity", "ws_wholesale_cost", "ws_sales_price", "cs_quantity", "cs_wholesale_cost", "cs_sales_price"], "consumes": ["date_2000"]}
      },
      "channel_aggregates": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_year AS sold_year, item_sk, customer_sk, SUM(ss_quantity) AS ss_qty, SUM(ss_wholesale_cost) AS ss_wc, SUM(ss_sales_price) AS ss_sp, SUM(ws_quantity) AS ws_qty, SUM(ws_wholesale_cost) AS ws_wc, SUM(ws_sales_price) AS ws_sp, SUM(cs_quantity) AS cs_qty, SUM(cs_wholesale_cost) AS cs_wc, SUM(cs_sales_price) AS cs_sp FROM sales_prejoined GROUP BY d_year, item_sk, customer_sk",
        "interfaces": {"outputs": ["sold_year", "item_sk", "customer_sk", "ss_qty", "ss_wc", "ss_sp", "ws_qty", "ws_wc", "ws_sp", "cs_qty", "cs_wc", "cs_sp"], "consumes": ["sales_prejoined"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT item_sk AS ss_item_sk, ROUND(ss_qty / (COALESCE(ws_qty, 0) + COALESCE(cs_qty, 0)), 2) AS ratio, ss_qty AS store_qty, ss_wc AS store_wholesale_cost, ss_sp AS store_sales_price, COALESCE(ws_qty, 0) + COALESCE(cs_qty, 0) AS other_chan_qty, COALESCE(ws_wc, 0) + COALESCE(cs_wc, 0) AS other_chan_wholesale_cost, COALESCE(ws_sp, 0) + COALESCE(cs_sp, 0) AS other_chan_sales_price FROM channel_aggregates WHERE (COALESCE(ws_qty, 0) > 0 OR COALESCE(cs_qty, 0) > 0) ORDER BY item_sk ASC, ss_qty DESC, ss_wc DESC, ss_sp DESC, (COALESCE(ws_qty, 0) + COALESCE(cs_qty, 0)) ASC, (COALESCE(ws_wc, 0) + COALESCE(cs_wc, 0)) ASC, (COALESCE(ws_sp, 0) + COALESCE(cs_sp, 0)) ASC, ROUND(ss_qty / (COALESCE(ws_qty, 0) + COALESCE(cs_qty, 0)), 2) ASC LIMIT 100",
        "interfaces": {"outputs": ["ss_item_sk", "ratio", "store_qty", "store_wholesale_cost", "store_sales_price", "other_chan_qty", "other_chan_wholesale_cost", "other_chan_sales_price"], "consumes": ["channel_aggregates"]}
      }
    },
    "reconstruction_order": ["date_2000", "sales_prejoined", "channel_aggregates", "main_query"],
    "assembly_template": "WITH date_2000 AS ({date_2000}), sales_prejoined AS ({sales_prejoined}), channel_aggregates AS ({channel_aggregates}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Replaced three separate channel CTEs with a staged join pipeline: first filter dates once, then join store_sales to filtered dates and left‑join returns/other channels in a single pass, filter out returns, then aggregate. This eliminates three separate date‑dim scans and reduces intermediate data by aggregating after the join.

**Expected speedup:** 2–3× from eliminating redundant date scans, early return filtering, and reduced intermediate materialization.