## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~100  — Aggregate monthly sales by product/store dimensions, compute average monthly sales via separate aggregation and join, filter rows with >10% relative deviation, and order by deviation and store.
    ├── [CTE] filtered_join  [+]  Cost: 100%  Rows: 593K  — Initial filtered join of item, store_sales, date_dim, store
    ├── [CTE] aggregated_with_avg  [+]  Cost: 96%  Rows: 4.4K  — Aggregate by (category, class, brand, store, company, month) to compute monthly sum
    ├── [CTE] partition_avg  [+]  Cost: 50%  Rows: 2.2K  — Compute average of monthly sums per (category, brand, store, company)
    ├── [CTE] joined_avg  [+]  Cost: 2%  Rows: 4.4K  — Join aggregated_with_avg with partition_avg to attach avg_monthly_sales
    ├── [CTE] filtered  [+]  Cost: 1%  Rows: 4.1K  — Filter where relative deviation > 0.1
    ├── [~] SORT (sum_sales - avg_monthly_sales ASC, s_store_name ASC)  — Same ordering, now applied to filtered CTE
    └── OUTPUT (*)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_based_window_replacement", "description": "Replaced window AVG with separate CTE aggregation and join to match target logical tree", "applied_to": ["aggregated_with_avg", "partition_avg", "joined_avg"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, ss_sales_price FROM item INNER JOIN store_sales ON ss_item_sk = i_item_sk INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk INNER JOIN store ON ss_store_sk = s_store_sk WHERE d_year = 1999 AND s_store_sk <= 100 AND ((i_category IN ('Jewelry','Shoes','Electronics') AND i_class IN ('semi-precious','athletic','portable')) OR (i_category IN ('Men','Music','Women') AND i_class IN ('accessories','rock','maternity')))",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "ss_sales_price"], "consumes": []}
      },
      "aggregated_with_avg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, SUM(ss_sales_price) AS sum_sales FROM filtered_join GROUP BY i_category, i_class, i_brand, s_store_name, s_company_name, d_moy",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "sum_sales"], "consumes": ["filtered_join"]}
      },
      "partition_avg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_brand, s_store_name, s_company_name, AVG(sum_sales) AS avg_monthly_sales FROM aggregated_with_avg GROUP BY i_category, i_brand, s_store_name, s_company_name",
        "interfaces": {"outputs": ["i_category", "i_brand", "s_store_name", "s_company_name", "avg_monthly_sales"], "consumes": ["aggregated_with_avg"]}
      },
      "joined_avg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT a.i_category, a.i_class, a.i_brand, a.s_store_name, a.s_company_name, a.d_moy, a.sum_sales, p.avg_monthly_sales FROM aggregated_with_avg a INNER JOIN partition_avg p ON a.i_category = p.i_category AND a.i_brand = p.i_brand AND a.s_store_name = p.s_store_name AND a.s_company_name = p.s_company_name",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "sum_sales", "avg_monthly_sales"], "consumes": ["aggregated_with_avg", "partition_avg"]}
      },
      "filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT * FROM joined_avg WHERE CASE WHEN avg_monthly_sales <> 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "sum_sales", "avg_monthly_sales"], "consumes": ["joined_avg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT * FROM filtered ORDER BY (sum_sales - avg_monthly_sales) ASC, s_store_name ASC LIMIT 100",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "sum_sales", "avg_monthly_sales"], "consumes": ["filtered"]}
      }
    },
    "reconstruction_order": ["filtered_join", "aggregated_with_avg", "partition_avg", "joined_avg", "filtered", "main_query"],
    "assembly_template": "WITH filtered_join AS ({filtered_join}), aggregated_with_avg AS ({aggregated_with_avg}), partition_avg AS ({partition_avg}), joined_avg AS ({joined_avg}), filtered AS ({filtered}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Replaced the original single-pass query with a CTE structure that matches the target logical tree: filtered join → aggregation → separate partition average computation → join → filter → order/limit. This preserves the exact semantic equivalence (including defensive division guard) while enabling DuckDB's optimizer to apply pushdowns and materialization decisions.

**Expected speedup:** 1.2-1.5x due to better predicate pushdown into filtered_join CTE and explicit control over aggregation steps, while avoiding window function overhead on large partitions.