## Part 1: Modified Logic Tree

```
QUERY: (restructured into CTEs)
└── [!] main_query  [!]  Cost: 100%  Rows: 100 — Now assembled from CTEs with UNION ALL branches
    ├── [+] item_branch1
    │   └── SCAN item  [~]  (filtered on disjoint category/class set)
    ├── [+] join_branch1
    │   ├── JOIN item_branch1 → store_sales → date_dim → store
    │   └── FILTER d_year=1999, s_store_sk<=100
    ├── [+] item_branch2
    │   └── SCAN item  [~]  (filtered on disjoint category/class set)
    ├── [+] join_branch2
    │   ├── JOIN item_branch2 → store_sales → date_dim → store
    │   └── FILTER d_year=1999, s_store_sk<=100
    ├── [+] union_all
    │   └── UNION ALL join_branch1 + join_branch2
    ├── [+] aggregated
    │   └── AGG (GROUP BY i_category,i_class,i_brand,s_store_name,s_company_name,d_moy)
    ├── [+] windowed
    │   └── WINDOW AVG over (i_category,i_brand,s_store_name,s_company_name)
    ├── [+] filtered
    │   └── FILTER (CASE guard > 0.1)
    └── [+] ordered
        ├── SORT (sum_sales - avg_monthly_sales, s_store_name)
        └── LIMIT 100
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "or_to_union", "description": "Split OR on disjoint item categories into UNION ALL branches with separate dimension prefetch", "applied_to": ["item_branch1", "item_branch2", "join_branch1", "join_branch2", "union_all"]},
    {"id": "R2", "type": "dimension_prefetch", "description": "Pre-filter item, date_dim, store into each branch before joining with store_sales", "applied_to": ["item_branch1", "item_branch2", "join_branch1", "join_branch2"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "item_branch1": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_category, i_class, i_brand FROM item WHERE i_category IN ('Jewelry','Shoes','Electronics') AND i_class IN ('semi-precious','athletic','portable')",
        "interfaces": {"outputs": ["i_item_sk", "i_category", "i_class", "i_brand"], "consumes": []}
      },
      "item_branch2": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_category, i_class, i_brand FROM item WHERE i_category IN ('Men','Music','Women') AND i_class IN ('accessories','rock','maternity')",
        "interfaces": {"outputs": ["i_item_sk", "i_category", "i_class", "i_brand"], "consumes": []}
      },
      "join_branch1": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i.i_category, i.i_class, i.i_brand, s.s_store_name, s.s_company_name, d.d_moy, ss.ss_sales_price FROM item_branch1 i INNER JOIN store_sales ss ON i.i_item_sk = ss.ss_item_sk INNER JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk AND d.d_year = 1999 INNER JOIN store s ON ss.ss_store_sk = s.s_store_sk AND s.s_store_sk <= 100",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "ss_sales_price"], "consumes": ["item_branch1"]}
      },
      "join_branch2": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i.i_category, i.i_class, i.i_brand, s.s_store_name, s.s_company_name, d.d_moy, ss.ss_sales_price FROM item_branch2 i INNER JOIN store_sales ss ON i.i_item_sk = ss.ss_item_sk INNER JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk AND d.d_year = 1999 INNER JOIN store s ON ss.ss_store_sk = s.s_store_sk AND s.s_store_sk <= 100",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "ss_sales_price"], "consumes": ["item_branch2"]}
      },
      "union_all": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT * FROM join_branch1 UNION ALL SELECT * FROM join_branch2",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "ss_sales_price"], "consumes": ["join_branch1", "join_branch2"]}
      },
      "aggregated": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, SUM(ss_sales_price) AS sum_sales FROM union_all GROUP BY i_category, i_class, i_brand, s_store_name, s_company_name, d_moy",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "sum_sales"], "consumes": ["union_all"]}
      },
      "windowed": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, AVG(sum_sales) OVER (PARTITION BY i_category, i_brand, s_store_name, s_company_name) AS avg_monthly_sales FROM aggregated",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "sum_sales", "avg_monthly_sales"], "consumes": ["aggregated"]}
      },
      "filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales FROM windowed WHERE CASE WHEN avg_monthly_sales <> 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "sum_sales", "avg_monthly_sales"], "consumes": ["windowed"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales FROM filtered ORDER BY (sum_sales - avg_monthly_sales) ASC, s_store_name ASC LIMIT 100",
        "interfaces": {"outputs": ["i_category", "i_class", "i_brand", "s_store_name", "s_company_name", "d_moy", "sum_sales", "avg_monthly_sales"], "consumes": ["filtered"]}
      }
    },
    "reconstruction_order": ["item_branch1", "item_branch2", "join_branch1", "join_branch2", "union_all", "aggregated", "windowed", "filtered", "main_query"],
    "assembly_template": "WITH item_branch1 AS ({item_branch1}), item_branch2 AS ({item_branch2}), join_branch1 AS ({join_branch1}), join_branch2 AS ({join_branch2}), union_all AS ({union_all}), aggregated AS ({aggregated}), windowed AS ({windowed}), filtered AS ({filtered}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Split the OR condition on disjoint item categories into separate UNION ALL branches, each with pre-filtered dimension CTEs (item, date_dim, store) before joining with store_sales. This allows DuckDB to apply independent join planning per branch.

**Expected speedup:** ~2-3x from reduced fact table scan cost per branch (disjoint filters) and better predicate pushdown into each branch. The UNION ALL prevents predicate push‑through across branches but each branch now has simpler, more selective joins.