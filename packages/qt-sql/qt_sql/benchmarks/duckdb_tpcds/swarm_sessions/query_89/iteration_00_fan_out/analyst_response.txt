<reasoning>
CLASSIFY: This is a star-join with late aggregation and window function, followed by filtering on the window result. The query joins a large fact table (store_sales) with three dimension tables (item, date_dim, store) using surrogate keys, filters on dimension attributes (date year, item category/class), groups by multiple dimensions including month, computes a windowed average per partition, then filters rows where monthly sales deviate >10% from that partition's average.

EXPLAIN PLAN ANALYSIS:
- Total time: 592ms
- Store_sales scan: 295.4ms (50% exclusive) - 5.4M/345.6M rows
- Hash join item: 123.0ms (21% exclusive) - reduces 5.4M to 593K rows
- Hash group by: 76.0ms (13% exclusive) - reduces 593K to 4,414 rows
- Window: 25.0ms (4% exclusive) - 4,414 rows
- Other operations are minor (<3% each)

Row count flow:
1. store_sales scan: 5.4M rows (from 345.6M)
2. date_dim join: stays at 5.4M (date filter reduces date_dim to 365 rows)
3. item join: reduces to 593K rows (item filter reduces item to 11K rows)
4. store join: stays at 593K rows (store filter reduces store to 100 rows)
5. Group by: reduces to 4,414 rows
6. Window: 4,414 rows
7. Filter: reduces to ~4,104 rows

Key observations:
- The store_sales scan is the largest cost (295ms). All other operations work on reduced data.
- The optimizer already pushes date filter (d_year=1999) into the date_dim scan.
- The item filter ((i_category IN ... AND i_class IN ...) OR (i_category IN ... AND i_class IN ...)) is applied after the join but reduces rows significantly (5.4M → 593K).
- The query scans each base table once. No redundant scans.
- The window function (AVG over partition) is computed after aggregation.
- The final filter on relative deviation eliminates only ~310 rows (4,414 → 4,104).

GAP MATCHING:
1. CROSS_COLUMN_OR_DECOMPOSITION: The item filter has OR conditions on different columns? Actually, it's OR between two AND conditions, both on i_category and i_class. The OR connects two composite conditions. This is same-table, same-column family OR. The engine handles same-column OR well. Splitting this could duplicate the fact table scan (2 branches). Historical regression shows 0.59x for same-column time range split.
2. CROSS_CTE_PREDICATE_BLINDNESS: The item filter is applied AFTER the join with store_sales. Could pre-filter item into CTE before joining. This matches dimension_cte_isolate, prefetch_fact_join, early_filter. The date filter is already pushed. Store filter is trivial.
3. REDUNDANT_SCAN_ELIMINATION: Only one scan per table. No opportunity.
4. UNION_CTE_SELF_JOIN_DECOMPOSITION: No UNION CTE or repeated scans with different filters.
5. WINDOW_OPTIMIZATION: Window computed after aggregation on 4,414 rows. Could potentially compute average via derived aggregation instead of window? But window is needed for per-partition average.

AGGREGATION TRAP CHECK:
- SUM(ss_sales_price) is grouping-insensitive to duplicates.
- AVG(SUM(...)) OVER (PARTITION BY ...) is computed per partition defined by (i_category, i_brand, s_store_name, s_company_name). Changing grouping would break.
- The CASE filter uses avg_monthly_sales in division. Must preserve NULL handling (avg_monthly_sales = 0 → NULL).

TRANSFORM SELECTION (ranked by expected value):
1. star_join_prefetch (dimension_cte_isolate + prefetch_fact_join): Pre-filter all dimensions into CTEs, then join with fact table. Reduces fact table join size. Historical: dimension_cte_isolate 1.93x, prefetch_fact_join 3.77x.
2. early_filter + pushdown: Filter dimensions first, push predicates early. Simpler version of above.
3. single_pass_aggregation with derived average: Compute average via subquery instead of window? Might allow better join ordering.
4. Exploration: or_to_union despite warning, because OR connects two disjoint category sets (Jewelry/Shoes/Electronics vs Men/Music/Women). Could split into two branches with separate fact joins, then UNION. Risk: duplicates fact scan.

LOGICAL TREE DESIGN:
For star_join_prefetch: Create CTEs for filtered date_dim, item, store. Join them with store_sales, then aggregate.
For early_filter: Use subqueries in FROM clause with filters applied first.
For single_pass_aggregation: Compute the average via a separate aggregate CTE and join back.
For or_to_union: Split item filter into two CTEs, join each with other tables, UNION ALL, then aggregate.

CTE materialization: Each CTE will be referenced once, so likely inlined. However, explicit CTEs force early filtering.
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
Identify 1999 monthly store-sales outliers where monthly sales deviate >10% from the average monthly sales for that (category, brand, store, company) across months. JOIN semantics: INNER joins require matching keys in all four tables; missing matches eliminate rows. Aggregation trap: AVG(SUM(...)) OVER partition must compute average of monthly sums per partition; changing grouping changes denominator. Filter dependency: The CASE filter depends on avg_monthly_sales; NULL when avg_monthly_sales = 0 must be preserved.

BOTTLENECK_DIAGNOSIS:
Scan-bound: store_sales scan dominates (295ms, 50%). Row reduction occurs primarily at item join (5.4M → 593K). The optimizer already pushes date filter into date_dim scan. Logical-tree percentages misleading: item join shows 21% cost but reduces rows 10x; store_sales scan is the true bottleneck. Cardinality flow: 5.4M fact rows → 593K after item filter → 4,414 after aggregation.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output all original columns (i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales)
- CTE_COLUMN_COMPLETENESS: Any CTE must include all columns referenced downstream (join keys, grouping columns, aggregates)
- LITERAL_PRESERVATION: Must preserve literal values: d_year=1999, category/class strings exactly
- SEMANTIC_EQUIVALENCE: Must return same rows and ordering (ORDER BY sum_sales - avg_monthly_sales, s_store_name LIMIT 100)
- CROSS_CTE_PREDICATE_BLINDNESS: Item filter applied after join; pre-filtering item into CTE could push predicate earlier
- SCAN_CONSOLIDATION_PIVOT: Only one scan per table; no consolidation opportunity

REGRESSION_WARNINGS:
1. or_to_union (0.59x on Q90):
   CAUSE: Split same-column time range OR duplicated fact table scans
   RULE: Do not split OR on same column family (i_category/i_class) unless categories are disjoint and branches have independent selectivity
2. dimension_cte_isolate (0.85x on Q67):
   CAUSE: Unfiltered dimension CTEs added materialization overhead
   RULE: Every dimension CTE must have a WHERE clause that reduces rows
3. date_cte_isolate (0.5x on Q25):
   CAUSE: Baseline <100ms, CTE overhead dominated
   RULE: This query baseline 592ms, CTE overhead acceptable

=== WORKER 1 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  filtered_date -> filtered_item -> filtered_store -> prefetched_fact -> aggregated -> windowed -> filtered -> ordered -> limited
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_year = 1999
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 365
    CONSUMERS: prefetched_fact
  filtered_item:
    FROM: item
    WHERE: ((i_category IN ('Jewelry','Shoes','Electronics') AND i_class IN ('semi-precious','athletic','portable')) OR (i_category IN ('Men','Music','Women') AND i_class IN ('accessories','rock','maternity')))
    OUTPUT: i_item_sk, i_category, i_class, i_brand
    EXPECTED_ROWS: 11K
    CONSUMERS: prefetched_fact
  filtered_store:
    FROM: store
    WHERE: s_store_sk <= 100
    OUTPUT: s_store_sk, s_store_name, s_company_name
    EXPECTED_ROWS: 100
    CONSUMERS: prefetched_fact
  prefetched_fact:
    FROM: store_sales
    JOIN: INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk
          INNER JOIN filtered_item ON ss_item_sk = i_item_sk  
          INNER JOIN filtered_store ON ss_store_sk = s_store_sk
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, ss_sales_price
    EXPECTED_ROWS: 593K
    CONSUMERS: aggregated
  aggregated:
    FROM: prefetched_fact
    GROUP BY: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy
    AGGREGATE: SUM(ss_sales_price) AS sum_sales
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales
    EXPECTED_ROWS: 4,414
    CONSUMERS: windowed
  windowed:
    FROM: aggregated
    WINDOW: AVG(sum_sales) OVER (PARTITION BY i_category, i_brand, s_store_name, s_company_name) AS avg_monthly_sales
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 4,414
    CONSUMERS: filtered
  filtered:
    FROM: windowed
    WHERE: CASE WHEN avg_monthly_sales <> 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 4,104
    CONSUMERS: ordered
  ordered:
    FROM: filtered
    ORDER BY: (sum_sales - avg_monthly_sales) ASC, s_store_name ASC
    LIMIT: 100
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 100
    CONSUMERS: final output
EXAMPLES: dimension_cte_isolate, prefetch_fact_join, multi_dimension_prefetch
EXAMPLE_ADAPTATION:
- dimension_cte_isolate: Apply pre-filtering of all three dimensions into CTEs; ignore the cross-join warning (we join them with fact table, not cross-join)
- prefetch_fact_join: Apply staged join pipeline: filter dimensions first, then join with fact table; ignore the limitation on cascading fact-table CTE chains (we have only one fact table)
- multi_dimension_prefetch: Apply pre-filtering of multiple dimensions (date, item, store) before fact join; ignore the date-only focus
HAZARD_FLAGS:
- CTE materialization overhead may offset benefits if filters are not selective enough
- Must ensure all join keys are included in CTE outputs

=== WORKER 2 BRIEFING ===

STRATEGY: early_filter
TARGET_LOGICAL_TREE:
  filtered_tables_join -> aggregated -> windowed -> filtered -> ordered -> limited
NODE_CONTRACTS:
  filtered_tables_join:
    FROM: (SELECT i_item_sk, i_category, i_class, i_brand FROM item WHERE ((i_category IN ('Jewelry','Shoes','Electronics') AND i_class IN ('semi-precious','athletic','portable')) OR (i_category IN ('Men','Music','Women') AND i_class IN ('accessories','rock','maternity')))) AS item
          INNER JOIN store_sales ON ss_item_sk = i_item_sk
          INNER JOIN (SELECT d_date_sk FROM date_dim WHERE d_year = 1999) AS date ON ss_sold_date_sk = d_date_sk
          INNER JOIN (SELECT s_store_sk, s_store_name, s_company_name FROM store WHERE s_store_sk <= 100) AS store ON ss_store_sk = s_store_sk
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, ss_sales_price
    EXPECTED_ROWS: 593K
    CONSUMERS: aggregated
  aggregated:
    FROM: filtered_tables_join
    GROUP BY: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy
    AGGREGATE: SUM(ss_sales_price) AS sum_sales
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales
    EXPECTED_ROWS: 4,414
    CONSUMERS: windowed
  windowed:
    FROM: aggregated
    WINDOW: AVG(sum_sales) OVER (PARTITION BY i_category, i_brand, s_store_name, s_company_name) AS avg_monthly_sales
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 4,414
    CONSUMERS: filtered
  filtered:
    FROM: windowed
    WHERE: CASE WHEN avg_monthly_sales <> 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 4,104
    CONSUMERS: ordered
  ordered:
    FROM: filtered
    ORDER BY: (sum_sales - avg_monthly_sales) ASC, s_store_name ASC
    LIMIT: 100
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 100
    CONSUMERS: final output
EXAMPLES: early_filter, pushdown, date_cte_isolate
EXAMPLE_ADAPTATION:
- early_filter: Apply dimension filtering in subqueries before joins; ignore the reason table example (we have item/date/store filters)
- pushdown: Push filters from outer query into subqueries; ignore the consolidation of multiple subqueries (we have single scans)
- date_cte_isolate: Apply date filtering into subquery; ignore the CTE materialization (use subquery instead)
HAZARD_FLAGS:
- Subqueries may be inlined by optimizer, losing forced filter order
- Must preserve all original filters exactly

=== WORKER 3 BRIEFING ===

STRATEGY: single_pass_aggregation_with_derived_avg
TARGET_LOGICAL_TREE:
  filtered_join -> aggregated_with_avg -> filtered -> ordered -> limited
NODE_CONTRACTS:
  filtered_join:
    FROM: item INNER JOIN store_sales ON ss_item_sk = i_item_sk
          INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk
          INNER JOIN store ON ss_store_sk = s_store_sk
    WHERE: d_year = 1999 
           AND s_store_sk <= 100
           AND ((i_category IN ('Jewelry','Shoes','Electronics') AND i_class IN ('semi-precious','athletic','portable')) OR (i_category IN ('Men','Music','Women') AND i_class IN ('accessories','rock','maternity')))
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, ss_sales_price
    EXPECTED_ROWS: 593K
    CONSUMERS: aggregated_with_avg
  aggregated_with_avg:
    FROM: filtered_join
    GROUP BY: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy
    AGGREGATE: SUM(ss_sales_price) AS sum_sales
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales
    EXPECTED_ROWS: 4,414
    CONSUMERS: self (for window computation via join)
  (Implicit window via join with aggregate of aggregates):
  Need to compute avg_monthly_sales as AVG(sum_sales) over partition. Can be done by joining aggregated_with_avg with a CTE that computes the average per partition.
  Let's define:
  partition_avg:
    FROM: aggregated_with_avg
    GROUP BY: i_category, i_brand, s_store_name, s_company_name
    AGGREGATE: AVG(sum_sales) AS avg_monthly_sales
    OUTPUT: i_category, i_brand, s_store_name, s_company_name, avg_monthly_sales
    CONSUMERS: joined_avg
  joined_avg:
    FROM: aggregated_with_avg INNER JOIN partition_avg USING (i_category, i_brand, s_store_name, s_company_name)
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 4,414
    CONSUMERS: filtered
  filtered:
    FROM: joined_avg
    WHERE: CASE WHEN avg_monthly_sales <> 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 4,104
    CONSUMERS: ordered
  ordered:
    FROM: filtered
    ORDER BY: (sum_sales - avg_monthly_sales) ASC, s_store_name ASC
    LIMIT: 100
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 100
    CONSUMERS: final output
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Compute multiple aggregates in one pass; adapt by computing sum_sales and partition average in separate aggregations then join; ignore the CASE WHEN labeling (not needed)
- channel_bitmap_aggregation: Consolidate computations; ignore the bucket labeling
HAZARD_FLAGS:
- Must ensure the partition average is mathematically equivalent to AVG OVER (PARTITION BY ...)
- Join between aggregated_with_avg and partition_avg must be on correct columns

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: or_to_union_disjoint_categories
TARGET_LOGICAL_TREE:
  item_branch1 -> join_branch1 -> 
  item_branch2 -> join_branch2 -> 
  union_all -> aggregated -> windowed -> filtered -> ordered -> limited
NODE_CONTRACTS:
  item_branch1:
    FROM: item
    WHERE: i_category IN ('Jewelry','Shoes','Electronics') AND i_class IN ('semi-precious','athletic','portable')
    OUTPUT: i_item_sk, i_category, i_class, i_brand
    EXPECTED_ROWS: ~5.5K (half of 11K)
    CONSUMERS: join_branch1
  item_branch2:
    FROM: item
    WHERE: i_category IN ('Men','Music','Women') AND i_class IN ('accessories','rock','maternity')
    OUTPUT: i_item_sk, i_category, i_class, i_brand
    EXPECTED_ROWS: ~5.5K
    CONSUMERS: join_branch2
  join_branch1:
    FROM: item_branch1
          INNER JOIN store_sales ON ss_item_sk = i_item_sk
          INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_year = 1999
          INNER JOIN store ON ss_store_sk = s_store_sk AND s_store_sk <= 100
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, ss_sales_price
    EXPECTED_ROWS: ~296.5K (half of 593K)
    CONSUMERS: union_all
  join_branch2:
    FROM: item_branch2
          INNER JOIN store_sales ON ss_item_sk = i_item_sk
          INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_year = 1999
          INNER JOIN store ON ss_store_sk = s_store_sk AND s_store_sk <= 100
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, ss_sales_price
    EXPECTED_ROWS: ~296.5K
    CONSUMERS: union_all
  union_all:
    FROM: join_branch1 UNION ALL join_branch2
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, ss_sales_price
    EXPECTED_ROWS: 593K
    CONSUMERS: aggregated
  aggregated:
    FROM: union_all
    GROUP BY: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy
    AGGREGATE: SUM(ss_sales_price) AS sum_sales
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales
    EXPECTED_ROWS: 4,414
    CONSUMERS: windowed
  windowed:
    FROM: aggregated
    WINDOW: AVG(sum_sales) OVER (PARTITION BY i_category, i_brand, s_store_name, s_company_name) AS avg_monthly_sales
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 4,414
    CONSUMERS: filtered
  filtered:
    FROM: windowed
    WHERE: CASE WHEN avg_monthly_sales <> 0 THEN ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales ELSE NULL END > 0.1
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 4,104
    CONSUMERS: ordered
  ordered:
    FROM: filtered
    ORDER BY: (sum_sales - avg_monthly_sales) ASC, s_store_name ASC
    LIMIT: 100
    OUTPUT: i_category, i_class, i_brand, s_store_name, s_company_name, d_moy, sum_sales, avg_monthly_sales
    EXPECTED_ROWS: 100
    CONSUMERS: final output
EXAMPLES: or_to_union, multi_dimension_prefetch
EXAMPLE_ADAPTATION:
- or_to_union: Split OR into UNION ALL branches; ignore the warning about same-column OR because categories are disjoint and filters are on different literal sets
- multi_dimension_prefetch: Apply dimension filtering in each branch; ignore the single dimension focus
HAZARD_FLAGS:
- Store_sales scanned twice (once per branch) - could double I/O cost
- Union may add overhead
- Must ensure categories are truly disjoint (they are)
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: The regression warning for or_to_union (0.59x on Q90) was for same-column time range split where both branches scanned the same fact table with overlapping ranges. Here, categories are disjoint, and each branch filters different item subsets, potentially allowing better join planning.
EXPLORATION_TYPE: compound_strategy (or_to_union + dimension filtering in each branch)