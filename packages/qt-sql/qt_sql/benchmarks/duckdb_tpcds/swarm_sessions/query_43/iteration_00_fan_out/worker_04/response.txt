### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Restructured to match Target Logical Tree with CTEs
    ├── [~] filtered_date (CTE)  [=]  — FROM date_dim WHERE d_year=2000
    │   └── SCAN date_dim
    │       └── FILTER (d_year = 2000)
    ├── [~] filtered_store (CTE)  [=]  — FROM store WHERE s_gmt_offset=-5
    │   └── SCAN store
    │       └── FILTER (s_gmt_offset = -5)
    ├── [~] dim_key_product (CTE)  [+]  — CROSS JOIN filtered_date × filtered_store
    │   ├── JOIN (CROSS)
    │   ├── CONSUME filtered_date
    │   └── CONSUME filtered_store
    ├── [~] fact_composite_join (CTE)  [+]  — INNER JOIN dim_key_product × store_sales ON composite key
    │   ├── JOIN (INNER) ON ss_sold_date_sk = d_date_sk AND ss_store_sk = s_store_sk
    │   ├── CONSUME dim_key_product
    │   └── SCAN store_sales
    ├── [~] attribute_join (CTE)  [+]  — Pass-through (no extra joins)
    │   └── CONSUME fact_composite_join
    ├── [~] main_aggregation (CTE)  [=]  — GROUP BY s_store_name, s_store_id with 7 CASE aggregates
    │   ├── AGG (GROUP BY)
    │   └── CONSUME attribute_join
    ├── [=] SORT (s_store_name ASC, s_store_id ASC, sun_sales ASC, mon_sales ASC, tue_sales ASC, wed_sales ASC, thu_sales ASC, fri_sales ASC, sat_sales ASC)
    └── [=] OUTPUT (s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "multi_dimension_prefetch",
      "description": "Created separate filtered CTEs for date_dim and store, then cross-joined before fact join",
      "applied_to": ["filtered_date", "filtered_store", "dim_key_product", "fact_composite_join"]
    },
    {
      "id": "R2",
      "type": "predicate_isolation",
      "description": "Keep d_year=2000 and s_gmt_offset=-5 filters in dimension CTEs, not pushed into fact table",
      "applied_to": ["filtered_date", "filtered_store"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_date": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT d_date_sk, d_day_name FROM date_dim WHERE d_year = 2000",
          "interfaces": {
            "outputs": ["d_date_sk", "d_day_name"],
            "consumes": []
          }
        },
        "filtered_store": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT s_store_sk, s_store_name, s_store_id FROM store WHERE s_gmt_offset = -5",
          "interfaces": {
            "outputs": ["s_store_sk", "s_store_name", "s_store_id"],
            "consumes": []
          }
        },
        "dim_key_product": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT fd.d_date_sk, fd.d_day_name, fs.s_store_sk, fs.s_store_name, fs.s_store_id FROM filtered_date fd CROSS JOIN filtered_store fs",
          "interfaces": {
            "outputs": ["d_date_sk", "d_day_name", "s_store_sk", "s_store_name", "s_store_id"],
            "consumes": ["filtered_date", "filtered_store"]
          }
        },
        "fact_composite_join": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT dkp.s_store_name, dkp.s_store_id, dkp.d_day_name, ss.ss_sales_price FROM dim_key_product dkp INNER JOIN store_sales ss ON ss.ss_sold_date_sk = dkp.d_date_sk AND ss.ss_store_sk = dkp.s_store_sk",
          "interfaces": {
            "outputs": ["s_store_name", "s_store_id", "d_day_name", "ss_sales_price"],
            "consumes": ["dim_key_product"]
          }
        },
        "attribute_join": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT s_store_name, s_store_id, d_day_name, ss_sales_price FROM fact_composite_join",
          "interfaces": {
            "outputs": ["s_store_name", "s_store_id", "d_day_name", "ss_sales_price"],
            "consumes": ["fact_composite_join"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT s_store_name, s_store_id, SUM(CASE WHEN d_day_name='Sunday' THEN ss_sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN d_day_name='Monday' THEN ss_sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN d_day_name='Tuesday' THEN ss_sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN d_day_name='Wednesday' THEN ss_sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN d_day_name='Thursday' THEN ss_sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN d_day_name='Friday' THEN ss_sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN d_day_name='Saturday' THEN ss_sales_price ELSE NULL END) AS sat_sales FROM attribute_aj GROUP BY s_store_name, s_store_id ORDER BY s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales LIMIT 100",
          "interfaces": {
            "outputs": ["s_store_name", "s_store_id", "sun_sales", "mon_sales", "tue_sales", "wed_sales", "thu_sales", "fri_sales", "sat_sales"],
            "consumes": ["attribute_join"]
          }
        }
      },
      "reconstruction_order": ["filtered_date", "filtered_store", "dim_key_product", "fact_composite_join", "attribute_join", "main_query"],
      "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_store AS ({filtered_store}), dim_key_product AS ({dim_key_product}), fact_composite_join AS ({fact_composite_join}), attribute_join AS ({attribute_aj}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured query into a CTE pipeline matching the target logical tree, isolating dimension filters in separate CTEs, then cross-joining dimensions before the fact table join. This preserves semantic equivalence while enabling DuckDB to apply dimension filters early and maintain predicate isolation.

**Expected speedup**: 1.2–1.5x (moderate) due to early reduction of dimension rows and columnar projection, though cross-join overhead may offset some gains.