## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Modified to use CTE structure
    ├── WITH date_cte  [+]  Cost: 0.1%  Rows: 365  — Filter date_dim for 2001
    ├── WITH addr_cte  [+]  Cost: 2.4%  Rows: ~242K  — Filter US addresses in 9 states
    ├── WITH cd_cte    [+]  Cost: 19%   Rows: ~1.9M  — Filter 3 demographic scenarios
    ├── WITH hd_cte    [+]  Cost: 0.07% Rows: ~7,200 — Filter dep_count in (1,3)
    ├── WITH store_cte [+]  Cost: 0.001% Rows: 102   — All store keys
    ├── WITH fact_prejoin [+] Cost: 60%  Rows: ~63K  — Join fact with all dimension CTEs
    ├── WITH filter_or [+]  Cost: 20%   Rows: ~63K  — Apply 3x3 combinatorial OR filters
    └── AGGREGATE       [=]  Cost: 0.2%  Rows: 1     — Compute final aggregates
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_prefilter", "description": "Isolate dimension filters into CTEs for early reduction", "applied_to": ["date_cte", "addr_cte", "cd_cte", "hd_cte", "store_cte"]},
    {"id": "R2", "type": "sequential_fact_join", "description": "Join fact table sequentially with pre-filtered dimension CTEs (prevents Cartesian explosion)", "applied_to": ["fact_prejoin"]},
    {"id": "R3", "type": "or_separation", "description": "Extract complex OR conditions into separate filter node after joins", "applied_to": ["filter_or"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "addr_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ca_address_sk, ca_state FROM customer_address WHERE ca_country = 'United States' AND ca_state IN ('SD', 'KS', 'MI', 'MO', 'ND', 'CO', 'NH', 'OH', 'TX')",
        "interfaces": {"outputs": ["ca_address_sk", "ca_state"], "consumes": []}
      },
      "cd_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT cd_demo_sk, cd_marital_status, cd_education_status FROM customer_demographics WHERE (cd_marital_status = 'D' AND cd_education_status = 'Unknown') OR (cd_marital_status = 'S' AND cd_education_status = 'College') OR (cd_marital_status = 'M' AND cd_education_status = '4 yr Degree')",
        "interfaces": {"outputs": ["cd_demo_sk", "cd_marital_status", "cd_education_status"], "consumes": []}
      },
      "hd_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT hd_demo_sk, hd_dep_count FROM household_demographics WHERE hd_dep_count IN (1, 3)",
        "interfaces": {"outputs": ["hd_demo_sk", "hd_dep_count"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk FROM store",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "fact_prejoin": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss.ss_quantity, ss.ss_ext_sales_price, ss.ss_ext_wholesale_cost, ss.ss_sales_price, ss.ss_net_profit, cd.cd_marital_status, cd.cd_education_status, hd.hd_dep_count, addr.ca_state FROM store_sales ss INNER JOIN date_cte d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN addr_cte addr ON ss.ss_addr_sk = addr.ca_address_sk INNER JOIN cd_cte cd ON ss.ss_cdemo_sk = cd.cd_demo_sk INNER JOIN hd_cte hd ON ss.ss_hdemo_sk = hd.hd_demo_sk INNER JOIN store_cte s ON ss.ss_store_sk = s.s_store_sk",
        "interfaces": {"outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost", "ss_sales_price", "ss_net_profit", "cd_marital_status", "cd_education_status", "hd_dep_count", "ca_state"], "consumes": ["date_cte", "addr_cte", "cd_cte", "hd_cte", "store_cte"]}
      },
      "filter_or": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM fact_prejoin WHERE ((cd_marital_status = 'D' AND cd_education_status = 'Unknown' AND ss_sales_price BETWEEN 100.00 AND 150.00 AND hd_dep_count = 3) OR (cd_marital_status = 'S' AND cd_education_status = 'College' AND ss_sales_price BETWEEN 50.00 AND 100.00 AND hd_dep_count = 1) OR (cd_marital_status = 'M' AND cd_education_status = '4 yr Degree' AND ss_sales_price BETWEEN 150.00 AND 200.00 AND hd_dep_count = 1)) AND ((ca_state IN ('SD', 'KS', 'MI') AND ss_net_profit BETWEEN 100 AND 200) OR (ca_state IN ('MO', 'ND', 'CO') AND ss_net_profit BETWEEN 150 AND 300) OR (ca_state IN ('NH', 'OH', 'TX') AND ss_net_profit BETWEEN 50 AND 250))",
        "interfaces": {"outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"], "consumes": ["fact_prejoin"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT AVG(ss_quantity) AS avg_ss_quantity, AVG(ss_ext_sales_price) AS avg_ss_ext_sales_price, AVG(ss_ext_wholesale_cost) AS avg_ss_ext_wholesale_cost, SUM(ss_ext_wholesale_cost) AS sum_ss_ext_wholesale_cost FROM filter_or",
        "interfaces": {"outputs": ["avg(ss_quantity)", "avg(ss_ext_sales_price)", "avg(ss_ext_wholesale_cost)", "sum(ss_ext_wholesale_cost)"], "consumes": ["filter_or"]}
      }
    },
    "reconstruction_order": ["date_cte", "addr_cte", "cd_cte", "hd_cte", "store_cte", "fact_prejoin", "filter_or", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), addr_cte AS ({addr_cte}), cd_cte AS ({cd_cte}), hd_cte AS ({hd_cte}), store_cte AS ({store_cte}), fact_prejoin AS ({fact_prejoin}), filter_or AS ({filter_or}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

## Changes and Expected Speedup

**Changes:** Isolated dimension filters into CTEs for early reduction, then sequentially joined them with the fact table to prevent Cartesian explosion, followed by applying the complex 3x3 combinatorial OR filter in a separate CTE.

**Expected speedup:** ~1.2-1.5x improvement due to reduced fact table I/O from early dimension filtering and predicate pushdown. The sequential join structure prevents the catastrophic cross-join seen in similar patterns while allowing DuckDB's columnar execution to benefit from pre-filtered dimension tables.