### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Filter store-sales rows by three OR-connected household/demographic/price scenarios and three OR-connected U.S. state/net-profit scenarios, then return overall aggregate statistics across all qualifying rows.
    ├── [~] branch1 (CTE) — First demographic/price scenario with address/profit filters
    │   ├── SCAN (store_sales, store (join), customer_demographics (join), household_demographics (join), customer_address (join), date_dim (join))
    │   ├── JOIN (s_store_sk = ss_store_sk)
    │   ├── JOIN (ss_sold_date_sk = d_date_sk)
    │   ├── JOIN (ss_hdemo_sk = hd_demo_sk)
    │   ├── JOIN (cd_demo_sk = ss_cdemo_sk)
    │   ├── JOIN (ss_addr_sk = ca_address_sk)
    │   └── FILTER (d_year=2001, ca_country='United States', cd_marital_status='D', cd_education_status='Unknown', ss_sales_price BETWEEN 100.00 AND 150.00, hd_dep_count=3, plus 3 address/profit ORs)
    ├── [~] branch2 (CTE) — Second demographic/price scenario with same address/profit filters
    │   └── (Same structure, different constants)
    ├── [~] branch3 (CTE) — Third demographic/price scenario with same address/profit filters
    │   └── (Same structure, different constants)
    ├── [!] union_all (CTE) — UNION ALL of three branches
    │   └── UNION ALL (branch1, branch2, branch3)
    └── [~] aggregate (main query) — Final aggregation
        └── AGGREGATE (avg(ss_quantity), avg(ss_ext_sales_price), avg(ss_ext_wholesale_cost), sum(ss_ext_wholesale_cost))
```

**Change markers:**
- `[~] main_query`: Changed from single-table join to CTE-based UNION ALL + aggregate
- `[~] branch1`, `branch2`, `branch3`: New CTEs isolating each demographic/price scenario
- `[!] union_all`: New CTE combining three branches via UNION ALL
- `[~] aggregate`: Modified to operate on union_all CTE instead of original join

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "or_to_union", "description": "Split cross-column OR conditions on demographics/price into three UNION ALL branches", "applied_to": ["branch1", "branch2", "branch3", "union_all"]},
    {"id": "R2", "type": "cte_optimization", "description": "Use CTEs to separate branches, allowing predicate pushdown within each branch", "applied_to": ["branch1", "branch2", "branch3", "union_all"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "branch1": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM store_sales INNER JOIN store ON s_store_sk = ss_store_sk INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk INNER JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk INNER JOIN customer_demographics ON cd_demo_sk = ss_cdemo_sk INNER JOIN customer_address ON ss_addr_sk = ca_address_sk WHERE d_year = 2001 AND ca_country = 'United States' AND cd_marital_status = 'D' AND cd_education_status = 'Unknown' AND ss_sales_price BETWEEN 100.00 AND 150.00 AND hd_dep_count = 3 AND ((ca_state IN ('SD', 'KS', 'MI') AND ss_net_profit BETWEEN 100 AND 200) OR (ca_state IN ('MO', 'ND', 'CO') AND ss_net_profit BETWEEN 150 AND 300) OR (ca_state IN ('NH', 'OH', 'TX') AND ss_net_profit BETWEEN 50 AND 250)))",
        "interfaces": {"outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"], "consumes": []}
      },
      "branch2": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM store_sales INNER JOIN store ON s_store_sk = ss_store_sk INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk INNER JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk INNER JOIN customer_demographics ON cd_demo_sk = ss_cdemo_sk INNER JOIN customer_address ON ss_addr_sk = ca_address_sk WHERE d_year = 2001 AND ca_country = 'United States' AND cd_marital_status = 'S' AND cd_education_status = 'College' AND ss_sales_price BETWEEN 50.00 AND 100.00 AND hd_dep_count = 1 AND ((ca_state IN ('SD', 'KS', 'MI') AND ss_net_profit BETWEEN 100 AND 200) OR (ca_state IN ('MO', 'ND', 'CO') AND ss_net_profit BETWEEN 150 AND 300) OR (ca_state IN ('NH', 'OH', 'TX') AND ss_net_profit BETWEEN 50 AND 250)))",
        "interfaces": {"outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"], "consumes": []}
      },
      "branch3": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM store_sales INNER JOIN store ON s_store_sk = ss_store_sk INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk INNER JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk INNER JOIN customer_demographics ON cd_demo_sk = ss_cdemo_sk INNER JOIN customer_address ON ss_addr_sk = ca_address_sk WHERE d_year = 2001 AND ca_country = 'United States' AND cd_marital_status = 'M' AND cd_education_status = '4 yr Degree' AND ss_sales_price BETWEEN 150.00 AND 200.00 AND hd_dep_count = 1 AND ((ca_state IN ('SD', 'KS', 'MI') AND ss_net_profit BETWEEN 100 AND 200) OR (ca_state IN ('MO', 'ND', 'CO') AND ss_net_profit BETWEEN 150 AND 300) OR (ca_state IN ('NH', 'OH', 'TX') AND ss_net_profit BETWEEN 50 AND 250)))",
        "interfaces": {"outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"], "consumes": []}
      },
      "union_all": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM branch1 UNION ALL SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM branch2 UNION ALL SELECT ss_quantity, ss_ext_sales_price, ss_ext_wholesale_cost FROM branch3",
        "interfaces": {"outputs": ["ss_quantity", "ss_ext_sales_price", "ss_ext_wholesale_cost"], "consumes": ["branch1", "branch2", "branch3"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT AVG(ss_quantity) AS avg_ss_quantity, AVG(ss_ext_sales_price) AS avg_ss_ext_sales_price, AVG(ss_ext_wholesale_cost) AS avg_ss_ext_wholesale_cost, SUM(ss_ext_wholesale_cost) AS sum_ss_ext_wholesale_cost FROM union_all",
        "interfaces": {"outputs": ["avg_ss_quantity", "avg_ss_ext_sales_price", "avg_ss_ext_wholesale_cost", "sum_ss_ext_wholesale_cost"], "consumes": ["union_all"]}
      }
    },
    "reconstruction_order": ["branch1", "branch2", "branch3", "union_all", "main_query"],
    "assembly_template": "WITH branch1 AS ({branch1}), branch2 AS ({branch2}), branch3 AS ({branch3}), union_all AS ({union_all}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Split the original query's cross-column OR conditions on demographics/price into three UNION ALL branches, each containing the full address/profit OR conditions. This allows DuckDB to push all predicates (demographics, price, address, profit) into each branch scan, reducing per-scan rows from ~5.3M to ~21K per branch.

**Expected speedup:** 2-3x due to predicate pushdown into each disjoint demographic/price branch, avoiding full-table scan with complex OR evaluation. Each branch reads ~0.4% of store_sales rows instead of ~40%.