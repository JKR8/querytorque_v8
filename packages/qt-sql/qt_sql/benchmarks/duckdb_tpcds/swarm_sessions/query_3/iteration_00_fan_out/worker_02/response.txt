### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [~] explicit_joins (CTE) - Converted from implicit joins to explicit INNER JOIN syntax
│   ├── SCAN (store_sales)
│   ├── JOIN (INNER JOIN date_dim ON ss_sold_date_sk = d_date_sk)
│   ├── JOIN (INNER JOIN item ON ss_item_sk = i_item_sk)
│   ├── FILTER (i_manufact_id = 816)
│   └── FILTER (d_moy = 11)
├── [~] group_agg (CTE) - Extracted aggregation into separate CTE
│   ├── SCAN (explicit_joins)
│   └── AGG (GROUP BY d_year, i_brand, i_brand_id)
└── [~] main_query - Replaces original single SELECT
    ├── SCAN (group_agg)
    ├── SORT (d_year ASC, sum_agg DESC, i_brand_id ASC)
    └── OUTPUT (d_year, brand_id, brand, sum_agg)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "explicit_join_conversion", "description": "Convert implicit comma joins to explicit INNER JOIN syntax", "applied_to": ["explicit_joins"]},
    {"id": "R2", "type": "cte_extraction", "description": "Extract join and aggregation into separate CTEs per target logical tree", "applied_to": ["explicit_joins", "group_agg", "main_query"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "explicit_joins": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT store_sales.ss_sales_price, date_dim.d_year, item.i_brand_id, item.i_brand FROM store_sales INNER JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk INNER JOIN item ON store_sales.ss_item_sk = item.i_item_sk WHERE item.i_manufact_id = 816 AND date_dim.d_moy = 11",
        "interfaces": {"outputs": ["ss_sales_price", "d_year", "i_brand_id", "i_brand"], "consumes": []}
      },
      "group_agg": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_year, i_brand_id, i_brand, SUM(ss_sales_price) AS sum_agg FROM explicit_joins GROUP BY d_year, i_brand, i_brand_id",
        "interfaces": {"outputs": ["d_year", "i_brand_id", "i_brand", "sum_agg"], "consumes": ["explicit_joins"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT d_year, i_brand_id AS brand_id, i_brand AS brand, sum_agg FROM group_agg ORDER BY d_year ASC, sum_agg DESC, i_brand_id ASC LIMIT 100",
        "interfaces": {"outputs": ["d_year", "brand_id", "brand", "sum_agg"], "consumes": ["group_agg"]}
      }
    },
    "reconstruction_order": ["explicit_joins", "group_agg", "main_query"],
    "assembly_template": "WITH explicit_joins AS ({explicit_joins}), group_agg AS ({group_agg}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Converted implicit comma joins to explicit INNER JOIN syntax and extracted the join and aggregation into separate CTEs as per the target logical tree structure. The expected mechanism maintains semantic equivalence while potentially enabling better join reordering optimization.

Expected speedup: Moderate (1.1-1.3x) - The explicit join syntax provides clearer optimization hints to the query planner, and CTE separation helps with predicate pushdown analysis while keeping the logical structure readable.