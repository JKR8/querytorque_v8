### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [=]  Cost: 100%  Rows: 100
    ├── [~] ca_cte  — Changed to CTE with early filter on city
    ├── [~] ib_cte  — Changed to CTE with early filter on income bounds  
    ├── [~] hd_cte  — Changed to CTE (unfiltered)
    ├── [~] c_cte   — Changed to CTE (unfiltered)
    ├── [~] cd_cte  — Changed to CTE (unfiltered)
    ├── [~] combined — Changed to CTE joining all 5 dimension CTEs
    ├── [~] sr_join — Changed to CTE joining combined with store_returns
    ├── [~] top_n   — Changed to main query with ORDER BY and LIMIT
    └── OUTPUT (customer_id, customername)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "dimension_cte_isolate",
      "description": "Pre-filter selective dimensions (customer_address, income_band) into separate CTEs before joining with large tables",
      "applied_to": ["ca_cte", "ib_cte"]
    },
    {
      "id": "R2", 
      "type": "multi_dimension_prefetch",
      "description": "Extract all dimension tables into CTEs (even unfiltered ones) to create small hash tables for efficient probing",
      "applied_to": ["hd_cte", "c_cte", "cd_cte"]
    },
    {
      "id": "R3",
      "type": "sequential_dimension_join",
      "description": "Join dimension CTEs sequentially via foreign keys before joining with fact table, avoiding cross-join of 3+ dimension CTEs",
      "applied_to": ["combined", "sr_join"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "ca_cte": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_city = 'Oakwood'",
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "ib_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ib_income_band_sk FROM income_band WHERE ib_lower_bound >= 5806 AND ib_upper_bound <= 55806",
        "interfaces": {"outputs": ["ib_income_band_sk"], "consumes": []}
      },
      "hd_cte": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT hd_demo_sk, hd_income_band_sk FROM household_demographics",
        "interfaces": {"outputs": ["hd_demo_sk", "hd_income_band_sk"], "consumes": []}
      },
      "c_cte": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT c_customer_id, c_first_name, c_last_name, c_current_addr_sk, c_current_hdemo_sk, c_current_cdemo_sk FROM customer",
        "interfaces": {"outputs": ["c_customer_id", "c_first_name", "c_last_name", "c_current_addr_sk", "c_current_hdemo_sk", "c_current_cdemo_sk"], "consumes": []}
      },
      "cd_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cd_demo_sk FROM customer_demographics", 
        "interfaces": {"outputs": ["cd_demo_sk"], "consumes": []}
      },
      "combined": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c.c_customer_id, c.c_first_name, c.c_last_name, cd.cd_demo_sk FROM ca_cte ca, ib_cte ib, hd_cte hd, c_cte c, cd_cte cd WHERE c.c_current_addr_sk = ca.ca_address_sk AND hd.hd_income_band_sk = ib.ib_income_band_sk AND c.c_current_hdemo_sk = hd.hd_demo_sk AND cd.cd_demo_sk = c.c_current_cdemo_sk",
        "interfaces": {"outputs": ["c_customer_id", "c_first_name", "c_last_name", "cd_demo_sk"], "consumes": ["ca_cte", "ib_cte", "hd_cte", "c_cte", "cd_cte"]}
      },
      "sr_join": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT c.c_customer_id, COALESCE(c.c_last_name,'') || ', ' || COALESCE(c.c_first_name,'') AS customername FROM combined c INNER JOIN store_returns sr ON sr.sr_cdemo_sk = c.cd_demo_sk",
        "interfaces": {"outputs": ["c_customer_id", "customername"], "consumes": ["combined"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_customer_id AS customer_id, customername FROM sr_join ORDER BY c_customer_id ASC LIMIT 100",
        "interfaces": {"outputs": ["customer_id", "customername"], "consumes": ["sr_join"]}
      }
    },
    "reconstruction_order": ["ca_cte", "ib_cte", "hd_cte", "c_cte", "cd_cte", "combined", "sr_join", "main_query"],
    "assembly_template": "WITH ca_cte AS ({ca_cte}), ib_cte AS ({ib_cte}), hd_cte AS ({hd_cte}), c_cte AS ({c_cte}), cd_cte AS ({cd_cte}), combined AS ({combined}), sr_join AS ({sr_join}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Isolated all dimension tables into CTEs with early filtering where applicable, then joined them sequentially via foreign keys before the final join with store_returns. This creates small hash tables from selective dimension filters (customer_address, income_band) that can be probed efficiently when joining with large tables (customer, household_demographics, customer_demographics).

**Expected speedup:** 1.5-2.0x by reducing the probe cost for large dimension tables through pre-materialized hash tables and avoiding cross-join explosion by joining dimensions sequentially.