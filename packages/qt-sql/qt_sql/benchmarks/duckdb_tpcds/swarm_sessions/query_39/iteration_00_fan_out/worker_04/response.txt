## Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] all_monthly_stats  [+]  — Compute mean, stdev, and cov for Jan & Feb 1998 for warehouse-item pairs
│   ├── SCAN (inventory, item, warehouse, date_dim)
│   ├── FILTER (d_year=1998 AND d_moy IN (1,2))
│   ├── AGG (GROUP BY w_warehouse_sk, i_item_sk, d_moy)
│   └── OUTPUT (w_warehouse_sk, i_item_sk, d_moy, stdev, mean, cov)
├── [CTE] pivoted_stats  [+]  — Window self-join to pair Jan/Feb stats, filter for high variability
│   ├── SCAN (all_monthly_stats)
│   ├── WINDOW (LAG for prev month stats)
│   ├── FILTER (d_moy=2 AND prev_d_moy=1 AND cov>1 AND prev_cov>1)
│   └── OUTPUT (w_warehouse_sk, i_item_sk, d_moy1, mean1, cov1, d_moy2, mean2, cov2)
└── [MAIN] main_output  [~]  — Final ordering and column projection
    ├── SCAN (pivoted_stats)
    ├── SORT (w_warehouse_sk, i_item_sk, d_moy1, mean1, cov1, d_moy2, mean2, cov2)
    └── OUTPUT (w_warehouse_sk, i_item_sk, d_moy1, mean1, cov1, w_warehouse_sk, i_item_sk, d_moy2, mean2, cov2)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "SELF_JOIN_TO_WINDOW", "description": "Replaced month self-join with LAG window function to eliminate join and enable predicate pushdown", "applied_to": ["pivoted_stats"]},
    {"id": "R2", "type": "EARLY_MONTH_FILTER", "description": "Pushed month filter (d_moy IN (1,2)) into initial aggregation CTE to reduce scan volume", "applied_to": ["all_monthly_stats"]},
    {"id": "R3", "type": "DEFERRED_WINDOW_FILTER", "description": "Applied cov>1 filter after window computation using QUALIFY to maintain semantic equivalence with original", "applied_to": ["pivoted_stats"]}
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "all_monthly_stats": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand) / avg(inv_quantity_on_hand) END AS cov FROM inventory, item, warehouse, date_dim WHERE inv_item_sk = i_item_sk AND inv_warehouse_sk = w_warehouse_sk AND inv_date_sk = d_date_sk AND d_year = 1998 AND d_moy IN (1, 2) GROUP BY w_warehouse_sk, i_item_sk, d_moy",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "stdev", "mean", "cov"],
            "consumes": []
          }
        },
        "pivoted_stats": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, prev_d_moy AS d_moy1, prev_mean AS mean1, prev_cov AS cov1, d_moy AS d_moy2, mean AS mean2, cov AS cov2 FROM (SELECT w_warehouse_sk, i_item_sk, d_moy, mean, cov, LAG(mean) OVER (PARTITION BY w_warehouse_sk, i_item_sk ORDER BY d_moy) AS prev_mean, LAG(cov) OVER (PARTITION BY w_warehouse_sk, i_item_sk ORDER BY d_moy) AS prev_cov, LAG(d_moy) OVER (PARTITION BY w_warehouse_sk, i_item_sk ORDER BY d_moy) AS prev_d_moy FROM all_monthly_stats) QUALIFY d_moy = 2 AND prev_d_moy = 1 AND cov > 1 AND prev_cov > 1",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy1", "mean1", "cov1", "d_moy2", "mean2", "cov2"],
            "consumes": ["all_monthly_stats"]
          }
        },
        "pivoted_stats_v2": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, prev_d_moy AS d_moy1, prev_mean AS mean1, prev_cov AS cov1, d_moy AS d_moy2, mean AS mean2, cov AS cov2 FROM (SELECT w_warehouse_sk, i_item_sk, d_moy, mean, cov, LAG(mean) OVER (PARTITION BY w_warehouse_sk, i_item_sk ORDER BY d_moy) AS prev_mean, LAG(cov) OVER (PARTITION BY w_warehouse_sk, i_item_sk ORDER BY d_moy) AS prev_cov, LAG(d_moy) OVER (PARTITION BY w_warehouse_sk, i_item_sk ORDER BY d_moy) AS prev_d_moy FROM all_monthly_stats) QUALIFY d_moy = 2 AND prev_d_moy = 1 AND cov > 1 AND prev_cov > 1.5",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy1", "mean1", "cov1", "d_moy2", "mean2", "cov2"],
            "consumes": ["all_monthly_stats"]
          }
        },
        "main_output": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, d_moy1, mean1, cov1, w_warehouse_sk, i_item_sk, d_moy2, mean2, cov2 FROM pivoted_stats ORDER BY w_warehouse_sk, i_item_sk, d_moy1, mean1, cov1, d_moy2, mean2, cov2",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy1", "mean1", "cov1", "w_warehouse_sk", "i_item_sk", "d_moy2", "mean2", "cov2"],
            "consumes": ["pivoted_stats"]
          }
        },
        "main_output_v2": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, d_moy1, mean1, cov1, w_warehouse_sk, i_item_sk, d_moy2, mean2, cov2 FROM pivoted_stats_v2 ORDER BY w_warehouse_sk, i_item_sk, d_moy1, mean1, cov1, d_moy2, mean2, cov2",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy1", "mean1", "cov1", "w_warehouse_sk", "i_item_sk", "d_moy2", "mean2", "cov2"],
            "consumes": ["pivoted_stats_v2"]
          }
        }
      },
      "reconstruction_order": ["all_monthly_stats", "pivoted_stats", "main_output", "pivoted_stats_v2", "main_output_v2"],
      "assembly_template": "WITH all_monthly_stats AS ({all_monthly_stats}), pivoted_stats AS ({pivoted_stats}) {main_output}; WITH all_monthly_stats AS ({all_monthly_stats}), pivoted_stats_v2 AS ({pivoted_stats_v2}) {main_output_v2}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

## Mechanism Explanation

**Changes:** Replaced the self-join between January and February inventory stats with a LAG window function, enabling predicate pushdown of month filters to the initial scan and eliminating the join overhead. The cov>1 filter is applied after window computation via QUALIFY to preserve the original semantics where both months must have high variability.

**Expected speedup:** ~1.5–2× due to elimination of self-join, reduced intermediate data volume from early month filtering, and vectorized window processing in DuckDB.