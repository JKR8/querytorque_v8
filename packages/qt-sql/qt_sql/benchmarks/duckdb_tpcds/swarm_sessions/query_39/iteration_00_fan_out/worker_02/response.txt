### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] month1_stats  [+]  Cost: 25%  Rows: ~1K — Compute Jan 1998 stats with cov>1
│   ├── SCAN (inventory, item, warehouse, date_dim)
│   ├── FILTER (d_year=1998 AND d_moy=1)
│   ├── AGG (GROUP BY w_warehouse_sk, i_item_sk)
│   ├── HAVING (CASE WHEN mean=0 THEN 0 ELSE stdev/mean END > 1)
│   └── OUTPUT (w_warehouse_sk, i_item_sk, 1 as d_moy, stdev, mean, cov)
├── [CTE] month2_stats  [+]  Cost: 25%  Rows: ~1K — Compute Feb 1998 stats with cov>1
│   ├── SCAN (inventory, item, warehouse, date_dim)
│   ├── FILTER (d_year=1998 AND d_moy=2)
│   ├── AGG (GROUP BY w_warehouse_sk, i_item_sk)
│   ├── HAVING (CASE WHEN mean=0 THEN 0 ELSE stdev/mean END > 1)
│   └── OUTPUT (w_warehouse_sk, i_item_sk, 2 as d_moy, stdev, mean, cov)
└── [MAIN] main_query  [~]  Cost: 50%  Rows: ~1K — Join Jan & Feb stats
    ├── SCAN (month1_stats, month2_stats)
    ├── JOIN (INNER on warehouse & item keys)
    ├── FILTER (month1_stats.cov > 1.5)  — Only for second query
    ├── SORT (by warehouse, item, month1 stats, month2 stats)
    └── OUTPUT (10 columns as specified)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_specialization",
      "description": "Split generic all-months CTE into month-specialized CTEs with embedded month filters",
      "applied_to": ["month1_stats", "month2_stats"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "month1_stats": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, 1 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 1 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "stdev", "mean", "cov"],
            "consumes": []
          }
        },
        "month2_stats": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, 2 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 2 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "stdev", "mean", "cov"],
            "consumes": []
          }
        },
        "main_query1": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.w_warehouse_sk, month2_stats.i_item_sk, month2_stats.d_moy, month2_stats.mean, month2_stats.cov FROM month1_stats JOIN month2_stats ON month1_stats.w_warehouse_sk = month2_stats.w_warehouse_sk AND month1_stats.i_item_sk = month2_stats.i_item_sk ORDER BY month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.d_moy, month2_stats.mean, month2_stats.cov",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov", "w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov"],
            "consumes": ["month1_stats", "month2_stats"]
          }
        },
        "main_query2": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.w_warehouse_sk, month2_stats.i_item_sk, month2_stats.d_moy, month2_stats.mean, month2_stats.cov FROM month1_stats JOIN month2_stats ON month1_stats.w_warehouse_sk = month2_stats.w_warehouse_sk AND month1_stats.i_item_sk = month2_stats.i_item_sk WHERE month1_stats.cov > 1.5 ORDER BY month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.d_moy, month2_stats.mean, month2_stats.cov",
          "interfaces": {
            "outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov", "w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov"],
            "consumes": ["month1_stats", "month2_stats"]
          }
        }
      },
      "reconstruction_order": ["month1_stats", "month2_stats", "main_query1", "main_query2"],
      "assembly_template": "WITH month1_stats AS ({month1_stats}), month2_stats AS ({month2_stats}) {main_query1}; WITH month1_stats AS ({month1_stats}), month2_stats AS ({month2_stats}) {main_query2}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Split the original all-months CTE into two specialized CTEs (January and February 1998) with embedded month filters and cov>1 conditions, eliminating the redundant full-year scan. Each month CTE now scans only its relevant month, while preserving all defensive guards and semantic invariants.

**Expected speedup**: ~1.3-1.4x due to reduced data scan volume (2 months vs full year) and early application of cov>1 filter.