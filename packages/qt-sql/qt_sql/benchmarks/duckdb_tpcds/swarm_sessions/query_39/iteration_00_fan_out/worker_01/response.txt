## Part 1: Modified Logic Tree

```
QUERY: (two independent statements)
├── [STATEMENT 1]
│   ├── [CTE] filtered_dates [=]
│   ├── [CTE] inventory_join [=]
│   ├── [CTE] monthly_stats [=]
│   └── [~] main_output → renamed to main_output1, filter adjusted for Q1
│       ├── FROM: monthly_stats
│       ├── WHERE: CASE WHEN mean1=0 THEN 0 ELSE stdev1/mean1 END > 1 AND CASE WHEN mean2=0 THEN 0 ELSE stdev2/mean2 END > 1
│       └── OUTPUT: Same 10 columns as original Q1
└── [STATEMENT 2]
    ├── [CTE] filtered_dates [=]
    ├── [CTE] inventory_join [=]
    ├── [CTE] monthly_stats [=]
    └── [~] main_output → renamed to main_output2, filter adjusted for Q2
        ├── FROM: monthly_stats
        ├── WHERE: CASE WHEN mean1=0 THEN 0 ELSE stdev1/mean1 END > 1.5 AND CASE WHEN mean2=0 THEN 0 ELSE stdev2/mean2 END > 1
        └── OUTPUT: Same 10 columns as original Q2
```

**Changes:** 
- Maintained exact node structure from Target Logical Tree
- Applied single-pass aggregation via monthly_stats CTE with CASE expressions
- Created two separate final statements matching original two queries
- Preserved all defensive guards (CASE WHEN mean=0 THEN...)

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "single_pass_aggregation", "description": "Consolidated separate monthly calculations into single GROUP BY with CASE expressions", "applied_to": ["monthly_stats"]}
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_dates": {
          "type": "cte",
          "change": "unchanged",
          "sql": "",
          "interfaces": {"outputs": ["d_date_sk", "d_moy"], "consumes": []}
        },
        "inventory_join": {
          "type": "cte",
          "change": "unchanged",
          "sql": "",
          "interfaces": {"outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "inv_quantity_on_hand"], "consumes": ["filtered_dates"]}
        },
        "monthly_stats": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, stddev_samp(CASE WHEN d_moy = 1 THEN inv_quantity_on_hand END) as stdev1, avg(CASE WHEN d_moy = 1 THEN inv_quantity_on_hand END) as mean1, stddev_samp(CASE WHEN d_moy = 2 THEN inv_quantity_on_hand END) as stdev2, avg(CASE WHEN d_moy = 2 THEN inv_quantity_on_hand END) as mean2 FROM inventory_join GROUP BY w_warehouse_sk, i_item_sk",
          "interfaces": {"outputs": ["w_warehouse_sk", "i_item_sk", "stdev1", "mean1", "stdev2", "mean2"], "consumes": ["inventory_join"]}
        },
        "main_output1": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, 1 as d_moy, mean1 as mean, CASE WHEN mean1 = 0 THEN NULL ELSE stdev1/mean1 END as cov, w_warehouse_sk, i_item_sk, 2 as d_moy, mean2 as mean, CASE WHEN mean2 = 0 THEN NULL ELSE stdev2/mean2 END as cov FROM monthly_stats WHERE CASE WHEN mean1 = 0 THEN 0 ELSE stdev1/mean1 END > 1 AND CASE WHEN mean2 = 0 THEN 0 ELSE stdev2/mean2 END > 1 ORDER BY w_warehouse_sk, i_item_sk, 1, mean1, CASE WHEN mean1 = 0 THEN NULL ELSE stdev1/mean1 END, 2, mean2, CASE WHEN mean2 = 0 THEN NULL ELSE stdev2/mean2 END",
          "interfaces": {"outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov", "w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov"], "consumes": ["monthly_stats"]}
        }
      },
      "reconstruction_order": ["filtered_dates", "inventory_join", "monthly_stats", "main_output1"],
      "assembly_template": "WITH filtered_dates AS (SELECT d_date_sk, d_moy FROM date_dim WHERE d_year = 1998 AND d_moy IN (1, 2)), inventory_join AS (SELECT w.w_warehouse_sk, i.i_item_sk, fd.d_moy, inv.inv_quantity_on_hand FROM inventory inv INNER JOIN filtered_dates fd ON inv.inv_date_sk = fd.d_date_sk INNER JOIN item i ON inv.inv_item_sk = i.i_item_sk INNER JOIN warehouse w ON inv.inv_warehouse_sk = w.w_warehouse_sk), monthly_stats AS ({monthly_stats}) {main_output1}"
    },
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "filtered_dates": {
          "type": "cte",
          "change": "unchanged",
          "sql": "",
          "interfaces": {"outputs": ["d_date_sk", "d_moy"], "consumes": []}
        },
        "inventory_join": {
          "type": "cte",
          "change": "unchanged",
          "sql": "",
          "interfaces": {"outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "inv_quantity_on_hand"], "consumes": ["filtered_dates"]}
        },
        "monthly_stats": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, stddev_samp(CASE WHEN d_moy = 1 THEN inv_quantity_on_hand END) as stdev1, avg(CASE WHEN d_moy = 1 THEN inv_quantity_on_hand END) as mean1, stddev_samp(CASE WHEN d_moy = 2 THEN inv_quantity_on_hand END) as stdev2, avg(CASE WHEN d_moy = 2 THEN inv_quantity_on_hand END) as mean2 FROM inventory_join GROUP BY w_warehouse_sk, i_item_sk",
          "interfaces": {"outputs": ["w_warehouse_sk", "i_item_sk", "stdev1", "mean1", "stdev2", "mean2"], "consumes": ["inventory_join"]}
        },
        "main_output2": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT w_warehouse_sk, i_item_sk, 1 as d_moy, mean1 as mean, CASE WHEN mean1 = 0 THEN NULL ELSE stdev1/mean1 END as cov, w_warehouse_sk, i_item_sk, 2 as d_moy, mean2 as mean, CASE WHEN mean2 = 0 THEN NULL ELSE stdev2/mean2 END as cov FROM monthly_stats WHERE CASE WHEN mean1 = 0 THEN 0 ELSE stdev1/mean1 END > 1.5 AND CASE WHEN mean2 = 0 THEN 0 ELSE stdev2/mean2 END > 1 ORDER BY w_warehouse_sk, i_item_sk, 1, mean1, CASE WHEN mean1 = 0 THEN NULL ELSE stdev1/mean1 END, 2, mean2, CASE WHEN mean2 = 0 THEN NULL ELSE stdev2/mean2 END",
          "interfaces": {"outputs": ["w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov", "w_warehouse_sk", "i_item_sk", "d_moy", "mean", "cov"], "consumes": ["monthly_stats"]}
        }
      },
      "reconstruction_order": ["filtered_dates", "inventory_join", "monthly_stats", "main_output2"],
      "assembly_template": "WITH filtered_dates AS (SELECT d_date_sk, d_moy FROM date_dim WHERE d_year = 1998 AND d_moy IN (1, 2)), inventory_join AS (SELECT w.w_warehouse_sk, i.i_item_sk, fd.d_moy, inv.inv_quantity_on_hand FROM inventory inv INNER JOIN filtered_dates fd ON inv.inv_date_sk = fd.d_date_sk INNER JOIN item i ON inv.inv_item_sk = i.i_item_sk INNER JOIN warehouse w ON inv.inv_warehouse_sk = w.w_warehouse_sk), monthly_stats AS ({monthly_stats}) {main_output2}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": [
    "All 10 output columns preserved in exact order",
    "CASE guards against division by zero maintained",
    "Single-pass aggregation eliminates duplicate scans",
    "WHERE filters applied before ORDER BY"
  ]
}
```

**Changes:** Applied single-pass aggregation pattern to compute January and February statistics in one scan of the filtered inventory data, eliminating the need for separate monthly groupings and self-join. This reduces N table scans to 1 pass while preserving exact semantics including coefficient of variation filters and defensive division guards.

**Expected speedup:** 3-5x due to elimination of self-join and redundant scans, while maintaining columnar efficiency through early column pruning.