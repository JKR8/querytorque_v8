## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: 1 — Consolidated into single CTE chain with union-promotion and filtered dimension CTEs
    ├── [CTE] promotion_dmail  [+]  — New CTE for dmail promotions
    ├── [CTE] promotion_email  [+]  — New CTE for email promotions  
    ├── [CTE] promotion_tv  [+]  — New CTE for tv promotions
    ├── [CTE] union_promotion  [+]  — UNION DISTINCT of three promotion channels
    ├── [CTE] filtered_date  [+]  — Pre-filtered date dimension
    ├── [CTE] filtered_item  [+]  — Pre-filtered item dimension
    ├── [CTE] filtered_store  [+]  — Pre-filtered store dimension
    ├── [CTE] filtered_customer_address  [+]  — Pre-filtered customer address dimension
    ├── [CTE] single_scan  [+]  — Single store_sales scan with LEFT JOIN to union_promotion
    ├── [CTE] final_calculation  [+]  — Final aggregation and percentage calculation
    ├── SORT (promotions ASC, total ASC)  [=]
    └── OUTPUT (promotions, total, CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100)  [=]
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "or_to_union", "description": "Split promotion OR condition into three separate CTEs unioned distinctly", "applied_to": ["promotion_dmail", "promotion_email", "promotion_tv", "union_promotion"]},
    {"id": "R2", "type": "star_join_prefetch", "description": "Pre-filter all dimension tables into CTEs before fact join", "applied_to": ["filtered_date", "filtered_item", "filtered_store", "filtered_customer_address"]},
    {"id": "R3", "type": "single_pass_aggregation", "description": "Consolidate two store_sales scans into one with CASE expression for promotion flag", "applied_to": ["single_scan"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "promotion_dmail": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT p_promo_sk FROM promotion WHERE p_channel_dmail = 'Y'",
        "interfaces": {"outputs": ["p_promo_sk"], "consumes": []}
      },
      "promotion_email": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT p_promo_sk FROM promotion WHERE p_channel_email = 'Y'",
        "interfaces": {"outputs": ["p_promo_sk"], "consumes": []}
      },
      "promotion_tv": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT p_promo_sk FROM promotion WHERE p_channel_tv = 'Y'",
        "interfaces": {"outputs": ["p_promo_sk"], "consumes": []}
      },
      "union_promotion": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT p_promo_sk FROM promotion_dmail UNION DISTINCT SELECT p_promo_sk FROM promotion_email UNION DISTINCT SELECT p_promo_sk FROM promotion_tv",
        "interfaces": {"outputs": ["p_promo_sk"], "consumes": ["promotion_dmail", "promotion_email", "promotion_tv"]}
      },
      "filtered_date": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy = 11",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk FROM item WHERE i_category = 'Jewelry'",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "filtered_store": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk FROM store WHERE s_gmt_offset = -7",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "filtered_customer_address": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -7",
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "single_scan": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT SUM(ss_ext_sales_price) AS total, SUM(CASE WHEN p.p_promo_sk IS NOT NULL THEN ss_ext_sales_price ELSE 0 END) AS promotions FROM store_sales INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk INNER JOIN filtered_store ON ss_store_sk = s_store_sk INNER JOIN filtered_item ON ss_item_sk = i_item_sk INNER JOIN customer ON ss_customer_sk = c_customer_sk INNER JOIN filtered_customer_address ON ca_address_sk = c_current_addr_sk LEFT JOIN union_promotion p ON ss_promo_sk = p.p_promo_sk",
        "interfaces": {"outputs": ["total", "promotions"], "consumes": ["filtered_date", "filtered_store", "filtered_item", "filtered_customer_address", "union_promotion"]}
      },
      "final_calculation": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT promotions, total, CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100 FROM single_scan ORDER BY promotions, total LIMIT 100",
        "interfaces": {"outputs": ["promotions", "total", "CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100"], "consumes": ["single_scan"]}
      }
    },
    "reconstruction_order": ["promotion_dmail", "promotion_email", "promotion_tv", "union_promotion", "filtered_date", "filtered_item", "filtered_store", "filtered_customer_address", "single_scan", "final_calculation"],
    "assembly_template": "WITH promotion_dmail AS ({promotion_dmail}), promotion_email AS ({promotion_email}), promotion_tv AS ({promotion_tv}), union_promotion AS ({union_promotion}), filtered_date AS ({filtered_date}), filtered_item AS ({filtered_item}), filtered_store AS ({filtered_store}), filtered_customer_address AS ({filtered_customer_address}), single_scan AS ({single_scan}) {final_calculation}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Split promotion OR condition into three CTEs unioned distinctly, pre‑filtered four dimension tables into lightweight CTEs, and consolidated the two original store_sales scans into a single scan with a CASE expression to separate promotional vs. total sales in one pass.

**Expected speedup**: 2–3× by eliminating the duplicate fact table scan and enabling parallel dimension‑filter evaluation.