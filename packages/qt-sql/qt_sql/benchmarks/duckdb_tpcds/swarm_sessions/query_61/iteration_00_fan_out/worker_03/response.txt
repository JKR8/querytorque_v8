## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1  — Use CTE pipeline with single fact scan
    ├── [~] CTE filtered_date  [=]  — Early dimension filtering
    ├── [~] CTE filtered_item  [=]  — Early dimension filtering  
    ├── [~] CTE filtered_store  [=]  — Early dimension filtering
    ├── [~] CTE filtered_customer_address  [=]  — Early dimension filtering
    ├── [~] CTE filtered_promotion  [=]  — Early dimension filtering
    ├── [+] CTE fact_join  — Single fact table scan with dimension joins
    │   ├── SCAN store_sales
    │   ├── JOIN filtered_date (INNER)
    │   ├── JOIN filtered_store (INNER)
    │   ├── JOIN filtered_item (INNER)
    │   ├── JOIN customer (INNER)
    │   └── JOIN filtered_customer_address (INNER)
    ├── [+] CTE promotional_agg  — Aggregate promotional sales
    │   └── AGGREGATE (SUM) + JOIN filtered_promotion
    ├── [+] CTE all_sales_agg  — Aggregate all sales
    │   └── AGGREGATE (SUM)
    └── [~] final_calculation  — CROSS JOIN aggregates and compute percentage
        ├── JOIN (CROSS) promotional_agg, all_sales_agg
        ├── OUTPUT (promotions, total, percentage)
        └── SORT (promotions, total) + LIMIT 100
```

**Changes:**
- `[+]` Added `fact_join` CTE that performs single store_sales scan with all dimension joins except promotion
- `[+]` Added `promotional_agg` CTE that aggregates promotional sales by joining `fact_join` with `filtered_promotion`
- `[+]` Added `all_sales_agg` CTE that aggregates all sales directly from `fact_join`
- `[~]` Modified `main_query` to use CTE structure instead of parallel subqueries

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "prefetch_fact_join",
      "description": "Replace parallel subqueries with CTE pipeline: pre-filter dimensions, join once with fact table, then split aggregates",
      "applied_to": ["filtered_date", "filtered_item", "filtered_store", "filtered_customer_address", "filtered_promotion", "fact_join", "promotional_agg", "all_sales_agg", "main_query"]
    },
    {
      "id": "R2", 
      "type": "dimension_cte_isolate",
      "description": "Pre-filter dimension tables into CTEs before fact join to create small hash tables",
      "applied_to": ["filtered_date", "filtered_item", "filtered_store", "filtered_customer_address", "filtered_promotion"]
    },
    {
      "id": "R3",
      "type": "single_fact_scan",
      "description": "Scan store_sales once in fact_join CTE, then reuse for both promotional and total aggregates",
      "applied_to": ["fact_join", "promotional_agg", "all_sales_agg"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy = 11",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte", 
        "change": "modified",
        "sql": "SELECT i_item_sk FROM item WHERE i_category = 'Jewelry'",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "filtered_store": {
        "type": "cte",
        "change": "modified", 
        "sql": "SELECT s_store_sk FROM store WHERE s_gmt_offset = -7",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "filtered_customer_address": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -7", 
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "filtered_promotion": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT p_promo_sk FROM promotion WHERE p_channel_dmail = 'Y' OR p_channel_email = 'Y' OR p_channel_tv = 'Y'",
        "interfaces": {"outputs": ["p_promo_sk"], "consumes": []}
      },
      "fact_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_ext_sales_price, ss_promo_sk FROM store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk JOIN filtered_store ON ss_store_sk = s_store_sk JOIN filtered_item ON ss_item_sk = i_item_sk JOIN customer ON ss_customer_sk = c_customer_sk JOIN filtered_customer_address ON ca_address_sk = c_current_addr_sk",
        "interfaces": {"outputs": ["ss_ext_sales_price", "ss_promo_sk"], "consumes": ["filtered_date", "filtered_store", "filtered_item", "filtered_customer_address"]}
      },
      "promotional_agg": {
        "type": "cte",
        "change": "added", 
        "sql": "SELECT SUM(ss_ext_sales_price) AS promotions FROM fact_join JOIN filtered_promotion ON ss_promo_sk = p_promo_sk",
        "interfaces": {"outputs": ["promotions"], "consumes": ["fact_join", "filtered_promotion"]}
      },
      "all_sales_agg": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT SUM(ss_ext_sales_price) AS total FROM fact_join",
        "interfaces": {"outputs": ["total"], "consumes": ["fact_join"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT promotions, total, CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100 FROM promotional_agg CROSS JOIN all_sales_agg ORDER BY promotions, total LIMIT 100",
        "interfaces": {"outputs": ["promotions", "total", "CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100"], "consumes": ["promotional_agg", "all_sales_agg"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_item", "filtered_store", "filtered_customer_address", "filtered_promotion", "fact_join", "promotional_agg", "all_sales_agg", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_item AS ({filtered_item}), filtered_store AS ({filtered_store}), filtered_customer_address AS ({filtered_customer_address}), filtered_promotion AS ({filtered_promotion}), fact_join AS ({fact_join}), promotional_agg AS ({promotional_agg}), all_sales_agg AS ({all_sales_agg}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Replace parallel store_sales scans with single scan in `fact_join` CTE, pre-filter dimensions into small CTEs for hash join efficiency, maintain semantic equivalence (same filters, same join types, same calculation). The `fact_join` CTE materializes the filtered fact rows once, preventing duplicate fact table scans while preserving all original filters and join conditions.

**Expected speedup:** ~2-3x by eliminating the second store_sales scan and enabling predicate pushdown through CTE chain. The dimension CTEs create tiny hash tables, and the single fact scan with subsequent aggregate split avoids the 2x sequential scan overhead of the original query.