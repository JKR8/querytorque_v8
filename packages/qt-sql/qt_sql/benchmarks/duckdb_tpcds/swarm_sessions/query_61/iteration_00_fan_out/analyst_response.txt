<reasoning>
1. **CLASSIFY**: This query is a **repeated fact scan** archetype. Two nearly identical subqueries scan the same fact table (store_sales) with the same dimension filters, differing only by the presence/absence of a promotion join and promotion filter. The subqueries are computed independently and then cross-joined (each returns a scalar aggregate). This is a classic case of redundant scanning.

2. **EXPLAIN PLAN ANALYSIS**:
   - Total runtime: 54ms.
   - Dominant cost: Two sequential scans of store_sales (20.9ms + 20.1ms = 41ms, 76% of total). Each scan reads ~56K rows from 345.6M rows (0.016% selectivity).
   - Row count drops sharply after date_dim join (73K → 30 rows) and item join (102K → 10K rows). The store join shows 0 rows due to a filter (s_store_sk <= 100) that appears in the EXPLAIN but not the original query—likely a placeholder or misinterpretation; the actual filter s_gmt_offset=-7 is present.
   - The optimizer already pushes filters into scans (e.g., date_dim filter pushed). It does NOT consolidate the two store_sales scans into one.
   - Each subquery scans store_sales once, for a total of 2 scans. Reducing to 1 scan would save ~20ms (37% of total).
   - The CTEs (subqueries) are not materialized; they are inlined and executed independently.

3. **GAP MATCHING**:
   - **REDUNDANT_SCAN_ELIMINATION**: Present. Two independent scans of store_sales with nearly identical joins/filters.
   - **CROSS_COLUMN_OR_DECOMPOSITION**: Present in promotion filter (p_channel_dmail='Y' OR p_channel_email='Y' OR p_channel_tv='Y'). The OR spans different columns of the same table.
   - **CROSS_CTE_PREDICATE_BLINDNESS**: Present. The same dimension filters (date, item, store, customer_address) are applied in both subqueries but evaluated separately each time.
   - The optimizer already handles intra-scan predicate pushdown well (filters appear in SEQ_SCAN nodes). No correlated subqueries, no EXISTS, no INTERSECT, no window functions.

4. **AGGREGATION TRAP CHECK**: Only SUM aggregates. No grouping-sensitive functions. The two aggregates are over overlapping but not identical row sets (promotional sales ⊆ total sales). Conditional aggregation with CASE or FILTER is safe because SUM is duplicate-insensitive and the join with promotion is a left join (preserves all rows for total, flags promotional rows).

5. **TRANSFORM SELECTION** (ranked by expected value):
   - **single_pass_aggregation** (high value, 4.47x historical): Consolidate two store_sales scans into one with conditional aggregation.
   - **or_to_union** (medium value, 3.17x historical): Split promotion OR into UNION ALL branches for better promotion table scan.
   - **star_join_prefetch** (medium value, 2.71x historical): Pre-filter all dimensions into CTEs before joining with store_sales once.
   - **exploration**: Combine single_pass_aggregation with pre-filtered dimension CTEs and OR-to-UNION on promotion.

6. **LOGICAL TREE DESIGN**:
   - Ensure CTE column completeness: Each CTE must output all columns needed downstream (join keys, aggregates).
   - For single_pass_aggregation, create a CTE that joins store_sales with all dimensions (left join promotion) and computes both sums conditionally.
   - For star_join_prefetch, create CTEs for each filtered dimension, then join them with store_sales in a single pass.
   - For or_to_union, split the promotion CTE into three UNION ALL branches.
   - For exploration, combine all three techniques.

Diversity: Each worker attacks a different bottleneck:
   - Worker 1: Consolidate scans (single_pass_aggregation).
   - Worker 2: Optimize promotion scan (or_to_union).
   - Worker 3: Pre-filter dimensions (star_join_prefetch).
   - Worker 4: Compound strategy (single_pass + prefetch + OR split).
</reasoning>
=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
Calculate November 1999 promotional-store-sales share for Jewelry in GMT offset -7 by dividing promotion-qualified sales by total sales under the same geography/category constraints. All joins are INNER (intersection) except promotion which is optional for total sales (LEFT JOIN preserves all sales rows). Aggregation uses SUM only (no grouping-sensitive traps). Filters on customer_address (ca_gmt_offset), item (i_category), store (s_gmt_offset), and date_dim (d_year, d_moy) must apply to both promotional and total sales; the promotion filter (p_channel_* OR) applies only to promotional sales.

BOTTLENECK_DIAGNOSIS:
Scan-bound: two sequential scans of store_sales (41ms, 76% of total) dominate cost. Each scan reads ~56K rows after date/item filters. Cardinality flow: date_dim (30 rows) → store_sales (56K rows) → item join (2.4K rows) → promotion join (1.2K rows). The optimizer already pushes filters into scans (date_dim, item) but cannot consolidate the two independent subqueries into a single scan. Logical-tree cost percentages are misleading (store_sales scans show 39%/37% exclusive time, but together they are 76% of total).

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output promotions, total, and calculated percentage exactly as original.
- CTE_COLUMN_COMPLETENESS: CTEs must include all columns referenced downstream (join keys, ss_ext_sales_price, promotion flags).
- LITERAL_PRESERVATION: Must preserve literal filters: ca_gmt_offset=-7, i_category='Jewelry', p_channel_dmail='Y', etc., d_year=1999, d_moy=11, s_gmt_offset=-7.
- SEMANTIC_EQUIVALENCE: Result must be identical single row with same numeric values.
- REDUNDANT_SCAN_ELIMINATION: Two store_sales scans present (EXPLAIN shows 2x SEQ_SCAN store_sales).
- CROSS_COLUMN_OR_DECOMPOSITION: Promotion filter ORs on three different columns (p_channel_dmail, p_channel_email, p_channel_tv).
- CROSS_CTE_PREDICATE_BLINDNESS: Same dimension filters applied in two separate subqueries.

REGRESSION_WARNINGS:
1. or_to_union (0.59x on Q90):
   CAUSE: Split same-column time range OR into UNION ALL, duplicating fact table scans.
   RULE: Only split OR on different columns of the same table, and only on dimension tables (not fact). Here, OR is on promotion table columns, not store_sales.
2. prefetch_fact_join (0.50x on Q25):
   CAUSE: CTE materialization overhead dominated on fast baseline (<50ms).
   RULE: Baseline is 54ms; still borderline. Use lightweight CTEs (filter only, no aggregation) to minimize overhead.
3. dimension_cte_isolate (0.0076x on Q26):
   CAUSE: Cross-joined 3+ dimension CTEs causing Cartesian explosion.
   RULE: Never cross-join dimension CTEs; join them sequentially with fact table.

=== WORKER 1 BRIEFING ===

STRATEGY: single_pass_aggregation
TARGET_LOGICAL_TREE:
  filtered_dims -> single_scan_with_conditional_aggs -> final_calculation
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_year=1999 AND d_moy=11
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 30
    CONSUMERS: single_scan
  filtered_item:
    FROM: item
    WHERE: i_category='Jewelry'
    OUTPUT: i_item_sk
    EXPECTED_ROWS: 10K
    CONSUMERS: single_scan
  filtered_store:
    FROM: store
    WHERE: s_gmt_offset=-7
    OUTPUT: s_store_sk
    EXPECTED_ROWS: unknown (plan shows 0 but likely >0)
    CONSUMERS: single_scan
  filtered_customer_address:
    FROM: customer_address
    WHERE: ca_gmt_offset=-7
    OUTPUT: ca_address_sk
    EXPECTED_ROWS: 702
    CONSUMERS: single_scan
  filtered_promotion:
    FROM: promotion
    WHERE: p_channel_dmail='Y' OR p_channel_email='Y' OR p_channel_tv='Y'
    OUTPUT: p_promo_sk
    EXPECTED_ROWS: 251
    CONSUMERS: single_scan
  single_scan:
    FROM: store_sales
         JOIN filtered_date ON ss_sold_date_sk = d_date_sk
         JOIN filtered_store ON ss_store_sk = s_store_sk
         JOIN filtered_item ON ss_item_sk = i_item_sk
         JOIN customer ON ss_customer_sk = c_customer_sk
         JOIN filtered_customer_address ON ca_address_sk = c_current_addr_sk
         LEFT JOIN filtered_promotion ON ss_promo_sk = p_promo_sk
    OUTPUT: 
        SUM(ss_ext_sales_price) AS total,
        SUM(CASE WHEN p_promo_sk IS NOT NULL THEN ss_ext_sales_price ELSE 0 END) AS promotions
    EXPECTED_ROWS: ~60K (combined)
    CONSUMERS: final_calculation
  final_calculation:
    FROM: single_scan
    OUTPUT: 
        promotions,
        total,
        CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100
    EXPECTED_ROWS: 1
    CONSUMERS: output
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation
EXAMPLE_ADAPTATION:
- single_pass_aggregation (Q9): Apply the pattern of merging multiple subqueries into one CTE with CASE aggregates. Ignore the scalar subquery context; adapt to our two subqueries.
- channel_bitmap_aggregation (Q88): Apply consolidation of repeated fact scans into a single scan with conditional aggregation. Ignore the bitmap labeling; we only have two conditions (promotional vs total).
HAZARD_FLAGS:
- LEFT JOIN filtered_promotion must not filter out rows; use LEFT JOIN to preserve all sales for total.
- Ensure filtered_promotion CTE includes only rows matching OR condition; otherwise promotional sum may be incorrect.

=== WORKER 2 BRIEFING ===

STRATEGY: or_to_union
TARGET_LOGICAL_TREE:
  promotion_union -> dims_and_fact -> separate_aggs -> final_calculation
NODE_CONTRACTS:
  promotion_dmail:
    FROM: promotion
    WHERE: p_channel_dmail='Y'
    OUTPUT: p_promo_sk
    EXPECTED_ROWS: subset of 251
    CONSUMERS: promotion_union
  promotion_email:
    FROM: promotion
    WHERE: p_channel_email='Y'
    OUTPUT: p_promo_sk
    EXPECTED_ROWS: subset of 251
    CONSUMERS: promotion_union
  promotion_tv:
    FROM: promotion
    WHERE: p_channel_tv='Y'
    OUTPUT: p_promo_sk
    EXPECTED_ROWS: subset of 251
    CONSUMERS: promotion_union
  promotion_union:
    FROM: promotion_dmail UNION ALL promotion_email UNION ALL promotion_tv
    OUTPUT: p_promo_sk
    EXPECTED_ROWS: 251
    CONSUMERS: promotional_scan
  filtered_dims: [same as Worker 1 filtered_date, item, store, customer_address]
  all_sales_scan:
    FROM: store_sales
         JOIN filtered_dims... (same joins as original all_sales subquery, excluding promotion)
    OUTPUT: ss_ext_sales_price
    EXPECTED_ROWS: ~60K
    CONSUMERS: all_sales_agg
  promotional_scan:
    FROM: store_sales
         JOIN filtered_dims...
         JOIN promotion_union ON ss_promo_sk = p_promo_sk
    OUTPUT: ss_ext_sales_price
    EXPECTED_ROWS: ~1.2K
    CONSUMERS: promotional_agg
  all_sales_agg:
    FROM: all_sales_scan
    AGGREGATE: SUM(ss_ext_sales_price) AS total
    OUTPUT: total
    EXPECTED_ROWS: 1
    CONSUMERS: final_calculation
  promotional_agg:
    FROM: promotional_scan
    AGGREGATE: SUM(ss_ext_sales_price) AS promotions
    OUTPUT: promotions
    EXPECTED_ROWS: 1
    CONSUMERS: final_calculation
  final_calculation:
    FROM: promotional_agg CROSS JOIN all_sales_agg
    OUTPUT: promotions, total, CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100
    EXPECTED_ROWS: 1
    CONSUMERS: output
EXAMPLES: or_to_union
EXAMPLE_ADAPTATION:
- or_to_union (Q15): Split OR on different promotion columns into UNION ALL branches. Ignore the fact that Q15 splits fact table OR; we split only dimension table (promotion) OR.
HAZARD_FLAGS:
- UNION ALL may duplicate promotion rows if a promotion qualifies for multiple channels (unlikely per data model). If duplicates possible, use UNION DISTINCT.
- Still two store_sales scans (all_sales_scan and promotional_scan) because we didn't consolidate scans.

=== WORKER 3 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  prefetched_dims -> fact_join -> split_aggs -> final_calculation
NODE_CONTRACTS:
  filtered_date: [same as Worker 1]
  filtered_item: [same as Worker 1]
  filtered_store: [same as Worker 1]
  filtered_customer_address: [same as Worker 1]
  filtered_promotion: [same as Worker 1]
  prefetched_dims:
    FROM: filtered_date, filtered_item, filtered_store, filtered_customer_address
    OUTPUT: d_date_sk, i_item_sk, s_store_sk, ca_address_sk
    EXPECTED_ROWS: Cartesian product of small dimension rows (but not joined; just a list of CTEs)
    CONSUMERS: fact_join
  fact_join:
    FROM: store_sales
         JOIN filtered_date ON ss_sold_date_sk = d_date_sk
         JOIN filtered_store ON ss_store_sk = s_store_sk
         JOIN filtered_item ON ss_item_sk = i_item_sk
         JOIN customer ON ss_customer_sk = c_customer_sk
         JOIN filtered_customer_address ON ca_address_sk = c_current_addr_sk
    OUTPUT: ss_ext_sales_price, ss_promo_sk
    EXPECTED_ROWS: ~60K
    CONSUMERS: promotional_agg, all_sales_agg
  promotional_agg:
    FROM: fact_join JOIN filtered_promotion ON ss_promo_sk = p_promo_sk
    AGGREGATE: SUM(ss_ext_sales_price) AS promotions
    OUTPUT: promotions
    EXPECTED_ROWS: 1
    CONSUMERS: final_calculation
  all_sales_agg:
    FROM: fact_join
    AGGREGATE: SUM(ss_ext_sales_price) AS total
    OUTPUT: total
    EXPECTED_ROWS: 1
    CONSUMERS: final_calculation
  final_calculation:
    FROM: promotional_agg CROSS JOIN all_sales_agg
    OUTPUT: promotions, total, CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100
    EXPECTED_ROWS: 1
    CONSUMERS: output
EXAMPLES: star_join_prefetch, prefetch_fact_join, dimension_cte_isolate
EXAMPLE_ADAPTATION:
- prefetch_fact_join (Q63): Apply CTE chain: filter dimensions, then join with fact table. Ignore the multi-fact aspect; we have only one fact table.
- dimension_cte_isolate (Q26): Pre-filter all dimension tables into CTEs before fact join. Ignore the cross-join hazard; we join dimensions sequentially with fact.
HAZARD_FLAGS:
- Still two aggregates over the same fact_join result (one with extra promotion join). This may still scan fact_join twice (if CTE not materialized). Use a materialized CTE for fact_join to avoid rescan.
- Ensure filtered_promotion CTE is referenced only once.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: compound_single_pass_prefetch_union
TARGET_LOGICAL_TREE:
  union_promotion -> prefetched_dims -> single_scan_conditional -> final_calculation
NODE_CONTRACTS:
  promotion_dmail: [same as Worker 2]
  promotion_email: [same as Worker 2]
  promotion_tv: [same as Worker 2]
  union_promotion:
    FROM: promotion_dmail UNION ALL promotion_email UNION ALL promotion_tv
    OUTPUT: p_promo_sk
    EXPECTED_ROWS: 251
    CONSUMERS: single_scan
  filtered_date: [same as Worker 1]
  filtered_item: [same as Worker 1]
  filtered_store: [same as Worker 1]
  filtered_customer_address: [same as Worker 1]
  single_scan:
    FROM: store_sales
         JOIN filtered_date ON ss_sold_date_sk = d_date_sk
         JOIN filtered_store ON ss_store_sk = s_store_sk
         JOIN filtered_item ON ss_item_sk = i_item_sk
         JOIN customer ON ss_customer_sk = c_customer_sk
         JOIN filtered_customer_address ON ca_address_sk = c_current_addr_sk
         LEFT JOIN union_promotion ON ss_promo_sk = p_promo_sk
    OUTPUT:
        SUM(ss_ext_sales_price) AS total,
        SUM(CASE WHEN p_promo_sk IS NOT NULL THEN ss_ext_sales_price ELSE 0 END) AS promotions
    EXPECTED_ROWS: ~60K
    CONSUMERS: final_calculation
  final_calculation:
    FROM: single_scan
    OUTPUT: promotions, total, CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100
    EXPECTED_ROWS: 1
    CONSUMERS: output
EXAMPLES: single_pass_aggregation, or_to_union, star_join_prefetch
EXAMPLE_ADAPTATION:
- single_pass_aggregation (Q9): Apply consolidation of two subqueries into one scan with CASE.
- or_to_union (Q15): Apply UNION ALL split of promotion OR across different columns.
- star_join_prefetch (Q43): Apply pre-filtering of all dimensions into CTEs before fact join.
HAZARD_FLAGS:
- UNION ALL may cause duplicate promotion rows if a promotion qualifies for multiple channels. Use UNION DISTINCT if duplicates possible.
- CTE materialization overhead may negate gains if too many CTEs. Use only necessary CTEs (5 dimension CTEs + union_promotion).
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy