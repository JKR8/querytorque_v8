## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Single-pass aggregation with CASE expressions replaces two separate store_sales scans
    ├── [CTE] filtered_date  [=]
    ├── [CTE] filtered_item  [=]
    ├── [CTE] filtered_store  [=]
    ├── [CTE] filtered_customer_address  [=]
    ├── [CTE] filtered_promotion  [=]
    ├── [CTE] single_scan  [~]  — Replaces two subqueries with conditional SUM(CASE)
    │   ├── JOIN store_sales
    │   ├── JOIN filtered_date
    │   ├── JOIN filtered_store
    │   ├── JOIN filtered_item
    │   ├── JOIN customer
    │   ├── JOIN filtered_customer_address
    │   ├── LEFT JOIN filtered_promotion
    │   └── AGGREGATE SUM(ss_ext_sales_price) as total,
    │                   SUM(CASE WHEN p_promo_sk IS NOT NULL THEN ss_ext_sales_price ELSE 0 END) as promotions
    └── [CTE] final_calculation  [~]  — Uses single_scan CTE instead of cross-join subqueries
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb_1_4_3",
  "rewrite_rules": [
    {"id": "R1", "type": "single_pass_aggregation", "description": "Merged two separate store_sales scans (promotional_sales and all_sales) into single scan with conditional aggregation using CASE expressions", "applied_to": ["single_scan"]},
    {"id": "R2", "type": "cte_decomposition", "description": "Extracted dimension table filters into separate CTEs for predicate pushdown and reuse", "applied_to": ["filtered_date", "filtered_item", "filtered_store", "filtered_customer_address", "filtered_promotion"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_item": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["i_item_sk"], "consumes": []}
      },
      "filtered_store": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "filtered_customer_address": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["ca_address_sk"], "consumes": []}
      },
      "filtered_promotion": {
        "type": "cte",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["p_promo_sk"], "consumes": []}
      },
      "single_scan": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT SUM(ss_ext_sales_price) AS total, SUM(CASE WHEN p_promo_sk IS NOT NULL THEN ss_ext_sales_price ELSE 0 END) AS promotions FROM store_sales JOIN filtered_date ON ss_sold_date_sk = d_date_sk JOIN filtered_store ON ss_store_sk = s_store_sk JOIN filtered_item ON ss_item_sk = i_item_sk JOIN customer ON ss_customer_sk = c_customer_sk JOIN filtered_customer_address ON ca_address_sk = c_current_addr_sk LEFT JOIN filtered_promotion ON ss_promo_sk = p_promo_sk",
        "interfaces": {"outputs": ["total", "promotions"], "consumes": ["filtered_date", "filtered_store", "filtered_item", "filtered_customer_address", "filtered_promotion"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT promotions, total, CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100 FROM single_scan ORDER BY promotions, total LIMIT 100",
        "interfaces": {"outputs": ["promotions", "total", "CAST(promotions AS DECIMAL(15,4))/CAST(total AS DECIMAL(15,4))*100"], "consumes": ["single_scan"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_item", "filtered_store", "filtered_customer_address", "filtered_promotion", "single_scan", "main_query"],
    "assembly_template": "WITH filtered_date AS (SELECT d_date_sk FROM date_dim WHERE d_year = 1999 AND d_moy = 11), filtered_item AS (SELECT i_item_sk FROM item WHERE i_category = 'Jewelry'), filtered_store AS (SELECT s_store_sk FROM store WHERE s_gmt_offset = -7), filtered_customer_address AS (SELECT ca_address_sk FROM customer_address WHERE ca_gmt_offset = -7), filtered_promotion AS (SELECT p_promo_sk FROM promotion WHERE p_channel_dmail = 'Y' OR p_channel_email = 'Y' OR p_channel_tv = 'Y'), single_scan AS ({single_scan}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

## Changes

Consolidated two separate store_sales scans (promotional_sales and all_sales subqueries) into a single CTE scan with conditional aggregation using CASE expressions inside SUM(), preserving LEFT JOIN semantics for promotions. This eliminates redundant fact table scans while maintaining exact semantic equivalence.

**Expected speedup:** ~2x (eliminates duplicate store_sales scan and joins)