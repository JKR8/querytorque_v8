## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  — Restructured into staged CTE pipeline
    ├── [CTE] filtered_dates  [+]  — Pre-filtered date dimension
    │   ├── SCAN (date_dim)
    │   └── FILTER (d_date BETWEEN '1998-04-06' AND '1998-04-06' + 30 DAY)
    ├── [CTE] prefetched_fact  [+]  — Fact table pre‑joined with filtered dates
    │   ├── SCAN (web_sales)
    │   └── JOIN (filtered_dates ON ws_sold_date_sk = d_date_sk)
    ├── [CTE] filtered_items  [+]  — Pre-filtered item dimension
    │   ├── SCAN (item)
    │   └── FILTER (i_category IN ('Books','Sports','Men'))
    ├── [CTE] aggregated  [+]  — Join reduced fact with filtered items, then aggregate
    │   ├── JOIN (prefetched_fact WITH filtered_items ON ws_item_sk = i_item_sk)
    │   └── AGG (GROUP BY i_item_id,i_item_desc,i_category,i_class,i_current_price)
    ├── [CTE] windowed  [+]  — Compute class revenue and ratio
    │   └── WINDOW (SUM(itemrevenue) OVER (PARTITION BY i_class))
    ├── [CTE] top_n  [+]  — Final ordering and limit
    │   ├── SORT (i_category,i_class,i_item_id,i_item_desc,revenueratio)
    │   └── LIMIT 100
    └── OUTPUT (i_item_id,i_item_desc,i_category,i_class,i_current_price,itemrevenue,revenueratio)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "prefetch_fact_join",
      "description": "Staged CTE pipeline: pre‑filter date and item dimensions, pre‑join date with fact, then join filtered items before aggregation.",
      "applied_to": ["filtered_dates", "prefetched_fact", "filtered_items", "aggregated", "windowed", "top_n"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('1998-04-06' AS DATE) AND (CAST('1998-04-06' AS DATE) + INTERVAL 30 DAY)",
        "interfaces": {
          "outputs": ["d_date_sk"],
          "consumes": []
        }
      },
      "prefetched_fact": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ws_item_sk, ws_ext_sales_price FROM web_sales INNER JOIN filtered_dates ON ws_sold_date_sk = d_date_sk",
        "interfaces": {
          "outputs": ["ws_item_sk", "ws_ext_sales_price"],
          "consumes": ["filtered_dates"]
        }
      },
      "filtered_items": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_item_id, i_item_desc, i_category, i_class, i_current_price FROM item WHERE i_category IN ('Books', 'Sports', 'Men')",
        "interfaces": {
          "outputs": ["i_item_sk", "i_item_id", "i_item_desc", "i_category", "i_class", "i_current_price"],
          "consumes": []
        }
      },
      "aggregated": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, i_item_desc, i_category, i_class, i_current_price, SUM(ws_ext_sales_price) AS itemrevenue FROM prefetched_fact INNER JOIN filtered_items ON ws_item_sk = i_item_sk GROUP BY i_item_id, i_item_desc, i_category, i_class, i_current_price",
        "interfaces": {
          "outputs": ["i_item_id", "i_item_desc", "i_category", "i_class", "i_current_price", "itemrevenue"],
          "consumes": ["prefetched_fact", "filtered_items"]
        }
      },
      "windowed": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, i_item_desc, i_category, i_class, i_current_price, itemrevenue, (itemrevenue * 100 / SUM(itemrevenue) OVER (PARTITION BY i_class)) AS revenueratio FROM aggregated",
        "interfaces": {
          "outputs": ["i_item_id", "i_item_desc", "i_category", "i_class", "i_current_price", "itemrevenue", "revenueratio"],
          "consumes": ["aggregated"]
        }
      },
      "top_n": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_id, i_item_desc, i_category, i_class, i_current_price, itemrevenue, revenueratio FROM windowed ORDER BY i_category ASC, i_class ASC, i_item_id ASC, i_item_desc ASC, revenueratio ASC LIMIT 100",
        "interfaces": {
          "outputs": ["i_item_id", "i_item_desc", "i_category", "i_class", "i_current_price", "itemrevenue", "revenueratio"],
          "consumes": ["windowed"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_item_id, i_item_desc, i_category, i_class, i_current_price, itemrevenue, revenueratio FROM top_n",
        "interfaces": {
          "outputs": ["i_item_id", "i_item_desc", "i_category", "i_class", "i_current_price", "itemrevenue", "revenueratio"],
          "consumes": ["top_n"]
        }
      }
    },
    "reconstruction_order": ["filtered_dates", "prefetched_fact", "filtered_items", "aggregated", "windowed", "top_n", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), prefetched_fact AS ({prefetched_fact}), filtered_items AS ({filtered_items}), aggregated AS ({aggregated}), windowed AS ({windowed}), top_n AS ({top_n}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured the original flat join into a staged CTE pipeline that pre‑filters the date and item dimensions, reduces the fact table early via the date join, then joins the filtered items before aggregation. This reduces hash‑table sizes and intermediate data movement.

**Expected speedup**: ~3‑4× (similar to the `prefetch_fact_join` example) due to early reduction of the fact table by the selective date filter and compound selectivity from the item category filter applied before the main join.