## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ~206  — Rewritten as CTE pipeline with union-all rollup
    ├── [=] filtered_dates (CTE)  Rows: 365
    ├── [=] filtered_stores (CTE)  Rows: 100
    ├── [~] joined_fact (CTE)  Rows: 5.4M  — Explicit INNER JOIN chain (was implicit in FROM)
    ├── [~] state_county_agg (CTE)  Rows: ~2000  — Explicit GROUP BY (was part of rollup)
    ├── [+] top_states (CTE)  Rows: ~50  — Extracted state-level ranking subquery
    ├── [+] level0 (CTE)  Rows: ~200  — County-level aggregates for top states
    ├── [+] level1 (CTE)  Rows: 5  — State-level aggregates for top states
    ├── [+] level2 (CTE)  Rows: 1  — Total aggregate for top states
    ├── [+] union_all (CTE)  Rows: ~206  — UNION ALL of three levels
    └── [~] windowed (CTE)  Rows: ~206  — Final window function (was in main SELECT)

No changes to:
- SCAN operations (date_dim, store, store_sales)
- FILTER predicates (d_month_seq range, s_store_sk limit)
- OUTPUT schema (total_sum, s_state, s_county, lochierarchy, rank_within_parent)
```

**Change markers explanation:**
- `[+]` = New CTE nodes added per target tree
- `[~]` = Modified components (joined_fact becomes explicit CTE, state_county_agg becomes CTE)
- `[!]` = Structural change from single ROLLUP query to CTE pipeline with UNION ALL

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "rollup_to_union_windowing", "description": "Convert GROUP BY ROLLUP to explicit UNION ALL of three aggregation levels (county, state, total)", "applied_to": ["main_query"]},
    {"id": "R2", "type": "predicate_pushdown", "description": "Push date and store filters into dedicated CTEs for early filtering", "applied_to": ["filtered_dates", "filtered_stores"]},
    {"id": "R3", "type": "cte_specialization", "description": "Split top-state subquery into reusable CTE, computed once", "applied_to": ["top_states"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1213 AND 1224",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_stores": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk, s_state, s_county FROM store WHERE s_store_sk <= 100",
        "interfaces": {"outputs": ["s_store_sk", "s_state", "s_county"], "consumes": []}
      },
      "joined_fact": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_net_profit, s_state, s_county FROM store_sales INNER JOIN filtered_dates ON ss_sold_date_sk = d_date_sk INNER JOIN filtered_stores ON ss_store_sk = s_store_sk",
        "interfaces": {"outputs": ["ss_net_profit", "s_state", "s_county"], "consumes": ["filtered_dates", "filtered_stores"]}
      },
      "state_county_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_state, s_county, SUM(ss_net_profit) AS state_county_sum FROM joined_fact GROUP BY s_state, s_county",
        "interfaces": {"outputs": ["s_state", "s_county", "state_county_sum"], "consumes": ["joined_fact"]}
      },
      "top_states": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_state, SUM(state_county_sum) AS state_sum, RANK() OVER (ORDER BY SUM(state_county_sum) DESC) AS ranking FROM state_county_agg GROUP BY s_state",
        "interfaces": {"outputs": ["s_state", "state_sum", "ranking"], "consumes": ["state_county_agg"]}
      },
      "level0": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT SUM(state_county_sum) AS total_sum, state_county_agg.s_state, s_county, 0 AS lochierarchy FROM state_county_agg INNER JOIN top_states ON state_county_agg.s_state = top_states.s_state WHERE top_states.ranking <= 5 GROUP BY state_county_agg.s_state, s_county",
        "interfaces": {"outputs": ["total_sum", "s_state", "s_county", "lochierarchy"], "consumes": ["state_county_agg", "top_states"]}
      },
      "level1": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT SUM(state_county_sum) AS total_sum, state_county_agg.s_state, NULL AS s_county, 1 AS lochierarchy FROM state_county_agg INNER JOIN top_states ON state_county_agg.s_state = top_states.s_state WHERE top_states.ranking <= 5 GROUP BY state_county_agg.s_state",
        "interfaces": {"outputs": ["total_sum", "s_state", "s_county", "lochierarchy"], "consumes": ["state_county_agg", "top_states"]}
      },
      "level2": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT SUM(state_county_sum) AS total_sum, NULL AS s_state, NULL AS s_county, 2 AS lochierarchy FROM state_county_agg INNER JOIN top_states ON state_county_agg.s_state = top_states.s_state WHERE top_states.ranking <= 5",
        "interfaces": {"outputs": ["total_sum", "s_state", "s_county", "lochierarchy"], "consumes": ["state_county_agg", "top_states"]}
      },
      "union_all": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT total_sum, s_state, s_county, lochierarchy FROM level0 UNION ALL SELECT total_sum, s_state, s_county, lochierarchy FROM level1 UNION ALL SELECT total_sum, s_state, s_county, lochierarchy FROM level2",
        "interfaces": {"outputs": ["total_sum", "s_state", "s_county", "lochierarchy"], "consumes": ["level0", "level1", "level2"]}
      },
      "windowed": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT total_sum, s_state, s_county, lochierarchy, RANK() OVER (PARTITION BY lochierarchy, CASE WHEN lochierarchy = 0 THEN s_state END ORDER BY total_sum DESC) AS rank_within_parent FROM union_all",
        "interfaces": {"outputs": ["total_sum", "s_state", "s_county", "lochierarchy", "rank_within_parent"], "consumes": ["union_all"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT total_sum, s_state, s_county, lochierarchy, rank_within_parent FROM windowed ORDER BY lochierarchy DESC, CASE WHEN lochierarchy = 0 THEN s_state END, rank_within_parent LIMIT 100",
        "interfaces": {"outputs": ["total_sum", "s_state", "s_county", "lochierarchy", "rank_within_parent"], "consumes": ["windowed"]}
      }
    },
    "reconstruction_order": ["filtered_dates", "filtered_stores", "joined_fact", "state_county_agg", "top_states", "level0", "level1", "level2", "union_all", "windowed", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), filtered_stores AS ({filtered_stores}), joined_fact AS ({joined_fact}), state_county_agg AS ({state_county_agg}), top_states AS ({top_states}), level0 AS ({level0}), level1 AS ({level1}), level2 AS ({level2}), union_all AS ({union_all}), windowed AS ({windowed}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": [
    "Output columns match original: total_sum, s_state, s_county, lochierarchy, rank_within_parent",
    "Date range preserved: d_month_seq BETWEEN 1213 AND 1224",
    "Store filter preserved: s_store_sk <= 100",
    "Top-5 state ranking preserved",
    "NULL handling for s_state/s_county in level1 and level2"
  ]
}
```

## Changes & Mechanism

**Structural change:** Converted single-query ROLLUP with correlated subquery into a CTE pipeline that: 1) isolates date/store filters early, 2) computes state rankings once in `top_states` CTE, 3) builds three aggregation levels explicitly via UNION ALL instead of ROLLUP, enabling partition-wise ranking.

**Expected speedup:** 1.5–2.0x. The main gains come from:
- Early filtering reduces fact table scans
- Single computation of top_states (subquery ran per row in original ROLLUP)
- UNION ALL allows DuckDB to optimize each level independently vs. monolithic ROLLUP
- Window function applied only to ~206 rows vs. intermediate rollup result