## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Uses CTEs to filter dimensions first, then apply multi-warehouse and no-returns filters, then aggregate.
    ├── [CTE] filtered_dimensions  [+]
    │   ├── SCAN (date_dim, customer_address, web_site)
    │   ├── FILTER (d_date BETWEEN '2000-2-01' AND (CAST('2000-2-01' AS DATE) + INTERVAL 60 DAY))
    │   ├── FILTER (ca_state = 'OK')
    │   ├── FILTER (web_company_name = 'pri')
    │   └── OUTPUT (d_date_sk, ca_address_sk, web_site_sk)
    ├── [CTE] filtered_fact_with_multiwarehouse  [+]
    │   ├── SCAN (web_sales AS ws1)
    │   ├── JOIN (ws1.ws_ship_date_sk = filtered_dimensions.d_date_sk, ws1.ws_ship_addr_sk = filtered_dimensions.ca_address_sk, ws1.ws_web_site_sk = filtered_dimensions.web_site_sk)
    │   ├── FILTER (EXISTS (SELECT 1 FROM web_sales ws2 WHERE ws2.ws_order_number = ws1.ws_order_number AND ws2.ws_warehouse_sk <> ws1.ws_warehouse_sk))
    │   └── OUTPUT (ws_order_number, ws_ext_ship_cost, ws_net_profit)
    ├── [CTE] no_returns  [+]
    │   ├── SCAN (filtered_fact_with_multiwarehouse)
    │   ├── FILTER (NOT EXISTS (SELECT 1 FROM web_returns wr WHERE wr.wr_order_number = ws_order_number))
    │   └── OUTPUT (ws_order_number, ws_ext_ship_cost, ws_net_profit)
    ├── [CTE] aggregate  [+]
    │   ├── SCAN (no_returns)
    │   ├── AGGREGATE (COUNT(DISTINCT ws_order_number), SUM(ws_ext_ship_cost), SUM(ws_net_profit))
    │   └── OUTPUT (order count, total shipping cost, total net profit)
    ├── SORT (order count ASC)  [=]
    └── OUTPUT (order count, total shipping cost, total net profit)  [=]
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter", "description": "Push date, address, and website filters into a CTE to reduce fact table scans", "applied_to": ["filtered_dimensions"]},
    {"id": "R2", "type": "scan_consolidation", "description": "Use filtered_dimensions CTE for main fact join, then apply multi-warehouse EXISTS condition on raw web_sales (no dimension pushdown to ws2 to preserve semantics)", "applied_to": ["filtered_fact_with_multiwarehouse"]},
    {"id": "R3", "type": "anti_join_as_not_exists", "description": "Convert NOT EXISTS to anti‑join via WHERE NOT EXISTS subquery, preserving original semantics", "applied_to": ["no_returns"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dimensions": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, ca_address_sk, web_site_sk FROM date_dim, customer_address, web_site WHERE d_date BETWEEN '2000-2-01' AND (CAST('2000-2-01' AS DATE) + INTERVAL 60 DAY) AND ca_state = 'OK' AND web_company_name = 'pri'",
        "interfaces": {"outputs": ["d_date_sk", "ca_address_sk", "web_site_sk"], "consumes": []}
      },
      "filtered_fact_with_multiwarehouse": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ws1.ws_order_number, ws1.ws_ext_ship_cost, ws1.ws_net_profit FROM web_sales ws1 JOIN filtered_dimensions fd ON ws1.ws_ship_date_sk = fd.d_date_sk AND ws1.ws_ship_addr_sk = fd.ca_address_sk AND ws1.ws_web_site_sk = fd.web_site_sk WHERE EXISTS (SELECT 1 FROM web_sales ws2 WHERE ws2.ws_order_number = ws1.ws_order_number AND ws2.ws_warehouse_sk <> ws1.ws_warehouse_sk)",
        "interfaces": {"outputs": ["ws_order_number", "ws_ext_ship_cost", "ws_net_profit"], "consumes": ["filtered_dimensions"]}
      },
      "no_returns": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ws_order_number, ws_ext_ship_cost, ws_net_profit FROM filtered_fact_with_multiwarehouse f WHERE NOT EXISTS (SELECT 1 FROM web_returns wr WHERE wr.wr_order_number = f.ws_order_number)",
        "interfaces": {"outputs": ["ws_order_number", "ws_ext_ship_cost", "ws_net_profit"], "consumes": ["filtered_fact_with_multiwarehouse"]}
      },
      "aggregate": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT COUNT(DISTINCT ws_order_number) AS \"order count\", SUM(ws_ext_ship_cost) AS \"total shipping cost\", SUM(ws_net_profit) AS \"total net profit\" FROM no_returns",
        "interfaces": {"outputs": ["order count", "total shipping cost", "total net profit"], "consumes": ["no_returns"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT \"order count\", \"total shipping cost\", \"total net profit\" FROM aggregate ORDER BY \"order count\" LIMIT 100",
        "interfaces": {"outputs": ["order count", "total shipping cost", "total net profit"], "consumes": ["aggregate"]}
      }
    },
    "reconstruction_order": ["filtered_dimensions", "filtered_fact_with_multiwarehouse", "no_returns", "aggregate", "main_query"],
    "assembly_template": "WITH filtered_dimensions AS ({filtered_dimensions}), filtered_fact_with_multiwarehouse AS ({filtered_fact_with_multiwarehouse}), no_returns AS ({no_returns}), aggregate AS ({aggregate}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

## Changes and Expected Speedup

**Changes:** The rewrite creates CTEs that filter dimension tables first (`filtered_dimensions`), then joins to `web_sales` once to get candidate rows meeting the date/address/website criteria, applies the multi‑warehouse EXISTS condition (without pushing dimension filters into the subquery to preserve original semantics), then filters out returned orders, and finally aggregates.

**Expected speedup:** ~2–4x. Early dimension filtering reduces the fact‑table scan to only rows matching the date, state, and company. The CTE structure allows DuckDB to push filters into the main join while keeping the EXISTS subquery independent (preventing incorrect dimension pushdown). The anti‑join remains as a NOT EXISTS to preserve short‑circuit evaluation.