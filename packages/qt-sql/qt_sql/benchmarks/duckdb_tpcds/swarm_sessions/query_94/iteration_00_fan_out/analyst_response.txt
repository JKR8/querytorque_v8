<reasoning>
CLASSIFY: This query is a star-join with correlated EXISTS/NOT EXISTS filters on the same fact table (web_sales) and a separate returns table. The EXISTS condition is a self-join for multi-warehouse orders; the NOT EXISTS is an anti-join on returns. This is a "star-join with late dim filter + correlated set operations" archetype.

EXPLAIN PLAN ANALYSIS:
- Total execution time: 366ms.
- Biggest cost: SEQ_SCAN web_sales (main branch) 298.3ms (81% exclusive time) scanning 158K of 86.4M rows.
- Second cost: HASH_JOIN INNER for EXISTS self-join (26.2ms, 7%) scanning web_sales again (7.2M rows, 14.5ms).
- Third cost: HASH_JOIN INNER for customer_address filter (13.5ms, 4%).
- Row counts: 
  - web_sales main scan: 158K rows after address/date/website filters.
  - web_sales EXISTS scan: 7.2M rows (unfiltered except for join condition).
  - After EXISTS semi-join: 955 rows.
  - After NOT EXISTS anti-join: 258 rows.
- The optimizer already decorrelates EXISTS/NOT EXISTS into semi/anti joins (RIGHT_SEMI, RIGHT_ANTI). It pushes dimension filters into scans (date_dim filter pushed, customer_address filter pushed, web_site filter pushed). No CTEs are present; it's a single flat query.
- Scans per base table:
  - web_sales: scanned twice (main branch 158K rows, EXISTS branch 7.2M rows).
  - web_returns: scanned once (718K rows).
  - date_dim: scanned once (61 rows).
  - customer_address: scanned once (6,028 rows).
  - web_site: scanned once (7 rows).

GAP MATCHING:
1. CORRELATED_SUBQUERY_PARALYSIS: Already decorrelated by engine (hash joins in plan). No gap.
2. CROSS_COLUMN_OR_DECOMPOSITION: No OR conditions.
3. CROSS_CTE_PREDICATE_BLINDNESS: No CTEs exist, but predicates are already pushed into scans. However, the EXISTS subquery on web_sales does NOT inherit the dimension filters (date, address, website) because it's a separate scan. This is a missed optimization opportunity: the EXISTS condition could be evaluated on the already-filtered web_sales rows rather than rescanning the entire table. This matches the "single_pass_aggregation" gap (repeated scans of same fact table).
4. REDUNDANT_SCAN_ELIMINATION: web_sales scanned twice. Consolidating into one scan would save ~14.5ms + some join overhead.
5. UNION_CTE_SELF_JOIN_DECOMPOSITION: Not applicable.

AGGREGATION TRAP CHECK:
- Aggregates: COUNT(DISTINCT ws_order_number), SUM(ws_ext_ship_cost), SUM(ws_net_profit). All are duplicate-insensitive (SUM of costs/profits across multi-warehouse orders is correct as long as we don't double-count rows). The EXISTS and NOT EXISTS are filters, not aggregations. Changing the evaluation order of filters doesn't affect aggregates.

TRANSFORM SELECTION:
1. **single_pass_aggregation** (scan consolidation): Merge the two web_sales scans into one CTE that pre-filters by dimensions and also computes multi-warehouse condition via window/self-grouping. This attacks the redundant scan gap.
2. **star_join_prefetch** (dimension pre-filtering): Pre-filter date_dim, customer_address, web_site into CTEs, then join with web_sales. This may reduce the main scan cost further, though the engine already pushes filters. Could still help by creating tiny dimension hash tables.
3. **exists_restructuring** (decorrelation via pre-materialization): Pre-compute multi-warehouse order numbers and returned order numbers as CTEs, then join. This is similar to decorrelation but the engine already does this; however, we can control materialization and possibly push dimension filters into the multi-warehouse CTE.
4. **exploration**: Combine dimension pre-filtering with EXISTS condition pushdown (i.e., compute multi-warehouse condition only on the dimension-filtered web_sales rows). This is novel because the EXISTS condition in the original query does not inherit dimension filters. We can attempt to push those filters into the EXISTS subquery logically (since ws1 and ws2 are the same order number, and ws1 already satisfies date/address/website, then ws2 must also satisfy those dimension constraints? Not necessarily: ws2 could be from a different date, address, website. But the EXISTS condition only matches on order number, not dimensions. However, if we are only interested in orders that themselves satisfy the dimension filters (ws1), then we only need to check for existence of another warehouse for those same orders. We can compute multi-warehouse condition on the set of orders that pass dimension filters, not the entire table. This could reduce the EXISTS scan from 7.2M rows to maybe a few thousand.

LOGICAL TREE DESIGN:
Will design 4 different CTE structures.

</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT: For web shipments to Oklahoma during a 60-day window from 2000-02-01 on company "pri" sites, report order count, shipping cost, and net profit for multi-warehouse orders with no returns. Joins are INNER (intersection) and SEMI/ANTI (existence filters). Aggregates are duplicate-insensitive (SUM, COUNT DISTINCT). Filter dependencies: multi-warehouse condition must be evaluated on the same order number but different warehouse; returns absence must be evaluated on the same order number.

BOTTLENECK_DIAGNOSIS: Scan-bound: two sequential scans of web_sales dominate (298ms main scan, 14.5ms EXISTS scan). Cardinality flow: 158K rows after dimension filters → 955 after multi-warehouse semi-join → 258 after returns anti-join → 1 after aggregation. Optimizer already pushes dimension filters into scans and decorrelates EXISTS/NOT EXISTS into hash semi/anti joins. Logical-tree cost percentages are misleading (main scan 81% exclusive, but EXISTS join adds 26ms).

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must output "order count", "total shipping cost", "total net profit".
- CTE_COLUMN_COMPLETENESS: Any CTE must include ws_order_number, ws_ext_ship_cost, ws_net_profit, ws_warehouse_sk, and join keys for downstream consumers.
- LITERAL_PRESERVATION: Must preserve date '2000-2-01', interval 60 DAY, state 'OK', company 'pri'.
- SEMANTIC_EQUIVALENCE: Result must be identical to original.
- REDUNDANT_SCAN_ELIMINATION: web_sales scanned twice; opportunity to consolidate.
- CROSS_CTE_PREDICATE_BLINDNESS: No CTEs exist currently, but creating CTEs may allow predicate pushdown into EXISTS subquery.

REGRESSION_WARNINGS:
1. materialize_cte (0.14x):
   CAUSE: Converted EXISTS to materialized CTE, forcing full scan and losing semi-join short-circuit.
   RULE: Do not convert EXISTS/NOT EXISTS used as filter into materialized CTE unless you can push filters into it.
2. single_pass_aggregation (0.59x on Q90):
   CAUSE: Split same-column OR into UNION branches, duplicating fact scans.
   RULE: Not applicable (no OR). But ensure consolidation doesn't introduce UNION branches.
3. prefetch_fact_join (0.50x on Q25):
   CAUSE: Baseline <50ms, CTE overhead dominated savings.
   RULE: Baseline is 366ms, so CTE overhead likely acceptable.

=== WORKER 1 BRIEFING ===

STRATEGY: single_pass_aggregation
TARGET_LOGICAL_TREE:
  filtered_dimensions -> candidate_orders -> multi_warehouse_flag -> final_aggregation
NODE_CONTRACTS:
  filtered_date:
    FROM: date_dim
    WHERE: d_date BETWEEN '2000-2-01' AND (CAST('2000-2-01' AS DATE) + INTERVAL 60 DAY)
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 61
    CONSUMERS: candidate_orders
  filtered_address:
    FROM: customer_address
    WHERE: ca_state = 'OK'
    OUTPUT: ca_address_sk
    EXPECTED_ROWS: 6,028
    CONSUMERS: candidate_orders
  filtered_website:
    FROM: web_site
    WHERE: web_company_name = 'pri'
    OUTPUT: web_site_sk
    EXPECTED_ROWS: 7
    CONSUMERS: candidate_orders
  candidate_orders:
    FROM: web_sales ws1
    JOIN: ws1.ws_ship_date_sk = filtered_date.d_date_sk
    JOIN: ws1.ws_ship_addr_sk = filtered_address.ca_address_sk
    JOIN: ws1.ws_web_site_sk = filtered_website.web_site_sk
    OUTPUT: ws_order_number, ws_ext_ship_cost, ws_net_profit, ws_warehouse_sk
    EXPECTED_ROWS: 158,000
    CONSUMERS: multi_warehouse_flag
  multi_warehouse_flag:
    FROM: candidate_orders co
    WHERE: EXISTS (SELECT 1 FROM candidate_orders co2 WHERE co2.ws_order_number = co.ws_order_number AND co2.ws_warehouse_sk <> co.ws_warehouse_sk)
    OUTPUT: ws_order_number, ws_ext_ship_cost, ws_net_profit
    EXPECTED_ROWS: 955
    CONSUMERS: final_aggregation
  final_aggregation:
    FROM: multi_warehouse_flag mwf
    WHERE: NOT EXISTS (SELECT 1 FROM web_returns wr WHERE wr.wr_order_number = mwf.ws_order_number)
    AGGREGATE: COUNT(DISTINCT ws_order_number), SUM(ws_ext_ship_cost), SUM(ws_net_profit)
    OUTPUT: "order count", "total shipping cost", "total net profit"
    EXPECTED_ROWS: 1
    CONSUMERS: output
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation
EXAMPLE_ADAPTATION:
- single_pass_aggregation (Q9): Apply consolidation of multiple scans into one CTE (candidate_orders) that pre-filters dimensions; compute multi-warehouse condition within same CTE using EXISTS (but note we still have a correlated subquery; could use window function). Ignore the CASE aggregation pattern.
- channel_bitmap_aggregation (Q88): Apply single scan with dimension filters; ignore the CASE labeling for channels.
HAZARD_FLAGS:
- The EXISTS in multi_warehouse_flag may still cause a second scan of candidate_orders (if not optimized). Consider using a window function (COUNT(DISTINCT ws_warehouse_sk) OVER (PARTITION BY ws_order_number)) to flag rows.

=== WORKER 2 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  filtered_dims -> fact_prejoin -> multi_warehouse_set -> no_returns_set -> final_join_aggregation
NODE_CONTRACTS:
  filtered_dims:
    FROM: date_dim, customer_address, web_site
    WHERE: d_date BETWEEN '2000-2-01' AND (CAST('2000-2-01' AS DATE) + INTERVAL 60 DAY) AND ca_state = 'OK' AND web_company_name = 'pri'
    JOIN: (none, cross join)
    OUTPUT: d_date_sk, ca_address_sk, web_site_sk
    EXPECTED_ROWS: 61 * 6,028 * 7 = ~2.5M (but will be reduced by fact join)
    CONSUMERS: fact_prejoin
  fact_prejoin:
    FROM: filtered_dims, web_sales ws1
    JOIN: ws1.ws_ship_date_sk = filtered_dims.d_date_sk AND ws1.ws_ship_addr_sk = filtered_dims.ca_address_sk AND ws1.ws_web_site_sk = filtered_dims.web_site_sk
    OUTPUT: ws_order_number, ws_ext_ship_cost, ws_net_profit, ws_warehouse_sk
    EXPECTED_ROWS: 158,000
    CONSUMERS: multi_warehouse_set, no_returns_set, final_join_aggregation
  multi_warehouse_set:
    FROM: fact_prejoin
    GROUP BY: ws_order_number
    HAVING: COUNT(DISTINCT ws_warehouse_sk) > 1
    OUTPUT: ws_order_number
    EXPECTED_ROWS: ~955 distinct orders
    CONSUMERS: final_join_aggregation
  no_returns_set:
    FROM: web_returns
    GROUP BY: wr_order_number
    OUTPUT: wr_order_number
    EXPECTED_ROWS: distinct returned orders (from 718K rows)
    CONSUMERS: final_join_aggregation
  final_join_aggregation:
    FROM: fact_prejoin fp
    JOIN: multi_warehouse_set mws ON fp.ws_order_number = mws.ws_order_number
    ANTI-JOIN: no_returns_set nrs ON fp.ws_order_number = nrs.wr_order_number
    AGGREGATE: COUNT(DISTINCT fp.ws_order_number), SUM(fp.ws_ext_ship_cost), SUM(fp.ws_net_profit)
    OUTPUT: "order count", "total shipping cost", "total net profit"
    EXPECTED_ROWS: 1
    CONSUMERS: output
EXAMPLES: prefetch_fact_join, dimension_cte_isolate
EXAMPLE_ADAPTATION:
- prefetch_fact_join (Q63): Apply chain: filter dimensions, pre-join with fact. Ignore the additional dimension joins after fact prejoin.
- dimension_cte_isolate (Q26): Pre-filter each dimension separately (date, address, website) then join with fact. Ignore the cross-join of dimension CTEs (do not cross-join).
HAZARD_FLAGS:
- Cross-joining dimension CTEs could cause Cartesian explosion (guard rule). Instead, join them sequentially with fact.
- The multi_warehouse_set computed from filtered fact_prejoin may miss orders where the second warehouse is outside the dimension filters (but EXISTS condition doesn't require dimension filters on ws2). This changes semantics! Must compute multi_warehouse_set from entire web_sales.

=== WORKER 3 BRIEFING ===

STRATEGY: exists_restructuring
TARGET_LOGICAL_TREE:
  multi_warehouse_orders -> returned_orders -> filtered_fact -> final_aggregation
NODE_CONTRACTS:
  multi_warehouse_orders:
    FROM: web_sales
    GROUP BY: ws_order_number
    HAVING: COUNT(DISTINCT ws_warehouse_sk) > 1
    OUTPUT: ws_order_number
    EXPECTED_ROWS: distinct orders with multiple warehouses (unknown, but from plan ~9,555 rows before semi-join)
    CONSUMERS: filtered_fact
  returned_orders:
    FROM: web_returns
    GROUP BY: wr_order_number
    OUTPUT: wr_order_number
    EXPECTED_ROWS: distinct returned orders (718K rows)
    CONSUMERS: filtered_fact
  filtered_fact:
    FROM: web_sales ws1, date_dim, customer_address, web_site, multi_warehouse_orders mwo, returned_orders ro
    JOIN: ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ws1.ws_web_site_sk = web_site_sk AND ws1.ws_order_number = mwo.ws_order_number
    ANTI-JOIN: ro ON ws1.ws_order_number = ro.wr_order_number
    WHERE: d_date BETWEEN '2000-2-01' AND (CAST('2000-2-01' AS DATE) + INTERVAL 60 DAY) AND ca_state = 'OK' AND web_company_name = 'pri'
    OUTPUT: ws_order_number, ws_ext_ship_cost, ws_net_profit
    EXPECTED_ROWS: 258
    CONSUMERS: final_aggregation
  final_aggregation:
    FROM: filtered_fact
    AGGREGATE: COUNT(DISTINCT ws_order_number), SUM(ws_ext_ship_cost), SUM(ws_net_profit)
    OUTPUT: "order count", "total shipping cost", "total net profit"
    EXPECTED_ROWS: 1
    CONSUMERS: output
EXAMPLES: decorrelate, materialize_cte
EXAMPLE_ADAPTATION:
- decorrelate (Q1): Convert correlated EXISTS to pre-materialized CTE (multi_warehouse_orders). Ignore the filter pushdown (we keep dimension filters in main join).
- materialize_cte (Q95): Use CTE for multi-warehouse detection. But do not materialize the EXISTS as a filter; instead, materialize the set of qualifying order numbers. Ignore the NOT EXISTS CTE pattern (we handle returns separately).
HAZARD_FLAGS:
- Computing multi_warehouse_orders from entire web_sales (86.4M rows) is expensive and may outweigh benefit.
- Must ensure anti-join with returned_orders is done after dimension filters to reduce rows.

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: dimension_push_into_exists
TARGET_LOGICAL_TREE:
  filtered_dimensions -> filtered_fact_with_multiwarehouse -> no_returns -> aggregate
NODE_CONTRACTS:
  filtered_dimensions:
    FROM: date_dim, customer_address, web_site
    WHERE: d_date BETWEEN '2000-2-01' AND (CAST('2000-2-01' AS DATE) + INTERVAL 60 DAY) AND ca_state = 'OK' AND web_company_name = 'pri'
    OUTPUT: d_date_sk, ca_address_sk, web_site_sk
    EXPECTED_ROWS: 61, 6,028, 7 (separate CTEs or combined)
    CONSUMERS: filtered_fact_with_multiwarehouse
  filtered_fact_with_multiwarehouse:
    FROM: web_sales ws1
    JOIN: filtered_dimensions ON ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ws1.ws_web_site_sk = web_site_sk
    WHERE: EXISTS (SELECT 1 FROM web_sales ws2 JOIN filtered_dimensions fd2 ON ws2.ws_ship_date_sk = fd2.d_date_sk AND ws2.ws_ship_addr_sk = fd2.ca_address_sk AND ws2.ws_web_site_sk = fd2.web_site_sk WHERE ws2.ws_order_number = ws1.ws_order_number AND ws2.ws_warehouse_sk <> ws1.ws_warehouse_sk)
    OUTPUT: ws_order_number, ws_ext_ship_cost, ws_net_profit
    EXPECTED_ROWS: 955
    CONSUMERS: no_returns
  no_returns:
    FROM: filtered_fact_with_multiwarehouse f
    WHERE: NOT EXISTS (SELECT 1 FROM web_returns wr WHERE wr.wr_order_number = f.ws_order_number)
    OUTPUT: ws_order_number, ws_ext_ship_cost, ws_net_profit
    EXPECTED_ROWS: 258
    CONSUMERS: aggregate
  aggregate:
    FROM: no_returns
    AGGREGATE: COUNT(DISTINCT ws_order_number), SUM(ws_ext_ship_cost), SUM(ws_net_profit)
    OUTPUT: "order count", "total shipping cost", "total net profit"
    EXPECTED_ROWS: 1
    CONSUMERS: output
EXAMPLES: pushdown, early_filter
EXAMPLE_ADAPTATION:
- pushdown (Q9): Push dimension filters into the EXISTS subquery (by joining ws2 with filtered_dimensions). This reduces the scan in EXISTS from entire web_sales to filtered set. Ignore the scalar subquery consolidation.
- early_filter (Q11): Filter dimension tables first, then use them in both main and subquery. Apply to both ws1 and ws2.
HAZARD_FLAGS:
- The EXISTS condition now requires ws2 to also satisfy dimension filters (date, address, website). This changes semantics because original EXISTS does not have those filters. However, since ws1 and ws2 share the same order number, and ws1 already satisfies dimension filters, does requiring ws2 to also satisfy them affect the result? Possibly yes: ws2 could be from a different date/address/website but same order number (unlikely in real data but possible). This rewrite is not semantically equivalent! Must adjust: we cannot push dimension filters into ws2. Therefore, this strategy is risky and may produce wrong results.
CONSTRAINT_OVERRIDE: SEMANTIC_EQUIVALENCE
OVERRIDE_REASONING: This rewrite changes the semantics of the EXISTS condition by adding dimension filters to ws2. In the original query, ws2 is not constrained by date, address, or website. However, in the TPC-DS schema, an order number is associated with a single sale date, ship address, and website? Need to check schema constraints. If ws_order_number determines ws_ship_date_sk, ws_ship_addr_sk, ws_web_site_sk (i.e., all rows for same order have same dimension keys), then pushing filters is safe. But we cannot assume that. Safer approach: do not push dimension filters into ws2; instead, compute multi-warehouse condition on the set of orders that pass dimension filters (as in Worker 2), but that also changes semantics. Exploration: we will attempt a hybrid where we compute multi-warehouse set from the filtered fact but also include any other warehouse rows for those orders (even if those rows don't satisfy dimension filters). This can be done by first getting filtered orders, then checking the full web_sales for multi-warehouse within those order numbers.
EXPLORATION_TYPE: novel_combination