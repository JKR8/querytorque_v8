**Part 1: Modified Logic Tree**

```
QUERY: (single statement)
├── [~] filtered_item: NEW shared dimension CTE
│   └── SCAN (item) with filter i_category='Home'
├── [~] filtered_dates: NEW shared dimension CTE  
│   └── SCAN (date_dim) with filter d_year IN (1998,1999)
├── [~] catalog_sales_details: NEW channel-specific CTE
│   ├── SCAN (catalog_sales)
│   ├── JOIN filtered_item ON cs_item_sk=i_item_sk
│   ├── JOIN filtered_dates ON cs_sold_date_sk=d_date_sk
│   └── LEFT JOIN catalog_returns ON (cs_order_number=cr_order_number AND cs_item_sk=cr_item_sk)
├── [~] store_sales_details: NEW channel-specific CTE
│   ├── SCAN (store_sales)
│   ├── JOIN filtered_item ON ss_item_sk=i_item_sk
│   ├── JOIN filtered_dates ON ss_sold_date_sk=d_date_sk
│   └── LEFT JOIN store_returns ON (ss_ticket_number=sr_ticket_number AND ss_item_sk=sr_item_sk)
├── [~] web_sales_details: NEW channel-specific CTE
│   ├── SCAN (web_sales)
│   ├── JOIN filtered_item ON ws_item_sk=i_item_sk
│   ├── JOIN filtered_dates ON ws_sold_date_sk=d_date_sk
│   └── LEFT JOIN web_returns ON (ws_order_number=wr_order_number AND ws_item_sk=wr_item_sk)
├── [-] all_sales: REMOVED original monolithic CTE
├── [+] union_all: NEW implicit union of three channel CTEs
├── [+] all_sales: NEW aggregated CTE (same name, different structure)
│   ├── FROM (catalog_sales_details UNION store_sales_details UNION web_sales_details)
│   └── GROUP BY d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id
└── [=] main_query: UNCHANGED (except now references new all_sales CTE)
```

**Part 2: Component Payload JSON**

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "shared_dimension_multi_channel",
      "description": "Extracted shared dimension filters (item category='Home' and date years 1998-1999) into separate CTEs reused across three channel branches",
      "applied_to": ["filtered_item", "filtered_dates"]
    },
    {
      "id": "R2", 
      "type": "union_cte_split",
      "description": "Split original monolithic all_sales CTE into three channel-specific detail CTEs followed by union and aggregation, eliminating redundant dimension scans",
      "applied_to": ["catalog_sales_details", "store_sales_details", "web_sales_details", "all_sales"]
    }
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_item": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_brand_id, i_class_id, i_category_id, i_manufact_id FROM item WHERE i_category = 'Home'",
        "interfaces": {
          "outputs": ["i_item_sk", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id"],
          "consumes": []
        }
      },
      "filtered_dates": {
        "type": "cte", 
        "change": "added",
        "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year IN (1998, 1999)",
        "interfaces": {
          "outputs": ["d_date_sk", "d_year"],
          "consumes": []
        }
      },
      "catalog_sales_details": {
        "type": "cte",
        "change": "added", 
        "sql": "SELECT d.d_year, i.i_brand_id, i.i_class_id, i.i_category_id, i.i_manufact_id, cs.cs_quantity - COALESCE(cr.cr_return_quantity, 0) AS sales_cnt, cs.cs_ext_sales_price - COALESCE(cr.cr_return_amount, 0.0) AS sales_amt FROM catalog_sales cs JOIN filtered_item i ON cs.cs_item_sk = i.i_item_sk JOIN filtered_dates d ON cs.cs_sold_date_sk = d.d_date_sk LEFT JOIN catalog_returns cr ON cs.cs_order_number = cr.cr_order_number AND cs.cs_item_sk = cr.cr_item_sk",
        "interfaces": {
          "outputs": ["d_year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "sales_cnt", "sales_amt"],
          "consumes": ["filtered_item", "filtered_dates"]
        }
      },
      "store_sales_details": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d.d_year, i.i_brand_id, i.i_class_id, i.i_category_id, i.i_manufact_id, ss.ss_quantity - COALESCE(sr.sr_return_quantity, 0) AS sales_cnt, ss.ss_ext_sales_price - COALESCE(sr.sr_return_amt, 0.0) AS sales_amt FROM store_sales ss JOIN filtered_item i ON ss.ss_item_sk = i.i_item_sk JOIN filtered_dates d ON ss.ss_sold_date_sk = d.d_date_sk LEFT JOIN store_returns sr ON ss.ss_ticket_number = sr.sr_ticket_number AND ss.ss_item_sk = sr.sr_item_sk",
        "interfaces": {
          "outputs": ["d_year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "sales_cnt", "sales_amt"],
          "consumes": ["filtered_item", "filtered_dates"]
        }
      },
      "web_sales_details": {
        "type": "cte", 
        "change": "added",
        "sql": "SELECT d.d_year, i.i_brand_id, i.i_class_id, i.i_category_id, i.i_manufact_id, ws.ws_quantity - COALESCE(wr.wr_return_quantity, 0) AS sales_cnt, ws.ws_ext_sales_price - COALESCE(wr.wr_return_amt, 0.0) AS sales_amt FROM web_sales ws JOIN filtered_item i ON ws.ws_item_sk = i.i_item_sk JOIN filtered_dates d ON ws.ws_sold_date_sk = d.d_date_sk LEFT JOIN web_returns wr ON ws.ws_order_number = wr.wr_order_number AND ws.ws_item_sk = wr.wr_item_sk",
        "interfaces": {
          "outputs": ["d_year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "sales_cnt", "sales_amt"],
          "consumes": ["filtered_item", "filtered_dates"]
        }
      },
      "all_sales": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id, SUM(sales_cnt) AS sales_cnt, SUM(sales_amt) AS sales_amt FROM (SELECT * FROM catalog_sales_details UNION ALL SELECT * FROM store_sales_details UNION ALL SELECT * FROM web_sales_details) union_all GROUP BY d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id",
        "interfaces": {
          "outputs": ["d_year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "sales_cnt", "sales_amt"],
          "consumes": ["catalog_sales_details", "store_sales_details", "web_sales_details"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified", 
        "sql": "SELECT prev_yr.d_year AS prev_year, curr_yr.d_year AS year, curr_yr.i_brand_id, curr_yr.i_class_id, curr_yr.i_category_id, curr_yr.i_manufact_id, prev_yr.sales_cnt AS prev_yr_cnt, curr_yr.sales_cnt AS curr_yr_cnt, curr_yr.sales_cnt - prev_yr.sales_cnt AS sales_cnt_diff, curr_yr.sales_amt - prev_yr.sales_amt AS sales_amt_diff FROM all_sales curr_yr, all_sales prev_yr WHERE curr_yr.i_brand_id = prev_yr.i_brand_id AND curr_yr.i_class_id = prev_yr.i_class_id AND curr_yr.i_category_id = prev_yr.i_category_id AND curr_yr.i_manufact_id = prev_yr.i_manufact_id AND curr_yr.d_year = 1999 AND prev_yr.d_year = 1998 AND CAST(curr_yr.sales_cnt AS DECIMAL(17,2)) / CAST(prev_yr.sales_cnt AS DECIMAL(17,2)) < 0.9 ORDER BY sales_cnt_diff, sales_amt_diff LIMIT 100",
        "interfaces": {
          "outputs": ["prev_year", "year", "i_brand_id", "i_class_id", "i_category_id", "i_manufact_id", "prev_yr_cnt", "curr_yr_cnt", "sales_cnt_diff", "sales_amt_diff"],
          "consumes": ["all_sales"]
        }
      }
    },
    "reconstruction_order": ["filtered_item", "filtered_dates", "catalog_sales_details", "store_sales_details", "web_sales_details", "all_sales", "main_query"],
    "assembly_template": "WITH filtered_item AS ({filtered_item}), filtered_dates AS ({filtered_dates}), catalog_sales_details AS ({catalog_sales_details}), store_sales_details AS ({store_sales_details}), web_sales_details AS ({web_sales_details}), all_sales AS ({all_sales}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Extracted shared dimension filters into reusable CTEs and split the monolithic union into separate channel CTEs, allowing DuckDB to push filters earlier and eliminate redundant dimension scans (3x item + 3x date_dim → 1x each). This matches the `shared_dimension_multi_channel` and `dimension_cte_isolate` patterns.

**Expected speedup:** ~1.9x (reducing 6 dimension scans to 2 while maintaining semantic equivalence and predicate pushdown boundaries at UNION ALL).