You are analyzing 5 failed optimization attempts to design a refined approach that reaches 2.0x speedup.

Your job: understand WHY each attempt fell short, identify unexplored optimization angles, and synthesize a NEW strategy that combines the best insights while avoiding repeated mistakes.

## Query: query_75
## Target: 2.0x speedup
## Dialect: duckdb

```sql
-- start query 75 in stream 0 using template query75.tpl
WITH all_sales AS (
 SELECT d_year
       ,i_brand_id
       ,i_class_id
       ,i_category_id
       ,i_manufact_id
       ,SUM(sales_cnt) AS sales_cnt
       ,SUM(sales_amt) AS sales_amt
 FROM (SELECT d_year
             ,i_brand_id
             ,i_class_id
             ,i_category_id
             ,i_manufact_id
             ,cs_quantity - COALESCE(cr_return_quantity,0) AS sales_cnt
             ,cs_ext_sales_price - COALESCE(cr_return_amount,0.0) AS sales_amt
       FROM catalog_sales JOIN item ON i_item_sk=cs_item_sk
                          JOIN date_dim ON d_date_sk=cs_sold_date_sk
                          LEFT JOIN catalog_returns ON (cs_order_number=cr_order_number 
                                                    AND cs_item_sk=cr_item_sk)
       WHERE i_category='Home'
       UNION
       SELECT d_year
             ,i_brand_id
             ,i_class_id
             ,i_category_id
             ,i_manufact_id
             ,ss_quantity - COALESCE(sr_return_quantity,0) AS sales_cnt
             ,ss_ext_sales_price - COALESCE(sr_return_amt,0.0) AS sales_amt
       FROM store_sales JOIN item ON i_item_sk=ss_item_sk
                        JOIN date_dim ON d_date_sk=ss_sold_date_sk
                        LEFT JOIN store_returns ON (ss_ticket_number=sr_ticket_number 
                                                AND ss_item_sk=sr_item_sk)
       WHERE i_category='Home'
       UNION
       SELECT d_year
             ,i_brand_id
             ,i_class_id
             ,i_category_id
             ,i_manufact_id
             ,ws_quantity - COALESCE(wr_return_quantity,0) AS sales_cnt
             ,ws_ext_sales_price - COALESCE(wr_return_amt,0.0) AS sales_amt
       FROM web_sales JOIN item ON i_item_sk=ws_item_sk
                      JOIN date_dim ON d_date_sk=ws_sold_date_sk
                      LEFT JOIN web_returns ON (ws_order_number=wr_order_number 
                                            AND ws_item_sk=wr_item_sk)
       WHERE i_category='Home') sales_detail
 GROUP BY d_year, i_brand_id, i_class_id, i_category_id, i_manufact_id)
 select prev_yr.d_year AS prev_year
                          ,curr_yr.d_year AS year
                          ,curr_yr.i_brand_id
                          ,curr_yr.i_class_id
                          ,curr_yr.i_category_id
                          ,curr_yr.i_manufact_id
                          ,prev_yr.sales_cnt AS prev_yr_cnt
                          ,curr_yr.sales_cnt AS curr_yr_cnt
                          ,curr_yr.sales_cnt-prev_yr.sales_cnt AS sales_cnt_diff
                          ,curr_yr.sales_amt-prev_yr.sales_amt AS sales_amt_diff
 FROM all_sales curr_yr, all_sales prev_yr
 WHERE curr_yr.i_brand_id=prev_yr.i_brand_id
   AND curr_yr.i_class_id=prev_yr.i_class_id
   AND curr_yr.i_category_id=prev_yr.i_category_id
   AND curr_yr.i_manufact_id=prev_yr.i_manufact_id
   AND curr_yr.d_year=1999
   AND prev_yr.d_year=1999-1
   AND CAST(curr_yr.sales_cnt AS DECIMAL(17,2))/CAST(prev_yr.sales_cnt AS DECIMAL(17,2))<0.9
 ORDER BY sales_cnt_diff,sales_amt_diff
 LIMIT 100;

-- end query 75 in stream 0 using template query75.tpl
```

## Previous Attempts

### Worker 1: conservative_pushdown_earlyfilter
- **Status**: ERROR (0.00x)
- **Error**: Value mismatch: rows differ between original and optimized
- **Transforms**: materialize_cte, union_cte_split
- **Examples used**: pushdown, early_filter, materialize_cte
- **Strategy hint**: Apply safe, proven optimizations by pushing filters into CTEs early, filtering dimension tables before joins, and materializing repeated patterns to avoid redundant computation.

```sql
WITH filtered_item AS (
  SELECT 
    i_item_sk,
    i_brand_id,
    i_class_id,
    i_category_id,
    i_manufact_id
  FROM item
  WHERE i_category = 'Home'
),
date_1999 AS (
  SELECT d_date_sk
  FROM date_dim
  WHERE d_year = 1999
),
date_1998 AS (
  SELECT d_date_sk
  FROM date_dim
  WHERE d_year = 1998
),
catalog_sales_1999 AS (
  SELECT
    i_brand_id,
    i_class_id,
    i_category_id,
    i_manufact_id,
    cs_quantity - COALESCE(cr_return_quantity, 0) AS sales_cnt,
    cs_ext_sales_price - COALESCE(cr_return_amount, 0.0) AS sales_amt
  FROM catalog_sales
  JOIN filtered_item ON i_item_sk = cs_item_sk
-- ... (truncated)
```

### Worker 2: moderate_date_dimension_isolation
- **Status**: ERROR (0.00x)
- **Error**: Value mismatch: rows differ between original and optimized
- **Transforms**: decorrelate, materialize_cte, union_cte_split
- **Examples used**: date_cte_isolate, dimension_cte_isolate, union_cte_split
- **Strategy hint**: Isolate date and dimension filtering into dedicated CTEs to enable better predicate pushdown, and split the UNION CTE by channel to optimize per-branch filtering.

```sql
WITH filtered_item AS (
  SELECT i_item_sk, i_brand_id, i_class_id, i_category_id, i_manufact_id
  FROM item
  WHERE i_category = 'Home'
),
filtered_dates_1999 AS (
  SELECT d_date_sk
  FROM date_dim
  WHERE d_year = 1999
),
filtered_dates_1998 AS (
  SELECT d_date_sk
  FROM date_dim
  WHERE d_year = 1998
),
catalog_sales_1999 AS (
  SELECT
    i_brand_id,
    i_class_id,
    i_category_id,
    i_manufact_id,
    SUM(cs_quantity - COALESCE(cr_return_quantity, 0)) AS sales_cnt,
    SUM(cs_ext_sales_price - COALESCE(cr_return_amount, 0.0)) AS sales_amt
  FROM catalog_sales
  JOIN filtered_item ON i_item_sk = cs_item_sk
  JOIN filtered_dates_1999 ON d_date_sk = cs_sold_date_sk
  LEFT JOIN catalog_returns ON (
    cs_order_number = cr_order_number AND cs_item_sk = cr_item_sk
  )
  GROUP BY i_brand_id, i_class_id, i_category_id, i_manufact_id
-- ... (truncated)
```

### Worker 3: aggressive_multi_cte_prefetch
- **Status**: WIN (1.10x)
- **Transforms**: none
- **Examples used**: prefetch_fact_join, multi_dimension_prefetch, single_pass_aggregation
- **Strategy hint**: Pre-filter and pre-join dimensions with facts in separate CTEs, then consolidate aggregation passes to minimize intermediate data and join costs.

```sql
-- start query 75 in stream 0 using template query75.tpl
WITH all_sales AS (
 SELECT d_year
       ,i_brand_id
       ,i_class_id
       ,i_category_id
       ,i_manufact_id
       ,SUM(sales_cnt) AS sales_cnt
       ,SUM(sales_amt) AS sales_amt
 FROM (SELECT d_year
             ,i_brand_id
             ,i_class_id
             ,i_category_id
             ,i_manufact_id
             ,cs_quantity - COALESCE(cr_return_quantity,0) AS sales_cnt
             ,cs_ext_sales_price - COALESCE(cr_return_amount,0.0) AS sales_amt
       FROM catalog_sales JOIN item ON i_item_sk=cs_item_sk
                          JOIN date_dim ON d_date_sk=cs_sold_date_sk
                          LEFT JOIN catalog_returns ON (cs_order_number=cr_order_number 
                                                    AND cs_item_sk=cr_item_sk)
       WHERE i_category='Home'
       UNION
       SELECT d_year
             ,i_brand_id
             ,i_class_id
             ,i_category_id
             ,i_manufact_id
             ,ss_quantity - COALESCE(sr_return_quantity,0) AS sales_cnt
             ,ss_ext_sales_price - COALESCE(sr_return_amt,0.0) AS sales_amt
       FROM store_sales JOIN item ON i_item_sk=ss_item_sk
-- ... (truncated)
```

### Worker 4: novel_structural_transforms
- **Status**: ERROR (0.00x)
- **Error**: Value mismatch: rows differ between original and optimized
- **Transforms**: materialize_cte, union_cte_split
- **Examples used**: intersect_to_exists, or_to_union, composite_decorrelate_union
- **Strategy hint**: Apply structural query transformations—convert patterns to EXISTS, split OR conditions into UNION ALL, and decorrelate complex subqueries—to enable alternative join planning.

```sql
WITH filtered_dates AS (
  SELECT d_date_sk, d_year
  FROM date_dim
  WHERE d_year IN (1998, 1999)
),
catalog_sales_filtered AS (
  SELECT
    d.d_year,
    i.i_brand_id,
    i.i_class_id,
    i.i_category_id,
    i.i_manufact_id,
    cs.cs_quantity - COALESCE(cr.cr_return_quantity, 0) AS sales_cnt,
    cs.cs_ext_sales_price - COALESCE(cr.cr_return_amount, 0.0) AS sales_amt
  FROM catalog_sales cs
  JOIN item i ON i.i_item_sk = cs.cs_item_sk
  JOIN filtered_dates d ON d.d_date_sk = cs.cs_sold_date_sk
  LEFT JOIN catalog_returns cr ON cs.cs_order_number = cr.cr_order_number 
    AND cs.cs_item_sk = cr.cr_item_sk
  WHERE i.i_category = 'Home'
),
store_sales_filtered AS (
  SELECT
    d.d_year,
    i.i_brand_id,
    i.i_class_id,
    i.i_category_id,
    i.i_manufact_id,
    ss.ss_quantity - COALESCE(sr.sr_return_quantity, 0) AS sales_cnt,
    ss.ss_ext_sales_price - COALESCE(sr.sr_return_amt, 0.0) AS sales_amt
-- ... (truncated)
```

### Worker 1: snipe_1
- **Status**: ERROR (0.00x)
- **Transforms**: materialize_cte, union_cte_split
- **Examples used**: early_filter, pushdown, union_cte_split
- **Strategy hint**: Isolate filtered dimensions (item, date_dim) into CTEs, then join in each channel's subquery exactly as in the original—do NOT aggregate before the UNION. Use UNION ALL, and ensure year filtering is applied only in the outermost WHERE clause (for prev_yr and curr_yr).

```sql
WITH filtered_item AS (
  SELECT
    i_item_sk,
    i_brand_id,
    i_class_id,
    i_category_id,
    i_manufact_id
  FROM item
  WHERE i_category = 'Home'
),
all_sales AS (
  SELECT
    d_year,
    i_brand_id,
    i_class_id,
    i_category_id,
    i_manufact_id,
    SUM(sales_cnt) AS sales_cnt,
    SUM(sales_amt) AS sales_amt
  FROM (
    SELECT
      d.d_year,
      i.i_brand_id,
      i.i_class_id,
      i.i_category_id,
      i.i_manufact_id,
      cs.cs_quantity - COALESCE(cr.cr_return_quantity, 0) AS sales_cnt,
      cs.cs_ext_sales_price - COALESCE(cr.cr_return_amount, 0.0) AS sales_amt
    FROM catalog_sales cs
    JOIN filtered_item i ON i.i_item_sk = cs.cs_item_sk
-- ... (truncated)
```

## DAG Structure & Bottlenecks

| Node | Role | Cost % |
|------|------|-------:|
| all_sales |  | 0.0% |
| main_query |  | 0.0% |

## Available Examples (Full Catalog)

- **composite_decorrelate_union** (2.42xx) — Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT
- **date_cte_isolate** (4.00xx) — Extract date filtering into a separate CTE to enable predicate pushdown and redu
- **decorrelate** (2.92xx) — Convert correlated subquery to separate CTE with GROUP BY, then JOIN
- **deferred_window_aggregation** (1.36xx) — When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joi
- **dimension_cte_isolate** (1.93xx) — Pre-filter ALL dimension tables into CTEs before joining with fact table, not ju
- **early_filter** (4.00xx) — Filter dimension tables FIRST, then join to fact tables to reduce expensive join
- **intersect_to_exists** (1.83xx) — Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join pl
- **materialize_cte** (1.37xx) — Extract repeated subquery patterns into a CTE to avoid recomputation
- **multi_date_range_cte** (2.35xx) — When query uses multiple date_dim aliases with different filters (d1, d2, d3), c
- **multi_dimension_prefetch** (2.71xx) — Pre-filter multiple dimension tables (date + store) into separate CTEs before jo
- **or_to_union** (3.17xx) — Split OR conditions on different columns into UNION ALL branches for better inde
- **prefetch_fact_join** (3.77xx) — Pre-filter dimension table into CTE, then pre-join with fact table in second CTE
- **pushdown** (2.11xx) — Push filters from outer query into CTEs/subqueries to reduce intermediate result
- **shared_dimension_multi_channel** (1.30xx) — Extract shared dimension filters (date, item, promotion) into CTEs when multiple
- **single_pass_aggregation** (4.47xx) — Consolidate multiple subqueries scanning the same table into a single CTE with c
- **union_cte_split** (1.36xx) — Split a generic UNION ALL CTE into specialized CTEs when the main query filters 

## Your Task

Analyze the failed attempts and design a refined approach:

1. **Failure Analysis**: Why did all attempts fall short? Be specific about mechanisms.
2. **Common Patterns**: What did multiple workers try unsuccessfully?
3. **Unexplored Space**: What optimization angles were missed entirely?
4. **Refined Strategy**: Synthesize a NEW approach combining best insights.

### Output Format (follow EXACTLY)

```
FAILURE_ANALYSIS:
<Why all workers fell short — be specific about mechanisms>

UNEXPLORED_OPPORTUNITIES:
<What optimization approaches haven't been tried>

REFINED_STRATEGY:
<Concrete optimization approach for next attempt>

EXAMPLES: <ex1>, <ex2>, <ex3>
HINT: <specific guidance for the refined attempt>
```