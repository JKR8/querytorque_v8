## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]  Cost: 100%  Rows: ~4.5K  — Restructured to follow target logical tree with CTEs
    ├── CTE store_filtered  [+]
    ├── CTE fact_store_join  [+]
    ├── CTE date_filtered  [+]
    ├── CTE fact_date_join  [+]
    ├── CTE hh_filtered  [+]
    ├── CTE fact_hh_join  [+]
    ├── CTE aggregation  [+]
    ├── CTE customer_join  [+]
    ├── SORT (c_last_name ASC, c_first_name ASC, c_salutation ASC, c_preferred_cust_flag DESC, ss_ticket_number ASC)
    └── OUTPUT (c_last_name, c_first_name, c_salutation, c_preferred_cust_flag, ss_ticket_number, cnt)
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb_v1.4.3",
  "rewrite_rules": [
    {"id": "R1", "type": "early_dimension_filtering", "description": "Pushed store, date, and household_demographics filters into separate CTEs to isolate predicate evaluation", "applied_to": ["store_filtered", "date_filtered", "hh_filtered"]},
    {"id": "R2", "type": "staged_join_sequence", "description": "Followed target logical tree: store → store_sales → date → household_demographics → aggregation → customer", "applied_to": ["fact_store_join", "fact_date_join", "fact_hh_join", "customer_join"]},
    {"id": "R3", "type": "preserve_semantic_equivalence", "description": "Kept all original filters, defensive CASE WHEN, and exact output schema/ordering", "applied_to": ["all"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "store_filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT s_store_sk FROM store WHERE s_county IN ('Ziebach County','Daviess County','Walker County','Richland County','Barrow County','Franklin Parish','Williamson County','Luce County')",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "fact_store_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_sold_date_sk, ss_store_sk, ss_hdemo_sk, ss_ticket_number, ss_customer_sk FROM store_sales INNER JOIN store_filtered ON store_sales.ss_store_sk = store_filtered.s_store_sk",
        "interfaces": {"outputs": ["ss_sold_date_sk", "ss_store_sk", "ss_hdemo_sk", "ss_ticket_number", "ss_customer_sk"], "consumes": ["store_filtered"]}
      },
      "date_filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE (d_dom BETWEEN 1 AND 3 OR d_dom BETWEEN 25 AND 28) AND d_year IN (1998, 1999, 2000)",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "fact_date_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT fact_store_join.ss_sold_date_sk, fact_store_join.ss_store_sk, fact_store_join.ss_hdemo_sk, fact_store_join.ss_ticket_number, fact_store_join.ss_customer_sk FROM fact_store_join INNER JOIN date_filtered ON fact_store_join.ss_sold_date_sk = date_filtered.d_date_sk",
        "interfaces": {"outputs": ["ss_sold_date_sk", "ss_store_sk", "ss_hdemo_sk", "ss_ticket_number", "ss_customer_sk"], "consumes": ["fact_store_join", "date_filtered"]}
      },
      "hh_filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE (hd_buy_potential = '1001-5000' OR hd_buy_potential = '0-500') AND hd_vehicle_count > 0 AND (CASE WHEN hd_vehicle_count > 0 THEN hd_dep_count / hd_vehicle_count ELSE NULL END) > 1.2",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "fact_hh_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT fact_date_join.ss_ticket_number, fact_date_join.ss_customer_sk FROM fact_date_join INNER JOIN hh_filtered ON fact_date_join.ss_hdemo_sk = hh_filtered.hd_demo_sk",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk"], "consumes": ["fact_date_join", "hh_filtered"]}
      },
      "aggregation": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_ticket_number, ss_customer_sk, COUNT(*) AS cnt FROM fact_hh_join GROUP BY ss_ticket_number, ss_customer_sk",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "cnt"], "consumes": ["fact_hh_join"]}
      },
      "customer_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_last_name, c_first_name, c_salutation, c_preferred_cust_flag, aggregation.ss_ticket_number, aggregation.cnt FROM aggregation INNER JOIN customer ON aggregation.ss_customer_sk = customer.c_customer_sk WHERE aggregation.cnt BETWEEN 15 AND 20",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "c_salutation", "c_preferred_cust_flag", "ss_ticket_number", "cnt"], "consumes": ["aggregation"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, c_salutation, c_preferred_cust_flag, ss_ticket_number, cnt FROM customer_join ORDER BY c_last_name, c_first_name, c_salutation, c_preferred_cust_flag DESC, ss_ticket_number",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "c_salutation", "c_preferred_cust_flag", "ss_ticket_number", "cnt"], "consumes": ["customer_join"]}
      }
    },
    "reconstruction_order": ["store_filtered", "fact_store_join", "date_filtered", "fact_date_join", "hh_filtered", "fact_hh_join", "aggregation", "customer_join", "main_query"],
    "assembly_template": "WITH store_filtered AS ({store_filtered}), fact_store_join AS ({fact_store_join}), date_filtered AS ({date_filtered}), fact_date_join AS ({fact_date_join}), hh_filtered AS ({hh_filtered}), fact_hh_join AS ({fact_hh_join}), aggregation AS ({aggregation}), customer_join AS ({customer_join}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured the flat multi-join query into a staged CTE pipeline that isolates dimension filtering (store, date, household_demographics) before joining with facts, exactly following the target logical tree. This preserves semantic equivalence while enabling predicate pushdown and column pruning.

**Expected speedup**: Moderate (1.2-1.5x) due to early filtering of small dimension tables and reduced intermediate result sizes, while avoiding the known regression pitfalls (no OR→UNION splitting, no cross-joining dimension CTEs).