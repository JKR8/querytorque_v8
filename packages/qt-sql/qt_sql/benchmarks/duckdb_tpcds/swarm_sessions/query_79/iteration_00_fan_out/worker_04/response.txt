### Part 1: Modified Logic Tree

```
QUERY:
└── [MAIN] main_query  [~]  — Restructured into CTE pipeline with OR-to-UNION decomposition and pre-filtered dimensions.
    ├── WITH date_cte  [+]
    │   └── SCAN date_dim (d_dow=1, d_year IN (1998,1999,2000))
    ├── WITH store_cte  [+]
    │   └── SCAN store (s_number_employees BETWEEN 200 AND 295)
    ├── WITH hd_cte_dep  [+]
    │   └── SCAN household_demographics (hd_dep_count=5)
    ├── WITH hd_cte_vehicle  [+]
    │   └── SCAN household_demographics (hd_vehicle_count>4)
    ├── WITH branch1  [+]
    │   ├── JOIN store_sales → date_cte (ss_sold_date_sk = d_date_sk)
    │   ├── JOIN store_sales → store_cte (ss_store_sk = s_store_sk)
    │   └── JOIN store_sales → hd_cte_dep (ss_hdemo_sk = hd_demo_sk)
    ├── WITH branch2  [+]
    │   ├── JOIN store_sales → date_cte (ss_sold_date_sk = d_date_sk)
    │   ├── JOIN store_sales → store_cte (ss_store_sk = s_store_sk)
    │   └── JOIN store_sales → hd_cte_vehicle (ss_hdemo_sk = hd_demo_sk)
    ├── WITH union_all  [+]
    │   └── UNION ALL (branch1, branch2)
    ├── WITH aggregate  [+]
    │   └── AGG (GROUP BY ss_ticket_number, ss_customer_sk, ss_addr_sk, s_city; SUM(ss_coupon_amt), SUM(ss_net_profit))
    ├── JOIN aggregate → customer (ss_customer_sk = c_customer_sk)  [=]
    ├── SORT (c_last_name, c_first_name, substr(s_city,1,30), profit)  [=]
    └── OUTPUT (c_last_name, c_first_name, substr(s_city,1,30), ss_ticket_number, amt, profit)  [=]
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "or_to_union", "description": "Split OR condition on hd_dep_count=5 OR hd_vehicle_count>4 into separate branches with pre‑filtered CTEs, enabling predicate pushdown per branch.", "applied_to": ["hd_cte_dep", "hd_cte_vehicle", "branch1", "branch2", "union_all"]},
    {"id": "R2", "type": "dimension_cte_isolate", "description": "Pre‑filter date_dim, store, and household_demographics into lightweight CTEs before joining with store_sales, reducing hash‑table sizes and enabling early fact‑table pruning.", "applied_to": ["date_cte", "store_cte", "hd_cte_dep", "hd_cte_vehicle"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_dow = 1 AND d_year IN (1998, 1999, 2000)",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s_store_sk, s_city FROM store WHERE s_number_employees BETWEEN 200 AND 295",
        "interfaces": {"outputs": ["s_store_sk", "s_city"], "consumes": []}
      },
      "hd_cte_dep": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE hd_dep_count = 5",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "hd_cte_vehicle": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE hd_vehicle_count > 4",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "branch1": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_ticket_number, ss_customer_sk, ss_addr_sk, store_cte.s_city, ss_coupon_amt, ss_net_profit FROM store_sales JOIN date_cte ON store_sales.ss_sold_date_sk = date_cte.d_date_sk JOIN store_cte ON store_sales.ss_store_sk = store_cte.s_store_sk JOIN hd_cte_dep ON store_sales.ss_hdemo_sk = hd_cte_dep.hd_demo_sk",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "ss_addr_sk", "s_city", "ss_coupon_amt", "ss_net_profit"], "consumes": ["date_cte", "store_cte", "hd_cte_dep"]}
      },
      "branch2": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_ticket_number, ss_customer_sk, ss_addr_sk, store_cte.s_city, ss_coupon_amt, ss_net_profit FROM store_sales JOIN date_cte ON store_sales.ss_sold_date_sk = date_cte.d_date_sk JOIN store_cte ON store_sales.ss_store_sk = store_cte.s_store_sk JOIN hd_cte_vehicle ON store_sales.ss_hdemo_sk = hd_cte_vehicle.hd_demo_sk",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "ss_addr_sk", "s_city", "ss_coupon_amt", "ss_net_profit"], "consumes": ["date_cte", "store_cte", "hd_cte_vehicle"]}
      },
      "union_all": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_ticket_number, ss_customer_sk, ss_addr_sk, s_city, ss_coupon_amt, ss_net_profit FROM branch1 UNION ALL SELECT ss_ticket_number, ss_customer_sk, ss_addr_sk, s_city, ss_coupon_amt, ss_net_profit FROM branch2",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "ss_addr_sk", "s_city", "ss_coupon_amt", "ss_net_profit"], "consumes": ["branch1", "branch2"]}
      },
      "aggregate": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_ticket_number, ss_customer_sk, s_city, SUM(ss_coupon_amt) AS amt, SUM(ss_net_profit) AS profit FROM union_all GROUP BY ss_ticket_number, ss_customer_sk, ss_addr_sk, s_city",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "s_city", "amt", "profit"], "consumes": ["union_all"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, substr(s_city, 1, 30) AS city_substr, ss_ticket_number, amt, profit FROM aggregate JOIN customer ON aggregate.ss_customer_sk = customer.c_customer_sk ORDER BY c_last_name, c_first_name, substr(s_city, 1, 30), profit LIMIT 100",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "city_substr", "ss_ticket_number", "amt", "profit"], "consumes": ["aggregate"]}
      }
    },
    "reconstruction_order": ["date_cte", "store_cte", "hd_cte_dep", "hd_cte_vehicle", "branch1", "branch2", "union_all", "aggregate", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), store_cte AS ({store_cte}), hd_cte_dep AS ({hd_cte_dep}), hd_cte_vehicle AS ({hd_cte_vehicle}), branch1 AS ({branch1}), branch2 AS ({branch2}), union_all AS ({union_all}), aggregate AS ({aggregate}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Split the OR condition on household_demographics into two separate branches (hd_dep_count=5, hd_vehicle_count>4) with pre‑filtered dimension CTEs, enabling DuckDB to push each filter directly into its branch and build smaller hash tables. This avoids the optimizer’s blind spot where only one OR‑clause filter is applied.

**Expected speedup**: 1.8–2.5× (based on observed speedups for OR‑to‑UNION on different‑column ORs and dimension‑pre‑filtering patterns).