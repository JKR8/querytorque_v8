### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]
    ├── CTE: date_subq  [+]
    │   └── SCAN date_dim (filtered: d_dow=1, d_year in (1998,1999,2000))
    ├── CTE: store_subq  [+]
    │   └── SCAN store (filtered: s_number_employees BETWEEN 200 AND 295)
    ├── CTE: hd_subq  [+]
    │   └── SCAN household_demographics (filtered: hd_dep_count=5 OR hd_vehicle_count>4)
    ├── CTE: fact_join  [+]
    │   ├── SCAN store_sales
    │   ├── JOIN date_subq ON ss_sold_date_sk = d_date_sk
    │   ├── JOIN store_subq ON ss_store_sk = s_store_sk
    │   └── JOIN hd_subq ON ss_hdemo_sk = hd_demo_sk
    ├── CTE: aggregate  [~] (now sources from fact_join instead of raw joins)
    │   └── AGG (GROUP BY ss_ticket_number, ss_customer_sk, ss_addr_sk, s_city)
    ├── JOIN (ss_customer_sk = c_customer_sk)  [=]
    ├── SORT (c_last_name ASC, c_first_name ASC, SUBSTRING(s_city, 1, 30) ASC, profit ASC)  [=]
    └── OUTPUT (c_last_name, c_first_name, SUBSTRING(s_city, 1, 30), ss_ticket_number, amt, profit)  [=]
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter", "description": "Push dimension filters into isolated CTEs before fact table joins, enabling predicate pushdown and avoiding Cartesian explosion.", "applied_to": ["date_subq", "store_subq", "hd_subq", "fact_join"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_subq": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_dow = 1 AND d_year IN (1998, 1999, 2000)",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_subq": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT s_store_sk, s_city FROM store WHERE s_number_employees BETWEEN 200 AND 295",
        "interfaces": {"outputs": ["s_store_sk", "s_city"], "consumes": []}
      },
      "hd_subq": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT hd_demo_sk FROM household_demographics WHERE hd_dep_count = 5 OR hd_vehicle_count > 4",
        "interfaces": {"outputs": ["hd_demo_sk"], "consumes": []}
      },
      "fact_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss.ss_ticket_number, ss.ss_customer_sk, ss.ss_addr_sk, st.s_city, ss.ss_coupon_amt, ss.ss_net_profit FROM store_sales ss INNER JOIN date_subq dt ON ss.ss_sold_date_sk = dt.d_date_sk INNER JOIN store_subq st ON ss.ss_store_sk = st.s_store_sk INNER JOIN hd_subq hd ON ss.ss_hdemo_sk = hd.hd_demo_sk",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "ss_addr_sk", "s_city", "ss_coupon_amt", "ss_net_profit"], "consumes": ["date_subq", "store_subq", "hd_subq"]}
      },
      "aggregate": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_ticket_number, ss_customer_sk, s_city, SUM(ss_coupon_amt) AS amt, SUM(ss_net_profit) AS profit FROM fact_join GROUP BY ss_ticket_number, ss_customer_sk, ss_addr_sk, s_city",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "s_city", "amt", "profit"], "consumes": ["fact_join"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, SUBSTRING(s_city, 1, 30), ss_ticket_number, amt, profit FROM aggregate ms INNER JOIN customer ON ss_customer_sk = c_customer_sk ORDER BY c_last_name, c_first_name, SUBSTRING(s_city, 1, 30), profit LIMIT 100",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "substr(s_city,1,30)", "ss_ticket_number", "amt", "profit"], "consumes": ["aggregate"]}
      }
    },
    "reconstruction_order": ["date_subq", "store_subq", "hd_subq", "fact_join", "aggregate", "main_query"],
    "assembly_template": "WITH date_subq AS ({date_subq}), store_subq AS ({store_subq}), hd_subq AS ({hd_subq}), fact_join AS ({fact_join}), aggregate AS ({aggregate}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Isolated dimension filters into separate CTEs, then joined them individually with the fact table. This allows predicate pushdown into each dimension scan and avoids the Cartesian product risk of cross-joining dimensions.

**Expected speedup**: 1.5–2.0x from reduced fact table scanning and early filtering.