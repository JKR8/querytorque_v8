### Part 1: Modified Logic Tree

```
QUERY:
└── [MAIN] main_query  [~]
    ├── [CTE] branch1  [+]
    │   ├── SCAN (store_sales, date_dim, store, household_demographics)
    │   ├── JOIN (store_sales.ss_sold_date_sk = date_dim.d_date_sk)
    │   ├── JOIN (store_sales.ss_store_sk = store.s_store_sk)
    │   ├── JOIN (store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk)
    │   ├── FILTER (date_dim.d_dow=1, d_year IN (1998,1999,2000), store.s_number_employees BETWEEN 200 AND 295, household_demographics.hd_dep_count=5)
    │   ├── AGG (GROUP BY ss_ticket_number, ss_customer_sk, ss_addr_sk, store.s_city)
    │   └── OUTPUT (ss_ticket_number, ss_customer_sk, s_city, amt, profit)
    ├── [CTE] branch2  [+]
    │   ├── SCAN (store_sales, date_dim, store, household_demographics)
    │   ├── JOIN (store_sales.ss_sold_date_sk = date_dim.d_date_sk)
    │   ├── JOIN (store_sales.ss_store_sk = store.s_store_sk)
    │   ├── JOIN (store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk)
    │   ├── FILTER (date_dim.d_dow=1, d_year IN (1998,1999,2000), store.s_number_employees BETWEEN 200 AND 295, household_demographics.hd_vehicle_count>4)
    │   ├── AGG (GROUP BY ss_ticket_number, ss_customer_sk, ss_addr_sk, store.s_city)
    │   └── OUTPUT (ss_ticket_number, ss_customer_sk, s_city, amt, profit)
    ├── [CTE] union_all  [+]
    │   └── UNION_ALL (branch1, branch2)
    ├── [CTE] join_customer  [+]
    │   ├── SCAN (union_all AS ms, customer)
    │   ├── JOIN (ms.ss_customer_sk = customer.c_customer_sk)
    │   └── OUTPUT (c_last_name, c_first_name, substr(ms.s_city,1,30), ss_ticket_number, amt, profit)
    └── ORDER_LIMIT [~]
        ├── SORT (c_last_name ASC, c_first_name ASC, substr(s_city,1,30) ASC, profit ASC)
        └── LIMIT 100
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "or_to_union", "description": "Split OR condition (hd_dep_count=5 OR hd_vehicle_count>4) into separate UNION ALL branches", "applied_to": ["branch1", "branch2", "union_all"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "branch1": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT store_sales.ss_ticket_number, store_sales.ss_customer_sk, store.s_city, SUM(store_sales.ss_coupon_amt) AS amt, SUM(store_sales.ss_net_profit) AS profit FROM store_sales INNER JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk INNER JOIN store ON store_sales.ss_store_sk = store.s_store_sk INNER JOIN household_demographics ON store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk WHERE date_dim.d_dow = 1 AND date_dim.d_year IN (1998, 1999, 2000) AND store.s_number_employees BETWEEN 200 AND 295 AND household_demographics.hd_dep_count = 5 GROUP BY store_sales.ss_ticket_number, store_sales.ss_customer_sk, store_sales.ss_addr_sk, store.s_city",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "s_city", "amt", "profit"], "consumes": []}
      },
      "branch2": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT store_sales.ss_ticket_number, store_sales.ss_customer_sk, store.s_city, SUM(store_sales.ss_coupon_amt) AS amt, SUM(store_sales.ss_net_profit) AS profit FROM store_sales INNER JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk INNER JOIN store ON store_sales.ss_store_sk = store.s_store_sk INNER JOIN household_demographics ON store_sales.ss_hdemo_sk = household_demographics.hd_demo_sk WHERE date_dim.d_dow = 1 AND date_dim.d_year IN (1998, 1999, 2000) AND store.s_number_employees BETWEEN 200 AND 295 AND household_demographics.hd_vehicle_count > 4 GROUP BY store_sales.ss_ticket_number, store_sales.ss_customer_sk, store_sales.ss_addr_sk, store.s_city",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "s_city", "amt", "profit"], "consumes": []}
      },
      "union_all": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_ticket_number, ss_customer_sk, s_city, amt, profit FROM branch1 UNION ALL SELECT ss_ticket_number, ss_customer_sk, s_city, amt, profit FROM branch2",
        "interfaces": {"outputs": ["ss_ticket_number", "ss_customer_sk", "s_city", "amt", "profit"], "consumes": ["branch1", "branch2"]}
      },
      "join_customer": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT customer.c_last_name, customer.c_first_name, substr(union_all.s_city, 1, 30) AS s_city, union_all.ss_ticket_number, union_all.amt, union_all.profit FROM union_all INNER JOIN customer ON union_all.ss_customer_sk = customer.c_customer_sk",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "s_city", "ss_ticket_number", "amt", "profit"], "consumes": ["union_all"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_last_name, c_first_name, s_city, ss_ticket_number, amt, profit FROM join_customer ORDER BY c_last_name ASC, c_first_name ASC, s_city ASC, profit ASC LIMIT 100",
        "interfaces": {"outputs": ["c_last_name", "c_first_name", "s_city", "ss_ticket_number", "amt", "profit"], "consumes": ["join_customer"]}
      }
    },
    "reconstruction_order": ["branch1", "branch2", "union_all", "join_customer", "main_query"],
    "assembly_template": "WITH branch1 AS ({branch1}), branch2 AS ({branch2}), union_all AS ({union_all}), join_customer AS ({join_customer}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Split the OR condition on different household_demographics columns into separate UNION ALL branches, allowing each branch to use focused filters and potentially different access paths. The structure follows the exact logical tree with dimension joins inside each branch to avoid Cartesian explosion.

**Expected speedup**: ~2x (each branch scans half the fact rows with focused filters, and DuckDB can push dimension filters into each branch scan).