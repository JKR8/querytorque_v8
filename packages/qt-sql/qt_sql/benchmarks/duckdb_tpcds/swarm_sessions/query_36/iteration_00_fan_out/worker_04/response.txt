### Part 1: Modified Logic Tree

```
QUERY: (CTE pipeline)
└── [~] main_query
    ├── [+] filtered_date (CTE)
    ├── [+] filtered_store (CTE)
    ├── [+] fact_preagg (CTE)
    ├── [+] item_join (CTE)
    ├── [+] level1_agg (CTE)
    ├── [+] level2_agg (CTE)
    ├── [+] level3_agg (CTE)
    ├── [+] union_all (CTE)
    ├── [+] window_rank (CTE)
    └── [=] final_sort
```

**Changes:**
- Restructured original ROLLUP query into explicit UNION ALL of three hierarchy levels via CTEs
- Pre-filtered date and store dimensions into separate CTEs before joining with fact table
- Pre-aggregated store_sales by item key before joining with item dimension (single-pass aggregation)
- Applied explicit window ranking per hierarchy level instead of ROLLUP-dependent grouping

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "prefetch_fact_join", "description": "Filter dimensions into CTEs before fact join to reduce early scan size", "applied_to": ["filtered_date", "filtered_store", "fact_preagg"]},
    {"id": "R2", "type": "single_pass_aggregation", "description": "Pre-aggregate fact table by item key before dimensional joins", "applied_to": ["fact_preagg"]},
    {"id": "R3", "type": "rollup_to_union_windowing", "description": "Replace ROLLUP with explicit UNION ALL of three hierarchy levels", "applied_to": ["level1_agg", "level2_agg", "level3_agg", "union_all", "window_rank"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_date": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "filtered_store": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk FROM store WHERE s_state IN ('SD','TN','GA','SC','MO','AL','MI','OH')",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "fact_preagg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_item_sk, SUM(ss_net_profit) AS profit_sum, SUM(ss_ext_sales_price) AS sales_sum FROM store_sales INNER JOIN filtered_date ON ss_sold_date_sk = d_date_sk INNER JOIN filtered_store ON ss_store_sk = s_store_sk GROUP BY ss_item_sk",
        "interfaces": {"outputs": ["ss_item_sk", "profit_sum", "sales_sum"], "consumes": ["filtered_date", "filtered_store"]}
      },
      "item_join": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i.i_category, i.i_class, fp.profit_sum, fp.sales_sum FROM fact_preagg fp INNER JOIN item i ON i.i_item_sk = fp.ss_item_sk",
        "interfaces": {"outputs": ["i_category", "i_class", "profit_sum", "sales_sum"], "consumes": ["fact_preagg"]}
      },
      "level1_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, i_class, 0 AS lochierarchy, SUM(profit_sum) AS sum_net_profit, SUM(sales_sum) AS sum_sales_price FROM item_join GROUP BY i_category, i_class",
        "interfaces": {"outputs": ["i_category", "i_class", "lochierarchy", "sum_net_profit", "sum_sales_price"], "consumes": ["item_join"]}
      },
      "level2_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_category, NULL AS i_class, 1 AS lochierarchy, SUM(profit_sum) AS sum_net_profit, SUM(sales_sum) AS sum_sales_price FROM item_join GROUP BY i_category",
        "interfaces": {"outputs": ["i_category", "i_class", "lochierarchy", "sum_net_profit", "sum_sales_price"], "consumes": ["item_join"]}
      },
      "level3_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT NULL AS i_category, NULL AS i_class, 2 AS lochierarchy, SUM(profit_sum) AS sum_net_profit, SUM(sales_sum) AS sum_sales_price FROM item_join",
        "interfaces": {"outputs": ["i_category", "i_class", "lochierarchy", "sum_net_profit", "sum_sales_price"], "consumes": ["item_join"]}
      },
      "union_all": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT * FROM level1_agg UNION ALL SELECT * FROM level2_agg UNION ALL SELECT * FROM level3_agg",
        "interfaces": {"outputs": ["i_category", "i_class", "lochierarchy", "sum_net_profit", "sum_sales_price"], "consumes": ["level1_agg", "level2_agg", "level3_agg"]}
      },
      "window_rank": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT sum_net_profit / sum_sales_price AS gross_margin, i_category, i_class, lochierarchy, CASE WHEN lochierarchy < 2 THEN RANK() OVER (PARTITION BY lochierarchy, CASE WHEN lochierarchy = 0 THEN i_category END ORDER BY sum_net_profit / sum_sales_price ASC) ELSE 1 END AS rank_within_parent FROM union_all",
        "interfaces": {"outputs": ["gross_margin", "i_category", "i_class", "lochierarchy", "rank_within_parent"], "consumes": ["union_all"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT gross_margin, i_category, i_class, lochierarchy, rank_within_parent FROM window_rank ORDER BY lochierarchy DESC, CASE WHEN lochierarchy = 0 THEN i_category END, rank_within_parent LIMIT 100",
        "interfaces": {"outputs": ["gross_margin", "i_category", "i_class", "lochierarchy", "rank_within_parent"], "consumes": ["window_rank"]}
      }
    },
    "reconstruction_order": ["filtered_date", "filtered_store", "fact_preagg", "item_join", "level1_agg", "level2_agg", "level3_agg", "union_all", "window_rank", "main_query"],
    "assembly_template": "WITH filtered_date AS ({filtered_date}), filtered_store AS ({filtered_store}), fact_preagg AS ({fact_preagg}), item_join AS ({item_join}), level1_agg AS ({level1_agg}), level2_agg AS ({level2_agg}), level3_agg AS ({level3_agg}), union_all AS ({union_all}), window_rank AS ({window_rank}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:**  
Restructured the ROLLUP query into an explicit three-level hierarchy via CTEs, applying dimensional filtering early and pre-aggregating fact data by item key before joining with the item dimension. This allows DuckDB to push filters down and reduce intermediate data volume before the expensive aggregation steps.

**Expected speedup:** 2.5-3.5x (based on similar patterns in regression tests) due to reduced fact table scan, early filtering, and explicit hierarchy computation avoiding ROLLUP's implicit grouping overhead.