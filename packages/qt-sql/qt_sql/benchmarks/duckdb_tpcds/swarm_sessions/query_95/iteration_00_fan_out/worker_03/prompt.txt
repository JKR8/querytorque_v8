You are a SQL rewrite engine for DuckDB v1.4.3. Follow the Target Logical Tree structure below. Your job is to write correct, executable SQL for each node — not to decide whether to restructure. Preserve exact semantic equivalence (same rows, same columns, same ordering). Preserve defensive guards: if the original uses CASE WHEN x > 0 THEN y/x END around a division, keep it — even when a WHERE clause makes the zero case unreachable. Guards prevent silent breakage if filters change upstream. Strip benchmark comments (-- start query, -- end query) from your output.

DuckDB specifics: columnar storage (SELECT only needed columns). CTEs referenced once are typically inlined; CTEs referenced multiple times may be materialized. FILTER clause is native (`COUNT(*) FILTER (WHERE cond)`). Predicate pushdown stops at UNION ALL boundaries and multi-level CTE references.

## Semantic Contract (MUST preserve)

For NC shipments during 60 days from 1999-02-01 on 'pri' company sites, report order count, shipping cost, and net profit for orders that (a) involve multiple warehouses AND (b) have a return that also involves multiple warehouses. JOIN semantics: INNER joins require all dimension matches; two semi-joins (IN subqueries) require order to be in both sets. Aggregation traps: COUNT(DISTINCT ws_order_number) counts distinct orders after filtering; SUMs are duplicate-safe because joins are on ws_order_number which is unique per order? Actually, web_sales may have multiple line items per order, but we aggregate after joins, so duplicates could affect SUMs. Need to ensure no duplicate inflation. Filter dependencies: The date filter depends on d_date_sk join; state and company filters depend on ca_address_sk and web_site_sk joins; the two IN subqueries depend on the CTE ws_wh.

## Target Logical Tree + Node Contracts

Build your rewrite following this CTE structure. Each node's OUTPUT list is exhaustive — your SQL must produce exactly those columns.

TARGET_LOGICAL_TREE:
ws_wh_grouped (GROUP BY) -> filtered_ws (join dims) -> semi_joins -> aggregate
NODE_CONTRACTS:
  ws_wh_grouped:
    FROM: web_sales
    GROUP BY: ws_order_number
    HAVING: MIN(ws_warehouse_sk) <> MAX(ws_warehouse_sk)
    OUTPUT: ws_order_number
    EXPECTED_ROWS: ~1K (same as original ws_wh)
    CONSUMERS: semi_join1, semi_join2
  filtered_ws:
    FROM: web_sales ws1, date_dim, customer_address, web_site
    JOIN: ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ws1.ws_web_site_sk = web_site_sk
    WHERE: d_date BETWEEN '1999-2-01' AND (CAST('1999-2-01' AS DATE) + INTERVAL 60 DAY) AND ca_state = 'NC' AND web_company_name = 'pri'
    OUTPUT: ws1.ws_order_number, ws1.ws_ext_ship_cost, ws1.ws_net_profit
    EXPECTED_ROWS: 9,956
    CONSUMERS: semi_join1, semi_join2, aggregate
  semi_join1:
    FROM: filtered_ws
    WHERE: ws_order_number IN (SELECT ws_order_number FROM ws_wh_grouped)
    OUTPUT: ws_order_number, ws_ext_ship_cost, ws_net_profit
    EXPECTED_ROWS: 7,217
    CONSUMERS: semi_join2
  semi_join2:
    FROM: semi_join1
    WHERE: ws_order_number IN (SELECT wr_order_number FROM web_returns WHERE wr_order_number IN (SELECT ws_order_number FROM ws_wh_grouped))
    OUTPUT: ws_order_number, ws_ext_ship_cost, ws_net_profit
    EXPECTED_ROWS: ~1K
    CONSUMERS: aggregate
  aggregate:
    FROM: semi_join2
    AGGREGATE: COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit"
    OUTPUT: "order count", "total shipping cost", "total net profit"
    EXPECTED_ROWS: 1
    CONSUMERS: final

NODE_CONTRACTS:
ws_wh_grouped:
    FROM: web_sales
    GROUP BY: ws_order_number
    HAVING: MIN(ws_warehouse_sk) <> MAX(ws_warehouse_sk)
    OUTPUT: ws_order_number
    EXPECTED_ROWS: ~1K (same as original ws_wh)
    CONSUMERS: semi_join1, semi_join2
  filtered_ws:
    FROM: web_sales ws1, date_dim, customer_address, web_site
    JOIN: ws1.ws_ship_date_sk = d_date_sk AND ws1.ws_ship_addr_sk = ca_address_sk AND ws1.ws_web_site_sk = web_site_sk
    WHERE: d_date BETWEEN '1999-2-01' AND (CAST('1999-2-01' AS DATE) + INTERVAL 60 DAY) AND ca_state = 'NC' AND web_company_name = 'pri'
    OUTPUT: ws1.ws_order_number, ws1.ws_ext_ship_cost, ws1.ws_net_profit
    EXPECTED_ROWS: 9,956
    CONSUMERS: semi_join1, semi_join2, aggregate
  semi_join1:
    FROM: filtered_ws
    WHERE: ws_order_number IN (SELECT ws_order_number FROM ws_wh_grouped)
    OUTPUT: ws_order_number, ws_ext_ship_cost, ws_net_profit
    EXPECTED_ROWS: 7,217
    CONSUMERS: semi_join2
  semi_join2:
    FROM: semi_join1
    WHERE: ws_order_number IN (SELECT wr_order_number FROM web_returns WHERE wr_order_number IN (SELECT ws_order_number FROM ws_wh_grouped))
    OUTPUT: ws_order_number, ws_ext_ship_cost, ws_net_profit
    EXPECTED_ROWS: ~1K
    CONSUMERS: aggregate
  aggregate:
    FROM: semi_join2
    AGGREGATE: COUNT(DISTINCT ws_order_number) AS "order count", SUM(ws_ext_ship_cost) AS "total shipping cost", SUM(ws_net_profit) AS "total net profit"
    OUTPUT: "order count", "total shipping cost", "total net profit"
    EXPECTED_ROWS: 1
    CONSUMERS: final

## Hazard Flags (avoid these specific risks)

- GROUP BY on 86.4M row web_sales may be expensive, but should be cheaper than self-join producing 74.8M rows.
- Need to ensure HAVING MIN <> MAX correctly identifies orders with at least two different warehouses (including NULL handling). ws_warehouse_sk is likely NOT NULL.

## Regression Warnings (observed failures on similar queries)

1. materialize_cte (0.54x on q95):
   CAUSE: Decomposed tightly-correlated EXISTS/NOT EXISTS into independent CTEs, severing cardinality relationship.
   RULE: Do not split the two IN conditions into independent CTEs; keep them as semi-joins on the same materialized CTE.
2. dimension_cte_isolate (0.0076x on q26):
   CAUSE: Cross-joined 3+ dimension CTEs caused Cartesian explosion.
   RULE: Never cross-join dimension CTEs; join them sequentially with fact table.

## Constraints (analyst-filtered for this query)

- COMPLETE_OUTPUT: Must output exactly three columns: "order count", "total shipping cost", "total net profit".
- CTE_COLUMN_COMPLETENESS: Any CTE must include ws_order_number for semi-joins, plus ws_ext_ship_cost and ws_net_profit for aggregation.
- LITERAL_PRESERVATION: Must preserve date '1999-2-01', interval 60, state 'NC', company 'pri'.
- SEMANTIC_EQUIVALENCE: Must return same rows and aggregates.
- ENGINE_GAP_REDUNDANT_SCAN_ELIMINATION: CTE ws_wh computed twice (two HASH_JOIN INNER nodes in EXPLAIN).
- ENGINE_GAP_CROSS_CTE_PREDICATE_BLINDNESS: Dimension filters applied late; opportunity to pre-filter dimensions into CTEs.

## Example Adaptation Notes

For each example: what to apply to your rewrite, and what to ignore.

- SELF_JOIN_TO_WINDOW: Replace self-join with GROUP BY HAVING MIN <> MAX. Ignore window function aspect.
- materialize_cte: Materialize the grouped CTE to share across semi-joins.
- union_cte_split: Not applicable; ignore the split by discriminator.

## Reference Examples

Pattern reference only — do not copy table/column names or literals.

### 1. SELF_JOIN_TO_WINDOW (unknown)

**BEFORE (slow):**
```sql
SELECT a.*, b.max_salary
      FROM employees a
      JOIN (
          SELECT department, MAX(salary) AS max_salary
          FROM employees GROUP BY department
      ) b ON a.department = b.department;
```

### 2. materialize_cte (1.37x)

**Principle:** Shared Materialization: extract repeated subquery patterns into CTEs to avoid recomputation. When the same logical check appears multiple times, compute it once and reference the result.

**BEFORE (slow):**
```sql
with ws_wh as
(select ws1.ws_order_number,ws1.ws_warehouse_sk wh1,ws2.ws_warehouse_sk wh2
 from web_sales ws1,web_sales ws2
 where ws1.ws_order_number = ws2.ws_order_number
   and ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)
 select 
   count(distinct ws_order_number) as "order count"
  ,sum(ws_ext_ship_cost) as "total shipping cost"
  ,sum(ws_net_profit) as "total net profit"
from
   web_sales ws1
  ,date_dim
  ,customer_address
  ,web_site
where
    d_date between '1999-2-01' and 
           (cast('1999-2-01' as date) + INTERVAL 60 DAY)
and ws1.ws_ship_date_sk = d_date_sk
and ws1.ws_ship_addr_sk = ca_address_sk
and ca_state = 'NC'
and ws1.ws_web_site_sk = web_site_sk
and web_company_name = 'pri'
and ws1.ws_order_number in (select ws_order_number
                            from ws_wh)
and ws1.ws_order_number in (select wr_order_number
                            from web_returns,ws_wh
                            where wr_order_number = ws_wh.ws_order_number)
order by count(distinct ws_order_number)
 LIMIT 100;
```

**AFTER (fast):**
[multi_warehouse_orders]:
```sql
SELECT DISTINCT ws_order_number FROM web_sales ws1 WHERE EXISTS (SELECT 1 FROM web_sales ws2 WHERE ws1.ws_order_number = ws2.ws_order_number AND ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)
```
[returned_orders]:
```sql
SELECT DISTINCT wr_order_number FROM web_returns
```
[main_query]:
```sql
SELECT COUNT(DISTINCT ws_order_number) AS order_count, SUM(ws_ext_ship_cost) AS total_shipping FROM web_sales ws1 JOIN date_dim ON ws1.ws_ship_date_sk = d_date_sk JOIN customer_address ON ws1.ws_ship_addr_sk = ca_address_sk JOIN web_site ON ws1.ws_web_site_sk = web_site_sk JOIN multi_warehouse_orders mwo ON ws1.ws_order_number = mwo.ws_order_number LEFT JOIN returned_orders ro ON ws1.ws_order_number = ro.wr_order_number WHERE d_date BETWEEN '2000-03-01' AND '2000-05-01' AND ca_state = 'IL' AND web_company_name = 'pri' AND ro.wr_order_number IS NULL
```

### 3. union_cte_split (1.36x)

**Principle:** CTE Specialization: when a generic CTE is scanned multiple times with different filters (e.g., by year), split it into specialized CTEs that embed the filter in their definition. Each specialized CTE processes only its relevant subset, eliminating redundant scans.

**BEFORE (slow):**
```sql
with year_total as (
 select c_customer_id customer_id
       ,c_first_name customer_first_name
       ,c_last_name customer_last_name
       ,d_year as year
       ,stddev_samp(ss_net_paid) year_total
       ,'s' sale_type
 from customer
     ,store_sales
     ,date_dim
 where c_customer_sk = ss_customer_sk
   and ss_sold_date_sk = d_date_sk
   and d_year in (1999,1999+1)
 group by c_customer_id
         ,c_first_name
         ,c_last_name
         ,d_year
 union all
 select c_customer_id customer_id
       ,c_first_name customer_first_name
       ,c_last_name customer_last_name
       ,d_year as year
       ,stddev_samp(ws_net_paid) year_total
       ,'w' sale_type
 from customer
     ,web_sales
     ,date_dim
 where c_customer_sk = ws_bill_customer_sk
   and ws_sold_date_sk = d_date_sk
   and d_year in (1999,1999+1)
 group by c_customer_id
         ,c_first_name
         ,c_last_name
         ,d_year
         )
  select
        t_s_secyear.customer_id, t_s_secyear.customer_first_name, t_s_secyear.customer_last_name
 from year_total t_s_firstyear
     ,year_total t_s_secyear
     ,year_total t_w_firstyear
     ,year_total t_w_secyear
 where t_s_secyear.customer_id = t_s_firstyear.customer_id
         and t_s_firstyear.customer_id = t_w_secyear.customer_id
         and t_s_firstyear.customer_id = t_w_firstyear.customer_id
         and t_s_firstyear.sale_type = 's'
         and t_w_firstyear.sale_type = 'w'
         and t_s_secyear.sale_type = 's'
         and t_w_secyear.sale_type = 'w'
         and t_s_firstyear.year = 1999
         and t_s_secyear.year = 1999+1
         and t_w_firstyear.year = 1999
         and t_w_secyear.year = 1999+1
         and t_s_firstyear.year_total > 0
         and t_w_firstyear.year_total > 0
         and case when t_w_firstyear.year_total > 0 then t_w_secyear.year_total / t_w_firstyear.year_total else null end
           > case when t_s_firstyear.year_total > 0 then t_s_secyear.year_total / t_s_firstyear.year_total else null end
 order by 2,1,3
 LIMIT 100;
```

**AFTER (fast):**
[year_1998_dates]:
```sql
SELECT d_date_sk, d_week_seq, d_day_name FROM date_dim WHERE d_year = 1998
```
[year_1999_dates]:
```sql
SELECT d_date_sk, d_week_seq, d_day_name FROM date_dim WHERE d_year = 1999
```
[wswscs_1998]:
```sql
SELECT d_week_seq, SUM(CASE WHEN d_day_name='Sunday' THEN sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN d_day_name='Monday' THEN sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN d_day_name='Tuesday' THEN sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN d_day_name='Wednesday' THEN sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN d_day_name='Thursday' THEN sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN d_day_name='Friday' THEN sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN d_day_name='Saturday' THEN sales_price ELSE NULL END) AS sat_sales FROM (SELECT ws_sold_date_sk AS sold_date_sk, ws_ext_sales_price AS sales_price FROM web_sales UNION ALL SELECT cs_sold_date_sk AS sold_date_sk, cs_ext_sales_price AS sales_price FROM catalog_sales) wscs JOIN year_1998_dates ON d_date_sk = sold_date_sk GROUP BY d_week_seq
```
[wswscs_1999]:
```sql
SELECT d_week_seq, SUM(CASE WHEN d_day_name='Sunday' THEN sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN d_day_name='Monday' THEN sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN d_day_name='Tuesday' THEN sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN d_day_name='Wednesday' THEN sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN d_day_name='Thursday' THEN sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN d_day_name='Friday' THEN sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN d_day_name='Saturday' THEN sales_price ELSE NULL END) AS sat_sales FROM (SELECT ws_sold_date_sk AS sold_date_sk, ws_ext_sales_price AS sales_price FROM web_sales UNION ALL SELECT cs_sold_date_sk AS sold_date_sk, cs_ext_sales_price AS sales_price FROM catalog_sales) wscs JOIN year_1999_dates ON d_date_sk = sold_date_sk GROUP BY d_week_seq
```
[main_query]:
```sql
SELECT y.d_week_seq AS d_week_seq1, ROUND(y.sun_sales / NULLIF(z.sun_sales, 0), 2), ROUND(y.mon_sales / NULLIF(z.mon_sales, 0), 2), ROUND(y.tue_sales / NULLIF(z.tue_sales, 0), 2), ROUND(y.wed_sales / NULLIF(z.wed_sales, 0), 2), ROUND(y.thu_sales / NULLIF(z.thu_sales, 0), 2), ROUND(y.fri_sales / NULLIF(z.fri_sales, 0), 2), ROUND(y.sat_sales / NULLIF(z.sat_sales, 0), 2) FROM wswscs_1998 y JOIN wswscs_1999 z ON y.d_week_seq = z.d_week_seq - 53 ORDER BY y.d_week_seq
```

## Original SQL

```sql
-- start query 95 in stream 0 using template query95.tpl
with ws_wh as
(select ws1.ws_order_number,ws1.ws_warehouse_sk wh1,ws2.ws_warehouse_sk wh2
 from web_sales ws1,web_sales ws2
 where ws1.ws_order_number = ws2.ws_order_number
   and ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)
 select 
   count(distinct ws_order_number) as "order count"
  ,sum(ws_ext_ship_cost) as "total shipping cost"
  ,sum(ws_net_profit) as "total net profit"
from
   web_sales ws1
  ,date_dim
  ,customer_address
  ,web_site
where
    d_date between '1999-2-01' and 
           (cast('1999-2-01' as date) + INTERVAL 60 DAY)
and ws1.ws_ship_date_sk = d_date_sk
and ws1.ws_ship_addr_sk = ca_address_sk
and ca_state = 'NC'
and ws1.ws_web_site_sk = web_site_sk
and web_company_name = 'pri'
and ws1.ws_order_number in (select ws_order_number
                            from ws_wh)
and ws1.ws_order_number in (select wr_order_number
                            from web_returns,ws_wh
                            where wr_order_number = ws_wh.ws_order_number)
order by count(distinct ws_order_number)
 LIMIT 100;

-- end query 95 in stream 0 using template query95.tpl
```

## Rewrite Checklist (must pass before final SQL)

- Follow every node in `TARGET_LOGICAL_TREE` and produce each `NODE_CONTRACT` output column exactly.
- Keep all semantic invariants from `Semantic Contract` and `Constraints` (including join/null behavior).
- Preserve all literals and the exact final output schema/order.
- Apply `Hazard Flags` and `Regression Warnings` as hard guards against known failure modes.

### Column Completeness Contract

Your `main_query` component MUST produce **exactly** these output columns (same names, same order):

  1. `order count`
  2. `total shipping cost`
  3. `total net profit`

Do NOT add, remove, or rename any output columns. The result set schema must be identical to the original query.

## Original Query Structure

This is the current query structure. All nodes are `[=]` (unchanged). Your modified Logic Tree below should show which nodes you changed.

```
QUERY: (single statement)
├── [CTE] ws_wh  [=]  Cost: 50%  Rows: ~1K  — Identify web order numbers that involve at least two different warehouses.
│   ├── SCAN (web_sales AS ws1 (join), web_sales AS ws2 (join))
│   ├── JOIN (ws1.ws_order_number = ws2.ws_order_number)
│   ├── FILTER (ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)
│   └── OUTPUT (ws_order_number, wh1, wh2)
└── [MAIN] main_query  [=]  Cost: 50%  Rows: ~1K  — Filter web sales by ship date range, state, and company; keep orders in the multi-warehouse set and in returned-order set; then aggregate distinct order count, shipping cost, and net profit.
    ├── SCAN (web_sales AS ws1 (join), date_dim (join), customer_address (join), web_site (join), ws_wh (join), web_returns (correlated subquery))
    ├── JOIN (ws1.ws_ship_date_sk = d_date_sk)
    ├── JOIN (ws1.ws_ship_addr_sk = ca_address_sk)
    ├── JOIN (+1 more)
    ├── FILTER (d_date BETWEEN '1999-2-01' AND (CAST('1999-2-01' AS DATE) + INTERVAL '60' DAY))
    ├── FILTER (ca_state = 'NC')
    ├── FILTER (+3 more)
    ├── SORT (COUNT(DISTINCT ws_order_number) ASC)
    └── OUTPUT (order count, total shipping cost, total net profit)
```

## Output Format

Your response has **two parts** in order:

### Part 1: Modified Logic Tree

Show what changed using change markers. Generate the tree BEFORE writing SQL.

Change markers:
- `[+]` — New component added
- `[-]` — Component removed
- `[~]` — Component modified (describe what changed)
- `[=]` — Unchanged (no children needed)
- `[!]` — Structural change (e.g. CTE → subquery)

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "<dialect>",
  "rewrite_rules": [
    {"id": "R1", "type": "<transform_name>", "description": "<what changed>", "applied_to": ["<component_id>"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "<cte_name>": {
        "type": "cte",
        "change": "modified",
        "sql": "<complete SQL for this CTE body>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<upstream_id>"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "<final SELECT>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<cte_name>"]}
      }
    },
    "reconstruction_order": ["<cte_name>", "main_query"],
    "assembly_template": "WITH <cte_name> AS ({<cte_name>}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Rules
- **Tree first, always.** Generate the Logic Tree before writing any SQL
- **One component at a time.** When writing SQL for component X, treat others as opaque interfaces
- **No ellipsis.** Every `sql` value must be complete, executable SQL
- **Frozen blocks are copy-paste.** Large CASE-WHEN lookups must be verbatim
- **Validate interfaces.** Verify every `consumes` reference exists in upstream `outputs`
- Only include components you **changed or added** — set unchanged components to `"change": "unchanged"` with `"sql": ""`
- `main_query` output columns must match the Column Completeness Contract above
- `reconstruction_order`: topological order of components for assembly

After the JSON, explain the mechanism:

```
Changes: <1-2 sentences: what structural change + the expected mechanism>
Expected speedup: <estimate>
```

Now output your Logic Tree and Component Payload JSON: