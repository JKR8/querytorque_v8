### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_range  [+]  Cost: <1%  Rows: 15  — Extract date_dim primary keys for 14-day window starting 2000-08-19
│   ├── SCAN (date_dim)
│   ├── FILTER (d_date BETWEEN CAST('2000-08-19' AS DATE) AND (CAST('2000-08-19' AS DATE) + INTERVAL '14' DAY))
│   └── OUTPUT (d_date_sk)
├── [CTE] ssr  [~]  Cost: 25%  Rows: 51  — Modified to join with date_range CTE instead of scanning date_dim directly
│   ├── SCAN (store_sales, store_returns)
│   ├── UNION
│   ├── JOIN (date_sk = d_date_sk) with date_range
│   ├── JOIN (store_sk = s_store_sk)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (s_store_id, sales, profit, returns, profit_loss)
├── [CTE] csr  [~]  Cost: 25%  Rows: 1133  — Modified to join with date_range CTE instead of scanning date_dim directly
│   ├── SCAN (catalog_sales, catalog_returns)
│   ├── UNION
│   ├── JOIN (date_sk = d_date_sk) with date_range
│   ├── JOIN (page_sk = cp_catalog_page_sk)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (cp_catalog_page_id, sales, profit, returns, profit_loss)
├── [CTE] wsr  [~]  Cost: 25%  Rows: 21  — Modified to join with date_range CTE instead of scanning date_dim directly
│   ├── SCAN (web_sales, web_returns)
│   ├── JOIN (LEFT OUTER) web_sales to web_returns
│   ├── UNION
│   ├── JOIN (date_sk = d_date_sk) with date_range
│   ├── JOIN (wsr_web_site_sk = web_site_sk)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (web_site_id, sales, profit, returns, profit_loss)
└── [MAIN] main_query  [=]  Cost: 25%  Rows: ~1K  — Unchanged union of channel CTEs with rollup
    ├── SCAN (wsr, ssr, csr)
    ├── AGG (GROUP BY)
    ├── SORT (channel ASC, id ASC)
    └── OUTPUT (channel, id, sales, returns, profit)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "date_cte_isolate", "description": "Extracted shared date filter into date_range CTE to eliminate 3 redundant date_dim scans", "applied_to": ["date_range", "ssr", "csr", "wsr"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_range": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN CAST('2000-08-19' AS DATE) AND (CAST('2000-08-19' AS DATE) + INTERVAL 14 DAY)",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "ssr": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s_store_id, SUM(sales_price) AS sales, SUM(profit) AS profit, SUM(return_amt) AS returns, SUM(net_loss) AS profit_loss FROM (SELECT ss_store_sk AS store_sk, ss_sold_date_sk AS date_sk, ss_ext_sales_price AS sales_price, ss_net_profit AS profit, CAST(0 AS DECIMAL(7,2)) AS return_amt, CAST(0 AS DECIMAL(7,2)) AS net_loss FROM store_sales UNION ALL SELECT sr_store_sk AS store_sk, sr_returned_date_sk AS date_sk, CAST(0 AS DECIMAL(7,2)) AS sales_price, CAST(0 AS DECIMAL(7,2)) AS profit, sr_return_amt AS return_amt, sr_net_loss AS net_loss FROM store_returns) AS salesreturns JOIN date_range ON salesreturns.date_sk = date_range.d_date_sk JOIN store ON salesreturns.store_sk = store.s_store_sk GROUP BY s_store_id",
        "interfaces": {"outputs": ["s_store_id", "sales", "profit", "returns", "profit_loss"], "consumes": ["date_range"]}
      },
      "csr": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT cp_catalog_page_id, SUM(sales_price) AS sales, SUM(profit) AS profit, SUM(return_amt) AS returns, SUM(net_loss) AS profit_loss FROM (SELECT cs_catalog_page_sk AS page_sk, cs_sold_date_sk AS date_sk, cs_ext_sales_price AS sales_price, cs_net_profit AS profit, CAST(0 AS DECIMAL(7,2)) AS return_amt, CAST(0 AS DECIMAL(7,2)) AS net_loss FROM catalog_sales UNION ALL SELECT cr_catalog_page_sk AS page_sk, cr_returned_date_sk AS date_sk, CAST(0 AS DECIMAL(7,2)) AS sales_price, CAST(0 AS DECIMAL(7,2)) AS profit, cr_return_amount AS return_amt, cr_net_loss AS net_loss FROM catalog_returns) AS salesreturns JOIN date_range ON salesreturns.date_sk = date_range.d_date_sk JOIN catalog_page ON salesreturns.page_sk = catalog_page.cp_catalog_page_sk GROUP BY cp_catalog_page_id",
        "interfaces": {"outputs": ["cp_catalog_page_id", "sales", "profit", "returns", "profit_loss"], "consumes": ["date_range"]}
      },
      "wsr": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT web_site_id, SUM(sales_price) AS sales, SUM(profit) AS profit, SUM(return_amt) AS returns, SUM(net_loss) AS profit_loss FROM (SELECT ws_web_site_sk AS wsr_web_site_sk, ws_sold_date_sk AS date_sk, ws_ext_sales_price AS sales_price, ws_net_profit AS profit, CAST(0 AS DECIMAL(7,2)) AS return_amt, CAST(0 AS DECIMAL(7,2)) AS net_loss FROM web_sales UNION ALL SELECT ws_web_site_sk AS wsr_web_site_sk, wr_returned_date_sk AS date_sk, CAST(0 AS DECIMAL(7,2)) AS sales_price, CAST(0 AS DECIMAL(7,2)) AS profit, wr_return_amt AS return_amt, wr_net_loss AS net_loss FROM web_returns LEFT OUTER JOIN web_sales ON (wr_item_sk = ws_item_sk AND wr_order_number = ws_order_number)) AS salesreturns JOIN date_range ON salesreturns.date_sk = date_range.d_date_sk JOIN web_site ON salesreturns.wsr_web_site_sk = web_site.web_site_sk GROUP BY web_site_id",
        "interfaces": {"outputs": ["web_site_id", "sales", "profit", "returns", "profit_loss"], "consumes": ["date_range"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "unchanged",
        "sql": "",
        "interfaces": {"outputs": ["channel", "id", "sales", "returns", "profit"], "consumes": ["ssr", "csr", "wsr"]}
      }
    },
    "reconstruction_order": ["date_range", "ssr", "csr", "wsr", "main_query"],
    "assembly_template": "WITH date_range AS ({date_range}), ssr AS ({ssr}), csr AS ({csr}), wsr AS ({wsr}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Introduced a shared `date_range` CTE to isolate the date filter that was redundantly scanned 3 times in the original query. Each channel CTE (ssr, csr, wsr) now joins with this pre-filtered date_range CTE instead of scanning date_dim directly, eliminating 2 redundant date_dim scans while preserving the exact same join semantics and output.

**Expected speedup:** ~1.3-1.5x based on similar pattern "shared_dimension_multi_channel". The main benefit comes from eliminating redundant dimension table scans (original: 3 date_dim scans at 0.6-0.8ms each) while maintaining the same logical structure and semantic equivalence.