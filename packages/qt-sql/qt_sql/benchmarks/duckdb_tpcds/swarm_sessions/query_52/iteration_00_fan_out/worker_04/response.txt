## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: 100 — CTE pipeline following target logical tree
    ├── WITH date_range AS (
    │      [MAIN] date_range  [+]
    │      ├── SCAN date_dim
    │      ├── FILTER (d_moy = 12 AND d_year = 2002)
    │      └── AGG (MIN(d_date_sk), MAX(d_date_sk))
    │      └── OUTPUT: min_sk, max_sk
    │   )
    ├── WITH range_filtered_sales AS (
    │      [MAIN] range_filtered_sales  [+]
    │      ├── SCAN store_sales
    │      ├── FILTER (ss_sold_date_sk BETWEEN (date_range.min_sk) AND (date_range.max_sk))
    │      └── OUTPUT: ss_item_sk, ss_ext_sales_price
    │   )
    ├── WITH item_filtered AS (
    │      [MAIN] item_filtered  [+]
    │      ├── SCAN range_filtered_sales
    │      ├── JOIN INNER item ON range_filtered_sales.ss_item_sk = item.i_item_sk
    │      ├── FILTER (item.i_manager_id = 1)
    │      └── OUTPUT: i_brand_id, i_brand, ss_ext_sales_price
    │   )
    ├── WITH aggregated AS (
    │      [MAIN] aggregated  [+]
    │      ├── SCAN item_filtered
    │      ├── AGG GROUP BY (i_brand, i_brand_id)
    │      └── OUTPUT: 2002 AS d_year, i_brand_id AS brand_id, i_brand AS brand, SUM(ss_ext_sales_price) AS ext_price
    │   )
    ├── [MAIN] sorted_limited  [+]
    │   ├── SCAN aggregated
    │   ├── SORT (d_year ASC, ext_price DESC, brand_id ASC)
    │   ├── LIMIT 100
    │   └── OUTPUT: d_year, brand_id, brand, ext_price
    └── OUTPUT (d_year, brand_id, brand, ext_price)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb_v1.4.3",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_breakout", "description": "Decomposed original query into CTE pipeline per target logical tree", "applied_to": ["date_range", "range_filtered_sales", "item_filtered", "aggregated", "sorted_limited"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_range": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT MIN(d_date_sk) AS min_sk, MAX(d_date_sk) AS max_sk FROM date_dim WHERE d_moy = 12 AND d_year = 2002",
        "interfaces": {"outputs": ["min_sk", "max_sk"], "consumes": []}
      },
      "range_filtered_sales": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_item_sk, ss_ext_sales_price FROM store_sales WHERE ss_sold_date_sk BETWEEN (SELECT min_sk FROM date_range) AND (SELECT max_sk FROM date_range)",
        "interfaces": {"outputs": ["ss_item_sk", "ss_ext_sales_price"], "consumes": ["date_range"]}
      },
      "item_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT item.i_brand_id, item.i_brand, range_filtered_sales.ss_ext_sales_price FROM range_filtered_sales INNER JOIN item ON range_filtered_sales.ss_item_sk = item.i_item_sk WHERE item.i_manager_id = 1",
        "interfaces": {"outputs": ["i_brand_id", "i_brand", "ss_ext_sales_price"], "consumes": ["range_filtered_sales"]}
      },
      "aggregated": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT 2002 AS d_year, i_brand_id AS brand_id, i_brand AS brand, SUM(ss_ext_sales_price) AS ext_price FROM item_filtered GROUP BY i_brand, i_brand_id",
        "interfaces": {"outputs": ["d_year", "brand_id", "brand", "ext_price"], "consumes": ["item_filtered"]}
      },
      "sorted_limited": {
        "type": "main_query",
        "change": "new",
        "sql": "SELECT d_year, brand_id, brand, ext_price FROM aggregated ORDER BY d_year ASC, ext_price DESC, brand_id ASC LIMIT 100",
        "interfaces": {"outputs": ["d_year", "brand_id", "brand", "ext_price"], "consumes": ["aggregated"]}
      }
    },
    "reconstruction_order": ["date_range", "range_filtered_sales", "item_filtered", "aggregated", "sorted_limited"],
    "assembly_template": "WITH date_range AS ({date_range}), range_filtered_sales AS ({range_filtered_sales}), item_filtered AS ({item_filtered}), aggregated AS ({aggregated}) {sorted_limited}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Restructured original 3-table join into a CTE pipeline isolating date range lookup, filtered fact table scan, dimension join, aggregation, and final ordering. This matches the target logical tree's decomposition while preserving all semantic invariants.

Expected speedup: Moderate (1.5-2x) - CTE pipeline enables predicate pushdown into individual scans while avoiding Cartesian product risks in original implicit join. DuckDB's optimizer can still push some predicates through CTEs, and the structured decomposition prevents regression from multi-level CTE reference issues.