### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query [!]  Cost: 100%  Rows: ~1K  — Decorrelated multi-channel CTE structure
    ├── [~] date_filter (CTE)  — Materialized date keys for 2001 Q1-Q3
    ├── [~] store_customers (CTE)  — Distinct store customers in period
    ├── [~] web_customers (CTE)  — Distinct web customers in period
    ├── [~] catalog_customers (CTE)  — Distinct catalog customers in period
    ├── [~] or_customers (CTE)  — UNION of web and catalog customers
    ├── [~] customer_base (CTE)  — Joined customer/address/demographics with mandatory store and (web|catalog) filters
    ├── [~] aggregation (CTE)  — GROUP BY with counts, sums, maxes
    └── [~] top_n (main_query)  — ORDER BY + LIMIT 100
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "composite_decorrelate_union", "description": "Convert correlated EXISTS to pre-materialized DISTINCT customer keys per channel with shared date filter CTE", "applied_to": ["date_filter", "store_customers", "web_customers", "catalog_customers", "or_customers", "customer_base"]},
    {"id": "R2", "type": "cte_materialization", "description": "Materialize small dimension filter (date) and large distinct customer sets for reuse", "applied_to": ["date_filter", "store_customers", "web_customers", "catalog_customers", "or_customers"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filter": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_qoy < 4",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT ss_customer_sk AS customer_sk FROM store_sales JOIN date_filter ON ss_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["customer_sk"], "consumes": ["date_filter"]}
      },
      "web_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT ws_bill_customer_sk AS customer_sk FROM web_sales JOIN date_filter ON ws_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["customer_sk"], "consumes": ["date_filter"]}
      },
      "catalog_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT DISTINCT cs_ship_customer_sk AS customer_sk FROM catalog_sales JOIN date_filter ON cs_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["customer_sk"], "consumes": ["date_filter"]}
      },
      "or_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT customer_sk FROM web_customers UNION SELECT customer_sk FROM catalog_customers",
        "interfaces": {"outputs": ["customer_sk"], "consumes": ["web_customers", "catalog_customers"]}
      },
      "customer_base": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk JOIN store_customers sc ON c.c_customer_sk = sc.customer_sk JOIN or_customers oc ON c.c_customer_sk = oc.customer_sk",
        "interfaces": {"outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"], "consumes": ["store_customers", "or_customers"]}
      },
      "aggregation": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, COUNT(*) AS cnt1, MAX(cd_dep_count) AS max_cd_dep_count1, SUM(cd_dep_count) AS sum_cd_dep_count, MAX(cd_dep_count) AS max_cd_dep_count2, cd_dep_employed_count, COUNT(*) AS cnt2, MAX(cd_dep_employed_count) AS max_cd_dep_employed_count1, SUM(cd_dep_employed_count) AS sum_cd_dep_employed_count, MAX(cd_dep_employed_count) AS max_cd_dep_employed_count2, cd_dep_college_count, COUNT(*) AS cnt3, MAX(cd_dep_college_count) AS max_cd_dep_college_count1, SUM(cd_dep_college_count) AS sum_cd_dep_college_count, MAX(cd_dep_college_count) AS max_cd_dep_college_count2 FROM customer_base GROUP BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count",
        "interfaces": {"outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cnt1", "max_cd_dep_count1", "sum_cd_dep_count", "max_cd_dep_count2", "cd_dep_employed_count", "cnt2", "max_cd_dep_employed_count1", "sum_cd_dep_employed_count", "max_cd_dep_employed_count2", "cd_dep_college_count", "cnt3", "max_cd_dep_college_count1", "sum_cd_dep_college_count", "max_cd_dep_college_count2"], "consumes": ["customer_base"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, cnt1, max_cd_dep_count1, sum_cd_dep_count, max_cd_dep_count2, cd_dep_employed_count, cnt2, max_cd_dep_employed_count1, sum_cd_dep_employed_count, max_cd_dep_employed_count2, cd_dep_college_count, cnt3, max_cd_dep_college_count1, sum_cd_dep_college_count, max_cd_dep_college_count2 FROM aggregation ORDER BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100",
        "interfaces": {"outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cnt1", "max(cd_dep_count)", "sum(cd_dep_count)", "max(cd_dep_count)", "cd_dep_employed_count", "cnt2", "max(cd_dep_employed_count)", "sum(cd_dep_employed_count)", "max(cd_dep_employed_count)", "cd_dep_college_count", "cnt3", "max(cd_dep_college_count)", "sum(cd_dep_college_count)", "max(cd_dep_college_count)"], "consumes": ["aggregation"]}
      }
    },
    "reconstruction_order": ["date_filter", "store_customers", "web_customers", "catalog_customers", "or_customers", "customer_base", "aggregation", "main_query"],
    "assembly_template": "WITH date_filter AS ({date_filter}), store_customers AS ({store_customers}), web_customers AS ({web_customers}), catalog_customers AS ({catalog_customers}), or_customers AS ({or_customers}), customer_base AS ({customer_base}), aggregation AS ({aggregation}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Converted correlated EXISTS subqueries into materialized CTEs for each sales channel, sharing a common date filter CTE. This allows each channel's distinct customers to be computed once, then joined via UNION (for web/catalog OR) and INNER JOINs (for mandatory store + OR condition).

Expected speedup: ~2.5–4x due to elimination of per-row correlated subquery execution and materialization of small dimension filter.