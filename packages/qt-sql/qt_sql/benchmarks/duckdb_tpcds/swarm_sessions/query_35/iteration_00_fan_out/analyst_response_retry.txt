### SHARED BRIEFING

**SEMANTIC_CONTRACT**: Profile household dependent metrics by state and customer demographics for customers who purchased in-store during 2001 Q1-Q3 AND also purchased via web OR catalog in the same period. JOINs are INNER (all must match) with EXISTS semi-joins. Aggregation traps: MAX(cd_dep_count) appears twice (lines 7,9) - must preserve duplicate outputs. Filter dependencies: date_dim filters (d_year=2001, d_qoy<4) must apply identically across all sales channels.

**BOTTLENECK_DIAGNOSIS**: Join-bound due to correlated subquery nested loops (DELIM_SCAN) forcing repeated full scans of large fact tables. Row counts: customer (2M) → join fanout → 82K groups. Optimizer handles same-table OR efficiently but cannot decorrelate EXISTS subqueries or push date filters across CTE boundaries. Logical-tree costs mislead - physical plan shows 70% cost in nested loop re-execution.

**ACTIVE_CONSTRAINTS**:  
- COMPLETE_OUTPUT: Must preserve all 19 output columns including duplicate MAX()  
- CTE_COLUMN_COMPLETENESS: Downstream GROUP BY references cd_dep_count, cd_dep_employed_count, cd_dep_college_count  
- LITERAL_PRESERVATION: d_year=2001 and d_qoy<4 must remain unchanged  
- SEMANTIC_EQUIVALENCE: EXISTS semi-join semantics critical for customer filtering  
- CORRELATED_SUBQUERY_PARALYSIS (P2): EXPLAIN shows DELIM_SCAN for sales subqueries  
- CROSS_CTE_PREDICATE_BLINDNESS (P0): Q-Error=ZERO_EST at CTE boundary  

**REGRESSION_WARNINGS**:  
1. Materialized EXISTS (0.14x):  
   CAUSE: Converting EXISTS to materialized CTE destroys semi-join short-circuit  
   RULE: Preserve EXISTS as semi-joins; use WHERE c.c_customer_sk IN (precomputed_keys)  
2. Orphaned CTE (0.49x):  
   CAUSE: Keeping original subquery alongside new CTE causes double materialization  
   RULE: Remove original EXISTS after CTE replacement  

---

### WORKER 1 BRIEFING  

**STRATEGY**: composite_decorrelate_union  
**TARGET_LOGICAL_TREE**:  
date_range → store_customers → web_or_catalog_customers → base_tables_join → filtered_customers → group_by  
**NODE_CONTRACTS**:  
date_range:  
  FROM: date_dim  
  WHERE: d_year = 2001 AND d_qoy < 4  
  OUTPUT: d_date_sk  
  EXPECTED_ROWS: 273 (91 days/quarter * 3 quarters)  
  CONSUMERS: store_customers, web_or_catalog_customers  

store_customers:  
  FROM: store_sales JOIN date_range ON ss_sold_date_sk = d_date_sk  
  OUTPUT: ss_customer_sk  
  EXPECTED_ROWS: 2.8M (SF10 store_sales) → 1.2M distinct  
  CONSUMERS: filtered_customers  

web_or_catalog_customers:  
  FROM: (  
    SELECT ws_bill_customer_sk FROM web_sales JOIN date_range ON ws_sold_date_sk = d_date_sk  
    UNION ALL  
    SELECT cs_ship_customer_sk FROM catalog_sales JOIN date_range ON cs_sold_date_sk = d_date_sk  
  )  
  OUTPUT: customer_sk  
  EXPECTED_ROWS: 1.5M distinct  
  CONSUMERS: filtered_customers  

filtered_customers:  
  FROM: customer c  
    JOIN store_customers sc ON c.c_customer_sk = sc.ss_customer_sk  
    JOIN web_or_catalog_customers wc ON c.c_customer_sk = wc.customer_sk  
    JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk  
    JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk  
  OUTPUT: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count  
  EXPECTED_ROWS: ~120K  
  CONSUMERS: group_by  

group_by:  
  GROUP BY: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count  
  AGGREGATE: count(*) cnt1, max(cd_dep_count), sum(cd_dep_count), ... [all original aggregates]  
  OUTPUT: All 19 original columns  
  EXPECTED_ROWS: ~82K  
  CONSUMERS: order_by  

order_by:  
  ORDER BY: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count  
  LIMIT: 100  

**EXAMPLES**: decorrelate, composite_decorrelate_union  
**EXAMPLE_ADAPTATION**:  
- decorrelate: Use CTE for store_customers but preserve UNION for web/catalog OR  
- composite_decorrelate_union: Apply date_range CTE to all channels  
**HAZARD_FLAGS**:  
- UNION ALL may produce duplicates if customer bought via both web+catalog → use UNION DISTINCT?  
- EXISTS semantics require DISTINCT customer keys in CTEs  

---

### WORKER 2 BRIEFING  

**STRATEGY**: star_join_prefetch  
**TARGET_LOGICAL_TREE**:  
date_range → customer_base → store_filtered → web_or_catalog_filtered → group_by  
**NODE_CONTRACTS**:  
date_range: (same as Worker 1)  

customer_base:  
  FROM: customer c  
    JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk  
    JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk  
  OUTPUT: c_customer_sk, ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count  
  EXPECTED_ROWS: 2M (SF10 customer)  
  CONSUMERS: store_filtered  

store_filtered:  
  FROM: customer_base cb  
  WHERE EXISTS (  
    SELECT 1 FROM store_sales ss JOIN date_range dr ON ss_sold_date_sk = dr.d_date_sk  
    WHERE ss.ss_customer_sk = cb.c_customer_sk  
  )  
  OUTPUT: All customer_base columns  
  EXPECTED_ROWS: ~1.2M  
  CONSUMERS: web_or_catalog_filtered  

web_or_catalog_filtered:  
  FROM: store_filtered sf  
  WHERE EXISTS (  
    SELECT 1 FROM web_sales ws JOIN date_range dr ON ws.ws_sold_date_sk = dr.d_date_sk  
    WHERE ws.ws_bill_customer_sk = sf.c_customer_sk  
  ) OR EXISTS (  
    SELECT 1 FROM catalog_sales cs JOIN date_range dr ON cs.cs_sold_date_sk = dr.d_date_sk  
    WHERE cs.cs_ship_customer_sk = sf.c_customer_sk  
  )  
  OUTPUT: All customer_base columns  
  EXPECTED_ROWS: ~120K  
  CONSUMERS: group_by  

group_by: (same as Worker 1)  

**EXAMPLES**: prefetch_fact_join, dimension_cte_isolate  
**EXAMPLE_ADAPTATION**:  
- prefetch_fact_join: Push date_range to all subqueries but keep EXISTS  
- dimension_cte_isolate: Pre-join customer/address/demographics  
**HAZARD_FLAGS**:  
- OR condition prevents channel consolidation  
- EXISTS preserved to maintain semi-join semantics  

---

### WORKER 3 BRIEFING  

**STRATEGY**: single_pass_aggregation  
**TARGET_LOGICAL_TREE**:  
date_range → multi_channel_agg → base_tables_join → group_by  
**NODE_CONTRACTS**:  
date_range: (same as Worker 1)  

multi_channel_agg:  
  FROM: (  
    SELECT ss_customer_sk AS customer_sk, 1 AS store_flag, 0 AS web_flag, 0 AS catalog_flag  
    FROM store_sales JOIN date_range ON ss_sold_date_sk = d_date_sk  
    UNION ALL  
    SELECT ws_bill_customer_sk, 0, 1, 0 FROM web_sales JOIN date_range ON ws_sold_date_sk = d_date_sk  
    UNION ALL  
    SELECT cs_ship_customer_sk, 0, 0, 1 FROM catalog_sales JOIN date_range ON cs_sold_date_sk = d_date_sk  
  )  
  GROUP BY: customer_sk  
  AGGREGATE: MAX(store_flag) AS bought_store, MAX(web_flag) AS bought_web, MAX(catalog_flag) AS bought_catalog  
  OUTPUT: customer_sk, bought_store, bought_web, bought_catalog  
  EXPECTED_ROWS: ~2.5M distinct  
  CONSUMERS: base_tables_join  

base_tables_join:  
  FROM: multi_channel_agg mca  
    JOIN customer c ON mca.customer_sk = c.c_customer_sk  
    JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk  
    JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk  
  WHERE: bought_store = 1 AND (bought_web = 1 OR bought_catalog = 1)  
  OUTPUT: ca_state, cd_gender, ... [all grouping columns]  
  EXPECTED_ROWS: ~120K  
  CONSUMERS: group_by  

group_by: (same as Worker 1)  

**EXAMPLES**: single_pass_aggregation, channel_bitmap_aggregation  
**EXAMPLE_ADAPTATION**:  
- single_pass_aggregation: Use UNION ALL + MAX flags instead of bitmap  
- channel_bitmap_aggregation: Adapt to MAX() since DuckDB lacks bitmaps  
**HAZARD_FLAGS**:  
- UNION ALL across 3 large fact tables → ensure date_range reduces scans  
- MAX() flags safe for semi-join emulation  

---

### WORKER 4 BRIEFING (EXPLORATION)  

**STRATEGY**: exists_restructuring  
**TARGET_LOGICAL_TREE**:  
date_range → store_customers → web_catalog_intersect → base_tables_join → group_by  
**NODE_CONTRACTS**:  
date_range: (same as Worker 1)  

store_customers: (same as Worker 1)  

web_catalog_intersect:  
  FROM: (  
    SELECT ws_bill_customer_sk AS customer_sk FROM web_sales JOIN date_range ON ws_sold_date_sk = d_date_sk  
    UNION  
    SELECT cs_ship_customer_sk FROM catalog_sales JOIN date_range ON cs_sold_date_sk = d_date_sk  
  )  
  OUTPUT: customer_sk  
  EXPECTED_ROWS: ~1.5M distinct  
  CONSUMERS: base_tables_join  

base_tables_join:  
  FROM: store_customers sc  
    JOIN web_catalog_intersect wci ON sc.ss_customer_sk = wci.customer_sk  
    JOIN customer c ON c.c_customer_sk = sc.ss_customer_sk  
    JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk  
    JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk  
  OUTPUT: All grouping columns  
  EXPECTED_ROWS: ~120K  
  CONSUMERS: group_by  

group_by: (same as Worker 1)  

**EXAMPLES**: intersect_to_exists, multi_intersect_exists_cte  
**EXAMPLE_ADAPTATION**:  
- intersect_to_exists: Replace OR with UNION (set operation)  
- multi_intersect_exists_cte: Use date_range in all CTEs  
**HAZARD_FLAGS**:  
- UNION may change NULL handling vs OR-EXISTS  
- Requires testing edge cases with NULL customer keys  
**CONSTRAINT_OVERRIDE**: None  
**OVERRIDE_REASONING**: N/A - preserves EXISTS via set operations  
**EXPLORATION_TYPE**: novel_combination  
**HYPOTHESIS_TAG**: H2_JOIN_ORDER (replaces correlated loops with set operations)