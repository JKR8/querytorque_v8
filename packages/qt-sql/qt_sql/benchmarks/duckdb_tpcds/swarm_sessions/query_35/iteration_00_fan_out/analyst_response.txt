### SHARED BRIEFING

SEMANTIC_CONTRACT: Profile household dependent metrics by state/demographics for customers who made store purchases in 2001 Q1-Q3 AND (web OR catalog) purchases in same period. INNER JOINs require all customer/address/demographic matches. EXISTS semi-joins require at least one matching sale per channel. Aggregation uses COUNT/MAX/SUM which are duplicate-insensitive. The d_year=2001 and d_qoy<4 filters must propagate identically to all three date_dim references.

BOTTLENECK_DIAGNOSIS: Scan-bound (store_sales: 4406ms, 62% total). Row flow: 806M store_sales → 3.1M filtered → 200K after semi-join. Optimizer handles semi-joins well but repeats identical date_dim scan three times (3x274 rows) and scans three fact tables separately despite identical date filters. Cardinality mismatch at DELIM_SCAN (est=280K, act=0) indicates CTE stats blindness.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must preserve all 19 output columns including counts and aggregates
- CTE_COLUMN_COMPLETENESS: CTEs must include customer_sk for joins and date_sk for filtering
- LITERAL_PRESERVATION: d_year=2001 and d_qoy<4 must remain exact
- SEMANTIC_EQUIVALENCE: EXISTS conditions require semi-join semantics
- P0: Predicate chain pushback - date filters applied late in subqueries
- P1: Repeated scans - date_dim scanned 3x, fact tables scanned separately
- P3: Aggregation after join - group by occurs after large dimension joins

REGRESSION_WARNINGS:
1. Materialize CTE for EXISTS (0.14x regression):
   CAUSE: Materializing EXISTS destroys semi-join short-circuit
   RULE: Preserve EXISTS structure, precompute only keys
2. Split same-column OR (0.23x regression):
   CAUSE: Splitting same-channel OR to UNION forces redundant scans
   RULE: Keep web/catalog OR intact
3. Cross-join 3 dim CTEs (0.0076x regression):
   CAUSE: Cartesian product from isolated dimension CTEs
   RULE: Join dimensions to facts, not to each other

=== WORKER 1 BRIEFING ===

STRATEGY: date_cte_isolate
TARGET_LOGICAL_TREE:
  date_range → store_sales_cte → web_sales_cte → catalog_sales_cte → main_join
NODE_CONTRACTS:
  date_range:
    FROM: date_dim
    WHERE: d_year=2001 AND d_qoy<4
    OUTPUT: d_date_sk
    EXPECTED_ROWS: 274
    CONSUMERS: store_sales_cte, web_sales_cte, catalog_sales_cte

  store_sales_cte:
    FROM: store_sales, date_range
    JOIN: ss_sold_date_sk = d_date_sk
    OUTPUT: ss_customer_sk
    EXPECTED_ROWS: 200K
    CONSUMERS: main_join

  web_sales_cte:
    FROM: web_sales, date_range
    JOIN: ws_sold_date_sk = d_date_sk
    OUTPUT: ws_bill_customer_sk
    EXPECTED_ROWS: 200K
    CONSUMERS: main_join

  catalog_sales_cte:
    FROM: catalog_sales, date_range
    JOIN: cs_sold_date_sk = d_date_sk
    OUTPUT: cs_ship_customer_sk
    EXPECTED_ROWS: 200K
    CONSUMERS: main_join

  main_join:
    FROM: customer c, customer_address ca, customer_demographics, store_sales_cte st, web_sales_cte ws, catalog_sales_cte cs
    JOIN: c.c_current_addr_sk=ca.ca_address_sk 
      AND cd_demo_sk=c.c_current_cdemo_sk
      AND c.c_customer_sk=st.ss_customer_sk
      AND (c.c_customer_sk=ws.ws_bill_customer_sk OR c.c_customer_sk=cs.cs_ship_customer_sk)
    GROUP BY: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count
    OUTPUT: All original SELECT columns
    EXPECTED_ROWS: 58K
    CONSUMERS: ORDER/LIMIT
EXAMPLES: date_cte_isolate, prefetch_fact_join
EXAMPLE_ADAPTATION: 
  - date_cte_isolate: Replicate date_range CTE
  - prefetch_fact_join: Prefilter facts but keep OR condition
HAZARD_FLAGS:
- OR condition may force full scan of web/catalog CTEs

=== WORKER 2 BRIEFING ===

STRATEGY: single_pass_aggregation
TARGET_LOGICAL_TREE:
  date_range → multi_channel_cte → main_join
NODE_CONTRACTS:
  date_range: (same as Worker 1)
  multi_channel_cte:
    FROM: 
      (SELECT ss_customer_sk AS cust_sk, 'store' AS channel FROM store_sales, date_range WHERE ss_sold_date_sk=d_date_sk)
      UNION ALL
      (SELECT ws_bill_customer_sk, 'web' FROM web_sales, date_range WHERE ws_sold_date_sk=d_date_sk)
      UNION ALL
      (SELECT cs_ship_customer_sk, 'catalog' FROM catalog_sales, date_range WHERE cs_sold_date_sk=d_date_sk)
    OUTPUT: cust_sk, channel
    EXPECTED_ROWS: 600K
    CONSUMERS: main_join
  main_join:
    FROM: customer c, customer_address ca, customer_demographics
    JOIN: c.c_current_addr_sk=ca.ca_address_sk 
      AND cd_demo_sk=c.c_current_cdemo_sk
    WHERE: EXISTS (SELECT 1 FROM multi_channel_cte m 
                  WHERE m.cust_sk=c.c_customer_sk AND m.channel='store')
      AND EXISTS (SELECT 1 FROM multi_channel_cte m 
                  WHERE m.cust_sk=c.c_customer_sk AND (m.channel='web' OR m.channel='catalog'))
    GROUP BY: (same as original)
    OUTPUT: (same as original)
    EXPECTED_ROWS: 58K
    CONSUMERS: ORDER/LIMIT
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation
EXAMPLE_ADAPTATION:
  - single_pass_aggregation: Consolidate scans but preserve EXISTS
  - channel_bitmap_aggregation: Use channel tags instead of bitmaps
HAZARD_FLAGS:
- UNION ALL may materialize duplicate customer-channel pairs

=== WORKER 3 BRIEFING ===

STRATEGY: star_join_prefetch
TARGET_LOGICAL_TREE:
  date_range → filtered_customers → main_agg
NODE_CONTRACTS:
  date_range: (same as Worker 1)
  filtered_customers:
    FROM: customer c
    WHERE: EXISTS (store_sales subquery) 
      AND (EXISTS (web_sales subquery) OR EXISTS (catalog_sales subquery))
    OUTPUT: c.*
    EXPECTED_ROWS: 50K
    CONSUMERS: main_agg
  main_agg:
    FROM: filtered_customers c, customer_address ca, customer_demographics
    JOIN: c.c_current_addr_sk=ca.ca_address_sk 
      AND cd_demo_sk=c.c_current_cdemo_sk
    GROUP BY: (same as original)
    OUTPUT: (same as original)
    EXPECTED_ROWS: 58K
    CONSUMERS: ORDER/LIMIT
EXAMPLES: star_join_prefetch, dimension_cte_isolate
EXAMPLE_ADAPTATION:
  - star_join_prefetch: Push customer filtering before dimensions
  - dimension_cte_isolate: Join dimensions after customer filtering
HAZARD_FLAGS:
- EXISTS subqueries may re-scan facts without date_range benefit

=== WORKER 4 BRIEFING ===

STRATEGY: composite_decorrelate_union
TARGET_LOGICAL_TREE:
  date_range → store_customers → web_customers → catalog_customers → combined_customers → main_agg
NODE_CONTRACTS:
  date_range: (same as Worker 1)
  store_customers:
    FROM: store_sales, date_range
    JOIN: ss_sold_date_sk=d_date_sk
    GROUP BY: ss_customer_sk
    OUTPUT: ss_customer_sk
    EXPECTED_ROWS: 180K
    CONSUMERS: combined_customers
  web_customers: (similar for web_sales)
  catalog_customers: (similar for catalog_sales)
  combined_customers:
    FROM: store_customers st
      LEFT JOIN web_customers ws ON st.ss_customer_sk=ws.ws_bill_customer_sk
      LEFT JOIN catalog_customers cs ON st.ss_customer_sk=cs.cs_ship_customer_sk
    WHERE: ws.ws_bill_customer_sk IS NOT NULL OR cs.cs_ship_customer_sk IS NOT NULL
    OUTPUT: st.ss_customer_sk
    EXPECTED_ROWS: 50K
    CONSUMERS: main_agg
  main_agg:
    FROM: combined_customers cc, customer c, customer_address ca, customer_demographics
    JOIN: cc.ss_customer_sk=c.c_customer_sk
      AND c.c_current_addr_sk=ca.ca_address_sk
      AND cd_demo_sk=c.c_current_cdemo_sk
    GROUP BY: (same as original)
    OUTPUT: (same as original)
    EXPECTED_ROWS: 58K
    CONSUMERS: ORDER/LIMIT
EXAMPLES: composite_decorrelate_union, prefetch_fact_join
EXAMPLE_ADAPTATION: 
  - composite_decorrelate_union: Pre-aggregate customers per channel
  - prefetch_fact_join: Use date_range in all fact CTEs
HAZARD_FLAGS:
- LEFT JOIN + OR condition may force full outer scan
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: Maintains EXISTS via LEFT JOIN/IS NOT NULL semantics
EXPLORATION_TYPE: compound_strategy
HYPOTHESIS_TAG: H1_CTE_PREDICATE_FENCE + H2_JOIN_ORDER