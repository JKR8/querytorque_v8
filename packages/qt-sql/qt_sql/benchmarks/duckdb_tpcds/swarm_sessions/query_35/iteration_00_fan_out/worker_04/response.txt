### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_range [=]
├── [CTE] store_customers [=]
├── [CTE] web_catalog_intersect [~]  # Replaced OR-EXISTS with UNION
└── [MAIN] main_query [~]  # Replaced EXISTS with CTE joins
    ├── FROM: store_customers sc
    ├── JOIN: web_catalog_intersect wci
    ├── JOIN: customer c
    ├── JOIN: customer_address ca
    ├── JOIN: customer_demographics cd
    ├── AGG (GROUP BY): ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count
    ├── SORT: ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count
    └── OUTPUT: 18 columns (preserved duplicates)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "exists_to_cte", "description": "Convert OR-EXISTS to materialized UNION CTE", "applied_to": ["web_catalog_intersect"]},
    {"id": "R2", "type": "cte_materialization", "description": "Replace correlated subqueries with date-filtered CTEs", "applied_to": ["date_range", "store_customers", "web_catalog_intersect"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_range": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_qoy < 4",
        "interfaces": {
          "outputs": ["d_date_sk"],
          "consumes": []
        }
      },
      "store_customers": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT DISTINCT ss_customer_sk FROM store_sales JOIN date_range ON ss_sold_date_sk = d_date_sk",
        "interfaces": {
          "outputs": ["ss_customer_sk"],
          "consumes": ["date_range"]
        }
      },
      "web_catalog_intersect": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ws_bill_customer_sk AS customer_sk FROM web_sales JOIN date_range ON ws_sold_date_sk = d_date_sk UNION SELECT cs_ship_customer_sk AS customer_sk FROM catalog_sales JOIN date_range ON cs_sold_date_sk = d_date_sk",
        "interfaces": {
          "outputs": ["customer_sk"],
          "consumes": ["date_range"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, COUNT(*) AS cnt1, MAX(cd.cd_dep_count), SUM(cd.cd_dep_count), MAX(cd.cd_dep_count), cd.cd_dep_employed_count, COUNT(*) AS cnt2, MAX(cd.cd_dep_employed_count), SUM(cd.cd_dep_employed_count), MAX(cd.cd_dep_employed_count), cd.cd_dep_college_count, COUNT(*) AS cnt3, MAX(cd.cd_dep_college_count), SUM(cd.cd_dep_college_count), MAX(cd.cd_dep_college_count) FROM store_customers sc JOIN web_catalog_intersect wci ON sc.ss_customer_sk = wci.customer_sk JOIN customer c ON c.c_customer_sk = sc.ss_customer_sk JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk GROUP BY ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count ORDER BY ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count LIMIT 100",
        "interfaces": {
          "outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cnt1", "max(cd_dep_count)", "sum(cd_dep_count)", "max(cd_dep_count)", "cd_dep_employed_count", "cnt2", "max(cd_dep_employed_count)", "sum(cd_dep_employed_count)", "max(cd_dep_employed_count)", "cd_dep_college_count", "cnt3", "max(cd_dep_college_count)", "sum(cd_dep_college_count)", "max(cd_dep_college_count)"],
          "consumes": ["store_customers", "web_catalog_intersect"]
        }
      }
    },
    "reconstruction_order": ["date_range", "store_customers", "web_catalog_intersect", "main_query"],
    "assembly_template": "WITH date_range AS ({date_range}), store_customers AS ({store_customers}), web_catalog_intersect AS ({web_catalog_intersect}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Changes Explanation
Replaced OR-EXISTS conditions with materialized CTE using UNION to preserve semi-join semantics while enabling predicate pushdown. The date_range CTE centralizes date filtering, and store_customers/web_catalog_intersect CTEs materialize distinct customer keys. The main query joins these CTEs directly to customer tables, preserving all original output columns including duplicate MAX() expressions.

Expected speedup: 1.8-2.4x (based on similar patterns in reference examples) due to eliminated correlated subqueries, centralized date filtering, and optimized hash joins.