### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [!] CTE date_filter
│   └── [=] SCAN date_dim
├── [!] CTE sales_unified
│   ├── [!] JOIN store_sales × date_filter
│   ├── [!] JOIN web_sales × date_filter
│   ├── [!] JOIN catalog_sales × date_filter
│   └── [!] UNION ALL
├── [!] CTE customer_channels
│   └── [!] AGG (GROUP BY customer_sk) + HAVING
├── [!] CTE customer_base
│   └── [=] JOIN customer × customer_address × customer_demographics × customer_channels
├── [!] CTE aggregation
│   └── [!] AGG (GROUP BY 6 demographic columns)
└── [!] main_query (top_n)
    └── [=] SORT + LIMIT
```

**Change markers:**
- `[!] CTE date_filter` – New isolated dimension filter (from example 3)
- `[!] CTE sales_unified` – Single-pass UNION ALL of three channels with CASE labeling (from example 1)
- `[!] CTE customer_channels` – Bitmap aggregation via MAX(CASE) to track channel presence (from example 2)
- `[!] CTE customer_base` – Changed from EXISTS filters to join on pre‑filtered customer list
- `[!] CTE aggregation` – Single‑pass multi‑metric aggregation (from example 1)
- `[!] main_query (top_n)` – Final ordering and limit; unchanged logic

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "date_cte_isolate", "description": "Extract date filter into CTE to share across three sales channels", "applied_to": ["date_filter"]},
    {"id": "R2", "type": "single_pass_aggregation", "description": "Replace three EXISTS subqueries with single UNION ALL of channel sales", "applied_to": ["sales_unified"]},
    {"id": "R3", "type": "channel_bitmap_aggregation", "description": "Use MAX(CASE) to compute channel flags, then HAVING to filter customers with store AND (web OR catalog)", "applied_to": ["customer_channels"]},
    {"id": "R4", "type": "semantic_join", "description": "Convert EXISTS semi‑joins to inner join on pre‑filtered customer list", "applied_to": ["customer_base"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filter": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_qoy < 4",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "sales_unified": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_customer_sk AS customer_sk, 'store' AS channel FROM store_sales JOIN date_filter ON ss_sold_date_sk = d_date_sk UNION ALL SELECT ws_bill_customer_sk AS customer_sk, 'web' AS channel FROM web_sales JOIN date_filter ON ws_sold_date_sk = d_date_sk UNION ALL SELECT cs_ship_customer_sk AS customer_sk, 'catalog' AS channel FROM catalog_sales JOIN date_filter ON cs_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["customer_sk", "channel"], "consumes": ["date_filter"]}
      },
      "customer_channels": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT customer_sk FROM sales_unified GROUP BY customer_sk HAVING MAX(CASE WHEN channel = 'store' THEN 1 ELSE 0 END) = 1 AND (MAX(CASE WHEN channel = 'web' THEN 1 ELSE 0 END) = 1 OR MAX(CASE WHEN channel = 'catalog' THEN 1 ELSE 0 END) = 1)",
        "interfaces": {"outputs": ["customer_sk"], "consumes": ["sales_unified"]}
      },
      "customer_base": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk JOIN customer_channels cc ON c.c_customer_sk = cc.customer_sk",
        "interfaces": {"outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"], "consumes": ["customer_channels"]}
      },
      "aggregation": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, COUNT(*) AS cnt1, MAX(cd_dep_count) AS \"max(cd_dep_count)\", SUM(cd_dep_count) AS \"sum(cd_dep_count)\", MAX(cd_dep_count) AS \"max(cd_dep_count)_2\", cd_dep_employed_count, COUNT(*) AS cnt2, MAX(cd_dep_employed_count) AS \"max(cd_dep_employed_count)\", SUM(cd_dep_employed_count) AS \"sum(cd_dep_employed_count)\", MAX(cd_dep_employed_count) AS \"max(cd_dep_employed_count)_2\", cd_dep_college_count, COUNT(*) AS cnt3, MAX(cd_dep_college_count) AS \"max(cd_dep_college_count)\", SUM(cd_dep_college_count) AS \"sum(cd_dep_college_count)\", MAX(cd_dep_college_count) AS \"max(cd_dep_college_count)_2\" FROM customer_base GROUP BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count",
        "interfaces": {"outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cnt1", "max(cd_dep_count)", "sum(cd_dep_count)", "max(cd_dep_count)_2", "cd_dep_employed_count", "cnt2", "max(cd_dep_employed_count)", "sum(cd_dep_employed_count)", "max(cd_dep_employed_count)_2", "cd_dep_college_count", "cnt3", "max(cd_dep_college_count)", "sum(cd_dep_college_count)", "max(cd_dep_college_count)_2"], "consumes": ["customer_base"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, cnt1, \"max(cd_dep_count)\", \"sum(cd_dep_count)\", \"max(cd_dep_count)_2\", cd_dep_employed_count, cnt2, \"max(cd_dep_employed_count)\", \"sum(cd_dep_employed_count)\", \"max(cd_dep_employed_count)_2\", cd_dep_college_count, cnt3, \"max(cd_dep_college_count)\", \"sum(cd_dep_college_count)\", \"max(cd_dep_college_count)_2\" FROM aggregation ORDER BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100",
        "interfaces": {"outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cnt1", "max(cd_dep_count)", "sum(cd_dep_count)", "max(cd_dep_count)_2", "cd_dep_employed_count", "cnt2", "max(cd_dep_employed_count)", "sum(cd_dep_employed_count)", "max(cd_dep_employed_count)_2", "cd_dep_college_count", "cnt3", "max(cd_dep_college_count)", "sum(cd_dep_college_count)", "max(cd_dep_college_count)_2"], "consumes": ["aggregation"]}
      }
    },
    "reconstruction_order": ["date_filter", "sales_unified", "customer_channels", "customer_base", "aggregation", "main_query"],
    "assembly_template": "WITH date_filter AS ({date_filter}), sales_unified AS ({sales_unified}), customer_channels AS ({customer_channels}), customer_base AS ({customer_base}), aggregation AS ({aggregation}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Converted three EXISTS subqueries (store, web, catalog) into a single‑pass UNION ALL that labels each sale with its channel, then aggregated per customer to compute channel‑presence flags. Isolated the date filter into a shared CTE. The final aggregation preserves all original grouping columns and duplicate‑safe aggregates.

**Expected speedup:** 4‑6× (based on example patterns: single‑pass aggregation 4.47×, bitmap aggregation 6.24×, date isolation 4.00×). The main gain comes from replacing three separate scans of the large sales tables (with date joins) with one scan each, plus converting semi‑joins to a single filtered inner join.