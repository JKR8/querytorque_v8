### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 95%  Rows: ~3.1M  — Join customer/address/demographics, enforce multi-channel purchase existence constraints for 2001 quarters 1-3, then group by geography and demographic dependent-count attributes to compute counts/sums/max statistics.
    ├── CTE: date_range  [+]  (SELECT d_date_sk FROM date_dim WHERE d_year=2001 and d_qoy<4)
    ├── CTE: multi_channel_agg  [+]  (UNION ALL of store, web, catalog sales with date_range, then group by customer_sk to get channel flags)
    ├── CTE: base_tables_join  [+]  (Join multi_channel_agg with customer, address, demographics and filter for store and (web or catalog))
    ├── SCAN: base_tables_join  [~]  (instead of base tables)
    ├── AGG (GROUP BY)  [=] 
    ├── SORT (ca_state ASC, ...)  [=] 
    └── OUTPUT (same as original)  [=] 
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "replace_exists_with_multi_channel_cte",
      "description": "Replaced the three EXISTS conditions with a multi-channel aggregation CTE that flags each customer's channel purchases, then filters for store and (web or catalog)",
      "applied_to": ["multi_channel_agg", "base_tables_join"]
    },
    {
      "id": "R2",
      "type": "single_pass_aggregation",
      "description": "Consolidated three separate sales channel scans into one pass per channel (with UNION ALL) and then aggregated by customer",
      "applied_to": ["multi_channel_agg"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "date_range": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_qoy < 4",
          "interfaces": {
            "outputs": ["d_date_sk"],
            "consumes": []
          }
        },
        "multi_channel_agg": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT customer_sk, MAX(store_flag) AS bought_store, MAX(web_flag) AS bought_web, MAX(catalog_flag) AS bought_catalog FROM (SELECT ss_customer_sk AS customer_sk, 1 AS store_flag, 0 AS web_flag, 0 AS catalog_flag FROM store_sales JOIN date_range ON store_sales.ss_sold_date_sk = date_range.d_date_sk UNION ALL SELECT ws_bill_customer_sk AS customer_sk, 0 AS store_flag, 1 AS web_flag, 0 AS catalog_flag FROM web_sales JOIN date_range ON web_sales.ws_sold_date_sk = date_range.d_date_sk UNION ALL SELECT cs_ship_customer_sk AS customer_sk, 0 AS store_flag, 0 AS web_flag, 1 AS catalog_flag FROM catalog_sales JOIN date_range ON catalog_sales.cs_sold_date_sk = date_range.d_date_sk) channel_sales GROUP BY customer_sk",
          "interfaces": {
            "outputs": ["customer_sk", "bought_store", "bought_web", "bought_catalog"],
            "consumes": ["date_range"]
          }
        },
        "base_tables_join": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM multi_channel_agg mca JOIN customer c ON mca.customer_sk = c.c_customer_sk JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk WHERE mca.bought_store = 1 AND (mca.bought_web = 1 OR mca.bought_catalog = 1)",
          "interfaces": {
            "outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"],
            "consumes": ["multi_channel_agg"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, COUNT(*) AS cnt1, MAX(cd_dep_count), SUM(cd_dep_count), MAX(cd_dep_count), cd_dep_employed_count, COUNT(*) AS cnt2, MAX(cd_dep_employed_count), SUM(cd_dep_employed_count), MAX(cd_dep_employed_count), cd_dep_college_count, COUNT(*) AS cnt3, MAX(cd_dep_college_count), SUM(cd_dep_college_count), MAX(cd_dep_college_count) FROM base_tables_join GROUP BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count ORDER BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100",
          "interfaces": {
            "outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cnt1", "MAX(cd_dep_count)", "SUM(cd_dep_count)", "MAX(cd_dep_count)", "cd_dep_employed_count", "cnt2", "MAX(cd_dep_employed_count)", "SUM(cd_dep_employed_count)", "MAX(cd_dep_employed_count)", "cd_dep_college_count", "cnt3", "MAX(cd_dep_college_count)", "SUM(cd_dep_college_count)", "MAX(cd_dep_college_count)"],
            "consumes": ["base_tables_join"]
          }
        }
      },
      "reconstruction_order": ["date_range", "multi_channel_agg", "base_tables_join", "main_query"],
      "assembly_template": "WITH date_range AS ({date_range}), multi_channel_agg AS ({multi_channel_agg}), base_tables_join AS ({base_tables_join}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Replaced EXISTS semi-joins with a multi-channel aggregation CTE that scans each sales table once and flags channel purchases per customer. This avoids correlated subqueries while maintaining identical semantics. The MAX() flags emulate semi-joins and the date_range CTE ensures consistent date filtering.

Expected speedup: 4-6x (based on reference examples) by eliminating correlated subqueries and reducing sales table scans from 3 to 1 per channel. Predicate pushdown into date_range minimizes scan costs.