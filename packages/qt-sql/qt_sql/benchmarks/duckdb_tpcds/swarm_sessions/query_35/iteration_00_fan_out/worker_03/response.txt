### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Replaces EXISTS with materialized CTE set operations (date_filter → store_exists/web_exists/catalog_exists) → UNION+INTERSECT → aggregation.
    ├── WITH date_filter  [+]  Cost: 0%  Rows: 274  — Materialized once, probed by three sales channels
    │   └── SCAN date_dim  [=]  WHERE d_year=2001 AND d_qoy<4
    ├── WITH store_exists  [+]  Cost: 0%  Rows: ~200K  — Customer+address+demographics+store_sales join (inner)
    │   └── JOIN customer, address, demographics, store_sales, date_filter
    ├── WITH web_exists  [+]  Cost: 0%  Rows: ~324K  — Customer+address+demographics+web_sales join (inner)
    │   └── JOIN customer, address, demographics, web_sales, date_filter
    ├── WITH catalog_exists  [+]  Cost: 0%  Rows: ~635K  — Customer+address+demographics+catalog_sales join (inner)
    │   └── JOIN customer, address, demographics, catalog_sales, date_filter
    ├── WITH customer_base_union  [+]  Cost: 0%  Rows: ~200K  — INTERSECT between store_exists and UNION of web_exists/catalog_exists
    │   └── SET_OP (INTERSECT, UNION)
    └── SELECT (aggregation + top_n)  [~]  — Group by demographic columns from customer_base_union
        ├── AGG (GROUP BY)  [=] 
        ├── SORT (original order keys)  [=] 
        └── OUTPUT (19 columns)  [=] 
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "date_cte_isolate", "description": "Extract date filter into reusable CTE to avoid triple scan", "applied_to": ["date_filter"]},
    {"id": "R2", "type": "or_to_union", "description": "Split web OR catalog into separate CTE branches (different tables)", "applied_to": ["web_exists", "catalog_exists"]},
    {"id": "R3", "type": "intersect_to_exists", "description": "Replace EXISTS semi‑joins with explicit INTERSECT of materialized CTEs", "applied_to": ["customer_base_union"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filter": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_qoy < 4",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_exists": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk JOIN store_sales ss ON c.c_customer_sk = ss.ss_customer_sk JOIN date_filter df ON ss.ss_sold_date_sk = df.d_date_sk",
        "interfaces": {"outputs": ["c_customer_sk", "ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"], "consumes": ["date_filter"]}
      },
      "web_exists": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk JOIN web_sales ws ON c.c_customer_sk = ws.ws_bill_customer_sk JOIN date_filter df ON ws.ws_sold_date_sk = df.d_date_sk",
        "interfaces": {"outputs": ["c_customer_sk", "ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"], "consumes": ["date_filter"]}
      },
      "catalog_exists": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_sk, ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk JOIN catalog_sales cs ON c.c_customer_sk = cs.cs_ship_customer_sk JOIN date_filter df ON cs.cs_sold_date_sk = df.d_date_sk",
        "interfaces": {"outputs": ["c_customer_sk", "ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"], "consumes": ["date_filter"]}
      },
      "customer_base_union": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT * FROM store_exists INTERSECT (SELECT * FROM web_exists UNION SELECT * FROM catalog_exists)",
        "interfaces": {"outputs": ["c_customer_sk", "ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"], "consumes": ["store_exists", "web_exists", "catalog_exists"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, COUNT(*) cnt1, MAX(cd_dep_count), SUM(cd_dep_count), MAX(cd_dep_count), cd_dep_employed_count, COUNT(*) cnt2, MAX(cd_dep_employed_count), SUM(cd_dep_employed_count), MAX(cd_dep_employed_count), cd_dep_college_count, COUNT(*) cnt3, MAX(cd_dep_college_count), SUM(cd_dep_college_count), MAX(cd_dep_college_count) FROM customer_base_union GROUP BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count ORDER BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100",
        "interfaces": {"outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cnt1", "MAX(cd_dep_count)", "SUM(cd_dep_count)", "MAX(cd_dep_count)", "cd_dep_employed_count", "cnt2", "MAX(cd_dep_employed_count)", "SUM(cd_dep_employed_count)", "MAX(cd_dep_employed_count)", "cd_dep_college_count", "cnt3", "MAX(cd_dep_college_count)", "SUM(cd_dep_college_count)", "MAX(cd_dep_college_count)"], "consumes": ["customer_base_union"]}
      }
    },
    "reconstruction_order": ["date_filter", "store_exists", "web_exists", "catalog_exists", "customer_base_union", "main_query"],
    "assembly_template": "WITH date_filter AS ({date_filter}), store_exists AS ({store_exists}), web_exists AS ({web_exists}), catalog_exists AS ({catalog_exists}), customer_base_union AS ({customer_base_union}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Changes: Replace EXISTS semi‑joins with materialized CTE pattern (date_filter → store/web/catalog_exists → INTERSECT/UNION). The date filter is isolated into a tiny CTE, each sales channel joins independently, and the customer set is built via INTERSECT (store) and UNION (web or catalog).

**Expected speedup:** 1.8–4.0x (date_cte_isolate + or_to_union gains, minus INTERSECT materialization cost). The biggest win is avoiding triple date_dim scan and allowing separate join plans per channel.