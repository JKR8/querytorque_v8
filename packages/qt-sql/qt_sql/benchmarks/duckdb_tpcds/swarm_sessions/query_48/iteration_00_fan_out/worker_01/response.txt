**Part 1: Modified Logic Tree**

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: 1 — UNION ALL of three branches with early-filtered dimensions, then aggregate.
    ├── [CTE] date_dim_cte  [+]  — Filter date_dim for 1999, output d_date_sk.
    ├── [CTE] store_cte  [+]  — Filter store where s_store_sk ≤ 100, output s_store_sk.
    ├── [CTE] customer_address_cte  [+]  — Filter address for United States and 9 states, output ca_address_sk, ca_state.
    ├── [CTE] store_sales_branch1  [+]  — Join store_sales with three dimension CTEs; filter price 100-150 and (state/profit OR group).
    ├── [CTE] store_sales_branch2  [+]  — Same join; filter price 50-100 and (state/profit OR group).
    ├── [CTE] store_sales_branch3  [+]  — Same join; filter price 150-200 and (state/profit OR group).
    ├── [CTE] union_all  [+]  — UNION ALL of three branches.
    └── [CTE] final_aggregation  [+]  — SUM(ss_quantity) over union_all.
```

**Part 2: Component Payload JSON**

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter", "description": "Push dimension filters into CTEs before joining to fact table.", "applied_to": ["date_dim_cte", "store_cte", "customer_address_cte"]},
    {"id": "R2", "type": "or_to_union", "description": "Split ORs on demographic/price columns into three UNION ALL branches, each scanning store_sales once with focused predicates.", "applied_to": ["store_sales_branch1", "store_sales_branch2", "store_sales_branch3"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_dim_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT s_store_sk FROM store WHERE s_store_sk <= 100",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "customer_address_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ca_address_sk, ca_state FROM customer_address WHERE ca_country = 'United States' AND ca_state IN ('MD','MN','IA','VA','IL','TX','MI','WI','IN')",
        "interfaces": {"outputs": ["ca_address_sk", "ca_state"], "consumes": []}
      },
      "store_sales_branch1": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss.ss_quantity FROM store_sales ss INNER JOIN date_dim_cte d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN store_cte s ON ss.ss_store_sk = s.s_store_sk INNER JOIN customer_address_cte ca ON ss.ss_addr_sk = ca.ca_address_sk WHERE ss.ss_sales_price BETWEEN 100.00 AND 150.00 AND ((ca.ca_state IN ('MD','MN','IA') AND ss.ss_net_profit BETWEEN 0 AND 2000) OR (ca.ca_state IN ('VA','IL','TX') AND ss.ss_net_profit BETWEEN 150 AND 3000) OR (ca.ca_state IN ('MI','WI','IN') AND ss.ss_net_profit BETWEEN 50 AND 25000))",
        "interfaces": {"outputs": ["ss_quantity"], "consumes": ["date_dim_cte", "store_cte", "customer_address_cte"]}
      },
      "store_sales_branch2": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss.ss_quantity FROM store_sales ss INNER JOIN date_dim_cte d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN store_cte s ON ss.ss_store_sk = s.s_store_sk INNER JOIN customer_address_cte ca ON ss.ss_addr_sk = ca.ca_address_sk WHERE ss.ss_sales_price BETWEEN 50.00 AND 100.00 AND ((ca.ca_state IN ('MD','MN','IA') AND ss.ss_net_profit BETWEEN 0 AND 2000) OR (ca.ca_state IN ('VA','IL','TX') AND ss.ss_net_profit BETWEEN 150 AND 3000) OR (ca.ca_state IN ('MI','WI','IN') AND ss.ss_net_profit BETWEEN 50 AND 25000))",
        "interfaces": {"outputs": ["ss_quantity"], "consumes": ["date_dim_cte", "store_cte", "customer_address_cte"]}
      },
      "store_sales_branch3": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss.ss_quantity FROM store_sales ss INNER JOIN date_dim_cte d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN store_cte s ON ss.ss_store_sk = s.s_store_sk INNER JOIN customer_address_cte ca ON ss.ss_addr_sk = ca.ca_address_sk WHERE ss.ss_sales_price BETWEEN 150.00 AND 200.00 AND ((ca.ca_state IN ('MD','MN','IA') AND ss.ss_net_profit BETWEEN 0 AND 2000) OR (ca.ca_state IN ('VA','IL','TX') AND ss.ss_net_profit BETWEEN 150 AND 3000) OR (ca.ca_state IN ('MI','WI','IN') AND ss.ss_net_profit BETWEEN 50 AND 25000))",
        "interfaces": {"outputs": ["ss_quantity"], "consumes": ["date_dim_cte", "store_cte", "customer_address_cte"]}
      },
      "union_all": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_quantity FROM store_sales_branch1 UNION ALL SELECT ss_quantity FROM store_sales_branch2 UNION ALL SELECT ss_quantity FROM store_sales_branch3",
        "interfaces": {"outputs": ["ss_quantity"], "consumes": ["store_sales_branch1", "store_sales_branch2", "store_sales_branch3"]}
      },
      "final_aggregation": {
        "type": "main_query",
        "change": "added",
        "sql": "SELECT SUM(ss_quantity) AS total_quantity FROM union_all",
        "interfaces": {"outputs": ["total_quantity"], "consumes": ["union_all"]}
      }
    },
    "reconstruction_order": ["date_dim_cte", "store_cte", "customer_address_cte", "store_sales_branch1", "store_sales_branch2", "store_sales_branch3", "union_all", "final_aggregation"],
    "assembly_template": "WITH date_dim_cte AS ({date_dim_cte}), store_cte AS ({store_cte}), customer_address_cte AS ({customer_address_cte}), store_sales_branch1 AS ({store_sales_branch1}), store_sales_branch2 AS ({store_sales_branch2}), store_sales_branch3 AS ({store_sales_branch3}), union_all AS ({union_all}) {final_aggregation}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured the original flat join into early‑filtered dimension CTEs and three UNION ALL branches, each scanning store_sales once with a distinct price range while preserving the original state/profit OR conditions within each branch. This allows DuckDB to push the price filter into each fact scan and use different access patterns per branch.

**Expected speedup:** ~3x (due to splitting the OR on different columns into separate branches, each with a focused fact scan).