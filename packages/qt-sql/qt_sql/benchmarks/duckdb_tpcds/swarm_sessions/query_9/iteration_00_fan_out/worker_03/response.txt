## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── bucket1_cte [~] Cost: 20%  Rows: 1  — Aggregate for quantity 1-20
│   └── SCAN store_sales [~]  (filter: ss_quantity between 1 and 20)
├── bucket2_cte [~] Cost: 20%  Rows: 1  — Aggregate for quantity 21-40
│   └── SCAN store_sales [~]  (filter: ss_quantity between 21 and 40)
├── bucket3_cte [~] Cost: 20%  Rows: 1  — Aggregate for quantity 41-60
│   └── SCAN store_sales [~]  (filter: ss_quantity between 41 and 60)
├── bucket4_cte [~] Cost: 20%  Rows: 1  — Aggregate for quantity 61-80
│   └── SCAN store_sales [~]  (filter: ss_quantity between 61 and 80)
├── bucket5_cte [~] Cost: 20%  Rows: 1  — Aggregate for quantity 81-100
│   └── SCAN store_sales [~]  (filter: ss_quantity between 81 and 100)
└── main_select [~] Cost: 0%  Rows: 1  — Cross join all CTEs with reason filter
    ├── SCAN reason [=]
    ├── FILTER (r_reason_sk = 1)
    ├── CROSS JOIN bucket1_cte [~]
    ├── CROSS JOIN bucket2_cte [~]
    ├── CROSS JOIN bucket3_cte [~]
    ├── CROSS JOIN bucket4_cte [~]
    └── CROSS JOIN bucket5_cte [~]
```

**Change markers:**
- `[~]` All CTEs and main_select modified: restructured from correlated scalar subqueries to explicit CTEs with cross joins, preserving exact aggregation logic and thresholds.

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb_v1.4.3",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_specialization", "description": "Split original correlated scalar subqueries into five specialized CTEs, each with its quantity filter embedded.", "applied_to": ["bucket1_cte", "bucket2_cte", "bucket3_cte", "bucket4_cte", "bucket5_cte"]},
    {"id": "R2", "type": "cross_join_consolidation", "description": "Replace repeated scalar subqueries with single cross joins of CTEs, preserving one-row semantics.", "applied_to": ["main_select"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "bucket1_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext, AVG(ss_net_profit) AS avg_net FROM store_sales WHERE ss_quantity BETWEEN 1 AND 20",
        "interfaces": {"outputs": ["cnt", "avg_ext", "avg_net"], "consumes": []}
      },
      "bucket2_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext, AVG(ss_net_profit) AS avg_net FROM store_sales WHERE ss_quantity BETWEEN 21 AND 40",
        "interfaces": {"outputs": ["cnt", "avg_ext", "avg_net"], "consumes": []}
      },
      "bucket3_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext, AVG(ss_net_profit) AS avg_net FROM store_sales WHERE ss_quantity BETWEEN 41 AND 60",
        "interfaces": {"outputs": ["cnt", "avg_ext", "avg_net"], "consumes": []}
      },
      "bucket4_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext, AVG(ss_net_profit) AS avg_net FROM store_sales WHERE ss_quantity BETWEEN 61 AND 80",
        "interfaces": {"outputs": ["cnt", "avg_ext", "avg_net"], "consumes": []}
      },
      "bucket5_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT COUNT(*) AS cnt, AVG(ss_ext_sales_price) AS avg_ext, AVG(ss_net_profit) AS avg_net FROM store_sales WHERE ss_quantity BETWEEN 81 AND 100",
        "interfaces": {"outputs": ["cnt", "avg_ext", "avg_net"], "consumes": []}
      },
      "main_select": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT CASE WHEN bucket1_cte.cnt > 2972190 THEN bucket1_cte.avg_ext ELSE bucket1_cte.avg_net END AS bucket1, CASE WHEN bucket2_cte.cnt > 4505785 THEN bucket2_cte.avg_ext ELSE bucket2_cte.avg_net END AS bucket2, CASE WHEN bucket3_cte.cnt > 1575726 THEN bucket3_cte.avg_ext ELSE bucket3_cte.avg_net END AS bucket3, CASE WHEN bucket4_cte.cnt > 3188917 THEN bucket4_cte.avg_ext ELSE bucket4_cte.avg_net END AS bucket4, CASE WHEN bucket5_cte.cnt > 3525216 THEN bucket5_cte.avg_ext ELSE bucket5_cte.avg_net END AS bucket5 FROM reason CROSS JOIN bucket1_cte CROSS JOIN bucket2_cte CROSS JOIN bucket3_cte CROSS JOIN bucket4_cte CROSS JOIN bucket5_cte WHERE r_reason_sk = 1",
        "interfaces": {"outputs": ["bucket1", "bucket2", "bucket3", "bucket4", "bucket5"], "consumes": ["bucket1_cte", "bucket2_cte", "bucket3_cte", "bucket4_cte", "bucket5_cte"]}
      }
    },
    "reconstruction_order": ["bucket1_cte", "bucket2_cte", "bucket3_cte", "bucket4_cte", "bucket5_cte", "main_select"],
    "assembly_template": "WITH bucket1_cte AS ({bucket1_cte}), bucket2_cte AS ({bucket2_cte}), bucket3_cte AS ({bucket3_cte}), bucket4_cte AS ({bucket4_cte}), bucket5_cte AS ({bucket5_cte}) {main_select}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured 15 correlated scalar subqueries (5 buckets × 3 subqueries each) into five specialized CTEs, each scanning store_sales once with its specific quantity range, then cross-joined in the main query with the same conditional logic. This eliminates redundant scans while preserving exact semantics and defensive thresholds.

**Expected speedup:** ~5x (reducing 15 table scans to 5, while DuckDB may inline CTEs and push filters).