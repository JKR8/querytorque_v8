<reasoning>
CLASSIFY: This is a "repeated fact scan" archetype. The query performs 15 separate scalar subqueries against the same fact table (store_sales) with different quantity range filters (5 buckets × 3 subqueries each: COUNT, AVG(ss_ext_sales_price), AVG(ss_net_profit)).

EXPLAIN PLAN ANALYSIS:
- Total execution time: 2430ms
- Store_sales scans: 15 separate SEQ_SCAN operations (visible in EXPLAIN as repeated nodes)
- Each scan processes ~5.5M rows (1.6% of 345.6M rows), taking 110-173ms per scan
- The reason table scan (1 row) is trivial
- No joins - just cross products of scalar results
- Total store_sales I/O: 15 scans × ~5.5M rows = ~82.5M rows processed
- Each bucket's logic requires 3 scans (COUNT, then one of two AVGs based on threshold)
- The CASE WHEN condition forces sequential execution: first compute COUNT, then compute the appropriate AVG
- The optimizer has NOT consolidated these scans - each is separate

GAP MATCHING:
1. REDUNDANT_SCAN_ELIMINATION: Strong match. Query scans same table 15 times with similar filters.
2. CORRELATED_SUBQUERY_PARALYSIS: Partial match. Scalar subqueries are uncorrelated but execute independently.
3. CROSS_CTE_PREDICATE_BLINDNESS: Not applicable - no CTEs.
4. CROSS_COLUMN_OR_DECOMPOSITION: Not applicable - no OR conditions.

AGGREGATION TRAP CHECK:
- Uses COUNT(*) and AVG() - both duplicate-sensitive
- Each subquery has independent WHERE clause (different quantity ranges)
- Consolidating into single scan with CASE WHEN preserves aggregation correctness because ranges are disjoint

TRANSFORM SELECTION (ranked by expected value):
1. single_pass_aggregation (4.47x historical): Consolidate 15 scans into 1 scan with conditional aggregates
2. channel_bitmap_aggregation (6.24x historical): Similar pattern - multiple buckets consolidated
3. pushdown (2.11x historical): Could create CTE with all aggregates
4. materialize_cte (1.37x historical): Materialize store_sales filtered data

STRUCTURAL DIVERSITY:
1. single_pass_aggregation: Pure consolidation in single CTE
2. prefetch_fact_join: Chain approach with filtered CTE then aggregation
3. union_cte_split: Split by bucket ranges with UNION ALL
4. EXPLORATION: Composite strategy combining consolidation with predicate optimization

LOGICAL TREE DESIGN:
For single_pass_aggregation: One CTE computing all 15 metrics, then CASE logic in main query
For prefetch_fact_join: First CTE filters store_sales to relevant ranges, second CTE computes aggregates
For union_cte_split: Separate CTE per bucket range, then combine
</reasoning>

=== SHARED BRIEFING ===

SEMANTIC_CONTRACT:
(a) Return five quantity-bucket metrics where each bucket chooses average extended sales price when bucket volume exceeds a threshold, otherwise average net profit, for store sales tied to reason key 1.
(b) No JOIN semantics - only uncorrelated scalar subqueries and a trivial reason table filter.
(c) AVG() is duplicate-sensitive but disjoint quantity ranges ensure no overlap; COUNT(*) counts all rows in each range.
(d) The r_reason_sk = 1 filter on reason table must be preserved but is trivial; quantity range thresholds (2972190, 4505785, etc.) are literal constants that must remain unchanged.

BOTTLENECK_DIAGNOSIS:
Scan-bound: 15 sequential scans of store_sales table dominate 2430ms runtime. Each scan processes ~5.5M rows (1.6% of table) taking 110-173ms. Total I/O: 82.5M rows processed. Cardinality flow: store_sales scans (5.5M rows each) → scalar aggregates (1 row each) → cross products → final 1 row. The optimizer already pushes quantity filters into each SEQ_SCAN but does NOT consolidate multiple scans of same table.

ACTIVE_CONSTRAINTS:
- COMPLETE_OUTPUT: Must preserve bucket1 through bucket5 column names and calculation logic exactly.
- CTE_COLUMN_COMPLETENESS: Any CTE must output all columns needed for CASE expression logic.
- LITERAL_PRESERVATION: Quantity thresholds (2972190, 4505785, 1575726, 3188917, 3525216) and range boundaries (1-20, 21-40, etc.) must remain unchanged.
- SEMANTIC_EQUIVALENCE: Must produce exactly one row with five bucket values identical to original.
- REDUNDANT_SCAN_ELIMINATION: Query exhibits 15 scans of same fact table with similar WHERE patterns.
- CORRELATED_SUBQUERY_PARALYSIS: Scalar subqueries execute independently with no correlation.

REGRESSION_WARNINGS:
1. materialize_cte (0.14x on Q16):
   CAUSE: Converted EXISTS to materialized CTE, forcing full scan instead of semi-join short-circuit
   RULE: Do NOT convert scalar subqueries to materialized CTEs that scan entire table - focus on consolidating existing scans.
2. date_cte_isolate (0.49x on Q31):
   CAUSE: Created duplicate CTEs when optimizer already pushed predicates effectively
   RULE: Check EXPLAIN - if scans already have filters pushed (they do), avoid decomposing further.

=== WORKER 1 BRIEFING ===

STRATEGY: single_pass_aggregation
TARGET_LOGICAL_TREE:
  store_aggregates_cte -> main_select
NODE_CONTRACTS:
  store_aggregates_cte:
    FROM: store_sales
    WHERE: ss_quantity BETWEEN 1 AND 100
    GROUP BY: (empty - global aggregates)
    AGGREGATE: 
      COUNT(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 END) as cnt_1_20,
      AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_ext_sales_price END) as avg_ext_1_20,
      AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_net_profit END) as avg_net_1_20,
      COUNT(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN 1 END) as cnt_21_40,
      AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_ext_sales_price END) as avg_ext_21_40,
      AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_net_profit END) as avg_net_21_40,
      COUNT(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN 1 END) as cnt_41_60,
      AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_ext_sales_price END) as avg_ext_41_60,
      AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_net_profit END) as avg_net_41_60,
      COUNT(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN 1 END) as cnt_61_80,
      AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_ext_sales_price END) as avg_ext_61_80,
      AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_net_profit END) as avg_net_61_80,
      COUNT(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN 1 END) as cnt_81_100,
      AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_ext_sales_price END) as avg_ext_81_100,
      AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_net_profit END) as avg_net_81_100
    OUTPUT: cnt_1_20, avg_ext_1_20, avg_net_1_20, cnt_21_40, avg_ext_21_40, avg_net_21_40, cnt_41_60, avg_ext_41_60, avg_net_41_60, cnt_61_80, avg_ext_61_80, avg_net_61_80, cnt_81_100, avg_ext_81_100, avg_net_81_100
    EXPECTED_ROWS: 1
    CONSUMERS: main_select
  main_select:
    FROM: reason CROSS JOIN store_aggregates_cte
    WHERE: r_reason_sk = 1
    OUTPUT: 
      CASE WHEN cnt_1_20 > 2972190 THEN avg_ext_1_20 ELSE avg_net_1_20 END as bucket1,
      CASE WHEN cnt_21_40 > 4505785 THEN avg_ext_21_40 ELSE avg_net_21_40 END as bucket2,
      CASE WHEN cnt_41_60 > 1575726 THEN avg_ext_41_60 ELSE avg_net_41_60 END as bucket3,
      CASE WHEN cnt_61_80 > 3188917 THEN avg_ext_61_80 ELSE avg_net_61_80 END as bucket4,
      CASE WHEN cnt_81_100 > 3525216 THEN avg_ext_81_100 ELSE avg_net_81_100 END as bucket5
    EXPECTED_ROWS: 1
    CONSUMERS: final output
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation, pushdown
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Apply CASE WHEN inside aggregates to compute all metrics in one scan; ignore any date dimension filtering - this query has no dimensions.
- channel_bitmap_aggregation: Apply the pattern of labeling rows by bucket and conditional aggregation; ignore the bitmap optimization since we have simple ranges.
- pushdown: Apply the consolidation of multiple subqueries into single CTE; ignore predicate pushdown since filters are already at scan level.
HAZARD_FLAGS:
- Must ensure CASE WHEN in aggregates correctly handles NULLs for AVG (AVG ignores NULLs, matching original).
- The WHERE clause ss_quantity BETWEEN 1 AND 100 may scan more rows than original (covers all ranges), but still one scan vs fifteen.

=== WORKER 2 BRIEFING ===

STRATEGY: prefetch_fact_join
TARGET_LOGICAL_TREE:
  filtered_sales_cte -> aggregated_metrics_cte -> main_select
NODE_CONTRACTS:
  filtered_sales_cte:
    FROM: store_sales
    WHERE: ss_quantity BETWEEN 1 AND 100
    OUTPUT: ss_quantity, ss_ext_sales_price, ss_net_profit
    EXPECTED_ROWS: ~27.5M (5.5M per range × 5 ranges)
    CONSUMERS: aggregated_metrics_cte
  aggregated_metrics_cte:
    FROM: filtered_sales_cte
    GROUP BY: (empty - global aggregates)
    AGGREGATE:
      COUNT(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 END) as cnt_1_20,
      AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_ext_sales_price END) as avg_ext_1_20,
      AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_net_profit END) as avg_net_1_20,
      COUNT(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN 1 END) as cnt_21_40,
      AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_ext_sales_price END) as avg_ext_21_40,
      AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_net_profit END) as avg_net_21_40,
      COUNT(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN 1 END) as cnt_41_60,
      AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_ext_sales_price END) as avg_ext_41_60,
      AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_net_profit END) as avg_net_41_60,
      COUNT(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN 1 END) as cnt_61_80,
      AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_ext_sales_price END) as avg_ext_61_80,
      AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_net_profit END) as avg_net_61_80,
      COUNT(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN 1 END) as cnt_81_100,
      AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_ext_sales_price END) as avg_ext_81_100,
      AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_net_profit END) as avg_net_81_100
    OUTPUT: cnt_1_20, avg_ext_1_20, avg_net_1_20, cnt_21_40, avg_ext_21_40, avg_net_21_40, cnt_41_60, avg_ext_41_60, avg_net_41_60, cnt_61_80, avg_ext_61_80, avg_net_61_80, cnt_81_100, avg_ext_81_100, avg_net_81_100
    EXPECTED_ROWS: 1
    CONSUMERS: main_select
  main_select:
    FROM: reason CROSS JOIN aggregated_metrics_cte
    WHERE: r_reason_sk = 1
    OUTPUT: 
      CASE WHEN cnt_1_20 > 2972190 THEN avg_ext_1_20 ELSE avg_net_1_20 END as bucket1,
      CASE WHEN cnt_21_40 > 4505785 THEN avg_ext_21_40 ELSE avg_net_21_40 END as bucket2,
      CASE WHEN cnt_41_60 > 1575726 THEN avg_ext_41_60 ELSE avg_net_41_60 END as bucket3,
      CASE WHEN cnt_61_80 > 3188917 THEN avg_ext_61_80 ELSE avg_net_61_80 END as bucket4,
      CASE WHEN cnt_81_100 > 3525216 THEN avg_ext_81_100 ELSE avg_net_81_100 END as bucket5
    EXPECTED_ROWS: 1
    CONSUMERS: final output
EXAMPLES: prefetch_fact_join, early_filter, multi_dimension_prefetch
EXAMPLE_ADAPTATION:
- prefetch_fact_join: Apply staged CTE chain: first filter fact table, then aggregate; ignore dimension filtering since no dimensions.
- early_filter: Apply early reduction of fact table via WHERE clause; ignore dimension table filtering.
- multi_dimension_prefetch: Apply principle of pre-filtering before aggregation; ignore multiple dimension CTEs.
HAZARD_FLAGS:
- Two CTEs may cause materialization overhead; ensure filtered_sales_cte is referenced only once (so may be inlined).
- The filtered_sales_cte WHERE clause (1-100) is correct but scans slightly more than original if any rows outside 1-100 exist (they do).

=== WORKER 3 BRIEFING ===

STRATEGY: union_cte_split
TARGET_LOGICAL_TREE:
  bucket1_cte, bucket2_cte, bucket3_cte, bucket4_cte, bucket5_cte -> main_select
NODE_CONTRACTS:
  bucket1_cte:
    FROM: store_sales
    WHERE: ss_quantity BETWEEN 1 AND 20
    GROUP BY: (empty)
    AGGREGATE: 
      COUNT(*) as cnt,
      AVG(ss_ext_sales_price) as avg_ext,
      AVG(ss_net_profit) as avg_net
    OUTPUT: cnt, avg_ext, avg_net
    EXPECTED_ROWS: 1
    CONSUMERS: main_select
  bucket2_cte:
    FROM: store_sales
    WHERE: ss_quantity BETWEEN 21 AND 40
    GROUP BY: (empty)
    AGGREGATE: 
      COUNT(*) as cnt,
      AVG(ss_ext_sales_price) as avg_ext,
      AVG(ss_net_profit) as avg_net
    OUTPUT: cnt, avg_ext, avg_net
    EXPECTED_ROWS: 1
    CONSUMERS: main_select
  bucket3_cte:
    FROM: store_sales
    WHERE: ss_quantity BETWEEN 41 AND 60
    GROUP BY: (empty)
    AGGREGATE: 
      COUNT(*) as cnt,
      AVG(ss_ext_sales_price) as avg_ext,
      AVG(ss_net_profit) as avg_net
    OUTPUT: cnt, avg_ext, avg_net
    EXPECTED_ROWS: 1
    CONSUMERS: main_select
  bucket4_cte:
    FROM: store_sales
    WHERE: ss_quantity BETWEEN 61 AND 80
    GROUP BY: (empty)
    AGGREGATE: 
      COUNT(*) as cnt,
      AVG(ss_ext_sales_price) as avg_ext,
      AVG(ss_net_profit) as avg_net
    OUTPUT: cnt, avg_ext, avg_net
    EXPECTED_ROWS: 1
    CONSUMERS: main_select
  bucket5_cte:
    FROM: store_sales
    WHERE: ss_quantity BETWEEN 81 AND 100
    GROUP BY: (empty)
    AGGREGATE: 
      COUNT(*) as cnt,
      AVG(ss_ext_sales_price) as avg_ext,
      AVG(ss_net_profit) as avg_net
    OUTPUT: cnt, avg_ext, avg_net
    EXPECTED_ROWS: 1
    CONSUMERS: main_select
  main_select:
    FROM: reason 
      CROSS JOIN bucket1_cte 
      CROSS JOIN bucket2_cte 
      CROSS JOIN bucket3_cte 
      CROSS JOIN bucket4_cte 
      CROSS JOIN bucket5_cte
    WHERE: r_reason_sk = 1
    OUTPUT: 
      CASE WHEN bucket1_cte.cnt > 2972190 THEN bucket1_cte.avg_ext ELSE bucket1_cte.avg_net END as bucket1,
      CASE WHEN bucket2_cte.cnt > 4505785 THEN bucket2_cte.avg_ext ELSE bucket2_cte.avg_net END as bucket2,
      CASE WHEN bucket3_cte.cnt > 1575726 THEN bucket3_cte.avg_ext ELSE bucket3_cte.avg_net END as bucket3,
      CASE WHEN bucket4_cte.cnt > 3188917 THEN bucket4_cte.avg_ext ELSE bucket4_cte.avg_net END as bucket4,
      CASE WHEN bucket5_cte.cnt > 3525216 THEN bucket5_cte.avg_ext ELSE bucket5_cte.avg_net END as bucket5
    EXPECTED_ROWS: 1
    CONSUMERS: final output
EXAMPLES: union_cte_split, shared_dimension_multi_channel, rollup_to_union_windowing
EXAMPLE_ADAPTATION:
- union_cte_split: Apply specialization per bucket range with separate CTEs; ignore year filtering aspect.
- shared_dimension_multi_channel: Apply pattern of independent CTEs per "channel" (bucket); ignore shared dimension extraction.
- rollup_to_union_windowing: Apply explicit separation of different aggregation groups; ignore window functions.
HAZARD_FLAGS:
- 5 CTEs may each be materialized, adding overhead vs single CTE.
- Must ensure cross joins don't create Cartesian explosion (each CTE returns 1 row, so safe).

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: composite_single_pass_with_predicate_pushdown
TARGET_LOGICAL_TREE:
  filtered_sales_cte -> bucket_aggregates_cte -> main_select
NODE_CONTRACTS:
  filtered_sales_cte:
    FROM: store_sales
    WHERE: ss_quantity BETWEEN 1 AND 100
    OUTPUT: ss_quantity, ss_ext_sales_price, ss_net_profit,
      CASE 
        WHEN ss_quantity BETWEEN 1 AND 20 THEN 1
        WHEN ss_quantity BETWEEN 21 AND 40 THEN 2
        WHEN ss_quantity BETWEEN 41 AND 60 THEN 3
        WHEN ss_quantity BETWEEN 61 AND 80 THEN 4
        WHEN ss_quantity BETWEEN 81 AND 100 THEN 5
      END as bucket_id
    EXPECTED_ROWS: ~27.5M
    CONSUMERS: bucket_aggregates_cte
  bucket_aggregates_cte:
    FROM: filtered_sales_cte
    GROUP BY: bucket_id
    AGGREGATE:
      COUNT(*) as cnt,
      AVG(ss_ext_sales_price) as avg_ext,
      AVG(ss_net_profit) as avg_net
    OUTPUT: bucket_id, cnt, avg_ext, avg_net
    EXPECTED_ROWS: 5
    CONSUMERS: main_select
  main_select:
    FROM: reason 
      CROSS JOIN (
        SELECT 
          MAX(CASE WHEN bucket_id = 1 AND cnt > 2972190 THEN avg_ext WHEN bucket_id = 1 THEN avg_net END) as bucket1,
          MAX(CASE WHEN bucket_id = 2 AND cnt > 4505785 THEN avg_ext WHEN bucket_id = 2 THEN avg_net END) as bucket2,
          MAX(CASE WHEN bucket_id = 3 AND cnt > 1575726 THEN avg_ext WHEN bucket_id = 3 THEN avg_net END) as bucket3,
          MAX(CASE WHEN bucket_id = 4 AND cnt > 3188917 THEN avg_ext WHEN bucket_id = 4 THEN avg_net END) as bucket4,
          MAX(CASE WHEN bucket_id = 5 AND cnt > 3525216 THEN avg_ext WHEN bucket_id = 5 THEN avg_net END) as bucket5
        FROM bucket_aggregates_cte
      ) buckets
    WHERE: r_reason_sk = 1
    OUTPUT: bucket1, bucket2, bucket3, bucket4, bucket5
    EXPECTED_ROWS: 1
    CONSUMERS: final output
EXAMPLES: single_pass_aggregation, channel_bitmap_aggregation, scan_consolidation_pivot
EXAMPLE_ADAPTATION:
- single_pass_aggregation: Apply single scan principle; enhance with bucket labeling.
- channel_bitmap_aggregation: Apply bucket labeling and GROUP BY; ignore bitmap aspect.
- scan_consolidation_pivot: Apply GROUP BY with discriminator then pivot; this is the core pattern.
HAZARD_FLAGS:
- MAX(CASE WHEN...) pivot may be less efficient than direct CASE expressions.
- GROUP BY bucket_id computes aggregates correctly but requires pivot to get single row.
CONSTRAINT_OVERRIDE: None
OVERRIDE_REASONING: N/A
EXPLORATION_TYPE: compound_strategy (combines single-pass aggregation with pivot transformation)