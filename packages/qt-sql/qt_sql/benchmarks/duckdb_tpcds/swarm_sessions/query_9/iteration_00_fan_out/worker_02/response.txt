### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [~] main_query  [~]  Cost: 1%  Rows: ~1  — Consolidates 15 scans into 1, then CROSS JOIN with filtered reason
    ├── [!] filtered_sales_cte  [+]  — Single scan of store_sales with quantity filter 1-100
    ├── [!] aggregated_metrics_cte  [+]  — Single-pass aggregates for all 5 quantity ranges
    ├── [=] SCAN (reason)
    ├── [=] FILTER (r_reason_sk = 1)
    └── [=] OUTPUT (bucket1, bucket2, bucket3, bucket4, bucket5)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "prefetch_fact_join", "description": "Consolidated 15 independent store_sales scans into single filtered CTE with one-pass aggregation", "applied_to": ["filtered_sales_cte", "aggregated_metrics_cte"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_sales_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss_quantity, ss_ext_sales_price, ss_net_profit FROM store_sales WHERE ss_quantity BETWEEN 1 AND 100",
        "interfaces": {"outputs": ["ss_quantity", "ss_ext_sales_price", "ss_net_profit"], "consumes": []}
      },
      "aggregated_metrics_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT COUNT(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN 1 END) AS cnt_1_20, AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_ext_sales_price END) AS avg_ext_1_20, AVG(CASE WHEN ss_quantity BETWEEN 1 AND 20 THEN ss_net_profit END) AS avg_net_1_20, COUNT(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN 1 END) AS cnt_21_40, AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_ext_sales_price END) AS avg_ext_21_40, AVG(CASE WHEN ss_quantity BETWEEN 21 AND 40 THEN ss_net_profit END) AS avg_net_21_40, COUNT(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN 1 END) AS cnt_41_60, AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_ext_sales_price END) AS avg_ext_41_60, AVG(CASE WHEN ss_quantity BETWEEN 41 AND 60 THEN ss_net_profit END) AS avg_net_41_60, COUNT(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN 1 END) AS cnt_61_80, AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_ext_sales_price END) AS avg_ext_61_80, AVG(CASE WHEN ss_quantity BETWEEN 61 AND 80 THEN ss_net_profit END) AS avg_net_61_80, COUNT(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN 1 END) AS cnt_81_100, AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_ext_sales_price END) AS avg_ext_81_100, AVG(CASE WHEN ss_quantity BETWEEN 81 AND 100 THEN ss_net_profit END) AS avg_net_81_100 FROM filtered_sales_cte",
        "interfaces": {"outputs": ["cnt_1_20", "avg_ext_1_20", "avg_net_1_20", "cnt_21_40", "avg_ext_21_40", "avg_net_21_40", "cnt_41_60", "avg_ext_41_60", "avg_net_41_60", "cnt_61_80", "avg_ext_61_80", "avg_net_61_80", "cnt_81_100", "avg_ext_81_100", "avg_net_81_100"], "consumes": ["filtered_sales_cte"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT CASE WHEN cnt_1_20 > 2972190 THEN avg_ext_1_20 ELSE avg_net_1_20 END AS bucket1, CASE WHEN cnt_21_40 > 4505785 THEN avg_ext_21_40 ELSE avg_net_21_40 END AS bucket2, CASE WHEN cnt_41_60 > 1575726 THEN avg_ext_41_60 ELSE avg_net_41_60 END AS bucket3, CASE WHEN cnt_61_80 > 3188917 THEN avg_ext_61_80 ELSE avg_net_61_80 END AS bucket4, CASE WHEN cnt_81_100 > 3525216 THEN avg_ext_81_100 ELSE avg_net_81_100 END AS bucket5 FROM reason CROSS JOIN aggregated_metrics_cte WHERE r_reason_sk = 1",
        "interfaces": {"outputs": ["bucket1", "bucket2", "bucket3", "bucket4", "bucket5"], "consumes": ["aggregated_metrics_cte"]}
      }
    },
    "reconstruction_order": ["filtered_sales_cte", "aggregated_metrics_cte", "main_query"],
    "assembly_template": "WITH filtered_sales_cte AS ({filtered_sales_cte}), aggregated_metrics_cte AS ({aggregated_metrics_cte}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Replaced 15 independent scalar subquery scans with a single CTE chain that scans store_sales once, computes all aggregates in one pass, then performs the conditional bucket logic. The mechanism is consolidation of duplicate scans through early filtering and single-pass aggregation.

**Expected speedup**: ~15x (reduces 15 full table scans to 1 scan with light filtering)