## Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~1K  — Join store sales with date, item, customer, address, and store; filter by month/year, manager id, and ZIP-prefix mismatch; aggregate extended sales price by brand/manufacturer attributes; and order by descending revenue.
    ├── [CTE] date_item_store_keys  [+]  Cost: 0%  Rows: ~5.56M  — Filter date, item, and store dimensions
    │   ├── SCAN date_dim
    │   ├── SCAN item
    │   ├── SCAN store
    │   ├── FILTER (d_moy=12 AND d_year=1999)
    │   ├── FILTER (i_manager_id=2)
    │   └── FILTER (s_store_sk <= 100)
    ├── [CTE] fact_filtered  [+]  Cost: 0%  Rows: ~933K  — Join dimension keys with fact table
    │   ├── SCAN store_sales
    │   └── JOIN (ON date_item_store_keys)
    ├── [CTE] join_customer_addr  [+]  Cost: 0%  Rows: ~15K  — Join customer and address, apply ZIP mismatch filter
    │   ├── SCAN customer
    │   ├── SCAN customer_address
    │   └── FILTER (substr(ca_zip,1,5) <> substr(s_zip,1,5))
    ├── [CTE] aggregation  [+]  Cost: 0%  Rows: ~901  — Join item for brand/Manufacturer and aggregate
    │   ├── SCAN item
    │   ├── GROUP BY (i_brand, i_brand_id, i_manufact_id, i_manufact)
    │   └── AGG (SUM(ss_ext_sales_price) AS ext_price)
    ├── AGG (GROUP BY)  [=]
    ├── SORT (ext_price DESC, i_brand ASC, i_brand_id ASC, i_manufact_id ASC, i_manufact ASC)  [=]
    └── OUTPUT (brand_id, brand, i_manufact_id, i_manufact, ext_price)  [=]
```

## Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "multi_dimension_prefetch",
      "description": "Pre-filter date, item, and store into a combined CTE before joining with fact table",
      "applied_to": ["date_item_store_keys", "fact_filtered"]
    },
    {
      "id": "R2",
      "type": "early_filter",
      "description": "Move customer and address tables to separate CTE and apply ZIP mismatch filter there",
      "applied_to": ["join_customer_addr"]
    },
    {
      "id": "R3",
      "type": "column_completeness",
      "description": "Ensure each CTE provides all columns needed downstream (s_zip, ca_zip, etc.)",
      "applied_to": ["date_item_store_keys", "fact_filtered", "join_customer_addr", "aggregation"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "date_item_store_keys": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT d.d_date_sk, i.i_item_sk, s.s_store_sk, s.s_zip FROM date_dim d CROSS JOIN item i CROSS JOIN store s WHERE d.d_moy = 12 AND d.d_year = 1999 AND i.i_manager_id = 2 AND s.s_store_sk <= 100",
          "interfaces": {
            "outputs": ["d_date_sk", "i_item_sk", "s_store_sk", "s_zip"],
            "consumes": []
          }
        },
        "fact_filtered": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT ss.ss_customer_sk, ss.ss_ext_sales_price, k.i_item_sk, k.s_store_sk, k.s_zip, k.d_date_sk FROM date_item_store_keys k JOIN store_sales ss ON k.d_date_sk = ss.ss_sold_date_sk AND k.i_item_sk = ss.ss_item_sk AND k.s_store_sk = ss.ss_store_sk",
          "interfaces": {
            "outputs": ["ss_customer_sk", "ss_ext_sales_price", "i_item_sk", "s_store_sk", "s_zip", "d_date_sk"],
            "consumes": ["date_item_store_keys"]
          }
        },
        "join_customer_addr": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT f.ss_ext_sales_price, f.i_item_sk, f.s_store_sk FROM fact_filtered f JOIN customer c ON f.ss_customer_sk = c.c_customer_sk JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE substr(ca.ca_zip, 1, 5) <> substr(f.s_zip, 1, 5)",
          "interfaces": {
            "outputs": ["ss_ext_sales_price", "i_item_sk", "s_store_sk"],
            "consumes": ["fact_filtered"]
          }
        },
        "aggregation": {
          "type": "cte",
          "change": "added",
          "sql": "SELECT i.i_brand_id, i.i_brand, i.i_manufact_id, i.i_manufact, SUM(j.ss_ext_sales_price) AS ext_price FROM join_customer_addr j JOIN item i ON j.i_item_sk = i.i_item_sk GROUP BY i.i_brand, i.i_brand_id, i.i_manufact_id, i.i_manufact",
          "interfaces": {
            "outputs": ["i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "ext_price"],
            "consumes": ["join_customer_addr"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, i_manufact_id, i_manufact, ext_price FROM aggregation ORDER BY ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact LIMIT 100",
          "interfaces": {
            "outputs": ["brand_id", "brand", "i_manufact_id", "i_manufact", "ext_price"],
            "consumes": ["aggregation"]
          }
        }
      },
      "reconstruction_order": ["date_item_store_keys", "fact_filtered", "join_customer_addr", "aggregation", "main_query"],
      "assembly_template": "WITH date_item_store_keys AS ({date_item_store_keys}), fact_filtered AS ({fact_filtered}), join_customer_addr AS ({join_customer_addr}), aggregation AS ({aggregation}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Restructured the original query into a sequence of CTEs following the target logical tree. Pre-filtered date, item, and store dimensions into a combined CTE before joining with the fact table. Moved customer and address joins to a separate CTE with the ZIP mismatch filter. Preserved all original filters and defensive guards.

**Expected speedup**: ~2.5-4.0x (based on similar multi-dimension prefetch transformations) due to reduced fact table scanning from early dimension filtering. The Cartesian product of filtered dimensions (31×1,793×100 = 5.56M) is still manageable and provides significant reduction from the full store_sales table.