## Part 1: Modified Logic Tree

```
QUERY: (structured as CTEs)
└── [MAIN] main_query  [~]  Cost: 100%  Rows: ~100 — Added CTE-based transformation
    ├── [~] CTE: date_item_cte  [NEW] — CROSS JOIN date_dim and item with filters
    │   ├── SCAN (date_dim, item)
    │   ├── FILTER (d_moy=12 AND d_year=1999 AND i_manager_id=2)
    │   └── OUTPUT (d_date_sk, i_item_sk, i_brand_id, i_brand, i_manufact_id, i_manufact)
    ├── [~] CTE: store_sales_filtered  [NEW] — Filter store_sales via EXISTS on date_item_cte
    │   ├── SCAN (store_sales)
    │   ├── FILTER (EXISTS with date_item_cte on ss_sold_date_sk=d_date_sk AND ss_item_sk=i_item_sk)
    │   └── OUTPUT (ss_item_sk, ss_customer_sk, ss_store_sk, ss_ext_sales_price)
    ├── [~] CTE: agg  [NEW] — Join filtered store_sales with date_item_cte and aggregate
    │   ├── JOIN (store_sales_filtered ⋈ date_item_cte on item_sk and date_sk)
    │   ├── AGG (GROUP BY i_brand,i_brand_id,i_manufact_id,i_manufact,ss_customer_sk,ss_store_sk)
    │   └── OUTPUT (i_brand_id,i_brand,i_manufact_id,i_manufact,ss_customer_sk,ss_store_sk,ext_price)
    ├── [~] CTE: late_zip_check  [NEW] — Join customer, address, store for ZIP mismatch
    │   ├── JOIN (agg ⋈ customer ⋈ customer_address ⋈ store)
    │   ├── FILTER (substr(ca_zip,1,5) <> substr(s_zip,1,5))
    │   └── OUTPUT (i_brand_id,i_brand,i_manufact_id,i_manufact,ext_price)
    ├── SORT (ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact)  [=]
    └── OUTPUT (brand_id, brand, i_manufact_id, i_manufact, ext_price)  [=]
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "star_join_prefetch", "description": "Isolate dimension filters (date_dim, item) into a separate CTE to reduce fact table probe size", "applied_to": ["date_item_cte"]},
    {"id": "R2", "type": "semi_join_filter", "description": "Use EXISTS to filter store_sales early while preserving semi-join semantics", "applied_to": ["store_sales_filtered"]},
    {"id": "R3", "type": "late_attribute_binding", "description": "Delay customer/address/store joins and ZIP filter until after aggregation to reduce join cardinality", "applied_to": ["late_zip_check"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_item_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d.d_date_sk, i.i_item_sk, i.i_brand_id, i.i_brand, i.i_manufact_id, i.i_manufact FROM date_dim d CROSS JOIN item i WHERE d.d_moy = 12 AND d.d_year = 1999 AND i.i_manager_id = 2",
        "interfaces": {"outputs": ["d_date_sk", "i_item_sk", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact"], "consumes": []}
      },
      "store_sales_filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ss.ss_item_sk, ss.ss_customer_sk, ss.ss_store_sk, ss.ss_ext_sales_price FROM store_sales ss WHERE EXISTS (SELECT 1 FROM date_item_cte k WHERE k.d_date_sk = ss.ss_sold_date_sk AND k.i_item_sk = ss.ss_item_sk)",
        "interfaces": {"outputs": ["ss_item_sk", "ss_customer_sk", "ss_store_sk", "ss_ext_sales_price"], "consumes": ["date_item_cte"]}
      },
      "agg": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT k.i_brand_id, k.i_brand, k.i_manufact_id, k.i_manufact, f.ss_customer_sk, f.ss_store_sk, SUM(f.ss_ext_sales_price) AS ext_price FROM store_sales_filtered f JOIN date_item_cte k ON f.ss_item_sk = k.i_item_sk AND f.ss_sold_date_sk = k.d_date_sk GROUP BY k.i_brand_id, k.i_brand, k.i_manufact_id, k.i_manufact, f.ss_customer_sk, f.ss_store_sk",
        "interfaces": {"outputs": ["i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "ss_customer_sk", "ss_store_sk", "ext_price"], "consumes": ["store_sales_filtered", "date_item_cte"]}
      },
      "late_zip_check": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT a.i_brand_id, a.i_brand, a.i_manufact_id, a.i_manufact, a.ext_price FROM agg a JOIN customer c ON a.ss_customer_sk = c.c_customer_sk JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN store s ON a.ss_store_sk = s.s_store_sk WHERE substr(ca.ca_zip, 1, 5) <> substr(s.s_zip, 1, 5)",
        "interfaces": {"outputs": ["i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "ext_price"], "consumes": ["agg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, i_manufact_id, i_manufact, ext_price FROM late_zip_check ORDER BY ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact LIMIT 100",
        "interfaces": {"outputs": ["brand_id", "brand", "i_manufact_id", "i_manufact", "ext_price"], "consumes": ["late_zip_check"]}
      }
    },
    "reconstruction_order": ["date_item_cte", "store_sales_filtered", "agg", "late_zip_check", "main_query"],
    "assembly_template": "WITH date_item_cte AS ({date_item_cte}), store_sales_filtered AS ({store_sales_filtered}), agg AS ({agg}), late_zip_check AS ({late_zip_check}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Transformed the original star-join query into a CTE pipeline that isolates dimension filters early (date_dim × item), uses EXISTS to filter the fact table, aggregates at brand/customer/store granularity, then applies ZIP mismatch filtering late. This reduces the fact table probe size via semi-join while preserving exact join semantics.

**Expected speedup**: ~2-4x (baseline 388ms → ~100-200ms) due to reduced fact table scanning and lower join cardinality before customer/address/store expansion.