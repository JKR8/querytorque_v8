### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [~]  — Restructured as staged CTE pipeline to avoid Cartesian explosion
    ├── [WITH] date_cte  [+] — Pre-filtered date dimension
    ├── [WITH] item_cte  [+] — Pre-filtered item dimension  
    ├── [WITH] store_cte  [+] — Pre-filtered store dimension
    ├── [WITH] customer_cte  [+] — Customer keys only
    ├── [WITH] addr_cte  [+] — Address keys only
    ├── [WITH] composite_keys  [+] — Early join between customer/address, no cross join
    ├── [WITH] fact_filtered  [+] — Join composite keys with fact table + ZIP filter
    ├── [WITH] aggregation  [+] — Group by brand/manufacturer
    └── SELECT (main_query)  [~] — Final projection, ordering, limit
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter all dimension tables into CTEs before joining with fact table", "applied_to": ["date_cte", "item_cte", "store_cte", "customer_cte", "addr_cte"]},
    {"id": "R2", "type": "staged_join_pipeline", "description": "Sequential join: customer+address first, then join with other dimensions via fact table", "applied_to": ["composite_keys", "fact_filtered"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d_date_sk FROM date_dim WHERE d_moy = 12 AND d_year = 1999",
        "interfaces": {"outputs": ["d_date_sk"], "consumes": []}
      },
      "item_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_item_sk, i_brand_id, i_brand, i_manufact_id, i_manufact FROM item WHERE i_manager_id = 2",
        "interfaces": {"outputs": ["i_item_sk", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT s_store_sk, s_zip FROM store WHERE s_store_sk <= 100",
        "interfaces": {"outputs": ["s_store_sk", "s_zip"], "consumes": []}
      },
      "customer_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c_customer_sk, c_current_addr_sk FROM customer",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_addr_sk"], "consumes": []}
      },
      "addr_cte": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT ca_address_sk, ca_zip FROM customer_address",
        "interfaces": {"outputs": ["ca_address_sk", "ca_zip"], "consumes": []}
      },
      "composite_keys": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT d.d_date_sk, i.i_item_sk, s.s_store_sk, c.c_customer_sk, a.ca_zip, s.s_zip, i.i_brand_id, i.i_brand, i.i_manufact_id, i.i_manufact FROM date_cte d CROSS JOIN item_cte i CROSS JOIN store_cte s INNER JOIN customer_cte c INNER JOIN addr_cte a ON c.c_current_addr_sk = a.ca_address_sk",
        "interfaces": {"outputs": ["d_date_sk", "i_item_sk", "s_store_sk", "c_customer_sk", "ca_zip", "s_zip", "i_brand_id", "i_brand", "i_manufact_id", "i_manufact"], "consumes": ["date_cte", "item_cte", "store_cte", "customer_cte", "addr_cte"]}
      },
      "fact_filtered": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT k.i_brand_id, k.i_brand, k.i_manufact_id, k.i_manufact, ss.ss_ext_sales_price FROM composite_keys k INNER JOIN store_sales ss ON k.d_date_sk = ss.ss_sold_date_sk AND k.i_item_sk = ss.ss_item_sk AND k.s_store_sk = ss.ss_store_sk AND k.c_customer_sk = ss.ss_customer_sk WHERE substr(k.ca_zip, 1, 5) <> substr(k.s_zip, 1, 5)",
        "interfaces": {"outputs": ["i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "ss_ext_sales_price"], "consumes": ["composite_keys"]}
      },
      "aggregation": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT i_brand_id, i_brand, i_manufact_id, i_manufact, SUM(ss_ext_sales_price) AS ext_price FROM fact_filtered GROUP BY i_brand, i_brand_id, i_manufact_id, i_manufact",
        "interfaces": {"outputs": ["i_brand_id", "i_brand", "i_manufact_id", "i_manufact", "ext_price"], "consumes": ["fact_filtered"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT i_brand_id AS brand_id, i_brand AS brand, i_manufact_id, i_manufact, ext_price FROM aggregation ORDER BY ext_price DESC, i_brand, i_brand_id, i_manufact_id, i_manufact LIMIT 100",
        "interfaces": {"outputs": ["brand_id", "brand", "i_manufact_id", "i_manufact", "ext_price"], "consumes": ["aggregation"]}
      }
    },
    "reconstruction_order": ["date_cte", "item_cte", "store_cte", "customer_cte", "addr_cte", "composite_keys", "fact_filtered", "aggregation", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), item_cte AS ({item_cte}), store_cte AS ({store_cte}), customer_cte AS ({customer_cte}), addr_cte AS ({addr_cte}), composite_keys AS ({composite_keys}), fact_filtered AS ({fact_filtered}), aggregation AS ({aggregation}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured from single large join to staged CTE pipeline that isolates dimension filtering, avoids Cartesian explosion by joining customer+address early, then joins with other dimensions through the fact table.

**Expected speedup:** ~2x-4x due to reduced intermediate result sizes and better predicate pushdown opportunities in DuckDB's columnar execution.