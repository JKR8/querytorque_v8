## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [=]  Cost: 100%  Rows: ~1K
    ├── CTE date_cte  [+]  — Filter date_dim for month sequence 1200–1211.
    │   └── SCAN date_dim
    ├── CTE item_cte  [+]  — Filter items by category/class/brand bundles.
    │   └── SCAN item
    ├── CTE store_cte  [+]  — Filter stores with s_store_sk ≤ 100.
    │   └── SCAN store
    ├── CTE fact_join_cte  [+]  — Join store_sales with all dimension CTEs.
    │   └── JOIN store_sales ⟕ date_cte ⟕ item_cte ⟕ store_cte
    ├── CTE agg_cte  [+]  — Group by manufacturer and quarter, sum sales.
    │   └── AGG (GROUP BY i_manufact_id, d_qoy)
    ├── CTE window_cte  [+]  — Compute manufacturer average quarterly sales.
    │   └── WINDOW (PARTITION BY i_manufact_id)
    ├── CTE filter_cte  [+]  — Filter rows where relative deviation > 10%.
    │   └── FILTER (CASE ... END > 0.1)
    └── CTE top_n  [+]  — Order and limit final results.
        ├── SORT (avg_quarterly_sales ASC, sum_sales ASC, i_manufact_id ASC)
        └── LIMIT 100
```

**Change markers:**
- `[+]` — Added all CTEs as per target logical tree (date_cte, item_cte, store_cte, fact_join_cte, agg_cte, window_cte, filter_cte, top_n)

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Pre-filter dimension tables into CTEs before fact join", "applied_to": ["date_cte", "item_cte", "store_cte"]},
    {"id": "R2", "type": "multi_dimension_prefetch", "description": "Prefilter all three dimension tables and join fact table once", "applied_to": ["fact_join_cte"]},
    {"id": "R3", "type": "early_filter", "description": "Apply dimension filters in CTEs to reduce fact table probe size", "applied_to": ["date_cte", "item_cte", "store_cte"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_qoy FROM date_dim WHERE d_month_seq BETWEEN 1200 AND 1211",
        "interfaces": {"outputs": ["d_date_sk", "d_qoy"], "consumes": []}
      },
      "item_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_item_sk, i_manufact_id FROM item WHERE ((i_category IN ('Books','Children','Electronics') AND i_class IN ('personal','portable','reference','self-help') AND i_brand IN ('scholaramalgamalg #14','scholaramalgamalg #7','exportiunivamalg #9','scholaramalgamalg #9')) OR (i_category IN ('Women','Music','Men') AND i_class IN ('accessories','classical','fragrances','pants') AND i_brand IN ('amalgimporto #1','edu packscholar #1','exportiimporto #1','importoamalg #1')))",
        "interfaces": {"outputs": ["i_item_sk", "i_manufact_id"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk FROM store WHERE s_store_sk <= 100",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "fact_join_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i.i_manufact_id, d.d_qoy, ss.ss_sales_price FROM store_sales ss INNER JOIN date_cte d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN item_cte i ON ss.ss_item_sk = i.i_item_sk INNER JOIN store_cte s ON ss.ss_store_sk = s.s_store_sk",
        "interfaces": {"outputs": ["i_manufact_id", "d_qoy", "ss_sales_price"], "consumes": ["date_cte", "item_cte", "store_cte"]}
      },
      "agg_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_manufact_id, d_qoy, SUM(ss_sales_price) AS sum_sales FROM fact_join_cte GROUP BY i_manufact_id, d_qoy",
        "interfaces": {"outputs": ["i_manufact_id", "d_qoy", "sum_sales"], "consumes": ["fact_join_cte"]}
      },
      "window_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_manufact_id, d_qoy, sum_sales, AVG(sum_sales) OVER (PARTITION BY i_manufact_id) AS avg_quarterly_sales FROM agg_cte",
        "interfaces": {"outputs": ["i_manufact_id", "d_qoy", "sum_sales", "avg_quarterly_sales"], "consumes": ["agg_cte"]}
      },
      "filter_cte": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_manufact_id, sum_sales, avg_quarterly_sales FROM window_cte WHERE CASE WHEN avg_quarterly_sales > 0 THEN ABS(sum_sales - avg_quarterly_sales) / avg_quarterly_sales ELSE NULL END > 0.1",
        "interfaces": {"outputs": ["i_manufact_id", "sum_sales", "avg_quarterly_sales"], "consumes": ["window_cte"]}
      },
      "top_n": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT i_manufact_id, sum_sales, avg_quarterly_sales FROM filter_cte ORDER BY avg_quarterly_sales ASC, sum_sales ASC, i_manufact_id ASC LIMIT 100",
        "interfaces": {"outputs": ["i_manufact_id", "sum_sales", "avg_quarterly_sales"], "consumes": ["filter_cte"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT * FROM top_n",
        "interfaces": {"outputs": ["i_manufact_id", "sum_sales", "avg_quarterly_sales"], "consumes": ["top_n"]}
      }
    },
    "reconstruction_order": ["date_cte", "item_cte", "store_cte", "fact_join_cte", "agg_cte", "window_cte", "filter_cte", "top_n", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), item_cte AS ({item_cte}), store_cte AS ({store_cte}), fact_join_cte AS ({fact_join_cte}), agg_cte AS ({agg_cte}), window_cte AS ({window_cte}), filter_cte AS ({filter_cte}), top_n AS ({top_n}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Applied dimension pre-filtering CTEs (date, item, store) to reduce fact table scan size, then joined once in fact_join_cte. Preserved all original filters, window semantics, and defensive division guard.

**Expected speedup:** 1.8–2.5x due to smaller hash tables for dimension joins and reduced fact table probing.