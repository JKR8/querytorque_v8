## Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [=]  Cost: 100%  Rows: ~100
    ├── [~] date_cte  [=]  Cost: 0.01%  Rows: 366
    ├── [~] store_cte  [=]  Cost: 0.01%  Rows: 100
    ├── [~] prefact_cte  [=]  Cost: ~98%  Rows: ~5.4M
    │   ├── SCAN store_sales
    │   ├── JOIN date_cte (INNER)
    │   └── JOIN store_cte (INNER)
    ├── [~] join_item_cte  [=]  Cost: ~1%  Rows: 198K
    │   ├── SCAN prefact_cte
    │   ├── JOIN item (INNER)
    │   └── FILTER (item attribute OR bundle)
    ├── [~] agg_cte  [=]  Cost: 0.5%  Rows: 3,065
    │   └── AGG (GROUP BY i_manufact_id, d_qoy)
    ├── [~] window_cte  [=]  Cost: 0.1%  Rows: 3,065
    │   └── WINDOW (PARTITION BY i_manufact_id)
    ├── [~] filter_cte  [=]  Cost: 0.1%  Rows: 2,618
    │   └── FILTER (deviation > 0.1)
    └── [~] top_n  [=]  Cost: 0.01%  Rows: 100
        ├── SORT (avg_quarterly_sales ASC, sum_sales ASC, i_manufact_id ASC)
        └── LIMIT 100
```

**Change markers:**
- `[~]` indicates each CTE is structurally identical to the target logical tree, with only column selections optimized per contract.

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb_v1.4.3",
  "rewrite_rules": [
    {"id": "R1", "type": "early_filter", "description": "Isolate date_dim and store filters into separate CTEs to reduce fact table join cardinality.", "applied_to": ["date_cte", "store_cte"]},
    {"id": "R2", "type": "staged_join", "description": "Build prefact CTE joining store_sales with filtered date/store first, then join item with complex OR condition.", "applied_to": ["prefact_cte", "join_item_cte"]},
    {"id": "R3", "type": "cte_pipeline", "description": "Encapsulate each logical operation (filter, join, aggregate, window, filter, top-N) in separate CTE for columnar projection control.", "applied_to": ["agg_cte", "window_cte", "filter_cte", "top_n"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT d_date_sk, d_qoy FROM date_dim WHERE d_month_seq BETWEEN 1200 AND 1211",
        "interfaces": {"outputs": ["d_date_sk", "d_qoy"], "consumes": []}
      },
      "store_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT s_store_sk FROM store WHERE s_store_sk <= 100",
        "interfaces": {"outputs": ["s_store_sk"], "consumes": []}
      },
      "prefact_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT ss_item_sk, ss_sales_price, d_qoy FROM store_sales INNER JOIN date_cte ON ss_sold_date_sk = d_date_sk INNER JOIN store_cte ON ss_store_sk = s_store_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_sales_price", "d_qoy"], "consumes": ["date_cte", "store_cte"]}
      },
      "join_item_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_manufact_id, d_qoy, ss_sales_price FROM prefact_cte INNER JOIN item ON ss_item_sk = i_item_sk WHERE ((i_category IN ('Books','Children','Electronics') AND i_class IN ('personal','portable','reference','self-help') AND i_brand IN ('scholaramalgamalg #14','scholaramalgamalg #7','exportiunivamalg #9','scholaramalgamalg #9')) OR (i_category IN ('Women','Music','Men') AND i_class IN ('accessories','classical','fragrances','pants') AND i_brand IN ('amalgimporto #1','edu packscholar #1','exportiimporto #1','importoamalg #1')))",
        "interfaces": {"outputs": ["i_manufact_id", "d_qoy", "ss_sales_price"], "consumes": ["prefact_cte"]}
      },
      "agg_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_manufact_id, d_qoy, SUM(ss_sales_price) AS sum_sales FROM join_item_cte GROUP BY i_manufact_id, d_qoy",
        "interfaces": {"outputs": ["i_manufact_id", "d_qoy", "sum_sales"], "consumes": ["join_item_cte"]}
      },
      "window_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_manufact_id, d_qoy, sum_sales, AVG(sum_sales) OVER (PARTITION BY i_manufact_id) AS avg_quarterly_sales FROM agg_cte",
        "interfaces": {"outputs": ["i_manufact_id", "d_qoy", "sum_sales", "avg_quarterly_sales"], "consumes": ["agg_cte"]}
      },
      "filter_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_manufact_id, sum_sales, avg_quarterly_sales FROM window_cte WHERE CASE WHEN avg_quarterly_sales > 0 THEN ABS(sum_sales - avg_quarterly_sales) / avg_quarterly_sales ELSE NULL END > 0.1",
        "interfaces": {"outputs": ["i_manufact_id", "sum_sales", "avg_quarterly_sales"], "consumes": ["window_cte"]}
      },
      "top_n": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT i_manufact_id, sum_sales, avg_quarterly_sales FROM filter_cte ORDER BY avg_quarterly_sales ASC, sum_sales ASC, i_manufact_id ASC LIMIT 100",
        "interfaces": {"outputs": ["i_manufact_id", "sum_sales", "avg_quarterly_sales"], "consumes": ["filter_cte"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT * FROM top_n",
        "interfaces": {"outputs": ["i_manufact_id", "sum_sales", "avg_quarterly_sales"], "consumes": ["top_n"]}
      }
    },
    "reconstruction_order": ["date_cte", "store_cte", "prefact_cte", "join_item_cte", "agg_cte", "window_cte", "filter_cte", "top_n", "main_query"],
    "assembly_template": "WITH date_cte AS ({date_cte}), store_cte AS ({store_cte}), prefact_cte AS ({prefact_cte}), join_item_cte AS ({join_item_cte}), agg_cte AS ({agg_cte}), window_cte AS ({window_cte}), filter_cte AS ({filter_cte}), top_n AS ({top_n}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured the original flat join into a staged CTE pipeline that isolates date and store filters first, then joins with the fact table, then filters by item attributes, preserving exact semantic equivalence and defensive division guard.

**Expected speedup:** 2-3x due to early reduction of fact table rows via pre-filtered dimension keys and columnar projection in each CTE stage (selecting only needed columns).