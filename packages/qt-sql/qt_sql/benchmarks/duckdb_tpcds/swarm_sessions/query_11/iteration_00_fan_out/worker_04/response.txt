## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_dates  [+]  — Isolate date dimension filtering
│   ├── SCAN (date_dim)
│   └── FILTER (d_year IN (2001, 2002))
├── [CTE] consolidated_sales  [+]  — Single-pass aggregation for both channels
│   ├── SCAN (store_sales (join filtered_dates))
│   ├── UNION ALL
│   ├── SCAN (web_sales (join filtered_dates))
│   └── AGG (GROUP BY customer_sk, d_year, sale_type)
├── [CTE] customer_late_binding  [+]  — Deferred customer join after aggregation
│   ├── SCAN (consolidated_sales (join customer))
│   └── JOIN (customer_sk = c_customer_sk)
└── [MAIN] main_query  [~]  — Restructured self-join with explicit filters
    ├── SCAN (customer_late_binding AS s2001)
    ├── SCAN (customer_late_binding AS s2002)
    ├── SCAN (customer_late_binding AS w2001)
    ├── SCAN (customer_late_binding AS w2002)
    ├── JOIN (s2001.customer_id = s2002.customer_id = w2001.customer_id = w2002.customer_id)
    ├── FILTER (year/channel conditions)
    ├── FILTER (positive baselines)
    ├── FILTER (growth ratio comparison)
    ├── SORT (customer_id, first_name, last_name, birth_country)
    └── OUTPUT (customer_id, customer_first_name, customer_last_name, customer_birth_country)
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Isolate date dimension filtering into separate CTE to reduce join size early", "applied_to": ["filtered_dates"]},
    {"id": "R2", "type": "single_pass_aggregation", "description": "Consolidate store and web sales scans into single UNION ALL with late customer join", "applied_to": ["consolidated_sales"]},
    {"id": "R3", "type": "deferred_window_aggregation", "description": "Delay customer join until after aggregation to reduce row count before joining", "applied_to": ["customer_late_binding"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_dates": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_year FROM date_dim WHERE d_year IN (2001, 2002)",
        "interfaces": {"outputs": ["d_date_sk", "d_year"], "consumes": []}
      },
      "consolidated_sales": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT customer_sk, d_year, sale_type, SUM(amount) AS year_total FROM (SELECT ss_customer_sk AS customer_sk, d_year, (ss_ext_list_price - ss_ext_discount_amt) AS amount, 's' AS sale_type FROM store_sales INNER JOIN filtered_dates fd ON ss_sold_date_sk = fd.d_date_sk UNION ALL SELECT ws_bill_customer_sk AS customer_sk, d_year, (ws_ext_list_price - ws_ext_discount_amt) AS amount, 'w' AS sale_type FROM web_sales INNER JOIN filtered_dates fd ON ws_sold_date_sk = fd.d_date_sk) t GROUP BY customer_sk, d_year, sale_type",
        "interfaces": {"outputs": ["customer_sk", "d_year", "sale_type", "year_total"], "consumes": ["filtered_dates"]}
      },
      "customer_late_binding": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, c.c_birth_country AS customer_birth_country, cs.d_year AS dyear, cs.year_total, cs.sale_type FROM consolidated_sales cs INNER JOIN customer c ON cs.customer_sk = c.c_customer_sk",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_birth_country", "dyear", "year_total", "sale_type"], "consumes": ["consolidated_sales"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT s2002.customer_id, s2002.customer_first_name, s2002.customer_last_name, s2002.customer_birth_country FROM customer_late_binding s2001, customer_late_binding s2002, customer_late_binding w2001, customer_late_binding w2002 WHERE s2001.customer_id = s2002.customer_id AND s2001.customer_id = w2001.customer_id AND s2001.customer_id = w2002.customer_id AND s2001.dyear = 2001 AND s2002.dyear = 2002 AND s2001.sale_type = 's' AND s2002.sale_type = 's' AND w2001.dyear = 2001 AND w2002.dyear = 2002 AND w2001.sale_type = 'w' AND w2002.sale_type = 'w' AND s2001.year_total > 0 AND w2001.year_total > 0 AND (w2002.year_total / w2001.year_total) > (s2002.year_total / s2001.year_total) ORDER BY s2002.customer_id, s2002.customer_first_name, s2002.customer_last_name, s2002.customer_birth_country LIMIT 100",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_birth_country"], "consumes": ["customer_late_binding"]}
      }
    },
    "reconstruction_order": ["filtered_dates", "consolidated_sales", "customer_late_binding", "main_query"],
    "assembly_template": "WITH filtered_dates AS ({filtered_dates}), consolidated_sales AS ({consolidated_sales}), customer_late_binding AS ({customer_late_binding}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Restructured from original single CTE with early customer join to three CTEs: (1) isolate date filtering, (2) consolidate store/web sales with aggregation before customer join, (3) late customer join, (4) same self-join logic. This eliminates redundant fact table scans.

**Expected speedup:** ~2-3x by reducing store_sales and web_sales from 4 scans each (original self-join) to 1 scan each, plus smaller hash tables from early date filtering.