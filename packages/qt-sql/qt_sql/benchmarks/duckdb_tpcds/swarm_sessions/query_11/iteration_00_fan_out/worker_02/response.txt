## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [+] store_2001:  Cost: ~25%  Rows: ~200K  — Store sales totals for 2001 only
├── [+] store_2002:  Cost: ~25%  Rows: ~200K  — Store sales totals for 2002 only
├── [+] web_2001:    Cost: ~25%  Rows: ~100K  — Web sales totals for 2001 only
├── [+] web_2002:    Cost: ~25%  Rows: ~100K  — Web sales totals for 2002 only
├── [~] main_query:  Cost: ~1%   Rows: ~100   — Four-way self-join on customer_id with growth ratio comparison
│   ├── SCAN (store_2001 AS s1, store_2002 AS s2, web_2001 AS w1, web_2002 AS w2)
│   ├── JOIN (s1.customer_id = s2.customer_id = w1.customer_id = w2.customer_id)
│   ├── FILTER (s1.year_total > 0 AND w1.year_total > 0)
│   ├── FILTER (CASE WHEN w1.year_total>0 THEN w2.year_total/w1.year_total ELSE 0.0 END > CASE WHEN s1.year_total>0 THEN s2.year_total/s1.year_total ELSE 0.0 END)
│   ├── SORT (customer_id, customer_first_name, customer_last_name, customer_birth_country)
│   └── OUTPUT (customer_id, customer_first_name, customer_last_name, customer_birth_country)
└── [-] year_total:  REMOVED — Generic CTE eliminated entirely to avoid redundant computation
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "union_cte_split", "description": "Split generic year_total CTE into 4 specialized CTEs by year(2001,2002) and channel(s,w), eliminating redundant scans", "applied_to": ["year_total"]},
    {"id": "R2", "type": "predicate_pushdown", "description": "Push year and channel filters from main query WHERE into CTE definitions", "applied_to": ["store_2001", "store_2002", "web_2001", "web_2002"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "store_2001": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, c.c_birth_country AS customer_birth_country, 2001 AS dyear, SUM(ss.ss_ext_list_price - ss.ss_ext_discount_amt) AS year_total, 's' AS sale_type FROM customer c, store_sales ss, date_dim d WHERE c.c_customer_sk = ss.ss_customer_sk AND ss.ss_sold_date_sk = d.d_date_sk AND d.d_year = 2001 GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, c.c_birth_country",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_birth_country", "dyear", "year_total", "sale_type"], "consumes": []}
      },
      "store_2002": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, c.c_birth_country AS customer_birth_country, 2002 AS dyear, SUM(ss.ss_ext_list_price - ss.ss_ext_discount_amt) AS year_total, 's' AS sale_type FROM customer c, store_sales ss, date_dim d WHERE c.c_customer_sk = ss.ss_customer_sk AND ss.ss_sold_date_sk = d.d_date_sk AND d.d_year = 2002 GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, c.c_birth_country",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_birth_country", "dyear", "year_total", "sale_type"], "consumes": []}
      },
      "web_2001": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, c.c_birth_country AS customer_birth_country, 2001 AS dyear, SUM(ws.ws_ext_list_price - ws.ws_ext_discount_amt) AS year_total, 'w' AS sale_type FROM customer c, web_sales ws, date_dim d WHERE c.c_customer_sk = ws.ws_bill_customer_sk AND ws.ws_sold_date_sk = d.d_date_sk AND d.d_year = 2001 GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, c.c_birth_country",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_birth_country", "dyear", "year_total", "sale_type"], "consumes": []}
      },
      "web_2002": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.c_customer_id AS customer_id, c.c_first_name AS customer_first_name, c.c_last_name AS customer_last_name, c.c_birth_country AS customer_birth_country, 2002 AS dyear, SUM(ws.ws_ext_list_price - ws.ws_ext_discount_amt) AS year_total, 'w' AS sale_type FROM customer c, web_sales ws, date_dim d WHERE c.c_customer_sk = ws.ws_bill_customer_sk AND ws.ws_sold_date_sk = d.d_date_sk AND d.d_year = 2002 GROUP BY c.c_customer_id, c.c_first_name, c.c_last_name, c.c_birth_country",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_birth_country", "dyear", "year_total", "sale_type"], "consumes": []}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT s2.customer_id, s2.customer_first_name, s2.customer_last_name, s2.customer_birth_country FROM store_2001 s1, store_2002 s2, web_2001 w1, web_2002 w2 WHERE s1.customer_id = s2.customer_id AND s2.customer_id = w1.customer_id AND w1.customer_id = w2.customer_id AND s1.year_total > 0 AND w1.year_total > 0 AND (CASE WHEN w1.year_total > 0 THEN w2.year_total / w1.year_total ELSE 0.0 END) > (CASE WHEN s1.year_total > 0 THEN s2.year_total / s1.year_total ELSE 0.0 END) ORDER BY s2.customer_id, s2.customer_first_name, s2.customer_last_name, s2.customer_birth_country LIMIT 100",
        "interfaces": {"outputs": ["customer_id", "customer_first_name", "customer_last_name", "customer_birth_country"], "consumes": ["store_2001", "store_2002", "web_2001", "web_2002"]}
      }
    },
    "reconstruction_order": ["store_2001", "store_2002", "web_2001", "web_2002", "main_query"],
    "assembly_template": "WITH store_2001 AS ({store_2001}), store_2002 AS ({store_2002}), web_2001 AS ({web_2001}), web_2002 AS ({web_2002}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes**: Split the generic `year_total` CTE into four specialized CTEs (`store_2001`, `store_2002`, `web_2001`, `web_2002`) that embed the year and channel filters in their definitions, eliminating redundant scans of the large fact tables. The main query performs a four-way self-join on customer_id with the growth ratio comparison.

**Expected speedup**: ~2x-3x. The original query scanned store_sales twice (4000ms + 315ms) and web_sales twice (1065ms + 46ms) within the same CTE execution. By splitting, each fact table scan occurs exactly once per year with proper predicate pushdown. DuckDB can now optimize each CTE independently and use columnar projection to only fetch needed columns.