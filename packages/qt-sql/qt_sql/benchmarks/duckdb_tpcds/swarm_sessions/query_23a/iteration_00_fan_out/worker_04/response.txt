### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [!] store_sales_unified_scan  [~]  Cost: 20%  Rows: 345.6M  — Single scan of store_sales with needed columns for downstream unified aggregation.
├── [!] frequent_items_and_max_sales  [+]  Cost: 35%  Rows: unknown  — Single-pass LEFT JOIN to date_dim (2000-2003), item, customer with conditional aggregates. Outputs both per-item-date counts and per-customer sales.
│   ├── SCAN (store_sales_unified_scan)
│   ├── LEFT JOIN date_dim (ss_sold_date_sk = d_date_sk AND d_year >= 2000 AND d_year <= 2003)
│   ├── LEFT JOIN item (ss_item_sk = i_item_sk)
│   ├── LEFT JOIN customer (ss_customer_sk = c_customer_sk)
│   ├── AGG (GROUP BY ss_item_sk, i_item_desc, ss_customer_sk, d_date)
│   └── OUTPUT (ss_item_sk, itemdesc, d_date, cnt, ss_customer_sk, csales)
├── [~] frequent_items_filtered  [~]  Cost: 10%  Rows: 4,202  — Filter unified results for cnt>4 and non-null date, collapse grouping to (itemdesc, item_sk, solddate).
│   ├── SCAN (frequent_items_and_max_sales)
│   ├── FILTER (cnt > 4 AND d_date IS NOT NULL)
│   ├── AGG (GROUP BY itemdesc, ss_item_sk, d_date)  (no aggregate)
│   └── OUTPUT (itemdesc, item_sk, solddate, cnt)
├── [~] max_sales_filtered  [+]  Cost: 10%  Rows: 472K  — Extract per‑customer total sales (csales) from unified CTE, filter non-null.
│   ├── SCAN (frequent_items_and_max_sales)
│   ├── FILTER (csales IS NOT NULL)
│   ├── AGG (GROUP BY ss_customer_sk)
│   └── OUTPUT (ss_customer_sk, csales_sum)
├── [~] max_store_sales_agg  [+]  Cost: 5%  Rows: 1  — Compute maximum per‑customer sales from filtered set.
│   ├── SCAN (max_sales_filtered)
│   ├── AGG (GROUP BY none)
│   └── OUTPUT (tpcds_cmax)
├── [~] best_customers  [~]  Cost: 15%  Rows: 171  — Aggregate store_sales (full scan) with customer join, filter against dynamic threshold from max_store_sales_agg.
│   ├── SCAN (store_sales, customer)
│   ├── JOIN (ss_customer_sk = c_customer_sk)
│   ├── AGG (GROUP BY c_customer_sk)
│   └── OUTPUT (c_customer_sk, ssales)
└── [=] main_union  [=]  Cost: 5%  Rows: ~1K  — Union May 2000 catalog/web sales, join with frequent_items_filtered and best_customers.
    ├── SCAN (catalog_sales, web_sales, date_dim, frequent_items_filtered, best_customers)
    └── OUTPUT (SUM(sales))
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "single_pass_aggregation",
      "description": "Consolidate two separate store_sales scans (frequent_ss_items and max_store_sales) into one CTE using conditional aggregates with LEFT JOIN to date_dim, preserving original INNER JOIN semantics via CASE guards.",
      "applied_to": ["store_sales_unified_scan", "frequent_items_and_max_sales", "frequent_items_filtered", "max_sales_filtered", "max_store_sales_agg"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "store_sales_unified_scan": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT ss_item_sk, ss_customer_sk, ss_quantity, ss_sales_price, ss_sold_date_sk FROM store_sales",
          "interfaces": {
            "outputs": ["ss_item_sk", "ss_customer_sk", "ss_quantity", "ss_sales_price", "ss_sold_date_sk"],
            "consumes": []
          }
        },
        "frequent_items_and_max_sales": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT ss_item_sk, SUBSTR(i_item_desc,1,30) AS itemdesc, d_date, COUNT(CASE WHEN d_date_sk IS NOT NULL THEN 1 END) AS cnt, ss_customer_sk, SUM(CASE WHEN d_date_sk IS NOT NULL THEN ss_quantity * ss_sales_price END) AS csales FROM store_sales_unified_scan LEFT JOIN date_dim ON ss_sold_date_sk = d_date_sk AND d_year >= 2000 AND d_year <= 2003 LEFT JOIN item ON ss_item_sk = i_item_sk LEFT JOIN customer ON ss_customer_sk = c_customer_sk GROUP BY ss_item_sk, i_item_desc, ss_customer_sk, d_date",
          "interfaces": {
            "outputs": ["ss_item_sk", "itemdesc", "d_date", "cnt", "ss_customer_sk", "csales"],
            "consumes": ["store_sales_unified_scan"]
          }
        },
        "frequent_items_filtered": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT itemdesc, ss_item_sk AS item_sk, d_date AS solddate, cnt FROM frequent_items_and_max_sales WHERE cnt > 4 AND d_date IS NOT NULL GROUP BY itemdesc, ss_item_sk, d_date, cnt",
          "interfaces": {
            "outputs": ["itemdesc", "item_sk", "solddate", "cnt"],
            "consumes": ["frequent_items_and_max_sales"]
          }
        },
        "max_sales_filtered": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT ss_customer_sk, SUM(csales) AS csales_sum FROM frequent_items_and_max_sales WHERE csales IS NOT NULL GROUP BY ss_customer_sk",
          "interfaces": {
            "outputs": ["ss_customer_sk", "csales_sum"],
            "consumes": ["frequent_items_and_max_sales"]
          }
        },
        "max_store_sales_agg": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT MAX(csales_sum) AS tpcds_cmax FROM max_sales_filtered",
          "interfaces": {
            "outputs": ["tpcds_cmax"],
            "consumes": ["max_sales_filtered"]
          }
        },
        "best_customers": {
          "type": "cte",
          "change": "modified",
          "sql": "SELECT c_customer_sk, SUM(ss_quantity * ss_sales_price) AS ssales FROM store_sales JOIN customer ON ss_customer_sk = c_customer_sk GROUP BY c_customer_sk HAVING SUM(ss_quantity * ss_sales_price) > (95/100.0) * (SELECT tpcds_cmax FROM max_store_sales_agg)",
          "interfaces": {
            "outputs": ["c_customer_sk", "ssales"],
            "consumes": ["max_store_sales_agg"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "unchanged",
          "sql": "",
          "interfaces": {
            "outputs": ["SUM(sales)"],
            "consumes": []
          }
        }
      },
      "reconstruction_order": ["store_sales_unified_scan", "frequent_items_and_max_sales", "frequent_items_filtered", "max_sales_filtered", "max_store_sales_agg", "best_customers"],
      "assembly_template": "WITH store_sales_unified_scan AS ({store_sales_unified_scan}), frequent_items_and_max_sales AS ({frequent_items_and_max_sales}), frequent_items_filtered AS ({frequent_items_filtered}), max_sales_filtered AS ({max_sales_filtered}), max_store_sales_agg AS ({max_store_sales_agg}), best_customers AS ({best_customers}) SELECT SUM(sales) FROM (SELECT cs_quantity * cs_list_price AS sales FROM catalog_sales, date_dim WHERE d_year = 2000 AND d_moy = 5 AND cs_sold_date_sk = d_date_sk AND cs_item_sk IN (SELECT item_sk FROM frequent_items_filtered) AND cs_bill_customer_sk IN (SELECT c_customer_sk FROM best_customers) UNION ALL SELECT ws_quantity * ws_list_price AS sales FROM web_sales, date_dim WHERE d_year = 2000 AND d_moy = 5 AND ws_sold_date_sk = d_date_sk AND ws_item_sk IN (SELECT item_sk FROM frequent_items_filtered) AND ws_bill_customer_sk IN (SELECT c_customer_sk FROM best_customers)) LIMIT 100;"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Combined the two independent store_sales scans (for frequent items and max customer sales) into a single CTE using conditional aggregates with LEFT JOIN to date_dim (2000-2003). The CASE guards ensure rows without matching dates are excluded from aggregates, preserving original INNER JOIN semantics. Downstream CTEs split the unified results into filtered frequent items and max sales paths.

**Expected speedup:** 2.5–4× reduction in store_sales I/O (from 4 scans to 2: unified CTE + best_customers) and elimination of redundant date_dim filtering.