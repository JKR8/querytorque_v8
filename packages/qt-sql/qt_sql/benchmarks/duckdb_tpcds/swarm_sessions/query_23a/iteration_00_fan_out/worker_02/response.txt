## Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] date_filter_2000_2003  [+]  Cost: <1%  Rows: 1,098  — Early filter date_dim for 2000-2003 to isolate store_sales join
│   ├── SCAN (date_dim)
│   ├── FILTER (d_year IN (2000, 2000+1, 2000+2, 2000+3))
│   └── OUTPUT (d_date_sk, d_date)
├── [CTE] store_sales_filtered  [+]  Cost: 25%  Rows: 16.6M  — Pre-join store_sales with filtered dates, output needed columns
│   ├── SCAN (store_sales)
│   ├── JOIN (date_filter_2000_2003 ON ss_sold_date_sk = d_date_sk)
│   └── OUTPUT (ss_item_sk, ss_customer_sk, ss_quantity, ss_sales_price, d_date)
├── [CTE] frequent_items_cte  [~]  Cost: 25%  Rows: 4,202  — Now joins store_sales_filtered instead of raw store_sales
│   ├── SCAN (store_sales_filtered, item (join))
│   ├── JOIN (ss_item_sk = i_item_sk)
│   ├── AGG (GROUP BY substr(i_item_desc,1,30), i_item_sk, d_date)
│   ├── HAVING (COUNT(*) > 4)
│   └── OUTPUT (itemdesc, item_sk, solddate, cnt)
├── [CTE] max_store_sales_cte  [~]  Cost: 25%  Rows: 472K  — Now joins store_sales_filtered instead of raw store_sales
│   ├── SCAN (store_sales_filtered, customer (join))
│   ├── JOIN (ss_customer_sk = c_customer_sk)
│   ├── AGG (GROUP BY c_customer_sk)
│   └── OUTPUT (c_customer_sk, csales)
├── [CTE] max_store_sales_agg  [+]  Cost: <1%  Rows: 1  — Isolate MAX(csales) for threshold
│   ├── SCAN (max_store_sales_cte)
│   ├── AGG (MAX(csales))
│   └── OUTPUT (tpcds_cmax)
├── [CTE] best_customers  [~]  Cost: 25%  Rows: 171  — Now uses max_store_sales_agg subquery
│   ├── SCAN (store_sales, customer (join))
│   ├── JOIN (ss_customer_sk = c_customer_sk)
│   ├── AGG (GROUP BY c_customer_sk)
│   ├── HAVING (ssales > (95/100.0) * (SELECT tpcds_cmax FROM max_store_sales_agg))
│   └── OUTPUT (c_customer_sk, ssales)
└── [MAIN] main_query  [~]  Cost: 25%  Rows: ~1K  — Union May 2000 catalog/web sales with IN subqueries to frequent_items_cte and best_customers
    ├── SCAN (catalog_sales, date_dim, web_sales, best_customers, frequent_items_cte)
    ├── JOIN (cs_sold_date_sk = d_date_sk)
    ├── FILTER (d_year = 2000)
    ├── FILTER (d_moy = 5)
    ├── FILTER (+2 more)
    ├── AGG (GROUP BY)
    └── OUTPUT (SUM(sales))
```

## Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "duckdb",
  "rewrite_rules": [
    {"id": "R1", "type": "dimension_cte_isolate", "description": "Isolate date_dim filter (2000-2003) into CTE before joining with store_sales", "applied_to": ["date_filter_2000_2003"]},
    {"id": "R2", "type": "prefetch_fact_join", "description": "Create store_sales_filtered CTE that pre-joins store_sales with filtered dates, reducing downstream scan size", "applied_to": ["store_sales_filtered"]},
    {"id": "R3", "type": "early_filter", "description": "Propagate filtered store_sales to frequent_items_cte and max_store_sales_cte instead of re-scanning raw store_sales with date joins", "applied_to": ["frequent_items_cte", "max_store_sales_cte"]},
    {"id": "R4", "type": "cte_split", "description": "Split max_store_sales into two CTEs: customer aggregates and global max, enabling reuse in best_customers", "applied_to": ["max_store_sales_cte", "max_store_sales_agg"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "date_filter_2000_2003": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT d_date_sk, d_date FROM date_dim WHERE d_year IN (2000, 2000+1, 2000+2, 2000+3)",
        "interfaces": {"outputs": ["d_date_sk", "d_date"], "consumes": []}
      },
      "store_sales_filtered": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT ss_item_sk, ss_customer_sk, ss_quantity, ss_sales_price, d_date FROM store_sales JOIN date_filter_2000_2003 ON ss_sold_date_sk = d_date_sk",
        "interfaces": {"outputs": ["ss_item_sk", "ss_customer_sk", "ss_quantity", "ss_sales_price", "d_date"], "consumes": ["date_filter_2000_2003"]}
      },
      "frequent_items_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT substr(i_item_desc,1,30) AS itemdesc, i_item_sk AS item_sk, d_date AS solddate, COUNT(*) AS cnt FROM store_sales_filtered JOIN item ON ss_item_sk = i_item_sk GROUP BY substr(i_item_desc,1,30), i_item_sk, d_date HAVING COUNT(*) > 4",
        "interfaces": {"outputs": ["itemdesc", "item_sk", "solddate", "cnt"], "consumes": ["store_sales_filtered"]}
      },
      "max_store_sales_cte": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_customer_sk, SUM(ss_quantity * ss_sales_price) AS csales FROM store_sales_filtered JOIN customer ON ss_customer_sk = c_customer_sk GROUP BY c_customer_sk",
        "interfaces": {"outputs": ["c_customer_sk", "csales"], "consumes": ["store_sales_filtered"]}
      },
      "max_store_sales_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT MAX(csales) AS tpcds_cmax FROM max_store_sales_cte",
        "interfaces": {"outputs": ["tpcds_cmax"], "consumes": ["max_store_sales_cte"]}
      },
      "best_customers": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT c_customer_sk, SUM(ss_quantity * ss_sales_price) AS ssales FROM store_sales JOIN customer ON ss_customer_sk = c_customer_sk GROUP BY c_customer_sk HAVING SUM(ss_quantity * ss_sales_price) > (95/100.0) * (SELECT tpcds_cmax FROM max_store_sales_agg)",
        "interfaces": {"outputs": ["c_customer_sk", "ssales"], "consumes": ["max_store_sales_agg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT SUM(sales) FROM (SELECT cs_quantity * cs_list_price AS sales FROM catalog_sales JOIN date_dim ON cs_sold_date_sk = d_date_sk WHERE d_year = 2000 AND d_moy = 5 AND cs_item_sk IN (SELECT item_sk FROM frequent_items_cte) AND cs_bill_customer_sk IN (SELECT c_customer_sk FROM best_customers) UNION ALL SELECT ws_quantity * ws_list_price AS sales FROM web_sales JOIN date_dim ON ws_sold_date_sk = d_date_sk WHERE d_year = 2000 AND d_moy = 5 AND ws_item_sk IN (SELECT item_sk FROM frequent_items_cte) AND ws_bill_customer_sk IN (SELECT c_customer_sk FROM best_customers))",
        "interfaces": {"outputs": ["SUM(sales)"], "consumes": ["frequent_items_cte", "best_customers"]}
      }
    },
    "reconstruction_order": ["date_filter_2000_2003", "store_sales_filtered", "frequent_items_cte", "max_store_sales_cte", "max_store_sales_agg", "best_customers", "main_query"],
    "assembly_template": "WITH date_filter_2000_2003 AS ({date_filter_2000_2003}), store_sales_filtered AS ({store_sales_filtered}), frequent_items_cte AS ({frequent_items_cte}), max_store_sales_cte AS ({max_store_sales_cte}), max_store_sales_agg AS ({max_store_sales_agg}), best_customers AS ({best_customers}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

**Changes:** Isolated date_dim filter into CTE, created pre‑joined store_sales CTE, then propagated filtered store_sales to both frequent_items_cte and max_store_sales_cte, splitting max_store_sales into two CTEs for reuse. This reduces repeated scanning of raw store_sales with date joins from 4x to 2x (store_sales_filtered scan + best_customers scan).

**Expected speedup:** ~2.5-3x due to eliminating two redundant store_sales scans (16.6M + 16.2M rows) and pushing date filter early into a small hash‑join.