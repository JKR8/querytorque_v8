You are an expert database performance analyst. Your job is to deeply analyze a slow SQL query, identify the root cause of its performance problems, and propose specific structural changes.

You follow a rigorous methodology: understand the structure, profile the costs, identify the mechanism (not just the symptom), propose changes with correctness reasoning, and learn from past failures.

## Query: query_78
## Dialect: duckdb

```sql
WITH ws AS (
  SELECT
    d_year AS ws_sold_year,
    ws_item_sk,
    ws_bill_customer_sk AS ws_customer_sk,
    SUM(ws_quantity) AS ws_qty,
    SUM(ws_wholesale_cost) AS ws_wc,
    SUM(ws_sales_price) AS ws_sp
  FROM web_sales
  LEFT JOIN web_returns
    ON wr_order_number = ws_order_number AND ws_item_sk = wr_item_sk
  JOIN date_dim
    ON ws_sold_date_sk = d_date_sk
  WHERE
    wr_order_number IS NULL
  GROUP BY
    d_year,
    ws_item_sk,
    ws_bill_customer_sk
), cs AS (
  SELECT
    d_year AS cs_sold_year,
    cs_item_sk,
    cs_bill_customer_sk AS cs_customer_sk,
    SUM(cs_quantity) AS cs_qty,
    SUM(cs_wholesale_cost) AS cs_wc,
    SUM(cs_sales_price) AS cs_sp
  FROM catalog_sales
  LEFT JOIN catalog_returns
    ON cr_order_number = cs_order_number AND cs_item_sk = cr_item_sk
  JOIN date_dim
    ON cs_sold_date_sk = d_date_sk
  WHERE
    cr_order_number IS NULL
  GROUP BY
    d_year,
    cs_item_sk,
    cs_bill_customer_sk
), ss AS (
  SELECT
    d_year AS ss_sold_year,
    ss_item_sk,
    ss_customer_sk,
    SUM(ss_quantity) AS ss_qty,
    SUM(ss_wholesale_cost) AS ss_wc,
    SUM(ss_sales_price) AS ss_sp
  FROM store_sales
  LEFT JOIN store_returns
    ON sr_ticket_number = ss_ticket_number AND ss_item_sk = sr_item_sk
  JOIN date_dim
    ON ss_sold_date_sk = d_date_sk
  WHERE
    sr_ticket_number IS NULL
  GROUP BY
    d_year,
    ss_item_sk,
    ss_customer_sk
)
SELECT
  ss_item_sk,
  ROUND(ss_qty / (
    COALESCE(ws_qty, 0) + COALESCE(cs_qty, 0)
  ), 2) AS ratio,
  ss_qty AS store_qty,
  ss_wc AS store_wholesale_cost,
  ss_sp AS store_sales_price,
  COALESCE(ws_qty, 0) + COALESCE(cs_qty, 0) AS other_chan_qty,
  COALESCE(ws_wc, 0) + COALESCE(cs_wc, 0) AS other_chan_wholesale_cost,
  COALESCE(ws_sp, 0) + COALESCE(cs_sp, 0) AS other_chan_sales_price
FROM ss
LEFT JOIN ws
  ON (
    ws_sold_year = ss_sold_year
    AND ws_item_sk = ss_item_sk
    AND ws_customer_sk = ss_customer_sk
  )
LEFT JOIN cs
  ON (
    cs_sold_year = ss_sold_year
    AND cs_item_sk = ss_item_sk
    AND cs_customer_sk = ss_customer_sk
  )
WHERE
  (
    COALESCE(ws_qty, 0) > 0 OR COALESCE(cs_qty, 0) > 0
  ) AND ss_sold_year = 2000
ORDER BY
  ss_item_sk,
  ss_qty DESC,
  ss_wc DESC,
  ss_sp DESC,
  other_chan_qty,
  other_chan_wholesale_cost,
  other_chan_sales_price,
  ratio
LIMIT 100
```

## Query Structure (DAG)

### 1. ws
**Role**: CTE (Definition Order: 0)
**Stats**: 25% Cost | ~1k rows
**Flags**: GROUP_BY
**Outputs**: [ws_sold_year, ws_item_sk, ws_customer_sk, ws_qty, ws_wc, ws_sp]
**Dependencies**: web_sales, web_returns (join), date_dim (join)
**Filters**: wr_order_number IS NULL
**Operators**: HASH_GROUP_BY, SEQ_SCAN[web_sales], SEQ_SCAN[web_returns], SEQ_SCAN[date_dim]
**Key Logic (SQL)**:
```sql
SELECT
  d_year AS ws_sold_year,
  ws_item_sk,
  ws_bill_customer_sk AS ws_customer_sk,
  SUM(ws_quantity) AS ws_qty,
  SUM(ws_wholesale_cost) AS ws_wc,
  SUM(ws_sales_price) AS ws_sp
FROM web_sales
LEFT JOIN web_returns
  ON wr_order_number = ws_order_number AND ws_item_sk = wr_item_sk
JOIN date_dim
  ON ws_sold_date_sk = d_date_sk
WHERE
  wr_order_number IS NULL
GROUP BY
  d_year,
  ws_item_sk,
  ws_bill_customer_sk
```

### 2. cs
**Role**: CTE (Definition Order: 0)
**Stats**: 25% Cost | ~1k rows
**Flags**: GROUP_BY
**Outputs**: [cs_sold_year, cs_item_sk, cs_customer_sk, cs_qty, cs_wc, cs_sp]
**Dependencies**: catalog_sales, catalog_returns (join), date_dim (join)
**Filters**: cr_order_number IS NULL
**Operators**: HASH_GROUP_BY, SEQ_SCAN[catalog_sales], SEQ_SCAN[catalog_returns], SEQ_SCAN[date_dim]
**Key Logic (SQL)**:
```sql
SELECT
  d_year AS cs_sold_year,
  cs_item_sk,
  cs_bill_customer_sk AS cs_customer_sk,
  SUM(cs_quantity) AS cs_qty,
  SUM(cs_wholesale_cost) AS cs_wc,
  SUM(cs_sales_price) AS cs_sp
FROM catalog_sales
LEFT JOIN catalog_returns
  ON cr_order_number = cs_order_number AND cs_item_sk = cr_item_sk
JOIN date_dim
  ON cs_sold_date_sk = d_date_sk
WHERE
  cr_order_number IS NULL
GROUP BY
  d_year,
  cs_item_sk,
  cs_bill_customer_sk
```

### 3. ss
**Role**: CTE (Definition Order: 0)
**Stats**: 25% Cost | ~1k rows
**Flags**: GROUP_BY
**Outputs**: [ss_sold_year, ss_item_sk, ss_customer_sk, ss_qty, ss_wc, ss_sp]
**Dependencies**: store_sales, store_returns (join), date_dim (join)
**Filters**: sr_ticket_number IS NULL
**Operators**: HASH_GROUP_BY, SEQ_SCAN[store_sales], SEQ_SCAN[store_returns], SEQ_SCAN[date_dim]
**Key Logic (SQL)**:
```sql
SELECT
  d_year AS ss_sold_year,
  ss_item_sk,
  ss_customer_sk,
  SUM(ss_quantity) AS ss_qty,
  SUM(ss_wholesale_cost) AS ss_wc,
  SUM(ss_sales_price) AS ss_sp
FROM store_sales
LEFT JOIN store_returns
  ON sr_ticket_number = ss_ticket_number AND ss_item_sk = sr_item_sk
JOIN date_dim
  ON ss_sold_date_sk = d_date_sk
WHERE
  sr_ticket_number IS NULL
GROUP BY
  d_year,
  ss_item_sk,
  ss_customer_sk
```

### 4. main_query
**Role**: Root / Output (Definition Order: 1)
**Stats**: 25% Cost | ~1k rows processed → 100 rows output
**Flags**: GROUP_BY, ORDER_BY, LIMIT(100)
**Outputs**: [ss_item_sk, ratio, store_qty, store_wholesale_cost, store_sales_price, other_chan_qty, other_chan_wholesale_cost, other_chan_sales_price] — ordered by ss_item_sk ASC, ss_qty DESC, ss_wc DESC, ss_sp DESC, other_chan_qty ASC, other_chan_wholesale_cost ASC, other_chan_sales_price ASC, ratio ASC
**Dependencies**: ss, ws (join), cs (join)
**Filters**: (COALESCE(ws_qty, 0) > 0 OR COALESCE(cs_qty, 0) > 0) | ss_sold_year = 2000
**Operators**: HASH_GROUP_BY, HASH_JOIN, SEQ_SCAN[ss], SEQ_SCAN[ws], SEQ_SCAN[cs]
**Key Logic (SQL)**:
```sql
SELECT
  ss_item_sk,
  ROUND(ss_qty / (
    COALESCE(ws_qty, 0) + COALESCE(cs_qty, 0)
  ), 2) AS ratio,
  ss_qty AS store_qty,
  ss_wc AS store_wholesale_cost,
  ss_sp AS store_sales_price,
  COALESCE(ws_qty, 0) + COALESCE(cs_qty, 0) AS other_chan_qty,
  COALESCE(ws_wc, 0) + COALESCE(cs_wc, 0) AS other_chan_wholesale_cost,
  COALESCE(ws_sp, 0) + COALESCE(cs_sp, 0) AS other_chan_sales_price
FROM ss
LEFT JOIN ws
  ON (
    ws_sold_year = ss_sold_year
    AND ws_item_sk = ss_item_sk
    AND ws_customer_sk = ss_customer_sk
  )
LEFT JOIN cs
  ON (
...
```

### Edges
- ss → main_query
- ws → main_query
- cs → main_query


## Reference Examples

**FAISS selected (by structural similarity):** shared_dimension_multi_channel, deferred_window_aggregation, intersect_to_exists

**All available gold examples:**

- **composite_decorrelate_union** (2.42xx) — Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT
- **date_cte_isolate** (4.00xx) — Extract date filtering into a separate CTE to enable predicate pushdown and redu
- **decorrelate** (2.92xx) — Convert correlated subquery to separate CTE with GROUP BY, then JOIN
- **deferred_window_aggregation** (1.36xx) — When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joi
- **dimension_cte_isolate** (1.93xx) — Pre-filter ALL dimension tables into CTEs before joining with fact table, not ju
- **early_filter** (4.00xx) — Filter dimension tables FIRST, then join to fact tables to reduce expensive join
- **intersect_to_exists** (1.83xx) — Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join pl
- **materialize_cte** (1.37xx) — Extract repeated subquery patterns into a CTE to avoid recomputation
- **multi_date_range_cte** (2.35xx) — When query uses multiple date_dim aliases with different filters (d1, d2, d3), c
- **multi_dimension_prefetch** (2.71xx) — Pre-filter multiple dimension tables (date + store) into separate CTEs before jo
- **or_to_union** (3.17xx) — Split OR conditions on different columns into UNION ALL branches for better inde
- **prefetch_fact_join** (3.77xx) — Pre-filter dimension table into CTE, then pre-join with fact table in second CTE
- **pushdown** (2.11xx) — Push filters from outer query into CTEs/subqueries to reduce intermediate result
- **shared_dimension_multi_channel** (1.30xx) — Extract shared dimension filters (date, item, promotion) into CTEs when multiple
- **single_pass_aggregation** (4.47xx) — Consolidate multiple subqueries scanning the same table into a single CTE with c
- **union_cte_split** (1.36xx) — Split a generic UNION ALL CTE into specialized CTEs when the main query filters 

## Your Task

Analyze this query following these steps IN ORDER:

### 1. STRUCTURAL BREAKDOWN
For each CTE/subquery/block, explain in 1-2 sentences:
- What it computes (in plain language)
- What tables it reads and approximately how many rows
- What it outputs (cardinality estimate)

### 2. BOTTLENECK IDENTIFICATION
Using the DAG costs above, identify the dominant cost center.
Don't just name it — explain the MECHANISM:
- Is it a full table scan that could be filtered?
- Is it a sort for a window function that could be deferred?
- Is it a hash join on a large build side that could be pre-filtered?
- Is it scanning the same table multiple times when once would suffice?

### 3. PROPOSED OPTIMIZATION
Propose 1-3 specific structural changes. For EACH one:
- **What**: Exactly what to change (e.g., 'merge CTEs X and Y into one scan')
- **Why**: The performance mechanism (e.g., 'eliminates a 28M-row rescan of store_sales')
- **Risk**: What semantic constraint could break (e.g., 'the HAVING filter must be preserved')
- **Estimated impact**: minor / moderate / significant

### 5. RECOMMENDED STRATEGY
Synthesize everything into a single recommended optimization approach.
Be specific enough that another engineer could implement it from your description.

### 6. EXAMPLE SELECTION
FAISS selected these examples: shared_dimension_multi_channel, deferred_window_aggregation, intersect_to_exists
Review the FAISS picks against the available examples above.
If you think different examples would be more relevant for this query,
list your preferred examples. Otherwise confirm the FAISS picks are good.

```
EXAMPLES: example_id_1, example_id_2, example_id_3
```

Use exact IDs from the available examples list above.
