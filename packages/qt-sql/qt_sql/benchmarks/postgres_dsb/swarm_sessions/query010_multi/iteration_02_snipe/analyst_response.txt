FAILURE_ANALYSIS:
Worker 1 (1.21x) achieved moderate speedup by pushing filters early but maintained correlated EXISTS subqueries that still execute per qualifying customer row. Worker 2 (0.93x) regressed by over-isolating CTEs (customer_address separately) without reducing correlation. Worker 3 (0.79x) regressed severely by materializing DISTINCT customer keys from all sales tables BEFORE joining, creating large intermediate results without leveraging customer-side filters. Worker 4 (1.47x) succeeded with OR-to-UNION transformation but still uses separate CTEs for each sales channel, missing opportunity to push customer-side filters INTO the sales CTEs. Worker 1's snipe attempt failed with syntax error but attempted a promising direction: unifying sales channels into a single customer presence bitmap. The fundamental bottleneck remains: correlated EXISTS force nested loops over customer-sales joins. All attempts except Worker 4 kept the OR condition as correlated subqueries or materialized large intermediate fact sets.

UNEXPLORED_OPPORTUNITIES:
1. **Pre-join customer filters with sales CTEs**: Push customer demographic/address/location filters INTO the sales CTEs via early joins before DISTINCT, reducing intermediate result sizes.
2. **Single-pass sales aggregation**: Compute customer eligibility across all three channels in one CTE using conditional aggregation instead of separate UNION/CTEs.
3. **Lateral join decorrelation**: Use LATERAL joins to unnest the correlated subqueries while maintaining predicate pushdown.
4. **Early customer candidate reduction**: Compute store_sales-eligible customers first, THEN check web/catalog against that reduced set only.
5. **Partial materialization strategy**: Materialize only the selective dimension tables (date/item) and keep sales tables as joins with pushdown.

REFINED_STRATEGY:
Create a single sales eligibility CTE that:
1. Starts with store_sales filtered by date/item and price ratio
2. LEFT LATERAL JOINs to web_sales and catalog_sales on same customer+date/item+price conditions
3. Uses conditional logic to check (web_exists OR catalog_exists)
4. Filters on customer demographics/address/location BEFORE DISTINCT by joining customer tables early
5. Returns only distinct eligible customer keys to join back for final grouping

This collapses three separate EXISTS checks into one pass over store_sales (the mandatory channel) with lateral checks for optional channels, while pushing all selective customer filters down to reduce rows before DISTINCT.

EXAMPLES: early_filter_decorrelate, pg_dimension_prefetch_star, pg_self_join_decomposition
HINT: Build a CTE that filters date/item once, then joins store_sales → customer → address → demographics with all base filters applied. Use LATERAL (SELECT EXISTS...) for web_sales and catalog_sales checks on the same customer. Return only customer keys where store_sales exists AND (web OR catalog exists). Then join back lightly for final grouping.