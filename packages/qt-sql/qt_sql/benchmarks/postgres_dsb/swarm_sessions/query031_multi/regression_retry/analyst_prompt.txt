You are coordinating a swarm of 4 optimization specialists. Each specialist will attempt to optimize the same query using a DIFFERENT strategy and set of examples.

Your job: analyze the query structure, identify 4 diverse optimization angles, and assign each specialist a unique strategy with 3 relevant examples. Maximize diversity to cover the optimization space.

## Query: query031_multi
## Dialect: postgres

```sql
with ss as
 (select ca_county,d_qoy, d_year,sum(ss_ext_sales_price) as store_sales
 from store_sales,date_dim,customer_address, item
 where ss_sold_date_sk = d_date_sk
  and ss_addr_sk=ca_address_sk
  and ss_item_sk = i_item_sk
  and i_color IN ('blanched', 'rosy')
  and i_manager_id BETWEEN 16 and 35
  and ss_list_price between 286 and 300
  and ca_state in ('TX','VA')
 group by ca_county,d_qoy, d_year),
 ws as
 (select ca_county,d_qoy, d_year,sum(ws_ext_sales_price) as web_sales
 from web_sales,date_dim,customer_address, item
 where ws_sold_date_sk = d_date_sk
  and ws_bill_addr_sk=ca_address_sk
  and ws_item_sk = i_item_sk
  and i_color IN ('blanched', 'rosy')
  and i_manager_id BETWEEN 16 and 35
  and ws_list_price between 286 and 300
  and ca_state in ('TX','VA')
group by ca_county,d_qoy, d_year)
 select
        ss1.ca_county
       ,ss1.d_year
       ,ws2.web_sales/ws1.web_sales web_q1_q2_increase
       ,ss2.store_sales/ss1.store_sales store_q1_q2_increase
       ,ws3.web_sales/ws2.web_sales web_q2_q3_increase
       ,ss3.store_sales/ss2.store_sales store_q2_q3_increase
 from
        ss ss1
       ,ss ss2
       ,ss ss3
       ,ws ws1
       ,ws ws2
       ,ws ws3
 where
    ss1.d_qoy = 1
    and ss1.d_year = 1998
    and ss1.ca_county = ss2.ca_county
    and ss2.d_qoy = 2
    and ss2.d_year = 1998
 and ss2.ca_county = ss3.ca_county
    and ss3.d_qoy = 3
    and ss3.d_year = 1998
    and ss1.ca_county = ws1.ca_county
    and ws1.d_qoy = 1
    and ws1.d_year = 1998
    and ws1.ca_county = ws2.ca_county
    and ws2.d_qoy = 2
    and ws2.d_year = 1998
    and ws1.ca_county = ws3.ca_county
    and ws3.d_qoy = 3
    and ws3.d_year =1998
    and case when ws1.web_sales > 0 then ws2.web_sales/ws1.web_sales else null end
       > case when ss1.store_sales > 0 then ss2.store_sales/ss1.store_sales else null end
    and case when ws2.web_sales > 0 then ws3.web_sales/ws2.web_sales else null end
       > case when ss2.store_sales > 0 then ss3.store_sales/ss2.store_sales else null end
 order by web_q1_q2_increase;
```

## DAG Structure & Bottlenecks

| Node | Role | Cost % | Key Operations |
|------|------|-------:|----------------|
| ss |  | 0.0% | — |
| ws |  | 0.0% | — |
| main_query |  | 0.0% | — |

## Top 20 Matched Examples (by structural similarity)

1. **pg_dimension_prefetch_star** (3.32x) — On multi-channel UNION queries with comma-separated implicit joins, pre-filter dimension tables (date, item, promotion) 
2. **pg_materialized_dimension_fact_prefilter** (2.68x) — Pre-filter ALL dimension tables AND the fact table into MATERIALIZED CTEs, then join with explicit JOIN syntax. On queri
3. **pg_self_join_decomposition** (3.93x) — Eliminate duplicate fact table scans in self-join patterns by computing the aggregation ONCE in a CTE and deriving both 
4. **early_filter_decorrelate** (1.13x) — 
5. **pg_date_cte_explicit_join** (2.28x) — Isolate a selective date_dim filter into a CTE AND convert all comma-separated joins to explicit JOIN syntax. The combin
6. **inline_decorrelate_materialized** (timeout_rescue) — 
7. **DSB_SELF_JOIN_DECOMPOSITION** (unknown) — Decompose many-to-many self-joins into multiple passes with
      intermediate materialization for better cardinality es
8. **AGGREGATE_PUSH_BELOW_JOIN** (unknown) — Push aggregation below join when only aggregated values are needed
      from one side, reducing join cardinality.
9. **DSB_NON_EQUI_JOIN_WINDOW** (unknown) — Rewrite non-equi joins with temporal ordering into window function
      patterns for better estimation.
10. **SELF_JOIN_TO_WINDOW** (unknown) — Replace self-joins used to access group-level values with window
      functions, eliminating the join entirely.
11. **AGGREGATE_PULL_UP_CONSTANTS** (unknown) — Pull up constant GROUP BY keys (SF=100 cited)
12. **CTE_OPTIMIZATION_FENCE_MATERIALIZED** (unknown) — Use MATERIALIZED to create optimization fence, preventing predicate
      pushdown and forcing single evaluation of expe
13. **DSB_PREDICATE_CORRELATION_STATS** (unknown) — Create extended statistics for DSB's intentionally correlated
      predicates that defeat independence assumption.
14. **GROUPING_SETS_INSTEAD_OF_UNION** (unknown) — Replace multiple GROUP BY queries with UNION ALL using single
      GROUPING SETS/ROLLUP/CUBE query for multi-level aggr
15. **LIMITED_COUNT_FOR_THRESHOLD** (unknown) — When checking if count exceeds threshold, use LIMIT to avoid
      counting all rows.
16. **WINDOW_SORT_ALIGNMENT** (unknown) — Align window function ORDER BY clauses to minimize sorts when
      multiple window functions are used in same query.
17. **CORRELATED_AGGREGATE_TO_LATERAL** (unknown) — Rewrite scalar subqueries with aggregations to LATERAL joins, enabling
      the optimizer to select optimal join strate
18. **CORRELATED_SUBQUERY_TO_WINDOW** (High - single scan vs N scans) — Rewrite scalar subqueries computing group aggregates to window functions,
      eliminating correlated execution and ena
19. **CORRELATED_WHERE_TO_DERIVED_TABLE** (unknown) — Convert correlated subqueries in WHERE clause to derived table joins
      when PostgreSQL fails to decorrelate automati
20. **CTE_INLINE_NOT_MATERIALIZED** (unknown) — Force CTE inlining with NOT MATERIALIZED to enable predicate pushdown
      when CTE is referenced multiple times but be

## All Available Examples (full catalog — can swap if needed)

- **pg_date_cte_explicit_join** (2.28x) — Isolate a selective date_dim filter into a CTE AND convert all comma-separated j
- **pg_dimension_prefetch_star** (3.32x) — On multi-channel UNION queries with comma-separated implicit joins, pre-filter d
- **early_filter_decorrelate** (1.13x) — 
- **inline_decorrelate_materialized** (timeout_rescue) — 
- **pg_materialized_dimension_fact_prefilter** (2.68x) — Pre-filter ALL dimension tables AND the fact table into MATERIALIZED CTEs, then 
- **pg_self_join_decomposition** (3.93x) — Eliminate duplicate fact table scans in self-join patterns by computing the aggr

## Your Task

Design 4 DIFFERENT optimization strategies exploring diverse approaches. You may keep the matched recommendations OR swap examples from the catalog.

**Constraints**:
- Each worker gets exactly 3 examples
- No duplicate examples across workers (12 total, 3 per worker)
- If fewer than 12 unique examples are available, reuse is allowed

**Diversity guidelines**:
- Worker 1: Conservative — proven patterns, low risk (e.g., pushdown, early filter)
- Worker 2: Moderate — date/dimension isolation, CTE restructuring
- Worker 3: Aggressive — multi-CTE restructuring, prefetch patterns
- Worker 4: Novel — OR-to-UNION, structural transforms, intersect-to-exists

For each worker, specify:
1. **Strategy name** (e.g., `aggressive_date_prefetch`)
2. **3 examples** to use (from matched picks or catalog)
3. **Strategy hint** (1-2 sentences guiding the optimization approach)

### Output Format (follow EXACTLY)

```
WORKER_1:
STRATEGY: <strategy_name>
EXAMPLES: <ex1>, <ex2>, <ex3>
HINT: <strategy guidance>

WORKER_2:
STRATEGY: <strategy_name>
EXAMPLES: <ex4>, <ex5>, <ex6>
HINT: <strategy guidance>

WORKER_3:
STRATEGY: <strategy_name>
EXAMPLES: <ex7>, <ex8>, <ex9>
HINT: <strategy guidance>

WORKER_4:
STRATEGY: <strategy_name>
EXAMPLES: <ex10>, <ex11>, <ex12>
HINT: <strategy guidance>
```