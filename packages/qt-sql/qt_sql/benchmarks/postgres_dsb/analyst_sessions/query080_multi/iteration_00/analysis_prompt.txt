You are an expert database performance analyst. Your job is to deeply analyze a slow SQL query, identify the root cause of its performance problems, and propose specific structural changes.

You follow a rigorous methodology: understand the structure, profile the costs, identify the mechanism (not just the symptom), propose changes with correctness reasoning, and learn from past failures.

## Query: query080_multi
## Dialect: postgres

```sql
WITH ssr AS (
  SELECT
    s_store_id AS store_id,
    SUM(ss_ext_sales_price) AS sales,
    SUM(COALESCE(sr_return_amt, 0)) AS returns,
    SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit
  FROM store_sales
  LEFT OUTER JOIN store_returns
    ON (
      ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number
    ), date_dim, store, item, promotion
  WHERE
    ss_sold_date_sk = d_date_sk
    AND d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY'
    AND ss_store_sk = s_store_sk
    AND ss_item_sk = i_item_sk
    AND i_current_price > 50
    AND ss_promo_sk = p_promo_sk
    AND p_channel_email = 'Y'
    AND p_channel_tv = 'Y'
    AND p_channel_radio = 'N'
    AND p_channel_press = 'N'
    AND p_channel_event = 'Y'
    AND ss_wholesale_cost BETWEEN 63 AND 78
    AND i_category IN ('Jewelry', 'Music')
  GROUP BY
    s_store_id
), csr AS (
  SELECT
    cp_catalog_page_id AS catalog_page_id,
    SUM(cs_ext_sales_price) AS sales,
    SUM(COALESCE(cr_return_amount, 0)) AS returns,
    SUM(cs_net_profit - COALESCE(cr_net_loss, 0)) AS profit
  FROM catalog_sales
  LEFT OUTER JOIN catalog_returns
    ON (
      cs_item_sk = cr_item_sk AND cs_order_number = cr_order_number
    ), date_dim, catalog_page, item, promotion
  WHERE
    cs_sold_date_sk = d_date_sk
    AND d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY'
    AND cs_catalog_page_sk = cp_catalog_page_sk
    AND cs_item_sk = i_item_sk
    AND i_current_price > 50
    AND cs_promo_sk = p_promo_sk
    AND p_channel_email = 'Y'
    AND p_channel_tv = 'Y'
    AND p_channel_radio = 'N'
    AND p_channel_press = 'N'
    AND p_channel_event = 'Y'
    AND cs_wholesale_cost BETWEEN 63 AND 78
    AND i_category IN ('Jewelry', 'Music')
  GROUP BY
    cp_catalog_page_id
), wsr AS (
  SELECT
    web_site_id,
    SUM(ws_ext_sales_price) AS sales,
    SUM(COALESCE(wr_return_amt, 0)) AS returns,
    SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit
  FROM web_sales
  LEFT OUTER JOIN web_returns
    ON (
      ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number
    ), date_dim, web_site, item, promotion
  WHERE
    ws_sold_date_sk = d_date_sk
    AND d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY'
    AND ws_web_site_sk = web_site_sk
    AND ws_item_sk = i_item_sk
    AND i_current_price > 50
    AND ws_promo_sk = p_promo_sk
    AND p_channel_email = 'Y'
    AND p_channel_tv = 'Y'
    AND p_channel_radio = 'N'
    AND p_channel_press = 'N'
    AND p_channel_event = 'Y'
    AND ws_wholesale_cost BETWEEN 63 AND 78
    AND i_category IN ('Jewelry', 'Music')
  GROUP BY
    web_site_id
)
SELECT
  channel,
  id,
  SUM(sales) AS sales,
  SUM(returns) AS returns,
  SUM(profit) AS profit
FROM (
  SELECT
    'store channel' AS channel,
    'store' || store_id AS id,
    sales,
    returns,
    profit
  FROM ssr
  UNION ALL
  SELECT
    'catalog channel' AS channel,
    'catalog_page' || catalog_page_id AS id,
    sales,
    returns,
    profit
  FROM csr
  UNION ALL
  SELECT
    'web channel' AS channel,
    'web_site' || web_site_id AS id,
    sales,
    returns,
    profit
  FROM wsr
) AS x
GROUP BY
  ROLLUP (
    channel,
    id
  )
ORDER BY
  channel,
  id
LIMIT 100
```

## Query Structure (DAG)

### 1. ssr
**Role**: CTE (Definition Order: 0)
**Stats**: 17% Cost | ~28k rows
**Flags**: GROUP_BY
**Outputs**: [store_id, sales, returns, profit]
**Dependencies**: store_sales, store_returns (join), date_dim (join), store (join), item (join), promotion (join)
**Joins**: ss_sold_date_sk = d_date_sk | ss_store_sk = s_store_sk | ss_item_sk = i_item_sk | ss_promo_sk = p_promo_sk
**Filters**: d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY' | i_current_price > 50 | p_channel_email = 'Y' | p_channel_tv = 'Y' | p_channel_radio = 'N' | p_channel_press = 'N' | p_channel_event = 'Y' | ss_wholesale_cost BETWEEN 63 AND 78 | i_category IN ('Jewelry', 'Music')
**Operators**: SEQ_SCAN[store_sales], SEQ_SCAN[store_returns], SEQ_SCAN[store]
**Key Logic (SQL)**:
```sql
SELECT
  s_store_id AS store_id,
  SUM(ss_ext_sales_price) AS sales,
  SUM(COALESCE(sr_return_amt, 0)) AS returns,
  SUM(ss_net_profit - COALESCE(sr_net_loss, 0)) AS profit
FROM store_sales
LEFT OUTER JOIN store_returns
  ON (
    ss_item_sk = sr_item_sk AND ss_ticket_number = sr_ticket_number
  ), date_dim, store, item, promotion
WHERE
  ss_sold_date_sk = d_date_sk
  AND d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY'
  AND ss_store_sk = s_store_sk
  AND ss_item_sk = i_item_sk
  AND i_current_price > 50
  AND ss_promo_sk = p_promo_sk
  AND p_channel_email = 'Y'
  AND p_channel_tv = 'Y'
  AND p_channel_radio = 'N'
...
```

### 2. csr
**Role**: CTE (Definition Order: 0)
**Stats**: 22% Cost | ~7k rows
**Flags**: GROUP_BY
**Outputs**: [catalog_page_id, sales, returns, profit]
**Dependencies**: catalog_sales, catalog_returns (join), date_dim (join), catalog_page (join), item (join), promotion (join)
**Joins**: cs_sold_date_sk = d_date_sk | cs_catalog_page_sk = cp_catalog_page_sk | cs_item_sk = i_item_sk | cs_promo_sk = p_promo_sk
**Filters**: d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY' | i_current_price > 50 | p_channel_email = 'Y' | p_channel_tv = 'Y' | p_channel_radio = 'N' | p_channel_press = 'N' | p_channel_event = 'Y' | cs_wholesale_cost BETWEEN 63 AND 78 | i_category IN ('Jewelry', 'Music')
**Operators**: SEQ_SCAN[catalog_sales], SEQ_SCAN[catalog_page], SEQ_SCAN[catalog_returns]
**Key Logic (SQL)**:
```sql
SELECT
  cp_catalog_page_id AS catalog_page_id,
  SUM(cs_ext_sales_price) AS sales,
  SUM(COALESCE(cr_return_amount, 0)) AS returns,
  SUM(cs_net_profit - COALESCE(cr_net_loss, 0)) AS profit
FROM catalog_sales
LEFT OUTER JOIN catalog_returns
  ON (
    cs_item_sk = cr_item_sk AND cs_order_number = cr_order_number
  ), date_dim, catalog_page, item, promotion
WHERE
  cs_sold_date_sk = d_date_sk
  AND d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY'
  AND cs_catalog_page_sk = cp_catalog_page_sk
  AND cs_item_sk = i_item_sk
  AND i_current_price > 50
  AND cs_promo_sk = p_promo_sk
  AND p_channel_email = 'Y'
  AND p_channel_tv = 'Y'
  AND p_channel_radio = 'N'
...
```

### 3. wsr
**Role**: CTE (Definition Order: 0)
**Stats**: 60% Cost | ~9k rows
**Flags**: GROUP_BY
**Outputs**: [web_site_id, sales, returns, profit]
**Dependencies**: web_sales, web_returns (join), date_dim (join), web_site (join), item (join), promotion (join)
**Joins**: ws_sold_date_sk = d_date_sk | ws_web_site_sk = web_site_sk | ws_item_sk = i_item_sk | ws_promo_sk = p_promo_sk
**Filters**: d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY' | i_current_price > 50 | p_channel_email = 'Y' | p_channel_tv = 'Y' | p_channel_radio = 'N' | p_channel_press = 'N' | p_channel_event = 'Y' | ws_wholesale_cost BETWEEN 63 AND 78 | i_category IN ('Jewelry', 'Music')
**Operators**: SEQ_SCAN[date_dim], SEQ_SCAN[promotion], SEQ_SCAN[item], SEQ_SCAN[date_dim], SEQ_SCAN[promotion]
**Key Logic (SQL)**:
```sql
SELECT
  web_site_id,
  SUM(ws_ext_sales_price) AS sales,
  SUM(COALESCE(wr_return_amt, 0)) AS returns,
  SUM(ws_net_profit - COALESCE(wr_net_loss, 0)) AS profit
FROM web_sales
LEFT OUTER JOIN web_returns
  ON (
    ws_item_sk = wr_item_sk AND ws_order_number = wr_order_number
  ), date_dim, web_site, item, promotion
WHERE
  ws_sold_date_sk = d_date_sk
  AND d_date BETWEEN CAST('1998-08-23' AS DATE) AND CAST('1998-08-23' AS DATE) + INTERVAL '30 DAY'
  AND ws_web_site_sk = web_site_sk
  AND ws_item_sk = i_item_sk
  AND i_current_price > 50
  AND ws_promo_sk = p_promo_sk
  AND p_channel_email = 'Y'
  AND p_channel_tv = 'Y'
  AND p_channel_radio = 'N'
...
```

### 4. main_query
**Role**: Root / Output (Definition Order: 1)
**Stats**: 0% Cost | ~1 rows processed → 100 rows output
**Flags**: GROUP_BY, ORDER_BY, LIMIT(100)
**Outputs**: [channel, id, sales, returns, profit] — ordered by channel ASC, id ASC
**Dependencies**: wsr, ssr, csr
**Operators**: SEQ_SCAN[Subquery Scan], SEQ_SCAN[Subquery Scan], SEQ_SCAN[Subquery Scan], Hash Join (Inner)
**Key Logic (SQL)**:
```sql
SELECT
  channel,
  id,
  SUM(sales) AS sales,
  SUM(returns) AS returns,
  SUM(profit) AS profit
FROM (
  SELECT
    'store channel' AS channel,
    'store' || store_id AS id,
    sales,
    returns,
    profit
  FROM ssr
  UNION ALL
  SELECT
    'catalog channel' AS channel,
    'catalog_page' || catalog_page_id AS id,
    sales,
    returns,
...
```

### Edges
- wsr → main_query
- ssr → main_query
- csr → main_query


## Previous Optimization Attempts

- Attempt 1: **date_cte_isolate** → WIN (1.12x)

## Reference Examples

**FAISS selected (by structural similarity):** pg_dimension_prefetch_star, early_filter_decorrelate, pg_self_join_decomposition

**All available gold examples:**

- **pg_date_cte_explicit_join** (2.28xx) — Isolate a selective date_dim filter into a CTE AND convert all comma-separated j
- **pg_dimension_prefetch_star** (3.32xx) — On multi-channel UNION queries with comma-separated implicit joins, pre-filter d
- **early_filter_decorrelate** (1.13xx) — 
- **pg_materialized_dimension_fact_prefilter** (2.68xx) — Pre-filter ALL dimension tables AND the fact table into MATERIALIZED CTEs, then 
- **pg_self_join_decomposition** (3.93xx) — Eliminate duplicate fact table scans in self-join patterns by computing the aggr

## Your Task

Analyze this query following these steps IN ORDER:

### 1. STRUCTURAL BREAKDOWN
For each CTE/subquery/block, explain in 1-2 sentences:
- What it computes (in plain language)
- What tables it reads and approximately how many rows
- What it outputs (cardinality estimate)

### 2. BOTTLENECK IDENTIFICATION
Using the DAG costs above, identify the dominant cost center.
Don't just name it — explain the MECHANISM:
- Is it a full table scan that could be filtered?
- Is it a sort for a window function that could be deferred?
- Is it a hash join on a large build side that could be pre-filtered?
- Is it scanning the same table multiple times when once would suffice?

### 3. PROPOSED OPTIMIZATION
Propose 1-3 specific structural changes. For EACH one:
- **What**: Exactly what to change (e.g., 'merge CTEs X and Y into one scan')
- **Why**: The performance mechanism (e.g., 'eliminates a 28M-row rescan of store_sales')
- **Risk**: What semantic constraint could break (e.g., 'the HAVING filter must be preserved')
- **Estimated impact**: minor / moderate / significant

### 4. FAILURE ANALYSIS
For each previous failed/regressed attempt, explain:
- WHY it failed (the specific mechanism)
- What constraint that teaches us for the next attempt

### 5. RECOMMENDED STRATEGY
Synthesize everything into a single recommended optimization approach.
Be specific enough that another engineer could implement it from your description.

### 6. EXAMPLE SELECTION
FAISS selected these examples: pg_dimension_prefetch_star, early_filter_decorrelate, pg_self_join_decomposition
Review the FAISS picks against the available examples above.
If you think different examples would be more relevant for this query,
list your preferred examples. Otherwise confirm the FAISS picks are good.

```
EXAMPLES: example_id_1, example_id_2, example_id_3
```

Use exact IDs from the available examples list above.
