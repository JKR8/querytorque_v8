[
  {
    "worker_id": 1,
    "strategy": "conservative_early_filter_pushdown",
    "examples": [
      "early_filter_decorrelate",
      "pg_date_cte_explicit_join",
      "pg_dimension_prefetch_star"
    ],
    "hint": "Push selective filters (date range, state list) as early as possible into the query flow, and convert implicit joins to explicit JOIN syntax for clarity and better join order control by the planner."
  },
  {
    "worker_id": 2,
    "strategy": "moderate_date_dimension_isolation",
    "examples": [
      "pg_date_cte_explicit_join",
      "pg_dimension_prefetch_star",
      "pg_materialized_dimension_fact_prefilter"
    ],
    "hint": "Isolate the selective date_dim and store filters into dedicated CTEs, then join them with the fact aggregation. Use explicit JOINs and consider materializing the pre-filtered CTEs."
  },
  {
    "worker_id": 3,
    "strategy": "aggressive_multi_cte_restructure",
    "examples": [
      "pg_materialized_dimension_fact_prefilter",
      "pg_self_join_decomposition",
      "pg_dimension_prefetch_star"
    ],
    "hint": "Pre-filter and materialize both dimension and fact data into separate CTEs. Restructure the self-join to compute the base aggregation only once, then derive the two time periods from that single result."
  },
  {
    "worker_id": 4,
    "strategy": "novel_self_join_elimination",
    "examples": [
      "pg_self_join_decomposition",
      "early_filter_decorrelate",
      "pg_materialized_dimension_fact_prefilter"
    ],
    "hint": "Eliminate the costly self-join by computing the weekly aggregates once and using window functions or conditional aggregation to create both time period columns (current year and prior year) in a single scan."
  }
]