{
  "query_id": "query085_spj_spj",
  "worker_id": 6,
  "run_name": "swarm_batch_20260208_142643",
  "timestamp": "2026-02-08T20:24:42.375807",
  "query_intent": "",
  "query_fingerprint": "",
  "examples_used": [
    "pg_self_join_decomposition",
    "early_filter_decorrelate",
    "pg_date_cte_explicit_join"
  ],
  "strategy": "Rewrite the query using LATERAL joins to force filter pushdown into the fact table access, while keeping dimension filters inline. Convert OR conditions to UNION ALL of three targeted subqueries, each",
  "status": "REGRESSION",
  "speedup": 0.18931825940797686,
  "transforms_applied": [
    "pushdown"
  ],
  "error_category": null,
  "error_messages": [],
  "what_worked": null,
  "why_it_worked": null,
  "what_failed": "Regression (0.19x): Rewrote query using LATERAL joins to push customer_address and web_sales filters into fact table access, decomposed OR conditions into three UNION ALL branches with simplified WHERE clauses, materialized date_dim filter in CTE, and preserved all original columns with conditional aggregation in a single pass per branch.",
  "why_it_failed": "All attempts fell short due to fundamental misapplication of CTE-based optimization in PostgreSQL. PostgreSQL's optimizer treats CTEs as optimization fences (by default), preventing pushdown of filters across CTE boundaries. Workers 2, 4, and 5 showed this clearly\u2014pre-filtering dimension tables in CTEs forced full scans of large fact tables before applying selective joins. Worker 1 failed syntactically by omitting needed columns. Worker 3 attempted aggressive materialization that exceeded time l",
  "principle": null,
  "reviewed": true
}