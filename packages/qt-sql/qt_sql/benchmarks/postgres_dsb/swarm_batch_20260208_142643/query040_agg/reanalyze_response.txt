FAILURE_ANALYSIS:
All workers attempted CTE-based pre-filtering but failed due to PostgreSQL's CTE optimization fence behavior—CTEs act as materialized barriers preventing predicate pushdown and join reordering. Worker 1 (0.99x) showed CTEs don't inherently degrade performance but fail to accelerate. Workers 2-5 attempted increasingly complex CTE nesting, which increased overhead without enabling better access paths. The fundamental bottleneck is the large fact-table join (catalog_sales ⋈ catalog_returns) filtered late. No attempt restructured the outer join or exploited date-based partition pruning.

COMMON_PATTERNS:
Multiple workers used dimension-prefetch CTEs (date_dim, item) and fact pre-filtering. All maintained the original left-outer-join structure. None addressed the costly conditional aggregation or date-range scan inefficiency.

UNEXPLORED_OPPORTUNITIES:
1. **Outer-join elimination**: Since cr_reason_sk=16 is highly selective, convert left join to inner join early.
2. **Date-based partition scan**: Rewrite date filter to enable partition pruning on cs_sold_date_sk.
3. **Aggregation pushdown**: Pre-aggregate before joining warehouse/item to reduce rows.
4. **Lateral join**: Use LATERAL for correlated date filtering.
5. **Conditional-aggregation optimization**: Separate before/after aggregates via UNION ALL.

REFINED_STRATEGY:
Convert left join to inner join (cr_reason_sk=16 is mandatory). Pre-aggregate catalog_sales and catalog_returns by date/item/warehouse before joining dimensions. Use date-dimension CTE but join directly via cs_sold_date_sk range scan. Separate before/after aggregates via derived tables to enable partition pruning.

EXAMPLES: pg_date_cte_explicit_join, early_filter_decorrelate, pg_self_join_decomposition
HINT: Transform left join to inner join, pre-aggregate fact tables by date/item keys, split before/after date logic into separate subqueries joined via UNION ALL, then join dimensions.