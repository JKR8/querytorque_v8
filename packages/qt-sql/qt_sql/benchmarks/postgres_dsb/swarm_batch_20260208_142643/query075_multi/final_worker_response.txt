```sql
WITH 
-- Pre-filter date dimension for relevant years only
filtered_date AS (
    SELECT d_date_sk, d_year
    FROM date_dim
    WHERE d_year IN (2001, 2002)
),
-- Pre-filter items to only Music category
filtered_item AS (
    SELECT 
        i_item_sk,
        i_brand_id,
        i_class_id,
        i_category_id,
        i_manufact_id
    FROM item
    WHERE i_category = 'Music'
),
-- Pre-aggregate catalog returns by composite key
catalog_returns_agg AS (
    SELECT 
        cr_order_number,
        cr_item_sk,
        SUM(cr_return_quantity) AS cr_return_quantity,
        SUM(cr_return_amount) AS cr_return_amount
    FROM catalog_returns
    WHERE cr_reason_sk IN (17, 48, 50, 56, 68)
    GROUP BY cr_order_number, cr_item_sk
),
-- Catalog sales with early filters and single-pass aggregation
catalog_sales_filtered AS (
    SELECT 
        d.d_year,
        i.i_brand_id,
        i.i_class_id,
        i.i_category_id,
        i.i_manufact_id,
        cs.cs_quantity - COALESCE(cra.cr_return_quantity, 0) AS sales_cnt,
        cs.cs_ext_sales_price - COALESCE(cra.cr_return_amount, 0.0) AS sales_amt
    FROM catalog_sales cs
    JOIN filtered_item i ON i.i_item_sk = cs.cs_item_sk
    JOIN filtered_date d ON d.d_date_sk = cs.cs_sold_date_sk
    LEFT JOIN catalog_returns_agg cra 
        ON cs.cs_order_number = cra.cr_order_number 
        AND cs.cs_item_sk = cra.cr_item_sk
    WHERE cs.cs_sales_price / cs.cs_list_price BETWEEN 33 * 0.01 AND 53 * 0.01
),
-- Pre-aggregate store returns by composite key
store_returns_agg AS (
    SELECT 
        sr_ticket_number,
        sr_item_sk,
        SUM(sr_return_quantity) AS sr_return_quantity,
        SUM(sr_return_amt) AS sr_return_amt
    FROM store_returns
    WHERE sr_reason_sk IN (17, 48, 50, 56, 68)
    GROUP BY sr_ticket_number, sr_item_sk
),
-- Store sales with early filters and single-pass aggregation
store_sales_filtered AS (
    SELECT 
        d.d_year,
        i.i_brand_id,
        i.i_class_id,
        i.i_category_id,
        i.i_manufact_id,
        ss.ss_quantity - COALESCE(sra.sr_return_quantity, 0) AS sales_cnt,
        ss.ss_ext_sales_price - COALESCE(sra.sr_return_amt, 0.0) AS sales_amt
    FROM store_sales ss
    JOIN filtered_item i ON i.i_item_sk = ss.ss_item_sk
    JOIN filtered_date d ON d.d_date_sk = ss.ss_sold_date_sk
    LEFT JOIN store_returns_agg sra 
        ON ss.ss_ticket_number = sra.sr_ticket_number 
        AND ss.ss_item_sk = sra.sr_item_sk
    WHERE ss.ss_sales_price / ss.ss_list_price BETWEEN 33 * 0.01 AND 53 * 0.01
),
-- Pre-aggregate web returns by composite key
web_returns_agg AS (
    SELECT 
        wr_order_number,
        wr_item_sk,
        SUM(wr_return_quantity) AS wr_return_quantity,
        SUM(wr_return_amt) AS wr_return_amt
    FROM web_returns
    WHERE wr_reason_sk IN (17, 48, 50, 56, 68)
    GROUP BY wr_order_number, wr_item_sk
),
-- Web sales with early filters and single-pass aggregation
web_sales_filtered AS (
    SELECT 
        d.d_year,
        i.i_brand_id,
        i.i_class_id,
        i.i_category_id,
        i.i_manufact_id,
        ws.ws_quantity - COALESCE(wra.wr_return_quantity, 0) AS sales_cnt,
        ws.ws_ext_sales_price - COALESCE(wra.wr_return_amt, 0.0) AS sales_amt
    FROM web_sales ws
    JOIN filtered_item i ON i.i_item_sk = ws.ws_item_sk
    JOIN filtered_date d ON d.d_date_sk = ws.ws_sold_date_sk
    LEFT JOIN web_returns_agg wra 
        ON ws.ws_order_number = wra.wr_order_number 
        AND ws.ws_item_sk = wra.wr_item_sk
    WHERE ws.ws_sales_price / ws.ws_list_price BETWEEN 33 * 0.01 AND 53 * 0.01
),
-- Combine all channels
combined_sales AS (
    SELECT * FROM catalog_sales_filtered
    UNION ALL
    SELECT * FROM store_sales_filtered
    UNION ALL
    SELECT * FROM web_sales_filtered
),
-- Aggregate by product hierarchy with both years in single pass
sales_by_year AS (
    SELECT 
        i_brand_id,
        i_class_id,
        i_category_id,
        i_manufact_id,
        SUM(CASE WHEN d_year = 2001 THEN sales_cnt ELSE 0 END) AS sales_cnt_2001,
        SUM(CASE WHEN d_year = 2002 THEN sales_cnt ELSE 0 END) AS sales_cnt_2002,
        SUM(CASE WHEN d_year = 2001 THEN sales_amt ELSE 0 END) AS sales_amt_2001,
        SUM(CASE WHEN d_year = 2002 THEN sales_amt ELSE 0 END) AS sales_amt_2002
    FROM combined_sales
    GROUP BY 
        i_brand_id,
        i_class_id,
        i_category_id,
        i_manufact_id
)
-- Final output with ratio filter
SELECT 
    2001 AS prev_year,
    2002 AS year,
    i_brand_id,
    i_class_id,
    i_category_id,
    i_manufact_id,
    sales_cnt_2001 AS prev_yr_cnt,
    sales_cnt_2002 AS curr_yr_cnt,
    sales_cnt_2002 - sales_cnt_2001 AS sales_cnt_diff,
    sales_amt_2002 - sales_amt_2001 AS sales_amt_diff
FROM sales_by_year
WHERE 
    sales_cnt_2001 > 0
    AND CAST(sales_cnt_2002 AS DECIMAL(17, 2)) / CAST(sales_cnt_2001 AS DECIMAL(17, 2)) < 0.9
ORDER BY 
    sales_cnt_diff,
    sales_amt_diff
LIMIT 100;
```

**Changes:**
1. Applied aggressive pre-filtering: created CTEs for filtered date (years 2001-2002 only) and filtered item (Music category only)
2. Pre-aggregated returns tables by their composite join keys to reduce row count before joining
3. Combined all three sales channels with UNION ALL after individual filtering
4. Computed both years' aggregates in a single pass using conditional SUM(CASE...) to avoid self-join
5. Applied final ratio filter in the main query's WHERE clause

**Expected speedup:** 2-3x by eliminating the expensive self-join, reducing intermediate data volume through early filtering, and minimizing join operations through pre-aggregation.