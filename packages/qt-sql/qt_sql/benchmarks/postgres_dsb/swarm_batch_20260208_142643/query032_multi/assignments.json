[
  {
    "worker_id": 1,
    "strategy": "conservative_early_filter_pushdown",
    "examples": [
      "early_filter_decorrelate",
      "pg_date_cte_explicit_join",
      "pg_dimension_prefetch_star"
    ],
    "hint": "Apply predicate pushdown and early filtering on dimension tables, convert implicit joins to explicit JOIN syntax, and isolate selective date ranges to reduce the initial row set before the expensive correlated subquery."
  },
  {
    "worker_id": 2,
    "strategy": "moderate_cte_isolation",
    "examples": [
      "pg_date_cte_explicit_join",
      "pg_materialized_dimension_fact_prefilter",
      "early_filter_decorrelate"
    ],
    "hint": "Use CTEs to pre-filter date_dim and item dimensions independently, then join with catalog_sales; consider materializing filtered fact rows to break the correlated subquery into a more efficient join."
  },
  {
    "worker_id": 3,
    "strategy": "aggressive_multi_cte_decomposition",
    "examples": [
      "pg_materialized_dimension_fact_prefilter",
      "pg_self_join_decomposition",
      "pg_dimension_prefetch_star"
    ],
    "hint": "Materialize pre-filtered dimension and fact tables into separate CTEs, then restructure the correlated subquery as a self-join decomposition to compute the average discount per item in a single scan."
  },
  {
    "worker_id": 4,
    "strategy": "novel_or_to_union_transform",
    "examples": [
      "early_filter_decorrelate",
      "pg_self_join_decomposition",
      "pg_date_cte_explicit_join"
    ],
    "hint": "Transform the OR condition on item into UNION ALL branches, then apply subquery decorrelation techniques to convert the correlated subquery into a derived table join, potentially using window functions for per-item averages."
  }
]