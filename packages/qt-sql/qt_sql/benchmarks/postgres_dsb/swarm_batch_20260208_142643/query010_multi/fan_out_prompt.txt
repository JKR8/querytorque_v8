You are coordinating a swarm of 4 optimization specialists. Each specialist will attempt to optimize the same query using a DIFFERENT strategy and set of examples.

Your job: analyze the query structure, identify 4 diverse optimization angles, and assign each specialist a unique strategy with 3 relevant examples. Maximize diversity to cover the optimization space.

## Query: query010_multi
## Dialect: postgres

```sql
select 
  cd_gender,
  cd_marital_status,
  cd_education_status,
  count(*) cnt1,
  cd_purchase_estimate,
  count(*) cnt2,
  cd_credit_rating,
  count(*) cnt3,
  cd_dep_count,
  count(*) cnt4,
  cd_dep_employed_count,
  count(*) cnt5,
  cd_dep_college_count,
  count(*) cnt6
 from
  customer c,customer_address ca,customer_demographics
 where
  c.c_current_addr_sk = ca.ca_address_sk and
  ca_county in ('Hickman County','Ohio County','Parke County','Pointe Coupee Parish','Siskiyou County') and
  c.c_birth_month in (3, 8) and
  cd_demo_sk = c.c_current_cdemo_sk
  and cd_marital_status in ('S', 'U', 'M')
  and cd_education_status in ('Secondary', 'Advanced Degree', '4 yr Degree')
  and cd_gender = 'M' and
  exists (select *
          from store_sales,date_dim, item
          where c.c_customer_sk = ss_customer_sk and
                ss_sold_date_sk = d_date_sk and
                d_year = 1998 and
                d_moy between 4 and 4+3 and
                ss_item_sk = i_item_sk and
                i_category in ('Children', 'Electronics', 'Men')
                and ss_sales_price / ss_list_price BETWEEN 11 * 0.01 AND 21 * 0.01
                and i_manager_id BETWEEN 51 and 60
                ) and
   (exists (select *
            from web_sales,date_dim, item
            where c.c_customer_sk = ws_bill_customer_sk and
                  ws_sold_date_sk = d_date_sk and
                  d_year = 1998 and
                  d_moy between 4 ANd 4+3 and
                  ws_item_sk = i_item_sk and
                  i_category in ('Children', 'Electronics', 'Men')
                  and i_manager_id BETWEEN 51 and 60
                  and ws_sales_price / ws_list_price BETWEEN 11 * 0.01 AND 21 * 0.01
                  ) or
    exists (select *
            from catalog_sales,date_dim, item
            where c.c_customer_sk = cs_ship_customer_sk and
                  cs_sold_date_sk = d_date_sk and
                  d_year = 1998 and
                  d_moy between 4 and 4+3 and
                  cs_item_sk = i_item_sk and
                  i_category in ('Children', 'Electronics', 'Men')
                  and i_manager_id BETWEEN 51 and 60
                  and cs_sales_price / cs_list_price BETWEEN 11 * 0.01 AND 21 * 0.01
                  ))
 group by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating,
          cd_dep_count,
          cd_dep_employed_count,
          cd_dep_college_count
 order by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating,
          cd_dep_count,
          cd_dep_employed_count,
          cd_dep_college_count
limit 100;
```

## DAG Structure & Bottlenecks

| Node | Role | Cost % | Key Operations |
|------|------|-------:|----------------|
| main_query |  | 0.0% | — |

## Top 4 FAISS Examples (by structural similarity)

1. **early_filter_decorrelate** (1.13xx) — 
2. **pg_dimension_prefetch_star** (3.32xx) — On multi-channel UNION queries with comma-separated implicit joins, pre-filter dimension tables (date, item, promotion) 
3. **pg_self_join_decomposition** (3.93xx) — Eliminate duplicate fact table scans in self-join patterns by computing the aggregation ONCE in a CTE and deriving both 
4. **pg_materialized_dimension_fact_prefilter** (2.68xx) — Pre-filter ALL dimension tables AND the fact table into MATERIALIZED CTEs, then join with explicit JOIN syntax. On queri

## All Available Examples (full catalog — can swap if needed)

- **pg_date_cte_explicit_join** (2.28xx) — Isolate a selective date_dim filter into a CTE AND convert all comma-separated j
- **pg_dimension_prefetch_star** (3.32xx) — On multi-channel UNION queries with comma-separated implicit joins, pre-filter d
- **early_filter_decorrelate** (1.13xx) — 
- **pg_materialized_dimension_fact_prefilter** (2.68xx) — Pre-filter ALL dimension tables AND the fact table into MATERIALIZED CTEs, then 
- **pg_self_join_decomposition** (3.93xx) — Eliminate duplicate fact table scans in self-join patterns by computing the aggr

## Your Task

Design 4 DIFFERENT optimization strategies exploring diverse approaches. You may keep FAISS recommendations OR swap examples from the catalog.

**Constraints**:
- Each worker gets exactly 3 examples
- No duplicate examples across workers (12 total, 3 per worker)
- If fewer than 12 unique examples are available, reuse is allowed

**Diversity guidelines**:
- Worker 1: Conservative — proven patterns, low risk (e.g., pushdown, early filter)
- Worker 2: Moderate — date/dimension isolation, CTE restructuring
- Worker 3: Aggressive — multi-CTE restructuring, prefetch patterns
- Worker 4: Novel — OR-to-UNION, structural transforms, intersect-to-exists

For each worker, specify:
1. **Strategy name** (e.g., `aggressive_date_prefetch`)
2. **3 examples** to use (from FAISS picks or catalog)
3. **Strategy hint** (1-2 sentences guiding the optimization approach)

### Output Format (follow EXACTLY)

```
WORKER_1:
STRATEGY: <strategy_name>
EXAMPLES: <ex1>, <ex2>, <ex3>
HINT: <strategy guidance>

WORKER_2:
STRATEGY: <strategy_name>
EXAMPLES: <ex4>, <ex5>, <ex6>
HINT: <strategy guidance>

WORKER_3:
STRATEGY: <strategy_name>
EXAMPLES: <ex7>, <ex8>, <ex9>
HINT: <strategy guidance>

WORKER_4:
STRATEGY: <strategy_name>
EXAMPLES: <ex10>, <ex11>, <ex12>
HINT: <strategy guidance>
```