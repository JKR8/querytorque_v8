FAILURE_ANALYSIS:
All attempts fell short due to three core issues: 1) Worker 1 and 5 had fatal errors (ambiguity/timeout) from improper column aliasing and excessive materialization. 2) Workers 2-4 failed to address the root bottleneck: the triple INTERSECT in cross_items performs expensive set operations on large intermediate results before applying item filters. 3) The avg_sales CTE scans the same fact tables thrice (store_sales, catalog_sales, web_sales) without leveraging pre-aggregated data. Workers 3 and 4's CTE pre-filtering helped marginally (1.05x) but didn't eliminate redundant computation across INTERSECT branches or between cross_items and avg_sales.

UNEXPLORED_OPPORTUNITIES:
1. **Fuse fact table scans**: Cross_items and avg_sales both scan the same three fact tables with similar filters (date range, wholesale_cost). These could be combined into a single pass per table.
2. **Replace INTERSECT with COUNT(DISTINCT channel)** - instead of set operations, compute items that appear in all 3 channels via grouping.
3. **Materialize only selective dimensions** - prefetching all dimensions (Worker 3) added overhead; only item filters are highly selective (i_category, i_manager_id).
4. **Partition main query by week_seq early** - compute this_year and last_year aggregates in one scan using conditional aggregation.
5. **Optimize avg_sales with pre-aggregated channel sums** - compute per-channel averages separately if distributions differ significantly.

REFINED_STRATEGY:
1. **Fused fact scan CTE**: Create a single CTE that scans each fact table once, outputting item_sk, channel marker, quantity*list_price (for avg), and item dimension keys. Apply all filters (date_range, wholesale_cost) here.
2. **Replace INTERSECT with grouped existence**: From the fused CTE, compute items present in all 3 channels via HAVING COUNT(DISTINCT channel)=3.
3. **Single-pass avg_sales**: Compute average sales directly from the fused CTE (excluding channel-existence logic).
4. **Weekly aggregates in main query**: Join fused CTE with filtered items and specific week dates using CASE statements to compute both year's aggregates in one GROUP BY.
5. **Limited materialization**: Only materialize the fused fact CTE and filtered item CTE; keep date_dim filters as subqueries to allow join pushdown.

EXAMPLES: pg_self_join_decomposition, early_filter_decorrelate, pg_dimension_prefetch_star
HINT: Build a unified fact CTE with columns: sales_key, item_sk, channel ('S'/'C'/'W'), sales_amount, d_year, d_week_seq. Then compute cross_items via grouping on item_sk having count(distinct channel)=3, and avg_sales via avg(sales_amount). In main query, join this CTE twice: once for week-specific aggregates (filtered by d_week_seq) and once for item existence (filtered by d_year range).