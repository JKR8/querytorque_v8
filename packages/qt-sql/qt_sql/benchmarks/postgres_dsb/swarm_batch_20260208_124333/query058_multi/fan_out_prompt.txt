You are coordinating a swarm of 4 optimization specialists. Each specialist will attempt to optimize the same query using a DIFFERENT strategy and set of examples.

Your job: analyze the query structure, identify 4 diverse optimization angles, and assign each specialist a unique strategy with 3 relevant examples. Maximize diversity to cover the optimization space.

## Query: query058_multi
## Dialect: postgres

```sql
with ss_items as
 (select i_item_id item_id
       ,c_birth_year birth_year
        ,sum(ss_ext_sales_price) ss_item_rev
 from store_sales
     ,item
     ,date_dim
     ,customer
 where ss_item_sk = i_item_sk
   and d_date in (select d_date
                  from date_dim
                  where d_month_seq = (select d_month_seq
                                      from date_dim
                                      where d_date = '1999-05-02'))
   and ss_sold_date_sk   = d_date_sk
   and ss_list_price between 217 and 246
   and i_manager_id BETWEEN 25 and 54
   and ss_customer_sk = c_customer_sk
   and c_birth_year BETWEEN 1961 AND 1967
group by i_item_id, c_birth_year),
 cs_items as
 (select i_item_id item_id
        ,c_birth_year birth_year
        ,sum(cs_ext_sales_price) cs_item_rev
  from catalog_sales
      ,item
      ,date_dim
      ,customer
 where cs_item_sk = i_item_sk
  and  d_date in (select d_date
                  from date_dim
                  where d_month_seq = (select d_month_seq
                                      from date_dim
                                      where d_date = '1999-05-02'))
  and  cs_sold_date_sk = d_date_sk
  and  cs_list_price between 217 and 246
  and i_manager_id BETWEEN 25 and 54
  and cs_bill_customer_sk = c_customer_sk
  and c_birth_year BETWEEN 1961 AND 1967
group by i_item_id, c_birth_year),
 ws_items as
 (select i_item_id item_id
      ,c_birth_year birth_year
        ,sum(ws_ext_sales_price) ws_item_rev
  from web_sales
      ,item
      ,date_dim
      ,customer
 where ws_item_sk = i_item_sk
  and  d_date in (select d_date
                  from date_dim
                  where d_month_seq = (select d_month_seq
                                     from date_dim
                                     where d_date = '1999-05-02'))
  and ws_sold_date_sk   = d_date_sk
  and ws_list_price between 217 and 246
  and i_manager_id BETWEEN 25 and 54
  and ws_bill_customer_sk = c_customer_sk
  and c_birth_year BETWEEN 1961 AND 1967
group by i_item_id, c_birth_year)
  select  ss_items.item_id, ss_items.birth_year
       ,ss_item_rev
       ,ss_item_rev/((ss_item_rev+cs_item_rev+ws_item_rev)/3) * 100 ss_dev
       ,cs_item_rev
       ,cs_item_rev/((ss_item_rev+cs_item_rev+ws_item_rev)/3) * 100 cs_dev
       ,ws_item_rev
       ,ws_item_rev/((ss_item_rev+cs_item_rev+ws_item_rev)/3) * 100 ws_dev
       ,(ss_item_rev+cs_item_rev+ws_item_rev)/3 average
 from ss_items,cs_items,ws_items
 where ss_items.item_id=cs_items.item_id
   and ss_items.item_id=ws_items.item_id
   and ss_items.birth_year = cs_items.birth_year
   and ss_items.birth_year = ws_items.birth_year
   and ss_item_rev between 0.9 * cs_item_rev and 1.1 * cs_item_rev
   and ss_item_rev between 0.9 * ws_item_rev and 1.1 * ws_item_rev
   and cs_item_rev between 0.9 * ss_item_rev and 1.1 * ss_item_rev
   and cs_item_rev between 0.9 * ws_item_rev and 1.1 * ws_item_rev
   and ws_item_rev between 0.9 * ss_item_rev and 1.1 * ss_item_rev
   and ws_item_rev between 0.9 * cs_item_rev and 1.1 * cs_item_rev
 order by item_id, birth_year
         ,ss_item_rev
 limit 100;
```

## DAG Structure & Bottlenecks

| Node | Role | Cost % | Key Operations |
|------|------|-------:|----------------|
| ss_items |  | 0.0% | — |
| cs_items |  | 0.0% | — |
| ws_items |  | 0.0% | — |
| main_query |  | 0.0% | — |

## Top 3 FAISS Examples (by structural similarity)

1. **pg_dimension_prefetch_star** (3.32xx) — On multi-channel UNION queries with comma-separated implicit joins, pre-filter dimension tables (date, item, promotion) 
2. **early_filter_decorrelate** (1.13xx) — 
3. **pg_self_join_decomposition** (3.93xx) — Eliminate duplicate fact table scans in self-join patterns by computing the aggregation ONCE in a CTE and deriving both 

## All Available Examples (full catalog — can swap if needed)

- **pg_date_cte_explicit_join** (2.28xx) — Isolate a selective date_dim filter into a CTE AND convert all comma-separated j
- **pg_dimension_prefetch_star** (3.32xx) — On multi-channel UNION queries with comma-separated implicit joins, pre-filter d
- **early_filter_decorrelate** (1.13xx) — 
- **pg_materialized_dimension_fact_prefilter** (2.68xx) — Pre-filter ALL dimension tables AND the fact table into MATERIALIZED CTEs, then 
- **pg_self_join_decomposition** (3.93xx) — Eliminate duplicate fact table scans in self-join patterns by computing the aggr

## Your Task

Design 4 DIFFERENT optimization strategies exploring diverse approaches. You may keep FAISS recommendations OR swap examples from the catalog.

**Constraints**:
- Each worker gets exactly 3 examples
- No duplicate examples across workers (12 total, 3 per worker)
- If fewer than 12 unique examples are available, reuse is allowed

**Diversity guidelines**:
- Worker 1: Conservative — proven patterns, low risk (e.g., pushdown, early filter)
- Worker 2: Moderate — date/dimension isolation, CTE restructuring
- Worker 3: Aggressive — multi-CTE restructuring, prefetch patterns
- Worker 4: Novel — OR-to-UNION, structural transforms, intersect-to-exists

For each worker, specify:
1. **Strategy name** (e.g., `aggressive_date_prefetch`)
2. **3 examples** to use (from FAISS picks or catalog)
3. **Strategy hint** (1-2 sentences guiding the optimization approach)

### Output Format (follow EXACTLY)

```
WORKER_1:
STRATEGY: <strategy_name>
EXAMPLES: <ex1>, <ex2>, <ex3>
HINT: <strategy guidance>

WORKER_2:
STRATEGY: <strategy_name>
EXAMPLES: <ex4>, <ex5>, <ex6>
HINT: <strategy guidance>

WORKER_3:
STRATEGY: <strategy_name>
EXAMPLES: <ex7>, <ex8>, <ex9>
HINT: <strategy guidance>

WORKER_4:
STRATEGY: <strategy_name>
EXAMPLES: <ex10>, <ex11>, <ex12>
HINT: <strategy guidance>
```