### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] sd_stores  [+]  Cost: 5%  Rows: ~10
│   ├── SCAN (store)
│   ├── FILTER (s_state = 'SD')
│   └── OUTPUT (s_store_sk)
├── [CTE] store_returns_filtered  [+]  Cost: 45%  Rows: ~500
│   ├── SCAN (store_returns, date_dim, sd_stores)
│   ├── JOIN (sr_returned_date_sk = d_date_sk AND sr_store_sk = s_store_sk)
│   ├── FILTER (d_year = 2000)
│   ├── AGG (GROUP BY sr_customer_sk, sr_store_sk)
│   └── OUTPUT (sr_customer_sk, sr_store_sk, ctr_total_return)
└── [MAIN] main_query  [~]  Cost: 50%  Rows: ~100
    ├── SCAN (store_returns_filtered AS ctr1 (join), customer (join), LATERAL (store_returns_filtered AS ctr2))
    ├── JOIN (ctr1.sr_customer_sk = c_customer_sk)
    ├── JOIN LATERAL (ctr1.sr_store_sk = ctr2.sr_store_sk)
    ├── FILTER (ctr_total_return > (AVG(ctr_total_return)*1.2))
    ├── SORT (c_customer_id ASC)
    └── OUTPUT (c_customer_id)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "snowflake",
  "rewrite_rules": [
    {
      "id": "R1",
      "type": "cte_isolate_dimension_filter",
      "description": "Early store filtering to reduce aggregation input",
      "applied_to": ["sd_stores"]
    },
    {
      "id": "R2",
      "type": "correlation_to_lateral",
      "description": "Convert correlated subquery to LATERAL join",
      "applied_to": ["main_query"]
    }
  ],
  "statements": [
    {
      "target_table": null,
      "change": "modified",
      "components": {
        "sd_stores": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT s_store_sk FROM store WHERE s_state = 'SD'",
          "interfaces": {
            "outputs": ["s_store_sk"],
            "consumes": []
          }
        },
        "store_returns_filtered": {
          "type": "cte",
          "change": "new",
          "sql": "SELECT sr_customer_sk, sr_store_sk, SUM(SR_FEE) AS ctr_total_return FROM store_returns INNER JOIN date_dim ON sr_returned_date_sk = d_date_sk INNER JOIN sd_stores ON sr_store_sk = s_store_sk WHERE d_year = 2000 GROUP BY sr_customer_sk, sr_store_sk",
          "interfaces": {
            "outputs": ["sr_customer_sk", "sr_store_sk", "ctr_total_return"],
            "consumes": ["sd_stores"]
          }
        },
        "main_query": {
          "type": "main_query",
          "change": "modified",
          "sql": "SELECT c_customer_id FROM store_returns_filtered ctr1, customer, LATERAL (SELECT AVG(ctr_total_return) * 1.2 AS avg_threshold FROM store_returns_filtered ctr2 WHERE ctr1.sr_store_sk = ctr2.sr_store_sk) WHERE ctr1.sr_customer_sk = c_customer_sk AND ctr_total_return > avg_threshold ORDER BY c_customer_id LIMIT 100",
          "interfaces": {
            "outputs": ["c_customer_id"],
            "consumes": ["store_returns_filtered"]
          }
        }
      },
      "reconstruction_order": ["sd_stores", "store_returns_filtered", "main_query"],
      "assembly_template": "WITH sd_stores AS ({sd_stores}), store_returns_filtered AS ({store_returns_filtered}) {main_query}"
    }
  ],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Restructured to isolate store filter early in CTE and use LATERAL for correlated aggregation. The early store filter reduces aggregation input from all stores to only SD stores (~10 rows), shrinking the subsequent aggregation input. The LATERAL maintains semantic equivalence to the original correlated subquery.

Expected speedup: 3-5x from reduced aggregation volume (500 vs original 1K+ rows) and efficient LATERAL execution on small store groups.