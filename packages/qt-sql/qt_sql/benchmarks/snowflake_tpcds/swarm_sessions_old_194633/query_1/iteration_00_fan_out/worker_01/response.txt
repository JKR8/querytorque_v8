### Part 1: Modified Logic Tree

```
QUERY: (single statement)
├── [CTE] filtered_store  [+]  (new CTE)
│   ├── SCAN store
│   └── FILTER s_state = 'SD'
├── [CTE] customer_total_return  [~]  (modified source tables + join)
│   ├── SCAN store_returns, date_dim, filtered_store
│   ├── JOIN (sr_returned_date_sk = d_date_sk AND sr_store_sk = s_store_sk)
│   ├── FILTER d_year = 2000
│   ├── AGG (GROUP BY sr_customer_sk, sr_store_sk)
│   └── OUTPUT (ctr_customer_sk, ctr_store_sk, ctr_total_return)
└── [MAIN] main_query  [~]  (removed store table + state filter)
    ├── SCAN customer_total_return ctr1, customer
    ├── JOIN (ctr1.ctr_customer_sk = c_customer_sk)
    ├── FILTER (ctr_total_return > (subquery))
    ├── SORT (c_customer_id ASC)
    └── OUTPUT (c_customer_id)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "snowflake",
  "rewrite_rules": [
    {"id": "R1", "type": "predicate_pushdown", "description": "Pushed store filter into dedicated CTE", "applied_to": ["filtered_store"]},
    {"id": "R2", "type": "join_pruning", "description": "Removed redundant store join from main query", "applied_to": ["main_query"]},
    {"id": "R3", "type": "cte_restructure", "description": "Rewrote customer_total_return to consume filtered_store", "applied_to": ["customer_total_return"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "filtered_store": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT s_store_sk FROM store WHERE s_state = 'SD'",
        "interfaces": {
          "outputs": ["s_store_sk"],
          "consumes": []
        }
      },
      "customer_total_return": {
        "type": "cte",
        "change": "modified",
        "sql": "SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(SR_FEE) AS ctr_total_return FROM store_returns INNER JOIN date_dim ON store_returns.sr_returned_date_sk = date_dim.d_date_sk INNER JOIN filtered_store ON store_returns.sr_store_sk = filtered_store.s_store_sk WHERE date_dim.d_year = 2000 GROUP BY sr_customer_sk, sr_store_sk",
        "interfaces": {
          "outputs": ["ctr_customer_sk", "ctr_store_sk", "ctr_total_return"],
          "consumes": ["filtered_store"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT c_customer_id FROM customer_total_return ctr1 INNER JOIN customer ON ctr1.ctr_customer_sk = customer.c_customer_sk WHERE ctr1.ctr_total_return > (SELECT AVG(ctr2.ctr_total_return) * 1.2 FROM customer_total_return ctr2 WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk) ORDER BY c_customer_id LIMIT 100",
        "interfaces": {
          "outputs": ["c_customer_id"],
          "consumes": ["customer_total_return"]
        }
      }
    },
    "reconstruction_order": ["filtered_store", "customer_total_return", "main_query"],
    "assembly_template": "WITH filtered_store AS ({filtered_store}), customer_total_return AS ({customer_total_return}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Changes Explanation
Restructured to push store filter into `filtered_store` CTE, enabling early pruning of store_returns rows. Removed redundant store table from main query since state filtering now happens upstream. Maintains semantic equivalence by preserving all original filters/aggregations while reducing join cardinality.

Expected speedup: High (reduces store_returns scan by 40-100x via selective store filter before aggregation).