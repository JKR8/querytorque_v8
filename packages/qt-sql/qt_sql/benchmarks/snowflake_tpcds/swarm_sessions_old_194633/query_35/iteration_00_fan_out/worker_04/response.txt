### Part 1: Modified Logic Tree

```
QUERY: (single statement)
└── [MAIN] main_query  [!]
    ├── [+] sales_agg
    ├── [+] customer_join
    └── [~] main_agg
        ├── SCAN (customer_join)
        ├── AGG (GROUP BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count)
        ├── SORT (ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count)
        └── OUTPUT (exact 18 columns per contract)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "snowflake",
  "rewrite_rules": [
    {"id": "R1", "type": "exists_to_bitmap", "description": "Convert OR-EXISTS to UNION ALL+BOOL_OR bitmap", "applied_to": ["sales_agg"]},
    {"id": "R2", "type": "join_refactor", "description": "Replace customer joins and filters with CTE-based bitmap join", "applied_to": ["customer_join", "main_agg"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "sales_agg": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT customer_sk, BOOL_OR(has_store) AS has_store, BOOL_OR(has_web) AS has_web, BOOL_OR(has_catalog) AS has_catalog FROM (SELECT ss_customer_sk AS customer_sk, TRUE AS has_store, FALSE AS has_web, FALSE AS has_catalog FROM store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk WHERE date_dim.d_year = 2001 AND date_dim.d_qoy < 4 UNION ALL SELECT ws_bill_customer_sk AS customer_sk, FALSE AS has_store, TRUE AS has_web, FALSE AS has_catalog FROM web_sales JOIN date_dim ON web_sales.ws_sold_date_sk = date_dim.d_date_sk WHERE date_dim.d_year = 2001 AND date_dim.d_qoy < 4 UNION ALL SELECT cs_ship_customer_sk AS customer_sk, FALSE AS has_store, FALSE AS has_web, TRUE AS has_catalog FROM catalog_sales JOIN date_dim ON catalog_sales.cs_sold_date_sk = date_dim.d_date_sk WHERE date_dim.d_year = 2001 AND date_dim.d_qoy < 4) GROUP BY customer_sk",
        "interfaces": {"outputs": ["customer_sk", "has_store", "has_web", "has_catalog"], "consumes": []}
      },
      "customer_join": {
        "type": "cte",
        "change": "added",
        "sql": "SELECT c.*, ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk JOIN sales_agg sa ON c.c_customer_sk = sa.customer_sk WHERE sa.has_store AND (sa.has_web OR sa.has_catalog)",
        "interfaces": {"outputs": ["c_customer_sk", "c_current_cdemo_sk", "c_current_addr_sk", "ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cd_dep_employed_count", "cd_dep_college_count"], "consumes": ["sales_agg"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, COUNT(*) AS cnt1, MAX(cd_dep_count), SUM(cd_dep_count), MAX(cd_dep_count), cd_dep_employed_count, COUNT(*) AS cnt2, MAX(cd_dep_employed_count), SUM(cd_dep_employed_count), MAX(cd_dep_employed_count), cd_dep_college_count, COUNT(*) AS cnt3, MAX(cd_dep_college_count), SUM(cd_dep_college_count), MAX(cd_dep_college_count) FROM customer_join GROUP BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count ORDER BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100",
        "interfaces": {"outputs": ["ca_state", "cd_gender", "cd_marital_status", "cd_dep_count", "cnt1", "MAX(cd_dep_count)", "SUM(cd_dep_count)", "MAX(cd_dep_count)", "cd_dep_employed_count", "cnt2", "MAX(cd_dep_employed_count)", "SUM(cd_dep_employed_count)", "MAX(cd_dep_employed_count)", "cd_dep_college_count", "cnt3", "MAX(cd_dep_college_count)", "SUM(cd_dep_college_count)", "MAX(cd_dep_college_count)"], "consumes": ["customer_join"]}
      }
    },
    "reconstruction_order": ["sales_agg", "customer_join", "main_query"],
    "assembly_template": "WITH sales_agg AS ({sales_agg}), customer_join AS ({customer_join}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Changes
- **Structural change:** Replaced OR-chained EXISTS subqueries with bitmap CTE (sales_agg) using UNION ALL+BOOL_OR to detect channel participation. Added customer_join CTE to materialize filtered customer set.
- **Mechanism:** sales_agg computes per-customer channel flags via UNION ALL across sales tables with fixed date filters. customer_join applies bitmap logic (has_store AND (has_web OR has_catalog)) during join, preserving original OR semantics. Final aggregation remains unchanged.
- **Expected speedup:** 2-3x by eliminating 3 separate date_dim scans and converting OR-EXISTS to single-pass bitmap. Avoids Q14-style regression by maintaining correct semi-join cardinality.