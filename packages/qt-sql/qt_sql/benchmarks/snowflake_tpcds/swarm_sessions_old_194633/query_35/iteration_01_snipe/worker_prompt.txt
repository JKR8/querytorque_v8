You are a senior SQL optimization architect for snowflake. You have FULL FREEDOM to design your own approach — you are NOT constrained to any specific logical tree topology or CTE structure. Your job: diagnose WHY previous workers failed to reach 2.0x, identify unexplored optimization angles, and produce an optimized SQL rewrite that reaches the target.

Preserve defensive guards: if the original uses CASE WHEN x > 0 THEN y/x END around a division, keep it — guards prevent silent breakage. Strip benchmark comments (-- start query, -- end query) from output.

## Target: >=2.0x speedup

Your target is >=2.0x speedup on this query. This is the bar. Anything below 2.0x is a miss.

## Previous Optimization Attempts
Target: **>=2.0x** | 4 workers tried | none reached target

### W1: date_cte_isolate → 0.0x ★ BEST [ERROR]
- **Examples**: date_cte_isolate, dimension_cte_split
- **Transforms**: date_cte_isolate
- **Approach**: Apply date filter consolidation from date_cte_isolate. Ignore dimension join asp
- **Error**: INTERFACE: [main_query] declares outputs ['max(cd_dep_college_count)', 'max(cd_dep_count)', 'max(cd_dep_employed_count)', 'sum(cd_dep_college_count)', 'sum(cd_dep_count)', 'sum(cd_dep_employed_count)'] but SELECT only produces ['ca_state', 'cd_dep_college_count', 'cd_dep_count', 'cd_dep_employed_count', 'cd_gender', 'cd_marital_status', 'cnt1', 'cnt2', 'cnt3'] | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
- **Optimized SQL:**
```sql
WITH date_cte AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2001 AND d_qoy < 4),
     store_sales_cte AS (SELECT ss_customer_sk FROM store_sales JOIN date_cte ON store_sales.ss_sold_date_sk = date_cte.d_date_sk),
     web_sales_cte AS (SELECT ws_bill_customer_sk FROM web_sales JOIN date_cte ON web_sales.ws_sold_date_sk = date_cte.d_date_sk),
     catalog_sales_cte AS (SELECT cs_ship_customer_sk FROM catalog_sales JOIN date_cte ON catalog_sales.cs_sold_date_sk = date_cte.d_date_sk)
SELECT
  ca_state,
  cd_gender,
  cd_marital_status,
  cd_dep_count,
  COUNT(*) cnt1,
  MAX(cd_dep_count),
  SUM(cd_dep_count),
  MAX(cd_dep_count),
  cd_dep_employed_count,
  COUNT(*) cnt2,
  MAX(cd_dep_employed_count),
  SUM(cd_dep_employed_count),
  MAX(cd_dep_employed_count),
  cd_dep_college_count,
  COUNT(*) cnt3,
  MAX(cd_dep_college_count),
  SUM(cd_dep_college_count),
  MAX(cd_dep_college_count)
FROM customer c
JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk
JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk
WHERE 
  c.c_customer_sk IN (SELECT ss_customer_sk FROM store_sales_cte)
  AND (
    c.c_customer_sk IN (SELECT ws_bill_customer_sk FROM web_sales_cte)
    OR c.c_customer_sk IN (SELECT cs_ship_customer_sk FROM catalog_sales_cte)
  )
GROUP BY 
  ca_state,
  cd_gender,
  cd_marital_status,
  cd_dep_count,
  cd_dep_employed_count,
  cd_dep_college_count
ORDER BY 
  ca_state,
  cd_gender,
  cd_marital_status,
  cd_dep_count,
  cd_dep_employed_count,
  cd_dep_college_count
LIMIT 100
```
- **Planner Diagnosis:**
```
[EXPLAIN failed — planner rejected this SQL]
Error: INTERFACE: [main_query] declares outputs ['max(cd_dep_college_count)', 'max(cd_dep_count)', 'max(cd_dep_employed_count)', 'sum(cd_dep_college_count)', 'sum(cd_dep_count)', 'sum(cd_dep_employed_count)'] but SELECT only produces ['ca_state', 'cd_dep_college_count', 'cd_dep_count', 'cd_dep_employed_count', 'cd_gender', 'cd_marital_status', 'cnt1', 'cnt2', 'cnt3'] | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
```

### W2: scan_consolidation_pivot → 0.0x ★ BEST [ERROR]
- **Examples**: single_pass_aggregation, union_cte_split
- **Transforms**: pushdown
- **Approach**: Use UNION pattern from union_cte_split but retain EXISTS check from original
- **Error**: INTERFACE: [all_sales_cte] declares outputs ['channel', 'customer_sk'] but SELECT only produces ['catalog', 'cs_ship_customer_sk'] | INTERFACE: [all_sales_cte] SELECT produces ['catalog', 'cs_ship_customer_sk'] not declared in outputs | INTERFACE: [customer_filter] declares outputs ['...all other customer columns...', 'c_current_cdemo_sk', 'c_customer_sk'] but SELECT only produces ['*', 'ca_state'] | INTERFACE: [customer_filter] SELECT produces ['*'] not declared in outputs | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
- **Optimized SQL:**
```sql
WITH all_sales_cte AS (SELECT ss_customer_sk AS customer_sk, 'store' AS channel FROM store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk WHERE date_dim.d_year = 2001 AND date_dim.d_qoy < 4 UNION ALL SELECT ws_bill_customer_sk, 'web' FROM web_sales JOIN date_dim ON web_sales.ws_sold_date_sk = date_dim.d_date_sk WHERE date_dim.d_year = 2001 AND date_dim.d_qoy < 4 UNION ALL SELECT cs_ship_customer_sk, 'catalog' FROM catalog_sales JOIN date_dim ON catalog_sales.cs_sold_date_sk = date_dim.d_date_sk WHERE date_dim.d_year = 2001 AND date_dim.d_qoy < 4), customer_filter AS (SELECT c.*, ca.ca_state FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk WHERE EXISTS (SELECT 1 FROM all_sales_cte WHERE channel = 'store' AND customer_sk = c.c_customer_sk) AND (EXISTS (SELECT 1 FROM all_sales_cte WHERE channel = 'web' AND customer_sk = c.c_customer_sk) OR EXISTS (SELECT 1 FROM all_sales_cte WHERE channel = 'catalog' AND customer_sk = c.c_customer_sk))) SELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, COUNT(*) AS cnt1, MAX(cd_dep_count) AS "MAX(cd_dep_count)", SUM(cd_dep_count) AS "SUM(cd_dep_count)", MAX(cd_dep_count) AS "MAX(cd_dep_count)", cd_dep_employed_count, COUNT(*) AS cnt2, MAX(cd_dep_employed_count) AS "MAX(cd_dep_employed_count)", SUM(cd_dep_employed_count) AS "SUM(cd_dep_employed_count)", MAX(cd_dep_employed_count) AS "MAX(cd_dep_employed_count)", cd_dep_college_count, COUNT(*) AS cnt3, MAX(cd_dep_college_count) AS "MAX(cd_dep_college_count)", SUM(cd_dep_college_count) AS "SUM(cd_dep_college_count)", MAX(cd_dep_college_count) AS "MAX(cd_dep_college_count)" FROM customer_filter cf JOIN customer_demographics cd ON cd.cd_demo_sk = cf.c_current_cdemo_sk GROUP BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count ORDER BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100
```
- **Planner Diagnosis:**
```
[EXPLAIN failed — planner rejected this SQL]
Error: INTERFACE: [all_sales_cte] declares outputs ['channel', 'customer_sk'] but SELECT only produces ['catalog', 'cs_ship_customer_sk'] | INTERFACE: [all_sales_cte] SELECT produces ['catalog', 'cs_ship_customer_sk'] not declared in outputs | INTERFACE: [customer_filter] declares outputs ['...all other customer columns...', 'c_current_cdemo_sk', 'c_customer_sk'] but SELECT only produces ['*', 'ca_state'] | INTERFACE: [customer_filter] SELECT produces ['*'] not declared in outputs | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
```

### W3: star_join_prefetch → 0.0x ★ BEST [ERROR]
- **Examples**: prefetch_fact_join, dimension_cte_split
- **Approach**: Use UNION pattern from prefetch_fact_join but preserve EXISTS logic via semi-joi
- **Error**: INTERFACE: [main_query] declares outputs ['max(cd_dep_college_count)', 'max(cd_dep_count)', 'max(cd_dep_employed_count)', 'sum(cd_dep_college_count)', 'sum(cd_dep_count)', 'sum(cd_dep_employed_count)'] but SELECT only produces ['ca_state', 'cd_dep_college_count', 'cd_dep_count', 'cd_dep_employed_count', 'cd_gender', 'cd_marital_status', 'cnt1', 'cnt2', 'cnt3'] | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
- **Optimized SQL:**
```sql
-- start query 35 in stream 0 using template query35.tpl
select  
  ca_state,
  cd_gender,
  cd_marital_status,
  cd_dep_count,
  count(*) cnt1,
  max(cd_dep_count),
  sum(cd_dep_count),
  max(cd_dep_count),
  cd_dep_employed_count,
  count(*) cnt2,
  max(cd_dep_employed_count),
  sum(cd_dep_employed_count),
  max(cd_dep_employed_count),
  cd_dep_college_count,
  count(*) cnt3,
  max(cd_dep_college_count),
  sum(cd_dep_college_count),
  max(cd_dep_college_count)
 from
  customer c,customer_address ca,customer_demographics
 where
  c.c_current_addr_sk = ca.ca_address_sk and
  cd_demo_sk = c.c_current_cdemo_sk and 
  exists (select *
          from store_sales,date_dim
          where c.c_customer_sk = ss_customer_sk and
                ss_sold_date_sk = d_date_sk and
                d_year = 2001 and
                d_qoy < 4) and
   (exists (select *
            from web_sales,date_dim
            where c.c_customer_sk = ws_bill_customer_sk and
                  ws_sold_date_sk = d_date_sk and
                  d_year = 2001 and
                  d_qoy < 4) or 
    exists (select * 
            from catalog_sales,date_dim
            where c.c_customer_sk = cs_ship_customer_sk and
                  cs_sold_date_sk = d_date_sk and
                  d_year = 2001 and
                  d_qoy < 4))
 group by ca_state,
          cd_gender,
          cd_marital_status,
          cd_dep_count,
          cd_dep_employed_count,
          cd_dep_college_count
 order by ca_state,
          cd_gender,
          cd_marital_status,
          cd_dep_count,
          cd_dep_employed_count,
          cd_dep_college_count
 LIMIT 100;

-- end query 35 in stream 0 using template query35.tpl
```

### W4: single_pass_aggregation → 0.0x ★ BEST [ERROR]
- **Examples**: channel_bitmap_aggregation
- **Transforms**: dimension_cte_isolate
- **Approach**: Use BOOL_OR technique but preserve original EXISTS logic in WHERE
- **Error**: INTERFACE: [customer_join] declares outputs ['c_current_addr_sk', 'c_current_cdemo_sk', 'c_customer_sk'] but SELECT only produces ['*', 'ca_state', 'cd_dep_college_count', 'cd_dep_count', 'cd_dep_employed_count', 'cd_gender', 'cd_marital_status'] | INTERFACE: [customer_join] SELECT produces ['*'] not declared in outputs | INTERFACE: [main_query] declares outputs ['max(cd_dep_college_count)', 'max(cd_dep_count)', 'max(cd_dep_employed_count)', 'sum(cd_dep_college_count)', 'sum(cd_dep_count)', 'sum(cd_dep_employed_count)'] but SELECT only produces ['ca_state', 'cd_dep_college_count', 'cd_dep_count', 'cd_dep_employed_count', 'cd_gender', 'cd_marital_status', 'cnt1', 'cnt2', 'cnt3'] | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
- **Optimized SQL:**
```sql
WITH sales_agg AS (SELECT customer_sk, BOOL_OR(has_store) AS has_store, BOOL_OR(has_web) AS has_web, BOOL_OR(has_catalog) AS has_catalog FROM (SELECT ss_customer_sk AS customer_sk, TRUE AS has_store, FALSE AS has_web, FALSE AS has_catalog FROM store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk WHERE date_dim.d_year = 2001 AND date_dim.d_qoy < 4 UNION ALL SELECT ws_bill_customer_sk AS customer_sk, FALSE AS has_store, TRUE AS has_web, FALSE AS has_catalog FROM web_sales JOIN date_dim ON web_sales.ws_sold_date_sk = date_dim.d_date_sk WHERE date_dim.d_year = 2001 AND date_dim.d_qoy < 4 UNION ALL SELECT cs_ship_customer_sk AS customer_sk, FALSE AS has_store, FALSE AS has_web, TRUE AS has_catalog FROM catalog_sales JOIN date_dim ON catalog_sales.cs_sold_date_sk = date_dim.d_date_sk WHERE date_dim.d_year = 2001 AND date_dim.d_qoy < 4) GROUP BY customer_sk), customer_join AS (SELECT c.*, ca.ca_state, cd.cd_gender, cd.cd_marital_status, cd.cd_dep_count, cd.cd_dep_employed_count, cd.cd_dep_college_count FROM customer c JOIN customer_address ca ON c.c_current_addr_sk = ca.ca_address_sk JOIN customer_demographics cd ON cd.cd_demo_sk = c.c_current_cdemo_sk JOIN sales_agg sa ON c.c_customer_sk = sa.customer_sk WHERE sa.has_store AND (sa.has_web OR sa.has_catalog)) SELECT ca_state, cd_gender, cd_marital_status, cd_dep_count, COUNT(*) AS cnt1, MAX(cd_dep_count), SUM(cd_dep_count), MAX(cd_dep_count), cd_dep_employed_count, COUNT(*) AS cnt2, MAX(cd_dep_employed_count), SUM(cd_dep_employed_count), MAX(cd_dep_employed_count), cd_dep_college_count, COUNT(*) AS cnt3, MAX(cd_dep_college_count), SUM(cd_dep_college_count), MAX(cd_dep_college_count) FROM customer_join GROUP BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count ORDER BY ca_state, cd_gender, cd_marital_status, cd_dep_count, cd_dep_employed_count, cd_dep_college_count LIMIT 100
```
- **Planner Diagnosis:**
```
[EXPLAIN failed — planner rejected this SQL]
Error: INTERFACE: [customer_join] declares outputs ['c_current_addr_sk', 'c_current_cdemo_sk', 'c_customer_sk'] but SELECT only produces ['*', 'ca_state', 'cd_dep_college_count', 'cd_dep_count', 'cd_dep_employed_count', 'cd_gender', 'cd_marital_status'] | INTERFACE: [customer_join] SELECT produces ['*'] not declared in outputs | INTERFACE: [main_query] declares outputs ['max(cd_dep_college_count)', 'max(cd_dep_count)', 'max(cd_dep_employed_count)', 'sum(cd_dep_college_count)', 'sum(cd_dep_count)', 'sum(cd_dep_employed_count)'] but SELECT only produces ['ca_state', 'cd_dep_college_count', 'cd_dep_count', 'cd_dep_employed_count', 'cd_gender', 'cd_marital_status', 'cnt1', 'cnt2', 'cnt3'] | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
```


## Original Execution Plan (EXPLAIN ANALYZE)

Compare each candidate's plan (above) against this baseline.

```
GlobalStats | 155740 | 155740 | 2639701907968
1 | 0 | Result | CA.CA_STATE, CUSTOMER_DEMOGRAPHICS.CD_GENDER, CUSTOMER_DEMOGRAPHICS.CD_MARITAL_STATUS, CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT, COUNT(*), MAX(MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT)), SUM(SUM_INTERNAL(CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT, COUNT(*))), MAX(MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT)), CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT, COUNT(*), MAX(MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT)), SUM(SUM_INTERNAL(CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT, COUNT(*))), MAX(MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT)), CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT, COUNT(*), MAX(MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT)), SUM(SUM_INTERNAL(CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT, COUNT(*))), MAX(MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT))
1 | 1 | [0] | SortWithLimit | sortKey: [CA.CA_STATE ASC NULLS LAST, CUSTOMER_DEMOGRAPHICS.CD_GENDER ASC NULLS LAST, CUSTOMER_DEMOGRAPHICS.CD_MARITAL_STATUS ASC NULLS LAST, CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT ASC NULLS LAST, CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT ASC NULLS LAST, CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT ASC NULLS LAST], rowCount: 100
1 | 2 | [1] | Aggregate | aggExprs: [COUNT(*), MAX(MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT)), SUM(SUM_INTERNAL(CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT, COUNT(*))), MAX(MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT)), SUM(SUM_INTERNAL(CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT, COUNT(*))), MAX(MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT)), SUM(SUM_INTERNAL(CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT, COUNT(*)))], groupKeys: [CA.CA_STATE, CUSTOMER_DEMOGRAPHICS.CD_GENDER, CUSTOMER_DEMOGRAPHICS.CD_MARITAL_STATUS, CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT, CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT, CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT]
1 | 3 | [2] | Aggregate | aggExprs: [COUNT(*), MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT), SUM_INTERNAL(CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT, COUNT(*)), MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT), SUM_INTERNAL(CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT, COUNT(*)), MAX(CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT), SUM_INTERNAL(CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT, COUNT(*))], groupKeys: [CA.CA_STATE, CUSTOMER_DEMOGRAPHICS.CD_GENDER, CUSTOMER_DEMOGRAPHICS.CD_MARITAL_STATUS, CUSTOMER_DEMOGRAPHICS.CD_DEP_COUNT, CUSTOMER_DEMOGRAPHICS.CD_DEP_EMPLOYED_COUNT, CUSTOMER_DEMOGRAPHICS.CD_DEP_COLLEGE_COUNT]
1 | 4 | [3] | InnerJoin | joinKey: (CUSTOMER_DEMOGRAPHICS.CD_DEMO_SK = C.C_CURRENT_CDEMO_SK)
1 | 5 | [4] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CUSTOMER_DEMOGRAPHICS | CD_DEMO_SK, CD_GENDER, CD_MARITAL_STATUS, CD_DEP_COUNT, CD_DEP_EMPLOYED_COUNT, CD_DEP_COLLEGE_COUNT | 1 | 1 | 7446528
1 | 6 | [4] | Aggregate | aggExprs: [COUNT(*)], groupKeys: [CA.CA_STATE, C.C_CURRENT_CDEMO_SK]
1 | 7 | [6] | InnerJoin | joinKey: (CA.CA_ADDRESS_SK = C.C_CURRENT_ADDR_SK)
1 | 8 | [7] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CUSTOMER_ADDRESS | CA | CA_ADDRESS_SK, CA_STATE | 256 | 256 | 776454656
1 | 9 | [7] | Aggregate | aggExprs: [COUNT(*)], groupKeys: [C.C_CURRENT_CDEMO_SK, C.C_CURRENT_ADDR_SK]
1 | 10 | [9] | SemiJoin | joinKey: (C.C_CUSTOMER_SK = STORE_SALES.SS_CUSTOMER_SK)
1 | 11 | [10] | Aggregate | aggExprs: [COUNT(*)], groupKeys: [C.C_CURRENT_CDEMO_SK, C.C_CURRENT_ADDR_SK, C.C_CUSTOMER_SK]
1 | 12 | [11] | Filter | (CATALOG_SALES.CS_SHIP_CUSTOMER_SK IS NOT NULL) OR (WEB_SALES.WS_BILL_CUSTOMER_SK IS NOT NULL)
1 | 13 | [12] | LeftOuterJoin | joinKey: (CATALOG_SALES.CS_SHIP_CUSTOMER_SK = C.C_CUSTOMER_SK)
1 | 14 | [13] | Aggregate | groupKeys: [CATALOG_SALES.CS_SHIP_CUSTOMER_SK]
1 | 15 | [14] | Aggregate | groupKeys: [CATALOG_SALES.CS_SHIP_CUSTOMER_SK]
1 | 16 | [15] | SemiJoin | joinKey: (DATE_DIM.D_DATE_SK = CATALOG_SALES.CS_SOLD_DATE_SK)
1 | 17 | [16] | Aggregate | groupKeys: [DATE_DIM.D_DATE_SK]
1 | 18 | [17] | Filter | (DATE_DIM.D_YEAR = 2001) AND (DATE_DIM.D_QOY < 4)
1 | 19 | [18] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.DATE_DIM | D_DATE_SK, D_YEAR, D_QOY | 1 | 1 | 2138624
1 | 20 | [16] | Aggregate | groupKeys: [CATALOG_SALES.CS_SHIP_CUSTOMER_SK, CATALOG_SALES.CS_SOLD_DATE_SK]
1 | 21 | [20] | Filter | (CATALOG_SALES.CS_SHIP_CUSTOMER_SK IS NOT NULL) AND (CATALOG_SALES.CS_SOLD_DATE_SK IS NOT NULL)
1 | 22 | [21] | JoinFilter | joinKey: (DATE_DIM.D_DATE_SK = CATALOG_SALES.CS_SOLD_DATE_SK)
1 | 23 | [22] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CATALOG_SALES | CS_SOLD_DATE_SK, CS_SHIP_CUSTOMER_SK | 54922 | 54922 | 923617475584
1 | 24 | [13] | LeftOuterJoin | joinKey: (WEB_SALES.WS_BILL_CUSTOMER_SK = C.C_CUSTOMER_SK)
1 | 25 | [24] | Aggregate | groupKeys: [WEB_SALES.WS_BILL_CUSTOMER_SK]
1 | 26 | [25] | Aggregate | groupKeys: [WEB_SALES.WS_BILL_CUSTOMER_SK]
1 | 27 | [26] | SemiJoin | joinKey: (DATE_DIM.D_DATE_SK = WEB_SALES.WS_SOLD_DATE_SK)
1 | 28 | [27] | Aggregate | groupKeys: [DATE_DIM.D_DATE_SK]
1 | 29 | [28] | Filter | (DATE_DIM.D_YEAR = 2001) AND (DATE_DIM.D_QOY < 4)
1 | 30 | [29] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.DATE_DIM | D_DATE_SK, D_YEAR, D_QOY | 1 | 1 | 2138624
1 | 31 | [27] | Aggregate | groupKeys: [WEB_SALES.WS_BILL_CUSTOMER_SK, WEB_SALES.WS_SOLD_DATE_SK]
1 | 32 | [31] | Filter | (WEB_SALES.WS_BILL_CUSTOMER_SK IS NOT NULL) AND (WEB_SALES.WS_SOLD_DATE_SK IS NOT NULL)
1 | 33 | [32] | JoinFilter | joinKey: (DATE_DIM.D_DATE_SK = WEB_SALES.WS_SOLD_DATE_SK)
1 | 34 | [33] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.WEB_SALES | WS_SOLD_DATE_SK, WS_BILL_CUSTOMER_SK | 27579 | 27579 | 461041485824
1 | 35 | [24] | Filter | C.C_CURRENT_CDEMO_SK IS NOT NULL
1 | 36 | [35] | JoinFilter | joinKey: (CUSTOMER_DEMOGRAPHICS.CD_DEMO_SK = C.C_CURRENT_CDEMO_SK)
1 | 37 | [36] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CUSTOMER | C | C_CUSTOMER_SK, C_CURRENT_CDEMO_SK, C_CURRENT_ADDR_SK | 261 | 261 | 2328538624
1 | 38 | [10] | SemiJoin | joinKey: (DATE_DIM.D_DATE_SK = STORE_SALES.SS_SOLD_DATE_SK)
1 | 39 | [38] | Aggregate | groupKeys: [DATE_DIM.D_DATE_SK]
1 | 40 | [39] | Filter | (DATE_DIM.D_YEAR = 2001) AND (DATE_DIM.D_QOY < 4)
1 | 41 | [40] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.DATE_DIM | D_DATE_SK, D_YEAR, D_QOY | 1 | 1 | 2138624
1 | 42 | [38] | Filter | (STORE_SALES.SS_CUSTOMER_SK IS NOT NULL) AND (STORE_SALES.SS_SOLD_DATE_SK IS NOT NULL)
1 | 43 | [42] | JoinFilter | joinKey: (C.C_CUSTOMER_SK = STORE_SALES.SS_CUSTOMER_SK)
1 | 44 | [43] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.STORE_SALES | SS_SOLD_DATE_SK, SS_CUSTOMER_SK | 72718 | 72718 | 1251924090880
```

## Semantic Contract (MUST preserve)

This query identifies customer demographic patterns across three sales channels (store/web/catalog) during Q1-3 of 2001. All joins are INNER except for optional sales channel participation (OR-exists). Aggregations use COUNT(*) which is duplicate-sensitive due to potential sales joins. Critical filters (d_year=2001, d_qoy<4) must remain exact to avoid temporal scope creep.

## Bottleneck Diagnosis

Scan-bound with 3 separate sales table scans (store/web/catalog) each joining to date_dim. Cardinality flow: 261 customers → 3 sales scans (72718/54922/27579 rows) → 100 output groups. Optimizer handles customer-demographic joins well via bloom filters. Logical-tree costs mislead - physical plan shows 2.63 trillion bytes processed despite LIMIT 100.

## Engine Profile

*Discovery mode — 10 strengths from docs/research, 9 hypothesized gaps in playbook. Collecting empirical evidence.*

### Optimizer Strengths (DO NOT fight these)
- **MICRO_PARTITION_PRUNING**: Filters on clustered columns skip micro-partitions at scan level
- **COLUMN_PRUNING**: Reads only columns referenced by final query, even through CTEs
- **PREDICATE_PUSHDOWN**: Filters pushed to storage layer including through single-ref CTEs
- **CORRELATED_DECORRELATION**: Correlated subqueries automatically decorrelated to hash joins
- **SEMI_JOIN**: EXISTS → SemiJoin with early termination
- **JOIN_FILTER**: Bloom filter pushdown from build side to probe-side TableScan
- **COST_BASED_JOIN_ORDER**: Evaluates multiple join orders, selects lowest cost
- **METADATA_SCAN_ELIMINATION**: MIN/MAX/COUNT served from micro-partition metadata without scan
- **QUALIFY_OPTIMIZATION**: Native window-function filtering, more efficient than nested subquery
- **DISTRIBUTED_AGGREGATION**: Multi-level partial aggregation for parallel warehouse execution

## Correctness Invariants (HARD STOPS — non-negotiable)

These 4 constraints are absolute. Even with full creative freedom, you may NEVER violate these:

- **COMPLETE_OUTPUT**: The rewritten query must output ALL columns from the original SELECT. Never drop, rename, or reorder output columns. Every column alias must be preserved exactly as in the original.
- **CTE_COLUMN_COMPLETENESS**: CRITICAL: When creating or modifying a CTE, its SELECT list MUST include ALL columns referenced by downstream queries. Check the Node Contracts section: every column in downstream_refs MUST appear in the CTE output. Also ensure: (1) JOIN columns used by consumers are included in SELECT, (2) every table referenced in WHERE is present in FROM/JOIN, (3) no ambiguous column names between the CTE and re-joined tables. Dropping a column that a downstream node needs will cause an execution error.
- **LITERAL_PRESERVATION**: CRITICAL: When rewriting SQL, you MUST copy ALL literal values (strings, numbers, dates) EXACTLY from the original query. Do NOT invent, substitute, or 'improve' any filter values. If the original says d_year = 2000, your rewrite MUST say d_year = 2000. If the original says ca_state = 'GA', your rewrite MUST say ca_state = 'GA'. Changing these values will produce WRONG RESULTS and the rewrite will be REJECTED.
- **SEMANTIC_EQUIVALENCE**: The rewritten query MUST return exactly the same rows, columns, and ordering as the original. This is the prime directive. Any rewrite that changes the result set — even by one row, one column, or a different sort order — is WRONG and will be REJECTED.

## Aggregation Semantics Check (HARD STOP)

- STDDEV_SAMP/VARIANCE are grouping-sensitive — changing group membership changes the result.
- AVG and STDDEV are NOT duplicate-safe.
- FILTER over a combined group != separate per-group computation.
- Verify aggregation equivalence for ANY proposed restructuring.

## Original SQL

```sql
select  
  ca_state,
  cd_gender,
  cd_marital_status,
  cd_dep_count,
  count(*) cnt1,
  max(cd_dep_count),
  sum(cd_dep_count),
  max(cd_dep_count),
  cd_dep_employed_count,
  count(*) cnt2,
  max(cd_dep_employed_count),
  sum(cd_dep_employed_count),
  max(cd_dep_employed_count),
  cd_dep_college_count,
  count(*) cnt3,
  max(cd_dep_college_count),
  sum(cd_dep_college_count),
  max(cd_dep_college_count)
 from
  customer c,customer_address ca,customer_demographics
 where
  c.c_current_addr_sk = ca.ca_address_sk and
  cd_demo_sk = c.c_current_cdemo_sk and 
  exists (select *
          from store_sales,date_dim
          where c.c_customer_sk = ss_customer_sk and
                ss_sold_date_sk = d_date_sk and
                d_year = 2001 and
                d_qoy < 4) and
   (exists (select *
            from web_sales,date_dim
            where c.c_customer_sk = ws_bill_customer_sk and
                  ws_sold_date_sk = d_date_sk and
                  d_year = 2001 and
                  d_qoy < 4) or 
    exists (select * 
            from catalog_sales,date_dim
            where c.c_customer_sk = cs_ship_customer_sk and
                  cs_sold_date_sk = d_date_sk and
                  d_year = 2001 and
                  d_qoy < 4))
 group by ca_state,
          cd_gender,
          cd_marital_status,
          cd_dep_count,
          cd_dep_employed_count,
          cd_dep_college_count
 order by ca_state,
          cd_gender,
          cd_marital_status,
          cd_dep_count,
          cd_dep_employed_count,
          cd_dep_college_count
 LIMIT 100;
```

## Your Task — Self-Directed Retry

Work through these 3 steps in a `<reasoning>` block, then output your optimized SQL:

1. **DIAGNOSE**: Why did the best worker achieve 0.0x instead of the 2.0x target? What do the EXPLAIN plans reveal about the actual execution bottleneck?
2. **IDENTIFY**: What optimization angles are still unexplored? What did the empirical results reveal that couldn't have been known before seeing the execution plans?
3. **REWRITE**: Produce optimized SQL that exploits the angles you identified. You may build on the best foundation or start fresh.

## Rewrite Checklist (must pass before final SQL)

- Verify output schema matches the Column Completeness Contract (same columns, same names, same order).
- Keep all semantic invariants from `Correctness Invariants` (including join/null behavior).
- Verify aggregation equivalence: same rows participate in each group, same aggregate semantics.
- Preserve all literals exactly (numbers, strings, date values).
- Apply `Hazard Flags` as hard guards against known failure modes.

### Column Completeness Contract

Your `main_query` component MUST produce **exactly** these output columns (same names, same order):

  1. `ca_state`
  2. `cd_gender`
  3. `cd_marital_status`
  4. `cd_dep_count`
  5. `cnt1`
  6. `MAX(cd_dep_count)`
  7. `SUM(cd_dep_count)`
  8. `MAX(cd_dep_count)`
  9. `cd_dep_employed_count`
  10. `cnt2`
  11. `MAX(cd_dep_employed_count)`
  12. `SUM(cd_dep_employed_count)`
  13. `MAX(cd_dep_employed_count)`
  14. `cd_dep_college_count`
  15. `cnt3`
  16. `MAX(cd_dep_college_count)`
  17. `SUM(cd_dep_college_count)`
  18. `MAX(cd_dep_college_count)`

Do NOT add, remove, or rename any output columns. The result set schema must be identical to the original query.

## Output Format

Your response has **two parts** in order:

### Part 1: Modified Logic Tree

Show what changed using change markers. Generate the tree BEFORE writing SQL.

Change markers:
- `[+]` — New component added
- `[-]` — Component removed
- `[~]` — Component modified (describe what changed)
- `[=]` — Unchanged (no children needed)
- `[!]` — Structural change (e.g. CTE → subquery)

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "<dialect>",
  "rewrite_rules": [
    {"id": "R1", "type": "<transform_name>", "description": "<what changed>", "applied_to": ["<component_id>"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "<cte_name>": {
        "type": "cte",
        "change": "modified",
        "sql": "<complete SQL for this CTE body>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<upstream_id>"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "<final SELECT>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<cte_name>"]}
      }
    },
    "reconstruction_order": ["<cte_name>", "main_query"],
    "assembly_template": "WITH <cte_name> AS ({<cte_name>}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Rules
- **Tree first, always.** Generate the Logic Tree before writing any SQL
- **One component at a time.** When writing SQL for component X, treat others as opaque interfaces
- **No ellipsis.** Every `sql` value must be complete, executable SQL
- **Frozen blocks are copy-paste.** Large CASE-WHEN lookups must be verbatim
- **Validate interfaces.** Verify every `consumes` reference exists in upstream `outputs`
- Only include components you **changed or added** — set unchanged components to `"change": "unchanged"` with `"sql": ""`
- `main_query` output columns must match the Column Completeness Contract above
- `reconstruction_order`: topological order of components for assembly

After the JSON, explain the mechanism:

```
Changes: <1-2 sentences: what structural change + the expected mechanism>
Expected speedup: <estimate>
```

Now output your Logic Tree and Component Payload JSON: