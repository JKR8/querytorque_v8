### Part 1: Modified Logic Tree

```
QUERY: (single statement with CTEs)
└── [MAIN] main_query  [~]  (restructured to use CTEs)
    ├── [CTE] time_buckets  [+]  (new time bucketing logic)
    ├── [CTE] sales_agg  [+]  (single-pass aggregation)
    ├── [CTE] final  [+]  (pivoted counts)
    └── OUTPUT (*)
```

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "snowflake",
  "rewrite_rules": [
    {"id": "R1", "type": "cte_introduction", "description": "Restructure repeated subqueries into CTEs with time bucketing", "applied_to": ["main_query"]},
    {"id": "R2", "type": "conditional_aggregation", "description": "Replace 8 subqueries with single-pass aggregation", "applied_to": ["sales_agg", "final"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "time_buckets": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT t_time_sk, CASE WHEN (t_hour = 8 AND t_minute >= 30) THEN 1 WHEN (t_hour = 9 AND t_minute < 30) THEN 2 WHEN (t_hour = 9 AND t_minute >= 30) THEN 3 WHEN (t_hour = 10 AND t_minute < 30) THEN 4 WHEN (t_hour = 10 AND t_minute >= 30) THEN 5 WHEN (t_hour = 11 AND t_minute < 30) THEN 6 WHEN (t_hour = 11 AND t_minute >= 30) THEN 7 WHEN (t_hour = 12 AND t_minute < 30) THEN 8 END AS interval_id FROM time_dim WHERE ((t_hour = 8 AND t_minute >= 30) OR (t_hour = 9 AND t_minute < 30) OR (t_hour = 9 AND t_minute >= 30) OR (t_hour = 10 AND t_minute < 30) OR (t_hour = 10 AND t_minute >= 30) OR (t_hour = 11 AND t_minute < 30) OR (t_hour = 11 AND t_minute >= 30) OR (t_hour = 12 AND t_minute < 30))",
        "interfaces": {
          "outputs": ["t_time_sk", "interval_id"],
          "consumes": []
        }
      },
      "sales_agg": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT tb.interval_id, COUNT(*) AS cnt FROM store_sales ss JOIN time_buckets tb ON ss.ss_sold_time_sk = tb.t_time_sk JOIN store s ON ss.ss_store_sk = s.s_store_sk JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk WHERE s.s_store_name = 'ese' AND ((hd.hd_dep_count = -1 AND hd.hd_vehicle_count <= 1) OR (hd.hd_dep_count = 4 AND hd.hd_vehicle_count <= 6) OR (hd.hd_dep_count = 3 AND hd.hd_vehicle_count <= 5)) GROUP BY tb.interval_id",
        "interfaces": {
          "outputs": ["interval_id", "cnt"],
          "consumes": ["time_buckets"]
        }
      },
      "final": {
        "type": "cte",
        "change": "new",
        "sql": "SELECT COALESCE(MAX(CASE WHEN interval_id = 1 THEN cnt END), 0) AS h8_30_to_9, COALESCE(MAX(CASE WHEN interval_id = 2 THEN cnt END), 0) AS h9_to_9_30, COALESCE(MAX(CASE WHEN interval_id = 3 THEN cnt END), 0) AS h9_30_to_10, COALESCE(MAX(CASE WHEN interval_id = 4 THEN cnt END), 0) AS h10_to_10_30, COALESCE(MAX(CASE WHEN interval_id = 5 THEN cnt END), 0) AS h10_30_to_11, COALESCE(MAX(CASE WHEN interval_id = 6 THEN cnt END), 0) AS h11_to_11_30, COALESCE(MAX(CASE WHEN interval_id = 7 THEN cnt END), 0) AS h11_30_to_12, COALESCE(MAX(CASE WHEN interval_id = 8 THEN cnt END), 0) AS h12_to_12_30 FROM sales_agg",
        "interfaces": {
          "outputs": ["h8_30_to_9", "h9_to_9_30", "h9_30_to_10", "h10_to_10_30", "h10_30_to_11", "h11_to_11_30", "h11_30_to_12", "h12_to_12_30"],
          "consumes": ["sales_agg"]
        }
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "SELECT * FROM final",
        "interfaces": {
          "outputs": ["h8_30_to_9", "h9_to_9_30", "h9_30_to_10", "h10_to_10_30", "h10_30_to_11", "h11_to_11_30", "h11_30_to_12", "h12_to_12_30"],
          "consumes": ["final"]
        }
      }
    },
    "reconstruction_order": ["time_buckets", "sales_agg", "final", "main_query"],
    "assembly_template": "WITH time_buckets AS ({time_buckets}), sales_agg AS ({sales_agg}), final AS ({final}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

Changes: Replaced 8 repeated subqueries with CTE-based time bucketing and single-pass aggregation. Early time categorization reduces intermediate rows before joining with dimensions. COALESCE ensures 0-count intervals are preserved.

Expected speedup: 8x reduction in fact table scans and 8x reduction in dimension joins.