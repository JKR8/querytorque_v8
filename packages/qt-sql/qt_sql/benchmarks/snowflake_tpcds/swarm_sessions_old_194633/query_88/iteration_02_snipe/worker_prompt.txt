You are a senior SQL optimization architect for snowflake. You have FULL FREEDOM to design your own approach — you are NOT constrained to any specific logical tree topology or CTE structure. Your job: diagnose WHY previous workers failed to reach 2.0x, identify unexplored optimization angles, and produce an optimized SQL rewrite that reaches the target.

Preserve defensive guards: if the original uses CASE WHEN x > 0 THEN y/x END around a division, keep it — guards prevent silent breakage. Strip benchmark comments (-- start query, -- end query) from output.

## Target: >=2.0x speedup

Your target is >=2.0x speedup on this query. This is the bar. Anything below 2.0x is a miss.

## PREVIOUS RETRY ATTEMPT — Learn from this

Your previous retry achieved **0.0x** against a target of **2.0x**.
**Error**: Benchmark failed: IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
**Strategy**: retry_1

Diagnose why this approach fell short and try a fundamentally different angle.

## Previous Optimization Attempts
Target: **>=2.0x** | 5 workers tried | none reached target

### W1: star_join_prefetch → 0.0x ★ BEST [ERROR]
- **Examples**: dimension_cte_isolate, multi_dimension_prefetch
- **Approach**: Use dimension_cte_isolate for store/household prefetch. Ignore date handling fro
- **Error**: IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
- **Optimized SQL:**
```sql
-- start query 88 in stream 0 using template query88.tpl
select  *
from
 (select count(*) h8_30_to_9
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk   
     and ss_hdemo_sk = household_demographics.hd_demo_sk 
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 8
     and time_dim.t_minute >= 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2)) 
     and store.s_store_name = 'ese') s1,
 (select count(*) h9_to_9_30 
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk 
     and time_dim.t_hour = 9 
     and time_dim.t_minute < 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s2,
 (select count(*) h9_30_to_10 
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 9
     and time_dim.t_minute >= 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s3,
 (select count(*) h10_to_10_30
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 10 
     and time_dim.t_minute < 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s4,
 (select count(*) h10_30_to_11
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 10 
     and time_dim.t_minute >= 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s5,
 (select count(*) h11_to_11_30
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk 
     and time_dim.t_hour = 11
     and time_dim.t_minute < 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s6,
 (select count(*) h11_30_to_12
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 11
     and time_dim.t_minute >= 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s7,
 (select count(*) h12_to_12_30
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 12
     and time_dim.t_minute < 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s8
;

-- end query 88 in stream 0 using template query88.tpl
```

### W2: single_pass_aggregation → 0.0x ★ BEST [ERROR]
- **Examples**: single_pass_aggregation, channel_bitmap_aggregation
- **Transforms**: decorrelate
- **Approach**: Use single_pass_aggregation's CASE grouping. Ignore bitmap techniques.
- **Error**: INTERFACE: [main_query] declares outputs ['h10_30_to_11', 'h10_to_10_30', 'h11_30_to_12', 'h11_to_11_30', 'h12_to_12_30', 'h8_30_to_9', 'h9_30_to_10', 'h9_to_9_30'] but SELECT only produces ['*'] | INTERFACE: [main_query] SELECT produces ['*'] not declared in outputs | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
- **Optimized SQL:**
```sql
WITH time_buckets AS (SELECT t_time_sk, CASE WHEN (t_hour = 8 AND t_minute >= 30) THEN 1 WHEN (t_hour = 9 AND t_minute < 30) THEN 2 WHEN (t_hour = 9 AND t_minute >= 30) THEN 3 WHEN (t_hour = 10 AND t_minute < 30) THEN 4 WHEN (t_hour = 10 AND t_minute >= 30) THEN 5 WHEN (t_hour = 11 AND t_minute < 30) THEN 6 WHEN (t_hour = 11 AND t_minute >= 30) THEN 7 WHEN (t_hour = 12 AND t_minute < 30) THEN 8 END AS interval_id FROM time_dim WHERE ((t_hour = 8 AND t_minute >= 30) OR (t_hour = 9 AND t_minute < 30) OR (t_hour = 9 AND t_minute >= 30) OR (t_hour = 10 AND t_minute < 30) OR (t_hour = 10 AND t_minute >= 30) OR (t_hour = 11 AND t_minute < 30) OR (t_hour = 11 AND t_minute >= 30) OR (t_hour = 12 AND t_minute < 30))), sales_agg AS (SELECT tb.interval_id, COUNT(*) AS cnt FROM store_sales ss JOIN time_buckets tb ON ss.ss_sold_time_sk = tb.t_time_sk JOIN store s ON ss.ss_store_sk = s.s_store_sk JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk WHERE s.s_store_name = 'ese' AND ((hd.hd_dep_count = -1 AND hd.hd_vehicle_count <= 1) OR (hd.hd_dep_count = 4 AND hd.hd_vehicle_count <= 6) OR (hd.hd_dep_count = 3 AND hd.hd_vehicle_count <= 5)) GROUP BY tb.interval_id), final AS (SELECT COALESCE(MAX(CASE WHEN interval_id = 1 THEN cnt END), 0) AS h8_30_to_9, COALESCE(MAX(CASE WHEN interval_id = 2 THEN cnt END), 0) AS h9_to_9_30, COALESCE(MAX(CASE WHEN interval_id = 3 THEN cnt END), 0) AS h9_30_to_10, COALESCE(MAX(CASE WHEN interval_id = 4 THEN cnt END), 0) AS h10_to_10_30, COALESCE(MAX(CASE WHEN interval_id = 5 THEN cnt END), 0) AS h10_30_to_11, COALESCE(MAX(CASE WHEN interval_id = 6 THEN cnt END), 0) AS h11_to_11_30, COALESCE(MAX(CASE WHEN interval_id = 7 THEN cnt END), 0) AS h11_30_to_12, COALESCE(MAX(CASE WHEN interval_id = 8 THEN cnt END), 0) AS h12_to_12_30 FROM sales_agg) SELECT * FROM final
```
- **Planner Diagnosis:**
```
[EXPLAIN failed — planner rejected this SQL]
Error: INTERFACE: [main_query] declares outputs ['h10_30_to_11', 'h10_to_10_30', 'h11_30_to_12', 'h11_to_11_30', 'h12_to_12_30', 'h8_30_to_9', 'h9_30_to_10', 'h9_to_9_30'] but SELECT only produces ['*'] | INTERFACE: [main_query] SELECT produces ['*'] not declared in outputs | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
```

### W3: predicate_propagation → 0.0x ★ BEST [ERROR]
- **Examples**: early_filter, transitive_predicate
- **Transforms**: pushdown
- **Approach**: Use early_filter's dimension join pushdown. Ignore date-specific logic.
- **Error**: INTERFACE: [main_query] declares outputs ['h10_30_to_11', 'h10_to_10_30', 'h11_30_to_12', 'h11_to_11_30', 'h12_to_12_30', 'h8_30_to_9', 'h9_30_to_10', 'h9_to_9_30'] but SELECT only produces ['*'] | INTERFACE: [main_query] SELECT produces ['*'] not declared in outputs | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
- **Optimized SQL:**
```sql
WITH filtered_sales AS (SELECT ss.ss_sold_time_sk
FROM store_sales ss
JOIN store s ON ss.ss_store_sk = s.s_store_sk
JOIN household_demographics hd ON ss.ss_hdemo_sk = hd.hd_demo_sk
WHERE s.s_store_name = 'ese'
  AND (
        (hd.hd_dep_count = -1 AND hd.hd_vehicle_count <= 1)
        OR (hd.hd_dep_count = 3 AND hd.hd_vehicle_count <= 5)
        OR (hd.hd_dep_count = 4 AND hd.hd_vehicle_count <= 6)
      )),
time_join AS (SELECT fs.ss_sold_time_sk, t.t_hour, t.t_minute
FROM filtered_sales fs
JOIN time_dim t ON fs.ss_sold_time_sk = t.t_time_sk),
interval_agg AS (SELECT
  COUNT_IF(t_hour=8 AND t_minute>=30) AS h8_30_to_9,
  COUNT_IF(t_hour=9 AND t_minute<30) AS h9_to_9_30,
  COUNT_IF(t_hour=9 AND t_minute>=30) AS h9_30_to_10,
  COUNT_IF(t_hour=10 AND t_minute<30) AS h10_to_10_30,
  COUNT_IF(t_hour=10 AND t_minute>=30) AS h10_30_to_11,
  COUNT_IF(t_hour=11 AND t_minute<30) AS h11_to_11_30,
  COUNT_IF(t_hour=11 AND t_minute>=30) AS h11_30_to_12,
  COUNT_IF(t_hour=12 AND t_minute<30) AS h12_to_12_30
FROM time_join)
SELECT * FROM interval_agg
```
- **Planner Diagnosis:**
```
[EXPLAIN failed — planner rejected this SQL]
Error: INTERFACE: [main_query] declares outputs ['h10_30_to_11', 'h10_to_10_30', 'h11_30_to_12', 'h11_to_11_30', 'h12_to_12_30', 'h8_30_to_9', 'h9_30_to_10', 'h9_to_9_30'] but SELECT only produces ['*'] | INTERFACE: [main_query] SELECT produces ['*'] not declared in outputs | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
```

### W4: late_household_binding → 0.0x ★ BEST [ERROR]
- **Examples**: deferred_window_aggregation, late_attribute_binding
- **Transforms**: decorrelate
- **Approach**: Use late_attribute_binding's deferred dimension join.
- **Error**: INTERFACE: [main_query] declares outputs ['h10_30_to_11', 'h10_to_10_30', 'h11_30_to_12', 'h11_to_11_30', 'h12_to_12_30', 'h8_30_to_9', 'h9_30_to_10', 'h9_to_9_30'] but SELECT only produces ['*'] | INTERFACE: [main_query] SELECT produces ['*'] not declared in outputs | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
- **Optimized SQL:**
```sql
WITH filtered_store AS (SELECT s_store_sk FROM store WHERE s_store_name = 'ese'), sales_time_agg AS (SELECT ss_hdemo_sk, COUNT_IF(t_hour=8 AND t_minute>=30) AS h8_30_to_9, COUNT_IF(t_hour=9 AND t_minute<30) AS h9_to_9_30, COUNT_IF(t_hour=9 AND t_minute>=30) AS h9_30_to_10, COUNT_IF(t_hour=10 AND t_minute<30) AS h10_to_10_30, COUNT_IF(t_hour=10 AND t_minute>=30) AS h10_30_to_11, COUNT_IF(t_hour=11 AND t_minute<30) AS h11_to_11_30, COUNT_IF(t_hour=11 AND t_minute>=30) AS h11_30_to_12, COUNT_IF(t_hour=12 AND t_minute<30) AS h12_to_12_30 FROM store_sales JOIN filtered_store ON ss_store_sk = s_store_sk JOIN time_dim ON ss_sold_time_sk = t_time_sk WHERE ((t_hour=8 AND t_minute>=30) OR (t_hour=9 AND t_minute<30) OR (t_hour=9 AND t_minute>=30) OR (t_hour=10 AND t_minute<30) OR (t_hour=10 AND t_minute>=30) OR (t_hour=11 AND t_minute<30) OR (t_hour=11 AND t_minute>=30) OR (t_hour=12 AND t_minute<30)) GROUP BY ss_hdemo_sk), household_join AS (SELECT SUM(h8_30_to_9) AS h8_30_to_9, SUM(h9_to_9_30) AS h9_to_9_30, SUM(h9_30_to_10) AS h9_30_to_10, SUM(h10_to_10_30) AS h10_to_10_30, SUM(h10_30_to_11) AS h10_30_to_11, SUM(h11_to_11_30) AS h11_to_11_30, SUM(h11_30_to_12) AS h11_30_to_12, SUM(h12_to_12_30) AS h12_to_12_30 FROM sales_time_agg JOIN household_demographics ON ss_hdemo_sk = hd_demo_sk WHERE ((hd_dep_count = -1 AND hd_vehicle_count <= -1+2) OR (hd_dep_count = 4 AND hd_vehicle_count <= 4+2) OR (hd_dep_count = 3 AND hd_vehicle_count <= 3+2))) SELECT * FROM household_join
```
- **Planner Diagnosis:**
```
[EXPLAIN failed — planner rejected this SQL]
Error: INTERFACE: [main_query] declares outputs ['h10_30_to_11', 'h10_to_10_30', 'h11_30_to_12', 'h11_to_11_30', 'h12_to_12_30', 'h8_30_to_9', 'h9_30_to_10', 'h9_to_9_30'] but SELECT only produces ['*'] | INTERFACE: [main_query] SELECT produces ['*'] not declared in outputs | IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
```

### W5: retry_1 → 0.0x ★ BEST [ERROR]
- **Transforms**: decorrelate
- **Error**: Benchmark failed: IO Error: Cannot open database "/mnt/c/Users/jakc9/Documents/QueryTorque_V8/snowflake://JKDL:YourNewPassword123!@CVRYJTF-AW47074/SNOWFLAKE_SAMPLE_DATA/TPCDS_SF10TCL?warehouse=COMPUTE_WH&role=ACCOUNTADMIN" in read-only mode: database does not exist
- **Optimized SQL:**
```sql
WITH filtered_store AS (
  SELECT s_store_sk 
  FROM store 
  WHERE s_store_name = 'ese'
), 
filtered_household AS (
  SELECT hd_demo_sk 
  FROM household_demographics 
  WHERE 
    (hd_dep_count = -1 AND hd_vehicle_count <= -1+2) OR
    (hd_dep_count = 4 AND hd_vehicle_count <= 4+2) OR
    (hd_dep_count = 3 AND hd_vehicle_count <= 3+2)
), 
time_buckets AS (
  SELECT t_time_sk, t_hour, t_minute 
  FROM time_dim 
  WHERE 
    (t_hour = 8 AND t_minute >= 30) OR
    (t_hour = 9 AND t_minute < 30) OR
    (t_hour = 9 AND t_minute >= 30) OR
    (t_hour = 10 AND t_minute < 30) OR
    (t_hour = 10 AND t_minute >= 30) OR
    (t_hour = 11 AND t_minute < 30) OR
    (t_hour = 11 AND t_minute >= 30) OR
    (t_hour = 12 AND t_minute < 30)
), 
sales_joined AS (
  SELECT t.t_hour, t.t_minute 
  FROM store_sales ss
  JOIN filtered_store s ON ss.ss_store_sk = s.s_store_sk
  JOIN filtered_household h ON ss.ss_hdemo_sk = h.hd_demo_sk
  JOIN time_buckets t ON ss.ss_sold_time_sk = t.t_time_sk
)
SELECT
  COUNT_IF(t_hour=8 AND t_minute>=30) AS h8_30_to_9,
  COUNT_IF(t_hour=9 AND t_minute<30) AS h9_to_9_30,
  COUNT_IF(t_hour=9 AND t_minute>=30) AS h9_30_to_10,
  COUNT_IF(t_hour=10 AND t_minute<30) AS h10_to_10_30,
  COUNT_IF(t_hour=10 AND t_minute>=30) AS h10_30_to_11,
  COUNT_IF(t_hour=11 AND t_minute<30) AS h11_to_11_30,
  COUNT_IF(t_hour=11 AND t_minute>=30) AS h11_30_to_12,
  COUNT_IF(t_hour=12 AND t_minute<30) AS h12_to_12_30
FROM sales_joined;
```


## Original Execution Plan (EXPLAIN ANALYZE)

Compare each candidate's plan (above) against this baseline.

```
GlobalStats | 72721 | 72721 | 1251925381632
1 | 0 | Result | COUNT(*), COUNT(*), COUNT(*), COUNT(*), COUNT(*), COUNT(*), COUNT(*), COUNT(*)
1 | 1 | [0] | Aggregate | aggExprs: [COUNT(IFF((TIME_DIM.T_HOUR = 12) AND (TIME_DIM.T_MINUTE < 30), TRUE, null)).condAggr(0), COUNT(IFF((TIME_DIM.T_HOUR = 11) AND (TIME_DIM.T_MINUTE >= 30), TRUE, null)).condAggr(1), COUNT(IFF((TIME_DIM.T_HOUR = 11) AND (TIME_DIM.T_MINUTE < 30), TRUE, null)).condAggr(2), COUNT(IFF((TIME_DIM.T_HOUR = 10) AND (TIME_DIM.T_MINUTE >= 30), TRUE, null)).condAggr(3), COUNT(IFF((TIME_DIM.T_HOUR = 10) AND (TIME_DIM.T_MINUTE < 30), TRUE, null)).condAggr(4), COUNT(IFF((TIME_DIM.T_HOUR = 9) AND (TIME_DIM.T_MINUTE >= 30), TRUE, null)).condAggr(5), COUNT(IFF((TIME_DIM.T_HOUR = 9) AND (TIME_DIM.T_MINUTE < 30), TRUE, null)).condAggr(6), COUNT(IFF((TIME_DIM.T_HOUR = 8) AND (TIME_DIM.T_MINUTE >= 30), TRUE, null)).condAggr(7)]
1 | 2 | [1] | Aggregate | aggExprs: [COUNT(COUNT(COUNT(COUNT(TRUE))))], groupKeys: [IFF((TIME_DIM.T_HOUR = 12) AND (TIME_DIM.T_MINUTE < 30), 0, IFF((TIME_DIM.T_HOUR = 11) AND (TIME_DIM.T_MINUTE >= 30), 1, IFF((TIME_DIM.T_HOUR = 11) AND (TIME_DIM.T_MINUTE < 30), 2, IFF((TIME_DIM.T_HOUR = 10) AND (TIME_DIM.T_MINUTE >= 30), 3, IFF((TIME_DIM.T_HOUR = 10) AND (TIME_DIM.T_MINUTE < 30), 4, IFF((TIME_DIM.T_HOUR = 9) AND (TIME_DIM.T_MINUTE >= 30), 5, IFF((TIME_DIM.T_HOUR = 9) AND (TIME_DIM.T_MINUTE < 30), 6, IFF((TIME_DIM.T_HOUR = 8) AND (TIME_DIM.T_MINUTE >= 30), 7, null))))))))]
1 | 3 | [2] | InnerJoin | joinKey: (TIME_DIM.T_TIME_SK = STORE_SALES.SS_SOLD_TIME_SK)
1 | 4 | [3] | Filter | ((TIME_DIM.T_HOUR = 12) AND (TIME_DIM.T_MINUTE < 30)) OR ((TIME_DIM.T_HOUR = 11) AND (TIME_DIM.T_MINUTE >= 30)) OR ((TIME_DIM.T_HOUR = 11) AND (TIME_DIM.T_MINUTE < 30)) OR ((TIME_DIM.T_HOUR = 10) AND (TIME_DIM.T_MINUTE >= 30)) OR ((TIME_DIM.T_HOUR = 10) AND (TIME_DIM.T_MINUTE < 30)) OR ((TIME_DIM.T_HOUR = 9) AND (TIME_DIM.T_MINUTE >= 30)) OR ((TIME_DIM.T_HOUR = 9) AND (TIME_DIM.T_MINUTE < 30)) OR ((TIME_DIM.T_HOUR = 8) AND (TIME_DIM.T_MINUTE >= 30))
1 | 5 | [4] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.TIME_DIM | T_TIME_SK, T_HOUR, T_MINUTE | 1 | 1 | 1124352
1 | 6 | [3] | Aggregate | aggExprs: [COUNT(COUNT(COUNT(TRUE)))], groupKeys: [STORE_SALES.SS_SOLD_TIME_SK]
1 | 7 | [6] | InnerJoin | joinKey: (HOUSEHOLD_DEMOGRAPHICS.HD_DEMO_SK = STORE_SALES.SS_HDEMO_SK)
1 | 8 | [7] | Filter | HOUSEHOLD_DEMOGRAPHICS.HD_DEP_COUNT IN 4 IN 3
1 | 9 | [8] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.HOUSEHOLD_DEMOGRAPHICS | HD_DEMO_SK, HD_DEP_COUNT | 1 | 1 | 30720
1 | 10 | [7] | Aggregate | aggExprs: [COUNT(COUNT(TRUE))], groupKeys: [STORE_SALES.SS_SOLD_TIME_SK, STORE_SALES.SS_HDEMO_SK]
1 | 11 | [10] | InnerJoin | joinKey: (STORE.S_STORE_SK = STORE_SALES.SS_STORE_SK)
1 | 12 | [11] | Filter | STORE.S_STORE_NAME = 'ese'
1 | 13 | [12] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.STORE | S_STORE_SK, S_STORE_NAME | 1 | 1 | 135680
1 | 14 | [11] | Aggregate | aggExprs: [COUNT(TRUE)], groupKeys: [STORE_SALES.SS_SOLD_TIME_SK, STORE_SALES.SS_HDEMO_SK, STORE_SALES.SS_STORE_SK]
1 | 15 | [14] | Filter | (STORE_SALES.SS_HDEMO_SK IS NOT NULL) AND (STORE_SALES.SS_STORE_SK IS NOT NULL) AND (STORE_SALES.SS_SOLD_TIME_SK IS NOT NULL)
1 | 16 | [15] | JoinFilter | joinKey: (TIME_DIM.T_TIME_SK = STORE_SALES.SS_SOLD_TIME_SK)
1 | 17 | [16] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.STORE_SALES | SS_SOLD_TIME_SK, SS_HDEMO_SK, SS_STORE_SK | 72718 | 72718 | 1251924090880
```

## Semantic Contract (MUST preserve)

This query counts store sales transactions within specific 30-minute intervals for store 'ese' that meet household demographic conditions (dep_count = -1, 3, or 4 with corresponding vehicle_count thresholds). All joins are INNER = transactions must match all dimension tables. Output preserves 8 distinct count columns with original names/literals. Aggregation uses simple COUNTs (safe for restructuring).

## Bottleneck Diagnosis

Scan-bound on store_sales (1.25TB scanned) dominates cost. Optimizer merged 8 subqueries into 1 scan with conditional aggregation (good), but:  
1) Household_demographics filters applied AFTER store_sales scan/aggregation  
2) Time_dim filters use disjunctive ORs (8 intervals)  
3) Store filter applied late  
Row flow: 125B rows → 72K rows after bloom filter → 72K rows after aggregation → 1 row. Optimizer handles bloom filtering and conditional aggregation well.

## Engine Profile

*Discovery mode — 10 strengths from docs/research, 9 hypothesized gaps in playbook. Collecting empirical evidence.*

### Optimizer Strengths (DO NOT fight these)
- **MICRO_PARTITION_PRUNING**: Filters on clustered columns skip micro-partitions at scan level
- **COLUMN_PRUNING**: Reads only columns referenced by final query, even through CTEs
- **PREDICATE_PUSHDOWN**: Filters pushed to storage layer including through single-ref CTEs
- **CORRELATED_DECORRELATION**: Correlated subqueries automatically decorrelated to hash joins
- **SEMI_JOIN**: EXISTS → SemiJoin with early termination
- **JOIN_FILTER**: Bloom filter pushdown from build side to probe-side TableScan
- **COST_BASED_JOIN_ORDER**: Evaluates multiple join orders, selects lowest cost
- **METADATA_SCAN_ELIMINATION**: MIN/MAX/COUNT served from micro-partition metadata without scan
- **QUALIFY_OPTIMIZATION**: Native window-function filtering, more efficient than nested subquery
- **DISTRIBUTED_AGGREGATION**: Multi-level partial aggregation for parallel warehouse execution

## Correctness Invariants (HARD STOPS — non-negotiable)

These 4 constraints are absolute. Even with full creative freedom, you may NEVER violate these:

- **COMPLETE_OUTPUT**: The rewritten query must output ALL columns from the original SELECT. Never drop, rename, or reorder output columns. Every column alias must be preserved exactly as in the original.
- **CTE_COLUMN_COMPLETENESS**: CRITICAL: When creating or modifying a CTE, its SELECT list MUST include ALL columns referenced by downstream queries. Check the Node Contracts section: every column in downstream_refs MUST appear in the CTE output. Also ensure: (1) JOIN columns used by consumers are included in SELECT, (2) every table referenced in WHERE is present in FROM/JOIN, (3) no ambiguous column names between the CTE and re-joined tables. Dropping a column that a downstream node needs will cause an execution error.
- **LITERAL_PRESERVATION**: CRITICAL: When rewriting SQL, you MUST copy ALL literal values (strings, numbers, dates) EXACTLY from the original query. Do NOT invent, substitute, or 'improve' any filter values. If the original says d_year = 2000, your rewrite MUST say d_year = 2000. If the original says ca_state = 'GA', your rewrite MUST say ca_state = 'GA'. Changing these values will produce WRONG RESULTS and the rewrite will be REJECTED.
- **SEMANTIC_EQUIVALENCE**: The rewritten query MUST return exactly the same rows, columns, and ordering as the original. This is the prime directive. Any rewrite that changes the result set — even by one row, one column, or a different sort order — is WRONG and will be REJECTED.

## Aggregation Semantics Check (HARD STOP)

- STDDEV_SAMP/VARIANCE are grouping-sensitive — changing group membership changes the result.
- AVG and STDDEV are NOT duplicate-safe.
- FILTER over a combined group != separate per-group computation.
- Verify aggregation equivalence for ANY proposed restructuring.

## Original SQL

```sql
select  *
from
 (select count(*) h8_30_to_9
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk   
     and ss_hdemo_sk = household_demographics.hd_demo_sk 
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 8
     and time_dim.t_minute >= 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2)) 
     and store.s_store_name = 'ese') s1,
 (select count(*) h9_to_9_30 
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk 
     and time_dim.t_hour = 9 
     and time_dim.t_minute < 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s2,
 (select count(*) h9_30_to_10 
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 9
     and time_dim.t_minute >= 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s3,
 (select count(*) h10_to_10_30
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 10 
     and time_dim.t_minute < 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s4,
 (select count(*) h10_30_to_11
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 10 
     and time_dim.t_minute >= 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s5,
 (select count(*) h11_to_11_30
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk 
     and time_dim.t_hour = 11
     and time_dim.t_minute < 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s6,
 (select count(*) h11_30_to_12
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 11
     and time_dim.t_minute >= 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s7,
 (select count(*) h12_to_12_30
 from store_sales, household_demographics , time_dim, store
 where ss_sold_time_sk = time_dim.t_time_sk
     and ss_hdemo_sk = household_demographics.hd_demo_sk
     and ss_store_sk = s_store_sk
     and time_dim.t_hour = 12
     and time_dim.t_minute < 30
     and ((household_demographics.hd_dep_count = -1 and household_demographics.hd_vehicle_count<=-1+2) or
          (household_demographics.hd_dep_count = 4 and household_demographics.hd_vehicle_count<=4+2) or
          (household_demographics.hd_dep_count = 3 and household_demographics.hd_vehicle_count<=3+2))
     and store.s_store_name = 'ese') s8
;
```

## Your Task — Self-Directed Retry

Work through these 3 steps in a `<reasoning>` block, then output your optimized SQL:

1. **DIAGNOSE**: Why did the best worker achieve 0.0x instead of the 2.0x target? What do the EXPLAIN plans reveal about the actual execution bottleneck?
2. **IDENTIFY**: What optimization angles are still unexplored? What did the empirical results reveal that couldn't have been known before seeing the execution plans?
3. **REWRITE**: Produce optimized SQL that exploits the angles you identified. You may build on the best foundation or start fresh.

## Rewrite Checklist (must pass before final SQL)

- Verify output schema matches the Column Completeness Contract (same columns, same names, same order).
- Keep all semantic invariants from `Correctness Invariants` (including join/null behavior).
- Verify aggregation equivalence: same rows participate in each group, same aggregate semantics.
- Preserve all literals exactly (numbers, strings, date values).
- Apply `Hazard Flags` as hard guards against known failure modes.

### Column Completeness Contract

Your `main_query` component MUST produce **exactly** these output columns (same names, same order):

  1. `*`

Do NOT add, remove, or rename any output columns. The result set schema must be identical to the original query.

## Output Format

Your response has **two parts** in order:

### Part 1: Modified Logic Tree

Show what changed using change markers. Generate the tree BEFORE writing SQL.

Change markers:
- `[+]` — New component added
- `[-]` — Component removed
- `[~]` — Component modified (describe what changed)
- `[=]` — Unchanged (no children needed)
- `[!]` — Structural change (e.g. CTE → subquery)

### Part 2: Component Payload JSON

```json
{
  "spec_version": "1.0",
  "dialect": "<dialect>",
  "rewrite_rules": [
    {"id": "R1", "type": "<transform_name>", "description": "<what changed>", "applied_to": ["<component_id>"]}
  ],
  "statements": [{
    "target_table": null,
    "change": "modified",
    "components": {
      "<cte_name>": {
        "type": "cte",
        "change": "modified",
        "sql": "<complete SQL for this CTE body>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<upstream_id>"]}
      },
      "main_query": {
        "type": "main_query",
        "change": "modified",
        "sql": "<final SELECT>",
        "interfaces": {"outputs": ["col1", "col2"], "consumes": ["<cte_name>"]}
      }
    },
    "reconstruction_order": ["<cte_name>", "main_query"],
    "assembly_template": "WITH <cte_name> AS ({<cte_name>}) {main_query}"
  }],
  "macros": {},
  "frozen_blocks": [],
  "validation_checks": []
}
```

### Rules
- **Tree first, always.** Generate the Logic Tree before writing any SQL
- **One component at a time.** When writing SQL for component X, treat others as opaque interfaces
- **No ellipsis.** Every `sql` value must be complete, executable SQL
- **Frozen blocks are copy-paste.** Large CASE-WHEN lookups must be verbatim
- **Validate interfaces.** Verify every `consumes` reference exists in upstream `outputs`
- Only include components you **changed or added** — set unchanged components to `"change": "unchanged"` with `"sql": ""`
- `main_query` output columns must match the Column Completeness Contract above
- `reconstruction_order`: topological order of components for assembly

After the JSON, explain the mechanism:

```
Changes: <1-2 sentences: what structural change + the expected mechanism>
Expected speedup: <estimate>
```

Now output your Logic Tree and Component Payload JSON: