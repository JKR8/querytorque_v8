You are a senior query optimization architect. Your job is to deeply analyze a SQL query and produce a structured briefing for 4 specialist workers who will each write a different optimized version.

You are the ONLY call that sees all the data: EXPLAIN plans, logical-tree costs, full constraint list, global knowledge, and the complete example catalog. The workers will only see what YOU put in their briefings. Your output quality directly determines their success.

## Query: query_64
## Dialect: snowflake

```sql
  1 | with cs_ui as
  2 |  (select cs_item_sk
  3 |         ,sum(cs_ext_list_price) as sale,sum(cr_refunded_cash+cr_reversed_charge+cr_store_credit) as refund
  4 |   from catalog_sales
  5 |       ,catalog_returns
  6 |   where cs_item_sk = cr_item_sk
  7 |     and cs_order_number = cr_order_number
  8 |   group by cs_item_sk
  9 |   having sum(cs_ext_list_price)>2*sum(cr_refunded_cash+cr_reversed_charge+cr_store_credit)),
 10 | cross_sales as
 11 |  (select i_product_name product_name
 12 |      ,i_item_sk item_sk
 13 |      ,s_store_name store_name
 14 |      ,s_zip store_zip
 15 |      ,ad1.ca_street_number b_street_number
 16 |      ,ad1.ca_street_name b_street_name
 17 |      ,ad1.ca_city b_city
 18 |      ,ad1.ca_zip b_zip
 19 |      ,ad2.ca_street_number c_street_number
 20 |      ,ad2.ca_street_name c_street_name
 21 |      ,ad2.ca_city c_city
 22 |      ,ad2.ca_zip c_zip
 23 |      ,d1.d_year as syear
 24 |      ,d2.d_year as fsyear
 25 |      ,d3.d_year s2year
 26 |      ,count(*) cnt
 27 |      ,sum(ss_wholesale_cost) s1
 28 |      ,sum(ss_list_price) s2
 29 |      ,sum(ss_coupon_amt) s3
 30 |   FROM   store_sales
 31 |         ,store_returns
 32 |         ,cs_ui
 33 |         ,date_dim d1
 34 |         ,date_dim d2
 35 |         ,date_dim d3
 36 |         ,store
 37 |         ,customer
 38 |         ,customer_demographics cd1
 39 |         ,customer_demographics cd2
 40 |         ,promotion
 41 |         ,household_demographics hd1
 42 |         ,household_demographics hd2
 43 |         ,customer_address ad1
 44 |         ,customer_address ad2
 45 |         ,income_band ib1
 46 |         ,income_band ib2
 47 |         ,item
 48 |   WHERE  ss_store_sk = s_store_sk AND
 49 |          ss_sold_date_sk = d1.d_date_sk AND
 50 |          ss_customer_sk = c_customer_sk AND
 51 |          ss_cdemo_sk= cd1.cd_demo_sk AND
 52 |          ss_hdemo_sk = hd1.hd_demo_sk AND
 53 |          ss_addr_sk = ad1.ca_address_sk and
 54 |          ss_item_sk = i_item_sk and
 55 |          ss_item_sk = sr_item_sk and
 56 |          ss_ticket_number = sr_ticket_number and
 57 |          ss_item_sk = cs_ui.cs_item_sk and
 58 |          c_current_cdemo_sk = cd2.cd_demo_sk AND
 59 |          c_current_hdemo_sk = hd2.hd_demo_sk AND
 60 |          c_current_addr_sk = ad2.ca_address_sk and
 61 |          c_first_sales_date_sk = d2.d_date_sk and
 62 |          c_first_shipto_date_sk = d3.d_date_sk and
 63 |          ss_promo_sk = p_promo_sk and
 64 |          hd1.hd_income_band_sk = ib1.ib_income_band_sk and
 65 |          hd2.hd_income_band_sk = ib2.ib_income_band_sk and
 66 |          cd1.cd_marital_status <> cd2.cd_marital_status and
 67 |          i_color in ('blanched','medium','brown','chocolate','burlywood','drab') and
 68 |          i_current_price between 23 and 23 + 10 and
 69 |          i_current_price between 23 + 1 and 23 + 15
 70 | group by i_product_name
 71 |        ,i_item_sk
 72 |        ,s_store_name
 73 |        ,s_zip
 74 |        ,ad1.ca_street_number
 75 |        ,ad1.ca_street_name
 76 |        ,ad1.ca_city
 77 |        ,ad1.ca_zip
 78 |        ,ad2.ca_street_number
 79 |        ,ad2.ca_street_name
 80 |        ,ad2.ca_city
 81 |        ,ad2.ca_zip
 82 |        ,d1.d_year
 83 |        ,d2.d_year
 84 |        ,d3.d_year
 85 | )
 86 | select cs1.product_name
 87 |      ,cs1.store_name
 88 |      ,cs1.store_zip
 89 |      ,cs1.b_street_number
 90 |      ,cs1.b_street_name
 91 |      ,cs1.b_city
 92 |      ,cs1.b_zip
 93 |      ,cs1.c_street_number
 94 |      ,cs1.c_street_name
 95 |      ,cs1.c_city
 96 |      ,cs1.c_zip
 97 |      ,cs1.syear
 98 |      ,cs1.cnt
 99 |      ,cs1.s1 as s11
100 |      ,cs1.s2 as s21
101 |      ,cs1.s3 as s31
102 |      ,cs2.s1 as s12
103 |      ,cs2.s2 as s22
104 |      ,cs2.s3 as s32
105 |      ,cs2.syear
106 |      ,cs2.cnt
107 | from cross_sales cs1,cross_sales cs2
108 | where cs1.item_sk=cs2.item_sk and
109 |      cs1.syear = 2001 and
110 |      cs2.syear = 2001 + 1 and
111 |      cs2.cnt <= cs1.cnt and
112 |      cs1.store_name = cs2.store_name and
113 |      cs1.store_zip = cs2.store_zip
114 | order by cs1.product_name
115 |        ,cs1.store_name
116 |        ,cs2.cnt
117 |        ,cs1.s1
118 |        ,cs2.s1;
```

## EXPLAIN ANALYZE Plan

```
GlobalStats | 140255 | 137949 | 2347468830720
1 | 0 | Result | CS1.PRODUCT_NAME, CS1.STORE_NAME, CS1.STORE_ZIP, CS1.B_STREET_NUMBER, CS1.B_STREET_NAME, CS1.B_CITY, CS1.B_ZIP, CS1.C_STREET_NUMBER, CS1.C_STREET_NAME, CS1.C_CITY, CS1.C_ZIP, CS1.SYEAR, CS1.CNT, CS1.S1, CS1.S2, CS1.S3, CS2.S1, CS2.S2, CS2.S3, CS2.SYEAR, CS2.CNT
1 | 1 | [0] | Sort | CS1.PRODUCT_NAME ASC NULLS LAST, CS1.STORE_NAME ASC NULLS LAST, CS2.CNT ASC NULLS LAST, CS1.S1 ASC NULLS LAST, CS2.S1 ASC NULLS LAST
1 | 2 | [1] | InnerJoin | joinKey: (CS2.ITEM_SK = CS1.ITEM_SK) AND (CS2.STORE_NAME = CS1.STORE_NAME) AND (CS2.STORE_ZIP = CS1.STORE_ZIP), joinFilter: CS2.CNT <= CS1.CNT
1 | 3 | [2] | WithReference | CS2
1 | 4 | [3] | Filter | (D1.D_YEAR = 2002) AND (CS2.STORE_NAME IS NOT NULL) AND (CS2.STORE_ZIP IS NOT NULL)
1 | 5 | [4, 88] | WithClause | CROSS_SALES
1 | 6 | [5] | Aggregate | aggExprs: [COUNT(*), SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), COUNT(*)), COUNT(*))), SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), COUNT(*)), COUNT(*))), SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), COUNT(*)), COUNT(*)))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, AD2.CA_STREET_NUMBER, AD2.CA_STREET_NAME, AD2.CA_CITY, AD2.CA_ZIP, D1.D_YEAR, D2.D_YEAR, D3.D_YEAR]
1 | 7 | [6] | Aggregate | aggExprs: [COUNT_INTERNAL(*)(COUNT_INTERNAL(*)(COUNT(*), COUNT(*)), COUNT(*)), SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), COUNT(*)), COUNT(*)), SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), COUNT(*)), COUNT(*)), SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), COUNT(*)), COUNT(*))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, AD2.CA_STREET_NUMBER, AD2.CA_STREET_NAME, AD2.CA_CITY, AD2.CA_ZIP, D1.D_YEAR, D2.D_YEAR, D3.D_YEAR]
1 | 8 | [7] | InnerJoin | joinKey: (STORE_SALES.SS_ITEM_SK = STORE_RETURNS.SR_ITEM_SK) AND (STORE_SALES.SS_TICKET_NUMBER = STORE_RETURNS.SR_TICKET_NUMBER)
1 | 9 | [8] | Aggregate | aggExprs: [COUNT_INTERNAL(*)(COUNT(*), COUNT(*)), SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), COUNT(*)), SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), COUNT(*)), SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), COUNT(*))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, AD2.CA_STREET_NUMBER, AD2.CA_STREET_NAME, AD2.CA_CITY, AD2.CA_ZIP, D1.D_YEAR, D2.D_YEAR, D3.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER]
1 | 10 | [9] | InnerJoin | joinKey: (CUSTOMER.C_CURRENT_ADDR_SK = AD2.CA_ADDRESS_SK)
1 | 11 | [10] | Aggregate | aggExprs: [COUNT(*), SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))), SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*)))))))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, D1.D_YEAR, D2.D_YEAR, D3.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CUSTOMER.C_CURRENT_ADDR_SK]
1 | 12 | [11] | InnerJoin | joinKey: (CD2.CD_DEMO_SK = CUSTOMER.C_CURRENT_CDEMO_SK), joinFilter: CD1.CD_MARITAL_STATUS <> CD2.CD_MARITAL_STATUS
1 | 13 | [12] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CUSTOMER_DEMOGRAPHICS | CD2 | CD_DEMO_SK, CD_MARITAL_STATUS | 1 | 1 | 7446528
1 | 14 | [12] | Aggregate | aggExprs: [COUNT(*), SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*)))))), SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*)))))), SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, D1.D_YEAR, D2.D_YEAR, D3.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CUSTOMER.C_CURRENT_ADDR_SK, CUSTOMER.C_CURRENT_CDEMO_SK, CD1.CD_MARITAL_STATUS]
1 | 15 | [14] | InnerJoin | joinKey: (D3.D_DATE_SK = CUSTOMER.C_FIRST_SHIPTO_DATE_SK)
1 | 16 | [15] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.DATE_DIM | D3 | D_DATE_SK, D_YEAR | 1 | 1 | 2138624
1 | 17 | [15] | Aggregate | aggExprs: [COUNT(*), SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))), SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))), SUM(SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*)))))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, D1.D_YEAR, D2.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CUSTOMER.C_CURRENT_ADDR_SK, CUSTOMER.C_CURRENT_CDEMO_SK, CD1.CD_MARITAL_STATUS, CUSTOMER.C_FIRST_SHIPTO_DATE_SK]
1 | 18 | [17] | InnerJoin | joinKey: (D2.D_DATE_SK = CUSTOMER.C_FIRST_SALES_DATE_SK)
1 | 19 | [18] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.DATE_DIM | D2 | D_DATE_SK, D_YEAR | 1 | 1 | 2138624
1 | 20 | [18] | Aggregate | aggExprs: [COUNT(*), SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*)))), SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*)))), SUM(SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, D1.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CUSTOMER.C_CURRENT_ADDR_SK, CUSTOMER.C_CURRENT_CDEMO_SK, CD1.CD_MARITAL_STATUS, CUSTOMER.C_FIRST_SHIPTO_DATE_SK, CUSTOMER.C_FIRST_SALES_DATE_SK]
1 | 21 | [20] | InnerJoin | joinKey: (IB2.IB_INCOME_BAND_SK = HD2.HD_INCOME_BAND_SK)
1 | 22 | [21] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.INCOME_BAND | IB2 | IB_INCOME_BAND_SK | 1 | 1 | 1536
1 | 23 | [21] | Aggregate | aggExprs: [COUNT(*), SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))), SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))), SUM(SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*)))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, D1.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CUSTOMER.C_CURRENT_ADDR_SK, CUSTOMER.C_CURRENT_CDEMO_SK, CD1.CD_MARITAL_STATUS, CUSTOMER.C_FIRST_SHIPTO_DATE_SK, CUSTOMER.C_FIRST_SALES_DATE_SK, HD2.HD_INCOME_BAND_SK]
1 | 24 | [23] | InnerJoin | joinKey: (HD2.HD_DEMO_SK = CUSTOMER.C_CURRENT_HDEMO_SK)
1 | 25 | [24] | JoinFilter | joinKey: (IB2.IB_INCOME_BAND_SK = HD2.HD_INCOME_BAND_SK)
1 | 26 | [25] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.HOUSEHOLD_DEMOGRAPHICS | HD2 | HD_DEMO_SK, HD_INCOME_BAND_SK | 1 | 1 | 30720
1 | 27 | [24] | Aggregate | aggExprs: [COUNT_INTERNAL(*)(COUNT_INTERNAL(*)(COUNT(*), COUNT(*)), COUNT(*)), SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*)), SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*)), SUM_INTERNAL(SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), COUNT(*))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, D1.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CUSTOMER.C_CURRENT_ADDR_SK, CUSTOMER.C_CURRENT_CDEMO_SK, CD1.CD_MARITAL_STATUS, CUSTOMER.C_FIRST_SHIPTO_DATE_SK, CUSTOMER.C_FIRST_SALES_DATE_SK, CUSTOMER.C_CURRENT_HDEMO_SK]
1 | 28 | [27] | InnerJoin | joinKey: (STORE_SALES.SS_CUSTOMER_SK = CUSTOMER.C_CUSTOMER_SK)
1 | 29 | [28] | Aggregate | aggExprs: [COUNT_INTERNAL(*)(COUNT(*), COUNT(*)), SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*)), SUM_INTERNAL(SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), COUNT(*))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, D1.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CD1.CD_MARITAL_STATUS, STORE_SALES.SS_CUSTOMER_SK]
1 | 30 | [29] | InnerJoin | joinKey: (STORE_SALES.SS_ADDR_SK = AD1.CA_ADDRESS_SK)
1 | 31 | [30] | Aggregate | aggExprs: [COUNT(*), SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))), SUM(SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*)))))))))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, D1.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CD1.CD_MARITAL_STATUS, STORE_SALES.SS_CUSTOMER_SK, STORE_SALES.SS_ADDR_SK]
1 | 32 | [31] | InnerJoin | joinKey: (PROMOTION.P_PROMO_SK = STORE_SALES.SS_PROMO_SK)
1 | 33 | [32] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.PROMOTION | P_PROMO_SK | 1 | 1 | 85504
1 | 34 | [32] | Aggregate | aggExprs: [COUNT(*), SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*)))))))), SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*)))))))), SUM(SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE.S_STORE_NAME, STORE.S_ZIP, D1.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CD1.CD_MARITAL_STATUS, STORE_SALES.SS_CUSTOMER_SK, STORE_SALES.SS_ADDR_SK, STORE_SALES.SS_PROMO_SK]
1 | 35 | [34] | InnerJoin | joinKey: (STORE.S_STORE_SK = STORE_SALES.SS_STORE_SK)
1 | 36 | [35] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.STORE | S_STORE_SK, S_STORE_NAME, S_ZIP | 1 | 1 | 135680
1 | 37 | [35] | Aggregate | aggExprs: [COUNT(*), SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))), SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))), SUM(SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*)))))))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, D1.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CD1.CD_MARITAL_STATUS, STORE_SALES.SS_CUSTOMER_SK, STORE_SALES.SS_ADDR_SK, STORE_SALES.SS_PROMO_SK, STORE_SALES.SS_STORE_SK]
1 | 38 | [37] | InnerJoin | joinKey: (IB1.IB_INCOME_BAND_SK = HD1.HD_INCOME_BAND_SK)
1 | 39 | [38] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.INCOME_BAND | IB1 | IB_INCOME_BAND_SK | 1 | 1 | 1536
1 | 40 | [38] | Aggregate | aggExprs: [COUNT(*), SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*)))))), SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*)))))), SUM(SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, D1.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CD1.CD_MARITAL_STATUS, STORE_SALES.SS_CUSTOMER_SK, STORE_SALES.SS_ADDR_SK, STORE_SALES.SS_PROMO_SK, STORE_SALES.SS_STORE_SK, HD1.HD_INCOME_BAND_SK]
1 | 41 | [40] | InnerJoin | joinKey: (HD1.HD_DEMO_SK = STORE_SALES.SS_HDEMO_SK)
1 | 42 | [41] | JoinFilter | joinKey: (IB1.IB_INCOME_BAND_SK = HD1.HD_INCOME_BAND_SK)
1 | 43 | [42] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.HOUSEHOLD_DEMOGRAPHICS | HD1 | HD_DEMO_SK, HD_INCOME_BAND_SK | 1 | 1 | 30720
1 | 44 | [41] | Aggregate | aggExprs: [COUNT(*), SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))), SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))), SUM(SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*)))))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, D1.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, CD1.CD_MARITAL_STATUS, STORE_SALES.SS_CUSTOMER_SK, STORE_SALES.SS_ADDR_SK, STORE_SALES.SS_PROMO_SK, STORE_SALES.SS_STORE_SK, STORE_SALES.SS_HDEMO_SK]
1 | 45 | [44] | InnerJoin | joinKey: (CD1.CD_DEMO_SK = STORE_SALES.SS_CDEMO_SK)
1 | 46 | [45] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CUSTOMER_DEMOGRAPHICS | CD1 | CD_DEMO_SK, CD_MARITAL_STATUS | 1 | 1 | 7446528
1 | 47 | [45] | Aggregate | aggExprs: [COUNT(*), SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*)))), SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*)))), SUM(SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, D1.D_YEAR, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, STORE_SALES.SS_CUSTOMER_SK, STORE_SALES.SS_ADDR_SK, STORE_SALES.SS_PROMO_SK, STORE_SALES.SS_STORE_SK, STORE_SALES.SS_HDEMO_SK, STORE_SALES.SS_CDEMO_SK]
1 | 48 | [47] | InnerJoin | joinKey: (D1.D_DATE_SK = STORE_SALES.SS_SOLD_DATE_SK)
1 | 49 | [48] | Filter | D1.D_YEAR IN 2001 IN 2002
1 | 50 | [49] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.DATE_DIM | D1 | D_DATE_SK, D_YEAR | 1 | 1 | 2138624
1 | 51 | [48] | Aggregate | aggExprs: [COUNT_INTERNAL(*)(COUNT_INTERNAL(*)(COUNT(*), COUNT(*)), COUNT(*)), SUM_INTERNAL(SUM(STORE_SALES.SS_WHOLESALE_COST), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))), SUM_INTERNAL(SUM(STORE_SALES.SS_LIST_PRICE), COUNT_INTERNAL(*)(COUNT(*), COUNT(*))), SUM_INTERNAL(SUM(STORE_SALES.SS_COUPON_AMT), COUNT_INTERNAL(*)(COUNT(*), COUNT(*)))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, STORE_SALES.SS_CUSTOMER_SK, STORE_SALES.SS_ADDR_SK, STORE_SALES.SS_PROMO_SK, STORE_SALES.SS_STORE_SK, STORE_SALES.SS_HDEMO_SK, STORE_SALES.SS_CDEMO_SK, STORE_SALES.SS_SOLD_DATE_SK]
1 | 52 | [51] | InnerJoin | joinKey: (CATALOG_SALES.CS_ITEM_SK = STORE_SALES.SS_ITEM_SK)
1 | 53 | [52] | Aggregate | aggExprs: [COUNT_INTERNAL(*)(COUNT(*), COUNT(*))], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK, CATALOG_SALES.CS_ITEM_SK]
1 | 54 | [53] | InnerJoin | joinKey: (ITEM.I_ITEM_SK = CATALOG_SALES.CS_ITEM_SK)
1 | 55 | [54] | Aggregate | aggExprs: [COUNT(*)], groupKeys: [ITEM.I_PRODUCT_NAME, ITEM.I_ITEM_SK]
1 | 56 | [55] | Filter | (ITEM.I_COLOR IN 'blanched' IN 'medium' IN 'brown' IN 'chocolate' IN 'burlywood' IN 'drab') AND (ITEM.I_CURRENT_PRICE >= 23) AND (ITEM.I_CURRENT_PRICE <= 33) AND (ITEM.I_CURRENT_PRICE >= 24) AND (ITEM.I_CURRENT_PRICE <= 38)
1 | 57 | [56] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.ITEM | I_ITEM_SK, I_CURRENT_PRICE, I_COLOR, I_PRODUCT_NAME | 2 | 2 | 23811584
1 | 58 | [54] | Aggregate | aggExprs: [COUNT(*)], groupKeys: [CATALOG_SALES.CS_ITEM_SK]
1 | 59 | [58] | Filter | (SUM(SUM_INTERNAL(SUM(CATALOG_SALES.CS_EXT_LIST_PRICE), COUNT(*)))) > (2 * (SUM(SUM_INTERNAL(SUM((CATALOG_RETURNS.CR_REFUNDED_CASH + CATALOG_RETURNS.CR_REVERSED_CHARGE) + CATALOG_RETURNS.CR_STORE_CREDIT), COUNT(*)))))
1 | 60 | [59] | Aggregate | aggExprs: [SUM(SUM_INTERNAL(SUM(CATALOG_SALES.CS_EXT_LIST_PRICE), COUNT(*))), SUM(SUM_INTERNAL(SUM((CATALOG_RETURNS.CR_REFUNDED_CASH + CATALOG_RETURNS.CR_REVERSED_CHARGE) + CATALOG_RETURNS.CR_STORE_CREDIT), COUNT(*)))], groupKeys: [CATALOG_SALES.CS_ITEM_SK]
1 | 61 | [60] | Aggregate | aggExprs: [SUM_INTERNAL(SUM(CATALOG_SALES.CS_EXT_LIST_PRICE), COUNT(*)), SUM_INTERNAL(SUM((CATALOG_RETURNS.CR_REFUNDED_CASH + CATALOG_RETURNS.CR_REVERSED_CHARGE) + CATALOG_RETURNS.CR_STORE_CREDIT), COUNT(*))], groupKeys: [CATALOG_SALES.CS_ITEM_SK]
1 | 62 | [61] | InnerJoin | joinKey: (CATALOG_RETURNS.CR_ITEM_SK = CATALOG_SALES.CS_ITEM_SK) AND (CATALOG_RETURNS.CR_ORDER_NUMBER = CATALOG_SALES.CS_ORDER_NUMBER)
1 | 63 | [62] | Aggregate | aggExprs: [SUM((CATALOG_RETURNS.CR_REFUNDED_CASH + CATALOG_RETURNS.CR_REVERSED_CHARGE) + CATALOG_RETURNS.CR_STORE_CREDIT), COUNT(*)], groupKeys: [CATALOG_RETURNS.CR_ITEM_SK, CATALOG_RETURNS.CR_ORDER_NUMBER]
1 | 64 | [63] | JoinFilter | joinKey: (ITEM.I_ITEM_SK = CATALOG_SALES.CS_ITEM_SK)
1 | 65 | [64] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CATALOG_RETURNS | CR_ITEM_SK, CR_ORDER_NUMBER, CR_REFUNDED_CASH, CR_REVERSED_CHARGE, CR_STORE_CREDIT | 4759 | 4759 | 82532796416
1 | 66 | [62] | Aggregate | aggExprs: [SUM(CATALOG_SALES.CS_EXT_LIST_PRICE), COUNT(*)], groupKeys: [CATALOG_SALES.CS_ITEM_SK, CATALOG_SALES.CS_ORDER_NUMBER]
1 | 67 | [66] | JoinFilter | joinKey: (ITEM.I_ITEM_SK = CATALOG_SALES.CS_ITEM_SK)
1 | 68 | [67] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CATALOG_SALES | CS_ITEM_SK, CS_ORDER_NUMBER, CS_EXT_LIST_PRICE | 54922 | 54922 | 923617475584
1 | 69 | [52] | Aggregate | aggExprs: [COUNT(*), SUM(STORE_SALES.SS_WHOLESALE_COST), SUM(STORE_SALES.SS_LIST_PRICE), SUM(STORE_SALES.SS_COUPON_AMT)], groupKeys: [STORE_SALES.SS_ITEM_SK, STORE_SALES.SS_TICKET_NUMBER, STORE_SALES.SS_CUSTOMER_SK, STORE_SALES.SS_ADDR_SK, STORE_SALES.SS_PROMO_SK, STORE_SALES.SS_STORE_SK, STORE_SALES.SS_HDEMO_SK, STORE_SALES.SS_CDEMO_SK, STORE_SALES.SS_SOLD_DATE_SK]
1 | 70 | [69] | Filter | (STORE_SALES.SS_CUSTOMER_SK IS NOT NULL) AND (STORE_SALES.SS_ADDR_SK IS NOT NULL) AND (STORE_SALES.SS_CDEMO_SK IS NOT NULL) AND (STORE_SALES.SS_PROMO_SK IS NOT NULL) AND (STORE_SALES.SS_STORE_SK IS NOT NULL) AND (STORE_SALES.SS_SOLD_DATE_SK IS NOT NULL) AND (STORE_SALES.SS_HDEMO_SK IS NOT NULL)
1 | 71 | [70] | JoinFilter | joinKey: (PROMOTION.P_PROMO_SK = STORE_SALES.SS_PROMO_SK)
1 | 72 | [71] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.STORE_SALES | SS_SOLD_DATE_SK, SS_ITEM_SK, SS_CUSTOMER_SK, SS_CDEMO_SK, SS_HDEMO_SK, SS_ADDR_SK, SS_STORE_SK, SS_PROMO_SK, SS_TICKET_NUMBER, SS_WHOLESALE_COST, SS_LIST_PRICE, SS_COUPON_AMT | 72718 | 70412 | 1212628258304
1 | 73 | [30] | Aggregate | aggExprs: [COUNT(*)], groupKeys: [AD1.CA_STREET_NUMBER, AD1.CA_STREET_NAME, AD1.CA_CITY, AD1.CA_ZIP, AD1.CA_ADDRESS_SK]
1 | 74 | [73] | JoinFilter | joinKey: (STORE_SALES.SS_ADDR_SK = AD1.CA_ADDRESS_SK)
1 | 75 | [74] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CUSTOMER_ADDRESS | AD1 | CA_ADDRESS_SK, CA_STREET_NUMBER, CA_STREET_NAME, CA_CITY, CA_ZIP | 256 | 256 | 776454656
1 | 76 | [28] | Aggregate | aggExprs: [COUNT(*)], groupKeys: [CUSTOMER.C_CURRENT_ADDR_SK, CUSTOMER.C_CURRENT_CDEMO_SK, CUSTOMER.C_FIRST_SHIPTO_DATE_SK, CUSTOMER.C_FIRST_SALES_DATE_SK, CUSTOMER.C_CURRENT_HDEMO_SK, CUSTOMER.C_CUSTOMER_SK]
1 | 77 | [76] | Filter | (CUSTOMER.C_CURRENT_CDEMO_SK IS NOT NULL) AND (CUSTOMER.C_FIRST_SHIPTO_DATE_SK IS NOT NULL) AND (CUSTOMER.C_FIRST_SALES_DATE_SK IS NOT NULL) AND (CUSTOMER.C_CURRENT_HDEMO_SK IS NOT NULL)
1 | 78 | [77] | JoinFilter | joinKey: (CD2.CD_DEMO_SK = CUSTOMER.C_CURRENT_CDEMO_SK), joinFilter: CD1.CD_MARITAL_STATUS <> CD2.CD_MARITAL_STATUS
1 | 79 | [78] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CUSTOMER | C_CUSTOMER_SK, C_CURRENT_CDEMO_SK, C_CURRENT_HDEMO_SK, C_CURRENT_ADDR_SK, C_FIRST_SHIPTO_DATE_SK, C_FIRST_SALES_DATE_SK | 261 | 261 | 2328538624
1 | 80 | [10] | Aggregate | aggExprs: [COUNT(*)], groupKeys: [AD2.CA_STREET_NUMBER, AD2.CA_STREET_NAME, AD2.CA_CITY, AD2.CA_ZIP, AD2.CA_ADDRESS_SK]
1 | 81 | [80] | JoinFilter | joinKey: (CUSTOMER.C_CURRENT_ADDR_SK = AD2.CA_ADDRESS_SK)
1 | 82 | [81] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.CUSTOMER_ADDRESS | AD2 | CA_ADDRESS_SK, CA_STREET_NUMBER, CA_STREET_NAME, CA_CITY, CA_ZIP | 256 | 256 | 776454656
1 | 83 | [8] | Aggregate | aggExprs: [COUNT(*)], groupKeys: [STORE_RETURNS.SR_ITEM_SK, STORE_RETURNS.SR_TICKET_NUMBER]
1 | 84 | [83] | JoinFilter | joinKey: (STORE_SALES.SS_ITEM_SK = STORE_RETURNS.SR_ITEM_SK) AND (STORE_SALES.SS_TICKET_NUMBER = STORE_RETURNS.SR_TICKET_NUMBER)
1 | 85 | [84] | TableScan | SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.STORE_RETURNS | SR_ITEM_SK, SR_TICKET_NUMBER | 7070 | 7070 | 124763446272
1 | 86 | [2] | JoinFilter | joinKey: (CS2.ITEM_SK = CS1.ITEM_SK) AND (CS2.STORE_NAME = CS1.STORE_NAME) AND (CS2.STORE_ZIP = CS1.STORE_ZIP), joinFilter: CS2.CNT <= CS1.CNT
1 | 87 | [86] | WithReference | CS1
1 | 88 | [87] | Filter | (D1.D_YEAR = 2001) AND (CS1.STORE_NAME IS NOT NULL) AND (CS1.STORE_ZIP IS NOT NULL)
```

**NOTE:** The EXPLAIN plan shows the PHYSICAL execution structure, which may differ significantly from the logical tree below. The optimizer may have already split CTEs, reordered joins, or pushed predicates. When the EXPLAIN and the logical tree disagree, the EXPLAIN is ground truth for what the optimizer is already doing.

Use EXPLAIN ANALYZE timings as ground truth. logical-tree cost percentages are derived metrics that may not reflect actual execution time.

## Query Structure (Logic Tree)

```
QUERY: (single statement)
├── [CTE] cs_ui  [=]  Cost: 33%  Rows: ~1K
│   ├── SCAN (catalog_sales, catalog_returns (join))
│   ├── JOIN (cs_item_sk = cr_item_sk)
│   ├── JOIN (cs_order_number = cr_order_number)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (cs_item_sk, sale, refund)
├── [CTE] cross_sales  [=]  Cost: 33%  Rows: ~1K
│   ├── SCAN (store_sales, store_returns (join), cs_ui (join), date_dim AS d1 (join), date_dim AS d2 (join), date_dim AS d3 (join), store (join), customer (join), customer_demographics AS cd1 (join), customer_demographics AS cd2 (join), promotion (join), household_demographics AS hd1 (join), household_demographics AS hd2 (join), customer_address AS ad1 (join), customer_address AS ad2 (join), income_band AS ib1 (join), income_band AS ib2 (join), item (join))
│   ├── JOIN (ss_store_sk = s_store_sk)
│   ├── JOIN (ss_sold_date_sk = d1.d_date_sk)
│   ├── JOIN (+16 more)
│   ├── FILTER (cd1.cd_marital_status <> cd2.cd_marital_status)
│   ├── FILTER (i_color IN ('blanched', 'medium', 'brown', 'chocolate', 'burlywood', 'drab'))
│   ├── FILTER (+2 more)
│   ├── AGG (GROUP BY)
│   └── OUTPUT (product_name, item_sk, store_name, store_zip, b_street_number, b_street_name, b_city, b_zip, ...)
└── [MAIN] main_query  [=]  Cost: 33%  Rows: ~1K
    ├── SCAN (cross_sales AS cs1 (join), cross_sales AS cs2 (join))
    ├── JOIN (cs1.item_sk = cs2.item_sk)
    ├── JOIN (cs1.store_name = cs2.store_name)
    ├── JOIN (+1 more)
    ├── FILTER (cs1.syear = 2001)
    ├── FILTER (cs2.syear = 2001 + 1)
    ├── FILTER (+1 more)
    ├── AGG (GROUP BY)
    ├── SORT (cs1.product_name ASC, cs1.store_name ASC, cs2.cnt ASC, cs1.s1 ASC, cs2.s1 ASC)
    └── OUTPUT (product_name, store_name, store_zip, b_street_number, b_street_name, b_city, b_zip, c_street_number, ...)
```

## Node Details

### 1. cs_ui
**Role**: CTE (Definition Order: 0)
**Stats**: 33% Cost | ~1k rows
**Flags**: GROUP_BY
**Outputs**: [cs_item_sk, sale, refund]
**Dependencies**: catalog_sales, catalog_returns (join)
**Joins**: cs_item_sk = cr_item_sk | cs_order_number = cr_order_number
**Operators**: HASH_GROUP_BY, SEQ_SCAN[catalog_sales], SEQ_SCAN[catalog_returns]
**Key Logic (SQL)**:
```sql
SELECT
  cs_item_sk,
  SUM(cs_ext_list_price) AS sale,
  SUM(cr_refunded_cash + cr_reversed_charge + cr_store_credit) AS refund
FROM catalog_sales, catalog_returns
WHERE
  cs_item_sk = cr_item_sk AND cs_order_number = cr_order_number
GROUP BY
  cs_item_sk
HAVING
  SUM(cs_ext_list_price) > 2 * SUM(cr_refunded_cash + cr_reversed_charge + cr_store_credit)
```

### 2. cross_sales
**Role**: CTE (Definition Order: 1)
**Stats**: 33% Cost | ~1k rows
**Flags**: GROUP_BY
**Outputs**: [product_name, item_sk, store_name, store_zip, b_street_number, b_street_name, b_city, b_zip, c_street_number, c_street_name, ...]
**Dependencies**: store_sales, store_returns (join), cs_ui (join), date_dim AS d1 (join), date_dim AS d2 (join), date_dim AS d3 (join), store (join), customer (join), customer_demographics AS cd1 (join), customer_demographics AS cd2 (join), promotion (join), household_demographics AS hd1 (join), household_demographics AS hd2 (join), customer_address AS ad1 (join), customer_address AS ad2 (join), income_band AS ib1 (join), income_band AS ib2 (join), item (join)
**Joins**: ss_store_sk = s_store_sk | ss_sold_date_sk = d1.d_date_sk | ss_customer_sk = c_customer_sk | ss_cdemo_sk = cd1.cd_demo_sk | ss_hdemo_sk = hd1.hd_demo_sk | ss_addr_sk = ad1.ca_address_sk | ss_item_sk = i_item_sk | ss_item_sk = sr_item_sk | ss_ticket_number = sr_ticket_number | ss_item_sk = cs_ui.cs_item_sk | c_current_cdemo_sk = cd2.cd_demo_sk | c_current_hdemo_sk = hd2.hd_demo_sk | c_current_addr_sk = ad2.ca_address_sk | c_first_sales_date_sk = d2.d_date_sk | c_first_shipto_date_sk = d3.d_date_sk | ss_promo_sk = p_promo_sk | hd1.hd_income_band_sk = ib1.ib_income_band_sk | hd2.hd_income_band_sk = ib2.ib_income_band_sk
**Filters**: cd1.cd_marital_status <> cd2.cd_marital_status | i_color IN ('blanched', 'medium', 'brown', 'chocolate', 'burlywood', 'drab') | i_current_price BETWEEN 23 AND 23 + 10 | i_current_price BETWEEN 23 + 1 AND 23 + 15
**Operators**: HASH_GROUP_BY, HASH_JOIN, SEQ_SCAN[store_sales], SEQ_SCAN[store_returns], SEQ_SCAN[cs_ui]
**Key Logic (SQL)**:
```sql
SELECT
  i_product_name AS product_name,
  i_item_sk AS item_sk,
  s_store_name AS store_name,
  s_zip AS store_zip,
  ad1.ca_street_number AS b_street_number,
  ad1.ca_street_name AS b_street_name,
  ad1.ca_city AS b_city,
  ad1.ca_zip AS b_zip,
  ad2.ca_street_number AS c_street_number,
  ad2.ca_street_name AS c_street_name,
  ad2.ca_city AS c_city,
  ad2.ca_zip AS c_zip,
  d1.d_year AS syear,
  d2.d_year AS fsyear,
  d3.d_year AS s2year,
  COUNT(*) AS cnt,
  SUM(ss_wholesale_cost) AS s1,
  SUM(ss_list_price) AS s2,
  SUM(ss_coupon_amt) AS s3
...
```

### 3. main_query
**Role**: Root / Output (Definition Order: 2)
**Stats**: 33% Cost | ~1k rows
**Flags**: GROUP_BY, ORDER_BY
**Outputs**: [product_name, store_name, store_zip, b_street_number, b_street_name, b_city, b_zip, c_street_number, c_street_name, c_city, ...] — ordered by cs1.product_name ASC, cs1.store_name ASC, cs2.cnt ASC, cs1.s1 ASC, cs2.s1 ASC
**Dependencies**: cross_sales AS cs1 (join), cross_sales AS cs2 (join)
**Joins**: cs1.item_sk = cs2.item_sk | cs1.store_name = cs2.store_name | cs1.store_zip = cs2.store_zip
**Filters**: cs1.syear = 2001 | cs2.syear = 2001 + 1 | cs2.cnt <= cs1.cnt
**Operators**: HASH_GROUP_BY, HASH_JOIN, SEQ_SCAN[cross_sales], SEQ_SCAN[cross_sales]
**Key Logic (SQL)**:
```sql
SELECT
  cs1.product_name,
  cs1.store_name,
  cs1.store_zip,
  cs1.b_street_number,
  cs1.b_street_name,
  cs1.b_city,
  cs1.b_zip,
  cs1.c_street_number,
  cs1.c_street_name,
  cs1.c_city,
  cs1.c_zip,
  cs1.syear,
  cs1.cnt,
  cs1.s1 AS s11,
  cs1.s2 AS s21,
  cs1.s3 AS s31,
  cs2.s1 AS s12,
  cs2.s2 AS s22,
  cs2.s3 AS s32,
...
```

### Edges
- cs_ui → cross_sales
- cross_sales → main_query
- cross_sales → main_query


## Aggregation Semantics Check

You MUST verify aggregation equivalence for any proposed restructuring:

- **STDDEV_SAMP(x)** requires >=2 non-NULL values per group. Returns NULL for 0-1 values. Changing group membership changes the result.
- `STDDEV_SAMP(x) FILTER (WHERE year=1999)` over a combined (1999,2000) group is NOT equivalent to `STDDEV_SAMP(x)` over only 1999 rows — FILTER still uses the combined group's membership for the stddev denominator.
- **AVG and STDDEV are NOT duplicate-safe**: if a join introduces row duplication, the aggregate result changes.
- When splitting a UNION ALL CTE with GROUP BY + aggregate, each split branch must preserve the exact GROUP BY columns and filter to the exact same row set as the original.
- **SAFE ALTERNATIVE**: If GROUP BY includes the discriminator column (e.g., d_year), each group is already partitioned. STDDEV_SAMP computed per-group is correct. You can then pivot using `MAX(CASE WHEN year = 1999 THEN year_total END) AS year_total_1999` because the GROUP BY guarantees exactly one row per (customer, year) — the MAX is just a row selector, not a real aggregation.

## Top 3 Tag-Matched Examples

### snowflake_date_cte_isolate (Nonex)
**Description:** Pre-filter date_dim in a CTE to reduce fact table join input. Helps Snowflake's micro-partition pruning on date-clustered fact tables.

### snowflake_decorrelate (Nonex)
**Description:** Convert correlated subquery to JOIN + GROUP BY for parallel MPP execution on Snowflake.

### snowflake_single_pass_aggregation (hypothesizedx)
**Description:** Replace N subqueries scanning the same fact table with a single scan using CASE WHEN conditional aggregation. Reduces remote I/O on Snowflake.
**Principle:** Scan Consolidation: scan large fact table once with conditional aggregation instead of N times with N subqueries. Critical for Snowflake where each scan hits remote storage.

## Optimization Principles (from benchmark history)

**reduce_scan_volume** (0.0x avg)
**consolidate_repeated_scans** (0.0x avg)
**decorrelate_subqueries** (0.0x avg)
**minimize_cte_count** (0.0x avg)

## Exploit Algorithm: Evidence-Based Gap Intelligence

The following describes known optimizer gaps with detection rules, procedural exploit steps, and evidence. Use DETECT rules to match structural features of the query, then follow EXPLOIT_STEPS.

# Snowflake Rewrite Playbook
# INITIAL — no empirical wins/regressions yet | TPC-DS SF10TCL

## HOW TO USE THIS DOCUMENT

Work in phase order. Each phase changes the plan shape — re-evaluate later phases after each.

  Phase 1: Reduce scan volume (P1, P2) — always first. Micro-partition pruning is Snowflake's #1 lever.
  Phase 2: Eliminate redundant work (P3, P4)
  Phase 3: Fix structural inefficiencies (P5, P6, P7)

Before choosing any strategy, scan the query profile for:
- Partitions scanned vs total: high ratio = pruning opportunity (add clustering key filters).
- Spilling to disk: bytes spilled > 0 = memory pressure, reduce intermediate sizes.
- Repeated table access: same table N times = consolidation candidate.
- Remote I/O vs cache: low cache hit = partition pruning or clustering issue.
- Join explosion: output rows >> input rows = join fanout, pre-aggregate.
- Subquery type: correlated subquery = decorrelation candidate (Snowflake handles well but not always optimally).

## ENGINE STRENGTHS — do NOT rewrite these patterns

1. **Micro-partition pruning**: Snowflake prunes partitions based on min/max metadata on clustering keys. If a filter matches the clustering key, pruning is automatic — do NOT restructure.
2. **Automatic clustering**: Snowflake re-clusters data in the background. Manual sort-based CTEs are unnecessary.
3. **Result set caching**: Identical queries return cached results in <100ms. Don't optimize for cache — focus on cold-run performance.
4. **MPP parallel execution**: Queries execute across warehouse nodes. Simple scans and aggregations are already parallelized.
5. **Semi-join optimization**: EXISTS/NOT EXISTS uses semi-join. Never materialize these patterns.
6. **Predicate pushdown**: Simple WHERE predicates pushed into scan. Don't wrap in CTEs for pushdown.
7. **Adaptive join selection**: Hash join vs merge join vs nested loop chosen automatically based on statistics.

## CORRECTNESS RULES

- Identical rows, columns, ordering as original.
- Copy ALL literals exactly (strings, numbers, dates).
- Preserve NULL semantics — NOT IN with NULLs behaves differently than NOT EXISTS.
- Every CTE must SELECT all columns referenced downstream.
- Never drop, rename, or reorder output columns.
- Preserve LIMIT semantics — no result set expansion.

## GLOBAL GUARDS (check always, before any rewrite)

1. EXISTS/NOT EXISTS → never materialize into CTEs (kills semi-join optimization)
2. Clustering key filters → never restructure (breaks micro-partition pruning)
3. Simple OR conditions → don't split to UNION ALL unless proven beneficial
4. Baseline < 500ms → skip CTE rewrites (network/compilation overhead on Snowflake > DuckDB)
5. CTEs are materialized by default — each CTE creates a temp result. Use sparingly.
6. UNION ALL creates separate execution branches — each scans independently. Limit to ≤3 branches.
7. Avoid creating more intermediate results than necessary — Snowflake spills large intermediates to remote storage.
8. Don't over-decompose — Snowflake's MPP engine handles large joins well if inputs are pruned.
9. Preserve window function partitioning — Snowflake optimizes PARTITION BY with sort-based execution.
10. QUALIFY clause is native to Snowflake — prefer over subquery-based row filtering.

## PATHOLOGY P1: CROSS_CTE_PREDICATE_BLINDNESS
**Signal**: Filter applied late (after join), large intermediate before filter.
**Transform**: date_cte_isolate, dimension_cte_isolate, early_filter
**Gate**: Original must scan > 1M rows before applying the selective filter.
**Strategy**: Pre-filter dimension tables in CTEs, join to fact table. Reduces partition scanning.
**Risk**: LOW — Snowflake CTEs are materialized, but small dimension CTEs are cheap.
**Example pattern**:
```sql
-- BEFORE: filter buried in WHERE after large join
SELECT ... FROM fact JOIN dim ON ... WHERE dim.col = 'value'
-- AFTER: pre-filter dimension, then join
WITH dim_filtered AS (SELECT ... FROM dim WHERE col = 'value')
SELECT ... FROM fact JOIN dim_filtered ON ...
```

## PATHOLOGY P2: REDUNDANT_SCAN_ELIMINATION
**Signal**: Same large table scanned multiple times in subqueries.
**Transform**: single_pass_aggregation, consolidate_scans
**Gate**: Table appears 3+ times in query, each scan > 100K rows.
**Strategy**: Scan once with CASE WHEN aggregation or a single CTE, then reference multiple times.
**Risk**: LOW — reduces I/O which is Snowflake's bottleneck.
**Example pattern**:
```sql
-- BEFORE: 8 subqueries each scanning store_sales
SELECT (SELECT count(*) FROM store_sales WHERE ...) as s1,
       (SELECT count(*) FROM store_sales WHERE ...) as s2
-- AFTER: single scan with conditional aggregation
SELECT count(CASE WHEN ... THEN 1 END) as s1,
       count(CASE WHEN ... THEN 1 END) as s2
FROM store_sales WHERE ...
```

## PATHOLOGY P3: CORRELATED_SUBQUERY_PARALYSIS
**Signal**: Correlated subquery in WHERE or SELECT list. EXPLAIN shows nested loop.
**Transform**: decorrelate, lateral_to_join
**Gate**: Outer query returns > 10K rows (correlation cost scales linearly).
**Strategy**: Convert correlated subquery to JOIN + GROUP BY.
**Risk**: MEDIUM — Snowflake handles some correlated subqueries well. Check if EXPLAIN already shows a join.

## PATHOLOGY P4: COMMA_JOIN_TO_EXPLICIT
**Signal**: FROM a, b, c WHERE a.x = b.x AND b.y = c.y (implicit cross joins).
**Transform**: explicit_join
**Gate**: 3+ tables in comma-join style.
**Strategy**: Convert to explicit JOIN...ON. Snowflake optimizer may handle both, but explicit joins provide clearer join ordering hints.
**Risk**: LOW — semantically equivalent, may help optimizer.

## PATHOLOGY P5: REPEATED_DIMENSION_PREFETCH
**Signal**: Same dimension table joined to multiple fact subqueries.
**Transform**: dimension_cte_isolate, multi_dimension_prefetch
**Gate**: Dimension joined 2+ times with same filter.
**Strategy**: Pre-filter dimension once in CTE, reuse across subqueries.
**Risk**: LOW — reduces redundant dimension scans.

## PATHOLOGY P6: SET_OPERATION_OPTIMIZATION
**Signal**: INTERSECT, EXCEPT used where EXISTS/NOT EXISTS would suffice.
**Transform**: intersect_to_exists, except_to_not_exists
**Gate**: Set operation on large result sets (> 100K rows per side).
**Strategy**: Convert to EXISTS/NOT EXISTS for semi-join optimization.
**Risk**: LOW — preserves semantics, enables semi-join.

## PATHOLOGY P7: WINDOW_FUNCTION_PUSHDOWN
**Signal**: Window function computed over large dataset, then filtered.
**Transform**: qualify_pushdown, pre_filter_window
**Gate**: Window function input > 1M rows, post-filter keeps < 10%.
**Strategy**: Use QUALIFY clause (Snowflake-native) or pre-filter input.
**Risk**: MEDIUM — QUALIFY changes execution order.

## VERIFICATION CHECKLIST

Before submitting any rewrite:
1. Row count: must match original exactly.
2. Column count and names: must match original exactly.
3. NULL handling: NOT IN/NOT EXISTS semantics preserved.
4. ORDER BY: must match original if present.
5. LIMIT: must match original if present.
6. No new tables introduced.
7. No columns removed from output.

## PRUNING GUIDE

Skip optimization if:
- Query baseline < 500ms (Snowflake overhead makes marginal gains invisible).
- Query is a simple point lookup (micro-partition pruning already optimal).
- Query uses only indexed/clustered columns in WHERE (already pruned).
- Only 1 table in FROM (nothing to restructure).

## REGRESSION REGISTRY

*No regressions recorded yet — this section will be populated after initial benchmark.*

| Query | Rewrite | Regression | Root Cause |
|-------|---------|------------|------------|
| — | — | — | — |


## Correctness Constraints (4 — NEVER violate)

**[CRITICAL] COMPLETE_OUTPUT**: The rewritten query must output ALL columns from the original SELECT. Never drop, rename, or reorder output columns. Every column alias must be preserved exactly as in the original.

**[CRITICAL] CTE_COLUMN_COMPLETENESS**: CRITICAL: When creating or modifying a CTE, its SELECT list MUST include ALL columns referenced by downstream queries. Check the Node Contracts section: every column in downstream_refs MUST appear in the CTE output. Also ensure: (1) JOIN columns used by consumers are included in SELECT, (2) every table referenced in WHERE is present in FROM/JOIN, (3) no ambiguous column names between the CTE and re-joined tables. Dropping a column that a downstream node needs will cause an execution error.
  - Failure: Q21 — prefetched_inventory CTE omits i_item_id but main query references it in SELECT and GROUP BY
  - Failure: Q76 — filtered_store_dates CTE omits d_year and d_qoy but aggregation CTE uses them in GROUP BY

**[CRITICAL] LITERAL_PRESERVATION**: CRITICAL: When rewriting SQL, you MUST copy ALL literal values (strings, numbers, dates) EXACTLY from the original query. Do NOT invent, substitute, or 'improve' any filter values. If the original says d_year = 2000, your rewrite MUST say d_year = 2000. If the original says ca_state = 'GA', your rewrite MUST say ca_state = 'GA'. Changing these values will produce WRONG RESULTS and the rewrite will be REJECTED.

**[CRITICAL] SEMANTIC_EQUIVALENCE**: The rewritten query MUST return exactly the same rows, columns, and ordering as the original. This is the prime directive. Any rewrite that changes the result set — even by one row, one column, or a different sort order — is WRONG and will be REJECTED.

## Your Task

First, use a `<reasoning>` block for your internal analysis. This will be stripped before parsing. Work through these steps IN ORDER:

1. **CLASSIFY**: What structural archetype is this query?
   (channel-comparison self-join / correlated-aggregate filter / star-join with late dim filter / repeated fact scan / multi-channel UNION ALL / EXISTS-set operations / other)

2. **EXPLAIN PLAN ANALYSIS**: From the EXPLAIN ANALYZE output, identify:
   - Compute wall-clock ms per EXPLAIN node. Sum repeated operations (e.g., 2x store_sales joins = total cost). The EXPLAIN is ground truth, not the logical-tree cost percentages.
   - Which nodes consume >10% of runtime and WHY
   - Where row counts drop sharply (existing selectivity)
   - Where row counts DON'T drop (missed optimization opportunity)
   - Whether the optimizer already splits CTEs, pushes predicates, or performs transforms you might otherwise assign
   - Count scans per base table. If a fact table is scanned N times, a restructuring that reduces it to 1 scan saves (N-1)/N of that table's I/O cost. Prioritize transforms that reduce scan count on the largest tables.
   - Whether the CTE is materialized once and probed multiple times, or re-executed per reference

3. **GAP MATCHING**: Compare the EXPLAIN analysis to the Engine Profile gaps above. For each gap:
   - Does this query exhibit the gap? (e.g., is a predicate NOT pushed into a CTE? Is the same fact table scanned multiple times?)
   - Check the 'opportunity' — does this query's structure match?
   - Check 'what_didnt_work' and 'field_notes' — any disqualifiers for this query?
   - Also verify: is the optimizer ALREADY handling this well? (Check the Optimizer Strengths above — if the engine already does it, your transform adds overhead, not value.)

4. **AGGREGATION TRAP CHECK**: For every aggregate function in the query, verify: does my proposed restructuring change which rows participate in each group? STDDEV_SAMP, VARIANCE, PERCENTILE_CONT, CORR are grouping-sensitive. SUM, COUNT, MIN, MAX are grouping-insensitive (modulo duplicates). If the query uses FILTER clauses or conditional aggregation, verify equivalence explicitly.

5. **TRANSFORM SELECTION**: From the matched engine gaps, select transforms that exploit the specific gaps present in THIS query. Rank by expected value (rows affected × historical speedup from evidence). Select 4 that are structurally diverse — each attacking a different gap or bottleneck.
   REJECT tag-matched examples whose primary technique requires a structural feature this query lacks (e.g., reject intersect_to_exists if query has no INTERSECT; reject decorrelate if query has no correlated subquery). Tag matching is approximate — always verify structural applicability.

6. **LOGICAL TREE DESIGN**: For each worker's strategy, define the target logical tree topology. Verify that every node contract has exhaustive output columns by checking downstream references.
   CTE materialization matters for your design: a CTE referenced by 2+ consumers will likely be materialized (good — computed once, probed many). A CTE referenced once may be inlined (no materialization benefit from 'sharing'). Design shared CTEs only when multiple downstream nodes consume them. See CTE_INLINING in Engine Profile strengths.

Then produce the structured briefing in EXACTLY this format:

```
=== SHARED BRIEFING ===

SEMANTIC_CONTRACT: (80-150 tokens, cover ONLY:)
(a) One sentence of business intent (start from pre-computed intent if available).
(b) JOIN type semantics that constrain rewrites (INNER = intersection = all sides must match).
(c) Any aggregation function traps specific to THIS query.
(d) Any filter dependencies that a rewrite could break.
Do NOT repeat information already in ACTIVE_CONSTRAINTS or REGRESSION_WARNINGS.

BOTTLENECK_DIAGNOSIS:
[Which operation dominates cost and WHY (not just '50% cost').
Scan-bound vs join-bound vs aggregation-bound.
Cardinality flow (how many rows at each stage).
What the optimizer already handles well (don't re-optimize).
Whether logical-tree cost percentages are misleading.]

ACTIVE_CONSTRAINTS:
- [CORRECTNESS_CONSTRAINT_ID]: [Why it applies to this query, 1 line]
- [ENGINE_GAP_ID]: [Evidence from EXPLAIN that this gap is active]
(List all 4 correctness constraints + the 1-3 engine gaps that
are active for THIS query based on your EXPLAIN analysis.)

REGRESSION_WARNINGS:
1. [Pattern name] ([observed regression]):
   CAUSE: [What happened mechanistically]
   RULE: [Actionable avoidance rule for THIS query]
(If no regression warnings are relevant, write 'None applicable.')

=== WORKER 1 BRIEFING ===

STRATEGY: [strategy_name]
TARGET_LOGICAL_TREE:
  [node] -> [node] -> [node]
NODE_CONTRACTS:
(Write all fields as SQL fragments, not natural language.
Example: 'WHERE: d_year IN (1999, 2000)' not 'WHERE: filter to target years'.
The worker uses these as specifications to code against.)
  [node_name]:
    FROM: [tables/CTEs]
    JOIN: [join conditions]
    WHERE: [filters]
    GROUP BY: [columns] (if applicable)
    AGGREGATE: [functions] (if applicable)
    OUTPUT: [exhaustive column list]
    EXPECTED_ROWS: [approximate row count from EXPLAIN analysis]
    CONSUMERS: [downstream nodes]
EXAMPLES: [ex1], [ex2], [ex3]
EXAMPLE_ADAPTATION:
[For each example: what aspect to apply to THIS strategy,
and what to IGNORE (e.g., 'apply the date CTE pattern; ignore the
decorrelation — Q74 has no correlated subquery').]
HAZARD_FLAGS:
- [Specific risk for this approach on this query]

=== WORKER 2 BRIEFING ===

STRATEGY: [strategy_name]
TARGET_LOGICAL_TREE:
  [node] -> [node] -> [node]
NODE_CONTRACTS:
(Write all fields as SQL fragments, not natural language.
Example: 'WHERE: d_year IN (1999, 2000)' not 'WHERE: filter to target years'.
The worker uses these as specifications to code against.)
  [node_name]:
    FROM: [tables/CTEs]
    JOIN: [join conditions]
    WHERE: [filters]
    GROUP BY: [columns] (if applicable)
    AGGREGATE: [functions] (if applicable)
    OUTPUT: [exhaustive column list]
    EXPECTED_ROWS: [approximate row count from EXPLAIN analysis]
    CONSUMERS: [downstream nodes]
EXAMPLES: [ex1], [ex2], [ex3]
EXAMPLE_ADAPTATION:
[For each example: what aspect to apply to THIS strategy,
and what to IGNORE (e.g., 'apply the date CTE pattern; ignore the
decorrelation — Q74 has no correlated subquery').]
HAZARD_FLAGS:
- [Specific risk for this approach on this query]

=== WORKER 3 BRIEFING ===

STRATEGY: [strategy_name]
TARGET_LOGICAL_TREE:
  [node] -> [node] -> [node]
NODE_CONTRACTS:
(Write all fields as SQL fragments, not natural language.
Example: 'WHERE: d_year IN (1999, 2000)' not 'WHERE: filter to target years'.
The worker uses these as specifications to code against.)
  [node_name]:
    FROM: [tables/CTEs]
    JOIN: [join conditions]
    WHERE: [filters]
    GROUP BY: [columns] (if applicable)
    AGGREGATE: [functions] (if applicable)
    OUTPUT: [exhaustive column list]
    EXPECTED_ROWS: [approximate row count from EXPLAIN analysis]
    CONSUMERS: [downstream nodes]
EXAMPLES: [ex1], [ex2], [ex3]
EXAMPLE_ADAPTATION:
[For each example: what aspect to apply to THIS strategy,
and what to IGNORE (e.g., 'apply the date CTE pattern; ignore the
decorrelation — Q74 has no correlated subquery').]
HAZARD_FLAGS:
- [Specific risk for this approach on this query]

=== WORKER 4 BRIEFING === (EXPLORATION WORKER)

STRATEGY: [strategy_name]
TARGET_LOGICAL_TREE:
  [node] -> [node] -> [node]
NODE_CONTRACTS:
(Write all fields as SQL fragments, not natural language.
Example: 'WHERE: d_year IN (1999, 2000)' not 'WHERE: filter to target years'.
The worker uses these as specifications to code against.)
  [node_name]:
    FROM: [tables/CTEs]
    JOIN: [join conditions]
    WHERE: [filters]
    GROUP BY: [columns] (if applicable)
    AGGREGATE: [functions] (if applicable)
    OUTPUT: [exhaustive column list]
    EXPECTED_ROWS: [approximate row count from EXPLAIN analysis]
    CONSUMERS: [downstream nodes]
EXAMPLES: [ex1], [ex2], [ex3]
EXAMPLE_ADAPTATION:
[For each example: what aspect to apply to THIS strategy,
and what to IGNORE (e.g., 'apply the date CTE pattern; ignore the
decorrelation — Q74 has no correlated subquery').]
HAZARD_FLAGS:
- [Specific risk for this approach on this query]
CONSTRAINT_OVERRIDE: [CONSTRAINT_ID or 'None']
OVERRIDE_REASONING: [Why this query's structure differs from the observed failure, or 'N/A']
EXPLORATION_TYPE: [constraint_relaxation | compound_strategy | novel_combination]

```

## Section Validation Checklist (MUST pass before final output)

Use this checklist to verify content quality, not just section presence:

### SHARED BRIEFING
- `SEMANTIC_CONTRACT`: 40-200 tokens and includes business intent, JOIN semantics, aggregation trap, and filter dependency.
- `BOTTLENECK_DIAGNOSIS`: states dominant mechanism, bound type (`scan-bound`/`join-bound`/`aggregation-bound`), cardinality flow, and what optimizer already handles well.
- `ACTIVE_CONSTRAINTS`: includes all 4 correctness IDs plus 1-3 active engine gaps with EXPLAIN evidence.
- `REGRESSION_WARNINGS`: either `None applicable.` or numbered entries with both `CAUSE:` and `RULE:`.

### WORKER N BRIEFING (N=1..4)
- `STRATEGY`: non-empty and unique across workers.
- `TARGET_LOGICAL_TREE`: explicit node chain (e.g., `a -> b -> c`).
- `NODE_CONTRACTS`: every logical tree node has a contract with `FROM`, `OUTPUT` (explicit columns), and `CONSUMERS`.
- `EXAMPLES`: 1-3 IDs per worker. Sharing an example across workers is allowed if each worker's EXAMPLE_ADAPTATION explains a different aspect to apply.
- `EXAMPLE_ADAPTATION`: for each example, states what to adapt and what to ignore for this worker's strategy.
- `HAZARD_FLAGS`: query-specific risks, not generic cautions.

### WORKER 4 EXPLORATION FIELDS
- Includes `CONSTRAINT_OVERRIDE`, `OVERRIDE_REASONING`, and `EXPLORATION_TYPE`.

## Transform Catalog

Select 4 transforms that are applicable to THIS query, maximizing structural diversity (each must attack a different part of the execution plan).

### Predicate Movement
- **global_predicate_pushdown**: Trace selective predicates from late in the CTE chain back to the earliest scan via join equivalences. Biggest win when a dimension filter is applied after a large intermediate materialization.
  Maps to examples: pushdown, early_filter, date_cte_isolate
- **transitive_predicate_propagation**: Infer predicates through join equivalence chains (A.key = B.key AND B.key = 5 -> A.key = 5). Especially across CTE boundaries where optimizers stop propagating.
  Maps to examples: early_filter, dimension_cte_isolate
- **null_rejecting_join_simplification**: When downstream WHERE rejects NULLs from the outer side of a LEFT JOIN, convert to INNER. Enables reordering and predicate pushdown. CHECK: does the query actually have LEFT/OUTER joins before assigning this.
  Maps to examples: (no direct gold example — novel transform)

### Join Restructuring
- **self_join_elimination**: When a UNION ALL CTE is self-joined N times with each join filtering to a different discriminator, split into N pre-partitioned CTEs. Eliminates discriminator filtering and repeated hash probes on rows that don't match.
  Maps to examples: union_cte_split, shared_dimension_multi_channel
- **decorrelation**: Convert correlated EXISTS/IN/scalar subqueries to CTE + JOIN. CHECK: does the query actually have correlated subqueries before assigning this.
  Maps to examples: decorrelate, composite_decorrelate_union
- **aggregate_pushdown**: When GROUP BY follows a multi-table join but aggregation only uses columns from one side, push the GROUP BY below the join. CHECK: verify the join doesn't change row multiplicity for the aggregate (one-to-many breaks AVG/STDDEV).
  Maps to examples: (no direct gold example — novel transform)
- **late_attribute_binding**: When a dimension table is joined only to resolve display columns (names, descriptions) that aren't used in filters, aggregations, or join conditions, defer that join until after all filtering and aggregation is complete. Join on the surrogate key once against the final reduced result set. This eliminates N-1 dimension scans when the CTE references the dimension N times. CHECK: verify the deferred columns aren't used in WHERE, GROUP BY, or JOIN ON — only in the final SELECT.
  Maps to examples: dimension_cte_isolate (partial pattern), early_filter

### Scan Optimization
- **star_join_prefetch**: Pre-filter ALL dimension tables into CTEs, then probe fact table with the combined key intersection.
  Maps to examples: dimension_cte_isolate, multi_dimension_prefetch, prefetch_fact_join, date_cte_isolate
- **single_pass_aggregation**: Merge N subqueries on the same fact table into 1 scan with CASE/FILTER inside aggregates. CHECK: STDDEV_SAMP/VARIANCE are grouping-sensitive — FILTER over a combined group != separate per-group computation.
  Maps to examples: single_pass_aggregation, channel_bitmap_aggregation
- **scan_consolidation_pivot**: When a CTE is self-joined N times with each reference filtering to a different discriminator (e.g., year, channel), consolidate into fewer scans that GROUP BY the discriminator, then pivot rows to columns using MAX(CASE WHEN discriminator = X THEN agg_value END). This halves the fact scans and dimension joins. SAFE when GROUP BY includes the discriminator — each group is naturally partitioned, so aggregates like STDDEV_SAMP are computed correctly per-partition. The pivot MAX is just a row selector (one row per group), not a real aggregation.
  Maps to examples: single_pass_aggregation, union_cte_split

### Structural Transforms
- **union_consolidation**: Share dimension lookups across UNION ALL branches that scan different fact tables with the same dim joins.
  Maps to examples: shared_dimension_multi_channel
- **window_optimization**: Push filters before window functions when they don't affect the frame. Convert ROW_NUMBER + filter to LATERAL + LIMIT. Merge same-PARTITION windows into one sort pass.
  Maps to examples: deferred_window_aggregation
- **exists_restructuring**: Convert INTERSECT to EXISTS for semi-join short-circuit, or restructure complex EXISTS with shared CTEs. CHECK: does the query actually have INTERSECT or complex EXISTS.
  Maps to examples: intersect_to_exists, multi_intersect_exists_cte

## Strategy Selection Rules

1. **CHECK APPLICABILITY**: Each transform has a structural prerequisite (correlated subquery, UNION ALL CTE, LEFT JOIN, etc.). Verify the query actually has the prerequisite before assigning a transform. DO NOT assign decorrelation if there are no correlated subqueries.
2. **CHECK OPTIMIZER OVERLAP**: Read the EXPLAIN plan. If the optimizer already performs a transform (e.g., already splits a UNION CTE, already pushes a predicate), that transform will have marginal benefit. Note this in your reasoning and prefer transforms the optimizer is NOT already doing.
3. **MAXIMIZE DIVERSITY**: Each worker must attack a different part of the execution plan. Do not assign 'pushdown variant A' and 'pushdown variant B'. Assign transforms from different categories above.
4. **ASSESS RISK PER-QUERY**: Risk is a function of (transform x query complexity), not an inherent property of the transform. Decorrelation is low-risk on a simple EXISTS and high-risk on nested correlation inside a CTE. Assess per-assignment.
5. **COMPOSITION IS ALLOWED AND ENCOURAGED**: A strategy can combine 2-3 transforms from different categories (e.g., star_join_prefetch + scan_consolidation_pivot, or date_cte_isolate + early_filter + decorrelate). The TARGET_LOGICAL_TREE should reflect the combined structure. Compound strategies are often the source of the biggest wins.
6. **MINIMAL-CHANGE BASELINE**: If the EXPLAIN shows the optimizer already handles the primary bottleneck (e.g., already splits CTEs, already pushes predicates), consider assigning one worker as a minimal-change baseline: explicit JOINs only, no structural changes. This provides a regression-safe fallback.

Each worker gets 1-3 examples. If fewer than 2 examples genuinely match the worker's strategy, assign 1 and state 'No additional examples apply.' Do NOT pad with irrelevant examples — an irrelevant example is worse than no example because the worker will try to apply its pattern. No duplicate examples across workers. Use example IDs from the catalog above.

For TARGET_LOGICAL_TREE: Define the CTE structure you want produced. For NODE_CONTRACTS: Be exhaustive with OUTPUT columns — missing columns cause semantic breaks.

## Exploration Budget (Worker 4)

Workers 1-3 follow the engine profile's proven patterns. **Worker 4 is the EXPLORATION worker** with a different mandate:

Worker 4 MAY (in priority order — prefer higher-value exploration):
  (c) **PREFERRED**: Attempt a novel technique not listed in the engine profile, if the EXPLAIN plan reveals an optimizer blind spot not yet documented. This is the highest-value exploration — new discoveries expand the engine profile for all future queries.
  (b) Combine 2-3 transforms from different engine gaps into a compound strategy that hasn't been tested before. Medium value — tests interaction effects between known patterns.
  (a) Retry a technique from 'what_didnt_work', IF the structural context of THIS query differs materially from the observed failure — explain the structural difference in HAZARD_FLAGS. Lowest priority — only when the query structure clearly diverges from the failed case.

Worker 4 may NEVER violate correctness constraints (LITERAL_PRESERVATION, SEMANTIC_EQUIVALENCE, COMPLETE_OUTPUT, CTE_COLUMN_COMPLETENESS).

The exploration worker's output is tagged EXPLORATORY and tracked separately. Past failures documented in the engine profile are context-specific — they happened on specific queries with specific structures. Worker 4's job is to test whether those failures generalize or not. If Worker 4 discovers a new win, it becomes field intelligence for the engine profile.

## Output Consumption Spec

Each worker receives:
1. SHARED BRIEFING (SEMANTIC_CONTRACT + BOTTLENECK_DIAGNOSIS + ACTIVE_CONSTRAINTS + REGRESSION_WARNINGS)
2. Their specific WORKER N BRIEFING (STRATEGY + TARGET_LOGICAL_TREE + NODE_CONTRACTS + EXAMPLES + EXAMPLE_ADAPTATION + HAZARD_FLAGS)
3. Full before/after SQL for their assigned examples (retrieved by example ID)
4. The original query SQL (full, as reference)
5. Column completeness contract + output format spec

Workers do NOT see other workers' briefings.
Presentation order: briefing first (understanding), then examples (patterns), then original SQL (source), then output format (mechanics).