{
  "explain_plan_text": "{'GlobalStats': {'partitionsTotal': 283, 'partitionsAssigned': 283, 'bytesAssigned': 3684704256}, 'Operations': [[{'id': 0, 'operation': 'Result', 'expressions': ['INV1.W_WAREHOUSE_SK', 'INV1.I_ITEM_SK', 'INV1.D_MOY', 'INV1.MEAN', 'INV1.COV', 'INV2.W_WAREHOUSE_SK', 'INV2.I_ITEM_SK', 'INV2.D_MOY', 'INV2.MEAN', 'INV2.COV']}, {'id': 1, 'operation': 'Sort', 'expressions': ['INV1.W_WAREHOUSE_SK ASC NULLS LAST', 'INV1.I_ITEM_SK ASC NULLS LAST', 'INV1.D_MOY ASC NULLS LAST', 'INV1.MEAN ASC NULLS LAST', 'INV1.COV ASC NULLS LAST', 'INV2.D_MOY ASC NULLS LAST', 'INV2.MEAN ASC NULLS LAST', 'INV2.COV ASC NULLS LAST'], 'parentOperators': [0]}, {'id': 2, 'operation': 'InnerJoin', 'expressions': ['joinKey: (INV1.I_ITEM_SK = INV2.I_ITEM_SK) AND (INV1.W_WAREHOUSE_SK = INV2.W_WAREHOUSE_SK)'], 'parentOperators': [1]}, {'id': 3, 'operation': 'WithReference', 'expressions': ['INV1'], 'parentOperators': [2]}, {'id': 4, 'operation': 'Filter', 'expressions': ['INV1.D_MOY = 5'], 'parentOperators': [3]}, {'id': 5, 'operation': 'WithClause', 'expressions': ['INV'], 'parentOperators': [4, 25]}, {'id': 6, 'operation': 'Filter', 'expressions': ['(CASE SCALED_ROUND_INT_DIVIDE(SUM(SUM(SUM(SUM_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*))))), COUNT(COUNT(COUNT(COUNT_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)))))) WHEN 0 THEN 0.0 ELSE (SQRT(TO_DOUBLE(SCALED_ROUND_INT_DIVIDE(IFF((((COUNT(COUNT(COUNT(COUNT_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)))))) * (SUM(SUM(SUM(SUM_INTERNAL((INVENTORY.INV_QUANTITY_ON_HAND) * (INVENTORY.INV_QUANTITY_ON_HAND), COUNT(*))))))) - ((SUM(SUM(SUM(SUM_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)))))) * (SUM(SUM(SUM(SUM_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)))))))) < 0, 0, ((COUNT(COUNT(COUNT(COUNT_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)))))) * (SUM(SUM(SUM(SUM_INTERNAL((INVENTORY.INV_QUANTITY_ON_HAND) * (INVENTORY.INV_QUANTITY_ON_HAND), COUNT(*))))))) - ((SUM(SUM(SUM(SUM_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)))))) * (SUM(SUM(SUM(SUM_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)))))))), NULLIF((COUNT(COUNT(COUNT(COUNT_INTERNAL(INVENTORY.INV...'], 'parentOperators': [5]}, {'id': 7, 'operation': 'Aggregate', 'expressions': ['aggExprs: [COUNT(COUNT(COUNT(COUNT_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*))))), SUM(SUM(SUM(SUM_INTERNAL((INVENTORY.INV_QUANTITY_ON_HAND) * (INVENTORY.INV_QUANTITY_ON_HAND), COUNT(*))))), SUM(SUM(SUM(SUM_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)))))]', 'groupKeys: [WAREHOUSE.W_WAREHOUSE_NAME, WAREHOUSE.W_WAREHOUSE_SK, ITEM.I_ITEM_SK, DATE_DIM.D_MOY]'], 'parentOperators': [6]}, {'id': 8, 'operation': 'Aggregate', 'expressions': ['aggExprs: [COUNT(COUNT(COUNT_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)))), SUM(SUM(SUM_INTERNAL((INVENTORY.INV_QUANTITY_ON_HAND) * (INVENTORY.INV_QUANTITY_ON_HAND), COUNT(*)))), SUM(SUM(SUM_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*))))]', 'groupKeys: [WAREHOUSE.W_WAREHOUSE_NAME, WAREHOUSE.W_WAREHOUSE_SK, ITEM.I_ITEM_SK, DATE_DIM.D_MOY]'], 'parentOperators': [7]}, {'id': 9, 'operation': 'InnerJoin', 'expressions': ['joinKey: (WAREHOUSE.W_WAREHOUSE_SK = INVENTORY.INV_WAREHOUSE_SK)'], 'parentOperators': [8]}, {'id': 10, 'operation': 'TableScan', 'objects': ['SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.WAREHOUSE'], 'expressions': ['W_WAREHOUSE_SK', 'W_WAREHOUSE_NAME'], 'partitionsAssigned': 1, 'partitionsTotal': 1, 'bytesAssigned': 7168, 'parentOperators': [9]}, {'id': 11, 'operation': 'Aggregate', 'expressions': ['aggExprs: [COUNT(COUNT_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*))), SUM(SUM_INTERNAL((INVENTORY.INV_QUANTITY_ON_HAND) * (INVENTORY.INV_QUANTITY_ON_HAND), COUNT(*))), SUM(SUM_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)))]', 'groupKeys: [ITEM.I_ITEM_SK, DATE_DIM.D_MOY, INVENTORY.INV_WAREHOUSE_SK]'], 'parentOperators': [9]}, {'id': 12, 'operation': 'InnerJoin', 'expressions': ['joinKey: (DATE_DIM.D_DATE_SK = INVENTORY.INV_DATE_SK)'], 'parentOperators': [11]}, {'id': 13, 'operation': 'Filter', 'expressions': ['(DATE_DIM.D_MOY IN 5 IN 6) AND (DATE_DIM.D_YEAR = 2002)'], 'parentOperators': [12]}, {'id': 14, 'operation': 'TableScan', 'objects': ['SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.DATE_DIM'], 'expressions': ['D_DATE_SK', 'D_YEAR', 'D_MOY'], 'partitionsAssigned': 1, 'partitionsTotal': 1, 'bytesAssigned': 2138624, 'parentOperators': [13]}, {'id': 15, 'operation': 'Aggregate', 'expressions': ['aggExprs: [COUNT_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*)), SUM_INTERNAL((INVENTORY.INV_QUANTITY_ON_HAND) * (INVENTORY.INV_QUANTITY_ON_HAND), COUNT(*)), SUM_INTERNAL(INVENTORY.INV_QUANTITY_ON_HAND, COUNT(*))]', 'groupKeys: [ITEM.I_ITEM_SK, INVENTORY.INV_WAREHOUSE_SK, INVENTORY.INV_DATE_SK]'], 'parentOperators': [12]}, {'id': 16, 'operation': 'InnerJoin', 'expressions': ['joinKey: (ITEM.I_ITEM_SK = INVENTORY.INV_ITEM_SK)'], 'parentOperators': [15]}, {'id': 17, 'operation': 'Aggregate', 'expressions': ['aggExprs: [COUNT(*)]', 'groupKeys: [ITEM.I_ITEM_SK]'], 'parentOperators': [16]}, {'id': 18, 'operation': 'Filter', 'expressions': [\"(ITEM.I_CATEGORY IN 'Shoes' IN 'Sports') AND (ITEM.I_MANAGER_ID >= 42) AND (ITEM.I_MANAGER_ID <= 61)\"], 'parentOperators': [17]}, {'id': 19, 'operation': 'TableScan', 'objects': ['SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.ITEM'], 'expressions': ['I_ITEM_SK', 'I_CATEGORY', 'I_MANAGER_ID'], 'partitionsAssigned': 2, 'partitionsTotal': 2, 'bytesAssigned': 23811584, 'parentOperators': [18]}, {'id': 20, 'operation': 'Filter', 'expressions': ['(INVENTORY.INV_QUANTITY_ON_HAND >= 791) AND (INVENTORY.INV_QUANTITY_ON_HAND <= 991)'], 'parentOperators': [16]}, {'id': 21, 'operation': 'JoinFilter', 'expressions': ['joinKey: (WAREHOUSE.W_WAREHOUSE_SK = INVENTORY.INV_WAREHOUSE_SK)'], 'parentOperators': [20]}, {'id': 22, 'operation': 'TableScan', 'objects': ['SNOWFLAKE_SAMPLE_DATA.TPCDS_SF10TCL.INVENTORY'], 'expressions': ['INV_DATE_SK', 'INV_ITEM_SK', 'INV_WAREHOUSE_SK', 'INV_QUANTITY_ON_HAND'], 'partitionsAssigned': 279, 'partitionsTotal': 279, 'bytesAssigned': 3658746880, 'parentOperators': [21]}, {'id': 23, 'operation': 'JoinFilter', 'expressions': ['joinKey: (INV1.I_ITEM_SK = INV2.I_ITEM_SK) AND (INV1.W_WAREHOUSE_SK = INV2.W_WAREHOUSE_SK)'], 'parentOperators': [2]}, {'id': 24, 'operation': 'WithReference', 'expressions': ['INV2'], 'parentOperators': [23]}, {'id': 25, 'operation': 'Filter', 'expressions': ['INV2.D_MOY = 6'], 'parentOperators': [24]}]]}",
  "plan_scanner_text": null,
  "semantic_intents": null,
  "matched_examples": [],
  "all_available_examples": [
    {
      "id": "sf_inline_decorrelate",
      "speedup": "23.17x",
      "description": "When a WHERE clause contains a correlated scalar subquery (e.g., col > (SELECT 1"
    },
    {
      "id": "sf_shared_scan_decorrelate",
      "speedup": "7.82x",
      "description": "When a correlated subquery re-scans the same fact table as the outer query with "
    },
    {
      "id": "sf_sk_pushdown_3fact",
      "speedup": "1.17x",
      "description": "When 3 fact tables (store_sales, catalog_sales, web_sales) each join date_dim vi"
    },
    {
      "id": "sf_sk_pushdown_union_all",
      "speedup": "2.13x",
      "description": "When a UNION ALL CTE combines multiple fact tables (web_sales + catalog_sales) a"
    }
  ],
  "engine_profile": {
    "version_tested": "8.x (cloud)",
    "profile_type": "engine_profile",
    "briefing_note": "P3 (correlated scalar decorrelation) 2/2 (100%) \u2014 23.17x and 7.82x wins on SF10TCL MEDIUM, 3x3 validated.",
    "strengths": [
      {
        "id": "MICRO_PARTITION_PRUNING",
        "summary": "Filters on clustered columns skip micro-partitions at scan level",
        "implication": "Snowflake's #1 optimization. Functions on filter columns kill pruning. Runtime pruning from CTE values invisible in static EXPLAIN."
      },
      {
        "id": "COLUMN_PRUNING",
        "summary": "Reads only columns referenced by final query, even through CTEs",
        "implication": "Automatic unless final SELECT is *."
      },
      {
        "id": "PREDICATE_PUSHDOWN",
        "summary": "Filters pushed to storage layer including through single-ref CTEs",
        "implication": "Also does predicate mirroring across join sides."
      },
      {
        "id": "CORRELATED_DECORRELATION",
        "summary": "Simple correlated subqueries (EXISTS/IN) automatically decorrelated to hash joins",
        "implication": "Do NOT decorrelate simple EXISTS/IN. DOES NOT handle correlated scalar subqueries with aggregation (see gap)."
      },
      {
        "id": "SEMI_JOIN",
        "summary": "EXISTS \u2192 SemiJoin with early termination",
        "implication": "Never materialize EXISTS patterns."
      },
      {
        "id": "JOIN_FILTER",
        "summary": "Bloom filter pushdown from build side to probe-side TableScan",
        "implication": "77/99 TPC-DS queries show JoinFilter."
      },
      {
        "id": "COST_BASED_JOIN_ORDER",
        "summary": "Evaluates multiple join orders, selects lowest cost",
        "implication": "Usually correct. Do NOT force join order."
      },
      {
        "id": "QUALIFY_OPTIMIZATION",
        "summary": "Native window-function filtering, more efficient than nested subquery",
        "implication": "Gives optimizer full visibility into filter intent."
      }
    ],
    "gaps": [
      {
        "id": "CORRELATED_SUBQUERY_PARALYSIS",
        "priority": "HIGH",
        "goal": "DECORRELATE",
        "detect": "WHERE col > (SELECT agg(col) FROM fact WHERE key = outer.key). Correlated scalar subquery with AVG/SUM/COUNT that re-scans fact table per outer row.",
        "gates": "REQUIRED: correlated scalar subquery with aggregate function (AVG, SUM, COUNT). REQUIRED: inner query joins fact table. Works on any fact table.",
        "what": "Correlated scalar subqueries with aggregation re-execute per outer row \u2014 O(N*M) scans.",
        "why": "Snowflake cannot flatten correlated scalar subqueries that aggregate over a correlated key. Unlike simple EXISTS/IN, these require per-row evaluation.",
        "opportunity": "Decompose into CTEs: (1) dimension filter, (2) date-filtered fact rows, (3) per-key aggregate threshold via GROUP BY. JOIN threshold CTE in final query. If inner and outer scan SAME fact table with SAME filters, use shared-scan variant.",
        "frequency_pct": 100,
        "what_worked": "2/2 wins. inline_decorrelate 23.17x (69.4s\u21923.0s), shared_scan_decorrelate 7.82x (8.0s\u21921.0s). Both on SF10TCL MEDIUM warehouse, 3x3 validation.",
        "what_didnt_work": "None observed.",
        "field_notes": "Tested on catalog_sales and web_sales. The shared-scan variant applies when inner = outer table with overlapping filters."
      }
    ],
    "dialect": "snowflake"
  },
  "constraints": [
    {
      "id": "COMPLETE_OUTPUT",
      "severity": "CRITICAL",
      "description": "The rewritten query must output ALL columns from the original SELECT. Never drop, rename, or reorder output columns.",
      "constraint_rules": [
        {
          "rule": "ALL_COLUMNS_PRESENT",
          "description": "Every column in the original SELECT list must appear in the rewritten SELECT list."
        },
        {
          "rule": "NO_COLUMN_RENAME",
          "description": "Column aliases must be preserved exactly. If the original says 'AS total_sales', the rewrite must use the same alias."
        },
        {
          "rule": "PRESERVE_COLUMN_ORDER",
          "description": "Columns must appear in the same order as the original SELECT list."
        }
      ],
      "prompt_instruction": "The rewritten query must output ALL columns from the original SELECT. Never drop, rename, or reorder output columns. Every column alias must be preserved exactly as in the original."
    },
    {
      "id": "CTE_COLUMN_COMPLETENESS",
      "severity": "CRITICAL",
      "description": "When creating or modifying a CTE, its SELECT list MUST include ALL columns that downstream nodes reference. Check the Node Contracts and Downstream Usage sections before writing any CTE.",
      "failure_rate": "Caused 54% of all execution errors (7 of 13 failures)",
      "observed_failures": [
        {
          "query": "Q21",
          "error": "prefetched_inventory CTE omits i_item_id but main query references it in SELECT and GROUP BY",
          "type": "MISSING_COLUMN_IN_CTE"
        },
        {
          "query": "Q76",
          "error": "filtered_store_dates CTE omits d_year and d_qoy but aggregation CTE uses them in GROUP BY",
          "type": "MISSING_COLUMN_IN_CTE"
        },
        {
          "query": "Q24",
          "error": "filtered_base CTE omits s_state, i_current_price, i_manager_id, i_units, i_size needed by downstream CTEs",
          "type": "MISSING_COLUMN_IN_CTE"
        },
        {
          "query": "Q64",
          "error": "filtered_store_sales CTE omits ss_sold_date_sk needed for JOIN in cross_sales CTE",
          "type": "MISSING_COLUMN_IN_CTE"
        },
        {
          "query": "Q60",
          "error": "ss/ws/cs CTEs reference item.i_item_sk and item.i_category in WHERE but item table not joined in CTE",
          "type": "MISSING_TABLE_IN_CTE"
        },
        {
          "query": "Q13",
          "error": "filtered_store_sales CTE references hd_demo_sk, cd_demo_sk from tables not joined in the CTE",
          "type": "MISSING_TABLE_IN_CTE"
        },
        {
          "query": "Q2",
          "error": "Ambiguous d_date_sk and d_week_seq columns between CTE and re-joined date_dim",
          "type": "AMBIGUOUS_COLUMN_REF"
        }
      ],
      "constraint_rules": [
        {
          "rule": "CHECK_DOWNSTREAM_REFS",
          "description": "Before writing a CTE, check the Downstream Usage section. Every column listed in downstream_refs for that node MUST appear in the CTE's SELECT list."
        },
        {
          "rule": "CHECK_JOIN_COLUMNS",
          "description": "If a downstream node JOINs on a column from this CTE (e.g., ON cte.d_date_sk = ...), that column MUST be in the CTE's SELECT."
        },
        {
          "rule": "CHECK_TABLE_PRESENCE",
          "description": "If a CTE's WHERE clause references columns from a table, that table MUST be in the CTE's FROM/JOIN clause."
        }
      ],
      "prompt_instruction": "CRITICAL: When creating or modifying a CTE, its SELECT list MUST include ALL columns referenced by downstream queries. Check the Node Contracts section: every column in downstream_refs MUST appear in the CTE output. Also ensure: (1) JOIN columns used by consumers are included in SELECT, (2) every table referenced in WHERE is present in FROM/JOIN, (3) no ambiguous column names between the CTE and re-joined tables. Dropping a column that a downstream node needs will cause an execution error."
    },
    {
      "id": "LITERAL_PRESERVATION",
      "severity": "CRITICAL",
      "description": "All literal values (strings, numbers, dates) from the original query MUST be preserved EXACTLY in the rewrite",
      "failure_rate": "100% of Q2-Q16 failures were caused by hallucinated literals",
      "observed_failures": [
        {
          "query": "Q2",
          "original": "d_year = 2001, d_year = 2002",
          "hallucinated": "d_year = 1998, d_year = 1999",
          "type": "YEAR_HALLUCINATION"
        },
        {
          "query": "Q7",
          "original": "cd_gender = 'M', cd_marital_status = 'S', d_year = 2000",
          "hallucinated": "cd_gender = 'F', cd_marital_status = 'W', d_year = 2001",
          "type": "MULTIPLE_LITERAL_HALLUCINATION"
        },
        {
          "query": "Q10",
          "original": "d_year = 2002, ca_county IN ('Rush County', 'Toole County', 'Jefferson County', 'Dona Ana County', 'La Porte County')",
          "hallucinated": "d_year = 2001, ca_county IN ('Storey County', 'Marquette County', 'Warren County', 'Cochran County', 'Kandiyohi County')",
          "type": "YEAR_AND_STRING_HALLUCINATION"
        },
        {
          "query": "Q13",
          "original": "cd_marital_status = 'M', cd_education_status = 'Advanced Degree'",
          "hallucinated": "cd_marital_status = 'D', cd_education_status = 'Unknown'",
          "type": "STRING_HALLUCINATION"
        },
        {
          "query": "Q16",
          "original": "ca_state = 'GA', cc_county = 'Williamson County', d_date BETWEEN '2002-02-01' AND '2002-04-02'",
          "hallucinated": "ca_state = 'WV', cc_county IN ('Ziebach County', ...), d_date BETWEEN '2002-4-01' AND ...",
          "type": "STATE_COUNTY_DATE_HALLUCINATION"
        }
      ],
      "constraint_rules": [
        {
          "rule": "EXACT_STRING_MATCH",
          "description": "String literals in WHERE clauses must be copied character-for-character",
          "examples": [
            "'M' not 'F'",
            "'GA' not 'WV'",
            "'Rush County' not 'Storey County'"
          ]
        },
        {
          "rule": "EXACT_NUMBER_MATCH",
          "description": "Numeric literals (years, amounts, counts) must be copied exactly",
          "examples": [
            "2000 not 2001",
            "2002 not 2001",
            "100.00 not 150.00"
          ]
        },
        {
          "rule": "EXACT_DATE_MATCH",
          "description": "Date literals must be copied exactly, including format",
          "examples": [
            "'2002-02-01' not '2002-4-01'"
          ]
        },
        {
          "rule": "EXACT_LIST_MATCH",
          "description": "IN lists must contain the exact same values in the same order",
          "examples": [
            "IN ('TX', 'OH', 'TX') not IN ('SD', 'KS', 'MI')"
          ]
        }
      ],
      "prompt_instruction": "CRITICAL: When rewriting SQL, you MUST copy ALL literal values (strings, numbers, dates) EXACTLY from the original query. Do NOT invent, substitute, or 'improve' any filter values. If the original says d_year = 2000, your rewrite MUST say d_year = 2000. If the original says ca_state = 'GA', your rewrite MUST say ca_state = 'GA'. Changing these values will produce WRONG RESULTS and the rewrite will be REJECTED."
    },
    {
      "id": "SEMANTIC_EQUIVALENCE",
      "severity": "CRITICAL",
      "description": "The rewritten query MUST return exactly the same rows, columns, and ordering as the original. This is the prime directive.",
      "constraint_rules": [
        {
          "rule": "SAME_ROWS",
          "description": "The rewritten query must produce the same set of rows as the original. No rows may be added or removed."
        },
        {
          "rule": "SAME_COLUMNS",
          "description": "The rewritten query must return the same columns in the same order with the same names and data types."
        },
        {
          "rule": "SAME_ORDERING",
          "description": "If the original query has an ORDER BY clause, the rewritten query must preserve the same ordering."
        }
      ],
      "prompt_instruction": "The rewritten query MUST return exactly the same rows, columns, and ordering as the original. This is the prime directive. Any rewrite that changes the result set \u2014 even by one row, one column, or a different sort order \u2014 is WRONG and will be REJECTED."
    },
    {
      "id": "KEEP_EXISTS_AS_EXISTS",
      "severity": "HIGH",
      "overridable": true,
      "description": "Prefer preserving EXISTS/NOT EXISTS subqueries. Converting to IN/NOT IN risks NULL-handling changes; converting to JOINs risks duplicate rows.",
      "observed_failures": [
        {
          "problem": "Converting NOT EXISTS to NOT IN changes behavior when the subquery column contains NULLs. NOT IN with NULLs returns no rows.",
          "type": "NULL_SEMANTIC_CHANGE"
        },
        {
          "problem": "Converting EXISTS to JOIN can produce duplicate rows when the subquery matches multiple rows per outer row.",
          "type": "DUPLICATE_ROW_INTRODUCTION"
        }
      ],
      "constraint_rules": [
        {
          "rule": "AVOID_EXISTS_TO_IN",
          "description": "Avoid converting EXISTS/NOT EXISTS to IN/NOT IN unless the subquery column is provably NOT NULL (has a NOT NULL constraint or is a primary key)."
        },
        {
          "rule": "EXISTS_TO_JOIN_NEEDS_DISTINCT",
          "description": "Converting EXISTS to JOIN requires SELECT DISTINCT or GROUP BY to prevent row duplication when the subquery matches multiple rows per outer row."
        }
      ],
      "override_conditions": [
        "The subquery join column has a NOT NULL constraint or is a primary key (safe for IN conversion)",
        "The subquery returns at most 1 row per outer row (1:1 relationship, safe for JOIN)",
        "EXISTS is converted to JOIN + DISTINCT/GROUP BY to explicitly handle duplicates"
      ],
      "prompt_instruction": "DEFAULT: Preserve EXISTS/NOT EXISTS as-is. NOT EXISTS\u2192NOT IN breaks with NULLs; EXISTS\u2192JOIN can duplicate rows. HOWEVER: if the join column is NOT NULL (PK or explicit constraint), EXISTS\u2192IN is safe. If the subquery is 1:1 with the outer query, EXISTS\u2192JOIN is safe. The exploration worker MAY convert EXISTS with written proof of NULL safety or 1:1 cardinality."
    },
    {
      "id": "NO_CROSS_JOIN_DIMENSIONS",
      "severity": "HIGH",
      "overridable": true,
      "description": "Avoid CROSS JOINing dimension tables into a single CTE. The Cartesian product can explode row counts and prevent index use on fact tables.",
      "failure_rate": "Caused 0.0076x regression on Q080 (132x slower) when 3 dimensions were cross-joined",
      "observed_failures": [
        {
          "query": "Q080_multi",
          "regression": "0.0076x (57ms -> 7500ms)",
          "broken_rewrite": "filtered_dims AS (SELECT d_date_sk, i_item_sk, p_promo_sk FROM date_dim CROSS JOIN item CROSS JOIN promotion WHERE ...)",
          "problem": "CROSS JOIN created 120K-row CTE (30 \u00d7 200 \u00d7 20), then 3-key join prevented index use on fact tables.",
          "type": "CROSS_JOIN_DIMENSION_EXPLOSION"
        }
      ],
      "constraint_rules": [
        {
          "rule": "PREFER_SEPARATE_DIMENSION_CTES",
          "description": "Each dimension table should generally be its own CTE with its own filter. Combining via CROSS JOIN risks Cartesian explosion."
        }
      ],
      "override_conditions": [
        "Only 2 dimensions are joined (not 3+) AND the product is <1000 rows",
        "The dimensions share a foreign key (not a true Cartesian \u2014 it's a filtered JOIN)",
        "The combined CTE replaces N separate semi-joins with 1 multi-key join on the fact table"
      ],
      "prompt_instruction": "DEFAULT: Keep each dimension as a SEPARATE CTE (filtered_date, filtered_item, etc.). Cross-joining 3 dimensions caused 0.0076x on Q080 (30\u00d7200\u00d720 = 120K rows). HOWEVER: joining exactly 2 small dimensions (<1000 row product) via a foreign key (not Cartesian) may be acceptable if it reduces total join count on the fact table. The exploration worker MAY attempt a 2-dimension join with size estimate. Never cross-join 3+ dimensions."
    },
    {
      "id": "NO_MATERIALIZE_EXISTS",
      "severity": "HIGH",
      "overridable": true,
      "description": "Avoid converting EXISTS/NOT EXISTS subqueries into materialized CTEs with full table scans. EXISTS uses semi-join short-circuiting which is typically more efficient.",
      "failure_rate": "Caused 0.14x and 0.54x regressions (7x and 2x slowdowns)",
      "observed_failures": [
        {
          "query": "Q16",
          "regression": "0.14x (18ms -> 126ms)",
          "original": "EXISTS (SELECT * FROM catalog_sales cs2 WHERE cs1.cs_order_number = cs2.cs_order_number AND cs1.cs_warehouse_sk <> cs2.cs_warehouse_sk)",
          "broken_rewrite": "WITH multi_warehouse_orders AS (SELECT DISTINCT cs_order_number FROM catalog_sales GROUP BY cs_order_number HAVING MIN(cs_warehouse_sk) <> MAX(cs_warehouse_sk))",
          "type": "EXISTS_TO_FULL_SCAN_CTE"
        },
        {
          "query": "Q95",
          "regression": "0.54x (390ms -> 728ms)",
          "original": "EXISTS(SELECT 1 FROM ws_wh WHERE ws_wh.ws_order_number = ws1.ws_order_number)",
          "broken_rewrite": "WITH multi_warehouse_orders AS (SELECT DISTINCT ws_order_number FROM ws_wh)",
          "type": "EXISTS_TO_MATERIALIZED_DISTINCT"
        }
      ],
      "observed_successes": [
        {
          "query": "Q14",
          "speedup": "1.83x",
          "context": "intersect_to_exists: INTERSECT converted to EXISTS for semi-join short-circuit. Shows EXISTS restructuring CAN help when applied in the right direction."
        }
      ],
      "constraint_rules": [
        {
          "rule": "PREFER_EXISTS_SEMI_JOIN",
          "description": "EXISTS and NOT EXISTS use semi-join optimization that short-circuits after finding the first match. Converting to materialized CTEs usually forces a full scan."
        },
        {
          "rule": "AVOID_FULL_TABLE_DISTINCT_CTE",
          "description": "Avoid creating CTEs like SELECT DISTINCT key FROM large_table to replace EXISTS. The CTE scans the entire table; EXISTS can stop after one match."
        }
      ],
      "override_conditions": [
        "The EXISTS subquery is correlated and executed many times (optimizer fails to decorrelate it)",
        "The CTE would be small (<10K rows) and probed multiple times, amortizing materialization cost",
        "The EXISTS is inside a UNION ALL branch where each branch re-executes the same correlated subquery"
      ],
      "prompt_instruction": "DEFAULT: Keep EXISTS/NOT EXISTS as-is \u2014 semi-join short-circuiting is usually faster than materialization. Converting to CTEs caused 0.14x on Q16 and 0.54x on Q95. HOWEVER: if the correlated EXISTS is executed many times and the optimizer fails to decorrelate it, materializing into a small CTE (<10K rows) probed via JOIN may help. The exploration worker MAY attempt this with reasoning about correlation frequency and CTE size."
    },
    {
      "id": "NO_UNFILTERED_DIMENSION_CTE",
      "severity": "HIGH",
      "description": "Never create a 'filtered' dimension CTE that has no WHERE clause. A CTE that selects all rows from a dimension table is pure materialization overhead with zero filtering benefit.",
      "failure_rate": "Caused 0.85x regression on Q67",
      "observed_failures": [
        {
          "query": "Q67",
          "regression": "0.85x (4509ms -> 5291ms)",
          "broken_rewrite": "filtered_stores AS (SELECT s_store_sk, s_store_id FROM store), filtered_items AS (SELECT i_item_sk, i_category, i_class, i_brand, i_product_name FROM item)",
          "problem": "Both CTEs select ALL rows - no WHERE clause, no filtering. Pure overhead.",
          "type": "UNFILTERED_DIMENSION_CTE"
        }
      ],
      "constraint_rules": [
        {
          "rule": "CTE_MUST_FILTER",
          "description": "Every dimension CTE you create MUST have a WHERE clause that reduces the row count. If a dimension table has no filter to apply, do NOT extract it into a CTE."
        },
        {
          "rule": "COLUMN_PROJECTION_IS_NOT_FILTERING",
          "description": "Selecting a subset of columns (SELECT a, b FROM table) is NOT filtering. The CTE still materializes all rows. Only a WHERE clause reduces rows."
        }
      ],
      "prompt_instruction": "Every CTE you create must include a WHERE clause that actually reduces row count. Selecting fewer columns is not filtering \u2014 the CTE still materializes every row. If a dimension table has no predicate to push down, leave it as a direct join in the main query instead of wrapping it in a CTE."
    },
    {
      "id": "OR_TO_UNION_GUARD",
      "severity": "HIGH",
      "overridable": true,
      "description": "Guard rails for or_to_union: branches should have different access paths (not same column) and be limited to 3 or fewer.",
      "observed_failures": [
        {
          "query": "Q90",
          "regression": "0.59x (16ms -> 27ms)",
          "original": "WHERE t.t_hour BETWEEN 10 AND 11 OR t.t_hour BETWEEN 16 AND 17",
          "broken_rewrite": "UNION ALL of two separate web_sales scans (one for AM hours, one for PM hours)",
          "problem": "Doubles the fact table scan. The OR on t_hour is trivial for the optimizer - it just checks two ranges on one column.",
          "type": "UNION_SAME_COLUMN_OR"
        },
        {
          "query": "Q13",
          "regression": "0.23x",
          "problem": "9 UNION branches from nested OR expansion (3 conditions x 3 values) caused 9x fact table scans.",
          "type": "UNION_BRANCH_EXPLOSION"
        },
        {
          "query": "Q48",
          "regression": "0.41x",
          "problem": "9 UNION branches from nested OR expansion caused severe regression from multiplied fact table scans.",
          "type": "UNION_BRANCH_EXPLOSION"
        }
      ],
      "observed_successes": [
        {
          "query": "Q88",
          "speedup": "6.28x",
          "context": "8 time-bucket subqueries on store_sales, each filtering distinct hour ranges via different WHERE clauses. Branches access genuinely different row subsets."
        },
        {
          "query": "Q10",
          "speedup": "1.49x",
          "context": "OR across different dimension table lookups creating distinct access paths."
        },
        {
          "query": "Q45",
          "speedup": "1.35x",
          "context": "OR conditions reference different tables/subqueries."
        }
      ],
      "constraint_rules": [
        {
          "rule": "OR_TO_UNION_REQUIRES_DIFFERENT_PATHS",
          "description": "or_to_union is most beneficial when OR conditions create fundamentally different access paths (e.g., across different tables or between a correlated subquery and a direct filter). Same-column ORs on trivial ranges are usually handled efficiently by the optimizer as a single scan."
        },
        {
          "rule": "OR_TO_UNION_PREFER_3_OR_FEWER",
          "description": "Prefer 3 or fewer UNION ALL branches. Nested ORs that expand into 9+ combinations are almost always harmful. 4-5 branches may be acceptable if each accesses genuinely different row subsets."
        }
      ],
      "override_conditions": [
        "Branches access genuinely different row subsets (different WHERE predicates, not just same-column ranges)",
        "Total branch count stays at 4-5 or fewer (not Cartesian expansion of nested ORs)",
        "EXPLAIN shows the fact table is already scanned N times in baseline, so splitting does not increase scan count",
        "Each branch filters to <20% of fact table rows (high selectivity per branch)"
      ],
      "prompt_instruction": "DEFAULT: Prefer 3 or fewer UNION ALL branches with different access paths per branch. Same-column ORs on simple ranges are usually handled efficiently by the optimizer. Nested ORs that expand into 4+ branches (e.g., 3 x 3 = 9 combinations) caused 0.23x-0.41x regressions. HOWEVER: or_to_union achieved 6.28x on Q88 where branches had genuinely different row subsets. The exploration worker MAY try 4-5 branches if each branch has distinct access paths and high selectivity. Provide reasoning."
    },
    {
      "id": "OR_TO_UNION_SELF_JOIN",
      "severity": "HIGH",
      "overridable": true,
      "description": "Avoid or_to_union on queries with self-joins. Splitting OR conditions on self-joined tables can create multiple independent scans that cannot share the self-join optimization.",
      "observed_failures": [
        {
          "query": "Q23",
          "regression": "0.51x",
          "problem": "Self-join on store_sales was split into separate UNION branches, each requiring its own full self-join, doubling execution time.",
          "type": "SELF_JOIN_SPLIT"
        }
      ],
      "constraint_rules": [
        {
          "rule": "AVOID_OR_TO_UNION_ON_SELF_JOINS",
          "description": "If a query contains a self-join (same table aliased twice), or_to_union is risky because the self-join must typically remain in a single query block to share the scan."
        }
      ],
      "override_conditions": [
        "The OR conditions are on a column NOT involved in the self-join predicate",
        "The self-join aliases have independent WHERE filters that make each branch selective",
        "EXPLAIN shows the self-join is already executed multiple times in baseline"
      ],
      "prompt_instruction": "DEFAULT: Avoid or_to_union when the query contains a self-join (same table with different aliases). Splitting forces each branch to independently perform the self-join (observed 0.51x on Q23). HOWEVER: if the OR conditions target a column not involved in the self-join predicate, or if each alias already has independent selective filters, splitting may still help. The exploration worker MAY attempt this with written reasoning about why the structural context differs from Q23."
    },
    {
      "id": "REMOVE_REPLACED_CTES",
      "severity": "HIGH",
      "description": "When creating replacement CTEs, always remove the original CTEs from the WITH clause. Leaving dead/unused CTEs causes unnecessary materialization overhead.",
      "failure_rate": "Contributed to 0.49x and 0.68x regressions",
      "observed_failures": [
        {
          "query": "Q31",
          "regression": "0.49x (99ms -> 201ms)",
          "problem": "Created new store_sales_agg and web_sales_agg CTEs but left the original ss and ws CTEs in the WITH clause. Both old and new CTEs coexist, wasting materialization.",
          "type": "DEAD_CTE_OVERHEAD"
        },
        {
          "query": "Q74",
          "regression": "0.68x (493ms -> 724ms)",
          "problem": "Created 4 new year-specific CTEs but left the original year_total, year_total_store, year_total_web CTEs. Total of 8 CTEs instead of 4.",
          "type": "DEAD_CTE_OVERHEAD"
        }
      ],
      "constraint_rules": [
        {
          "rule": "REPLACE_NOT_APPEND",
          "description": "When your rewrite replaces a CTE with a new version, the original CTE node must be removed or overwritten. Do not define both the old and new CTE."
        }
      ],
      "prompt_instruction": "When creating replacement CTEs, overwrite the original by using the same node_id in your rewrite_sets, or ensure the original is removed from the WITH clause. Every CTE in the final query should be actively used \u2014 dead CTEs still get materialized and waste resources (caused 0.49x on Q31, 0.68x on Q74)."
    },
    {
      "id": "UNION_CTE_SPLIT_MUST_REPLACE",
      "severity": "HIGH",
      "description": "When splitting a UNION into separate CTEs, the original UNION must be eliminated. Creating CTEs that duplicate the UNION branches while keeping the original UNION doubles the work.",
      "observed_failures": [
        {
          "query": "multiple",
          "problem": "UNION branches were extracted into CTEs but the original UNION ALL remained in the main query, causing each branch to be computed twice.",
          "type": "DUPLICATE_UNION"
        }
      ],
      "constraint_rules": [
        {
          "rule": "CTE_SPLIT_REPLACES_UNION",
          "description": "When applying union_cte_split, the final query must reference the CTEs instead of the original UNION. The total number of UNION ALL operations should not increase."
        }
      ],
      "prompt_instruction": "When applying union_cte_split (splitting UNION into CTEs), the original UNION must be eliminated from the main query. The main query should reference the split CTEs, not duplicate the UNION branches. If the rewritten query has more UNION ALL operations than the original, the rewrite is incorrect."
    },
    {
      "id": "DECORRELATE_MUST_FILTER_FIRST",
      "severity": "MEDIUM",
      "description": "When decorrelating a subquery into a JOIN, the replacement JOIN must include a selective filter. A decorrelation that produces an unfiltered cross-product is worse than the original correlated subquery.",
      "observed_failures": [
        {
          "query": "multiple",
          "problem": "Correlated subquery was converted to JOIN without carrying over the original WHERE filters, producing a much larger intermediate result than the correlated version.",
          "type": "UNFILTERED_DECORRELATION"
        }
      ],
      "constraint_rules": [
        {
          "rule": "DECORRELATE_PRESERVES_FILTERS",
          "description": "When converting a correlated subquery to a JOIN + GROUP BY CTE, all WHERE conditions from the original subquery must be preserved in the CTE or JOIN condition. The replacement must not produce more rows than the original correlated subquery."
        }
      ],
      "prompt_instruction": "When decorrelating a correlated subquery into a JOIN, ensure all original WHERE filters are preserved in the replacement CTE or JOIN condition. A decorrelation without selective filters creates a cross-product that is larger than the original per-row correlated execution. The replacement CTE must filter to at most the same cardinality as the original subquery."
    },
    {
      "id": "DIMENSION_CTE_SAME_COLUMN_OR",
      "severity": "MEDIUM",
      "description": "Do not extract dimension CTE filters when the WHERE clause has OR conditions on the same column. Same-column ORs are efficiently handled by the optimizer in a single scan; CTE extraction adds overhead without benefit.",
      "observed_failures": [
        {
          "query": "Q37",
          "regression": "0.89x",
          "problem": "OR conditions on item.i_current_price ranges were extracted into separate CTEs, adding CTE materialization overhead without improving selectivity.",
          "type": "SAME_COLUMN_OR_CTE"
        }
      ],
      "constraint_rules": [
        {
          "rule": "KEEP_SAME_COLUMN_OR_INLINE",
          "description": "When OR conditions filter the same column (e.g., i_current_price BETWEEN X AND Y OR i_current_price BETWEEN A AND B), keep them inline in WHERE. Only extract dimension CTEs when filters span different columns or tables."
        }
      ],
      "prompt_instruction": "Do not create dimension CTEs to isolate OR conditions that filter the same column. The optimizer handles same-column ORs efficiently in a single scan. Only apply dimension_cte_isolate when filters span different columns or different dimension tables."
    },
    {
      "id": "EARLY_FILTER_CTE_BEFORE_CHAIN",
      "severity": "MEDIUM",
      "description": "Early filter CTEs must be referenced by the main query chain. An orphaned CTE that pre-filters data but is never joined back into the main query wastes materialization effort.",
      "observed_failures": [
        {
          "query": "multiple",
          "problem": "Early filter CTEs were created but not referenced in subsequent JOINs, resulting in wasted CTE materialization plus the original unfiltered joins remaining.",
          "type": "ORPHANED_FILTER_CTE"
        }
      ],
      "constraint_rules": [
        {
          "rule": "FILTER_CTE_MUST_BE_REFERENCED",
          "description": "Every early_filter CTE must be referenced by at least one downstream CTE or the main query. If a filter CTE is created, the original unfiltered table reference must be replaced with the CTE reference."
        }
      ],
      "prompt_instruction": "When creating an early_filter CTE, ensure it is actually referenced in the main query chain. The original unfiltered table reference must be replaced with the CTE reference. Do not create CTEs that filter a table if the main query still joins the original unfiltered table \u2014 this adds overhead without benefit."
    },
    {
      "id": "EXPLICIT_JOINS",
      "severity": "MEDIUM",
      "description": "Convert comma-separated implicit joins to explicit JOIN ... ON syntax. This gives the optimizer better join-order freedom.",
      "constraint_rules": [
        {
          "rule": "PREFER_EXPLICIT_JOIN",
          "description": "When the original query uses comma-separated tables with WHERE conditions for joining, convert to explicit JOIN ... ON syntax."
        }
      ],
      "prompt_instruction": "Convert comma-separated implicit joins to explicit JOIN ... ON syntax. This gives the optimizer better join-order freedom."
    },
    {
      "id": "MIN_BASELINE_THRESHOLD",
      "severity": "MEDIUM",
      "overridable": true,
      "description": "Be conservative with CTE-based transforms on queries with very short baseline runtimes. CTE materialization overhead can dominate when the query is already fast.",
      "failure_rate": "Caused 0.14x-0.59x regressions on queries under 50ms",
      "observed_failures": [
        {
          "query": "Q25",
          "regression": "0.50x (31ms -> 62ms)",
          "baseline_ms": 31,
          "transform": "prefetch_fact_join with 6 CTEs",
          "type": "CTE_OVERHEAD_ON_FAST_QUERY"
        },
        {
          "query": "Q90",
          "regression": "0.59x (16ms -> 27ms)",
          "baseline_ms": 16,
          "transform": "multi_dimension_prefetch with 4 CTEs + UNION ALL",
          "type": "CTE_OVERHEAD_ON_FAST_QUERY"
        },
        {
          "query": "Q16",
          "regression": "0.14x (18ms -> 126ms)",
          "baseline_ms": 18,
          "transform": "materialize_cte with 2 full-scan CTEs",
          "type": "CTE_OVERHEAD_ON_FAST_QUERY"
        }
      ],
      "constraint_rules": [
        {
          "rule": "CHECK_BASELINE_RUNTIME",
          "description": "If the Execution Plan shows estimated or actual runtime under 50ms, prefer minimal rewrites. DuckDB already optimizes simple star-join patterns efficiently."
        }
      ],
      "override_conditions": [
        "The transform reduces scan count (e.g., 3 scans \u2192 1 scan) even on a fast query",
        "The query is a component of a larger pipeline where cumulative savings matter",
        "The transform simplifies the query structure without adding CTEs (e.g., pushdown, decorrelate)"
      ],
      "prompt_instruction": "DEFAULT: If baseline is under 100ms, prefer minimal rewrites. CTE materialization overhead (hash tables, intermediate storage) can exceed filtering benefit on fast queries. HOWEVER: transforms that reduce scan count without adding CTEs (pushdown, decorrelate) may still help. The exploration worker MAY attempt structural changes on fast queries if the transform is scan-reducing, not CTE-adding."
    },
    {
      "id": "PREFETCH_MULTI_FACT_CHAIN",
      "severity": "MEDIUM",
      "overridable": true,
      "description": "Prefer limiting cascading fact-table CTEs to 2. Each additional CTE materializes a large intermediate result.",
      "observed_failures": [
        {
          "query": "Q4",
          "regression": "0.78x",
          "problem": "3 cascading fact-table CTEs (store_sales -> catalog_sales -> web_sales) created excessive intermediate materialization.",
          "type": "FACT_CHAIN_OVERHEAD"
        }
      ],
      "constraint_rules": [
        {
          "rule": "PREFER_2_OR_FEWER_FACT_CTES",
          "description": "When pre-joining fact tables with filtered dimensions in CTEs, 2 cascading fact CTEs is safe. A third adds risk of excessive materialization."
        }
      ],
      "override_conditions": [
        "Each fact CTE has highly selective filters (<5% of rows survive), keeping intermediate sizes small",
        "The 3rd CTE reads from a dimension-filtered result, not a raw fact table",
        "The query already has 3+ separate fact table scans in baseline \u2014 chaining cannot be worse"
      ],
      "prompt_instruction": "DEFAULT: Limit to 2 cascading fact-table CTEs. A 3rd CTE caused 0.78x on Q4 from excessive materialization. HOWEVER: if each CTE applies highly selective filters (<5% row survival), the intermediate results stay small. The exploration worker MAY try a 3-CTE chain if filters are selective and baseline already has 3+ separate scans."
    },
    {
      "id": "SINGLE_PASS_AGGREGATION_LIMIT",
      "severity": "MEDIUM",
      "overridable": true,
      "description": "Prefer limiting single-pass aggregation to 8 CASE branches. Beyond 8, CASE evaluation overhead may reduce benefit.",
      "observed_failures": [
        {
          "query": "Q88",
          "note": "8 CASE branches (time slices) was the maximum tested that still showed improvement (6.28x). More branches are untested, not proven harmful.",
          "type": "CASE_BRANCH_LIMIT"
        }
      ],
      "observed_successes": [
        {
          "query": "Q88",
          "speedup": "6.28x",
          "context": "8 CASE branches consolidating 8 separate time-bucket subqueries into a single scan."
        },
        {
          "query": "Q9",
          "speedup": "4.47x",
          "context": "5 CASE branches consolidating repeated store_sales scans."
        }
      ],
      "constraint_rules": [
        {
          "rule": "PREFER_8_OR_FEWER_CASE_BRANCHES",
          "description": "When consolidating repeated scans into CASE WHEN aggregates, 8 or fewer branches is well-tested. More branches are untested territory."
        }
      ],
      "override_conditions": [
        "The original query has 9-12 repeated scans on the same fact table (high consolidation value)",
        "Each CASE branch is a simple equality check (low per-row overhead)",
        "The fact table is large (>1M rows) so scan reduction dominates CASE evaluation cost"
      ],
      "prompt_instruction": "DEFAULT: Use at most 8 CASE branches for single_pass_aggregation (tested up to 8 at 6.28x on Q88). HOWEVER: 9-12 branches with simple equality checks on large fact tables may still net positive. The exploration worker MAY try 9-12 branches if the scan reduction value is high. Beyond 12 branches is not recommended."
    }
  ],
  "regression_warnings": [],
  "strategy_leaderboard": null,
  "query_archetype": null,
  "resource_envelope": null,
  "exploit_algorithm_text": "# Snowflake Rewrite Playbook\n# TPC-DS SF10TCL empirical evidence | X-Small warehouse\n\n## ENGINE STRENGTHS \u2014 do NOT rewrite these patterns\n\n1. **Micro-partition pruning**: Filters on clustered columns skip micro-partitions. DO NOT wrap filter columns in functions (kills pruning).\n2. **Column pruning through CTEs**: Reads only columns referenced by final query. Automatic.\n3. **Predicate pushdown**: Filters pushed to storage layer, including through single-ref CTEs. Also does predicate MIRRORING across join sides. DO NOT manually duplicate filters already applied to the same table. NOTE: Does NOT push date_sk ranges through UNION ALL CTEs or across comma joins to fact tables \u2014 see P4.\n4. **Correlated subquery decorrelation (simple)**: Transforms simple correlated subqueries into hash joins. DOES NOT handle correlated scalar subqueries with aggregation (see P3). Check EXPLAIN for nested loop before manual decorrelation of simple EXISTS/IN patterns.\n5. **EXISTS/NOT EXISTS semi-join**: Early termination. SemiJoin node in plan. NEVER materialize EXISTS into CTEs.\n6. **Join filtering (bloom filters)**: JoinFilter nodes push bloom filters from build side to probe-side TableScan. 77/99 TPC-DS queries show JoinFilter. DO NOT restructure joins that already have JoinFilter.\n7. **Cost-based join ordering**: Usually correct. DO NOT force join order unless evidence of a flipped join.\n8. **QUALIFY clause**: Native window-function filtering, more efficient than subquery.\n\n## GLOBAL GUARDS\n\n1. EXISTS/NOT EXISTS \u2192 never materialize into CTEs (kills SemiJoin early termination).\n2. UNION ALL \u2192 limit to \u22643 branches (each = separate scan pipeline).\n3. CTEs referenced once \u2192 inline. CTEs referenced 2+ times \u2192 keep.\n4. Do NOT restructure joins that have JoinFilter.\n5. Do NOT wrap filter columns in functions \u2192 prevents micro-partition pruning.\n6. NOT IN \u2192 NOT EXISTS for NULL safety.\n7. Baseline < 100ms \u2192 skip structural rewrites.\n\n---\n\n## DOCUMENTED CASES\n\n**P3: Correlated Scalar Subquery with Aggregation** (DECORRELATE) \u2014 100% success (2/2)\n\n| Aspect | Detail |\n|---|---|\n| Detect | WHERE col > (SELECT agg(col) FROM fact WHERE key = outer.key). Correlated scalar subquery with AVG/SUM/COUNT that re-scans the same or different fact table per outer row. |\n| Gates | REQUIRED: correlated scalar subquery with aggregate function. REQUIRED: inner query joins fact table. Works on any fact table (catalog_sales, web_sales, store_sales). |\n| Treatments | Decompose into CTEs: (1) dimension filter, (2) date-filtered fact rows, (3) per-key aggregate threshold via GROUP BY. Final query JOINs threshold CTE. If inner and outer scan the SAME fact table with SAME filters, use shared-scan variant (single CTE for both). |\n| Failures | None observed. |\n\nEvidence table \u2014 wins (MEDIUM warehouse, 3x3 validation):\n\n| Example | Orig_ms | Opt_ms | Speedup | Pattern |\n|---------|---------|--------|---------|---------|\n| inline_decorrelate | 69,415 | 2,996 | 23.17x | 3 CTEs: dim filter + date-filtered fact + per-key threshold |\n| shared_scan_decorrelate | 8,025 | 1,026 | 7.82x | Shared-scan variant: common fact CTE reused for threshold + outer rows |\n\n---\n\n**P4: Predicate Transitivity Failure \u2014 SK Range Pushdown** (SK_PUSHDOWN) \u2014 100% success (2/2)\n\n| Aspect | Detail |\n|---|---|\n| Detect | Fact table(s) joined to date_dim via comma join. Date filter on date_dim columns (d_year, d_moy, d_quarter_name) but NO explicit sold_date_sk range on the fact table. EXPLAIN shows full or near-full partition scan on fact table(s). Especially impactful through UNION ALL CTEs. |\n| Gates | REQUIRED: date filter exists on date_dim. REQUIRED: fact table joined via sold_date_sk = d_date_sk (comma or explicit). REQUIRED: fact table partition scan ratio > 50%. Does NOT help if query is compute-bound (e.g. ROLLUP). |\n| Treatments | (1) Look up date_sk range: SELECT MIN(d_date_sk), MAX(d_date_sk) FROM date_dim WHERE <date_filter>. (2) Add explicit sold_date_sk BETWEEN <min> AND <max> on each fact table. (3) Convert comma joins to explicit JOINs. For UNION ALL CTEs: push the BETWEEN inside each branch. |\n| Failures | Q17 NEUTRAL (0.97x) \u2014 Snowflake already optimizes after warmup when SK ranges are wide (274 values). Q67 TIMEOUT \u2014 ROLLUP over 8 columns is compute-bound, not I/O-bound. |\n\nEvidence table \u2014 wins (X-Small warehouse, 5x trimmed mean):\n\n| Example | Orig_ms | Opt_ms | Speedup | Pattern |\n|---------|---------|--------|---------|---------|\n| sk_pushdown_union_all (Q2) | 229,847 | 107,982 | 2.13x | BETWEEN pushed into UNION ALL branches (web_sales + catalog_sales) |\n| sk_pushdown_3fact (Q56) | 10,234 | 8,730 | 1.17x | BETWEEN on 3 fact tables (store_sales + catalog_sales + web_sales) |\n\n---\n\n## PRUNING GUIDE\n\n| Plan shows | Skip |\n|---|---|\n| No correlated scalar subquery with aggregate | P3 (decorrelation) |\n| Simple EXISTS/IN correlation (no aggregate) | P3 (Snowflake handles these natively) |\n| No date_dim join or no date filter | P4 (SK pushdown) |\n| Fact table partition scan < 50% | P4 (already pruning well) |\n| Query is compute-bound (ROLLUP, massive GROUP BY) | P4 (SK pushdown won't help) |\n| Baseline < 100ms | ALL structural rewrites |\n\n## REGRESSION REGISTRY\n\nNo regressions observed.\n\nNeutrals (not regressions, but no win):\n- Q17 P4 SK pushdown: 0.97x \u2014 wide date range (274 values), Snowflake handles after warmup\n- Q67 P4 SK pushdown: both timeout \u2014 ROLLUP over 8 columns is compute-bound\n",
  "detected_transforms": "[TransformMatch(id='sf_sk_pushdown_multi_fact', overlap_ratio=1.0, matched_features=['DATE_DIM', 'MULTI_TABLE_5+'], missing_features=[], total_required=2, gap='PREDICATE_TRANSITIVITY_FAILURE', engines=['snowflake'], contraindications=[]), TransformMatch(id='sf_inline_decorrelate', overlap_ratio=0.5, matched_features=['AGG_AVG', 'DATE_DIM'], missing_features=['CORRELATED_SUB', 'SCALAR_AGG_SUB'], total_required=4, gap='CORRELATED_SUBQUERY_PARALYSIS', engines=['snowflake'], contraindications=[]), TransformMatch(id='sf_shared_scan_decorrelate', overlap_ratio=0.5, matched_features=['AGG_AVG', 'CTE'], missing_features=['CORRELATED_SUB', 'SCALAR_AGG_SUB_CTE'], total_required=4, gap='CORRELATED_SUBQUERY_PARALYSIS', engines=['snowflake'], contraindications=[]), TransformMatch(id='sf_sk_pushdown_union_all', overlap_ratio=0.3333333333333333, matched_features=['DATE_DIM'], missing_features=['MULTI_CHANNEL', 'UNION'], total_required=3, gap='PREDICATE_TRANSITIVITY_FAILURE', engines=['snowflake'], contraindications=[])]",
  "qerror_analysis": "QErrorAnalysis(signals=[], max_q_error=1.0, severity='ACCURATE', direction='ACCURATE', locus='PROJECTION', magnitude='MINOR', structural_flags=['ESTIMATE_ONLY'], pathology_candidates=[])"
}