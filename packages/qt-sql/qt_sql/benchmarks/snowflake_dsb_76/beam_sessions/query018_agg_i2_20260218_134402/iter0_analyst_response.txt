{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The fact table scan dominates runtime (920 GB) without a direct date key range filter, despite a selective date_dim join. Multiple aggregate nodes process millions of rows after joins, suggesting opportunity for early aggregation and predicate pushdown.",
    "reasoning_trace": [
      "Fact table CATALOG_SALES scan reads 920 GB (parts=54721/54922) without a direct cs_sold_date_sk range filter.",
      "Date dimension is filtered by d_year=1999 and joined on sold_date_sk, but plan does not show range pushdown into fact scan.",
      "Aggregate nodes show nested aggregation (multiple levels) after joins, indicating late reduction.",
      "Dimension tables are already small (parts=1 or 2) and fully pruned."
    ],
    "cost_spine": ["TableScan (CATALOG_SALES)", "InnerJoin (DATE_DIM)", "Aggregate (multiple levels)", "GroupingSets", "SortWithLimit"],
    "hotspots": [
      {
        "op": "TableScan (CATALOG_SALES)",
        "why": "largest I/O volume (920 GB) without date key range pushdown",
        "evidence": "parts=54721/54922 bytes=920184101376"
      },
      {
        "op": "Aggregate (multiple levels)",
        "why": "late aggregation after joins amplifies row processing",
        "evidence": "nested aggregate nodes (1.3, 1.4, 1.9, 1.14, 1.19) after joins"
      }
    ],
    "do_not_do": [
      "avoid materializing EXISTS (none present)",
      "avoid same-column OR to UNION ALL (no OR predicate)",
      "avoid unfiltered large CTEs"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "target": "Add cs_sold_date_sk BETWEEN derived min and max from date_dim filter (d_year=1999) to the fact table scan predicate list.",
      "dag_target_hint": "Modify TableScan (CATALOG_SALES) filter to include date key range.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim"],
        "where_must_preserve": ["d_year = 1999", "cs_wholesale_cost BETWEEN 5 AND 10"],
        "output_must_preserve": ["all original columns and join semantics"]
      },
      "gates_checked": ["G_SF_SK_DATE_FILTER_REQUIRED:PASS", "G_SF_SK_SCAN_PRESSURE:PASS", "G_SF_SK_COMPUTE_BOUND_SKIP:PASS", "G_SF_SK_RANGE_SEMANTICS:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.8,
      "expected_explain_delta": "Fact table scan shows reduced partitions and bytes scanned due to date key range filter.",
      "recommended_patch_ops": ["add_predicate_to_fact_scan"],
      "recommended_examples": ["sf_sk_pushdown_union_all"],
      "rank_rationale": "Targets primary hotspot with direct evidence of missing date range pushdown.",
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p02",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate catalog_sales by cs_item_sk and cs_bill_customer_sk (and other join keys) before joining with dimensions, adjusting AVG aggregates to SUM/COUNT.",
      "dag_target_hint": "Insert a CTE aggregating catalog_sales by join keys, then join with dimensions and compute final ROLLUP.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "item", "customer"],
        "where_must_preserve": ["i_category = 'Music'", "c_birth_month = 12"],
        "output_must_preserve": ["grouping keys compatibility with ROLLUP", "AVG semantics via SUM/COUNT"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:AVG handled via SUM/COUNT"],
      "exploration": true,
      "exploration_hypothesis": "Pre-aggregating fact table by join keys may reduce rows before joining with dimensions, but the ROLLUP on dimension columns requires careful handling.",
      "confidence": 0.5,
      "expected_explain_delta": "Fact table scan replaced by pre-aggregated CTE; subsequent joins and aggregates have fewer rows.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "recommended_examples": ["aggregate_pushdown"],
      "rank_rationale": "Exploration targeting secondary hotspot (aggregate amplification) with plausible impact.",
      "gold_example_id": "aggregate_pushdown"
    },
    {
      "probe_id": "p03",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Pre-filter each dimension table (date_dim, item, customer_demographics, customer, customer_address) into CTEs returning only surrogate keys and needed columns.",
      "dag_target_hint": "Replace each dimension table in FROM clause with a CTE that pre-filters.",
      "node_contract": {
        "from_must_include": ["date_dim", "item", "customer_demographics", "customer", "customer_address"],
        "where_must_preserve": ["d_year=1999", "i_category='Music'", "cd_gender='F' AND cd_education_status='4 yr Degree'", "c_birth_month=12", "ca_state IN ('AR','IN','VA')"],
        "output_must_preserve": ["all join keys and dimension columns for grouping"]
      },
      "gates_checked": ["cross_cte_predicate_blindness:PASS", "unfiltered_cte:AVOID"],
      "exploration": true,
      "exploration_hypothesis": "Isolating dimension filters into CTEs may help optimizer build better hash tables and improve join order, though dimensions are already small.",
      "confidence": 0.4,
      "expected_explain_delta": "Dimension scans become CTE scans; fact table join may benefit from smaller build sides.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "recommended_examples": ["multi_dimension_prefetch"],
      "rank_rationale": "Exploration targeting dimension tables (already small) with low expected impact but safe.",
      "gold_example_id": "multi_dimension_prefetch"
    },
    {
      "probe_id": "p04",
      "transform_id": "inner_join_conversion",
      "family": "F",
      "target": "Convert comma-separated joins to explicit INNER JOIN syntax with ON clauses.",
      "dag_target_hint": "Change FROM clause to use explicit JOIN ... ON for all tables.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "customer_demographics", "customer", "customer_address", "date_dim", "item"],
        "where_must_preserve": ["all original join conditions and filters"],
        "output_must_preserve": ["all original output columns and aliases"]
      },
      "gates_checked": ["join_multiplicity_safe:PASS", "left_join_filter_order_rigidity:NOT_APPLICABLE"],
      "exploration": true,
      "exploration_hypothesis": "Explicit JOIN syntax might provide better hints to the optimizer for join order, though Snowflake's cost-based join order is robust.",
      "confidence": 0.3,
      "expected_explain_delta": "Plan shape may change in join order, but result is equivalent.",
      "recommended_patch_ops": ["replace_from"],
      "recommended_examples": ["inner_join_conversion"],
      "rank_rationale": "Exploration with low expected impact, but safe and easy to apply.",
      "gold_example_id": "inner_join_conversion"
    }
  ],
  "dropped": [
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated subquery pattern in plan evidence."
    },
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan evidence."
    },
    {
      "transform_id": "materialize_cte",
      "family": "E",
      "reason": "No repeated scans or subtrees in plan evidence."
    },
    {
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "reason": "No correlated scalar aggregate subquery pattern in SQL."
    }
  ]
}