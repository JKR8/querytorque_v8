{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 2,
    "probe_count": 6,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The plan exhibits repeated scans of large fact tables (catalog_sales, web_sales, store_sales) without early filtering, and UNION ALL branches lack partition-pruning predicates. Predicate transitivity failure prevents date_sk filters from pushing into fact scans, causing excessive scan volume. Early filtering and decorrelation strategies can reduce data flow before expensive joins and aggregations.",
    "reasoning_trace": [
      "Multiple large fact table scans (CATALOG_SALES, WEB_SALES, STORE_SALES) dominate the plan with no apparent partition pruning.",
      "UNION ALL branches lack explicit date_sk range filters, missing micro-partition pruning opportunities.",
      "Repeated dimension table scans (DATE_DIM, ITEM, CUSTOMER) suggest potential for early filtering and reuse.",
      "Nested aggregation layers indicate late-row reduction, increasing memory and compute pressure."
    ],
    "cost_spine": [
      "UnionAll",
      "TableScan (CATALOG_SALES)",
      "TableScan (WEB_SALES)",
      "InnerJoin",
      "Aggregate",
      "Aggregate"
    ],
    "hotspots": [
      {
        "op": "TableScan (CATALOG_SALES)",
        "why": "large fact table scanned without partition pruning",
        "evidence": "parts=54721/54922 bytes=920184101376"
      },
      {
        "op": "TableScan (WEB_SALES)",
        "why": "large fact table scanned without partition pruning",
        "evidence": "parts=27574/27579 bytes=460956759040"
      },
      {
        "op": "UnionAll",
        "why": "UNION ALL branches lack date_sk BETWEEN pushdown for pruning",
        "evidence": "scans two large fact tables without partition-key filtering"
      },
      {
        "op": "Aggregate",
        "why": "late-row reduction after wide join",
        "evidence": "multiple aggregation layers on large intermediate results"
      }
    ],
    "do_not_do": [
      "avoid unfiltered large CTE introduction",
      "avoid materializing simple EXISTS paths already optimized as semi-join",
      "do not wrap partition/filter keys in functions when pruning matters"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "target": "Push explicit date_sk BETWEEN predicates into each UNION ALL branch to enable micro-partition pruning on CATALOG_SALES and WEB_SALES.",
      "dag_target_hint": "Modify the cs_or_ws_sales CTE to add date_sk range filters in each branch.",
      "node_contract": {
        "from_must_include": [
          "catalog_sales",
          "web_sales",
          "date_dim"
        ],
        "where_must_preserve": [
          "d_moy = 1",
          "d_year = 1998"
        ],
        "output_must_preserve": [
          "sold_date_sk",
          "customer_sk",
          "item_sk",
          "wholesale_cost"
        ]
      },
      "gates_checked": [
        "G_SF_SK_DATE_FILTER_REQUIRED:PASS",
        "G_SF_SK_SCAN_PRESSURE:PASS",
        "G_SF_SK_RANGE_SEMANTICS:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.92,
      "expected_explain_delta": "Each fact table scan (CATALOG_SALES, WEB_SALES) gains partition-key filtering, reducing scanned bytes significantly.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from",
        "replace_where_predicate"
      ],
      "recommended_examples": [
        "sf_sk_pushdown_union_all"
      ],
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p02",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Pre-filter ITEM and DATE_DIM into dedicated CTEs to reduce join input size and enable reuse.",
      "dag_target_hint": "Create dedicated CTEs for filtered ITEM and DATE_DIM before joining with fact tables.",
      "node_contract": {
        "from_must_include": [
          "item",
          "date_dim"
        ],
        "where_must_preserve": [
          "i_category = 'Electronics'",
          "i_class = 'personal'",
          "d_moy = 1",
          "d_year = 1998"
        ],
        "output_must_preserve": [
          "i_item_sk",
          "d_date_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS",
        "multiplicity_guard_required:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Dimension tables ITEM and DATE_DIM are scanned once and reused, reducing redundant work in join paths.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "dimension_cte_isolate"
      ]
    },
    {
      "probe_id": "p03",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate STORE_SALES by customer key before joining with customer dimensions to reduce row volume.",
      "dag_target_hint": "Modify my_revenue CTE to pre-aggregate store_sales by c_customer_sk before joining.",
      "node_contract": {
        "from_must_include": [
          "store_sales"
        ],
        "where_must_preserve": [
          "ss_wholesale_cost BETWEEN 35 AND 65",
          "d_month_seq range filter"
        ],
        "output_must_preserve": [
          "ss_customer_sk",
          "revenue (sum of ss_ext_sales_price)"
        ]
      },
      "gates_checked": [
        "agg_key_compatibility:PASS",
        "duplication_sensitive_metrics:none"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.88,
      "expected_explain_delta": "Rows into final aggregate and join reduce due to earlier grouping on STORE_SALES.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "aggregate_pushdown"
      ],
      "gold_example_id": "aggregate_pushdown"
    },
    {
      "probe_id": "p04",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Materialize my_customers CTE to prevent recomputation in downstream joins.",
      "dag_target_hint": "Add MATERIALIZED hint to my_customers CTE to ensure single evaluation.",
      "node_contract": {
        "from_must_include": [
          "catalog_sales",
          "web_sales",
          "item",
          "date_dim",
          "customer"
        ],
        "where_must_preserve": [
          "i_category = 'Electronics'",
          "i_class = 'personal'",
          "d_moy = 1",
          "d_year = 1998",
          "wholesale_cost BETWEEN 35 AND 65",
          "c_birth_year BETWEEN 1928 AND 1941"
        ],
        "output_must_preserve": [
          "c_customer_sk",
          "c_current_addr_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS",
        "multiplicity_guard_required:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Repeated use of my_customers in downstream joins may benefit from explicit materialization to avoid recomputation.",
      "confidence": 0.65,
      "expected_explain_delta": "my_customers CTE is evaluated once and reused, reducing redundant scan and join work.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "materialize_cte"
      ]
    },
    {
      "probe_id": "p05",
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "target": "Push date_sk BETWEEN predicate into STORE_SALES scan to enable micro-partition pruning.",
      "dag_target_hint": "Modify store_sales scan in my_revenue CTE to include explicit date_sk range filter.",
      "node_contract": {
        "from_must_include": [
          "store_sales",
          "date_dim"
        ],
        "where_must_preserve": [
          "ss_wholesale_cost BETWEEN 35 AND 65",
          "d_month_seq range filter"
        ],
        "output_must_preserve": [
          "ss_customer_sk",
          "ss_sold_date_sk",
          "ss_ext_sales_price"
        ]
      },
      "gates_checked": [
        "G_SF_SK_DATE_FILTER_REQUIRED:PASS",
        "G_SF_SK_SCAN_PRESSURE:PASS",
        "G_SF_SK_RANGE_SEMANTICS:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "STORE_SALES scan lacks explicit date_sk filtering, missing partition pruning opportunity.",
      "confidence": 0.78,
      "expected_explain_delta": "STORE_SALES scan gains partition-key filtering, reducing scanned bytes significantly.",
      "recommended_patch_ops": [
        "replace_where_predicate"
      ],
      "recommended_examples": [
        "sf_sk_pushdown_3fact"
      ]
    },
    {
      "probe_id": "p06",
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "target": "Extract shared ITEM and DATE_DIM filters into a single CTE and reference from both UNION ALL branches.",
      "dag_target_hint": "Create shared filtered CTEs for ITEM and DATE_DIM before UNION ALL.",
      "node_contract": {
        "from_must_include": [
          "item",
          "date_dim"
        ],
        "where_must_preserve": [
          "i_category = 'Electronics'",
          "i_class = 'personal'",
          "d_moy = 1",
          "d_year = 1998"
        ],
        "output_must_preserve": [
          "i_item_sk",
          "d_date_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS",
        "multiplicity_guard_required:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Both UNION ALL branches apply identical ITEM and DATE_DIM filters, suggesting shared CTE opportunity.",
      "confidence": 0.70,
      "expected_explain_delta": "Redundant ITEM and DATE_DIM scans are eliminated by sharing filtered CTEs.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "shared_dimension_multi_channel"
      ]
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan evidence."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT operations present in query."
    },
    {
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "reason": "No correlated scalar subquery pattern detected in SQL or plan."
    }
  ]
}