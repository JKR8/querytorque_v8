{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 2,
    "probe_count": 8,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Plan shows massive fact-table scans (CATALOG_SALES 920GB, CATALOG_RETURNS 82GB) with late application of date-range filter after join. The date_dim filter (d_date between) is applied to dimension scan but not pushed into fact-table micro-partition pruning via cs_sold_date_sk range, causing full table scan. Secondary hotspot is the two-stage aggregation amplifying row flow.",
    "reasoning_trace": [
      "CATALOG_SALES scan: 54721/54922 parts (99.6%) scanned, 920GB I/O dominant",
      "DATE_DIM filter applied at [1.12] but join occurs at [1.11] after fact scan",
      "No cs_sold_date_sk BETWEEN predicate visible in CATALOG_SALES filter [1.14]",
      "Two-stage aggregation: [1.6] groups by IFF(...), then [1.3] re-aggregates",
      "CATALOG_RETURNS scan: 4759/4759 parts (100%) despite cr_reason_sk=33 filter"
    ],
    "cost_spine": ["TableScan(CATALOG_SALES)", "InnerJoin(DATE_DIM)", "InnerJoin(ITEM)", "InnerJoin(CATALOG_RETURNS)", "Aggregate[1.6]", "Aggregate[1.3]"],
    "hotspots": [
      {
        "op": "TableScan(CATALOG_SALES)",
        "why": "full table scan without date_sk pushdown",
        "evidence": "parts=54721/54922 bytes=920184101376"
      },
      {
        "op": "Aggregate[1.6]",
        "why": "two-stage aggregation amplifies intermediate rows",
        "evidence": "group by IFF(...) then re-aggregated at [1.3]"
      },
      {
        "op": "TableScan(CATALOG_RETURNS)",
        "why": "full scan despite selective cr_reason_sk=33",
        "evidence": "parts=4759/4759 bytes=82532796416"
      }
    ],
    "do_not_do": [
      "avoid materializing EXISTS patterns (no EXISTS in query)",
      "avoid same-column OR to UNION ALL (no OR predicate)",
      "avoid unfiltered large CTEs that increase scan volume"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "target": "Add explicit cs_sold_date_sk BETWEEN range derived from date_dim filter to CATALOG_SALES scan predicate.",
      "dag_target_hint": "Modify final_select WHERE clause to include cs_sold_date_sk BETWEEN (SELECT MIN(d_date_sk) FROM date_dim WHERE d_date BETWEEN '2002-01-20' AND '2002-03-21') AND (SELECT MAX(d_date_sk) FROM date_dim WHERE d_date BETWEEN '2002-01-20' AND '2002-03-21')",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim"],
        "where_must_preserve": ["d_date between '2002-01-20' and '2002-03-21'", "cs_wholesale_cost between 42 and 61"],
        "output_must_preserve": ["all original columns and aggregation semantics"]
      },
      "gates_checked": ["G_SF_SK_DATE_FILTER_REQUIRED:PASS", "G_SF_SK_SCAN_PRESSURE:PASS", "G_SF_SK_RANGE_SEMANTICS:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "CATALOG_SALES scan shows reduced parts scanned (micro-partition pruning) and lower bytes.",
      "recommended_patch_ops": ["add_where_predicate", "add_scalar_subquery"],
      "rank_rationale": "Primary hotspot: targets largest I/O source with native Snowflake transform for predicate pushdown.",
      "recommended_examples": ["sf_sk_pushdown_union_all"],
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p02",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate catalog_sales and catalog_returns by (cs_item_sk, cs_order_number, cs_warehouse_sk, cs_sold_date_sk) before joining with dimensions.",
      "dag_target_hint": "Replace final_select FROM clause with CTE that pre-aggregates fact tables.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "catalog_returns"],
        "where_must_preserve": ["cr_reason_sk = 33", "cs_wholesale_cost between 42 and 61"],
        "output_must_preserve": ["sum(cs_sales_price - coalesce(cr_refunded_cash,0)) per grouping key"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Aggregate[1.6] disappears; join input rows reduce before date_dim and item joins.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Secondary hotspot: reduces row amplification before expensive joins.",
      "recommended_examples": ["aggregate_pushdown"],
      "gold_example_id": "aggregate_pushdown"
    },
    {
      "probe_id": "p03",
      "transform_id": "inner_join_conversion",
      "family": "F",
      "target": "Convert LEFT OUTER JOIN catalog_returns to INNER JOIN since cr_reason_sk=33 filter eliminates NULL rows.",
      "dag_target_hint": "Change LEFT OUTER JOIN to INNER JOIN in final_select.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "catalog_returns"],
        "where_must_preserve": ["cr_reason_sk = 33"],
        "output_must_preserve": ["all original output columns and aggregation semantics"]
      },
      "gates_checked": ["NULL_DEPENDENT_LOGIC:PASS", "join_multiplicity_safe:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.90,
      "expected_explain_delta": "JoinFilter may become regular join predicate, potentially better join ordering.",
      "recommended_patch_ops": ["replace_join_type"],
      "rank_rationale": "Semantic optimization: LEFT JOIN with right-side filter behaves as INNER JOIN.",
      "recommended_examples": ["inner_join_conversion"],
      "gold_example_id": "inner_join_conversion"
    },
    {
      "probe_id": "p04",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre-filter date_dim, item, warehouse into separate CTEs and join with pre-aggregated fact CTE.",
      "dag_target_hint": "Wrap dimension tables in CTEs with their filters, then join with fact CTE.",
      "node_contract": {
        "from_must_include": ["date_dim", "item", "warehouse"],
        "where_must_preserve": ["d_date between '2002-01-20' and '2002-03-21'", "i_category='Jewelry'", "i_manager_id between 61 and 100"],
        "output_must_preserve": ["all original join keys and output columns"]
      },
      "gates_checked": ["G_SF_CTE_REUSE_RULE:PASS", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Snowflake may benefit from explicit dimension CTEs for better cardinality estimates and join ordering.",
      "confidence": 0.55,
      "expected_explain_delta": "Dimension scans become CTE scans; join order may shift to dimension-first.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Exploration: tests dimension isolation in Snowflake, though dimension scans are already small.",
      "recommended_examples": ["multi_dimension_prefetch"],
      "gold_example_id": "multi_dimension_prefetch"
    },
    {
      "probe_id": "p05",
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "target": "Convert comma joins to explicit JOIN syntax and isolate date_dim filter into CTE.",
      "dag_target_hint": "Rewrite FROM clause to use explicit JOIN ON syntax and move date_dim filter to CTE.",
      "node_contract": {
        "from_must_include": ["date_dim", "catalog_sales"],
        "where_must_preserve": ["d_date between '2002-01-20' and '2002-03-21'"],
        "output_must_preserve": ["all original join conditions and output columns"]
      },
      "gates_checked": ["G_SF_JOINFILTER_PRESERVE:PASS", "join_multiplicity_safe:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Explicit JOIN syntax may improve predicate pushdown in Snowflake optimizer.",
      "confidence": 0.50,
      "expected_explain_delta": "JoinFilter may become regular join predicate; date_dim CTE may materialize.",
      "recommended_patch_ops": ["replace_from", "insert_cte"],
      "rank_rationale": "Exploration: tests join syntax impact on predicate pushdown.",
      "recommended_examples": ["date_cte_explicit_join"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p06",
      "transform_id": "single_pass_aggregation",
      "family": "C",
      "target": "Consolidate two-stage aggregation into single GROUP BY with conditional sums directly.",
      "dag_target_hint": "Replace final SELECT aggregation with single SUM(CASE...) grouped by w_state, i_item_id.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "catalog_returns", "date_dim"],
        "where_must_preserve": ["d_date between '2002-01-20' and '2002-03-21'"],
        "output_must_preserve": ["sales_before and sales_after values identical to original"]
      },
      "gates_checked": ["duplication_sensitive_metrics:none", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Two-stage aggregation may be optimizer artifact; single-pass may reduce intermediate rows.",
      "confidence": 0.60,
      "expected_explain_delta": "Aggregate[1.6] and Aggregate[1.3] collapse into one Aggregate node.",
      "recommended_patch_ops": ["replace_select", "replace_group_by"],
      "rank_rationale": "Exploration: simplifies aggregation tree, may reduce compute overhead.",
      "recommended_examples": ["single_pass_aggregation"],
      "gold_example_id": ""
    },
    {
      "probe_id": "p07",
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "target": "Push date_sk range into fact scan using scalar subqueries, similar to p01 but using UNION ALL pattern (though query has no UNION).",
      "dag_target_hint": "Add cs_sold_date_sk BETWEEN subqueries to WHERE clause.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim"],
        "where_must_preserve": ["d_date between '2002-01-20' and '2002-03-21'"],
        "output_must_preserve": ["all original columns and aggregation semantics"]
      },
      "gates_checked": ["G_SF_SK_DATE_FILTER_REQUIRED:PASS", "G_SF_SK_SCAN_PRESSURE:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Alternative pushdown pattern may interact differently with Snowflake's pruning.",
      "confidence": 0.50,
      "expected_explain_delta": "Similar to p01: reduced CATALOG_SALES scan parts.",
      "recommended_patch_ops": ["add_where_predicate", "add_scalar_subquery"],
      "rank_rationale": "Exploration: variant of primary pushdown transform.",
      "recommended_examples": ["sf_sk_pushdown_union_all"],
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p08",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Materialize filtered date_dim keys in a CTE to potentially improve join performance.",
      "dag_target_hint": "Wrap date_dim filter in a MATERIALIZED CTE (if Snowflake supports hint).",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_date between '2002-01-20' and '2002-03-21'"],
        "output_must_preserve": ["d_date_sk for join"]
      },
      "gates_checked": ["G_SF_CTE_REUSE_RULE:PASS", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Materializing small dimension may improve join planning in Snowflake.",
      "confidence": 0.45,
      "expected_explain_delta": "Date_dim scan becomes CTE scan; join may use hash table.",
      "recommended_patch_ops": ["insert_cte", "add_materialized_hint"],
      "rank_rationale": "Exploration: tests CTE materialization impact on join performance.",
      "recommended_examples": ["materialize_cte"],
      "gold_example_id": ""
    }
  ],
  "dropped": [
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated subqueries in query."
    },
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicates in query."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT operations in query."
    },
    {
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "reason": "No correlated scalar aggregate subqueries."
    },
    {
      "transform_id": "channel_bitmap_aggregation",
      "family": "C",
      "reason": "No repeated fact table scans with different channel filters."
    }
  ]
}