{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 1,
    "probe_count": 5,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The primary bottleneck stems from a correlated scalar subquery computing average return per store, which re-executes per outer row. A secondary hotspot involves early filtering opportunities missed on dimension tables like customer_demographics and store. Decorrelating the scalar subquery and pushing down selective filters should significantly reduce runtime.",
    "reasoning_trace": [
      "Correlated scalar aggregate subquery (avg) triggers rescans of customer_total_return per outer row.",
      "Dimension tables (store, customer_demographics) lack pre-filtering before large joins.",
      "No evidence of nested loops or severe estimate mismatches, but plan depth indicates amplification risk.",
      "Snowflake’s strength in decorrelating simple EXISTS does not extend to scalar aggregates.",
      "Early filter pushdown aligns with Snowflake’s column-pruning and micro-partition strengths."
    ],
    "cost_spine": [
      "InnerJoin",
      "InnerJoin",
      "InnerJoin",
      "Aggregate",
      "TableScan"
    ],
    "hotspots": [
      {
        "op": "InnerJoin",
        "why": "correlated scalar subquery forces per-row re-execution of aggregate",
        "evidence": "joinFilter: (CTR1.CTR_TOTAL_RETURN) > (((SUM(CTR2.CTR_TOTAL_RETURN)) / (NVL(COUNT(CTR2.CTR_TOTAL_RETURN), 0))) * 1.2)"
      },
      {
        "op": "TableScan",
        "why": "dimension tables scanned broadly before selective filters applied",
        "evidence": "STORE, CUSTOMER_DEMOGRAPHICS scanned without early keyset reduction"
      }
    ],
    "do_not_do": [
      "avoid EXISTS materialization into broad CTE branches",
      "do not wrap partition keys in functions during date_sk pushdown",
      "preserve join filters that enable semi-join behavior"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "target": "Decompose correlated scalar AVG subquery into shared CTE + threshold CTE to eliminate per-row re-execution.",
      "dag_target_hint": "Rewrite final_select to replace subquery with precomputed threshold join.",
      "node_contract": {
        "from_must_include": ["customer_total_return ctr2"],
        "where_must_preserve": ["ctr1.ctr_store_sk = ctr2.ctr_store_sk"],
        "output_must_preserve": ["ctr1.ctr_customer_sk", "ctr1.ctr_total_return"]
      },
      "gates_checked": [
        "G_SF_CORR_SCALAR_REQUIRED:PASS",
        "G_SF_CORR_SIMPLE_EXISTS_SKIP:PASS",
        "G_SF_CORR_FACT_CONTEXT:PASS",
        "G_SF_CORR_SEMANTIC_KEYS:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.93,
      "expected_explain_delta": "Subquery disappears; replaced with single-pass threshold CTE join.",
      "recommended_patch_ops": ["insert_cte", "replace_where_predicate"],
      "recommended_examples": ["sf_inline_decorrelate"],
      "gold_example_id": "sf_inline_decorrelate"
    },
    {
      "probe_id": "p02",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Pre-filter customer_demographics into isolated CTE to reduce join size with customer.",
      "dag_target_hint": "Insert cd_filtered CTE before final_select and update join path.",
      "node_contract": {
        "from_must_include": ["customer_demographics"],
        "where_must_preserve": [
          "cd_marital_status IN ('M')",
          "cd_education_status IN ('Advanced Degree', 'College')",
          "cd_gender = 'F'"
        ],
        "output_must_preserve": ["cd_demo_sk"]
      },
      "gates_checked": [
        "no_or_to_union:PASS",
        "multiplicity_guard_required:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.81,
      "expected_explain_delta": "CustomerDemographics scan pruned to small keyset; join input rows drop.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "recommended_examples": ["duckdb_dimension_cte_isolate_01"]
    },
    {
      "probe_id": "p03",
      "transform_id": "date_cte_isolate",
      "family": "A",
      "target": "Isolate date_dim filter into CTE to improve predicate pushdown into store_returns.",
      "dag_target_hint": "Create d_filtered CTE and propagate date_sk constraint into fact scan.",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_year = 2002"],
        "output_must_preserve": ["d_date_sk"]
      },
      "gates_checked": [
        "G_SF_FILTER_FUNCTION_WRAP:PASS",
        "G_SF_JOINFILTER_PRESERVE:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.76,
      "expected_explain_delta": "DateDim scan becomes narrow; joinFilter propagates to store_returns for pruning.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "recommended_examples": ["duckdb_date_cte_isolate_01"]
    },
    {
      "probe_id": "p04",
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "target": "Push date_sk range predicate into store_returns scan to enable micro-partition pruning.",
      "dag_target_hint": "Modify store_returns scan to include explicit date_sk BETWEEN derived from d_year=2002.",
      "node_contract": {
        "from_must_include": ["store_returns", "date_dim"],
        "where_must_preserve": ["sr_returned_date_sk = d_date_sk", "d_year = 2002"],
        "output_must_preserve": ["sr_customer_sk", "sr_store_sk", "sr_return_amt_inc_tax"]
      },
      "gates_checked": [
        "G_SF_SK_DATE_FILTER_REQUIRED:PASS",
        "G_SF_SK_SCAN_PRESSURE:PASS",
        "G_SF_SK_RANGE_SEMANTICS:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Fact table scan pressure suggests potential for partition pruning via sk pushdown.",
      "confidence": 0.65,
      "expected_explain_delta": "StoreReturns scan prunes micro-partitions; reduces I/O and row volume.",
      "recommended_patch_ops": ["replace_where_predicate"],
      "recommended_examples": ["sf_sk_pushdown_union_all"],
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p05",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Pre-filter store table to IL/KY/TX states before join with customer_total_return.",
      "dag_target_hint": "Introduce s_filtered CTE and update join path in final_select.",
      "node_contract": {
        "from_must_include": ["store"],
        "where_must_preserve": ["s_state IN ('IL', 'KY', 'TX')"],
        "output_must_preserve": ["s_store_sk"]
      },
      "gates_checked": [
        "no_or_to_union:PASS",
        "multiplicity_guard_required:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Broad store scan contributes to join amplification; early filter may reduce inner side.",
      "confidence": 0.58,
      "expected_explain_delta": "Store scan pruned to small keyset; reduces join inner-side volume.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "recommended_examples": ["duckdb_early_filter_01"]
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No cross-column OR predicates detected in plan or SQL."
    },
    {
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "reason": "No pre-aggregation opportunity evident; grouping already occurs early in CTE."
    },
    {
      "transform_id": "materialize_cte",
      "family": "E",
      "reason": "No repeated CTE scans or self-joins found in plan structure."
    }
  ]
}