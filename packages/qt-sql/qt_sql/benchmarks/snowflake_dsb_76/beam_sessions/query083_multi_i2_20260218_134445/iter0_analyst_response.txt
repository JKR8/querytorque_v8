{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 2,
    "probe_count": 8,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Plan shows 3 independent fact table scans (store_returns: 124GB, catalog_returns: 82GB, web_returns: 39GB) each repeating identical date_dim subquery pattern 3 times (9 total scans). Each branch uses nested scalar subqueries on date_dim (d_date IN (SELECT ... IN (SELECT ...))) that may block predicate pushdown to fact tables. Date_dim scans are small (2MB each) but repeated, and fact scans show no partition pruning evidence.",
    "reasoning_trace": [
      "Three large fact scans dominate I/O: store_returns (7070 parts, 124GB), catalog_returns (4759 parts, 82GB), web_returns (2289 parts, 39GB)",
      "Each branch repeats identical date_dim subquery structure 3 times → total 9 small date_dim scans",
      "Subquery pattern: d_date IN (SELECT d_date FROM date_dim WHERE d_month_seq IN (SELECT d_month_seq FROM date_dim WHERE d_date IN (...)))",
      "No evidence of date_sk pushdown to fact tables; scans appear full-table",
      "Anti-padding guard: date_dim scans are negligible individually (<1% of total I/O) but repeated pattern suggests predicate pushdown opportunity",
      "Family A (early filtering) and Family C (aggregation pushdown) are underrepresented given the scan volume and repeated work"
    ],
    "cost_spine": [
      "TableScan (STORE_RETURNS) → Filter → Aggregate → InnerJoin → Aggregate → Aggregate → InnerJoin → Result",
      "TableScan (CATALOG_RETURNS) → Filter → Aggregate → InnerJoin → Aggregate → Aggregate → InnerJoin → Result",
      "TableScan (WEB_RETURNS) → Filter → Aggregate → InnerJoin → Aggregate → Aggregate → InnerJoin → Result",
      "Multiple date_dim subquery scans (9 instances)"
    ],
    "hotspots": [
      {
        "op": "TableScan (STORE_RETURNS)",
        "why": "largest fact scan without evident partition pruning",
        "evidence": "parts=7070/7070 bytes=124763446272"
      },
      {
        "op": "TableScan (CATALOG_RETURNS)",
        "why": "second largest fact scan, same pattern as store_returns",
        "evidence": "parts=4759/4759 bytes=82532796416"
      },
      {
        "op": "TableScan (WEB_RETURNS)",
        "why": "third fact scan, same pattern",
        "evidence": "parts=2289/2289 bytes=39149218304"
      },
      {
        "op": "Repeated date_dim subquery evaluation",
        "why": "identical subquery computed 9 times across branches",
        "evidence": "9 instances of date_dim scans in plan (nodes 1.14, 1.16, 1.18, 1.37, 1.39, 1.41, 1.60, 1.62, 1.64)"
      }
    ],
    "do_not_do": [
      "avoid materializing EXISTS subqueries (Snowflake already optimizes them via SEMI_JOIN)",
      "avoid converting correlated scalar subqueries when not present (none in this query)",
      "do not split OR predicates (no OR in plan)",
      "do not introduce UNION ALL branches without clear partition pruning benefit"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "target": "Precompute date_sk values from the nested date_dim subquery as a CTE, then join fact tables directly on date_sk with explicit BETWEEN range derived from the four literal dates, enabling micro-partition pruning on all three fact tables.",
      "dag_target_hint": "Replace each channel's date_dim subquery join with a filtered date_sk CTE join on sr_returned_date_sk BETWEEN min_sk AND max_sk (or IN list).",
      "node_contract": {
        "from_must_include": ["store_returns", "catalog_returns", "web_returns", "date_dim"],
        "where_must_preserve": ["i_category IN ('Children','Electronics')", "i_manager_id BETWEEN 15 AND 24", "return_amt/return_quantity BETWEEN 253 AND 282", "reason_sk IN (7,18,19,22,36)", "d_date IN ('1999-01-10','1999-06-17','1999-08-04','1999-11-05')"],
        "output_must_preserve": ["item_id", "sr_item_qty", "cr_item_qty", "wr_item_qty", "final order by and limit"]
      },
      "gates_checked": [
        "G_SF_SK_DATE_FILTER_REQUIRED:PASS",
        "G_SF_SK_SCAN_PRESSURE:PASS",
        "G_SF_SK_COMPUTE_BOUND_SKIP:PASS",
        "G_SF_SK_RANGE_SEMANTICS:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.88,
      "expected_explain_delta": "Fact table scans show reduced partitions read (parts<total) and earlier Filter operator with date_sk predicate; repeated date_dim scans eliminated.",
      "recommended_patch_ops": ["insert_cte", "replace_join_predicate", "replace_subquery_with_cte"],
      "rank_rationale": "Primary hotspot: addresses largest I/O source across all three fact tables with native Snowflake transform.",
      "recommended_examples": ["sf_sk_pushdown_union_all"],
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p02",
      "transform_id": "date_cte_isolate",
      "family": "A",
      "target": "Extract the nested date_dim subquery into a single CTE returning distinct d_date_sk for the four literal dates, then join this CTE once per channel to eliminate repeated subquery evaluation.",
      "dag_target_hint": "Replace each date_dim subquery chain with a single reference to pre‑filtered date_keys CTE.",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_date IN ('1999-01-10','1999-06-17','1999-08-04','1999-11-05')"],
        "output_must_preserve": ["All original date_dim join semantics"]
      },
      "gates_checked": ["no_or_to_union:PASS", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Snowflake may not automatically common‑subexpression‑eliminate the repeated subquery; materializing once could reduce redundant work and improve join‑filter pushdown.",
      "confidence": 0.65,
      "expected_explain_delta": "Number of date_dim scans drops from 9 to 1; join filters may appear earlier in plan.",
      "recommended_patch_ops": ["insert_cte", "replace_subquery_with_cte", "replace_join_predicate"],
      "rank_rationale": "Secondary hotspot: targets repeated date_dim scans; exploration because native decorrelation may already handle this.",
      "recommended_examples": []
    },
    {
      "probe_id": "p03",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre‑aggregate each fact table by item_sk and date_sk before joining with item and date_dim, reducing rows flowing through the join layers.",
      "dag_target_hint": "Modify sr_items, cr_items, wr_items CTEs to aggregate store_returns/catalog_returns/web_returns at (item_sk, returned_date_sk) grain first, then join with item and date_dim.",
      "node_contract": {
        "from_must_include": ["store_returns", "catalog_returns", "web_returns"],
        "where_must_preserve": ["return_amt/return_quantity BETWEEN 253 AND 282", "reason_sk IN (7,18,19,22,36)"],
        "output_must_preserve": ["item_id grouping key compatibility", "SUM(return_quantity) per item"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.78,
      "expected_explain_delta": "Aggregate nodes appear earlier in plan (closer to fact scans); input rows to downstream joins reduced.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "rewrite_group_by"],
      "rank_rationale": "Targets amplification hotspot: each fact scan feeds multiple aggregation layers; pushing aggregation down reduces join work.",
      "recommended_examples": ["duckdb_agg_pushdown_fact_key_01"],
      "gold_example_id": "duckdb_agg_pushdown_fact_key_01"
    },
    {
      "probe_id": "p04",
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "target": "Create a single pre‑filtered CTE for date_dim and item filters, then join it with each fact table in separate channel CTEs, ensuring dimension filters are applied once and shared.",
      "dag_target_hint": "Extract date_dim and item filters into a common CTE, then join with store_returns, catalog_returns, web_returns separately.",
      "node_contract": {
        "from_must_include": ["date_dim", "item"],
        "where_must_preserve": ["d_date IN literal list", "i_category IN ('Children','Electronics')", "i_manager_id BETWEEN 15 AND 24"],
        "output_must_preserve": ["All join keys and filter semantics"]
      },
      "gates_checked": ["no_or_to_union:PASS", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Sharing dimension CTEs across channels may improve Snowflake's ability to cache small dimension results and propagate filters earlier.",
      "confidence": 0.58,
      "expected_explain_delta": "Dimension scans (date_dim, item) reduce from multiple instances to one each; fact joins may show earlier filter pushdown.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_where_predicate"],
      "rank_rationale": "Exploration: addresses repeated dimension scans; under‑represented family A variant.",
      "recommended_examples": []
    },
    {
      "probe_id": "p05",
      "transform_id": "channel_bitmap_aggregation",
      "family": "C",
      "target": "Consolidate three separate fact table scans into a single UNION ALL scan with conditional aggregation, scanning each fact table once and computing all three quantities in a single pass per channel.",
      "dag_target_hint": "Replace sr_items, cr_items, wr_items CTEs with a single CTE that UNION ALLs store_returns, catalog_returns, web_returns and uses CASE expressions to compute channel‑specific sums.",
      "node_contract": {
        "from_must_include": ["store_returns", "catalog_returns", "web_returns"],
        "where_must_preserve": ["return_amt/return_quantity BETWEEN 253 AND 282", "reason_sk IN (7,18,19,22,36)", "date filters", "item filters"],
        "output_must_preserve": ["item_id", "sr_item_qty", "cr_item_qty", "wr_item_qty"]
      },
      "gates_checked": ["no_or_to_union:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Single‑pass aggregation across three fact tables may reduce total scan I/O if Snowflake can parallelize UNION ALL branches efficiently.",
      "confidence": 0.52,
      "expected_explain_delta": "Three separate fact scan branches merge into one UNION ALL subtree; aggregate nodes consolidate.",
      "recommended_patch_ops": ["insert_cte", "rewrite_union_all", "rewrite_aggregation"],
      "rank_rationale": "Exploration: radical consolidation of fact scans; high‑risk, high‑reward if I/O reduction materializes.",
      "recommended_examples": []
    },
    {
      "probe_id": "p06",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Push item and date_dim filters into a pre‑joined CTE that returns only the necessary surrogate keys, then join with fact tables using those keys, reducing fact table rows early.",
      "dag_target_hint": "Create a CTE joining date_dim and item with all filters applied, then join that CTE with each fact table on item_sk and date_sk.",
      "node_contract": {
        "from_must_include": ["date_dim", "item"],
        "where_must_preserve": ["d_date IN literal list", "i_category IN ('Children','Electronics')", "i_manager_id BETWEEN 15 AND 24"],
        "output_must_preserve": ["item_sk", "d_date_sk", "item_id"]
      },
      "gates_checked": ["no_or_to_union:PASS", "multiplicity_guard_required:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.72,
      "expected_explain_delta": "Fact table scans show reduced rows due to earlier join with filtered dimension keys.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_predicate"],
      "rank_rationale": "Targets secondary hotspot: dimension filtering may not be pushed down effectively; early join reduces fact rows.",
      "recommended_examples": []
    },
    {
      "probe_id": "p07",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre‑filter both date_dim and item into separate CTEs, then join them with each fact table sequentially, creating a staged reduction pipeline.",
      "dag_target_hint": "Create date_filter CTE and item_filter CTE, then join each with fact tables in a chain: fact → date_filter → item_filter.",
      "node_contract": {
        "from_must_include": ["date_dim", "item"],
        "where_must_preserve": ["d_date IN literal list", "i_category IN ('Children','Electronics')", "i_manager_id BETWEEN 15 AND 24"],
        "output_must_preserve": ["All join keys and filter semantics"]
      },
      "gates_checked": ["no_or_to_union:PASS", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Staged dimension prefetch may help Snowflake's optimizer choose better join orders and build smaller hash tables.",
      "confidence": 0.60,
      "expected_explain_delta": "Dimension scans become independent CTEs; join order may shift to dimension‑first.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "replace_join_order"],
      "rank_rationale": "Exploration: under‑represented family A variant; tests dimension‑first join topology.",
      "recommended_examples": []
    },
    {
      "probe_id": "p08",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Materialize the filtered date_dim subquery results as a CTE to avoid recomputation across the three channels and within each channel's nested subqueries.",
      "dag_target_hint": "Wrap the date_dim subquery in a MATERIALIZED CTE and reference it in each channel's date join.",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_date IN ('1999-01-10','1999-06-17','1999-08-04','1999-11-05')"],
        "output_must_preserve": ["d_date", "d_date_sk", "d_month_seq"]
      },
      "gates_checked": ["no_or_to_union:PASS", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Snowflake may inline CTEs by default; explicit materialization could force reuse and eliminate redundant subquery evaluation.",
      "confidence": 0.50,
      "expected_explain_delta": "Reduced number of date_dim scans; CTE appears as a persistent subplan.",
      "recommended_patch_ops": ["insert_cte", "materialize_cte", "replace_subquery_with_cte"],
      "rank_rationale": "Exploration: tests CTE materialization impact on repeated subqueries; low risk, low expected gain.",
      "recommended_examples": []
    }
  ],
  "dropped": [
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated scalar subqueries in plan; subqueries are already decorrelated as semi‑joins."
    },
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan evidence."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT operations in query."
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "No LEFT JOIN patterns in query; all joins are inner."
    },
    {
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "reason": "No self‑join patterns; each fact table appears once per channel."
    },
    {
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "reason": "No correlated scalar aggregate subqueries; pattern mismatch."
    },
    {
      "transform_id": "sf_shared_scan_decorrelate",
      "family": "B",
      "reason": "No correlated scalar aggregate subqueries; pattern mismatch."
    }
  ]
}