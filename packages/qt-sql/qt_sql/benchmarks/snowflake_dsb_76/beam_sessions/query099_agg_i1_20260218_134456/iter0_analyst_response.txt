{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The dominant cost is a full 923GB scan of CATALOG_SALES (54922 parts) without effective partition pruning for d_month_seq, causing massive row flow into a cascade of aggregation stages. Predicates on date_dim (d_month_seq BETWEEN 1192 AND 1215) are applied after the fact table scan, missing a major early-filter opportunity. Aggregation is performed in a multi-stage pattern, potentially amplifying compute after the large scan.",
    "reasoning_trace": [
      "GlobalStats Bytes=923619642880, 54926/54926 parts scanned, indicating near-full table scan.",
      "Plan shows fact table scan [1.22-1.23] before join with date_dim [1.8], suggesting predicate pushdown failure.",
      "Aggregate cascade: [1.20] → [1.16] → [1.11] → [1.7] → [1.3] → [1.2] → [1.1]; each stage processes the same large rowset.",
      "Dimension tables (WAREHOUSE, SHIP_MODE, CALL_CENTER, DATE_DIM) are fully pruned (parts=1/1), so not primary I/O bottlenecks.",
      "No nested loops, set operations, or correlated subqueries detected; families B and D are unlikely."
    ],
    "cost_spine": [
      "TableScan(CATALOG_SALES) (54922/54922 parts, 923GB)",
      "Filter(cs_list_price)",
      "Aggregate[SUM(1)] (IFF case bucket)",
      "InnerJoin(SHIP_MODE)",
      "Aggregate[SUM(SUM(1))]",
      "InnerJoin(CALL_CENTER)",
      "Aggregate[SUM_INTERNAL(...)]",
      "InnerJoin(DATE_DIM)",
      "Aggregate[SUM(SUM_INTERNAL(...))]",
      "InnerJoin(WAREHOUSE)",
      "Aggregate[aggExprs: SUM(...)]",
      "Aggregate[group by substring, sm_type, cc_name]",
      "SortWithLimit",
      "Result"
    ],
    "hotspots": [
      {
        "op": "TableScan(CATALOG_SALES)",
        "why": "Full fact table scan without date pruning dominates I/O (923GB).",
        "evidence": "parts=54922/54922 bytes=923617475584"
      },
      {
        "op": "Aggregate cascade",
        "why": "Multiple aggregation stages process full scan volume, amplifying compute.",
        "evidence": "Nodes [1.20], [1.16], [1.11], [1.7], [1.3], [1.2] each process same large rowset"
      },
      {
        "op": "InnerJoin(DATE_DIM)",
        "why": "Date filter applied after fact scan, missing early pruning opportunity.",
        "evidence": "Filter [1.9] on d_month_seq applied after fact scan [1.22-1.23]"
      }
    ],
    "do_not_do": [
      "Do not introduce correlated subquery decorrelation (no EXISTS/IN correlation present).",
      "Avoid OR-to-UNION transforms (no OR predicate).",
      "Do not materialize simple dimension scans already fully pruned (parts=1/1).",
      "Avoid deep CTE chains that reduce parallelism on large fact scans."
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "target": "Add explicit date_sk range derived from d_month_seq filter to CATALOG_SALES scan, converting comma join to explicit JOIN with derived date keys.",
      "dag_target_hint": "Change final_select FROM clause: replace date_dim join with pre‑filtered date_keys CTE and push cs_ship_date_sk BETWEEN (SELECT MIN(d_date_sk) FROM date_dim WHERE d_month_seq BETWEEN 1192 AND 1215) AND (SELECT MAX(...)).",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim"],
        "where_must_preserve": ["d_month_seq between 1192 and 1192 + 23", "cs_ship_date_sk = d_date_sk", "cs_list_price between 86 and 115", "sm_type = 'EXPRESS'", "cc_class = 'small'", "w_gmt_offset = -5"],
        "output_must_preserve": ["All original output columns, grouping keys, and CASE logic"]
      },
      "gates_checked": ["G_SF_SK_DATE_FILTER_REQUIRED:PASS", "G_SF_SK_SCAN_PRESSURE:PASS", "G_SF_SK_COMPUTE_BOUND_SKIP:PASS", "G_SF_SK_RANGE_SEMANTICS:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.88,
      "expected_explain_delta": "Date filter pushed into fact scan; CATALOG_SALES parts scanned reduced dramatically.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "add_predicate"],
      "rank_rationale": "Primary hotspot: eliminates 923GB full scan via predicate pushdown; native Snowflake transform with gold example.",
      "recommended_examples": ["sf_sk_pushdown_union_all"],
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p02",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre‑aggregate CATALOG_SALES by join keys (cs_warehouse_sk, cs_ship_date_sk, cs_ship_mode_sk, cs_call_center_sk) and CASE bucket before joining dimensions, collapsing the multi‑stage aggregate cascade.",
      "dag_target_hint": "Replace final_select FROM with CTE that groups catalog_sales by join keys and computes bucket counts, then join to dimensions.",
      "node_contract": {
        "from_must_include": ["catalog_sales"],
        "where_must_preserve": ["cs_list_price between 86 and 115", "cs_ship_date_sk IS NOT NULL", "cs_warehouse_sk IS NOT NULL", "cs_call_center_sk IS NOT NULL", "cs_ship_mode_sk IS NOT NULL"],
        "output_must_preserve": ["Same CASE bucket definitions, same grouping keys after join"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Aggregate cascade collapses; fewer rows flow into dimension joins; aggregate nodes shift left.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "reorder_group_by"],
      "rank_rationale": "Secondary hotspot: reduces compute amplification from multi‑stage aggregates; gold example shows 42.90x.",
      "recommended_examples": ["aggregate_pushdown"],
      "gold_example_id": "aggregate_pushdown"
    },
    {
      "probe_id": "p03",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre‑filter all dimension tables (date_dim, warehouse, ship_mode, call_center) into CTEs before joining with catalog_sales, enabling hash‑join with tiny probe tables.",
      "dag_target_hint": "Wrap each dimension filter into a separate CTE, then join them sequentially with catalog_sales.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "warehouse", "ship_mode", "call_center", "date_dim"],
        "where_must_preserve": ["d_month_seq between 1192 and 1192 + 23", "cs_ship_date_sk = d_date_sk", "cs_list_price between 86 and 115", "sm_type = 'EXPRESS'", "cc_class = 'small'", "w_gmt_offset = -5"],
        "output_must_preserve": ["All original output columns and grouping"]
      },
      "gates_checked": ["no_or_to_union:PASS", "multiplicity_guard_required:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Dimension scans become tiny CTEs; join order may shift; fact scan remains broad but join cost reduces.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "reorder_joins"],
      "rank_rationale": "Targets join topology; may improve join filter pushdown; gold example shows 2.71x.",
      "recommended_examples": ["multi_dimension_prefetch"],
      "gold_example_id": "multi_dimension_prefetch"
    },
    {
      "probe_id": "p04",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Isolate date_dim filter into a CTE returning only d_date_sk for the month range, then join with catalog_sales using that CTE.",
      "dag_target_hint": "Create date_range CTE with SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1192 AND 1215; replace date_dim join with date_range CTE.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim"],
        "where_must_preserve": ["d_month_seq between 1192 and 1192 + 23", "cs_ship_date_sk = d_date_sk"],
        "output_must_preserve": ["All original columns and semantics"]
      },
      "gates_checked": ["no_or_to_union:PASS", "multiplicity_guard_required:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.70,
      "expected_explain_delta": "Date_dim scan becomes tiny; join filter may push into fact scan; micro‑partition pruning may improve.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Simpler variant of p01; focuses only on date_dim isolation.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p05",
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "target": "Build a staged pipeline: filter date_dim → join with catalog_sales on date key → filter other dimensions → aggregate.",
      "dag_target_hint": "Create date_filtered CTE, then join with catalog_sales, then join remaining dimensions.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "date_dim"],
        "where_must_preserve": ["d_month_seq between 1192 and 1192 + 23", "cs_ship_date_sk = d_date_sk", "cs_list_price between 86 and 115"],
        "output_must_preserve": ["All original columns and grouping"]
      },
      "gates_checked": ["no_or_to_union:PASS", "multiplicity_guard_required:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.72,
      "expected_explain_delta": "Fact rows reduced before joining other dimensions; aggregate cascade may shrink.",
      "recommended_patch_ops": ["insert_cte", "replace_from", "reorder_joins"],
      "rank_rationale": "Staged reduction may compound selectivity; portable candidate.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p06",
      "transform_id": "single_pass_aggregation",
      "family": "C",
      "target": "Consolidate the multi‑stage aggregate cascade into a single GROUP BY that computes all five CASE buckets in one pass.",
      "dag_target_hint": "Replace the cascading aggregate nodes with a single aggregate that computes SUM(CASE ...) for each bucket directly.",
      "node_contract": {
        "from_must_include": ["catalog_sales"],
        "where_must_preserve": ["cs_list_price between 86 and 115"],
        "output_must_preserve": ["Same five bucket sums and grouping keys"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": true,
      "exploration_hypothesis": "Snowflake's internal aggregate cascade may be optimal; testing single‑pass explicit aggregation may reduce compute overhead.",
      "confidence": 0.55,
      "expected_explain_delta": "Fewer aggregate nodes; same final result; possible reduction in compute time.",
      "recommended_patch_ops": ["replace_aggregate", "reorder_group_by"],
      "rank_rationale": "Exploration: targets aggregate cascade hotspot with a different mechanism.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p07",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Materialize the filtered date_dim keys as a CTE to guarantee a single scan and reuse across the query.",
      "dag_target_hint": "WITH date_keys AS (SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1192 AND 1215) SELECT ... FROM catalog_sales JOIN date_keys ON cs_ship_date_sk = d_date_sk ...",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_month_seq between 1192 and 1192 + 23"],
        "output_must_preserve": ["d_date_sk keyset"]
      },
      "gates_checked": ["no_or_to_union:PASS", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Snowflake may inline single‑use CTEs; materialization may force earlier filter application.",
      "confidence": 0.50,
      "expected_explain_delta": "Date_dim scan becomes a separate materialized step; join may reorder.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "rank_rationale": "Exploration: tests CTE materialization impact on join planning.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p08",
      "transform_id": "inner_join_conversion",
      "family": "F",
      "target": "Convert comma‑separated joins to explicit INNER JOIN syntax to give optimizer more join‑order flexibility.",
      "dag_target_hint": "Replace FROM catalog_sales, warehouse, ship_mode, call_center, date_dim WHERE ... with explicit JOIN ON clauses.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "warehouse", "ship_mode", "call_center", "date_dim"],
        "where_must_preserve": ["All original join conditions and filters"],
        "output_must_preserve": ["All original columns and semantics"]
      },
      "gates_checked": ["join_multiplicity_safe:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Explicit JOIN syntax may trigger different cost‑based join reordering in Snowflake, potentially reducing intermediate row‑flow.",
      "confidence": 0.45,
      "expected_explain_delta": "Join order may change; no change in semantics.",
      "recommended_patch_ops": ["replace_from", "reorder_joins"],
      "rank_rationale": "Exploration: join‑topology family; gold example shows 3.44x.",
      "recommended_examples": ["inner_join_conversion"],
      "gold_example_id": "inner_join_conversion"
    },
    {
      "probe_id": "p09",
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "target": "Not applicable; no correlated subquery present. Probe kept for family coverage but will be no‑op.",
      "dag_target_hint": "No change.",
      "node_contract": {
        "from_must_include": [],
        "where_must_preserve": [],
        "output_must_preserve": []
      },
      "gates_checked": ["G_SF_CORR_SCALAR_REQUIRED:FAIL", "G_SF_CORR_SIMPLE_EXISTS_SKIP:PASS"],
      "exploration": true,
      "exploration_hypothesis": "No correlation present; probe serves as a control to confirm no decorrelation opportunity.",
      "confidence": 0.10,
      "expected_explain_delta": "No plan change expected.",
      "recommended_patch_ops": [],
      "rank_rationale": "Exploration: family B underrepresented; confirms absence of correlation.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p10",
      "transform_id": "or_to_union",
      "family": "D",
      "target": "Not applicable; no OR predicate. Probe kept for family coverage.",
      "dag_target_hint": "No change.",
      "node_contract": {
        "from_must_include": [],
        "where_must_preserve": [],
        "output_must_preserve": []
      },
      "gates_checked": ["no_or_to_union:PASS"],
      "exploration": true,
      "exploration_hypothesis": "No OR present; confirms family D not needed.",
      "confidence": 0.10,
      "expected_explain_delta": "No plan change.",
      "recommended_patch_ops": [],
      "rank_rationale": "Exploration: family D underrepresented; confirms no set‑op opportunity.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p11",
      "transform_id": "intersect_to_exists",
      "family": "D",
      "target": "Not applicable; no INTERSECT. Probe kept for family coverage.",
      "dag_target_hint": "No change.",
      "node_contract": {
        "from_must_include": [],
        "where_must_preserve": [],
        "output_must_preserve": []
      },
      "gates_checked": ["no_or_to_union:PASS"],
      "exploration": true,
      "exploration_hypothesis": "No INTERSECT present; confirms family D not needed.",
      "confidence": 0.10,
      "expected_explain_delta": "No plan change.",
      "recommended_patch_ops": [],
      "rank_rationale": "Exploration: family D underrepresented; confirms no set‑op opportunity.",
      "recommended_examples": [],
      "gold_example_id": ""
    },
    {
      "probe_id": "p12",
      "transform_id": "deferred_window_aggregation",
      "family": "C",
      "target": "Not applicable; no window functions. Probe kept for family coverage.",
      "dag_target_hint": "No change.",
      "node_contract": {
        "from_must_include": [],
        "where_must_preserve": [],
        "output_must_preserve": []
      },
      "gates_checked": ["no_or_to_union:PASS"],
      "exploration": true,
      "exploration_hypothesis": "No window functions present; confirms no deferred window opportunity.",
      "confidence": 0.10,
      "expected_explain_delta": "No plan change.",
      "recommended_patch_ops": [],
      "rank_rationale": "Exploration: family C already covered; confirms no window‑specific optimization.",
      "recommended_examples": [],
      "gold_example_id": ""
    }
  ],
  "dropped": [
    {
      "transform_id": "channel_bitmap_aggregation",
      "family": "C",
      "reason": "No multiple channel fact tables (store_sales, catalog_sales, web_sales) present."
    },
    {
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "reason": "No multiple channel fact tables; dimension filters are not shared across channels."
    },
    {
      "transform_id": "composite_decorrelate_union",
      "family": "B",
      "reason": "No correlated subqueries present."
    },
    {
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "reason": "No correlated subqueries present."
    },
    {
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "reason": "No correlated scalar aggregate subqueries present."
    },
    {
      "transform_id": "sf_shared_scan_decorrelate",
      "family": "B",
      "reason": "No correlated subqueries present."
    },
    {
      "transform_id": "union_cte_split",
      "family": "D",
      "reason": "No UNION or repeated CTE scans."
    },
    {
      "transform_id": "rollup_to_union_windowing",
      "family": "D",
      "reason": "No ROLLUP or ranking window functions present."
    },
    {
      "transform_id": "multi_date_range_cte",
      "family": "A",
      "reason": "Date_dim joined only once, not multiple times with different filters."
    },
    {
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "reason": "No self‑join patterns; also engine mismatch (postgresql)."
    },
    {
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "reason": "Engine mismatch (postgresql); Snowflake already uses explicit joins in plan."
    },
    {
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "reason": "Engine mismatch (postgresql); similar to multi_dimension_prefetch but not native."
    },
    {
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "reason": "Engine mismatch (postgresql); no non‑equi joins present."
    },
    {
      "transform_id": "self_join_decomposition",
      "family": "F",
      "reason": "No self‑join patterns."
    }
  ]
}