{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 2,
    "probe_count": 10,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The plan exhibits multiple hotspots including broad scans of large fact tables (CATALOG_SALES, WEB_SALES, STORE_SALES) without effective date-based pruning, and repeated dimension table scans. Predicate transitivity failure prevents date filters from pushing down into fact table scans, leading to excessive data scanning. Early filtering and decorrelation strategies can significantly reduce data volume.",
    "reasoning_trace": [
      "CATALOG_SALES and WEB_SALES scans are extremely large (920GB and 460GB respectively) and lack effective predicate pushdown for date-based pruning.",
      "DATE_DIM filters exist but are not effectively pushed down to fact tables across UNION ALL branches.",
      "Multiple scans of DATE_DIM, CUSTOMER, CUSTOMER_ADDRESS, and ITEM suggest opportunities for early filtering and CTE reuse.",
      "No correlated subqueries detected that require decorrelation."
    ],
    "cost_spine": [
      "UnionAll",
      "TableScan (CATALOG_SALES)",
      "TableScan (WEB_SALES)",
      "InnerJoin",
      "TableScan (DATE_DIM)",
      "TableScan (ITEM)",
      "TableScan (CUSTOMER)"
    ],
    "hotspots": [
      {
        "op": "TableScan (CATALOG_SALES)",
        "why": "extremely large scan without effective predicate pushdown",
        "evidence": "parts=54721/54922 bytes=920184101376"
      },
      {
        "op": "TableScan (WEB_SALES)",
        "why": "large scan without effective predicate pushdown",
        "evidence": "parts=27574/27579 bytes=460956759040"
      },
      {
        "op": "TableScan (STORE_SALES)",
        "why": "large scan without effective predicate pushdown",
        "evidence": "parts=70412/72718 bytes=1212628258304"
      },
      {
        "op": "TableScan (DATE_DIM)",
        "why": "repeated scans suggest early filtering opportunity",
        "evidence": "scanned 3 times with same base size"
      }
    ],
    "do_not_do": [
      "avoid same-column OR to UNION ALL split",
      "avoid unfiltered large CTE introduction",
      "do not materialize EXISTS patterns"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "target": "Push date_sk filter predicates into UNION ALL branches for CATALOG_SALES and WEB_SALES to enable micro-partition pruning.",
      "dag_target_hint": "Modify the UnionAll node and its source scans to include explicit date range filters.",
      "node_contract": {
        "from_must_include": [
          "catalog_sales",
          "web_sales",
          "date_dim"
        ],
        "where_must_preserve": [
          "d_moy = 1",
          "d_year = 1998",
          "wholesale_cost BETWEEN 35 AND 65"
        ],
        "output_must_preserve": [
          "cs_bill_customer_sk",
          "ws_bill_customer_sk",
          "cs_item_sk",
          "ws_item_sk",
          "cs_sold_date_sk",
          "ws_sold_date_sk"
        ]
      },
      "gates_checked": [
        "G_SF_SK_DATE_FILTER_REQUIRED:PASS",
        "G_SF_SK_SCAN_PRESSURE:PASS",
        "G_SF_SK_RANGE_SEMANTICS:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.95,
      "expected_explain_delta": "Date filters pushed into CATALOG_SALES and WEB_SALES scans, reducing scanned bytes significantly via micro-partition pruning.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from",
        "replace_where_predicate"
      ],
      "recommended_examples": [
        "sf_sk_pushdown_union_all"
      ],
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p02",
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "target": "Push date_sk filter predicates to STORE_SALES scan based on date_dim filter to enable micro-partition pruning.",
      "dag_target_hint": "Modify the STORE_SALES scan node to include explicit date range filter.",
      "node_contract": {
        "from_must_include": [
          "store_sales",
          "date_dim"
        ],
        "where_must_preserve": [
          "d_moy = 1",
          "d_year = 1998",
          "ss_wholesale_cost BETWEEN 35 AND 65"
        ],
        "output_must_preserve": [
          "ss_customer_sk",
          "ss_sold_date_sk",
          "ss_ext_sales_price"
        ]
      },
      "gates_checked": [
        "G_SF_SK_DATE_FILTER_REQUIRED:PASS",
        "G_SF_SK_SCAN_PRESSURE:PASS",
        "G_SF_SK_RANGE_SEMANTICS:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.90,
      "expected_explain_delta": "Date filter pushed into STORE_SALES scan, reducing scanned bytes significantly via micro-partition pruning.",
      "recommended_patch_ops": [
        "replace_where_predicate"
      ],
      "recommended_examples": [
        "sf_sk_pushdown_3fact"
      ],
      "gold_example_id": "sf_sk_pushdown_3fact"
    },
    {
      "probe_id": "p03",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Isolate selective ITEM filters into a CTE to reduce repeated scans and improve join efficiency.",
      "dag_target_hint": "Create a new CTE for filtered ITEM and reference it in the main query.",
      "node_contract": {
        "from_must_include": [
          "item"
        ],
        "where_must_preserve": [
          "i_category = 'Electronics'",
          "i_class = 'personal'
        ],
        "output_must_preserve": [
          "i_item_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.80,
      "expected_explain_delta": "ITEM table scanned once into a small CTE, reducing repeated scans and improving join performance.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "duckdb_dimension_cte_isolate_01"
      ]
    },
    {
      "probe_id": "p04",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Prefetch and filter DATE_DIM, CUSTOMER, and CUSTOMER_ADDRESS into CTEs before joining with fact tables.",
      "dag_target_hint": "Create CTEs for each dimension with selective filters and join them with fact tables.",
      "node_contract": {
        "from_must_include": [
          "date_dim",
          "customer",
          "customer_address"
        ],
        "where_must_preserve": [
          "d_moy = 1",
          "d_year = 1998",
          "c_birth_year BETWEEN 1928 AND 1941",
          "ca_state IN ('AR','CO','IA','IL','KY','NC','NM','NY','PA','TX')"
        ],
        "output_must_preserve": [
          "d_date_sk",
          "c_customer_sk",
          "c_current_addr_sk",
          "ca_address_sk",
          "ca_county",
          "ca_state"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Multiple dimension scans reduced to single scans with filters applied early, significantly reducing join input sizes.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from",
        "replace_where_predicate"
      ],
      "recommended_examples": [
        "duckdb_multi_dimension_prefetch_01"
      ]
    },
    {
      "probe_id": "p05",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Push aggregation below join in my_revenue CTE by pre-aggregating STORE_SALES by customer key.",
      "dag_target_hint": "Modify my_revenue CTE to aggregate STORE_SALES before joining with other tables.",
      "node_contract": {
        "from_must_include": [
          "store_sales"
        ],
        "where_must_preserve": [
          "ss_wholesale_cost BETWEEN 35 AND 65"
        ],
        "output_must_preserve": [
          "ss_customer_sk",
          "revenue (sum of ss_ext_sales_price)"
        ]
      },
      "gates_checked": [
        "agg_key_compatibility:PASS",
        "duplication_sensitive_metrics:none"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Rows into final aggregate and join reduce due to earlier grouping of STORE_SALES.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "duckdb_agg_pushdown_fact_key_01"
      ],
      "gold_example_id": "duckdb_agg_pushdown_fact_key_01"
    },
    {
      "probe_id": "p06",
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "target": "Extract shared DATE_DIM and ITEM filters into a single CTE and reference it from both CATALOG_SALES and WEB_SALES branches.",
      "dag_target_hint": "Create shared CTEs for DATE_DIM and ITEM filters and use them in the UnionAll branches.",
      "node_contract": {
        "from_must_include": [
          "date_dim",
          "item"
        ],
        "where_must_preserve": [
          "d_moy = 1",
          "d_year = 1998",
          "i_category = 'Electronics'",
          "i_class = 'personal'"
        ],
        "output_must_preserve": [
          "d_date_sk",
          "i_item_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Shared dimension filters can reduce redundant scans in multi-channel UNION ALL branches.",
      "confidence": 0.65,
      "expected_explain_delta": "Redundant scans of DATE_DIM and ITEM eliminated by sharing pre-filtered CTEs across channels.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from",
        "replace_where_predicate"
      ],
      "recommended_examples": [
        "duckdb_shared_dimension_multi_channel_01"
      ]
    },
    {
      "probe_id": "p07",
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "target": "Build a CTE chain that progressively reduces data: first filter DATE_DIM, then pre-join with CATALOG_SALES and WEB_SALES.",
      "dag_target_hint": "Create a chain of CTEs starting with DATE_DIM filter, then joining with fact tables.",
      "node_contract": {
        "from_must_include": [
          "date_dim",
          "catalog_sales",
          "web_sales"
        ],
        "where_must_preserve": [
          "d_moy = 1",
          "d_year = 1998",
          "cs_wholesale_cost BETWEEN 35 AND 65",
          "ws_wholesale_cost BETWEEN 35 AND 65"
        ],
        "output_must_preserve": [
          "cs_bill_customer_sk",
          "ws_bill_customer_sk",
          "cs_item_sk",
          "ws_item_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Staged join pipeline can reduce data volume early by filtering and joining dimensions before fact table expansion.",
      "confidence": 0.60,
      "expected_explain_delta": "Data volume reduced early through staged filtering and joining, leading to smaller intermediate results.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from",
        "replace_where_predicate"
      ],
      "recommended_examples": [
        "duckdb_prefetch_fact_join_01"
      ]
    },
    {
      "probe_id": "p08",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Materialize the my_customers CTE to avoid recomputation when referenced in my_revenue.",
      "dag_target_hint": "Ensure my_customers CTE is computed once and reused.",
      "node_contract": {
        "from_must_include": [
          "catalog_sales",
          "web_sales",
          "item",
          "date_dim",
          "customer"
        ],
        "where_must_preserve": [
          "d_moy = 1",
          "d_year = 1998",
          "i_category = 'Electronics'",
          "i_class = 'personal'",
          "wholesale_cost BETWEEN 35 AND 65",
          "c_birth_year BETWEEN 1928 AND 1941"
        ],
        "output_must_preserve": [
          "c_customer_sk",
          "c_current_addr_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Materializing my_customers CTE can prevent redundant computation if Snowflake chooses to inline it.",
      "confidence": 0.55,
      "expected_explain_delta": "my_customers CTE computed once and reused, potentially reducing overall query execution time.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "duckdb_materialize_cte_01"
      ]
    },
    {
      "probe_id": "p09",
      "transform_id": "date_cte_isolate",
      "family": "A",
      "target": "Isolate DATE_DIM filters into a CTE to create a small hash table for efficient joining.",
      "dag_target_hint": "Create a CTE for filtered DATE_DIM and use it in joins.",
      "node_contract": {
        "from_must_include": [
          "date_dim"
        ],
        "where_must_preserve": [
          "d_moy = 1",
          "d_year = 1998"
        ],
        "output_must_preserve": [
          "d_date_sk",
          "d_month_seq"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Isolating DATE_DIM filters can improve join performance by creating a small, efficient hash table.",
      "confidence": 0.50,
      "expected_explain_delta": "DATE_DIM scanned once into a small CTE, improving join efficiency with fact tables.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from",
        "replace_where_predicate"
      ],
      "recommended_examples": [
        "duckdb_date_cte_isolate_01"
      ]
    },
    {
      "probe_id": "p10",
      "transform_id": "early_filter",
      "family": "A",
      "target": "Apply early filtering on CUSTOMER table based on birth year before joining.",
      "dag_target_hint": "Modify CUSTOMER scan to include birth year filter.",
      "node_contract": {
        "from_must_include": [
          "customer"
        ],
        "where_must_preserve": [
          "c_birth_year BETWEEN 1928 AND 1941"
        ],
        "output_must_preserve": [
          "c_customer_sk",
          "c_current_addr_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Filtering CUSTOMER table early can reduce the number of rows entering the join with fact tables.",
      "confidence": 0.45,
      "expected_explain_delta": "CUSTOMER table scan reduced by applying birth year filter early.",
      "recommended_patch_ops": [
        "replace_where_predicate"
      ],
      "recommended_examples": [
        "duckdb_early_filter_01"
      ]
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan evidence."
    },
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated subquery hotspot in plan evidence."
    },
    {
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "reason": "No correlated scalar aggregate subquery detected."
    },
    {
      "transform_id": "sf_shared_scan_decorrelate",
      "family": "B",
      "reason": "No correlated scalar aggregate subquery with shared scan detected."
    }
  ]
}