{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The query performs full scans of large fact tables (store_sales, catalog_sales, store_returns) because date range predicates are not pushed down to the fact table level, limiting micro-partition pruning. Adding explicit date_sk BETWEEN clauses based on date_dim filters could prune partitions early. Additionally, aggregation is done after joining, but pre-aggregating fact tables on join keys could reduce row volume entering the joins.",
    "reasoning_trace": [
      "STORE_SALES scan bytes=1.2TB indicates full table scan without effective predicate pushdown.",
      "DATE_DIM filters are selective (parts=1/1) but not directly applied to fact table scans in the plan.",
      "Aggregation operators appear after large joins, suggesting late reduction in row flow.",
      "No correlated subqueries or nested loops, simplifying optimization focus to early filtering and aggregation pushdown."
    ],
    "cost_spine": ["TableScan (STORE_SALES)", "TableScan (CATALOG_SALES)", "TableScan (STORE_RETURNS)", "InnerJoin", "Aggregate"],
    "hotspots": [
      {
        "op": "TableScan (STORE_SALES)",
        "why": "largest I/O volume, full scan without date predicate pruning",
        "evidence": "parts=70412/72718 bytes=1212628258304"
      },
      {
        "op": "TableScan (CATALOG_SALES)",
        "why": "second largest I/O volume, similar lack of predicate pushdown",
        "evidence": "parts=54721/54922 bytes=920184101376"
      },
      {
        "op": "TableScan (STORE_RETURNS)",
        "why": "significant I/O volume, predicate not pushed to scan",
        "evidence": "parts=7070/7070 bytes=124763446272"
      }
    ],
    "do_not_do": [
      "avoid wrapping date_sk or filter columns in functions to preserve micro-partition pruning",
      "avoid materializing EXISTS/NOT EXISTS patterns as they are already optimized in Snowflake",
      "avoid introducing unfiltered large CTEs that increase intermediate data"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "target": "Add explicit date_sk BETWEEN predicates to store_sales, catalog_sales, and store_returns based on d1, d2, d3 filters to enable micro-partition pruning.",
      "dag_target_hint": "Modify WHERE clauses of fact table scans in final_select.",
      "node_contract": {
        "from_must_include": ["store_sales", "catalog_sales", "store_returns", "date_dim d1", "date_dim d2", "date_dim d3"],
        "where_must_preserve": ["d1.d_moy = 3", "d1.d_year = 1999", "d2.d_moy between 3 and 5", "d2.d_year = 1999", "d3.d_moy between 3 and 5", "d3.d_year = 1999"],
        "output_must_preserve": ["i_item_id", "i_item_desc", "s_store_id", "s_store_name", "max(ss_net_profit)", "max(sr_net_loss)", "max(cs_net_profit)", "GROUP BY and ORDER BY columns", "LIMIT 100"]
      },
      "gates_checked": ["G_SF_SK_DATE_FILTER_REQUIRED:PASS", "G_SF_SK_SCAN_PRESSURE:PASS", "G_SF_SK_COMPUTE_BOUND_SKIP:PASS", "G_SF_SK_RANGE_SEMANTICS:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Fact table scans show reduced partitions read due to date_sk BETWEEN predicate pushdown.",
      "recommended_patch_ops": ["add_predicate_to_scan", "replace_where_clause"],
      "recommended_examples": ["sf_sk_pushdown_union_all"],
      "rank_rationale": "Targets primary hotspot with direct evidence of missing predicate pushdown and high expected impact.",
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p02",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate store_sales by ss_item_sk, ss_store_sk, ss_customer_sk, ss_ticket_number, ss_sold_date_sk to compute max(ss_net_profit) before joining with other tables.",
      "dag_target_hint": "Insert CTE for pre-aggregated store_sales and adjust final_select FROM clause.",
      "node_contract": {
        "from_must_include": ["store_sales"],
        "where_must_preserve": ["d1.d_moy = 3", "d1.d_year = 1999"],
        "output_must_preserve": ["grouping key compatibility with item and store dimensions", "max(ss_net_profit) aggregation"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Aggregate operator moves closer to store_sales scan, reducing input rows to subsequent joins.",
      "recommended_patch_ops": ["insert_cte", "replace_from"],
      "recommended_examples": ["aggregate_pushdown"],
      "rank_rationale": "Addresses store_sales hotspot by reducing row flow early with moderate confidence.",
      "gold_example_id": "aggregate_pushdown"
    },
    {
      "probe_id": "p03",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate catalog_sales by cs_bill_customer_sk, cs_item_sk, cs_sold_date_sk to compute max(cs_net_profit) before joining with other tables.",
      "dag_target_hint": "Insert CTE for pre-aggregated catalog_sales and adjust final_select FROM clause.",
      "node_contract": {
        "from_must_include": ["catalog_sales"],
        "where_must_preserve": ["d3.d_moy between 3 and 5", "d3.d_year = 1999"],
        "output_must_preserve": ["grouping key compatibility with store_returns and other joins", "max(cs_net_profit) aggregation"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Aggregate operator moves closer to catalog_s