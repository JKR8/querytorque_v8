```json
{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 1,
    "probe_count": 4,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The query performs a star-schema join across catalog_sales, inventory, and multiple dimensions with three date_dim joins and non-equi conditions (inv_quantity_on_hand < cs_quantity). Without detailed plan metrics, primary bottlenecks likely include large fact-table scans without micro-partition pruning due to complex multi-date join conditions, and potential join amplification from inventory-to-catalog_sales non-equi join. Early filtering and predicate pushdown opportunities exist across dimension tables.",
    "reasoning_trace": [
      "Three date_dim joins (d1,d2,d3) with different filters create complex predicate propagation challenges",
      "Non-equi join condition (inv_quantity_on_hand < cs_quantity) may cause row amplification",
      "Multiple dimension filters (hd_buy_potential, cd_marital_status, i_category, cs_wholesale_cost) could benefit from early reduction",
      "Snowflake's strength in micro-partition pruning may be hindered by date_sk join indirection",
      "Aggregation happens after all joins, potentially after significant row inflation"
    ],
    "cost_spine": ["Scan catalog_sales", "Join inventory", "Join date_dim d1,d2,d3", "Join dimensions", "Aggregate", "Sort+Limit"],
    "hotspots": [
      {
        "op": "catalog_sales scan",
        "why": "largest fact table with multiple date joins complicating predicate pushdown",
        "evidence": "primary fact table in star-schema with 3 date_dim joins and non-equi condition"
      },
      {
        "op": "inventory-to-catalog_sales join",
        "why": "non-equi join condition may amplify rows before aggregation",
        "evidence": "inv_quantity_on_hand < cs_quantity predicate can't use hash join efficiently"
      },
      {
        "op": "multiple date_dim joins",
        "why": "three separate date_dim joins with different filters create predicate propagation complexity",
        "evidence": "d1.d_year=1999, d1.d_week_seq=d2.d_week_seq, d3.d_date > d1.d_date+3"
      }
    ],
    "do_not_do": [
      "avoid converting left joins to inner joins (promotion and catalog_returns are correctly left outer)",
      "avoid OR-to-UNION decomposition (no OR predicates in query)",
      "avoid decorrelation transforms (no correlated subqueries present)"
    ]
  },
  "probe_summary_schema": ["probe_id", "transform_id", "family", "expected_explain_delta", "confidence", "exploration", "rank_rationale", "target", "dag_target_hint", "recommended_patch_ops", "recommended_examples"],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "target": "Add explicit date_sk BETWEEN filters to catalog_sales and inventory joins by computing date_sk ranges from date_dim filters before the main query",
      "dag_target_hint": "Add CTEs for d1_range, d2_range, d3_range with date_sk bounds, then join with BETWEEN conditions",
      "node_contract": {
        "from_must_include": ["catalog_sales cs", "inventory inv", "date_dim d1", "date_dim d2", "date_dim d3"],
        "where_must_preserve": ["d1.d_year = 1999", "d1.d_week_seq = d2.d_week_seq", "d3.d_date > d1.d_date + interval '3 day'", "inv_quantity_on_hand < cs_quantity"],
        "output_must_preserve": ["all original output columns, aggregations, and order semantics"]
      },
      "gates_checked": ["G_SF_SK_DATE_FILTER_REQUIRED:PASS", "G_SF_SK_SCAN_PRESSURE:PASS", "G_SF_SK_RANGE_SEMANTICS:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Micro-partition pruning on catalog_sales and inventory via date_sk range predicates reducing scan volume",
      "recommended_patch_ops": ["insert_cte", "modify_join_predicate", "add_between_filter"],
      "rank_rationale": "Primary probe targeting largest fact-table scan with date_sk pushdown pattern known to work in Snowflake",
      "recommended_examples": ["sf_sk_pushdown_union_all"],
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p02",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Create CTEs for all selective dimension filters (customer_demographics, household_demographics, item, warehouse, promotion) before joining to fact tables",
      "dag_target_hint": "Add filtered_dimensions CTE containing all dimension surrogate keys with filters applied early",
      "node_contract": {
        "from_must_include": ["customer_demographics cd", "household_demographics hd", "item i", "warehouse w"],
        "where_must_preserve": ["hd_buy_potential = '>10000'", "cd_marital_status = 'S'", "cd_dep_count between 9 and 11", "i_category IN ('Men', 'Shoes', 'Sports')"],
        "output_must_preserve": ["all join relationships and final output columns"]
      },
      "gates_checked": ["G_SF_CTE_REUSE_RULE:PASS", "G_SF_FILTER_FUNCTION_WRAP:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Snowflake may not push all dimension filters early enough; pre-materializing filtered dimension keys could reduce fact-table join work",
      "confidence": 0.65,
      "expected_explain_delta": "Smaller hash tables for dimension joins and earlier row reduction before fact-table scans",
      "recommended_patch_ops": ["insert_cte", "replace_dimension_scans"],
      "rank_rationale": "Exploration probe targeting early dimension filtering to reduce join amplification",
      "recommended_examples": ["multi_dimension_prefetch"],
      "gold_example_id": "multi_dimension_prefetch"
    },
    {
      "probe_id": "p03",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate catalog_sales by item, warehouse, and week_seq before joining with dimensions, preserving all necessary join keys and aggregates",
      "dag_target_hint": "Create pre_aggregated_sales CTE with partial aggregation on (cs_item_sk, inv_warehouse_sk, d_week_seq)",
      "node_contract": {
        "from_must_include": ["catalog_sales cs", "inventory inv", "date_dim d1"],
        "where_must_preserve": ["d1.d_year = 1999", "inv_quantity_on_hand < cs_quantity"],
        "output_must_preserve": ["Grouping keys (i_item_desc, w_warehouse_name, d_week_seq) and aggregation correctness for promo/no_promo counts"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Aggregation happens earlier in plan, reducing rows flowing through dimension joins",
      "recommended_patch_ops": ["insert_cte", "replace_from", "reaggregate"],
      "rank_rationale": "Targets aggregation-after-join pattern by pushing aggregation earlier in the pipeline",
      "recommended_examples": ["aggregate_pushdown"],
      "gold_example_id": "aggregate_pushdown"
    },
    {
      "probe_id": "p04",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Materialize the inventory-catalog_sales join with date filters as a CTE to avoid recomputing the non-equi join multiple times",
      "dag_target_hint": "Create fact_join CTE containing filtered inventory and catalog_sales with date conditions already applied",
      "node_contract": {
        "from_must_include": ["catalog_sales cs", "inventory inv", "date_dim d1", "date_dim d2"],
        "where_must_preserve": ["inv_quantity_on_hand < cs_quantity", "d1.d_week_seq = d2.d_week_seq", "d1.d_year = 1999"],
        "output_must_preserve": ["All columns needed for downstream joins and aggregation"]
      },
      "gates_checked": ["G_SF_CTE_REUSE_RULE:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Materializing the complex non-equi join may allow Snowflake to better optimize downstream dimension joins",
      "confidence": 0.60,
      "expected_explain_delta": "Single materialization of expensive non-equi join reused for all dimension joins",
      "recommended_patch_ops": ["insert_cte", "materialize_join"],
      "rank_rationale": "Exploration probe targeting non-equi join hotspot with materialization strategy",
      "recommended_examples": [],
      "gold_example_id": ""
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate in query; pattern mismatch"
    },
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "No correlated subqueries in query; pattern mismatch"
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT operations in query; pattern mismatch"
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "Left joins (promotion, catalog_returns) are correctly left outer and not filtered in WHERE"
    },
    {
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "reason": "No correlated scalar subqueries with aggregation in query"
    }
  ]
}
```