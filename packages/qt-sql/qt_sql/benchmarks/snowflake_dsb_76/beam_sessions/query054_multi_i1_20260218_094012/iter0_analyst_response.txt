{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 2,
    "probe_count": 6,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "The plan exhibits repeated scans of large fact tables (catalog_sales, web_sales, store_sales) without early partition pruning, and multiple CTEs perform similar filtering. Predicate pushdown into UNION ALL branches and dimension prefetching can reduce I/O and repeated work. A secondary opportunity exists in decorrelating scalar subqueries used in date range filtering.",
    "reasoning_trace": [
      "Multiple large fact table scans (catalog_sales, web_sales, store_sales) lack explicit date_sk range pushdown, missing micro-partition pruning.",
      "Repeated dimension table scans (date_dim, item, customer) suggest opportunity for CTE prefetch to reduce redundancy.",
      "Subqueries for d_month_seq use scalar aggregation and may not be decorrelated efficiently by the engine.",
      "No nested loops or severe estimate mismatches observed, but scan volume is high."
    ],
    "cost_spine": [
      "UnionAll",
      "TableScan (CATALOG_SALES)",
      "TableScan (WEB_SALES)",
      "InnerJoin",
      "Aggregate",
      "TableScan (STORE_SALES)"
    ],
    "hotspots": [
      {
        "op": "TableScan (CATALOG_SALES)",
        "why": "large fact table without explicit date_sk pruning",
        "evidence": "parts=54721/54922 bytes=920184101376"
      },
      {
        "op": "TableScan (WEB_SALES)",
        "why": "large fact table without explicit date_sk pruning",
        "evidence": "parts=27574/27579 bytes=460956759040"
      },
      {
        "op": "TableScan (STORE_SALES)",
        "why": "large fact table without early pruning",
        "evidence": "parts=70412/72718 bytes=1212628258304"
      }
    ],
    "do_not_do": [
      "avoid EXISTS materialization into broad CTEs",
      "do not remove effective join filters without replacement",
      "do not introduce wide CTEs without clear reuse benefit"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "target": "Push date_sk range filters into each branch of the UNION ALL between catalog_sales and web_sales to enable micro-partition pruning.",
      "dag_target_hint": "Modify the cs_or_ws_sales CTE to include explicit date_sk BETWEEN predicates derived from date_dim filter.",
      "node_contract": {
        "from_must_include": [
          "catalog_sales",
          "web_sales",
          "date_dim"
        ],
        "where_must_preserve": [
          "d_moy = 1",
          "d_year = 1998"
        ],
        "output_must_preserve": [
          "sold_date_sk",
          "customer_sk",
          "item_sk",
          "wholesale_cost"
        ]
      },
      "gates_checked": [
        "G_SF_SK_DATE_FILTER_REQUIRED:PASS",
        "G_SF_SK_SCAN_PRESSURE:PASS",
        "G_SF_SK_RANGE_SEMANTICS:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.92,
      "expected_explain_delta": "Each fact table scan in UNION ALL branches prunes partitions using explicit date_sk range, reducing I/O.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from",
        "replace_where_predicate"
      ],
      "recommended_examples": [
        "sf_sk_pushdown_union_all"
      ],
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p02",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre-filter item, date_dim, and customer tables into dedicated CTEs before joining with fact tables to reduce repeated scans.",
      "dag_target_hint": "Create dedicated CTEs for filtered item, date_dim, and customer before the cs_or_ws_sales join.",
      "node_contract": {
        "from_must_include": [
          "item",
          "date_dim",
          "customer"
        ],
        "where_must_preserve": [
          "i_category = 'Electronics'",
          "i_class = 'personal'",
          "d_moy = 1",
          "d_year = 1998",
          "c_birth_year BETWEEN 1928 AND 1941"
        ],
        "output_must_preserve": [
          "i_item_sk",
          "d_date_sk",
          "c_customer_sk",
          "c_current_addr_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Dimension tables scanned once and reused, reducing total scan volume and enabling smaller hash tables in joins.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "multi_dimension_prefetch"
      ]
    },
    {
      "probe_id": "p03",
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "target": "Decompose the scalar subquery used to compute d_month_seq range into precomputed CTEs to avoid repeated execution.",
      "dag_target_hint": "Rewrite the d_month_seq subqueries in my_revenue as precomputed CTEs joined via range filter.",
      "node_contract": {
        "from_must_include": [
          "date_dim"
        ],
        "where_must_preserve": [
          "d_year = 1998",
          "d_moy = 1"
        ],
        "output_must_preserve": [
          "d_month_seq range for BETWEEN filter"
        ]
      },
      "gates_checked": [
        "G_SF_CORR_SCALAR_REQUIRED:PASS",
        "G_SF_CORR_SEMANTIC_KEYS:PASS"
      ],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.88,
      "expected_explain_delta": "Subquery execution replaced with single precomputed range value, avoiding repeated scalar aggregation.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "sf_inline_decorrelate"
      ],
      "gold_example_id": "sf_inline_decorrelate"
    },
    {
      "probe_id": "p04",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate store_sales by customer_sk before joining with customer_address and store to reduce join input volume.",
      "dag_target_hint": "Modify my_revenue CTE to pre-aggregate store_sales by customer_sk before dimension joins.",
      "node_contract": {
        "from_must_include": [
          "store_sales"
        ],
        "where_must_preserve": [
          "ss_wholesale_cost BETWEEN 35 AND 65"
        ],
        "output_must_preserve": [
          "ss_customer_sk",
          "revenue (sum of ss_ext_sales_price)"
        ]
      },
      "gates_checked": [
        "agg_key_compatibility:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "store_sales is large and joins multiple dimensions; pre-aggregation may reduce intermediate row volume.",
      "confidence": 0.72,
      "expected_explain_delta": "store_sales rows reduced via early grouping, lowering join and filter cost in downstream operations.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "aggregate_pushdown"
      ],
      "gold_example_id": "aggregate_pushdown"
    },
    {
      "probe_id": "p05",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Materialize the my_customers CTE to prevent repeated evaluation when joined in my_revenue.",
      "dag_target_hint": "Add MATERIALIZED keyword or ensure my_customers is computed once and reused.",
      "node_contract": {
        "from_must_include": [
          "catalog_sales",
          "web_sales",
          "item",
          "date_dim",
          "customer"
        ],
        "where_must_preserve": [
          "i_category = 'Electronics'",
          "i_class = 'personal'",
          "d_moy = 1",
          "d_year = 1998",
          "wholesale_cost BETWEEN 35 AND 65",
          "c_birth_year BETWEEN 1928 AND 1941"
        ],
        "output_must_preserve": [
          "c_customer_sk",
          "c_current_addr_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "my_customers CTE may be evaluated multiple times; materialization ensures single execution.",
      "confidence": 0.65,
      "expected_explain_delta": "CTE computed once and reused, avoiding redundant scan and join work.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "materialize_cte"
      ]
    },
    {
      "probe_id": "p06",
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "target": "Extract shared date_dim and item filters into a single CTE and reference from both catalog_sales and web_sales branches.",
      "dag_target_hint": "Create shared filtered CTEs for date_dim and item, referenced by both UNION ALL branches.",
      "node_contract": {
        "from_must_include": [
          "date_dim",
          "item"
        ],
        "where_must_preserve": [
          "d_moy = 1",
          "d_year = 1998",
          "i_category = 'Electronics'",
          "i_class = 'personal'"
        ],
        "output_must_preserve": [
          "d_date_sk",
          "i_item_sk"
        ]
      },
      "gates_checked": [
        "no_or_to_union:PASS"
      ],
      "exploration": true,
      "exploration_hypothesis": "Shared filters on date_dim and item are applied in both UNION branches; shared CTE avoids duplicate scans.",
      "confidence": 0.68,
      "expected_explain_delta": "Dimension tables scanned once and reused across UNION ALL branches, reducing total scan volume.",
      "recommended_patch_ops": [
        "insert_cte",
        "replace_from"
      ],
      "recommended_examples": [
        "shared_dimension_multi_channel"
      ]
    }
  ],
  "dropped": [
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicates detected in plan that would benefit from decomposition."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT operations present in query structure."
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "No LEFT JOIN followed by WHERE NOT NULL pattern detected."
    }
  ]
}