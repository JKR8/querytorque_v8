{
  "dispatch": {
    "dialect": "snowflake",
    "importance_stars": 3,
    "probe_count": 12,
    "early_stop": false,
    "equivalence_tier": "unordered",
    "hypothesis": "Query scans store_sales three times (7TB total) with late filtering after join amplification, and runs correlated subquery threshold in best_ss_customer that rescans aggregated store_sales per customer group. Early filtering via date_sk pushdown and decorrelation of threshold subquery will reduce fact scans. Materializing reusable CTEs can eliminate repeated dimension scans.",
    "reasoning_trace": [
      "Primary cost spine: three full store_sales scans (parts=72718) each ~1.2TB, plus catalog_sales (54922 parts) and web_sales (27579 parts).",
      "Date_dim filters (d_year=1998) exist but sold_date_sk range not pushed into fact scans across UNION branches (PREDICATE_TRANSITIVITY_FAILURE).",
      "best_ss_customer CTE contains correlated scalar subquery ((95/100)*max_store_sales) forcing repeated evaluation per customer group (CORRELATED_SUBQUERY_PARALYSIS).",
      "Multiple CTEs (frequent_ss_items, best_ss_customer) referenced twice each but not materialized, causing recomputation.",
      "Anti-padding guard: item and date_dim scans show parts=1-2, already fully pruned; targeting them yields minimal gain."
    ],
    "cost_spine": ["TableScan (STORE_SALES) x3", "TableScan (CATALOG_SALES)", "TableScan (WEB_SALES)", "Aggregate (multiple levels)", "SemiJoin (frequent_ss_items, best_ss_customer)"],
    "hotspots": [
      {
        "op": "TableScan (STORE_SALES) in max_store_sales path",
        "why": "full scan without date_sk pushdown, feeds correlated subquery threshold",
        "evidence": "parts=72718/72718 bytes=1251924090880"
      },
      {
        "op": "TableScan (STORE_SALES) in frequent_ss_items path",
        "why": "full scan without date_sk pushdown, later filtered by date_dim",
        "evidence": "parts=70412/72718 bytes=1212628258304"
      },
      {
        "op": "TableScan (STORE_SALES) in best_ss_customer path",
        "why": "full scan without date_sk pushdown, feeds aggregation then correlated filter",
        "evidence": "parts=72718/72718 bytes=1251924090880"
      },
      {
        "op": "Correlated subquery threshold in best_ss_customer",
        "why": "scalar subquery (max_store_sales) re-executed per customer group",
        "evidence": "Filter expr=... > ((95/100)*Subquery(Step1)) at node 2.34"
      }
    ],
    "do_not_do": [
      "avoid wrapping date_sk in functions (breaks micro-partition pruning)",
      "avoid converting EXISTS semi-joins to CTEs (Snowflake already optimizes)",
      "avoid introducing unfiltered large CTEs",
      "avoid same-column OR to UNION ALL (no OR predicate hotspot)"
    ]
  },
  "probe_summary_schema": [
    "probe_id",
    "transform_id",
    "family",
    "expected_explain_delta",
    "confidence",
    "exploration",
    "rank_rationale",
    "target",
    "dag_target_hint",
    "recommended_patch_ops",
    "recommended_examples"
  ],
  "probes": [
    {
      "probe_id": "p01",
      "transform_id": "sf_sk_pushdown_union_all",
      "family": "A",
      "target": "Push date_sk BETWEEN derived from date_dim filters (d_year=1998, d_moy=10) into catalog_sales and web_sales scans in the UNION ALL branches of final_select.",
      "dag_target_hint": "Add date_sk range filter directly on catalog_sales and web_sales before joining date_dim.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "web_sales", "date_dim"],
        "where_must_preserve": ["d_year = 1998", "d_moy = 10", "cs_wholesale_cost BETWEEN 11 AND 21", "ws_wholesale_cost BETWEEN 11 AND 21"],
        "output_must_preserve": ["cs_item_sk in (select item_sk from frequent_ss_items)", "cs_bill_customer_sk in (select c_customer_sk from best_ss_customer)", "ws_item_sk in (select item_sk from frequent_ss_items)", "ws_bill_customer_sk in (select c_customer_sk from best_ss_customer)"]
      },
      "gates_checked": ["G_SF_SK_DATE_FILTER_REQUIRED:PASS", "G_SF_SK_SCAN_PRESSURE:PASS", "G_SF_SK_COMPUTE_BOUND_SKIP:PASS", "G_SF_SK_RANGE_SEMANTICS:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.90,
      "expected_explain_delta": "catalog_sales and web_sales TableScan show micro-partition pruning on date_sk range, reducing scanned bytes.",
      "recommended_patch_ops": ["add_predicate_to_fact_scan", "derive_sk_range_from_dim"],
      "recommended_examples": ["sf_sk_pushdown_union_all"],
      "rank_rationale": "Targets largest fact scans (catalog_sales 923GB, web_sales 461GB) with native Snowflake pushdown transform.",
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p02",
      "transform_id": "sf_inline_decorrelate",
      "family": "B",
      "target": "Decorrelate scalar subquery (max_store_sales) in best_ss_customer by extracting threshold into a separate CTE and joining via key.",
      "dag_target_hint": "Replace correlated scalar subquery with precomputed max(csales) CTE, then join threshold via cross join or CTE reference.",
      "node_contract": {
        "from_must_include": ["store_sales", "customer", "date_dim"],
        "where_must_preserve": ["ss_customer_sk = c_customer_sk", "ss_sold_date_sk = d_date_sk", "d_year = 1998", "ss_wholesale_cost BETWEEN 11 AND 21", "c_birth_year BETWEEN 1934 AND 1940"],
        "output_must_preserve": ["c_customer_sk", "sum(ss_quantity*ss_sales_price) > (95/100)*threshold"]
      },
      "gates_checked": ["G_SF_CORR_SCALAR_REQUIRED:PASS", "G_SF_CORR_SIMPLE_EXISTS_SKIP:PASS", "G_SF_CORR_FACT_CONTEXT:PASS", "G_SF_CORR_SEMANTIC_KEYS:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.85,
      "expected_explain_delta": "Correlated subquery filter node replaced with static threshold join, removing repeated evaluation.",
      "recommended_patch_ops": ["extract_subquery_to_cte", "replace_scalar_subquery_with_join"],
      "recommended_examples": ["sf_inline_decorrelate"],
      "rank_rationale": "Targets correlated subquery hotspot that forces repeated aggregation rescans.",
      "gold_example_id": "sf_inline_decorrelate"
    },
    {
      "probe_id": "p03",
      "transform_id": "aggregate_pushdown",
      "family": "C",
      "target": "Pre-aggregate store_sales by customer_sk before joining with customer in max_store_sales and best_ss_customer CTEs.",
      "dag_target_hint": "Push group by c_customer_sk/ss_customer_sk down below the join with date_dim.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim"],
        "where_must_preserve": ["ss_sold_date_sk = d_date_sk", "d_year = 1998", "ss_wholesale_cost BETWEEN 11 AND 21"],
        "output_must_preserve": ["c_customer_sk", "sum(ss_quantity*ss_sales_price)"]
      },
      "gates_checked": ["agg_key_compatibility:PASS", "duplication_sensitive_metrics:none"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.75,
      "expected_explain_delta": "Aggregate nodes move earlier in plan, reducing rows flowing into customer join.",
      "recommended_patch_ops": ["rewrite_cte_aggregation", "push_group_by_below_join"],
      "recommended_examples": ["aggregate_pushdown"],
      "rank_rationale": "Reduces row amplification before large customer join in max_store_sales and best_ss_customer.",
      "gold_example_id": "aggregate_pushdown"
    },
    {
      "probe_id": "p04",
      "transform_id": "sf_sk_pushdown_multi_fact",
      "family": "A",
      "target": "Push date_sk BETWEEN derived from d_year=1998 into all store_sales scans (three CTEs) via explicit join condition.",
      "dag_target_hint": "Add sold_date_sk range predicate directly on store_sales scans in frequent_ss_items, max_store_sales, and best_ss_customer CTEs.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim"],
        "where_must_preserve": ["ss_sold_date_sk = d_date_sk", "d_year = 1998"],
        "output_must_preserve": ["All existing group by and filter predicates"]
      },
      "gates_checked": ["G_SF_SK_DATE_FILTER_REQUIRED:PASS", "G_SF_SK_SCAN_PRESSURE:PASS", "G_SF_SK_COMPUTE_BOUND_SKIP:PASS", "G_SF_SK_RANGE_SEMANTICS:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.88,
      "expected_explain_delta": "store_sales TableScan nodes show micro-partition pruning on date_sk range, reducing each ~1.2TB scan.",
      "recommended_patch_ops": ["add_predicate_to_fact_scan", "derive_sk_range_from_dim"],
      "recommended_examples": ["sf_sk_pushdown_union_all", "sf_sk_pushdown_3fact"],
      "rank_rationale": "Targets three store_sales scans (largest I/O) with native pushdown; complementary to p01.",
      "gold_example_id": "sf_sk_pushdown_union_all"
    },
    {
      "probe_id": "p05",
      "transform_id": "materialize_cte",
      "family": "E",
      "target": "Materialize frequent_ss_items and best_ss_customer CTEs to avoid recomputation (each referenced twice).",
      "dag_target_hint": "Add MATERIALIZED keyword to WITH clause definitions of frequent_ss_items and best_ss_customer.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim", "item", "customer"],
        "where_must_preserve": ["All original CTE filter and join conditions"],
        "output_must_preserve": ["All CTE output columns and semantics"]
      },
      "gates_checked": ["G_SF_CTE_REUSE_RULE:PASS", "multi_ref_cte:PASS"],
      "exploration": false,
      "exploration_hypothesis": "",
      "confidence": 0.70,
      "expected_explain_delta": "CTE scans become materialized nodes, eliminating duplicate computation subtrees.",
      "recommended_patch_ops": ["add_materialized_keyword"],
      "recommended_examples": [],
      "rank_rationale": "Eliminates duplicate computation of two CTEs each referenced twice.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p06",
      "transform_id": "multi_dimension_prefetch",
      "family": "A",
      "target": "Pre-filter date_dim, item, and customer into separate CTEs before joining with store_sales to reduce fact scan rows via early key reduction.",
      "dag_target_hint": "Create filtered dimension CTEs (date_dim_filtered, item_filtered, customer_filtered) and join them with store_sales in each CTE.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim", "item", "customer"],
        "where_must_preserve": ["d_year=1998", "i_manager_id BETWEEN 81 and 100", "i_category IN ('Children','Men','Sports')", "c_birth_year BETWEEN 1934 AND 1940", "ss_wholesale_cost BETWEEN 11 AND 21"],
        "output_must_preserve": ["All original grouping and aggregation columns"]
      },
      "gates_checked": ["G_SF_FILTER_FUNCTION_WRAP:PASS", "G_SF_JOINFILTER_PRESERVE:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Snowflake may already push filters, but pre‑filtering dimensions into tiny CTEs could improve join order and reduce fact scan rows via early key propagation.",
      "confidence": 0.55,
      "expected_explain_delta": "Dimension scans become tiny materialized CTEs, store_sales scans show reduced rows via early join key restriction.",
      "recommended_patch_ops": ["create_dimension_cte", "rewrite_joins_with_cte"],
      "recommended_examples": ["multi_dimension_prefetch"],
      "rank_rationale": "Exploration targeting early reduction of fact scans via dimension pre‑filtering (family A underrepresented).",
      "gold_example_id": "multi_dimension_prefetch"
    },
    {
      "probe_id": "p07",
      "transform_id": "single_pass_aggregation",
      "family": "C",
      "target": "Consolidate multiple store_sales aggregations (max_store_sales and best_ss_customer) into a single CTE that computes both csales and ssales per customer.",
      "dag_target_hint": "Create single CTE aggregating store_sales by customer_sk with both sum(ss_quantity*ss_sales_price) and conditional aggregates.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim", "customer"],
        "where_must_preserve": ["ss_sold_date_sk = d_date_sk", "d_year = 1998", "ss_wholesale_cost BETWEEN 11 AND 21", "c_birth_year BETWEEN 1934 AND 1940"],
        "output_must_preserve": ["c_customer_sk", "csales", "ssales"]
      },
      "gates_checked": ["no_duplicate_aggregation:PASS", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Two separate store_sales aggregations on same filtered subset could be merged into one scan, reducing I/O.",
      "confidence": 0.65,
      "expected_explain_delta": "Two store_sales aggregations merge into one TableScan and one Aggregate node.",
      "recommended_patch_ops": ["merge_cte_aggregations", "rewrite_with_case_aggregates"],
      "recommended_examples": ["single_pass_aggregation"],
      "rank_rationale": "Exploration targeting redundant store_sales scans; family C underrepresented.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p08",
      "transform_id": "prefetch_fact_join",
      "family": "A",
      "target": "Stage join pipeline: filter date_dim and item first, join with store_sales to produce frequent_ss_items keyset, then join with customer for best_ss_customer.",
      "dag_target_hint": "Restructure CTEs to chain: dim_filters → fact_join → aggregation, ensuring each step reduces rows before next join.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim", "item", "customer"],
        "where_must_preserve": ["All original filters on dimensions and fact"],
        "output_must_preserve": ["All CTE outputs and join conditions"]
      },
      "gates_checked": ["G_SF_FILTER_FUNCTION_WRAP:PASS", "G_SF_JOINFILTER_PRESERVE:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Staged join order may improve cardinality estimates and reduce intermediate row counts.",
      "confidence": 0.50,
      "expected_explain_delta": "Join order changes to dimension‑first, fact scan rows reduce due to early key restriction.",
      "recommended_patch_ops": ["reorder_cte_chain", "insert_staging_cte"],
      "recommended_examples": ["prefetch_fact_join"],
      "rank_rationale": "Exploration testing join topology sensitivity; family A already covered but different mechanism.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p09",
      "transform_id": "dimension_cte_isolate",
      "family": "A",
      "target": "Isolate date_dim filter (d_year=1998) into a CTE returning only d_date_sk, then join with store_sales in all three contexts.",
      "dag_target_hint": "Create date_dim_filtered CTE with selective columns and join via date_sk in store_sales scans.",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_year = 1998"],
        "output_must_preserve": ["d_date_sk"]
      },
      "gates_checked": ["G_SF_FILTER_FUNCTION_WRAP:PASS", "G_SF_JOINFILTER_PRESERVE:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Small dimension CTE may improve join planning and allow predicate pushdown.",
      "confidence": 0.45,
      "expected_explain_delta": "date_dim scan becomes tiny CTE, store_sales joins reference filtered key set.",
      "recommended_patch_ops": ["create_dimension_cte", "replace_dimension_scan"],
      "recommended_examples": ["dimension_cte_isolate"],
      "rank_rationale": "Secondary exploration targeting dimension pruning; low confidence due to Snowflake's native pushdown.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p10",
      "transform_id": "shared_dimension_multi_channel",
      "family": "A",
      "target": "Create shared date_dim CTE for catalog_sales and web_sales UNION branches to avoid redundant date_dim scans.",
      "dag_target_hint": "Extract date_dim filter (d_year=1998, d_moy=10) into a single CTE referenced by both catalog_sales and web_sales joins.",
      "node_contract": {
        "from_must_include": ["date_dim"],
        "where_must_preserve": ["d_year = 1998", "d_moy = 10"],
        "output_must_preserve": ["d_date_sk"]
      },
      "gates_checked": ["G_SF_CTE_REUSE_RULE:PASS", "multi_ref_cte:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Shared dimension CTE may improve reuse and reduce duplicate dimension work.",
      "confidence": 0.40,
      "expected_explain_delta": "date_dim scanned once instead of twice, catalog_sales and web_sales join to same CTE.",
      "recommended_patch_ops": ["create_shared_dim_cte", "replace_dimension_scans"],
      "recommended_examples": ["shared_dimension_multi_channel"],
      "rank_rationale": "Exploration targeting duplicate dimension scans in UNION branches.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p11",
      "transform_id": "channel_bitmap_aggregation",
      "family": "C",
      "target": "Consolidate catalog_sales and web_sales UNION branches into a single scan with channel labeling and conditional aggregation.",
      "dag_target_hint": "Create single CTE scanning both catalog_sales and web_sales via UNION ALL, add channel column, then aggregate with CASE per channel.",
      "node_contract": {
        "from_must_include": ["catalog_sales", "web_sales", "date_dim"],
        "where_must_preserve": ["d_year=1998", "d_moy=10", "cs_wholesale_cost BETWEEN 11 AND 21", "ws_wholesale_cost BETWEEN 11 AND 21"],
        "output_must_preserve": ["SUM(sales) per channel", "item_sk and bill_customer_sk filters from frequent_ss_items and best_ss_customer"]
      },
      "gates_checked": ["no_duplicate_aggregation:PASS", "multiplicity_guard_required:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Consolidating two fact scans into one may reduce I/O if overlapping partitions are scanned.",
      "confidence": 0.35,
      "expected_explain_delta": "catalog_sales and web_sales TableScan merge into one node with channel discriminator.",
      "recommended_patch_ops": ["merge_union_branches", "add_channel_column", "conditional_aggregation"],
      "recommended_examples": ["channel_bitmap_aggregation"],
      "rank_rationale": "Exploration targeting redundant fact scans in UNION; high risk due to different table structures.",
      "gold_example_id": ""
    },
    {
      "probe_id": "p12",
      "transform_id": "sf_shared_scan_decorrelate",
      "family": "B",
      "target": "Create shared store_sales CTE for max_store_sales and best_ss_customer to avoid scanning store_sales twice for same filters.",
      "dag_target_hint": "Extract common store_sales scan with date_dim join and wholesale_cost filter into a CTE, reuse in both aggregations.",
      "node_contract": {
        "from_must_include": ["store_sales", "date_dim"],
        "where_must_preserve": ["ss_sold_date_sk = d_date_sk", "d_year = 1998", "ss_wholesale_cost BETWEEN 11 AND 21"],
        "output_must_preserve": ["ss_customer_sk", "ss_quantity", "ss_sales_price"]
      },
      "gates_checked": ["G_SF_CORR_FACT_CONTEXT:PASS", "G_SF_CORR_SEMANTIC_KEYS:PASS"],
      "exploration": true,
      "exploration_hypothesis": "Shared scan could reduce duplicate I/O for store_sales in max_store_sales and best_ss_customer.",
      "confidence": 0.60,
      "expected_explain_delta": "store_sales scanned once instead of twice for the two aggregations.",
      "recommended_patch_ops": ["create_shared_fact_cte", "replace_redundant_scans"],
      "recommended_examples": ["sf_shared_scan_decorrelate"],
      "rank_rationale": "Exploration targeting duplicate store_sales scans with same filters; family B underrepresented.",
      "gold_example_id": "sf_shared_scan_decorrelate"
    }
  ],
  "dropped": [
    {
      "transform_id": "date_cte_isolate",
      "family": "A",
      "reason": "date_dim scans already show parts=1/1 (fully pruned), marginal gain."
    },
    {
      "transform_id": "early_filter",
      "family": "A",
      "reason": "Duplicate mechanism with dimension_cte_isolate and prefetch_fact_join."
    },
    {
      "transform_id": "multi_date_range_cte",
      "family": "A",
      "reason": "No multiple date ranges with different filters in query."
    },
    {
      "transform_id": "decorrelate",
      "family": "B",
      "reason": "Snowflake already decorrelates EXISTS/IN; only scalar aggregate correlation present, covered by sf_inline_decorrelate."
    },
    {
      "transform_id": "early_filter_decorrelate",
      "family": "B",
      "reason": "Engine mismatch (postgresql) and covered by native sf_inline_decorrelate."
    },
    {
      "transform_id": "inline_decorrelate_materialized",
      "family": "B",
      "reason": "Engine mismatch (postgresql) and covered by native sf_inline_decorrelate."
    },
    {
      "transform_id": "intersect_to_exists",
      "family": "D",
      "reason": "No INTERSECT operation in query."
    },
    {
      "transform_id": "multi_intersect_exists_cte",
      "family": "D",
      "reason": "No INTERSECT operation in query."
    },
    {
      "transform_id": "or_to_union",
      "family": "D",
      "reason": "No OR predicate hotspot in plan evidence."
    },
    {
      "transform_id": "rollup_to_union_windowing",
      "family": "D",
      "reason": "No ROLLUP operation in query."
    },
    {
      "transform_id": "union_cte_split",
      "family": "D",
      "reason": "No generic CTE scanned multiple times with different filters."
    },
    {
      "transform_id": "pg_self_join_decomposition",
      "family": "E",
      "reason": "Engine mismatch (postgresql) and no self‑join pattern."
    },
    {
      "transform_id": "date_cte_explicit_join",
      "family": "F",
      "reason": "Engine mismatch (postgresql) and comma joins already explicit in query."
    },
    {
      "transform_id": "dimension_prefetch_star",
      "family": "F",
      "reason": "Engine mismatch (postgresql) and covered by multi_dimension_prefetch."
    },
    {
      "transform_id": "inner_join_conversion",
      "family": "F",
      "reason": "No LEFT JOIN followed by WHERE filter on right table."
    },
    {
      "transform_id": "materialized_dimension_fact_prefilter",
      "family": "F",
      "reason": "Engine mismatch (postgresql) and no non‑equi joins."
    },
    {
      "transform_id": "self_join_decomposition",
      "family": "F",
      "reason": "No CTE self‑join with different filter values."
    }
  ]
}