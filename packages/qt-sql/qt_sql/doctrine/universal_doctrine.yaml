# Universal Doctrine — Engine-agnostic optimization philosophy
# Stable across all engines and deployments.
# Loaded by doctrine/__init__.py::load_doctrine()

mission: |
  Optimize SQL queries to run faster on smaller infrastructure.
  Every recommendation must reduce latency, memory, or cost
  on the target resource envelope.

principles:
  minimum_work: |
    The best optimization is eliminating work the engine doesn't
    need to do. Prefer rewrites that reduce rows processed, joins
    evaluated, and bytes scanned.

  fit_the_box: |
    The query must complete within the scenario card's resource
    envelope. A 2x faster query that spills to disk on the target
    is worse than a 1.3x faster query that fits in memory.

  equivalence_first: |
    Every rewrite must produce identical results to the original.
    No optimization justifies correctness risk.

  evidence_required: |
    No recommendation without evidence. Cite the plan node,
    profile counter, or cost estimate that supports the claim.

bottleneck_taxonomy:
  spill: "Intermediate results exceed memory, written to disk/remote"
  join_explosion: "Join produces more rows than either input (bad cardinality)"
  bad_join_order: "Large table on build side, small table on probe side"
  bad_pruning: "Engine scans partitions/pages it doesn't need"
  redundant_scan: "Same table scanned multiple times unnecessarily"
  sort_pressure: "ORDER BY / GROUP BY on large intermediate"
  skew: "Data skew causes one worker to do most of the work"
  materialization: "CTE or subquery materialized when streaming would suffice"
  bad_estimates: "Optimizer cardinality estimates off by >10x"

# Engine-specific signal mappings (which engine signals map to which bottleneck)
engine_signal_mappings:
  spill:
    postgres: "temp_blks_written, Sort Method: external merge, Hash Batches > 1"
    duckdb: "n/a (in-memory engine)"
    snowflake: "bytes_spilled_remote_storage, bytes_spilled_local_storage"
  bad_pruning:
    postgres: "Rows Removed by Filter >> Actual Rows"
    duckdb: "CROSS_CTE_PREDICATE_BLINDNESS"
    snowflake: "Partitions Scanned > 5% of Total"
  redundant_scan:
    postgres: "CORRELATED_SUBQUERY_PARALYSIS (repeated table access)"
    duckdb: "REDUNDANT_SCAN_ELIMINATION"
    snowflake: "duplicate TableScan nodes on same table"
  bad_estimates:
    postgres: "Plan Rows / Actual Rows ratio > 10x"
    duckdb: "Q-Error magnitude"
    snowflake: "estimated vs actual NDV on join keys"

hallucination_rules:
  feature_gate: |
    Any recommendation referencing an engine feature MUST satisfy:
      (a) engine_pack.capabilities confirms feature exists: true
      (b) evidence_bundle contains supporting signal
    If either gate fails, label recommendation as:
      "CONDITIONAL: verify [feature] is available and [signal] is present"

  version_gate: |
    Do not assert behavior from one engine version applies to another.
    Engine packs are versioned. Use only the loaded version.

  no_invented_syntax: |
    Do not invent SQL hints, session parameters, or commands.
    Only use syntax documented in the engine pack.

correctness_constraints:
  literal_preservation: |
    Never change string literals, numeric constants, date values,
    or column aliases that affect result set content.
  semantic_equivalence: |
    Rewritten query must return identical rows in identical order
    (when ORDER BY is specified) to the original.
  complete_output: |
    All columns in the original SELECT list must appear in the rewrite.
    No columns may be added or removed.
  cte_column_completeness: |
    Every CTE must SELECT all columns referenced by downstream consumers.
    Missing columns cause runtime errors.

worker_diversity:
  families:
    A: "Early Filtering — push predicates earlier, reduce input rows"
    B: "Decorrelation — eliminate correlated subqueries"
    C: "Aggregation — pre-aggregate, partial aggregate, single-pass"
    D: "Set Operations — OR→UNION, INTERSECT→EXISTS, UNION dedup"
    E: "Materialization — CTE inline/materialize, subquery factoring"
    F: "Join Transform — reorder, eliminate, change join method"

  enforcement: |
    At least 3 of 6 families represented as primary/secondary across 4 workers.
    W1: Proven compound (highest-confidence strategy from diagnosis)
    W2: Structural alternative (different family from W1)
    W3: Aggressive compound (3+ transforms from 2+ families)
    W4: Orthogonal exploration (uncovered family or novel technique)

global_guards:
  - "NEVER cross-join 3+ dimension CTEs (0.0076x regression)"
  - "Same-column OR conditions → never split to UNION (0.23x regression)"
  - "EXISTS subquery → never materialize (0.14x regression)"
  - "Every CTE MUST have a WHERE clause (0.85x regression without)"
  - "Baseline < 100ms → skip CTE rewrites (overhead exceeds gain)"
  - "UNION ALL branch limit: max 3 branches (9 branches = 9x scans)"
  - "Window functions: never duplicate PARTITION BY columns"
  - "COUNT(*) → never change to COUNT(col) (NULL semantics differ)"
  - "DISTINCT + ORDER BY → preserve column set in SELECT"
  - "Aggregate subquery in SELECT → validate NULL handling after decorrelation"
