{
  "failure_analysis": "All attempts failed because they focused on dimension pre-filtering (item, date_dim) while missing the critical bottleneck: the three massive fact table scans (catalog_sales, store_sales, web_sales) each with LEFT JOINs to their respective returns tables. The pre-filtering CTEs provided marginal benefit (0.2-0.28x) because:\n1. Fact tables aren't pre-filtered - they still scan all rows before applying ratio filters\n2. UNION approach processes each channel separately with repeated dimension joins\n3. Self-join at the end still requires full aggregation of both years\n4. Worker 4's structural transformation had promise but contained a syntax error (missing d_year in CTE)",
  "unexplored": "1. **Single-pass aggregation with year pivoting**: Compute both years' aggregates in one pass using conditional aggregation (CASE WHEN d_year=...), eliminating the self-join entirely\n2. **Early fact table filtering**: Push the ratio filters (sales_price/list_price BETWEEN...) into materialized CTEs before joining with returns\n3. **Returns pre-aggregation**: Aggregate returns by their foreign keys before joining to sales, reducing the many-to-many join explosion\n4. **Channel merging**: Use UNION ALL with explicit channel markers instead of separate UNION branches\n5. **Two-phase aggregation**: First aggregate sales-returns at the item/date level, then roll up to brand/class/category",
  "refined_strategy": "Combine the best elements: pre-filter facts aggressively, pre-aggregate returns, compute both years in single pass via conditional aggregation. Structure:\n1. Create filtered_facts CTEs for each channel with ratio filters applied early\n2. Create aggregated_returns CTEs with GROUP BY on join keys\n3. Join filtered facts with aggregated returns (not LEFT JOIN to individual returns)\n4. UNION ALL all channels with channel indicator\n5. Single aggregation with SUM(CASE WHEN d_year=2001...) and SUM(CASE WHEN d_year=2002...)\n6. Apply final ratio filter in HAVING clause",
  "examples": [
    "pg_self_join_decomposition",
    "pg_materialized_dimension_fact_prefilter",
    "early_filter_decorrelate"
  ],
  "hint": "Implement single-pass year aggregation using conditional SUMs with CASE statements, pre-aggregate returns tables by their composite keys before joining, and use UNION ALL with explicit channel columns to avoid duplicate removal overhead."
}