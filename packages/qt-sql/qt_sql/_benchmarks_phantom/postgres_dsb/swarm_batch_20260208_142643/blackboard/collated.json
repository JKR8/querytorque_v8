{
  "principles": [
    {
      "id": "or_to_union",
      "name": "Or To Union",
      "what": "Applied or_to_union achieving 73.35x speedup",
      "why": "Converting OR to UNION ALL lets optimizer choose independent index paths per branch",
      "when": "WHERE clause has OR conditions over different dimension keys (\u22643 branches)",
      "when_not": "Caused regression on query013_spj_spj, query085_agg, query085_spj_spj, query091_spj_spj, query101_agg (worst: 0.05x); We are given 5 attempts, all of which failed to reach the target 2.0x speedup. The best attempt achieved only 1.06x.\n\nLet's analyze each attempt:\n\n1. **Worker 1 (conservative_early_pushdown)**: 0.82x ",
      "verified_speedups": [
        73.35242111461433,
        66.32527638993845,
        53.10837425657921,
        3.067018811694743,
        1.7390934770856203,
        1.6973457487323271,
        1.170427997752986
      ],
      "avg_speedup": 28.637,
      "queries": [
        "query010_multi",
        "query013_agg",
        "query023_multi",
        "query054_multi",
        "query065_multi",
        "query072_spj_spj",
        "query080_multi"
      ],
      "transforms": [
        "date_cte_isolate",
        "dimension_cte_isolate",
        "or_to_union",
        "prefetch_fact_join"
      ]
    },
    {
      "id": "decorrelate",
      "name": "Decorrelate",
      "what": "Applied decorrelate, date_cte_isolate, dimension_cte_isolate achieving 122.29x speedup",
      "why": "Correlated subqueries re-execute per outer row; converting to JOIN eliminates per-row overhead; Pre-filtering date dimension into CTE reduces hash join probe table from 73K to ~365 rows; Pre-filtering all dimension tables into CTEs avoids repeated full-table scans",
      "when": "Query has correlated subquery in WHERE or SELECT that references outer table",
      "when_not": "Caused regression on query030_multi, query038_multi, query054_multi, query058_multi, query072_spj_spj, query083_multi, query087_multi (worst: 0.00x); The fundamental issue is that all attempts treated this as a simple CTE/materalization problem when the real bottleneck lies elsewhere. The original query already has optimal filter pushdown - Postgre",
      "verified_speedups": [
        122.28628549405371,
        108.83433493033179,
        107.74576725495528,
        11.623200099186304,
        10.946612330947332,
        10.835117003229474,
        4.630291368154034,
        4.103093014813743,
        2.126719235185333,
        1.9521396747351196,
        1.9242588792425155,
        1.7574278136172428,
        1.7413608791729855,
        1.52735815246076,
        1.5244777783663208,
        1.3253961714080202
      ],
      "avg_speedup": 24.68,
      "queries": [
        "query039_multi",
        "query054_multi",
        "query059_multi",
        "query065_multi",
        "query081_multi",
        "query087_multi"
      ],
      "transforms": [
        "date_cte_isolate",
        "decorrelate",
        "dimension_cte_isolate",
        "multi_dimension_prefetch",
        "prefetch_fact_join"
      ]
    },
    {
      "id": "prefetch_fact_join",
      "name": "Prefetch Fact Join",
      "what": "Applied prefetch_fact_join: Created separate pre-filtered CTEs for dimensions (date_dim, item) and fact subsets (store_sales with wholesale_cost filter), materialized distinct item_sk from frequent_ss_items, and converted IN subqueries to explicit joins to enable better plan optimization.",
      "why": "Pre-joining filtered dimensions with fact table before aggregation reduces join input",
      "when": "Query joins filtered dates/dims with large fact table; pre-join reduces probe size",
      "when_not": "Caused regression on query013_spj_spj, query025_agg, query031_multi, query050_spj_spj, query072_spj_spj, query083_multi, query085_agg, query087_multi, query101_agg (worst: 0.04x); We are given 5 attempts, all of which failed to reach the target 2.0x speedup. The best attempt achieved only 1.06x.\n\nLet's analyze each attempt:\n\n1. **Worker 1 (conservative_early_pushdown)**: 0.82x ",
      "verified_speedups": [
        64.55244269378329,
        3.3232686420331894,
        1.9096524241678212,
        1.1183033701998488
      ],
      "avg_speedup": 17.726,
      "queries": [
        "query023_multi",
        "query050_agg",
        "query080_multi"
      ],
      "transforms": [
        "prefetch_fact_join"
      ]
    },
    {
      "id": "date_cte_isolate",
      "name": "Date Cte Isolate",
      "what": "Applied date_cte_isolate, multi_dimension_prefetch achieving 11.23x speedup",
      "why": "Pre-filtering date dimension into CTE reduces hash join probe table from 73K to ~365 rows; Pre-filtering multiple dimension tables in parallel reduces join fan-out",
      "when": "Query joins date_dim on multiple conditions (year, month, etc.) with fact tables",
      "when_not": "Caused regression on query010_multi, query013_agg, query013_spj_spj, query018_agg, query018_spj_spj, query019_spj_spj, query025_agg, query027_agg, query027_spj_spj, query030_multi, query031_multi, query038_multi, query040_spj_spj, query050_spj_spj, query054_multi, query058_multi, query064_multi, query069_multi, query072_agg, query072_spj_spj, query083_multi, query085_agg, query085_spj_spj, query087_multi, query091_agg, query091_spj_spj, query094_multi, query100_agg, query101_agg, query101_spj_spj, query102_agg, query102_spj_spj (worst: 0.00x); Rewrite increased execution time \u2014 likely added overhead or prevented optimizer optimizations",
      "verified_speedups": [
        11.232139433447843,
        9.62164454268518,
        5.230518436383954,
        4.427864781544116,
        4.332563879765709,
        4.1871005597949456,
        3.804719650483733,
        3.664518718324099,
        3.5183672412141727,
        3.280025955833233,
        2.020200575455194,
        1.8388338665963029,
        1.8219644169344114,
        1.820888647355756,
        1.5791616753126991,
        1.433334918594728,
        1.3943311758574517,
        1.3639086733889336,
        1.2724570762873264,
        1.2289723178206347,
        1.2090317549808018,
        1.1992900217595654,
        1.1873395682650838,
        1.180915193084758,
        1.1772966331778911,
        1.1760558717497558,
        1.1758970086549476,
        1.1715073534764526,
        1.1648213087268702,
        1.1404043526791572,
        1.1179640420855672,
        1.1119870666322185,
        1.1116793782034127,
        1.1084531937353757,
        1.1048729871954481
      ],
      "avg_speedup": 2.469,
      "queries": [
        "query010_multi",
        "query019_agg",
        "query019_spj_spj",
        "query025_spj_spj",
        "query027_agg",
        "query027_spj_spj",
        "query040_agg",
        "query040_spj_spj",
        "query050_agg",
        "query069_multi",
        "query072_agg",
        "query080_multi",
        "query099_agg",
        "query099_spj_spj",
        "query100_spj_spj",
        "query101_agg",
        "query101_spj_spj",
        "query102_agg",
        "query102_spj_spj"
      ],
      "transforms": [
        "date_cte_isolate",
        "dimension_cte_isolate",
        "multi_date_range_cte",
        "multi_dimension_prefetch",
        "prefetch_fact_join"
      ]
    },
    {
      "id": "pushdown",
      "name": "Pushdown",
      "what": "Applied pushdown: ** Created separate CTEs for filtered stores and two date ranges, then computed the two periods' aggregations independently with explicit JOINs and early filter pushdown. This enables PostgreSQL to use hash joins with small dimension tables and process less data overall.\n\n**Expected speedup:** 1.8-2.5x due to reduced intermediate result sizes and better join order control.",
      "why": "Pushing predicates closer to table scans reduces data volume in upper operators",
      "when": "WHERE predicates reference columns from tables deep in the join tree",
      "when_not": "Caused regression on query014_multi, query027_spj_spj, query031_multi, query058_multi, query083_multi, query085_spj_spj, query087_multi, query091_agg (worst: 0.19x); All attempts fell short due to three core issues: 1) Worker 1 and 5 had fatal errors (ambiguity/timeout) from improper column aliasing and excessive materialization. 2) Workers 2-4 failed to address t",
      "verified_speedups": [
        4.6799802539183615,
        2.877932543501555,
        1.9303353662366844,
        1.1778171040495835,
        1.1003399162251937
      ],
      "avg_speedup": 2.353,
      "queries": [
        "query019_agg",
        "query059_multi",
        "query072_agg",
        "query080_multi",
        "query094_multi"
      ],
      "transforms": [
        "pushdown"
      ]
    },
    {
      "id": "unknown",
      "name": "Unknown",
      "what": "Applied unknown: Isolated date_dim subquery into a materialized CTE and created pre-filtered dimension CTEs for item and customer before joining with fact tables. Converted implicit joins to explicit JOIN syntax.",
      "why": "",
      "when": "",
      "when_not": "",
      "verified_speedups": [
        2.524130607367415,
        1.8413157512267129,
        1.5782496133672843,
        1.3090493738395756,
        1.3023183424416436,
        1.2228752599892374
      ],
      "avg_speedup": 1.63,
      "queries": [
        "query018_spj_spj",
        "query019_agg",
        "query058_multi",
        "query084_agg",
        "query099_spj_spj",
        "query102_agg"
      ],
      "transforms": []
    },
    {
      "id": "dimension_cte_isolate",
      "name": "Dimension Cte Isolate",
      "what": "Applied dimension_cte_isolate achieving 1.91x speedup",
      "why": "Pre-filtering all dimension tables into CTEs avoids repeated full-table scans",
      "when": "Query joins 2+ dimension tables that could each be pre-filtered independently",
      "when_not": "Caused regression on query019_spj_spj, query030_multi, query038_multi, query040_spj_spj, query050_spj_spj, query054_multi, query069_multi, query083_multi, query085_agg, query087_multi (worst: 0.00x); All attempts fell short due to PostgreSQL's CTE optimization fence behavior. Workers 1-5 used non-materialized CTEs (default behavior in versions prior to 12), causing the planner to compute each CTE ",
      "verified_speedups": [
        1.908835330896292,
        1.598830782308037,
        1.3077128182680382
      ],
      "avg_speedup": 1.605,
      "queries": [
        "query072_spj_spj",
        "query084_agg",
        "query084_spj_spj"
      ],
      "transforms": [
        "dimension_cte_isolate"
      ]
    },
    {
      "id": "multi_dimension_prefetch",
      "name": "Multi Dimension Prefetch",
      "what": "Applied multi_dimension_prefetch achieving 2.10x speedup",
      "why": "Pre-filtering multiple dimension tables in parallel reduces join fan-out",
      "when": "Query references multiple dimension tables (date + store, date + item, etc.)",
      "when_not": "Caused regression on query010_multi, query013_agg, query013_spj_spj, query018_agg, query018_spj_spj, query019_spj_spj, query025_agg, query027_agg, query027_spj_spj, query031_multi, query058_multi, query064_multi, query069_multi, query072_agg, query085_agg, query085_spj_spj, query091_agg, query091_spj_spj, query094_multi, query100_agg, query101_agg, query101_spj_spj, query102_agg, query102_spj_spj (worst: 0.05x); Rewrite increased execution time \u2014 likely added overhead or prevented optimizer optimizations",
      "verified_speedups": [
        2.102927380757268,
        1.9057258662371936,
        1.4104156816846927,
        1.405997493540603,
        1.148035192530136
      ],
      "avg_speedup": 1.595,
      "queries": [
        "query084_agg",
        "query084_spj_spj"
      ],
      "transforms": [
        "multi_dimension_prefetch",
        "prefetch_fact_join"
      ]
    }
  ],
  "anti_patterns": [
    {
      "id": "regression_date_cte_isolate",
      "name": "Regression: Date Cte Isolate",
      "mechanism": "All attempts fell short due to PostgreSQL's CTE optimization fence behavior. Workers 1-5 used non-materialized CTEs (default behavior in versions prior to 12), causing the planner to compute each CTE independently without cross-CTE join optimization or predicate pushdown. This prevented join order flexibility and forced nested-loop-like execution patterns. Worker 4's EXISTS approach was catastrophic (0.09x) because it created correlated subqueries that executed per fact row. The common CTE-based",
      "observed_regressions": [
        0.0907290408477507,
        0.10218180912439384,
        0.12554739360569717,
        0.14213020021281034,
        0.14709725891780479,
        0.16656947231435276,
        0.16994321025009027,
        0.21488232149949552,
        0.31694311474477227,
        0.33400414068348694,
        0.4789079989317887,
        0.5328110061033504,
        0.5423145696517109,
        0.5628992369896807,
        0.5672164000284285,
        0.5736853922513541,
        0.5803857634647263,
        0.5807304449311763,
        0.586342232968759,
        0.6090467396914759,
        0.6227092246112371,
        0.6832426209004484,
        0.6887565723791719,
        0.6971173212617228,
        0.6998217468273141,
        0.7328249935449896,
        0.7348292007872801,
        0.7388682916576443,
        0.766511002507978,
        0.7769748721167025,
        0.7808289291932969,
        0.8022319221906962,
        0.8035182154450308,
        0.809905782731543,
        0.8140371502848629,
        0.8185070826612433,
        0.8210548370366179,
        0.8283677800306781,
        0.846800115917242,
        0.8752394451824919,
        0.8787607786825783,
        0.891588003866242,
        0.9044077078672319,
        0.9046975186669034,
        0.9128768479864671,
        0.9275470085734001,
        0.9304515012455505
      ],
      "queries": [
        "query010_multi",
        "query013_agg",
        "query013_spj_spj",
        "query018_agg",
        "query018_spj_spj",
        "query019_spj_spj",
        "query025_agg",
        "query027_agg",
        "query027_spj_spj",
        "query031_multi",
        "query038_multi",
        "query040_spj_spj",
        "query050_spj_spj",
        "query064_multi",
        "query069_multi",
        "query072_agg",
        "query085_agg",
        "query085_spj_spj",
        "query087_multi",
        "query091_agg",
        "query091_spj_spj",
        "query094_multi",
        "query100_agg",
        "query101_agg",
        "query101_spj_spj",
        "query102_agg",
        "query102_spj_spj"
      ],
      "avoid_when": "Applying date_cte_isolate to queries similar to query010_multi, query013_agg, query013_spj_spj, query018_agg, query018_spj_spj, query019_spj_spj, query025_agg, query027_agg, query027_spj_spj, query031_multi, query038_multi, query040_spj_spj, query050_spj_spj, query064_multi, query069_multi, query072_agg, query085_agg, query085_spj_spj, query087_multi, query091_agg, query091_spj_spj, query094_multi, query100_agg, query101_agg, query101_spj_spj, query102_agg, query102_spj_spj"
    },
    {
      "id": "regression_decorrelate",
      "name": "Regression: Decorrelate",
      "mechanism": "Rewrite increased execution time \u2014 likely added overhead or prevented optimizer optimizations",
      "observed_regressions": [
        0.003912673449386068,
        0.044064674002489465,
        0.05596440999938244,
        0.05724773669469979,
        0.25562384453763026,
        0.31319360492390497,
        0.33718887542206927,
        0.5297065472309617,
        0.6028919543590417,
        0.7558250601173462,
        0.8519562819001825
      ],
      "queries": [
        "query030_multi",
        "query038_multi",
        "query054_multi",
        "query058_multi",
        "query072_spj_spj",
        "query083_multi",
        "query087_multi"
      ],
      "avoid_when": "Applying decorrelate to queries similar to query030_multi, query038_multi, query054_multi, query058_multi, query072_spj_spj, query083_multi, query087_multi"
    },
    {
      "id": "regression_or_to_union",
      "name": "Regression: Or To Union",
      "mechanism": "The primary failure mechanism was a column resolution error (\"column 'ca_state' does not exist\") that occurred in 3/5 attempts. This happened because workers created CTEs for filtered dimension tables (like customer_address) but only selected a subset of columns (e.g., just `ca_address_sk`), then referenced additional columns (like `ca_state`) from these CTEs in the main query's WHERE clause. Attempts 1, 2, and 5 all made this same structural mistake by referencing columns from CTEs that weren't",
      "observed_regressions": [
        0.0467011509266561,
        0.19878978789847268,
        0.4503627669578873,
        0.45383904965492755,
        0.48862029193478385,
        0.6752815077300026
      ],
      "queries": [
        "query013_spj_spj",
        "query085_agg",
        "query085_spj_spj",
        "query091_spj_spj",
        "query101_agg"
      ],
      "avoid_when": "Applying or_to_union to queries similar to query013_spj_spj, query085_agg, query085_spj_spj, query091_spj_spj, query101_agg"
    },
    {
      "id": "regression_prefetch_fact_join",
      "name": "Regression: Prefetch Fact Join",
      "mechanism": "All attempts fell short due to fundamental misconceptions about PostgreSQL's optimizer behavior with CTEs. Worker 1 (1.00x) showed CTEs provided no benefit because PostgreSQL's optimizer can already push filters into implicit joins. Workers 2-5 (0.68x, 0.81x, 0.47x, 0.69x) performed worse because their CTEs were being materialized by default (PostgreSQL's behavior), creating temporary tables that eliminated index usage and increased I/O. Worker 4's 0.47x was disastrous because it forced material",
      "observed_regressions": [
        0.47301395944073477,
        0.5774072799872746,
        0.6837710778307073
      ],
      "queries": [
        "query025_agg",
        "query087_multi",
        "query101_agg"
      ],
      "avoid_when": "Applying prefetch_fact_join to queries similar to query025_agg, query087_multi, query101_agg"
    },
    {
      "id": "regression_pushdown",
      "name": "Regression: Pushdown",
      "mechanism": "All attempts fell short due to fundamental misapplication of CTE-based optimization in PostgreSQL. PostgreSQL's optimizer treats CTEs as optimization fences (by default), preventing pushdown of filters across CTE boundaries. Workers 2, 4, and 5 showed this clearly\u2014pre-filtering dimension tables in CTEs forced full scans of large fact tables before applying selective joins. Worker 1 failed syntactically by omitting needed columns. Worker 3 attempted aggressive materialization that exceeded time l",
      "observed_regressions": [
        0.18931825940797686,
        0.27264263420150997,
        0.30164630336520837,
        0.5286574887247264,
        0.6064965256501722,
        0.6191655319776519,
        0.6355028465788267,
        0.6505571068220858
      ],
      "queries": [
        "query014_multi",
        "query027_spj_spj",
        "query031_multi",
        "query058_multi",
        "query083_multi",
        "query085_spj_spj",
        "query087_multi",
        "query091_agg"
      ],
      "avoid_when": "Applying pushdown to queries similar to query014_multi, query027_spj_spj, query031_multi, query058_multi, query083_multi, query085_spj_spj, query087_multi, query091_agg"
    },
    {
      "id": "regression_single_pass_aggregation",
      "name": "Regression: Single Pass Aggregation",
      "mechanism": "All attempts fell short because they only addressed dimension table filtering and join syntax, missing the core performance bottleneck: the original query's multi-way self-join pattern (six instances of CTEs) forces repeated scans of aggregated data. While pre-filtering dimensions helped modestly (0.61x-0.74x), the fundamental computational complexity remains. The self-joins create exponential growth in intermediate rows, and the final Cartesian-style joins between ss and ws CTEs multiply the pr",
      "observed_regressions": [
        0.6185349049690998,
        0.6718921051415718
      ],
      "queries": [
        "query031_multi"
      ],
      "avoid_when": "Applying single_pass_aggregation to queries similar to query031_multi"
    },
    {
      "id": "regression_unknown_regression",
      "name": "Regression: Unknown Regression",
      "mechanism": "All attempts fell short due to three core issues: 1) Worker 1 and 5 had fatal errors (ambiguity/timeout) from improper column aliasing and excessive materialization. 2) Workers 2-4 failed to address the root bottleneck: the triple INTERSECT in cross_items performs expensive set operations on large intermediate results before applying item filters. 3) The avg_sales CTE scans the same fact tables thrice (store_sales, catalog_sales, web_sales) without leveraging pre-aggregated data. Workers 3 and 4",
      "observed_regressions": [
        0.7845365331719858
      ],
      "queries": [
        "query014_multi"
      ],
      "avoid_when": "Applying unknown_regression to queries similar to query014_multi"
    },
    {
      "id": "error_execution",
      "name": "Error Pattern: Execution",
      "mechanism": "DISTINCT is not implemented for window functions\nLINE 7:         COUNT(DISTINCT ws2.ws_warehouse_sk) \n                ^\n",
      "observed_regressions": [
        0.0
      ],
      "queries": [
        "query094_multi"
      ],
      "avoid_when": "Watch for execution errors when rewriting queries with complex joins/aliases"
    },
    {
      "id": "error_timeout",
      "name": "Error Pattern: Timeout",
      "mechanism": "canceling statement due to statement timeout\n",
      "observed_regressions": [
        0.0,
        0.0
      ],
      "queries": [
        "query014_multi",
        "query085_spj_spj"
      ],
      "avoid_when": "Watch for timeout errors when rewriting queries with complex joins/aliases"
    },
    {
      "id": "error_unknown",
      "name": "Error Pattern: Unknown",
      "mechanism": "operator does not exist: integer = character\nLINE 29: JOIN store ON inv_warehouse_sk = s_state\n                                        ^\nHINT:  No operator matches the given name and argument types. You might need to add explicit type casts.\n",
      "observed_regressions": [
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0
      ],
      "queries": [
        "query013_spj_spj",
        "query014_multi",
        "query019_agg",
        "query023_multi",
        "query025_spj_spj",
        "query030_multi",
        "query031_multi",
        "query054_multi",
        "query058_multi",
        "query064_multi",
        "query072_agg",
        "query075_multi",
        "query085_agg",
        "query085_spj_spj",
        "query091_agg",
        "query094_multi",
        "query101_spj_spj",
        "query102_agg",
        "query102_spj_spj"
      ],
      "avoid_when": "Watch for unknown errors when rewriting queries with complex joins/aliases"
    },
    {
      "id": "semantic_mismatch_date_cte_isolate",
      "name": "Semantic Mismatch: Date Cte Isolate",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0
      ],
      "queries": [
        "query040_agg",
        "query075_multi",
        "query099_agg",
        "query100_agg"
      ],
      "avoid_when": "Applying date_cte_isolate to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_decorrelate",
      "name": "Semantic Mismatch: Decorrelate",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0,
        0.0
      ],
      "queries": [
        "query014_multi",
        "query059_multi",
        "query075_multi"
      ],
      "avoid_when": "Applying decorrelate to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_multi_dimension_prefetch",
      "name": "Semantic Mismatch: Multi Dimension Prefetch",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0
      ],
      "queries": [
        "query084_agg"
      ],
      "avoid_when": "Applying multi_dimension_prefetch to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_or_to_union",
      "name": "Semantic Mismatch: Or To Union",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0
      ],
      "queries": [
        "query100_agg"
      ],
      "avoid_when": "Applying or_to_union to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_prefetch_fact_join",
      "name": "Semantic Mismatch: Prefetch Fact Join",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0
      ],
      "queries": [
        "query075_multi"
      ],
      "avoid_when": "Applying prefetch_fact_join to queries where semantic equivalence is hard to verify"
    },
    {
      "id": "semantic_mismatch_union_cte_split",
      "name": "Semantic Mismatch: Union Cte Split",
      "mechanism": "Rewrite changed query semantics \u2014 different row counts or values returned",
      "observed_regressions": [
        0.0,
        0.0
      ],
      "queries": [
        "query075_multi"
      ],
      "avoid_when": "Applying union_cte_split to queries where semantic equivalence is hard to verify"
    }
  ],
  "summary": {
    "n_principles": 8,
    "n_anti_patterns": 16,
    "total_wins": 30,
    "total_improved": 51,
    "total_neutral": 59,
    "total_regression": 78,
    "total_error": 29,
    "total_fail": 16
  }
}