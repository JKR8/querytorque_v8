```sql
WITH filtered_dates AS (
    -- Unified date CTE encoding d1-d2-d3 relationships
    SELECT 
        d1.d_date_sk AS sold_date_sk,
        d1.d_week_seq,
        d1.d_date AS sold_date,
        d2.d_date_sk AS inv_date_sk,
        d3.d_date_sk AS ship_date_sk
    FROM date_dim d1
    JOIN date_dim d2 ON d1.d_week_seq = d2.d_week_seq
    JOIN date_dim d3 ON d3.d_date > d1.d_date + INTERVAL '3 DAY'
    WHERE d1.d_year = 1998
),
filtered_cs_candidates AS (
    -- Pre-filter catalog_sales with all applicable dimension keys and wholesale cost
    SELECT 
        cs.cs_item_sk,
        cs.cs_order_number,
        cs.cs_quantity,
        cs.cs_wholesale_cost,
        cs.cs_sold_date_sk,
        cs.cs_ship_date_sk,
        cs.cs_bill_cdemo_sk,
        cs.cs_bill_hdemo_sk,
        i.i_item_sk,
        cd.cd_demo_sk,
        hd.hd_demo_sk,
        -- Window functions to find minimal candidates per required columns
        MIN(i.i_item_sk) OVER () AS min_i_item_sk,
        MIN(cs.cs_item_sk) OVER () AS min_cs_item_sk,
        MIN(cs.cs_order_number) OVER () AS min_cs_order_number
    FROM catalog_sales cs
    JOIN item i ON cs.cs_item_sk = i.i_item_sk
    JOIN customer_demographics cd ON cs.cs_bill_cdemo_sk = cd.cd_demo_sk
    JOIN household_demographics hd ON cs.cs_bill_hdemo_sk = hd.hd_demo_sk
    WHERE i.i_category IN ('Home', 'Men', 'Music')
      AND cd.cd_marital_status = 'M'
      AND cd.cd_dep_count BETWEEN 9 AND 11
      AND hd.hd_buy_potential = '501-1000'
      AND cs.cs_wholesale_cost BETWEEN 34 AND 54
),
filtered_cs_with_dates AS (
    -- Join with date relationships
    SELECT 
        cs.*,
        fd.d_week_seq,
        fd.inv_date_sk
    FROM filtered_cs_candidates cs
    JOIN filtered_dates fd 
        ON cs.cs_sold_date_sk = fd.sold_date_sk
        AND cs.cs_ship_date_sk = fd.ship_date_sk
    WHERE cs.min_i_item_sk = cs.i_item_sk
       OR cs.min_cs_item_sk = cs.cs_item_sk
       OR cs.min_cs_order_number = cs.cs_order_number
),
minimal_candidates AS (
    -- Get distinct minimal candidates for validation
    SELECT DISTINCT
        cs.cs_item_sk,
        cs.cs_order_number,
        cs.cs_quantity,
        cs.d_week_seq,
        cs.i_item_sk,
        cs.inv_date_sk
    FROM filtered_cs_with_dates cs
)
SELECT
    MIN(cs.i_item_sk) AS min_i_item_sk,
    MIN(w.w_warehouse_name) AS min_w_warehouse_name,
    MIN(cs.d_week_seq) AS min_d_week_seq,
    MIN(cs.cs_item_sk) AS min_cs_item_sk,
    MIN(cs.cs_order_number) AS min_cs_order_number,
    MIN(inv.inv_item_sk) AS min_inv_item_sk
FROM minimal_candidates cs
JOIN inventory inv 
    ON cs.cs_item_sk = inv.inv_item_sk
    AND cs.inv_date_sk = inv.inv_date_sk
JOIN warehouse w ON inv.inv_warehouse_sk = w.w_warehouse_sk
WHERE inv.inv_quantity_on_hand < cs.cs_quantity;
```

**Changes:**
1. Removed unnecessary LEFT JOINs to promotion and catalog_returns since they don't affect MIN aggregates.
2. Created a unified date CTE using EXISTS logic (via JOINs) to encode d1-d2-d3 relationships upfront.
3. Pre-filtered catalog_sales with all dimension filters and wholesale cost, using window functions to identify minimal candidate rows early.
4. Validated the `inv_quantity_on_hand < cs_quantity` condition only against minimal candidates, reducing the expensive inventory join.

**Expected speedup:** 2-3x due to early aggregation, reduced join complexity, and minimal validation against inventory.