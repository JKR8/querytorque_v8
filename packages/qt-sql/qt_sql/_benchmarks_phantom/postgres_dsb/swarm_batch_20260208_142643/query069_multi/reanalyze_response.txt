FAILURE_ANALYSIS:
The attempts fell short because they focused on syntactic rewrites (CTEs, explicit joins) without addressing the fundamental performance bottlenecks: (1) Three separate correlated subqueries (EXISTS/NOT EXISTS) force repeated scanning of massive fact tables (store_sales, web_sales, catalog_sales) for each qualifying customer, creating O(nÂ²) behavior. (2) Workers 1-3 kept correlated subqueries or inefficient anti-join patterns. Worker 4's anti-join approach (1.14x) was better but still performed multiple LEFT JOINs on large fact tables. Worker 5 (1.58x) showed the best improvement by pushing filters early but still suffered from correlated subqueries scanning large tables per customer. All attempts missed the opportunity to pre-aggregate fact tables at the customer level before joining.

UNEXPLORED_OPPORTUNITIES:
1. **Pre-aggregate fact tables by customer before existence checks** - Compute which customers have qualifying sales in each channel via lightweight aggregations (COUNT or boolean flags) on pre-filtered fact data.
2. **Use conditional aggregation in a single pass** - Transform the three separate existence checks into conditional counts or flags in a single customer-level aggregation.
3. **Materialize filtered fact subsets** - Create temporary filtered subsets of sales tables with only relevant columns (customer key, list_price) joined once with date_dim.
4. **Leverage bitmap or hash aggregation** - Use PostgreSQL's hash aggregation to quickly compute customer-level sales presence across all three channels in one scan per fact table.
5. **Early elimination via address/demographics** - Push address and demographics filters into CTEs that are materialized to avoid repeated scanning.

REFINED_STRATEGY:
Create three lightweight CTEs that pre-aggregate each sales channel at the customer level, filtering by date and price in a single scan. Then perform a single pass join between customer/demographics/address and these aggregated CTEs using LEFT JOINs with NULL checks for NOT EXISTS logic. Use conditional aggregation to compute the three counts in one GROUP BY operation.

EXAMPLES: pg_materialized_dimension_fact_prefilter, pg_self_join_decomposition, early_filter_decorrelate
HINT: Create materialized CTEs for store_sales_customers, web_sales_customers, and catalog_sales_customers containing only customer keys that meet the date/price criteria. Then join customer with demographics and address, and LEFT JOIN these CTEs to implement EXISTS/NOT EXISTS logic in a single pass without correlated subqueries. Use COUNT(DISTINCT ...) or boolean aggregations to handle duplicates.