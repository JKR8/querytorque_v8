[
  {
    "worker_id": 1,
    "strategy": "conservative_filter_pushdown_explicit_join",
    "examples": [
      "early_filter_decorrelate",
      "pg_date_cte_explicit_join",
      "pg_self_join_decomposition"
    ],
    "hint": "Convert implicit joins to explicit JOIN syntax for better join order control, push all dimension filters directly into JOIN conditions, and eliminate any unnecessary complexity while maintaining the original logic."
  },
  {
    "worker_id": 2,
    "strategy": "moderate_dimension_isolation_cte",
    "examples": [
      "pg_date_cte_explicit_join",
      "pg_dimension_prefetch_star",
      "early_filter_decorrelate"
    ],
    "hint": "Isolate selective dimension filters (date_dim, customer_demographics, item, store) into separate CTEs before joining to the fact table, using explicit JOINs to enforce optimal join order."
  },
  {
    "worker_id": 3,
    "strategy": "aggressive_materialized_prefilter_star",
    "examples": [
      "pg_materialized_dimension_fact_prefilter",
      "pg_dimension_prefetch_star",
      "pg_self_join_decomposition"
    ],
    "hint": "Materialize all pre-filtered dimension tables AND the filtered fact table into separate CTEs (with MATERIALIZED hint if needed), then perform the final star-join and aggregation on these reduced datasets."
  },
  {
    "worker_id": 4,
    "strategy": "novel_rollup_decomposition_union",
    "examples": [
      "pg_self_join_decomposition",
      "pg_materialized_dimension_fact_prefilter",
      "pg_dimension_prefetch_star"
    ],
    "hint": "Decompose the ROLLUP into separate aggregation levels using UNION ALL\u2014compute base aggregates once in a CTE, then derive different grouping levels from it, potentially avoiding repeated fact table scans."
  }
]