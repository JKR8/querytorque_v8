```sql
WITH filtered_dates AS (
    SELECT d_date_sk
    FROM date_dim
    WHERE d_date BETWEEN '1998-03-13' AND CAST('1998-03-13' AS DATE) + INTERVAL '90 DAY'
),
item_avg_discount AS (
    SELECT 
        ws_item_sk,
        1.3 * AVG(ws_ext_discount_amt) AS avg_threshold
    FROM web_sales
    JOIN filtered_dates ON ws_sold_date_sk = filtered_dates.d_date_sk
    WHERE ws_wholesale_cost BETWEEN 26 AND 46
      AND ws_sales_price / ws_list_price BETWEEN 34 * 0.01 AND 49 * 0.01
    GROUP BY ws_item_sk
)
SELECT
    SUM(ws_ext_discount_amt) AS "Excess Discount Amount"
FROM web_sales
JOIN item ON i_item_sk = ws_item_sk
JOIN filtered_dates ON ws_sold_date_sk = filtered_dates.d_date_sk
JOIN item_avg_discount iad ON web_sales.ws_item_sk = iad.ws_item_sk
WHERE (i_manufact_id BETWEEN 341 AND 540 OR i_category IN ('Home', 'Men', 'Music'))
  AND ws_wholesale_cost BETWEEN 26 AND 46
  AND ws_ext_discount_amt > iad.avg_threshold
ORDER BY
    SUM(ws_ext_discount_amt)
LIMIT 100
```

**Changes**: 
1. Converted implicit comma joins to explicit JOIN syntax for better predicate control.
2. Created a filtered_dates CTE to pre-select relevant date range rows.
3. Created an item_avg_discount CTE to compute the threshold once per item, eliminating the correlated subquery.
4. Pushed down date and cost filters early into CTEs.

**Expected speedup**: ~2-3x by eliminating per-row subquery execution and enabling better join planning with pre-filtered dimension tables.