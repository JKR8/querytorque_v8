FAILURE_ANALYSIS:
All attempts fell short because they treated the query as a standard star-join pattern without addressing the fundamental bottleneck: the self-correlated aggregate subquery computing `avg(ctr_total_return)*1.2` for each store. The CTE `customer_total_return` scans store_returns once, but the correlated subquery forces repeated aggregation over the same data for each store_sk, leading to O(nÂ²) behavior. Even materialization attempts failed because they didn't decompose the self-join or leverage early pruning of irrelevant stores. Additionally, filters on store.state and customer demographics were applied too late in the execution plan, missing opportunities for predicate pushdown into the fact table via dimension key pre-filters.

UNEXPLORED_OPPORTUNITIES:
1. **Store-wise aggregation pre-computation**: Compute store-level averages in a separate pass before the main query, eliminating correlation overhead.
2. **Two-phase filtering**: Push store.state and customer demographic filters early to reduce the store_returns scan via dimension key bitmap lookups.
3. **Partial materialization with partitioning**: Materialize only the store_returns rows that satisfy date/year and price-range conditions, then compute per-store aggregates from this subset.
4. **Lateral join for efficient per-store processing**: Use LATERAL to compute store averages only for stores that pass the state filter.
5. **Early exclusion of low-cardinality stores**: Pre-compute which store_sk values exist in filtered store and customer dimensions before scanning store_returns.

REFINED_STRATEGY:
Decompose the query into three sequential stages:
1. **Dimension key pre-filtering**: Create CTEs that pre-select store_sk values from store where state IN ('MI','ND','TX'), and customer_sk values from customer JOIN customer_demographics with all demographic filters.
2. **Fact table filtering with dimension keys**: Scan store_returns JOIN date_dim, but restrict to store_sk and customer_sk from pre-filtered dimensions, plus date/year and price-range conditions. Materialize this subset.
3. **Two-level aggregation pipeline**: 
   a) Compute store-level average returns from the filtered fact subset (GROUP BY ctr_store_sk)
   b) Compute customer-level returns (GROUP BY ctr_customer_sk, ctr_store_sk, ctr_reason_sk) only for reason_sk 25-28
   c) JOIN store-level averages with customer-level returns via non-correlated condition.
This eliminates correlation, reduces fact table scanning, and applies all dimension filters before aggregation.

EXAMPLES: pg_self_join_decomposition, pg_dimension_prefetch_star, early_filter_decorrelate
HINT: Use WITH materialized CTEs for pre-filtered dimension keys, then a filtered fact subset CTE, then separate aggregate CTEs for store-level and customer-level metrics before final JOIN. Ensure all dimension filters are applied before any aggregation on store_returns.