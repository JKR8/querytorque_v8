### What went wrong
The optimization changed the semantic ordering of operations. The original query computes ROLLUP *before* ranking, creating super-aggregate rows (including category subtotals and grand totals) that participate in the ranking. The attempted version computes ranking *before* ROLLUP, ranking only at the detailed level. This causes two problems: 1) The ROLLUP operation after ranking incorrectly aggregates ranked values (SUM(sumsales) on already-aggregated sumsales, MIN(rk) on non-additive ranks) 2) The ranking window now operates on a different dataset - detailed rows only, missing super-aggregate rows that should compete for top ranks. This semantic mismatch likely caused either incorrect results or a query execution error when the database tried to aggregate window function results.

### Why speedup was insufficient
The bottleneck remains at the base_aggregates step (85% cost) - the large join and aggregation of store_sales with dimensions. The optimization merely repackaged this expensive operation into a CTE without addressing its fundamental cost drivers: a full table scan of store_sales, multi-way joins, and aggregation across 8 grouping columns. The added complexity (extra aggregation layer in main_query) actually increased overhead. The 85% cost in base_aggregates shows the original pain point was not mitigated - we're still processing the same billions of fact rows through expensive joins and grouping operations.

### Next approach
Implement a **layered aggregation strategy with early filtering and dimension pushdown**:

```sql
WITH filtered_sales AS (
  -- Early filter and pre-aggregate at lowest grain
  SELECT 
    ss_item_sk,
    ss_store_sk,
    d.d_year,
    d.d_qoy,
    d.d_moy,
    SUM(COALESCE(ss_sales_price * ss_quantity, 0)) AS raw_sumsales
  FROM store_sales
  JOIN date_dim d ON ss_sold_date_sk = d_date_sk
    AND d_month_seq BETWEEN 1206 AND 1206 + 11
  GROUP BY ss_item_sk, ss_store_sk, d.d_year, d.d_qoy, d.d_moy
),
enriched_sales AS (
  -- Late join with dimensions only for needed rows
  SELECT 
    i.i_category,
    i.i_class,
    i.i_brand,
    i.i_product_name,
    fs.d_year,
    fs.d_qoy,
    fs.d_moy,
    s.s_store_id,
    fs.raw_sumsales
  FROM filtered_sales fs
  JOIN item i ON fs.ss_item_sk = i.i_item_sk
  JOIN store s ON fs.ss_store_sk = s.s_store_sk
),
rolled_sales AS (
  -- Apply ROLLUP on enriched (already reduced) dataset
  SELECT
    i_category,
    i_class,
    i_brand,
    i_product_name,
    d_year,
    d_qoy,
    d_moy,
    s_store_id,
    SUM(raw_sumsales) AS sumsales
  FROM enriched_sales
  GROUP BY ROLLUP (
    i_category, i_class, i_brand, i_product_name,
    d_year, d_qoy, d_moy, s_store_id
  )
)
SELECT *
FROM (
  SELECT
    *,
    RANK() OVER (PARTITION BY i_category ORDER BY sumsales DESC) AS rk
  FROM rolled_sales
) ranked
WHERE rk <= 100
ORDER BY i_category, i_class, i_brand, i_product_name,
         d_year, d_qoy, d_moy, s_store_id, sumsales, rk
LIMIT 100;
```

Key innovations:
1. **Early fact reduction**: Aggregate store_sales at the natural key level (item/store/date) before joining to dimensions, drastically reducing rows for expensive joins
2. **Preserved semantic order**: ROLLUP happens before ranking as in original
3. **Minimal dimension joins**: Dimensions are joined only to the pre-aggregated fact set
4. **Maintained COALESCE** for correctness

### Learned constraints
1. **Never change operation sequence** between ROLLUP/CUBE and window functions - they must maintain original dependency order
2. **Avoid aggregating window function results** - ranking values are not additive and cannot be SUM/MIN meaningfully after the fact
3. **CTE materialization alone doesn't help** if the underlying data volume and operations remain unchanged
4. **Dimension joins should be deferred** until after fact table reduction when possible, especially with high-cardinality grouping
5. **Preserve NULL-handling semantics** - removing COALESCE can silently change results