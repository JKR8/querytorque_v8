You are analyzing 5 failed optimization attempts to design a refined approach that reaches 2.0x speedup.

Your job: understand WHY each attempt fell short, identify unexplored optimization angles, and synthesize a NEW strategy that combines the best insights while avoiding repeated mistakes.

## Query: query_28
## Target: 2.0x speedup
## Dialect: duckdb

```sql
-- start query 28 in stream 0 using template query28.tpl
select *
from (select avg(ss_list_price) B1_LP
            ,count(ss_list_price) B1_CNT
            ,count(distinct ss_list_price) B1_CNTD
      from store_sales
      where ss_quantity between 0 and 5
        and (ss_list_price between 131 and 131+10 
             or ss_coupon_amt between 16798 and 16798+1000
             or ss_wholesale_cost between 25 and 25+20)) B1,
     (select avg(ss_list_price) B2_LP
            ,count(ss_list_price) B2_CNT
            ,count(distinct ss_list_price) B2_CNTD
      from store_sales
      where ss_quantity between 6 and 10
        and (ss_list_price between 145 and 145+10
          or ss_coupon_amt between 14792 and 14792+1000
          or ss_wholesale_cost between 46 and 46+20)) B2,
     (select avg(ss_list_price) B3_LP
            ,count(ss_list_price) B3_CNT
            ,count(distinct ss_list_price) B3_CNTD
      from store_sales
      where ss_quantity between 11 and 15
        and (ss_list_price between 150 and 150+10
          or ss_coupon_amt between 6600 and 6600+1000
          or ss_wholesale_cost between 9 and 9+20)) B3,
     (select avg(ss_list_price) B4_LP
            ,count(ss_list_price) B4_CNT
            ,count(distinct ss_list_price) B4_CNTD
      from store_sales
      where ss_quantity between 16 and 20
        and (ss_list_price between 91 and 91+10
          or ss_coupon_amt between 13493 and 13493+1000
          or ss_wholesale_cost between 36 and 36+20)) B4,
     (select avg(ss_list_price) B5_LP
            ,count(ss_list_price) B5_CNT
            ,count(distinct ss_list_price) B5_CNTD
      from store_sales
      where ss_quantity between 21 and 25
        and (ss_list_price between 0 and 0+10
          or ss_coupon_amt between 7629 and 7629+1000
          or ss_wholesale_cost between 6 and 6+20)) B5,
     (select avg(ss_list_price) B6_LP
            ,count(ss_list_price) B6_CNT
            ,count(distinct ss_list_price) B6_CNTD
      from store_sales
      where ss_quantity between 26 and 30
        and (ss_list_price between 89 and 89+10
          or ss_coupon_amt between 15257 and 15257+1000
          or ss_wholesale_cost between 31 and 31+20)) B6
 LIMIT 100;

-- end query 28 in stream 0 using template query28.tpl
```

## Previous Attempts

### Worker 1: conservative_safe_optimizations
- **Status**: pass (1.05x)
- **Transforms**: none
- **Examples used**: pushdown, materialize_cte, early_filter
- **Strategy hint**: Apply filter pushdown to ensure each subquery filters rows early, use CTE materialization to avoid redundant computation, and filter the fact table before aggregation for minimal risk.

```sql
WITH store_sales_filtered AS (
  SELECT
    ss_quantity,
    ss_list_price,
    CASE
      WHEN ss_quantity BETWEEN 0 AND 5
        AND (ss_list_price BETWEEN 131 AND 141
             OR ss_coupon_amt BETWEEN 16798 AND 17798
             OR ss_wholesale_cost BETWEEN 25 AND 45) THEN 1
      WHEN ss_quantity BETWEEN 6 AND 10
        AND (ss_list_price BETWEEN 145 AND 155
             OR ss_coupon_amt BETWEEN 14792 AND 15792
             OR ss_wholesale_cost BETWEEN 46 AND 66) THEN 2
      WHEN ss_quantity BETWEEN 11 AND 15
        AND (ss_list_price BETWEEN 150 AND 160
             OR ss_coupon_amt BETWEEN 6600 AND 7600
             OR ss_wholesale_cost BETWEEN 9 AND 29) THEN 3
      WHEN ss_quantity BETWEEN 16 AND 20
        AND (ss_list_price BETWEEN 91 AND 101
             OR ss_coupon_amt BETWEEN 13493 AND 14493
             OR ss_wholesale_cost BETWEEN 36 AND 56) THEN 4
      WHEN ss_quantity BETWEEN 21 AND 25
        AND (ss_list_price BETWEEN 0 AND 10
             OR ss_coupon_amt BETWEEN 7629 AND 8629
             OR ss_wholesale_cost BETWEEN 6 AND 26) THEN 5
      WHEN ss_quantity BETWEEN 26 AND 30
        AND (ss_list_price BETWEEN 89 AND 99
             OR ss_coupon_amt BETWEEN 15257 AND 16257
             OR ss_wholesale_cost BETWEEN 31 AND 51) THEN 6
      ELSE NULL
-- ... (truncated)
```

### Worker 2: moderate_cte_restructuring
- **Status**: pass (1.02x)
- **Transforms**: none
- **Examples used**: dimension_cte_isolate, multi_date_range_cte, union_cte_split
- **Strategy hint**: Restructure using CTEs to isolate each quantity range as a separate filtered dataset, enabling better predicate pushdown and potential plan optimization for each range.

```sql
WITH bucket_data AS (
  SELECT 
    ss_list_price,
    CASE 
      WHEN ss_quantity BETWEEN 0 AND 5 
        AND (ss_list_price BETWEEN 131 AND 141
             OR ss_coupon_amt BETWEEN 16798 AND 17798
             OR ss_wholesale_cost BETWEEN 25 AND 45) THEN 1
      WHEN ss_quantity BETWEEN 6 AND 10 
        AND (ss_list_price BETWEEN 145 AND 155
             OR ss_coupon_amt BETWEEN 14792 AND 15792
             OR ss_wholesale_cost BETWEEN 46 AND 66) THEN 2
      WHEN ss_quantity BETWEEN 11 AND 15 
        AND (ss_list_price BETWEEN 150 AND 160
             OR ss_coupon_amt BETWEEN 6600 AND 7600
             OR ss_wholesale_cost BETWEEN 9 AND 29) THEN 3
      WHEN ss_quantity BETWEEN 16 AND 20 
        AND (ss_list_price BETWEEN 91 AND 101
             OR ss_coupon_amt BETWEEN 13493 AND 14493
             OR ss_wholesale_cost BETWEEN 36 AND 56) THEN 4
      WHEN ss_quantity BETWEEN 21 AND 25 
        AND (ss_list_price BETWEEN 0 AND 10
             OR ss_coupon_amt BETWEEN 7629 AND 8629
             OR ss_wholesale_cost BETWEEN 6 AND 26) THEN 5
      WHEN ss_quantity BETWEEN 26 AND 30 
        AND (ss_list_price BETWEEN 89 AND 99
             OR ss_coupon_amt BETWEEN 15257 AND 16257
             OR ss_wholesale_cost BETWEEN 31 AND 51) THEN 6
    END AS bucket
  FROM store_sales
-- ... (truncated)
```

### Worker 3: aggressive_single_pass
- **Status**: pass (0.57x)
- **Transforms**: none
- **Examples used**: single_pass_aggregation, prefetch_fact_join, shared_dimension_multi_channel
- **Strategy hint**: Consolidate all six subqueries into a single table scan with conditional aggregation, prefetch filtered data into CTEs, and share common filter logic across ranges.

```sql
WITH all_data AS (
  SELECT 
    ss_quantity,
    ss_list_price,
    ss_coupon_amt,
    ss_wholesale_cost,
    -- Pre-compute bucket flags for conditional aggregation
    CASE WHEN ss_quantity BETWEEN 0 AND 5 
          AND (ss_list_price BETWEEN 131 AND 141 
               OR ss_coupon_amt BETWEEN 16798 AND 17798 
               OR ss_wholesale_cost BETWEEN 25 AND 45) 
         THEN 1 ELSE 0 END AS bucket1_flag,
    CASE WHEN ss_quantity BETWEEN 6 AND 10 
          AND (ss_list_price BETWEEN 145 AND 155 
               OR ss_coupon_amt BETWEEN 14792 AND 15792 
               OR ss_wholesale_cost BETWEEN 46 AND 66) 
         THEN 1 ELSE 0 END AS bucket2_flag,
    CASE WHEN ss_quantity BETWEEN 11 AND 15 
          AND (ss_list_price BETWEEN 150 AND 160 
               OR ss_coupon_amt BETWEEN 6600 AND 7600 
               OR ss_wholesale_cost BETWEEN 9 AND 29) 
         THEN 1 ELSE 0 END AS bucket3_flag,
    CASE WHEN ss_quantity BETWEEN 16 AND 20 
          AND (ss_list_price BETWEEN 91 AND 101 
               OR ss_coupon_amt BETWEEN 13493 AND 14493 
               OR ss_wholesale_cost BETWEEN 36 AND 56) 
         THEN 1 ELSE 0 END AS bucket4_flag,
    CASE WHEN ss_quantity BETWEEN 21 AND 25 
          AND (ss_list_price BETWEEN 0 AND 10 
               OR ss_coupon_amt BETWEEN 7629 AND 8629 
-- ... (truncated)
```

### Worker 4: novel_or_to_union_transform
- **Status**: pass (0.78x)
- **Transforms**: none
- **Examples used**: or_to_union, composite_decorrelate_union, intersect_to_exists
- **Strategy hint**: Transform OR conditions into UNION ALL branches for better index usage, decorrelate multiple disjunctive filters, and apply intersect/exists conversions for structural novelty.

```sql
WITH 
B1_pre AS (
    SELECT ss_list_price
    FROM store_sales
    WHERE ss_quantity BETWEEN 0 AND 5
      AND ss_list_price BETWEEN 131 AND 131 + 10
    UNION ALL
    SELECT ss_list_price
    FROM store_sales
    WHERE ss_quantity BETWEEN 0 AND 5
      AND ss_coupon_amt BETWEEN 16798 AND 16798 + 1000
    UNION ALL
    SELECT ss_list_price
    FROM store_sales
    WHERE ss_quantity BETWEEN 0 AND 5
      AND ss_wholesale_cost BETWEEN 25 AND 25 + 20
),
B2_pre AS (
    SELECT ss_list_price
    FROM store_sales
    WHERE ss_quantity BETWEEN 6 AND 10
      AND ss_list_price BETWEEN 145 AND 145 + 10
    UNION ALL
    SELECT ss_list_price
    FROM store_sales
    WHERE ss_quantity BETWEEN 6 AND 10
      AND ss_coupon_amt BETWEEN 14792 AND 14792 + 1000
    UNION ALL
    SELECT ss_list_price
    FROM store_sales
-- ... (truncated)
```

### Worker 5: refined_snipe
- **Status**: pass (0.66x)
- **Transforms**: none
- **Examples used**: 
- **Strategy hint**: Snipe from iter 1

```sql
SELECT
    B1_LP, B1_CNT, B1_CNTD,
    B2_LP, B2_CNT, B2_CNTD,
    B3_LP, B3_CNT, B3_CNTD,
    B4_LP, B4_CNT, B4_CNTD,
    B5_LP, B5_CNT, B5_CNTD,
    B6_LP, B6_CNT, B6_CNTD
FROM (
    SELECT
        AVG(CASE WHEN ss_quantity BETWEEN 0 AND 5 AND (
                ss_list_price BETWEEN 131 AND 141 OR 
                ss_coupon_amt BETWEEN 16798 AND 17798 OR 
                ss_wholesale_cost BETWEEN 25 AND 45
            ) THEN ss_list_price END) AS B1_LP,
        COUNT(CASE WHEN ss_quantity BETWEEN 0 AND 5 AND (
                ss_list_price BETWEEN 131 AND 141 OR 
                ss_coupon_amt BETWEEN 16798 AND 17798 OR 
                ss_wholesale_cost BETWEEN 25 AND 45
            ) THEN ss_list_price END) AS B1_CNT,
        COUNT(DISTINCT CASE WHEN ss_quantity BETWEEN 0 AND 5 AND (
                ss_list_price BETWEEN 131 AND 141 OR 
                ss_coupon_amt BETWEEN 16798 AND 17798 OR 
                ss_wholesale_cost BETWEEN 25 AND 45
            ) THEN ss_list_price END) AS B1_CNTD,
        
        AVG(CASE WHEN ss_quantity BETWEEN 6 AND 10 AND (
                ss_list_price BETWEEN 145 AND 155 OR 
                ss_coupon_amt BETWEEN 14792 AND 15792 OR 
                ss_wholesale_cost BETWEEN 46 AND 66
            ) THEN ss_list_price END) AS B2_LP,
-- ... (truncated)
```

## DAG Structure & Bottlenecks

| Node | Role | Cost % |
|------|------|-------:|
| main_query |  | 0.0% |

## Available Examples (Full Catalog)

- **composite_decorrelate_union** (2.42xx) — Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT
- **date_cte_isolate** (4.00xx) — Extract date filtering into a separate CTE to enable predicate pushdown and redu
- **decorrelate** (2.92xx) — Convert correlated subquery to separate CTE with GROUP BY, then JOIN
- **deferred_window_aggregation** (1.36xx) — When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joi
- **dimension_cte_isolate** (1.93xx) — Pre-filter ALL dimension tables into CTEs before joining with fact table, not ju
- **early_filter** (4.00xx) — Filter dimension tables FIRST, then join to fact tables to reduce expensive join
- **intersect_to_exists** (1.83xx) — Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join pl
- **materialize_cte** (1.37xx) — Extract repeated subquery patterns into a CTE to avoid recomputation
- **multi_date_range_cte** (2.35xx) — When query uses multiple date_dim aliases with different filters (d1, d2, d3), c
- **multi_dimension_prefetch** (2.71xx) — Pre-filter multiple dimension tables (date + store) into separate CTEs before jo
- **or_to_union** (3.17xx) — Split OR conditions on different columns into UNION ALL branches for better inde
- **prefetch_fact_join** (3.77xx) — Pre-filter dimension table into CTE, then pre-join with fact table in second CTE
- **pushdown** (2.11xx) — Push filters from outer query into CTEs/subqueries to reduce intermediate result
- **shared_dimension_multi_channel** (1.30xx) — Extract shared dimension filters (date, item, promotion) into CTEs when multiple
- **single_pass_aggregation** (4.47xx) — Consolidate multiple subqueries scanning the same table into a single CTE with c
- **union_cte_split** (1.36xx) — Split a generic UNION ALL CTE into specialized CTEs when the main query filters 

## Your Task

Analyze the failed attempts and design a refined approach:

1. **Failure Analysis**: Why did all attempts fall short? Be specific about mechanisms.
2. **Common Patterns**: What did multiple workers try unsuccessfully?
3. **Unexplored Space**: What optimization angles were missed entirely?
4. **Refined Strategy**: Synthesize a NEW approach combining best insights.

### Output Format (follow EXACTLY)

```
FAILURE_ANALYSIS:
<Why all workers fell short — be specific about mechanisms>

UNEXPLORED_OPPORTUNITIES:
<What optimization approaches haven't been tried>

REFINED_STRATEGY:
<Concrete optimization approach for next attempt>

EXAMPLES: <ex1>, <ex2>, <ex3>
HINT: <specific guidance for the refined attempt>
```