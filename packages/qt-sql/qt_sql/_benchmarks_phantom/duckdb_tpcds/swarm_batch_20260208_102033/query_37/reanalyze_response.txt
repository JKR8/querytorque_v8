FAILURE_ANALYSIS:
All workers fell short due to misapplied optimization patterns that increased overhead without addressing the true bottleneck: the large-scale join between inventory and catalog_sales with different cardinalities. Worker 1-4 used CTE isolation correctly but missed the fundamental issue that the join between inventory (filtered by date/quantity) and catalog_sales (no filters) creates massive intermediate results. Worker 5 catastrophically failed by joining on wrong columns (inv_item_sk = d_date_sk), creating a Cartesian product. The core issue is that the original query joins four tables then groups, while all attempts maintained this four-way join structure. None transformed the join order to exploit the fact that catalog_sales is only used for existence checking (via the group by on i_item_id after joining).

UNEXPLORED_OPPORTUNITIES:
1. Convert the catalog_sales join to an early semi-join before joining with inventory
2. Use Bloom filter or early aggregation on inventory to reduce rows before expensive joins
3. Leverage composite indexes via predicate ordering (i_manufact_id + i_current_price)
4. Transform the GROUP BY into a DISTINCT with pre-aggregated existence check
5. Use lateral joins or window functions to avoid the four-way join entirely

REFINED_STRATEGY:
Transform the query to push the catalog_sales existence check EARLY using a semi-join, then join with pre-filtered inventory and items. Specifically: 1) Filter items by price/manufacturer, 2) Check existence in catalog_sales via EXISTS, 3) Join with inventory filtered by date and quantity, 4) Remove GROUP BY since duplicates only come from inventory joins and we can use DISTINCT on item keys after filtering. This reduces the join fan-out dramatically.

EXAMPLES: early_filter, decorrelate, single_pass_aggregation
HINT: Push catalog_sales existence check to item-level first using EXISTS, then join with pre-aggregated inventory data using window functions to avoid duplicates, finally apply DISTINCT instead of GROUP BY.

```sql
WITH filtered_items AS (
    SELECT 
        i_item_sk,
        i_item_id,
        i_item_desc,
        i_current_price
    FROM item
    WHERE i_current_price BETWEEN 45 AND 75
      AND i_manufact_id IN (856, 707, 1000, 747)
      AND EXISTS (
          SELECT 1 
          FROM catalog_sales 
          WHERE cs_item_sk = i_item_sk
      )
),
filtered_dates AS (
    SELECT d_date_sk
    FROM date_dim
    WHERE d_date BETWEEN CAST('1999-02-21' AS DATE) 
                     AND (CAST('1999-02-21' AS DATE) + INTERVAL '60' DAY)
),
inventory_aggregated AS (
    SELECT 
        inv_item_sk,
        MAX(inv_date_sk) as inv_date_sk
    FROM inventory
    WHERE inv_quantity_on_hand BETWEEN 100 AND 500
    GROUP BY inv_item_sk
)
SELECT DISTINCT
    fi.i_item_id,
    fi.i_item_desc,
    fi.i_current_price
FROM filtered_items fi
JOIN inventory_aggregated ia ON fi.i_item_sk = ia.inv_item_sk
JOIN filtered_dates fd ON ia.inv_date_sk = fd.d_date_sk
ORDER BY fi.i_item_id
LIMIT 100;
```