```sql
WITH filtered_dates AS (
    SELECT d_date_sk
    FROM date_dim
    WHERE d_year = 1999
      AND d_moy = 11
),
filtered_stores AS (
    SELECT s_store_sk
    FROM store
    WHERE s_gmt_offset = -7
),
filtered_addresses AS (
    SELECT ca_address_sk
    FROM customer_address
    WHERE ca_gmt_offset = -7
),
filtered_items AS (
    SELECT i_item_sk
    FROM item
    WHERE i_category = 'Jewelry'
),
filtered_promotions AS (
    SELECT p_promo_sk
    FROM promotion
    WHERE p_channel_dmail = 'Y'
       OR p_channel_email = 'Y'
       OR p_channel_tv = 'Y'
),
joined_data AS (
    SELECT
        ss.ss_ext_sales_price,
        CASE WHEN fp.p_promo_sk IS NOT NULL THEN ss.ss_ext_sales_price ELSE 0.0 END AS promo_price
    FROM store_sales ss
    JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk
    JOIN filtered_stores fs ON ss.ss_store_sk = fs.s_store_sk
    JOIN filtered_addresses fa ON ss.ss_customer_sk = c_customer_sk
    JOIN customer c ON c.c_current_addr_sk = fa.ca_address_sk
    JOIN filtered_items fi ON ss.ss_item_sk = fi.i_item_sk
    LEFT JOIN filtered_promotions fp ON ss.ss_promo_sk = fp.p_promo_sk
)
SELECT
    SUM(promo_price) AS promotions,
    SUM(ss_ext_sales_price) AS total,
    CAST(SUM(promo_price) AS DECIMAL(15, 4)) / 
    CAST(SUM(ss_ext_sales_price) AS DECIMAL(15, 4)) * 100
FROM joined_data
ORDER BY promotions, total
LIMIT 100
```

**Changes**: Applied dimension_cte_isolate pattern to pre-filter all dimension tables (date_dim, store, customer_address, item, promotion) into tiny CTEs containing only surrogate keys, then performed a single-pass aggregation with conditional logic to compute both promotional and total sales.

**Expected speedup**: 2.0x+ by reducing large dimension table scans to tiny filtered CTEs, eliminating redundant computation of the same joins, and enabling better hash join optimization with pre-filtered dimension keys.