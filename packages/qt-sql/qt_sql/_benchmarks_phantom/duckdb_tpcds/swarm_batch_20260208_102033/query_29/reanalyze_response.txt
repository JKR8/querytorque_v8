FAILURE_ANALYSIS:
All attempts fell short because they failed to fundamentally restructure the star-join pattern. Worker 1's error stemmed from attempting to push filters into subqueries without maintaining column references. Workers 2, 4, and 5 achieved only ~1.0x because they merely prefetched dimension filters without optimizing the core problem: the triple Cartesian join pattern (store_sales × store_returns × catalog_sales) where each fact table joins through different date_dim aliases. These CTE-based prefiltering approaches didn't address the explosive intermediate join cardinality. Worker 3's slowdown (0.87x) suggests the optimizer couldn't leverage prefetching effectively. All attempts treated the three fact tables symmetrically, missing asymmetric optimization opportunities based on join cardinality and filtering selectivity.

UNEXPLORED_OPPORTUNITIES:
1. **Single-pass aggregation on largest fact table**: Use `single_pass_aggregation` to pre-aggregate store_sales (the largest fact table) by (item, store, customer, ticket) before joining, reducing downstream join cardinality.
2. **Fact-driven decorrelation**: Instead of symmetric CTEs, chain the joins linearly: filter store_sales → join to store_returns → join to catalog_sales, materializing intermediate results.
3. **Columnar pruning**: Select only required columns early, especially dropping unused keys after joins.
4. **Join reordering with statistics**: Explicitly control join order based on filtered table sizes.
5. **Predicate pushthrough**: Push date predicates through fact-to-fact joins using WHERE EXISTS patterns.

REFINED_STRATEGY:
1. **Primary fact table pre-aggregation**: Create a CTE that pre-aggregates store_sales with its date filter (d1), store, and item, grouping by all join keys needed for subsequent joins (ss_item_sk, ss_store_sk, ss_customer_sk, ss_ticket_number).
2. **Chained fact joins with early materialization**: Join the pre-aggregated store_sales to store_returns (with d2 filter) in a second CTE, computing partial aggregates. Then join that result to catalog_sales (with d3 filter) in a third CTE.
3. **Column pruning at each stage**: At each CTE, drop join keys immediately after they're used to reduce memory footprint.
4. **Final aggregation consolidation**: Perform the final AVG() calculations in the outermost query using the pre-aggregated quantities.
5. **Selective UNION for d3 years**: Use `or_to_union` for d3's year filter (1999,2000,2001) to enable partition pruning.

EXAMPLES: single_pass_aggregation, early_filter, or_to_union, prefetch_fact_join, decorrelate
HINT: Start by aggregating store_sales at the grain of (ss_item_sk, ss_store_sk, ss_customer_sk, ss_ticket_number) with SUM(ss_quantity) and COUNT(ss_quantity) for later averaging. Then join to store_returns similarly aggregated, then to catalog_sales. Use explicit JOIN ordering with smallest filtered relations first.