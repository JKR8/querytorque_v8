FAILURE_ANALYSIS:
All attempts fell short due to two primary mechanisms:
1. **Column projection errors**: Workers 2 and 3 attempted dimension isolation but incorrectly projected only date_sk columns while subsequent CTEs needed d_date for grouping/output. DuckDB's column binding occurs during parsing, causing fatal errors before execution.
2. **Insufficient structural transformations**: Workers 1, 4, and 5 achieved only modest speedups (1.14x-1.24x) because they kept the original nested subquery pattern intact. The IN subqueries in the main query force repeated evaluation against catalog_sales/web_sales, preventing efficient join reordering and parallelization. No attempt addressed the core bottleneck: multiple independent CTEs scanning store_sales separately with similar date filters but different join patterns.

UNEXPLORED_OPPORTUNITIES:
1. **Single-pass store_sales aggregation**: Combine the three store_sales scans (frequent_ss_items, max_store_sales, best_ss_customer) into one pre-filtered CTE with comprehensive aggregations.
2. **Decorrelate IN subqueries**: Convert the main query's IN subqueries to explicit joins with pre-materialized dimension keys.
3. **Union factorization**: Pre-join frequent_ss_items and best_ss_customer with catalog_sales/web_sales separately before union, allowing predicate pushdown into each channel.
4. **Column pruning in CTEs**: Project only essential keys (item_sk, customer_sk) from intermediate CTEs when full rows aren't needed downstream.

REFINED_STRATEGY:
1. Create a consolidated store_sales CTE filtered once for years 2000-2003, joining with date_dim and extracting all needed dimensions (item_sk, customer_sk, d_date, ss_quantity*ss_sales_price).
2. Compute frequent_ss_items and customer aggregates in parallel from this single CTE using GROUP BY GROUPING SETS or separate CTEs sharing the same base.
3. Materialize distinct item_sk and customer_sk from these aggregations into separate CTEs for dimension keys only.
4. In main query, pre-join catalog_sales/web_sales with May 2000 date filter, then join with dimension key CTEs using explicit INNER JOINs instead of IN subqueries.
5. Ensure all dimension-isolating CTEs project required columns (d_date where needed) to avoid binder errors.

EXAMPLES: single_pass_aggregation, decorrelate, pushdown, dimension_cte_isolate
HINT: Build a single base CTE for store_sales filtered on d_year IN (2000,2001,2002,2003) with joins to date_dim and item. From it, compute both frequent items (group by item_sk, d_date, substr) and customer sales aggregates. Materialize results as two key-only CTEs. In main query, filter catalog_sales/web_sales with May 2000 date CTE first, then join with key CTEs explicitly.