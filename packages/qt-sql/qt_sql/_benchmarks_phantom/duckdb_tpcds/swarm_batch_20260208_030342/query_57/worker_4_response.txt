```sql
WITH filtered_dates AS (
    SELECT d_date_sk, d_year, d_moy
    FROM date_dim
    WHERE (d_year = 1999)
       OR (d_year = 1998 AND d_moy = 12)
       OR (d_year = 2000 AND d_moy = 1)
),
v1 AS (
    SELECT
        i_category,
        i_brand,
        cc_name,
        d_year,
        d_moy,
        SUM(cs_sales_price) AS sum_sales,
        AVG(SUM(cs_sales_price)) OVER (PARTITION BY i_category, i_brand, cc_name, d_year) AS avg_monthly_sales,
        RANK() OVER (PARTITION BY i_category, i_brand, cc_name ORDER BY d_year, d_moy) AS rn
    FROM item
    JOIN catalog_sales ON cs_item_sk = i_item_sk
    JOIN filtered_dates ON cs_sold_date_sk = d_date_sk
    JOIN call_center ON cc_call_center_sk = cs_call_center_sk
    GROUP BY
        i_category,
        i_brand,
        cc_name,
        d_year,
        d_moy
),
v2 AS (
    SELECT
        v1.i_brand,
        v1.d_year,
        v1.avg_monthly_sales,
        v1.sum_sales,
        LAG(v1.sum_sales) OVER (PARTITION BY v1.i_category, v1.i_brand, v1.cc_name ORDER BY v1.d_year, v1.d_moy) AS psum,
        LEAD(v1.sum_sales) OVER (PARTITION BY v1.i_category, v1.i_brand, v1.cc_name ORDER BY v1.d_year, v1.d_moy) AS nsum
    FROM v1
)
SELECT
    *
FROM v2
WHERE
    d_year = 1999
    AND avg_monthly_sales > 0
    AND ABS(sum_sales - avg_monthly_sales) / avg_monthly_sales > 0.1
    AND psum IS NOT NULL
    AND nsum IS NOT NULL
ORDER BY
    sum_sales - avg_monthly_sales,
    nsum
LIMIT 100
```

**Changes:** 
1. Transformed the OR conditions on date_dim into a filtered CTE for better predicate pushdown.
2. Replaced the 3-way self-join with window functions (LAG/LEAD) to avoid expensive triangular joins.
3. Simplified the CASE expression since avg_monthly_sales > 0 filter already guarantees positive values.

**Expected speedup:** ~2-3x due to eliminating the self-join and enabling better date filtering pushdown.