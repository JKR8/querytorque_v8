# Beam Pipeline v3 — Smart Dispatch, Adaptive Probes, Evidence Sniper

This version removes AST-based routing and uses a reasoning dispatcher (R1) that chooses probes from plan evidence + a full transform catalog.
Probe count is adaptive using a ★ importance score, preventing “junk probes” on simple queries.

---

## Inputs that drive effort

### ★ Importance (1–3)
This is a per-query scoring signal from the DB / fleet system:

- ★★★: hardest / most expensive / most important → deeper search
- ★★: medium
- ★: easy / low importance

The dispatcher must adapt `probe_count` accordingly (and can early-stop if the query is already efficient).

---

## Core Principle

- **Workers are narrow**: one transform, one precise target, produce a PatchPlan.
- **Sniper is evidence-informed**: reads BDA + deltas and produces ONE best compound PatchPlan.
  - Sniper may combine wins OR propose a novel transform if workers missed the real hotspot.
  - Sniper is not a deterministic “plan zipper,” but must justify actions with evidence.

---

## Pipeline (per query mission)

```
STEP 0: Baseline
  - record original_ms, original_explain, original_sql_hash

STEP 1: SMART DISPATCH (R1, 1 call)
  Inputs: importance★ + target_dialect + engine profile + original_sql + explain + IR map + full transform catalog
  Output: probe_count + 4–16 probe assignments (single-transform)

STEP 2: WORKERS (4–16, parallel; typically small models)
  Each worker receives:
    - shared hypothesis (from dispatch)
    - ONE probe assignment (transform + target + node_contract + gates_checked)
    - original SQL + IR map (+ optional plan snippet)
    - target_dialect + engine profile (authoritative dialect constraints)
    - patch ops + semantic rules + anchor-hash rules
  Output: PatchPlan JSON

STEP 3: APPLY PATCH + TIER-1 GATE
  - Apply PatchPlan to IR
  - Structural validation: parse, refs, aliasing, literals unchanged, no orphan scans
  - Retry-once policy per probe with concrete error message (optional)

STEP 4: EQUIVALENCE GATE
  - Use tiered equivalence policy:
    - `exact`: row count + checksum/MD5 vs baseline
    - `unordered`: row count + order-insensitive checksum
    - `nondeterministic`: row count + bounded sample/value checks for volatile queries
  - Retry-once policy with failure notes (optional)

STEP 5: BENCHMARK
  - Only for equivalence-passing candidates
  - Record speedup, variance

STEP 6: EXPLAIN COLLECTION
  - Capture EXPLAIN for passing candidates

STEP 7: COLLATE BDA TABLE
  - One row per probe: status, speedup, explain_delta, ops_used, failure_reason

STEP 8: SNIPER (R1, 1 call)
  Inputs: importance★ + target_dialect + engine profile + full BDA table + worker SQL patches + explain deltas
  Output: ONE highest-probability compound PatchPlan, or TWO when pathways are genuinely competing
  Rules: prefer 1–3 steps; if >3, justify complexity + risk and provide a fallback threshold

STEP 9: RE-VALIDATE SNIPER PATCH
  - Steps 3–6 again on the sniper output
  - Final: best_speedup, best_patch_plan, derived SQL
```

---

## Probe count policy (dispatcher)

Recommended defaults:
- ★★★: 12–16 probes (include 1–2 exploration)
- ★★: 8–12 probes (optional exploration)
- ★: 4–8 probes (exploration optional)

Dispatcher may set `early_stop: true` for already-efficient plans.
Exploration probes should target a secondary hotspot and, when possible, use a family not represented in primary probes.

---

## Collated Results Table (BDA schema)

Minimum fields (per probe):

- `probe_id`
- `transform_id`, `family`
- `status`: PASS | WIN | REGRESSION | FAIL_TIER1 | FAIL_EQUIV | ERROR
- `speedup` (if benchmarked)
- `benchmark_ms` (optional)
- `ops_used`
- `explain_delta`: 1–2 lines (operator replaced, loops reduced, rows reduced)
- `failure_reason` (if any)
- `notes` (optional; short)

This table is the primary evidence surface for the Sniper.

---

## Prompt caching discipline

All prompts must be structured like:

1) **Static header** (dialect rules, patch ops, registries, schemas)
2) `## Cache Boundary`
3) **Dynamic tail** (★ score, SQL, plan, IR hashes, catalog, BDA)

This makes caching stable across missions and reduces token waste.

---

## Patch IR + Anchor Hashes (robustness requirement)

- Anchor hashes must be generated by a deterministic parser and be **whitespace/formatting independent**.
- Patch steps that reference `by_anchor_hash` must remain valid under benign formatting changes.
- If anchors are missing or ambiguous, prefer coarse ops (`replace_where_predicate`) or no-op.

---

## Files

- `beam_dispatcher_v3.txt` — Smart dispatch prompt with adaptive probe count + probe summary schema
- `beam_worker_v3.txt` — Single-transform worker prompt with strict anchor-hash rules
- `beam_sniper_v3.txt` — Evidence-informed sniper prompt (free to innovate; must justify; outputs one best PatchPlan)
