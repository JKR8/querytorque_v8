## Role

Transform a SQL query by applying ONE specific optimization. Target engine: PostgreSQL.
Output a PatchPlan JSON that transforms the query's IR structure.

## Prompt Map

### Phase A — Cached Instructions
A1. Patch operations and output rules
A2. Verification checklist
A3. Gold pattern reference (if provided)

### Phase B — Probe-Specific Input
B1. Probe assignment + node contract
B2. Original SQL
B3. Current IR node map

## Patch Operations

| Op | Description | Payload |
|----|-------------|---------|
| insert_cte | Add a new CTE to the WITH clause | cte_name, cte_query_sql |
| replace_from | Replace the FROM clause | from_sql |
| replace_where_predicate | Replace the WHERE clause | expr_sql |
| replace_body | Replace entire query body (SELECT, FROM, WHERE, GROUP BY) | sql_fragment |
| replace_expr_subtree | Replace a specific expression | expr_sql (+ by_anchor_hash) |
| delete_expr_subtree | Remove a specific expression | (target only, no payload) |

## Instructions

1. Read the **Target** description — it tells you WHERE and HOW to apply the transform
2. Respect **Node Contract** as target-state spec (FROM/WHERE/OUTPUT).
3. Design a target IR showing what the optimized query should look like
4. Build patch steps to get from current IR → target IR
5. Adapt the gold pattern shape; never copy literal SQL
6. All SQL in payloads must be complete, executable fragments (no ellipsis)
7. Use dialect: "postgres" in the output
8. Target all steps at by_node_id: "S0" (the main statement)

**Semantic guards** — MUST preserve:
- All WHERE/HAVING/ON conditions exactly
- All literal values unchanged (35*0.01 stays as 35*0.01)
- Column names, aliases, ORDER BY, and LIMIT exactly
- Do NOT add new filter conditions
- No orphaned CTEs or duplicated source scans after replacement

## Verification Checklist
- [ ] every new CTE has a selective WHERE
- [ ] no orphaned CTEs/tables remain
- [ ] EXISTS semantics preserved unless anti-join decorrelation is explicit
- [ ] same-column OR conditions were not split into UNION branches
- [ ] downstream consumers have all required projected columns

Output ONLY the JSON object (no markdown, no explanation).

---

## Cache Boundary
Everything below is probe-specific input.

## Probe Assignment

**Transform**: decorrelate_not_exists_to_cte (Family B)
**Hypothesis**: The bottleneck is repeated correlated subqueries scanning store_sales per row.
**Target**: Convert the NOT EXISTS correlated subquery into a MATERIALIZED CTE: SELECT DISTINCT customer_sk FROM web_sales JOIN date_dim WHERE d_year = 2002. Then replace NOT EXISTS with LEFT JOIN cte ... IS NULL anti-pattern.
**Phase**: ?
**Exploration**: no

### Gates Checked
not provided

### Node Contract

not provided

### Original SQL

```sql
select 
  cd_gender,
  cd_marital_status,
  cd_education_status,
  count(*) cnt1,
  cd_purchase_estimate,
  count(*) cnt2,
  cd_credit_rating,
  count(*) cnt3
 from
  customer c,customer_address ca,customer_demographics
 where
  c.c_current_addr_sk = ca.ca_address_sk and
  ca_state in ('CO','NC','TX') and
  cd_demo_sk = c.c_current_cdemo_sk
  and cd_marital_status in ('S', 'M', 'U')
  and cd_education_status in ('Primary', 'College') and
  exists (select *
          from store_sales,date_dim
          where c.c_customer_sk = ss_customer_sk and
                ss_sold_date_sk = d_date_sk and
                d_year = 2002 and
                d_moy between 10 and 10+2
                and ss_list_price between 80 and 169
          ) and
   (not exists (select *
            from web_sales,date_dim
            where c.c_customer_sk = ws_bill_customer_sk and
                  ws_sold_date_sk = d_date_sk and
                  d_year = 2002 and
                  d_moy between 10 and 10+2
                  and ws_list_price between 80 and 169
            ) and
    not exists (select *
            from catalog_sales,date_dim
            where c.c_customer_sk = cs_ship_customer_sk and
                  cs_sold_date_sk = d_date_sk and
                  d_year = 2002 and
                  d_moy between 10 and 10+2
                  and cs_list_price between 80 and 169)
            )
 group by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating
 order by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating
 limit 100;
```

### Current IR Node Map

```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: customer c, customer_address ca, customer_demographics
    WHERE [dae945277e160f9b]: c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_cu...
    GROUP BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    ORDER BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

### Gold Pattern Reference
- `plan_id`: `gold_postgres_early_filter_decorrelate`
- `step_ops`: insert_cte -> insert_cte+replace_from -> replace_from -> replace_where_predicate
- `ctes`: `store_thresholds`
- Reuse pattern shape, not literal table/column names.
