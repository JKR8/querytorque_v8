## Role

Transform this SQL query by applying ONE specific optimization. Target engine: PostgreSQL.
Output a PatchPlan JSON that transforms the query's IR structure.

**Transform**: decorrelate_not_exists_to_cte (Family B)
**Hypothesis**: The bottleneck is repeated correlated subqueries scanning store_sales per row.
**Target**: Convert the NOT EXISTS correlated subquery into a MATERIALIZED CTE: SELECT DISTINCT customer_sk FROM web_sales JOIN date_dim WHERE d_year = 2002. Then replace NOT EXISTS with LEFT JOIN cte ... IS NULL anti-pattern.

## Original SQL

```sql
select 
  cd_gender,
  cd_marital_status,
  cd_education_status,
  count(*) cnt1,
  cd_purchase_estimate,
  count(*) cnt2,
  cd_credit_rating,
  count(*) cnt3
 from
  customer c,customer_address ca,customer_demographics
 where
  c.c_current_addr_sk = ca.ca_address_sk and
  ca_state in ('CO','NC','TX') and
  cd_demo_sk = c.c_current_cdemo_sk
  and cd_marital_status in ('S', 'M', 'U')
  and cd_education_status in ('Primary', 'College') and
  exists (select *
          from store_sales,date_dim
          where c.c_customer_sk = ss_customer_sk and
                ss_sold_date_sk = d_date_sk and
                d_year = 2002 and
                d_moy between 10 and 10+2
                and ss_list_price between 80 and 169
          ) and
   (not exists (select *
            from web_sales,date_dim
            where c.c_customer_sk = ws_bill_customer_sk and
                  ws_sold_date_sk = d_date_sk and
                  d_year = 2002 and
                  d_moy between 10 and 10+2
                  and ws_list_price between 80 and 169
            ) and
    not exists (select *
            from catalog_sales,date_dim
            where c.c_customer_sk = cs_ship_customer_sk and
                  cs_sold_date_sk = d_date_sk and
                  d_year = 2002 and
                  d_moy between 10 and 10+2
                  and cs_list_price between 80 and 169)
            )
 group by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating
 order by cd_gender,
          cd_marital_status,
          cd_education_status,
          cd_purchase_estimate,
          cd_credit_rating
 limit 100;
```

## Current IR Node Map

```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: customer c, customer_address ca, customer_demographics
    WHERE [dae945277e160f9b]: c.c_current_addr_sk = ca.ca_address_sk AND ca_state IN ('CO', 'NC', 'TX') AND cd_demo_sk = c.c_cu...
    GROUP BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating
    ORDER BY: cd_gender, cd_marital_status, cd_education_status, cd_purchase_estimate, cd_credit_rating

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Patch Operations

| Op | Description | Payload |
|----|-------------|---------|
| insert_cte | Add a new CTE to the WITH clause | cte_name, cte_query_sql |
| replace_from | Replace the FROM clause | from_sql |
| replace_where_predicate | Replace the WHERE clause | expr_sql |
| replace_body | Replace entire query body (SELECT, FROM, WHERE, GROUP BY) | sql_fragment |
| replace_expr_subtree | Replace a specific expression | expr_sql (+ by_anchor_hash) |
| delete_expr_subtree | Remove a specific expression | (target only, no payload) |

## Gold Patch Example (reference pattern)

```json
{
  "plan_id": "gold_postgres_early_filter_decorrelate",
  "dialect": "postgres",
  "description": "Early Selection + Decorrelation: push dimension filters into CTE definitions before materialization, and decorrelate correlated subqueries by pre-computing thresholds in separate CTEs. Filters reduce rows early; decorrelation replaces per-row subquery execution with a single pre-computed JOIN.",
  "preconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "postconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "store_thresholds",
        "cte_query_sql": "SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_limit FROM customer_total_return GROUP BY ctr_store_sk"
      },
      "description": "Insert CTE 'store_thresholds' for pre-aggregated computation"
    },
    {
      "step_id": "s2",
      "op": "replace_block_with_cte_pair",
      "target": {
        "by_node_id": "S0",
        "by_label": "customer_total_return"
      },
      "payload": {
        "sql_fragment": "customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_REFUNDED_CASH) AS ctr_total_return FROM store_returns JOIN date_dim ON sr_returned_date_sk = d_date_sk JOIN store ON sr_store_sk = s_store_sk WHERE d_year = 2001 AND s_state IN ('MI', 'NC', 'WI') AND sr_return_amt / sr_return_quantity BETWEEN 236 AND 295 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk)"
      },
      "description": "Replace CTE 'customer_total_return' body with optimized version"
    },
    {
      "step_id": "s3",
      "op": "replace_from",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "from_sql": "customer_total_return AS ctr1 JOIN store_thresholds AS st ON ctr1.ctr_store_sk = st.ctr_store_sk JOIN customer ON ctr1.ctr_customer_sk = c_customer_sk JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk JOIN store AS s ON ctr1.ctr_store_sk = s.s_store_sk"
      },
      "description": "Replace comma-join FROM with explicit JOINs"
    },
    {
      "step_id": "s4",
      "op": "replace_where_predicate",
      "target": {
        "by_node_id": "S0",
        "by_anchor_hash": "6eef64f061a2aa84"
      },
      "payload": {
        "expr_sql": "ctr1.ctr_total_return > st.avg_limit AND ctr1.ctr_reason_sk BETWEEN 28 AND 31 AND s.s_state IN ('MI', 'NC', 'WI') AND cd_marital_status = 'W' AND cd_education_status IN ('4 yr Degree', 'College') AND cd_gender = 'M' AND c_birth_month = 5 AND c_birth_year BETWEEN 1950 AND 1956"
      },
      "description": "Replace WHERE predicate with optimized version"
    }
  ]
}
```

## Instructions

1. Read the **Target** description above — it tells you WHERE and HOW to apply the transform
2. Design a target IR showing what the optimized query should look like
3. Build patch steps to get from current IR → target IR
4. Adapt the gold example pattern to THIS query's tables, columns, and predicates
5. All SQL in payloads must be complete, executable fragments (no ellipsis)
6. Use dialect: "postgres" in the output
7. Target all steps at by_node_id: "S0" (the main statement)

**Semantic guards** — MUST preserve:
- All WHERE/HAVING/ON conditions exactly
- All literal values unchanged (35*0.01 stays as 35*0.01)
- Column names, aliases, ORDER BY, and LIMIT exactly
- Do NOT add new filter conditions

Output ONLY the JSON object (no markdown, no explanation):