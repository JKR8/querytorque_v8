{
  "engine": "snowflake",
  "version_tested": "8.x (cloud)",
  "profile_type": "engine_profile",
  "briefing_note": "P1 (date CTE pruning) empirically proven — 22/35 tested (63% success). All wins TIMEOUT→completes. P2 (scan consolidation) 0/1 without date pruning.",
  "strengths": [
    {"id": "MICRO_PARTITION_PRUNING", "summary": "Filters on clustered columns skip micro-partitions at scan level", "implication": "Snowflake's #1 optimization. Functions on filter columns kill pruning. Runtime pruning from CTE values invisible in static EXPLAIN."},
    {"id": "COLUMN_PRUNING", "summary": "Reads only columns referenced by final query, even through CTEs", "implication": "Automatic unless final SELECT is *."},
    {"id": "PREDICATE_PUSHDOWN", "summary": "Filters pushed to storage layer including through single-ref CTEs", "implication": "Also does predicate mirroring across join sides. Does NOT push through comma joins for partition pruning."},
    {"id": "CORRELATED_DECORRELATION", "summary": "Correlated subqueries automatically decorrelated to hash joins", "implication": "Do NOT decorrelate unless EXPLAIN shows nested loop."},
    {"id": "SEMI_JOIN", "summary": "EXISTS → SemiJoin with early termination", "implication": "Never materialize EXISTS patterns."},
    {"id": "JOIN_FILTER", "summary": "Bloom filter pushdown from build side to probe-side TableScan", "implication": "77/99 TPC-DS queries. Date CTE does NOT interfere with JoinFilter."},
    {"id": "COST_BASED_JOIN_ORDER", "summary": "Evaluates multiple join orders, selects lowest cost", "implication": "Usually correct. Do NOT force join order."},
    {"id": "QUALIFY_OPTIMIZATION", "summary": "Native window-function filtering, more efficient than nested subquery", "implication": "Gives optimizer full visibility into filter intent."}
  ],
  "gaps": [
    {
      "id": "COMMA_JOIN_DATE_PRUNING_FAILURE",
      "priority": "HIGH",
      "goal": "SMALLEST_SET_FIRST",
      "detect": "Fact table: all partitions assigned in EXPLAIN, date filter exists on date_dim, comma join between fact and date_dim.",
      "gates": "REQUIRED: date range/year/month filter on date_dim. REQUIRED: fact table >1000 partitions. Narrower dates prune more: 30d→1s, 1yr→55-250s.",
      "what": "Comma joins between fact tables and date_dim prevent runtime partition pruning",
      "why": "Optimizer assigns all micro-partitions before resolving date filter through comma join. Date predicate never reaches fact scan.",
      "opportunity": "Isolate date_dim filter into CTE, JOIN to fact table. Enables runtime pruning invisible in EXPLAIN.",
      "frequency_pct": 63,
      "what_worked": "22 wins. Date CTE + explicit JOINs. Works for single-date, multi-date (d1/d2/d3), EXISTS subqueries, UNION branches. All from TIMEOUT→completes.",
      "what_didnt_work": "No date filter (Q9/Q88/Q93). CTE self-join (Q47/Q57). FULL OUTER JOIN (Q51/Q97). 3-way fact + wide date (Q17/Q29). Too heavy for X-Small (Q35/Q67/Q72/Q85/Q89). EXCEPT (Q87).",
      "field_notes": "Static EXPLAIN still shows all partitions — pruning is runtime only. SF10 partitions: store_sales 73K (1.2TB), catalog_sales 55K (861GB), web_sales 28K (461GB)."
    },
    {
      "id": "REPEATED_SUBQUERY_FULL_SCAN",
      "priority": "LOW",
      "goal": "DONT_REPEAT_WORK",
      "detect": "Same fact table scanned N times with similar filters.",
      "gates": "Without date pruning: insufficient on huge tables (Q9 failed — 73K partitions). Must preserve exact aggregation semantics.",
      "what": "Multiple identical subqueries on same fact table trigger independent full scans.",
      "why": "No CSE across subquery boundaries.",
      "opportunity": "Consolidate into single scan with conditional aggregation (CASE WHEN).",
      "what_worked": "Untested with date pruning.",
      "what_didnt_work": "Q9 TIMEOUT — 73K parts unavoidable without date filter.",
      "field_notes": "Needs more evidence. Only attempt after P1 (date pruning) is applied."
    }
  ]
}
