{
  "engine": "snowflake",
  "version_tested": "8.x (cloud)",
  "profile_type": "engine_profile",
  "briefing_note": "P3 (correlated scalar decorrelation) 2/2 (100%) — 23.17x and 7.82x wins on SF10TCL MEDIUM, 3x3 validated.",
  "strengths": [
    {"id": "MICRO_PARTITION_PRUNING", "summary": "Filters on clustered columns skip micro-partitions at scan level", "implication": "Snowflake's #1 optimization. Functions on filter columns kill pruning. Runtime pruning from CTE values invisible in static EXPLAIN."},
    {"id": "COLUMN_PRUNING", "summary": "Reads only columns referenced by final query, even through CTEs", "implication": "Automatic unless final SELECT is *."},
    {"id": "PREDICATE_PUSHDOWN", "summary": "Filters pushed to storage layer including through single-ref CTEs", "implication": "Also does predicate mirroring across join sides."},
    {"id": "CORRELATED_DECORRELATION", "summary": "Simple correlated subqueries (EXISTS/IN) automatically decorrelated to hash joins", "implication": "Do NOT decorrelate simple EXISTS/IN. DOES NOT handle correlated scalar subqueries with aggregation (see gap)."},
    {"id": "SEMI_JOIN", "summary": "EXISTS → SemiJoin with early termination", "implication": "Never materialize EXISTS patterns."},
    {"id": "JOIN_FILTER", "summary": "Bloom filter pushdown from build side to probe-side TableScan", "implication": "77/99 TPC-DS queries show JoinFilter."},
    {"id": "COST_BASED_JOIN_ORDER", "summary": "Evaluates multiple join orders, selects lowest cost", "implication": "Usually correct. Do NOT force join order."},
    {"id": "QUALIFY_OPTIMIZATION", "summary": "Native window-function filtering, more efficient than nested subquery", "implication": "Gives optimizer full visibility into filter intent."}
  ],
  "gaps": [
    {
      "id": "CORRELATED_SCALAR_AGGREGATION_FAILURE",
      "priority": "HIGH",
      "goal": "DECORRELATE",
      "detect": "WHERE col > (SELECT agg(col) FROM fact WHERE key = outer.key). Correlated scalar subquery with AVG/SUM/COUNT that re-scans fact table per outer row.",
      "gates": "REQUIRED: correlated scalar subquery with aggregate function (AVG, SUM, COUNT). REQUIRED: inner query joins fact table. Works on any fact table.",
      "what": "Correlated scalar subqueries with aggregation re-execute per outer row — O(N*M) scans.",
      "why": "Snowflake cannot flatten correlated scalar subqueries that aggregate over a correlated key. Unlike simple EXISTS/IN, these require per-row evaluation.",
      "opportunity": "Decompose into CTEs: (1) dimension filter, (2) date-filtered fact rows, (3) per-key aggregate threshold via GROUP BY. JOIN threshold CTE in final query. If inner and outer scan SAME fact table with SAME filters, use shared-scan variant.",
      "frequency_pct": 100,
      "what_worked": "2/2 wins. inline_decorrelate 23.17x (69.4s→3.0s), shared_scan_decorrelate 7.82x (8.0s→1.0s). Both on SF10TCL MEDIUM warehouse, 3x3 validation.",
      "what_didnt_work": "None observed.",
      "field_notes": "Tested on catalog_sales and web_sales. The shared-scan variant applies when inner = outer table with overlapping filters."
    }
  ]
}
