{
  "id": "PG_EXISTS_TO_IN_BLOCK",
  "severity": "HIGH",
  "description": "NEVER convert EXISTS/NOT EXISTS correlated subqueries into IN/NOT IN with materialized CTEs on PostgreSQL. PostgreSQL's semi-join optimization for EXISTS uses early termination (stops after first match). Materializing into CTEs forces full DISTINCT aggregation of fact tables.",
  "failure_rate": "2/2 queries regressed (0.50x-0.86x)",
  "observed_failures": [
    {
      "query": "DSB Q069_multi",
      "speedup": "0.50x",
      "original": "EXISTS/NOT EXISTS subqueries against store_sales, web_sales, catalog_sales",
      "rewrite": "3 CTEs with DISTINCT customer_sk, then IN/NOT IN checks",
      "problem": "DISTINCT on multi-million-row fact tables is expensive. EXISTS semi-join stops after first match per row."
    },
    {
      "query": "DSB Q010_multi",
      "speedup": "0.86x",
      "original": "EXISTS against store_sales, OR'd EXISTS against web_sales/catalog_sales",
      "rewrite": "store_customers CTE + web_or_catalog_customers UNION ALL CTE",
      "problem": "UNION ALL without deduplication creates massive CTE. Original OR'd EXISTS short-circuits independently."
    }
  ],
  "constraint_rules": [
    {
      "rule": "PRESERVE_EXISTS_SEMIJOIN",
      "description": "Keep EXISTS/NOT EXISTS as correlated subqueries on PostgreSQL",
      "rationale": "PostgreSQL converts EXISTS to efficient semi-join with early termination. CTE materialization loses this."
    },
    {
      "rule": "NO_DISTINCT_FACT_CTE",
      "description": "Never materialize SELECT DISTINCT customer_sk FROM fact_table into a CTE",
      "rationale": "DISTINCT on fact tables (millions of rows) is always expensive. Semi-join avoids the full scan."
    },
    {
      "rule": "NO_NOT_IN_REPLACEMENT",
      "description": "Never replace NOT EXISTS with NOT IN on PostgreSQL",
      "rationale": "NOT IN has NULL-handling semantics that can block hash anti-join optimization."
    }
  ],
  "prompt_instruction": "POSTGRESQL RULE: NEVER convert EXISTS/NOT EXISTS to IN/NOT IN with materialized CTEs. PostgreSQL uses efficient semi-join with early termination for EXISTS. Materializing DISTINCT keys from fact tables forces full scans and loses the early-termination benefit. Observed 0.50x-0.86x regressions.",
  "dialect": "postgresql"
}
