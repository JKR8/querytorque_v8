{
  "id": "PG_DATE_CTE_CAUTION",
  "severity": "MEDIUM",
  "engine": "postgresql",
  "description": "date_cte_isolate on PostgreSQL is a double-edged sword. It helps on star-schema queries with explicit JOINs (3.32x, 2.28x wins) but HURTS on queries with EXISTS/NOT EXISTS, INTERSECT/EXCEPT, or when the CTE fence blocks predicate pushdown. Only use when converting comma-joins to explicit JOINs simultaneously.",
  "failure_rate": "7/29 queries regressed when date_cte_isolate was applied (24% regression rate)",
  "observed_wins": [
    {"query": "DSB Q080_multi", "speedup": "3.32x", "pattern": "Multi-channel UNION with comma joins → explicit JOINs + date CTE"},
    {"query": "DSB Q099_agg", "speedup": "2.28x", "pattern": "Star schema with comma joins → explicit JOINs + date CTE"},
    {"query": "DSB Q040_agg", "speedup": "1.22x", "pattern": "Star schema + date range CTE"},
    {"query": "DSB Q072_spj_spj", "speedup": "1.14x", "pattern": "3 date_dim instances consolidated into 1 CTE"}
  ],
  "observed_failures": [
    {"query": "DSB Q069_multi", "speedup": "0.50x", "pattern": "EXISTS subqueries → CTE + IN (killed semi-join)"},
    {"query": "DSB Q031_multi", "speedup": "0.55x", "pattern": "Already had efficient CTEs, CTE fence blocked pushdown"},
    {"query": "DSB Q087_multi", "speedup": "0.59x", "pattern": "EXCEPT branches, broad customer CTE"},
    {"query": "DSB Q038_multi", "speedup": "0.85x", "pattern": "INTERSECT branches, CTE overhead"},
    {"query": "DSB Q010_multi", "speedup": "0.86x", "pattern": "EXISTS → CTE + IN conversion"},
    {"query": "DSB Q014_multi", "speedup": "0.87x", "pattern": "Inconsistent application, scalar subquery overhead"},
    {"query": "DSB Q058_multi", "speedup": "0.89x", "pattern": "Inconsistent application across branches"}
  ],
  "constraint_rules": [
    {
      "rule": "REQUIRE_EXPLICIT_JOIN_CONVERSION",
      "description": "Only use date_cte_isolate when ALSO converting comma-separated joins to explicit JOINs",
      "rationale": "The win comes from explicit JOINs + CTE together, not CTE alone."
    },
    {
      "rule": "BLOCK_WITH_EXISTS",
      "description": "Never use date_cte_isolate on queries containing EXISTS/NOT EXISTS subqueries",
      "rationale": "CTE materialization kills semi-join early termination."
    },
    {
      "rule": "BLOCK_WITH_SET_OPS",
      "description": "Never use date_cte_isolate on queries with INTERSECT/EXCEPT",
      "rationale": "Each set operation branch handles date_dim efficiently inline. CTE adds overhead."
    },
    {
      "rule": "CONSISTENT_APPLICATION",
      "description": "If applying to multi-branch queries (UNION ALL), apply to ALL branches or NONE",
      "rationale": "Partial application creates asymmetric plans that confuse the optimizer."
    }
  ],
  "prompt_instruction": "POSTGRESQL RULE: date_cte_isolate is ONLY beneficial when combined with converting comma-joins to explicit JOINs on star-schema queries. DO NOT use it on queries with EXISTS/NOT EXISTS (kills semi-join), INTERSECT/EXCEPT (adds CTE overhead per branch), or when the query already has efficient CTEs. If applying to UNION ALL branches, apply to ALL or NONE."
}
