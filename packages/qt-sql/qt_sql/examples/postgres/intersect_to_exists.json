{
  "id": "pg_intersect_to_exists",
  "name": "INTERSECT to EXISTS Semi-Join (PostgreSQL)",
  "description": "Convert INTERSECT set operations to EXISTS semi-joins. PostgreSQL implements INTERSECT via full materialization + sort comparison, while EXISTS uses semi-join with early termination. For large result sets, EXISTS is significantly faster.",
  "engine": "postgresql",
  "benchmark": "DSB SF10",
  "verified_speedup": "1.78x",
  "principle": "INTERSECT to EXISTS: INTERSECT materializes both sides fully, sorts, and compares. EXISTS uses semi-join with index + early termination per row. When both sides produce 10K+ rows, EXISTS is cheaper because it stops at first match.",
  "transforms": [
    "intersect_to_exists"
  ],
  "original_sql": "select count(*) from (\n    select distinct c_last_name, c_first_name, d_date\n    from store_sales, date_dim, customer\n    where ss_sold_date_sk = d_date_sk\n      and ss_customer_sk = c_customer_sk\n      and d_month_seq between 1189 and 1200\n      and c_birth_month in (4, 9, 10, 12)\n      and ss_list_price between 25 and 84\n      and ss_wholesale_cost BETWEEN 34 AND 54\n  intersect\n    select distinct c_last_name, c_first_name, d_date\n    from catalog_sales, date_dim, customer\n    where cs_sold_date_sk = d_date_sk\n      and cs_bill_customer_sk = c_customer_sk\n      and d_month_seq between 1189 and 1200\n      and c_birth_month in (4, 9, 10, 12)\n      and cs_list_price between 25 and 84\n      and cs_wholesale_cost BETWEEN 34 AND 54\n  intersect\n    select distinct c_last_name, c_first_name, d_date\n    from web_sales, date_dim, customer\n    where ws_sold_date_sk = d_date_sk\n      and ws_bill_customer_sk = c_customer_sk\n      and d_month_seq between 1189 and 1200\n      and c_birth_month in (4, 9, 10, 12)\n      and ws_list_price between 25 and 84\n      and ws_wholesale_cost BETWEEN 34 AND 54\n) hot_cust\nlimit 100;",
  "optimized_sql": "WITH store_sales_base AS (\n  SELECT DISTINCT c.c_last_name, c.c_first_name, d.d_date\n  FROM store_sales ss\n  INNER JOIN date_dim d ON ss.ss_sold_date_sk = d.d_date_sk\n  INNER JOIN customer c ON ss.ss_customer_sk = c.c_customer_sk\n  WHERE d.d_month_seq BETWEEN 1189 AND 1200\n    AND c.c_birth_month IN (4, 9, 10, 12)\n    AND ss.ss_list_price BETWEEN 25 AND 84\n    AND ss.ss_wholesale_cost BETWEEN 34 AND 54\n)\nSELECT COUNT(*)\nFROM store_sales_base ssb\nWHERE EXISTS (\n  SELECT 1 FROM catalog_sales cs\n  INNER JOIN date_dim d ON cs.cs_sold_date_sk = d.d_date_sk\n  INNER JOIN customer c ON cs.cs_bill_customer_sk = c.c_customer_sk\n  WHERE d.d_month_seq BETWEEN 1189 AND 1200\n    AND c.c_birth_month IN (4, 9, 10, 12)\n    AND cs.cs_list_price BETWEEN 25 AND 84\n    AND cs.cs_wholesale_cost BETWEEN 34 AND 54\n    AND c.c_last_name = ssb.c_last_name\n    AND c.c_first_name = ssb.c_first_name\n    AND d.d_date = ssb.d_date\n) AND EXISTS (\n  SELECT 1 FROM web_sales ws\n  INNER JOIN date_dim d ON ws.ws_sold_date_sk = d.d_date_sk\n  INNER JOIN customer c ON ws.ws_bill_customer_sk = c.c_customer_sk\n  WHERE d.d_month_seq BETWEEN 1189 AND 1200\n    AND c.c_birth_month IN (4, 9, 10, 12)\n    AND ws.ws_list_price BETWEEN 25 AND 84\n    AND ws.ws_wholesale_cost BETWEEN 34 AND 54\n    AND c.c_last_name = ssb.c_last_name\n    AND c.c_first_name = ssb.c_first_name\n    AND d.d_date = ssb.d_date\n)\nLIMIT 100",
  "example": {
    "opportunity": "INTERSECT_TO_EXISTS",
    "input_slice": "select count(*) from (\n  select distinct ... from store_sales, date_dim, customer where ...\n  intersect\n  select distinct ... from catalog_sales, date_dim, customer where ...\n  intersect\n  select distinct ... from web_sales, date_dim, customer where ...\n) hot_cust limit 100",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "intersect_to_exists",
          "nodes": {
            "store_sales_base": "SELECT DISTINCT c_last_name, c_first_name, d_date FROM store_sales JOIN date_dim JOIN customer WHERE ...",
            "main_query": "SELECT COUNT(*) FROM store_sales_base ssb WHERE EXISTS (catalog match) AND EXISTS (web match)"
          },
          "invariants_kept": [
            "same result count",
            "same set semantics"
          ],
          "expected_speedup": "1.8x",
          "risk": "low"
        }
      ]
    },
    "key_insight": "Principle: INTERSECT to EXISTS — INTERSECT materializes both sides fully before comparing. EXISTS uses semi-join with early termination: it stops scanning as soon as the first matching row is found. For the 3-way channel intersection pattern (store ∩ catalog ∩ web), materialize the first channel as a base CTE, then use EXISTS to probe the other two. Also converts comma joins to explicit INNER JOIN.",
    "pattern_detection": "Look for: INTERSECT between 2+ SELECT DISTINCT queries over different fact tables with identical customer/date/filter structure. Each INTERSECT branch scans a different fact table but returns the same column set."
  },
  "family": "F",
  "patch_plan": {
    "plan_id": "gold_postgres_pg_intersect_to_exists",
    "dialect": "postgres",
    "description": "Convert INTERSECT set operations to EXISTS semi-joins. PostgreSQL implements INTERSECT via full materialization + sort comparison, while EXISTS uses semi-join with early termination. For large result sets, EXISTS is significantly faster.",
    "preconditions": [
      {
        "kind": "parse_ok"
      }
    ],
    "postconditions": [
      {
        "kind": "parse_ok"
      }
    ],
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {
          "by_node_id": "S0"
        },
        "payload": {
          "cte_name": "store_sales_base",
          "cte_query_sql": "SELECT DISTINCT c.c_last_name, c.c_first_name, d.d_date FROM store_sales AS ss INNER JOIN date_dim AS d ON ss.ss_sold_date_sk = d.d_date_sk INNER JOIN customer AS c ON ss.ss_customer_sk = c.c_customer_sk WHERE d.d_month_seq BETWEEN 1189 AND 1200 AND c.c_birth_month IN (4, 9, 10, 12) AND ss.ss_list_price BETWEEN 25 AND 84 AND ss.ss_wholesale_cost BETWEEN 34 AND 54"
        },
        "description": "Insert CTE 'store_sales_base' for date dimension filtering"
      },
      {
        "step_id": "s2",
        "op": "replace_from",
        "target": {
          "by_node_id": "S0"
        },
        "payload": {
          "from_sql": "store_sales_base AS ssb"
        },
        "description": "Replace FROM clause with optimized version"
      },
      {
        "step_id": "s3",
        "op": "replace_where_predicate",
        "target": {
          "by_node_id": "S0"
        },
        "payload": {
          "expr_sql": "EXISTS(SELECT 1 FROM catalog_sales AS cs INNER JOIN date_dim AS d ON cs.cs_sold_date_sk = d.d_date_sk INNER JOIN customer AS c ON cs.cs_bill_customer_sk = c.c_customer_sk WHERE d.d_month_seq BETWEEN 1189 AND 1200 AND c.c_birth_month IN (4, 9, 10, 12) AND cs.cs_list_price BETWEEN 25 AND 84 AND cs.cs_wholesale_cost BETWEEN 34 AND 54 AND c.c_last_name = ssb.c_last_name AND c.c_first_name = ssb.c_first_name AND d.d_date = ssb.d_date) AND EXISTS(SELECT 1 FROM web_sales AS ws INNER JOIN date_dim AS d ON ws.ws_sold_date_sk = d.d_date_sk INNER JOIN customer AS c ON ws.ws_bill_customer_sk = c.c_customer_sk WHERE d.d_month_seq BETWEEN 1189 AND 1200 AND c.c_birth_month IN (4, 9, 10, 12) AND ws.ws_list_price BETWEEN 25 AND 84 AND ws.ws_wholesale_cost BETWEEN 34 AND 54 AND c.c_last_name = ssb.c_last_name AND c.c_first_name = ssb.c_first_name AND d.d_date = ssb.d_date)"
        },
        "description": "Add WHERE clause with optimized predicates"
      }
    ]
  }
}
