{
  "id": "pg_self_join_decomposition",
  "name": "Self-Join Decomposition (PostgreSQL)",
  "description": "Eliminate duplicate fact table scans in self-join patterns by computing the aggregation ONCE in a CTE and deriving both per-item and per-store averages from the same materialized result. PostgreSQL materializes CTEs by default, making this extremely effective.",
  "engine": "postgresql",
  "benchmark": "DSB SF10",
  "verified_speedup": "3.93x",
  "principle": "Shared Materialization (PG): when the same fact+dimension scan appears multiple times in self-join patterns, materialize it once as a CTE and derive all needed aggregates from the same result. PostgreSQL materializes CTEs by default, making this extremely effective.",
  "transforms": [
    "materialize_cte"
  ],
  "original_sql": "select \n\ts_store_name,\n\ti_item_desc,\n\tsc.revenue,\n\ti_current_price,\n\ti_wholesale_cost,\n\ti_brand\n from store, item,\n     (select ss_store_sk, avg(revenue) as ave\n\tfrom\n\t    (select  ss_store_sk, ss_item_sk,\n\t\t     sum(ss_sales_price) as revenue\n\t\tfrom store_sales, date_dim\n\t\twhere ss_sold_date_sk = d_date_sk and d_month_seq between 1213 and 1213+11\n   and ss_sales_price / ss_list_price BETWEEN 38 * 0.01 AND 48 * 0.01\n\t\tgroup by ss_store_sk, ss_item_sk) sa\n\tgroup by ss_store_sk) sb,\n     (select  ss_store_sk, ss_item_sk, sum(ss_sales_price) as revenue\n\tfrom store_sales, date_dim\n\twhere ss_sold_date_sk = d_date_sk and d_month_seq between 1213 and 1213+11\n  and ss_sales_price / ss_list_price BETWEEN 38 * 0.01 AND 48 * 0.01\n\tgroup by ss_store_sk, ss_item_sk) sc\n where sb.ss_store_sk = sc.ss_store_sk and\n       sc.revenue <= 0.1 * sb.ave and\n       s_store_sk = sc.ss_store_sk and\n       i_item_sk = sc.ss_item_sk\n       and i_manager_id BETWEEN 32 and 36\n       and s_state in ('TN','TX','VA')\n order by s_store_name, i_item_desc\nlimit 100;",
  "optimized_sql": "WITH date_filter AS (SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1213 AND 1213 + 11), store_sales_revenue AS (SELECT ss_store_sk, ss_item_sk, SUM(ss_sales_price) AS revenue FROM store_sales JOIN date_filter ON store_sales.ss_sold_date_sk = date_filter.d_date_sk WHERE ss_sales_price / ss_list_price BETWEEN 38 * 0.01 AND 48 * 0.01 GROUP BY ss_store_sk, ss_item_sk), store_avg_revenue AS (SELECT ss_store_sk, AVG(revenue) AS ave FROM store_sales_revenue GROUP BY ss_store_sk), filtered_store AS (SELECT s_store_sk, s_store_name, s_state FROM store WHERE s_state IN ('TN', 'TX', 'VA')), filtered_item AS (SELECT i_item_sk, i_item_desc, i_current_price, i_wholesale_cost, i_brand, i_manager_id FROM item WHERE i_manager_id BETWEEN 32 AND 36) SELECT s_store_name, i_item_desc, sc.revenue, i_current_price, i_wholesale_cost, i_brand FROM store_avg_revenue AS sb JOIN store_sales_revenue AS sc ON sb.ss_store_sk = sc.ss_store_sk JOIN filtered_store AS s ON sc.ss_store_sk = s.s_store_sk JOIN filtered_item AS i ON sc.ss_item_sk = i.i_item_sk WHERE sc.revenue <= 0.1 * sb.ave ORDER BY s_store_name, i_item_desc LIMIT 100",
  "example": {
    "opportunity": "SELF_JOIN_DECOMPOSITION",
    "input_slice": "select s_store_name, i_item_desc, sc.revenue, i_current_price, i_wholesale_cost, i_brand\nfrom store, item,\n  (select ss_store_sk, avg(revenue) as ave\n   from (select ss_store_sk, ss_item_sk, sum(ss_sales_price) as revenue\n         from store_sales, date_dim\n         where ss_sold_date_sk = d_date_sk and d_month_seq between 1213 and 1224\n           and ss_sales_price / ss_list_price BETWEEN 0.38 AND 0.48\n         group by ss_store_sk, ss_item_sk) sa\n   group by ss_store_sk) sb,\n  (select ss_store_sk, ss_item_sk, sum(ss_sales_price) as revenue\n   from store_sales, date_dim\n   where ss_sold_date_sk = d_date_sk and d_month_seq between 1213 and 1224\n     and ss_sales_price / ss_list_price BETWEEN 0.38 AND 0.48\n   group by ss_store_sk, ss_item_sk) sc\nwhere sb.ss_store_sk = sc.ss_store_sk\n  and sc.revenue <= 0.1 * sb.ave\n  and s_store_sk = sc.ss_store_sk\n  and i_item_sk = sc.ss_item_sk\n  and i_manager_id BETWEEN 32 AND 36\n  and s_state in ('TN','TX','VA')\norder by s_store_name, i_item_desc\nlimit 100",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "materialize_cte",
          "nodes": {
            "date_filter": "SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1213 AND 1224",
            "store_sales_revenue": "SELECT ss_store_sk, ss_item_sk, SUM(ss_sales_price) AS revenue FROM store_sales JOIN date_filter ON ss_sold_date_sk = d_date_sk WHERE ss_sales_price / ss_list_price BETWEEN 0.38 AND 0.48 GROUP BY ss_store_sk, ss_item_sk",
            "store_avg_revenue": "SELECT ss_store_sk, AVG(revenue) AS ave FROM store_sales_revenue GROUP BY ss_store_sk",
            "filtered_store": "SELECT s_store_sk, s_store_name FROM store WHERE s_state IN ('TN', 'TX', 'VA')",
            "filtered_item": "SELECT i_item_sk, i_item_desc, i_current_price, i_wholesale_cost, i_brand FROM item WHERE i_manager_id BETWEEN 32 AND 36",
            "main_query": "SELECT s_store_name, i_item_desc, sc.revenue, i_current_price, i_wholesale_cost, i_brand FROM store_avg_revenue AS sb JOIN store_sales_revenue AS sc ON sb.ss_store_sk = sc.ss_store_sk JOIN filtered_store AS s ON sc.ss_store_sk = s.s_store_sk JOIN filtered_item AS i ON sc.ss_item_sk = i.i_item_sk WHERE sc.revenue <= 0.1 * sb.ave ORDER BY s_store_name, i_item_desc LIMIT 100"
          },
          "invariants_kept": [
            "same result rows",
            "same aggregation",
            "same ordering"
          ],
          "expected_speedup": "3.9x",
          "risk": "low"
        }
      ]
    },
    "key_insight": "Principle: Shared Materialization (PG) \u2014 when the same fact+dimension scan appears multiple times, materialize it once as a CTE and reference it from each consumer. PostgreSQL CTE materialization guarantees single execution. Here: store_sales+date_dim scanned twice with identical predicates becomes one materialized CTE, reused for both per-item revenue and per-store averages. Combined with dimension pre-filtering to reduce I/O.",
    "pattern_detection": "Look for queries where the same fact table + date_dim join appears in two or more subqueries with identical WHERE predicates. The subqueries typically compute per-group aggregates at different granularities (e.g., per-item vs per-store)."
  },
  "family": "E"
}