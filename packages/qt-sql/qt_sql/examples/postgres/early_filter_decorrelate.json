{
  "id": "early_filter_decorrelate",
  "name": "Early Filter + Decorrelate",
  "database": "postgres",
  "verified_speedup": "27.80x (V2 DSB SF10, was 1.13x in V1)",
  "principle": "Early Selection + Decorrelation: push dimension filters into CTE definitions before materialization, and decorrelate correlated subqueries by pre-computing thresholds in separate CTEs. Filters reduce rows early; decorrelation replaces per-row subquery execution with a single pre-computed JOIN.",
  "benchmark": {
    "dataset": "dsb_sf10",
    "query": "query001",
    "original_time_s": 13.43,
    "optimized_time_s": 11.85
  },
  "ast_flags": {
    "kb_patterns_detected": [
      {
        "id": "CORRELATED_TO_CTE",
        "name": "Correlated Subquery to Pre-computed CTE",
        "trigger": "WHERE col > (SELECT AVG/SUM/COUNT FROM ... WHERE correlated)"
      },
      {
        "id": "DATE_CTE_ISOLATION",
        "name": "Date CTE Isolation",
        "trigger": "date_dim joined with d_year/d_qoy/d_month filter, fact table present"
      }
    ],
    "structural_patterns": [
      "CTE with correlated subquery reference (ctr1 -> ctr2)",
      "Dimension filter (s_state) applied AFTER CTE in main query",
      "AVG aggregate in correlated subquery with GROUP BY correlation key"
    ]
  },
  "original_sql": "WITH customer_total_return AS (\n  SELECT sr_customer_sk AS ctr_customer_sk,\n         sr_store_sk AS ctr_store_sk,\n         sr_reason_sk AS ctr_reason_sk,\n         SUM(SR_REFUNDED_CASH) AS ctr_total_return\n  FROM store_returns, date_dim\n  WHERE sr_returned_date_sk = d_date_sk\n    AND d_year = 2001\n    AND sr_return_amt / sr_return_quantity BETWEEN 236 AND 295\n  GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk\n)\nSELECT c_customer_id\nFROM customer_total_return ctr1, store, customer, customer_demographics\nWHERE ctr1.ctr_total_return > (\n    SELECT AVG(ctr_total_return) * 1.2\n    FROM customer_total_return ctr2\n    WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk\n  )\n  AND ctr1.ctr_reason_sk BETWEEN 28 AND 31\n  AND s_store_sk = ctr1.ctr_store_sk\n  AND s_state IN ('MI', 'NC', 'WI')\n  AND ctr1.ctr_customer_sk = c_customer_sk\n  AND c_current_cdemo_sk = cd_demo_sk\n  AND cd_marital_status IN ('W', 'W')\n  AND cd_education_status IN ('4 yr Degree', 'College')\n  AND cd_gender = 'M'\n  AND c_birth_month = 5\n  AND c_birth_year BETWEEN 1950 AND 1956\nORDER BY c_customer_id\nLIMIT 100",
  "optimized_sql": "WITH customer_total_return AS (\n    SELECT sr_customer_sk AS ctr_customer_sk,\n           sr_store_sk AS ctr_store_sk,\n           sr_reason_sk AS ctr_reason_sk,\n           SUM(SR_REFUNDED_CASH) AS ctr_total_return\n    FROM store_returns\n    JOIN date_dim ON sr_returned_date_sk = d_date_sk\n    JOIN store ON sr_store_sk = s_store_sk\n    WHERE d_year = 2001\n      AND s_state IN ('MI', 'NC', 'WI')\n      AND sr_return_amt / sr_return_quantity BETWEEN 236 AND 295\n    GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk\n),\nstore_thresholds AS (\n    SELECT ctr_store_sk,\n           AVG(ctr_total_return) * 1.2 AS avg_limit\n    FROM customer_total_return\n    GROUP BY ctr_store_sk\n)\nSELECT c_customer_id\nFROM customer_total_return ctr1\nJOIN store_thresholds st ON ctr1.ctr_store_sk = st.ctr_store_sk\nJOIN customer ON ctr1.ctr_customer_sk = c_customer_sk\nJOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk\nJOIN store s ON ctr1.ctr_store_sk = s.s_store_sk\nWHERE ctr1.ctr_total_return > st.avg_limit\n  AND ctr1.ctr_reason_sk BETWEEN 28 AND 31\n  AND s.s_state IN ('MI', 'NC', 'WI')\n  AND cd_marital_status = 'W'\n  AND cd_education_status IN ('4 yr Degree', 'College')\n  AND cd_gender = 'M'\n  AND c_birth_month = 5\n  AND c_birth_year BETWEEN 1950 AND 1956\nORDER BY c_customer_id\nLIMIT 100",
  "pg_blind_spots": [
    "Cannot push filters into materialized CTEs",
    "Correlated subqueries may execute row-by-row on large CTEs"
  ],
  "input": {
    "description": "CTE aggregates fact table, main query has correlated subquery for AVG threshold, dimension filter applied late",
    "sql": "WITH customer_total_return AS (\n  SELECT sr_customer_sk AS ctr_customer_sk,\n         sr_store_sk AS ctr_store_sk,\n         sr_reason_sk AS ctr_reason_sk,\n         SUM(SR_REFUNDED_CASH) AS ctr_total_return\n  FROM store_returns, date_dim\n  WHERE sr_returned_date_sk = d_date_sk\n    AND d_year = 2001\n    AND sr_return_amt / sr_return_quantity BETWEEN 236 AND 295\n  GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk\n)\nSELECT c_customer_id\nFROM customer_total_return ctr1, store, customer, customer_demographics\nWHERE ctr1.ctr_total_return > (\n    SELECT AVG(ctr_total_return) * 1.2\n    FROM customer_total_return ctr2\n    WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk\n  )\n  AND ctr1.ctr_reason_sk BETWEEN 28 AND 31\n  AND s_store_sk = ctr1.ctr_store_sk\n  AND s_state IN ('MI', 'NC', 'WI')\n  AND ctr1.ctr_customer_sk = c_customer_sk\n  AND c_current_cdemo_sk = cd_demo_sk\n  AND cd_marital_status IN ('W', 'W')\n  AND cd_education_status IN ('4 yr Degree', 'College')\n  AND cd_gender = 'M'\n  AND c_birth_month = 5\n  AND c_birth_year BETWEEN 1950 AND 1956\nORDER BY c_customer_id\nLIMIT 100"
  },
  "output": {
    "description": "Push dimension filter INTO CTE, decorrelate AVG into separate CTE, JOIN on threshold",
    "sql": "WITH customer_total_return AS (\n    SELECT sr_customer_sk AS ctr_customer_sk,\n           sr_store_sk AS ctr_store_sk,\n           sr_reason_sk AS ctr_reason_sk,\n           SUM(SR_REFUNDED_CASH) AS ctr_total_return\n    FROM store_returns\n    JOIN date_dim ON sr_returned_date_sk = d_date_sk\n    JOIN store ON sr_store_sk = s_store_sk\n    WHERE d_year = 2001\n      AND s_state IN ('MI', 'NC', 'WI')\n      AND sr_return_amt / sr_return_quantity BETWEEN 236 AND 295\n    GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk\n),\nstore_thresholds AS (\n    SELECT ctr_store_sk,\n           AVG(ctr_total_return) * 1.2 AS avg_limit\n    FROM customer_total_return\n    GROUP BY ctr_store_sk\n)\nSELECT c_customer_id\nFROM customer_total_return ctr1\nJOIN store_thresholds st ON ctr1.ctr_store_sk = st.ctr_store_sk\nJOIN customer ON ctr1.ctr_customer_sk = c_customer_sk\nJOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk\nJOIN store s ON ctr1.ctr_store_sk = s.s_store_sk\nWHERE ctr1.ctr_total_return > st.avg_limit\n  AND ctr1.ctr_reason_sk BETWEEN 28 AND 31\n  AND s.s_state IN ('MI', 'NC', 'WI')\n  AND cd_marital_status = 'W'\n  AND cd_education_status IN ('4 yr Degree', 'College')\n  AND cd_gender = 'M'\n  AND c_birth_month = 5\n  AND c_birth_year BETWEEN 1950 AND 1956\nORDER BY c_customer_id\nLIMIT 100"
  },
  "transforms_applied": [
    "early_filter",
    "decorrelate"
  ],
  "key_insight": "Principle: Early Selection + Decorrelation \u2014 push dimension filters into CTE definitions before materialization, and decorrelate correlated subqueries by pre-computing thresholds in separate CTEs. Filters reduce rows early; decorrelation replaces per-row subquery execution with a single pre-computed JOIN. Here: dimension filters pushed into CTEs, AVG threshold pre-computed and JOINed.",
  "family": "B",
  "patch_plan": {
    "plan_id": "gold_postgres_early_filter_decorrelate",
    "dialect": "postgresql",
    "description": "Early Selection + Decorrelation: push dimension filters into CTE definitions before materialization, and decorrelate correlated subqueries by pre-computing thresholds in separate CTEs. Filters reduce rows early; decorrelation replaces per-row subquery execution with a single pre-computed JOIN.",
    "preconditions": [
      {
        "kind": "parse_ok"
      }
    ],
    "postconditions": [
      {
        "kind": "parse_ok"
      }
    ],
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {
          "by_node_id": "S0"
        },
        "payload": {
          "cte_name": "store_thresholds",
          "cte_query_sql": "SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_limit FROM customer_total_return GROUP BY ctr_store_sk"
        },
        "description": "Insert CTE 'store_thresholds' for pre-aggregated computation"
      },
      {
        "step_id": "s2",
        "op": "replace_block_with_cte_pair",
        "target": {
          "by_node_id": "S0",
          "by_label": "customer_total_return"
        },
        "payload": {
          "sql_fragment": "customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, sr_reason_sk AS ctr_reason_sk, SUM(SR_REFUNDED_CASH) AS ctr_total_return FROM store_returns JOIN date_dim ON sr_returned_date_sk = d_date_sk JOIN store ON sr_store_sk = s_store_sk WHERE d_year = 2001 AND s_state IN ('MI', 'NC', 'WI') AND sr_return_amt / sr_return_quantity BETWEEN 236 AND 295 GROUP BY sr_customer_sk, sr_store_sk, sr_reason_sk)"
        },
        "description": "Replace CTE 'customer_total_return' body with optimized version"
      },
      {
        "step_id": "s3",
        "op": "replace_from",
        "target": {
          "by_node_id": "S0"
        },
        "payload": {
          "from_sql": "customer_total_return AS ctr1 JOIN store_thresholds AS st ON ctr1.ctr_store_sk = st.ctr_store_sk JOIN customer ON ctr1.ctr_customer_sk = c_customer_sk JOIN customer_demographics ON c_current_cdemo_sk = cd_demo_sk JOIN store AS s ON ctr1.ctr_store_sk = s.s_store_sk"
        },
        "description": "Replace comma-join FROM with explicit JOINs"
      },
      {
        "step_id": "s4",
        "op": "replace_where_predicate",
        "target": {
          "by_node_id": "S0",
          "by_anchor_hash": "6eef64f061a2aa84"
        },
        "payload": {
          "expr_sql": "ctr1.ctr_total_return > st.avg_limit AND ctr1.ctr_reason_sk BETWEEN 28 AND 31 AND s.s_state IN ('MI', 'NC', 'WI') AND cd_marital_status = 'W' AND cd_education_status IN ('4 yr Degree', 'College') AND cd_gender = 'M' AND c_birth_month = 5 AND c_birth_year BETWEEN 1950 AND 1956"
        },
        "description": "Replace WHERE predicate with optimized version"
      }
    ]
  },
  "ir_node_map_before": "S0 [SELECT]\n  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)\n    FROM: store_returns, date_dim\n    WHERE [4fa12f115227afec]: sr_returned_date_sk = d_date_sk AND d_year = 2001 AND sr_return_amt / sr_return_quantity BETWEEN ...\n    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk\n  MAIN QUERY (via Q_S0)\n    FROM: customer_total_return ctr1, store, customer, customer_demographics\n    WHERE [6eef64f061a2aa84]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WH...\n    ORDER BY: c_customer_id\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
  "ir_node_map_target": "S0 [SELECT]\n  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)\n    FROM: store_returns, date_dim, store\n    WHERE [1fc3c21c19b840aa]: d_year = 2001 AND s_state IN ('MI', 'NC', 'WI') AND sr_return_amt / sr_return_quantity BETWEEN 23...\n    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk\n  CTE: store_thresholds  (via CTE_Q_S0_store_thresholds)\n    FROM: customer_total_return\n    GROUP BY: ctr_store_sk\n  MAIN QUERY (via Q_S0)\n    FROM: customer_total_return ctr1, store_thresholds st, customer, customer_demographics, store s\n    WHERE [fa3d3cbec1ba162d]: ctr1.ctr_total_return > st.avg_limit AND ctr1.ctr_reason_sk BETWEEN 28 AND 31 AND s.s_state IN ('...\n    ORDER BY: c_customer_id\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
  "dialect": "postgresql",
  "transforms": [
    "decorrelate",
    "early_filter"
  ],
  "families": [
    "A",
    "B",
    "C"
  ],
  "gap_ids": [
    "CORRELATED_SUBQUERY_PARALYSIS",
    "CROSS_CTE_PREDICATE_BLINDNESS"
  ]
}
