{
  "id": "sf_date_cte_explicit_join",
  "name": "Date CTE Isolation + Explicit Joins (Snowflake)",
  "description": "Isolate date_dim filter into a CTE, then explicit JOIN to fact table. Enables Snowflake runtime micro-partition pruning that comma joins prevent.",
  "verified_speedup": "TIMEOUT->0.7s",
  "principle": "Date CTE Isolation + Explicit Joins: isolate date_dim filter into a CTE, then explicitly JOIN the fact table to the CTE. Comma joins between fact tables and date_dim prevent Snowflake from pushing date predicates to the fact table scan at runtime. The optimizer assigns all micro-partitions before resolving the date filter. Explicit JOINs enable runtime partition pruning (invisible in static EXPLAIN).",
  "benchmark_queries": [
    "Q21",
    "Q55",
    "Q32",
    "Q36",
    "Q53",
    "Q49",
    "Q77",
    "Q5",
    "Q80",
    "Q25",
    "Q16",
    "Q48",
    "Q50",
    "Q65",
    "Q66",
    "Q12"
  ],
  "example": {
    "opportunity": "SF_DATE_CTE_EXPLICIT_JOIN",
    "input_slice": "select *\n from(select w_warehouse_name\n            ,i_item_id\n            ,sum(case when (cast(d_date as date) < cast ('2002-02-27' as date))\n\t                then inv_quantity_on_hand \n                      else 0 end) as inv_before\n            ,sum(case when (cast(d_date as date) >= cast ('2002-02-27' as date))\n                      then inv_quantity_on_hand \n                      else 0 end) as inv_after\n   from inventory\n       ,warehouse\n       ,item\n       ,date_dim\n   where i_current_price between 0.99 and 1.49\n     and i_item_sk          = inv_item_sk\n     and inv_warehouse_sk   = w_warehouse_sk\n     and inv_date_sk    = d_date_sk\n     and d_date between (cast ('2002-02-27' as date) - INTERVAL 30 DAY)\n                    and (cast ('2002-02-27' as date) + INTERVAL 30 DAY)\n   group by w_warehouse_name, i_item_id) x\n where (case when inv_before > 0 \n             then inv_after / inv_before \n             else null\n             end) between 2.0/3.0 and 3.0/2.0\n order by w_warehouse_name\n         ,i_item_id\n LIMIT 100",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "sf_date_cte_explicit_join",
          "nodes": {
            "date_filter": "SELECT d_date_sk, d_date FROM date_dim WHERE d_date BETWEEN DATEADD(DAY, -30, '2002-02-27'::DATE) AND DATEADD(DAY, 30, '2002-02-27'::DATE)",
            "main_query": "SELECT * FROM (SELECT w_warehouse_name, i_item_id, SUM(CASE WHEN d_date < '2002-02-27'::DATE THEN inv_quantity_on_hand ELSE 0 END) AS inv_before, SUM(CASE WHEN d_date >= '2002-02-27'::DATE THEN inv_quantity_on_hand ELSE 0 END) AS inv_after FROM inventory JOIN date_filter ON inv_date_sk = d_date_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN item ON i_item_sk = inv_item_sk WHERE i_current_price BETWEEN 0.99 AND 1.49 GROUP BY w_warehouse_name, i_item_id) x WHERE (CASE WHEN inv_before > 0 THEN inv_after / inv_before ELSE NULL END) BETWEEN 2.0/3.0 AND 3.0/2.0 ORDER BY w_warehouse_name, i_item_id LIMIT 100"
          },
          "invariants_kept": [
            "output columns unchanged",
            "grain preserved",
            "same result rows"
          ],
          "expected_speedup": "TIMEOUT->0.7s",
          "risk": "low"
        }
      ]
    },
    "transforms": [
      "sf_date_cte_explicit_join"
    ],
    "key_insight": "Snowflake P1 pathology: comma joins between fact tables and date_dim prevent runtime micro-partition pruning. The optimizer assigns all micro-partitions before resolving the date filter in WHERE. Fix: extract date_dim filter into a CTE, then explicitly JOIN the fact table to the CTE. This enables runtime partition pruning (invisible in static EXPLAIN). Pattern works for single-date, multi-date (d1/d2/d3 aliases), EXISTS subqueries, and UNION branches. 22/35 wins (63%), all converting TIMEOUT >300s to completes. Fails on: no date filter, CTE self-joins, FULL OUTER JOINs, 3-way fact+wide date ranges."
  },
  "original_sql": "select *\n from(select w_warehouse_name\n            ,i_item_id\n            ,sum(case when (cast(d_date as date) < cast ('2002-02-27' as date))\n\t                then inv_quantity_on_hand \n                      else 0 end) as inv_before\n            ,sum(case when (cast(d_date as date) >= cast ('2002-02-27' as date))\n                      then inv_quantity_on_hand \n                      else 0 end) as inv_after\n   from inventory\n       ,warehouse\n       ,item\n       ,date_dim\n   where i_current_price between 0.99 and 1.49\n     and i_item_sk          = inv_item_sk\n     and inv_warehouse_sk   = w_warehouse_sk\n     and inv_date_sk    = d_date_sk\n     and d_date between (cast ('2002-02-27' as date) - INTERVAL 30 DAY)\n                    and (cast ('2002-02-27' as date) + INTERVAL 30 DAY)\n   group by w_warehouse_name, i_item_id) x\n where (case when inv_before > 0 \n             then inv_after / inv_before \n             else null\n             end) between 2.0/3.0 and 3.0/2.0\n order by w_warehouse_name\n         ,i_item_id\n LIMIT 100;",
  "optimized_sql": "WITH date_filter AS (\n    SELECT d_date_sk, d_date FROM date_dim\n    WHERE d_date BETWEEN DATEADD(DAY, -30, '2002-02-27'::DATE) AND DATEADD(DAY, 30, '2002-02-27'::DATE)\n)\nSELECT * FROM (\n    SELECT w_warehouse_name\n          ,i_item_id\n          ,SUM(CASE WHEN d_date < '2002-02-27'::DATE THEN inv_quantity_on_hand ELSE 0 END) AS inv_before\n          ,SUM(CASE WHEN d_date >= '2002-02-27'::DATE THEN inv_quantity_on_hand ELSE 0 END) AS inv_after\n    FROM inventory\n        JOIN date_filter ON inv_date_sk = d_date_sk\n        JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk\n        JOIN item ON i_item_sk = inv_item_sk\n    WHERE i_current_price BETWEEN 0.99 AND 1.49\n    GROUP BY w_warehouse_name, i_item_id\n) x\nWHERE (CASE WHEN inv_before > 0 THEN inv_after / inv_before ELSE NULL END)\n      BETWEEN 2.0/3.0 AND 3.0/2.0\nORDER BY w_warehouse_name, i_item_id\nLIMIT 100;",
  "optimized_source": "manual",
  "type": "gold",
  "family": "F"
}