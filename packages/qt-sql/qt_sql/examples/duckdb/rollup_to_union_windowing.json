{
  "id": "rollup_to_union_windowing",
  "name": "ROLLUP to UNION ALL Windowing",
  "description": "Replace GROUP BY ROLLUP with explicit UNION ALL of pre-aggregated CTEs at each hierarchy level, combined with window functions for ranking",
  "verified_speedup": "2.47x",
  "engine": "duckdb",
  "example": {
    "opportunity": "EARLY_FILTER + MATERIALIZE_CTE + UNION_CTE_SPLIT",
    "input_slice": "select sum(ss_net_profit)/sum(ss_ext_sales_price) as gross_margin,\n  i_category, i_class,\n  grouping(i_category)+grouping(i_class) as lochierarchy,\n  rank() over (partition by grouping(i_category)+grouping(i_class),\n    case when grouping(i_class) = 0 then i_category end\n    order by sum(ss_net_profit)/sum(ss_ext_sales_price) asc) as rank_within_parent\nfrom store_sales, date_dim d1, item, store\nwhere d1.d_year = 2002 and d1.d_date_sk = ss_sold_date_sk\n  and i_item_sk = ss_item_sk and s_store_sk = ss_store_sk\n  and s_state in ('SD','TN','GA','SC','MO','AL','MI','OH')\ngroup by rollup(i_category,i_class)\norder by lochierarchy desc, case when lochierarchy = 0 then i_category end, rank_within_parent\nLIMIT 100",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "early_filter",
          "nodes": {
            "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_year = 2002",
            "filtered_stores": "SELECT s_store_sk FROM store WHERE s_state IN ('SD', 'TN', 'GA', 'SC', 'MO', 'AL', 'MI', 'OH')",
            "item_sums": "SELECT ss_item_sk, SUM(ss_net_profit) AS net_profit, SUM(ss_ext_sales_price) AS sales_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk JOIN filtered_stores ON ss_store_sk = s_store_sk GROUP BY ss_item_sk",
            "item_aggregates": "SELECT i.i_category, i.i_class, SUM(item_sums.net_profit) AS net_profit, SUM(item_sums.sales_price) AS sales_price FROM item_sums JOIN item i ON item_sums.ss_item_sk = i.i_item_sk GROUP BY i.i_category, i.i_class",
            "detailed": "SELECT net_profit / sales_price AS gross_margin, i_category, i_class, 0 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0",
            "category_summary": "SELECT SUM(net_profit) / SUM(sales_price) AS gross_margin, i_category, NULL AS i_class, 1 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0 GROUP BY i_category",
            "grand_total": "SELECT SUM(net_profit) / SUM(sales_price) AS gross_margin, NULL AS i_category, NULL AS i_class, 2 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0",
            "all_levels": "SELECT * FROM detailed UNION ALL SELECT * FROM category_summary UNION ALL SELECT * FROM grand_total",
            "main_query": "SELECT gross_margin, i_category, i_class, lochierarchy, CASE WHEN lochierarchy < 2 THEN RANK() OVER (PARTITION BY lochierarchy, CASE WHEN lochierarchy = 0 THEN i_category END ORDER BY gross_margin ASC) ELSE 1 END AS rank_within_parent FROM all_levels ORDER BY lochierarchy DESC, CASE WHEN lochierarchy = 0 THEN i_category END, rank_within_parent LIMIT 100"
          },
          "invariants_kept": [
            "output columns unchanged",
            "same hierarchy levels"
          ],
          "expected_speedup": "2.47x",
          "risk": "medium"
        }
      ]
    },
    "key_insight": "ROLLUP generates all grouping levels in a single pass, but the optimizer cannot specialize each level's aggregation. Breaking into explicit UNION ALL of pre-computed CTEs allows each level to use the already-aggregated item_aggregates CTE, and dimension filters are pushed into early CTEs.",
    "when_not_to_use": "Do not use when ROLLUP generates all levels efficiently (small dimension tables, few groups) or when the query genuinely needs all possible grouping set combinations. Only beneficial when specific levels need different optimization paths."
  },
  "original_sql": "select sum(ss_net_profit)/sum(ss_ext_sales_price) as gross_margin, i_category, i_class, grouping(i_category)+grouping(i_class) as lochierarchy, rank() over (partition by grouping(i_category)+grouping(i_class), case when grouping(i_class) = 0 then i_category end order by sum(ss_net_profit)/sum(ss_ext_sales_price) asc) as rank_within_parent from store_sales, date_dim d1, item, store where d1.d_year = 2002 and d1.d_date_sk = ss_sold_date_sk and i_item_sk = ss_item_sk and s_store_sk = ss_store_sk and s_state in ('SD','TN','GA','SC','MO','AL','MI','OH') group by rollup(i_category,i_class) order by lochierarchy desc, case when lochierarchy = 0 then i_category end, rank_within_parent LIMIT 100;",
  "optimized_sql": "WITH filtered_dates AS (SELECT d_date_sk FROM date_dim WHERE d_year = 2002), filtered_stores AS (SELECT s_store_sk FROM store WHERE s_state IN ('SD', 'TN', 'GA', 'SC', 'MO', 'AL', 'MI', 'OH')), item_sums AS (SELECT ss_item_sk, SUM(ss_net_profit) AS net_profit, SUM(ss_ext_sales_price) AS sales_price FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = filtered_dates.d_date_sk JOIN filtered_stores ON ss_store_sk = filtered_stores.s_store_sk GROUP BY ss_item_sk), item_aggregates AS (SELECT i.i_category, i.i_class, SUM(item_sums.net_profit) AS net_profit, SUM(item_sums.sales_price) AS sales_price FROM item_sums JOIN item i ON item_sums.ss_item_sk = i.i_item_sk GROUP BY i.i_category, i.i_class), detailed AS (SELECT net_profit / sales_price AS gross_margin, i_category, i_class, 0 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0), category_summary AS (SELECT SUM(net_profit) / SUM(sales_price) AS gross_margin, i_category, NULL AS i_class, 1 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0 GROUP BY i_category), grand_total AS (SELECT SUM(net_profit) / SUM(sales_price) AS gross_margin, NULL AS i_category, NULL AS i_class, 2 AS lochierarchy FROM item_aggregates WHERE sales_price <> 0), all_levels AS (SELECT * FROM detailed UNION ALL SELECT * FROM category_summary UNION ALL SELECT * FROM grand_total), ranked AS (SELECT gross_margin, i_category, i_class, lochierarchy, CASE WHEN lochierarchy < 2 THEN RANK() OVER (PARTITION BY lochierarchy, CASE WHEN lochierarchy = 0 THEN i_category END ORDER BY gross_margin ASC) ELSE 1 END AS rank_within_parent FROM all_levels)\nSELECT gross_margin, i_category, i_class, lochierarchy, rank_within_parent FROM ranked ORDER BY lochierarchy DESC, CASE WHEN lochierarchy = 0 THEN i_category END, rank_within_parent LIMIT 100;",
  "optimized_source": "swarm_final_worker",
  "sf10_rows_match": true
}
