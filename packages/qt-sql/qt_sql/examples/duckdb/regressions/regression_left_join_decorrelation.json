{
  "id": "regression_left_join_decorrelation",
  "type": "regression",
  "name": "regression: LEFT JOIN semi-join destroyed (0.34x)",
  "description": "Do not decorrelate correlated LEFT JOINs that the optimizer already executes as semi-joins. Materializing the correlated subquery into a CTE forces redundant scans.",
  "verified_speedup": "0.34x",
  "query_id": "",
  "transform_attempted": "decorrelate",
  "regression_mechanism": "Converted a correlated LEFT JOIN + filter into two materialized CTEs (sales_with_filtered_returns AND filtered_returns), both scanning store_returns. The original correlated LEFT JOIN was efficiently executed as a semi-join during the store_sales scan. Materializing both CTEs forces independent scans and loses the semi-join optimization.",
  "original_sql": "-- start query 93 in stream 0 using template query93.tpl\nselect ss_customer_sk\n            ,sum(act_sales) sumsales\n      from (select ss_item_sk\n                  ,ss_ticket_number\n                  ,ss_customer_sk\n                  ,case when sr_return_quantity is not null then (ss_quantity-sr_return_quantity)*ss_sales_price\n                                                            else (ss_quantity*ss_sales_price) end act_sales\n            from store_sales left outer join store_returns on (sr_item_sk = ss_item_sk\n                                                               and sr_ticket_number = ss_ticket_number)\n                ,reason\n            where sr_reason_sk = r_reason_sk\n              and r_reason_desc = 'duplicate purchase') t\n      group by ss_customer_sk\n      order by sumsales, ss_customer_sk\n LIMIT 100;\n\n-- end query 93 in stream 0 using template query93.tpl",
  "example": {
    "before_sql": "-- start query 93 in stream 0 using template query93.tpl\nselect ss_customer_sk\n            ,sum(act_sales) sumsales\n      from (select ss_item_sk\n                  ,ss_ticket_number\n                  ,ss_customer_sk\n                  ,case when sr_return_quantity is not null then (ss_quantity-sr_return_quantity)*ss_sales_price\n                                                            else (ss_quantity*ss_sales_price) end act_sales\n            from store_sales left outer join store_returns on (sr_item_sk = ss_item_sk\n                                                               and sr_ticket_number = ss_ticket_number)\n                ,reason\n            where sr_reason_sk = r_reason_sk\n              and r_reason_desc = 'duplicate purchase') t\n      group by ss_customer_sk\n      order by sumsales, ss_customer_sk\n LIMIT 100;\n\n-- end query 93 in stream 0 using template query93.tpl",
    "after_sql": "WITH filtered_reason AS (SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'), sales_with_filtered_returns AS (SELECT ss.ss_customer_sk, ss.ss_item_sk, ss.ss_ticket_number, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales AS ss LEFT JOIN (SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk) AS sr ON (sr.sr_item_sk = ss.ss_item_sk AND sr.sr_ticket_number = ss.ss_ticket_number)), filtered_returns AS (SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk)\nSELECT ss_customer_sk, SUM(CASE WHEN NOT sr_return_quantity IS NULL THEN (ss_quantity - sr_return_quantity) * ss_sales_price ELSE ss_quantity * ss_sales_price END) AS sumsales FROM sales_with_filtered_returns GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100",
    "key_insight": "Do not decorrelate correlated LEFT JOINs that the optimizer already executes as semi-joins. Materializing the correlated subquery into a CTE forces redundant scans."
  }
}