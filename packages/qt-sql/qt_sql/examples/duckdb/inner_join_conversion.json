{
  "id": "inner_join_conversion",
  "name": "Inner Join Conversion",
  "description": "Convert LEFT JOIN + right-table WHERE filter to INNER JOIN + early filter CTE when the WHERE eliminates NULL rows",
  "verified_speedup": "3.44x",
  "principle": "When a LEFT JOIN is immediately followed by a WHERE filter on the right table that eliminates NULL rows, convert to INNER JOIN + early filter CTE. The WHERE clause already makes the LEFT JOIN behave as an INNER JOIN, but the optimizer keeps the LEFT JOIN semantics (preserving all left rows), wasting work on rows that are filtered out.",
  "example": {
    "opportunity": "INNER_JOIN_CONVERSION",
    "input_slice": "SELECT ss_customer_sk, SUM(act_sales) sumsales\nFROM (SELECT ss_item_sk, ss_ticket_number, ss_customer_sk,\n        CASE WHEN sr_return_quantity IS NOT NULL\n          THEN (ss_quantity-sr_return_quantity)*ss_sales_price\n          ELSE (ss_quantity*ss_sales_price) END act_sales\n      FROM store_sales LEFT OUTER JOIN store_returns\n        ON (sr_item_sk = ss_item_sk AND sr_ticket_number = ss_ticket_number)\n        , reason\n      WHERE sr_reason_sk = r_reason_sk\n        AND r_reason_desc = 'duplicate purchase') t\nGROUP BY ss_customer_sk\nORDER BY sumsales, ss_customer_sk LIMIT 100",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "inner_join_conversion",
          "nodes": {
            "filtered_reason": "SELECT r_reason_sk, r_reason_desc FROM reason WHERE r_reason_desc = 'duplicate purchase'",
            "joined_returns_sales": "SELECT ss.ss_customer_sk, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales ss INNER JOIN store_returns sr ON (ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number) INNER JOIN filtered_reason fr ON sr.sr_reason_sk = fr.r_reason_sk",
            "main_query": "SELECT ss_customer_sk, SUM((ss_quantity - sr_return_quantity) * ss_sales_price) AS sumsales FROM joined_returns_sales GROUP BY ss_customer_sk ORDER BY sumsales ASC, ss_customer_sk ASC LIMIT 100"
          },
          "invariants_kept": [
            "output columns unchanged",
            "grain preserved",
            "same result rows"
          ],
          "expected_speedup": "3.44x",
          "risk": "low"
        }
      ]
    },
    "key_insight": "Principle: Inner Join Conversion \u2014 when a LEFT JOIN is followed by a WHERE filter on the right table (sr_reason_sk = r_reason_sk), the WHERE already eliminates NULL rows from the LEFT JOIN, making it behave as an INNER JOIN. Converting explicitly to INNER JOIN + early filter CTE lets the optimizer skip preserving left-side rows. Here: filtered reason \u2192 INNER JOIN store_returns + store_sales \u2192 aggregate. The optimizer cannot infer that the WHERE makes LEFT JOIN equivalent to INNER JOIN.",
    "when_not_to_use": "Do NOT convert if CASE WHEN checks for IS NULL on the right-table column \u2014 the NULL branch is semantically meaningful and the LEFT JOIN is intentional."
  },
  "original_sql": "select ss_customer_sk\n            ,sum(act_sales) sumsales\n      from (select ss_item_sk\n                  ,ss_ticket_number\n                  ,ss_customer_sk\n                  ,case when sr_return_quantity is not null then (ss_quantity-sr_return_quantity)*ss_sales_price\n                                                            else (ss_quantity*ss_sales_price) end act_sales\n            from store_sales left outer join store_returns on (sr_item_sk = ss_item_sk\n                                                               and sr_ticket_number = ss_ticket_number)\n                ,reason\n            where sr_reason_sk = r_reason_sk\n              and r_reason_desc = 'duplicate purchase') t\n      group by ss_customer_sk\n      order by sumsales, ss_customer_sk\n LIMIT 100;",
  "optimized_sql": "WITH filtered_reason AS (SELECT r_reason_sk, r_reason_desc FROM reason WHERE r_reason_desc = 'duplicate purchase'), joined_returns_sales AS (SELECT ss.ss_customer_sk, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales ss INNER JOIN store_returns sr ON (ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number) INNER JOIN filtered_reason fr ON sr.sr_reason_sk = fr.r_reason_sk), aggregated AS (SELECT ss_customer_sk, SUM((ss_quantity - sr_return_quantity) * ss_sales_price) AS sumsales FROM joined_returns_sales GROUP BY ss_customer_sk), top_n AS (SELECT ss_customer_sk, sumsales FROM aggregated ORDER BY sumsales ASC, ss_customer_sk ASC LIMIT 100) SELECT ss_customer_sk, sumsales FROM top_n",
  "optimized_source": "swarm_w2",
  "sf10_rows_match": true,
  "family": "F",
  "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) t\n    GROUP BY: ss_customer_sk\n    ORDER BY: sumsales, ss_customer_sk\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
  "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_reason  (via CTE_Q_S0_filtered_reason)\n    FROM: reason\n    WHERE [a7afe1b89848b69b]: r_reason_desc = 'duplicate purchase'\n  CTE: joined_returns_sales  (via CTE_Q_S0_joined_returns_sales)\n    FROM: store_sales ss, store_returns sr, filtered_reason fr\n  CTE: aggregated  (via CTE_Q_S0_aggregated)\n    FROM: joined_returns_sales\n    GROUP BY: ss_customer_sk\n  CTE: top_n  (via CTE_Q_S0_top_n)\n    FROM: aggregated\n    ORDER BY: sumsales, ss_customer_sk\n  MAIN QUERY (via Q_S0)\n    FROM: top_n\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
  "dialect": "duckdb",
  "transforms": [
    "inner_join_conversion"
  ],
  "families": [
    "F"
  ],
  "gap_ids": [
    "LEFT_JOIN_FILTER_ORDER_RIGIDITY"
  ],
  "tree_example": {
    "plan_id": "gold_duckdb_inner_join_conversion",
    "dialect": "duckdb",
    "target_ir": "rewrite final_select to optimized query shape",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": [],
          "outputs": [
            "ss_customer_sk",
            "sumsales"
          ],
          "changed": true,
          "sql": "WITH filtered_reason AS (SELECT r_reason_sk, r_reason_desc FROM reason WHERE r_reason_desc = 'duplicate purchase'), joined_returns_sales AS (SELECT ss.ss_customer_sk, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales ss INNER JOIN store_returns sr ON (ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number) INNER JOIN filtered_reason fr ON sr.sr_reason_sk = fr.r_reason_sk), aggregated AS (SELECT ss_customer_sk, SUM((ss_quantity - sr_return_quantity) * ss_sales_price) AS sumsales FROM joined_returns_sales GROUP BY ss_customer_sk), top_n AS (SELECT ss_customer_sk, sumsales FROM aggregated ORDER BY sumsales ASC, ss_customer_sk ASC LIMIT 100) SELECT ss_customer_sk, sumsales FROM top_n"
        }
      ]
    }
  }
}
