{
  "id": "early_filter",
  "name": "Early Dimension Filter",
  "description": "Filter dimension tables FIRST, then join to fact tables to reduce expensive joins",
  "verified_speedup": "4.00x",
  "principle": "Early Selection: filter small dimension tables first, then join to large fact tables. This reduces the fact table scan to only rows matching the filter, rather than scanning all rows and filtering after the join.",
  "example": {
    "opportunity": "EARLY_FILTER",
    "input_slice": "[main_query]:\nSELECT ss_customer_sk, SUM(act_sales) AS sumsales\nFROM (SELECT ss.ss_customer_sk, CASE WHEN sr.sr_return_quantity IS NOT NULL\n        THEN (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price\n        ELSE ss.ss_quantity * ss.ss_sales_price END AS act_sales\n      FROM store_sales ss LEFT JOIN store_returns sr ON ss.ss_item_sk = sr.sr_item_sk\n      JOIN reason r ON sr.sr_reason_sk = r.r_reason_sk\n      WHERE r.r_reason_desc = 'duplicate purchase') t\nGROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "early_filter",
          "nodes": {
            "filtered_reason": "SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'",
            "filtered_returns": "SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk",
            "main_query": "SELECT ss_customer_sk, SUM(act_sales) AS sumsales FROM (SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales ss JOIN filtered_returns fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100"
          },
          "invariants_kept": [
            "output columns unchanged",
            "grain preserved",
            "same result rows"
          ],
          "expected_speedup": "2.71x",
          "risk": "low"
        }
      ]
    },
    "key_insight": "Principle: Early Selection \u2014 filter small dimension tables first, then join to large fact tables. This reduces the fact table scan to only rows matching the filter, rather than scanning all rows and filtering after the join. Here: filter reason table to 'duplicate purchase' first, then join to store_returns, then to store_sales \u2014 dramatically reducing the rows entering the expensive fact join."
  },
  "original_sql": "select ss_customer_sk\n            ,sum(act_sales) sumsales\n      from (select ss_item_sk\n                  ,ss_ticket_number\n                  ,ss_customer_sk\n                  ,case when sr_return_quantity is not null then (ss_quantity-sr_return_quantity)*ss_sales_price\n                                                            else (ss_quantity*ss_sales_price) end act_sales\n            from store_sales left outer join store_returns on (sr_item_sk = ss_item_sk\n                                                               and sr_ticket_number = ss_ticket_number)\n                ,reason\n            where sr_reason_sk = r_reason_sk\n              and r_reason_desc = 'duplicate purchase') t\n      group by ss_customer_sk\n      order by sumsales, ss_customer_sk\n LIMIT 100;",
  "optimized_sql": "WITH filtered_reason AS (SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'), filtered_returns AS (SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk)\nSELECT ss_customer_sk, SUM(act_sales) AS sumsales FROM (SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales AS ss JOIN filtered_returns AS fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t GROUP BY ss_customer_sk ORDER BY sumsales, ss_customer_sk LIMIT 100;",
  "optimized_source": "kimi",
  "sf10_rows_match": true,
  "family": "A",
  "patch_plan": {
    "plan_id": "gold_duckdb_early_filter",
    "dialect": "duckdb",
    "description": "Filter dimension tables FIRST, then join to fact tables to reduce expensive joins",
    "preconditions": [
      {
        "kind": "parse_ok"
      }
    ],
    "postconditions": [
      {
        "kind": "parse_ok"
      }
    ],
    "steps": [
      {
        "step_id": "s1",
        "op": "insert_cte",
        "target": {
          "by_node_id": "S0"
        },
        "payload": {
          "cte_name": "filtered_reason",
          "cte_query_sql": "SELECT r_reason_sk FROM reason WHERE r_reason_desc = 'duplicate purchase'"
        },
        "description": "Insert CTE 'filtered_reason'"
      },
      {
        "step_id": "s2",
        "op": "insert_cte",
        "target": {
          "by_node_id": "S0"
        },
        "payload": {
          "cte_name": "filtered_returns",
          "cte_query_sql": "SELECT sr_item_sk, sr_ticket_number, sr_return_quantity FROM store_returns JOIN filtered_reason ON sr_reason_sk = r_reason_sk"
        },
        "description": "Insert CTE 'filtered_returns' for pre-filtered join"
      },
      {
        "step_id": "s3",
        "op": "replace_from",
        "target": {
          "by_node_id": "S0"
        },
        "payload": {
          "from_sql": "(SELECT ss.ss_customer_sk, CASE WHEN NOT fr.sr_return_quantity IS NULL THEN (ss.ss_quantity - fr.sr_return_quantity) * ss.ss_sales_price ELSE (ss.ss_quantity * ss.ss_sales_price) END AS act_sales FROM store_sales AS ss JOIN filtered_returns AS fr ON (fr.sr_item_sk = ss.ss_item_sk AND fr.sr_ticket_number = ss.ss_ticket_number)) AS t"
        },
        "description": "Replace FROM clause with CTE-based JOINs"
      }
    ]
  },
  "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) t\n    GROUP BY: ss_customer_sk\n    ORDER BY: sumsales, ss_customer_sk\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
  "ir_node_map_target": "S0 [SELECT]\n  CTE: filtered_reason  (via CTE_Q_S0_filtered_reason)\n    FROM: reason\n    WHERE [a7afe1b89848b69b]: r_reason_desc = 'duplicate purchase'\n  CTE: filtered_returns  (via CTE_Q_S0_filtered_returns)\n    FROM: store_returns, filtered_reason\n  MAIN QUERY (via Q_S0)\n    FROM: (subquery) t\n    GROUP BY: ss_customer_sk\n    ORDER BY: sumsales, ss_customer_sk\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)"
}
