{
  "id": "date_cte_isolate",
  "name": "Date CTE Isolation",
  "description": "Extract date filtering into a separate CTE to enable predicate pushdown and reduce scans",
  "verified_speedup": "4.00x",
  "principle": "Dimension Isolation: extract small dimension lookups into CTEs so they materialize once and subsequent joins probe a tiny hash table instead of rescanning.",
  "example": {
    "opportunity": "DATE_CTE_ISOLATE + CATEGORY_AVG",
    "input_slice": "[main_query]:\nSELECT a.ca_state state, count(*) cnt\nFROM customer_address a, customer c, store_sales s, date_dim d, item i\nWHERE a.ca_address_sk = c.c_current_addr_sk\n  AND c.c_customer_sk = s.ss_customer_sk\n  AND s.ss_sold_date_sk = d.d_date_sk\n  AND s.ss_item_sk = i.i_item_sk\n  AND d.d_month_seq = (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2000 AND d_moy = 1)\n  AND i.i_current_price > 1.2 * (SELECT avg(j.i_current_price) FROM item j WHERE j.i_category = i.i_category)\nGROUP BY a.ca_state HAVING count(*) >= 10\nORDER BY cnt, a.ca_state LIMIT 100",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "date_cte_isolate",
          "nodes": {
            "target_month": "SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2000 AND d_moy = 1",
            "category_avg_price": "SELECT i_category, AVG(i_current_price) * 1.2 AS avg_threshold FROM item GROUP BY i_category",
            "filtered_dates": "SELECT d_date_sk FROM date_dim JOIN target_month ON d_month_seq = target_month.d_month_seq",
            "filtered_sales": "SELECT ss_customer_sk, ss_item_sk FROM store_sales JOIN filtered_dates ON ss_sold_date_sk = d_date_sk",
            "main_query": "SELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address a JOIN customer c ON a.ca_address_sk = c.c_current_addr_sk JOIN filtered_sales s ON c.c_customer_sk = s.ss_customer_sk JOIN item i ON s.ss_item_sk = i.i_item_sk JOIN category_avg_price cap ON i.i_category = cap.i_category WHERE i.i_current_price > cap.avg_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100"
          },
          "invariants_kept": [
            "same result rows",
            "same ordering",
            "same column output",
            "same grouping and aggregation"
          ],
          "expected_speedup": "2.0x",
          "risk": "low"
        }
      ]
    },
    "key_insight": "Principle: Dimension Isolation \u2014 extract small dimension lookups into CTEs so they materialize once and subsequent joins probe a tiny hash table. Here: extract date month_seq subquery into CTE, extract category average into separate CTE with GROUP BY, then JOIN instead of correlated subquery. Each CTE is scanned once.",
    "when_not_to_use": "Do not use when the optimizer already pushes date predicates effectively (e.g., simple equality filters on date columns in self-joins). Do not decompose an already-efficient existing CTE into sub-CTEs \u2014 this adds materialization overhead without reducing scans. Caused 0.49x regression on an already-optimized date-pushdown case and 0.71x on an over-decomposed CTE case."
  },
  "original_sql": "select a.ca_state state, count(*) cnt\n from customer_address a\n     ,customer c\n     ,store_sales s\n     ,date_dim d\n     ,item i\n where       a.ca_address_sk = c.c_current_addr_sk\n \tand c.c_customer_sk = s.ss_customer_sk\n \tand s.ss_sold_date_sk = d.d_date_sk\n \tand s.ss_item_sk = i.i_item_sk\n \tand d.d_month_seq = \n \t     (select distinct (d_month_seq)\n \t      from date_dim\n               where d_year = 2002\n \t        and d_moy = 3 )\n \tand i.i_current_price > 1.2 * \n             (select avg(j.i_current_price) \n \t     from item j \n \t     where j.i_category = i.i_category)\n group by a.ca_state\n having count(*) >= 10\n order by cnt, a.ca_state\n LIMIT 100;",
  "optimized_sql": "WITH target_month AS (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3), category_avg AS (SELECT i_category, AVG(i_current_price) * 1.2 AS price_threshold FROM item GROUP BY i_category)\nSELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address AS a JOIN customer AS c ON a.ca_address_sk = c.c_current_addr_sk JOIN store_sales AS s ON c.c_customer_sk = s.ss_customer_sk JOIN date_dim AS d ON s.ss_sold_date_sk = d.d_date_sk JOIN target_month AS tm ON d.d_month_seq = tm.d_month_seq JOIN item AS i ON s.ss_item_sk = i.i_item_sk JOIN category_avg AS ca ON i.i_category = ca.i_category WHERE i.i_current_price > ca.price_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100;",
  "optimized_source": "kimi",
  "sf10_rows_match": true,
  "family": "A",
  "ir_node_map_before": "S0 [SELECT]\n  MAIN QUERY (via Q_S0)\n    FROM: customer_address a, customer c, store_sales s, date_dim d, item i\n    WHERE [2837aea03aa52676]: a.ca_address_sk = c.c_current_addr_sk AND c.c_customer_sk = s.ss_customer_sk AND s.ss_sold_date_s...\n    GROUP BY: a.ca_state\n    ORDER BY: cnt, a.ca_state\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
  "ir_node_map_target": "S0 [SELECT]\n  CTE: target_month  (via CTE_Q_S0_target_month)\n    FROM: date_dim\n    WHERE [198e5f8f07395c48]: d_year = 2002 AND d_moy = 3\n  CTE: category_avg  (via CTE_Q_S0_category_avg)\n    FROM: item\n    GROUP BY: i_category\n  MAIN QUERY (via Q_S0)\n    FROM: customer_address a, customer c, store_sales s, date_dim d, target_month tm, item i, category_avg ca\n    WHERE [031e98036ebea62d]: i.i_current_price > ca.price_threshold\n    GROUP BY: a.ca_state\n    ORDER BY: cnt, a.ca_state\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
  "dialect": "duckdb",
  "transforms": [
    "date_cte_isolate"
  ],
  "families": [
    "A"
  ],
  "gap_ids": [
    "CROSS_CTE_PREDICATE_BLINDNESS"
  ],
  "dag_example": {
    "plan_id": "gold_duckdb_date_cte_isolate",
    "dialect": "duckdb",
    "target_ir": "rewrite final_select to optimized query shape",
    "dag": {
      "order": [
        "final_select"
      ],
      "final_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "deps": [],
          "outputs": [
            "state",
            "cnt"
          ],
          "changed": true,
          "sql": "WITH target_month AS (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3), category_avg AS (SELECT i_category, AVG(i_current_price) * 1.2 AS price_threshold FROM item GROUP BY i_category)\nSELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address AS a JOIN customer AS c ON a.ca_address_sk = c.c_current_addr_sk JOIN store_sales AS s ON c.c_customer_sk = s.ss_customer_sk JOIN date_dim AS d ON s.ss_sold_date_sk = d.d_date_sk JOIN target_month AS tm ON d.d_month_seq = tm.d_month_seq JOIN item AS i ON s.ss_item_sk = i.i_item_sk JOIN category_avg AS ca ON i.i_category = ca.i_category WHERE i.i_current_price > ca.price_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100"
        }
      ]
    }
  }
}
