{
  "id": "aggregate_pushdown",
  "name": "Aggregate Pushdown Below Joins",
  "description": "Pre-aggregate fact table by join key before dimension joins to reduce rows entering the join from millions to thousands",
  "verified_speedup": "42.90x",
  "principle": "Push aggregation below joins: when a GROUP BY + aggregate operates on a single fact table joined with dimensions, pre-aggregate the fact table on the join key first, THEN join with dimensions. Reduces rows entering the join from millions to thousands.",
  "example": {
    "opportunity": "AGGREGATE_PUSHDOWN",
    "input_slice": "SELECT i_product_name, i_brand, i_class, i_category, avg(inv_quantity_on_hand) qoh\nFROM inventory, date_dim, item\nWHERE inv_date_sk=d_date_sk AND inv_item_sk=i_item_sk\n  AND d_month_seq BETWEEN 1188 AND 1188 + 11\nGROUP BY ROLLUP(i_product_name, i_brand, i_class, i_category)\nORDER BY qoh, i_product_name, i_brand, i_class, i_category\nLIMIT 100",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "aggregate_pushdown",
          "nodes": {
            "date_filtered": "SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1188 AND 1188 + 11",
            "inventory_date": "SELECT inv_item_sk, inv_quantity_on_hand FROM inventory JOIN date_filtered ON inv_date_sk = d_date_sk",
            "inventory_agg": "SELECT inv_item_sk, SUM(inv_quantity_on_hand) AS sum_qty, COUNT(inv_quantity_on_hand) AS cnt FROM inventory_date GROUP BY inv_item_sk",
            "join_item": "SELECT i_product_name, i_brand, i_class, i_category, sum_qty, cnt FROM inventory_agg JOIN item ON inv_item_sk = i_item_sk",
            "rollup_aggregate": "SELECT i_product_name, i_brand, i_class, i_category, CASE WHEN SUM(cnt) > 0 THEN SUM(sum_qty) / SUM(cnt) END AS qoh FROM join_item GROUP BY ROLLUP(i_product_name, i_brand, i_class, i_category)",
            "main_query": "SELECT i_product_name, i_brand, i_class, i_category, qoh FROM rollup_aggregate ORDER BY qoh ASC, i_product_name ASC, i_brand ASC, i_class ASC, i_category ASC LIMIT 100"
          },
          "invariants_kept": [
            "output columns unchanged",
            "grain preserved",
            "same result rows"
          ],
          "expected_speedup": "42.90x",
          "risk": "medium"
        }
      ]
    },
    "key_insight": "Principle: Aggregate Pushdown \u2014 pre-aggregate the fact table (inventory) by the join key (inv_item_sk) BEFORE joining with the dimension table (item). The original query joins 7M inventory rows with date_dim and item, then aggregates with ROLLUP. The rewrite filters dates first, pre-aggregates inventory to ~150K rows (one per item), THEN joins item. AVG is reconstructed from SUM/COUNT since pre-aggregation changes the row count. This produced our single biggest individual win (42.90x).",
    "when_not_to_use": "Only works when GROUP BY keys are a superset of join keys \u2014 misaligned keys produce wrong results. When ROLLUP/CUBE is present, must reconstruct AVG from SUM/COUNT since pre-aggregation changes the row count."
  },
  "original_sql": "select i_product_name\n             ,i_brand\n             ,i_class\n             ,i_category\n             ,avg(inv_quantity_on_hand) qoh\n       from inventory\n           ,date_dim\n           ,item\n       where inv_date_sk=d_date_sk\n              and inv_item_sk=i_item_sk\n              and d_month_seq between 1188 and 1188 + 11\n       group by rollup(i_product_name\n                       ,i_brand\n                       ,i_class\n                       ,i_category)\norder by qoh, i_product_name, i_brand, i_class, i_category\n LIMIT 100;",
  "optimized_sql": "WITH date_filtered AS (SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1188 AND 1188 + 11), inventory_date AS (SELECT inv_item_sk, inv_quantity_on_hand FROM inventory JOIN date_filtered ON inv_date_sk = d_date_sk), inventory_agg AS (SELECT inv_item_sk, SUM(inv_quantity_on_hand) AS sum_qty, COUNT(inv_quantity_on_hand) AS cnt FROM inventory_date GROUP BY inv_item_sk), join_item AS (SELECT i_product_name, i_brand, i_class, i_category, sum_qty, cnt FROM inventory_agg JOIN item ON inv_item_sk = i_item_sk), rollup_aggregate AS (SELECT i_product_name, i_brand, i_class, i_category, CASE WHEN SUM(cnt) > 0 THEN SUM(sum_qty) / SUM(cnt) END AS qoh FROM join_item GROUP BY ROLLUP(i_product_name, i_brand, i_class, i_category)) SELECT i_product_name, i_brand, i_class, i_category, qoh FROM rollup_aggregate ORDER BY qoh ASC, i_product_name ASC, i_brand ASC, i_class ASC, i_category ASC LIMIT 100",
  "optimized_source": "swarm_w1",
  "sf10_rows_match": true
}
