{
  "id": "self_join_decomposition",
  "name": "Self-Join Decomposition",
  "description": "Split self-joined CTE with different filter values into separate per-filter CTEs to avoid full materialization and post-filtering",
  "verified_speedup": "4.76x",
  "principle": "When a CTE is self-joined with different filter values (e.g., inv1.d_moy=1 AND inv2.d_moy=2), split into separate CTEs each embedding their filter. The optimizer cannot push the outer WHERE filter into the CTE's GROUP BY, causing full materialization and post-filtering.",
  "example": {
    "opportunity": "SELF_JOIN_DECOMPOSITION",
    "input_slice": "WITH inv AS (\n  SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy,\n    stdev, mean, CASE mean WHEN 0 THEN NULL ELSE stdev/mean END cov\n  FROM (SELECT w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy,\n          stddev_samp(inv_quantity_on_hand) stdev, avg(inv_quantity_on_hand) mean\n        FROM inventory, item, warehouse, date_dim\n        WHERE inv_item_sk = i_item_sk AND inv_warehouse_sk = w_warehouse_sk\n          AND inv_date_sk = d_date_sk AND d_year = 1998\n        GROUP BY w_warehouse_name, w_warehouse_sk, i_item_sk, d_moy) foo\n  WHERE CASE mean WHEN 0 THEN 0 ELSE stdev/mean END > 1)\nSELECT inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov,\n       inv2.w_warehouse_sk, inv2.i_item_sk, inv2.d_moy, inv2.mean, inv2.cov\nFROM inv inv1, inv inv2\nWHERE inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk\n  AND inv1.d_moy=1 AND inv2.d_moy=1+1\nORDER BY inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov,\n         inv2.d_moy, inv2.mean, inv2.cov",
    "output": {
      "rewrite_sets": [
        {
          "id": "rs_01",
          "transform": "self_join_decomposition",
          "nodes": {
            "month1_stats": "SELECT w_warehouse_sk, i_item_sk, 1 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 1 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1",
            "month2_stats": "SELECT w_warehouse_sk, i_item_sk, 2 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 2 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1",
            "main_query": "SELECT month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.w_warehouse_sk, month2_stats.i_item_sk, month2_stats.d_moy, month2_stats.mean, month2_stats.cov FROM month1_stats JOIN month2_stats ON month1_stats.w_warehouse_sk = month2_stats.w_warehouse_sk AND month1_stats.i_item_sk = month2_stats.i_item_sk ORDER BY month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.d_moy, month2_stats.mean, month2_stats.cov"
          },
          "invariants_kept": [
            "output columns unchanged",
            "grain preserved",
            "same result rows"
          ],
          "expected_speedup": "4.76x",
          "risk": "low"
        }
      ]
    },
    "key_insight": "Principle: Self-Join Decomposition \u2014 when a CTE is self-joined with different discriminator filters (d_moy=1 vs d_moy=2), the optimizer materializes the CTE for ALL months then post-filters. Splitting into month1_stats and month2_stats CTEs each with their own d_moy filter means each CTE aggregates only its month's rows. The comma join is also converted to explicit JOIN ON. 4.76x speedup from processing 1/12th of the data in each CTE.",
    "when_not_to_use": "Only applies when the CTE is self-joined with different discriminator values. If the self-join uses the same filter on both aliases, decomposition provides no benefit."
  },
  "original_sql": "with inv as\n(select w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy\n       ,stdev,mean, case mean when 0 then null else stdev/mean end cov\n from(select w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy\n            ,stddev_samp(inv_quantity_on_hand) stdev,avg(inv_quantity_on_hand) mean\n      from inventory\n          ,item\n          ,warehouse\n          ,date_dim\n      where inv_item_sk = i_item_sk\n        and inv_warehouse_sk = w_warehouse_sk\n        and inv_date_sk = d_date_sk\n        and d_year =1998\n      group by w_warehouse_name,w_warehouse_sk,i_item_sk,d_moy) foo\n where case mean when 0 then 0 else stdev/mean end > 1)\nselect inv1.w_warehouse_sk,inv1.i_item_sk,inv1.d_moy,inv1.mean, inv1.cov\n        ,inv2.w_warehouse_sk,inv2.i_item_sk,inv2.d_moy,inv2.mean, inv2.cov\nfrom inv inv1,inv inv2\nwhere inv1.i_item_sk = inv2.i_item_sk\n  and inv1.w_warehouse_sk =  inv2.w_warehouse_sk\n  and inv1.d_moy=1\n  and inv2.d_moy=1+1\norder by inv1.w_warehouse_sk,inv1.i_item_sk,inv1.d_moy,inv1.mean,inv1.cov\n        ,inv2.d_moy,inv2.mean, inv2.cov\n;",
  "optimized_sql": "WITH month1_stats AS (SELECT w_warehouse_sk, i_item_sk, 1 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 1 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1), month2_stats AS (SELECT w_warehouse_sk, i_item_sk, 2 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 2 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1) SELECT month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.w_warehouse_sk, month2_stats.i_item_sk, month2_stats.d_moy, month2_stats.mean, month2_stats.cov FROM month1_stats JOIN month2_stats ON month1_stats.w_warehouse_sk = month2_stats.w_warehouse_sk AND month1_stats.i_item_sk = month2_stats.i_item_sk ORDER BY month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.d_moy, month2_stats.mean, month2_stats.cov",
  "optimized_source": "swarm_w2",
  "sf10_rows_match": true,
  "family": "F",
  "ir_node_map_before": "S0 [SELECT]\n  CTE: inv  (via CTE_Q_S0_inv)\n    FROM: (subquery) foo\n    WHERE [ceb681f4fee117f7]: CASE mean WHEN 0 THEN 0 ELSE stdev / mean END > 1\n  MAIN QUERY (via Q_S0)\n    FROM: inv inv1, inv inv2\n    WHERE [903785bf15ae0b13]: inv1.i_item_sk = inv2.i_item_sk AND inv1.w_warehouse_sk = inv2.w_warehouse_sk AND inv1.d_moy = 1 ...\n    ORDER BY: inv1.w_warehouse_sk, inv1.i_item_sk, inv1.d_moy, inv1.mean, inv1.cov, inv2.d_moy, inv2.mean, inv2.cov\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
  "ir_node_map_target": "S0 [SELECT]\n  CTE: month1_stats  (via CTE_Q_S0_month1_stats)\n    FROM: inventory, item, warehouse, date_dim\n    WHERE [897571daf06f68d7]: d_year = 1998 AND d_moy = 1\n    GROUP BY: w_warehouse_sk, i_item_sk\n  CTE: month2_stats  (via CTE_Q_S0_month2_stats)\n    FROM: inventory, item, warehouse, date_dim\n    WHERE [ce1ca54e676639f9]: d_year = 1998 AND d_moy = 2\n    GROUP BY: w_warehouse_sk, i_item_sk\n  MAIN QUERY (via Q_S0)\n    FROM: month1_stats, month2_stats\n    ORDER BY: month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.d_moy, month2_stats.mean, month2_stats.cov\n\nPatch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree\nTarget: by_node_id (statement, e.g. \"S0\") + by_anchor_hash (expression)",
  "dialect": "duckdb",
  "transforms": [
    "self_join_decomposition"
  ],
  "families": [
    "F"
  ],
  "gap_ids": [
    "CROSS_CTE_PREDICATE_BLINDNESS"
  ],
  "tree_example": {
    "plan_id": "gold_duckdb_self_join_decomposition",
    "dialect": "duckdb",
    "target_ir": "rewrite final_select to optimized query shape",
    "tree": {
      "root_node_id": "final_select",
      "nodes": [
        {
          "node_id": "final_select",
          "parent_node_id": null,
          "sources": [],
          "outputs": [
            "w_warehouse_sk",
            "i_item_sk",
            "d_moy",
            "mean",
            "cov",
            "w_warehouse_sk",
            "i_item_sk",
            "d_moy",
            "mean",
            "cov"
          ],
          "changed": true,
          "sql": "WITH month1_stats AS (SELECT w_warehouse_sk, i_item_sk, 1 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 1 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1), month2_stats AS (SELECT w_warehouse_sk, i_item_sk, 2 AS d_moy, stddev_samp(inv_quantity_on_hand) AS stdev, avg(inv_quantity_on_hand) AS mean, CASE WHEN avg(inv_quantity_on_hand) = 0 THEN NULL ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END AS cov FROM inventory JOIN item ON inv_item_sk = i_item_sk JOIN warehouse ON inv_warehouse_sk = w_warehouse_sk JOIN date_dim ON inv_date_sk = d_date_sk WHERE d_year = 1998 AND d_moy = 2 GROUP BY w_warehouse_sk, i_item_sk HAVING CASE WHEN avg(inv_quantity_on_hand) = 0 THEN 0 ELSE stddev_samp(inv_quantity_on_hand)/avg(inv_quantity_on_hand) END > 1) SELECT month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.w_warehouse_sk, month2_stats.i_item_sk, month2_stats.d_moy, month2_stats.mean, month2_stats.cov FROM month1_stats JOIN month2_stats ON month1_stats.w_warehouse_sk = month2_stats.w_warehouse_sk AND month1_stats.i_item_sk = month2_stats.i_item_sk ORDER BY month1_stats.w_warehouse_sk, month1_stats.i_item_sk, month1_stats.d_moy, month1_stats.mean, month1_stats.cov, month2_stats.d_moy, month2_stats.mean, month2_stats.cov"
        }
      ]
    }
  }
}
