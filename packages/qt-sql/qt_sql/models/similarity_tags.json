{
  "examples": [
    {
      "id": "aggregate_pushdown",
      "tags": [
        "aggregate",
        "between",
        "date_dim",
        "group_by",
        "inventory",
        "item",
        "join",
        "order_by",
        "rollup"
      ],
      "category": "aggregation_rewrite",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Aggregate Pushdown Below Joins",
        "description": "Pre-aggregate fact table by join key before dimension joins to reduce rows entering the join from millions to thousands",
        "verified_speedup": "42.90x",
        "transforms": [
          "aggregate_pushdown"
        ],
        "winning_transform": "aggregate_pushdown",
        "principle": "Push aggregation below joins: when a GROUP BY + aggregate operates on a single fact table joined with dimensions, pre-aggregate the fact table on the join key first, THEN join with dimensions. Reduces rows entering the join from millions to thousands.",
        "key_insight": "Principle: Aggregate Pushdown \u2014 pre-aggregate the fact table (inventory) by the join key (inv_item_sk) BEFORE joining with the dimension table (item). The original query joins 7M inventory rows with date_dim and item, then aggregates with ROLLUP. The rewrite filters dates first, pre-aggregates inventory to ~150K rows (one per item), THEN joins item. AVG is reconstructed from SUM/COUNT since pre-aggregation changes the row count. This produced our single biggest individual win (42.90x).",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "channel_bitmap_aggregation",
      "tags": [
        "aggregate",
        "household_demographics",
        "independent_sub",
        "join",
        "or_branch_count:3",
        "or_predicate",
        "or_same_col",
        "repeat:household_demographics:8",
        "repeat:store:8",
        "repeat:store_sales:8",
        "repeat:time_dim:8",
        "repeated_scan",
        "self_join",
        "star_join_pattern",
        "store",
        "store_sales",
        "sub_nesting_depth:1",
        "subquery",
        "time_dim"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Channel Bitmap Aggregation",
        "description": "Consolidate repeated scans of the same fact table (one per time/channel bucket) into a single scan with CASE WHEN labels and conditional aggregation",
        "verified_speedup": "6.24x",
        "transforms": [
          "single_pass_aggregation + dimension_cte_isolate"
        ],
        "winning_transform": "single_pass_aggregation + dimension_cte_isolate",
        "principle": "",
        "key_insight": "The original query scans store_sales 8 times (once per time bucket), each with identical dimension joins. Consolidating into a single scan with CASE WHEN labels inside COUNT() reduces I/O from 8x to 1x. Dimension pre-filtering CTEs further reduce the join probe size.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "composite_decorrelate_union",
      "tags": [
        "aggregate",
        "catalog_sales",
        "correlated",
        "customer",
        "customer_address",
        "customer_demographics",
        "date_dim",
        "decorrelate",
        "exists",
        "group_by",
        "join",
        "materialize",
        "multi_channel",
        "or_branch_count:2",
        "or_predicate",
        "or_same_col",
        "order_by",
        "repeat:date_dim:3",
        "repeated_scan",
        "self_join",
        "star_join_pattern",
        "store_sales",
        "web_sales"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Decorrelate EXISTS + OR-to-UNION Composite",
        "description": "Decorrelate multiple correlated EXISTS subqueries into pre-materialized DISTINCT customer CTEs with a shared date filter, and replace OR(EXISTS a, EXISTS b) with UNION of key sets",
        "verified_speedup": "2.42x",
        "transforms": [
          "decorrelate + date_cte_isolate + or_to_union"
        ],
        "winning_transform": "decorrelate + date_cte_isolate + or_to_union",
        "principle": "Composite Decorrelation: when multiple correlated EXISTS share common filters, extract shared dimensions into a single CTE and decorrelate the EXISTS checks into pre-materialized key sets joined via UNION.",
        "key_insight": "Principle: Composite Decorrelation \u2014 when multiple correlated EXISTS share common filters, extract shared dimensions once, decorrelate each EXISTS into a DISTINCT CTE, and replace OR(EXISTS) with UNION at the set level. Here: (1) shared date filter CTE, (2) each EXISTS becomes SELECT DISTINCT customer_sk joined with filtered_dates, (3) OR(EXISTS web, EXISTS catalog) becomes UNION of key CTEs. Works because the query only checks membership, which DISTINCT + JOIN achieves.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "date_cte_isolate",
      "tags": [
        "aggregate",
        "correlated_sub",
        "correlated_subquery",
        "customer",
        "customer_address",
        "date_dim",
        "distinct",
        "group_by",
        "having",
        "independent_sub",
        "item",
        "join",
        "order_by",
        "pushdown",
        "repeat:date_dim:2",
        "repeat:item:2",
        "self_join",
        "star_join_pattern",
        "store_sales",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Date CTE Isolation",
        "description": "Extract date filtering into a separate CTE to enable predicate pushdown and reduce scans",
        "verified_speedup": "4.00x",
        "transforms": [
          "date_cte_isolate + category_avg"
        ],
        "winning_transform": "date_cte_isolate + category_avg",
        "principle": "Dimension Isolation: extract small dimension lookups into CTEs so they materialize once and subsequent joins probe a tiny hash table instead of rescanning.",
        "key_insight": "Principle: Dimension Isolation \u2014 extract small dimension lookups into CTEs so they materialize once and subsequent joins probe a tiny hash table. Here: extract date month_seq subquery into CTE, extract category average into separate CTE with GROUP BY, then JOIN instead of correlated subquery. Each CTE is scanned once.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "decorrelate",
      "tags": [
        "aggregate",
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "cte",
        "cte_filtered",
        "customer",
        "customer_total_return",
        "date_dim",
        "group_by",
        "join",
        "order_by",
        "repeat:customer_total_return:2",
        "self_join",
        "star_join_pattern",
        "store",
        "store_returns",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Decorrelate Subquery",
        "description": "Convert correlated subquery to separate CTE with GROUP BY, then JOIN",
        "verified_speedup": "2.92x",
        "transforms": [
          "decorrelate + pushdown"
        ],
        "winning_transform": "decorrelate + pushdown",
        "principle": "Decorrelation: convert correlated subqueries to standalone CTEs with GROUP BY, then JOIN. Correlated subqueries re-execute per outer row; a pre-computed CTE executes once.",
        "key_insight": "Principle: Decorrelation \u2014 convert correlated subqueries to standalone CTEs with GROUP BY, then JOIN. Correlated subqueries re-execute per outer row; a pre-computed CTE executes once. Here: push s_state='SD' filter early into first CTE, compute average as separate CTE with GROUP BY (not window function), then JOIN on the average threshold.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "deferred_window_aggregation",
      "tags": [
        "aggregate",
        "between",
        "case",
        "correlated_sub",
        "correlated_subquery",
        "cte",
        "cte_filtered",
        "date_dim",
        "group_by",
        "join",
        "multi_channel",
        "multi_cte",
        "order_by",
        "outer_join",
        "repeat:date_dim:2",
        "self_join",
        "store_sales",
        "store_v1",
        "sub_nesting_depth:2",
        "subquery",
        "web_sales",
        "web_v1",
        "window"
      ],
      "category": "subquery_elimination",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Deferred Window Aggregation",
        "description": "When multiple CTEs each perform GROUP BY + WINDOW (cumulative sum), then are joined with FULL OUTER JOIN followed by another WINDOW pass for NULL carry-forward: defer the WINDOW out of the CTEs, join daily totals, then compute cumulative sums once on the joined result. SUM() OVER() naturally skips NULLs, eliminating the need for a separate MAX() carry-forward window.",
        "verified_speedup": "1.36x",
        "transforms": [
          "consolidate window passes"
        ],
        "winning_transform": "consolidate window passes",
        "principle": "Deferred Aggregation: delay expensive operations (window functions) until after joins reduce the dataset. Computing window functions inside individual CTEs then joining is more expensive than joining first and computing windows once on the combined result.",
        "key_insight": "Principle: Deferred Aggregation \u2014 delay expensive operations (window functions) until after joins reduce the dataset. Computing windows in CTEs before joining wastes work on rows that get filtered. Here: remove WINDOW from CTEs (keep only GROUP BY for daily totals), join the reduced results, then compute SUM() OVER() once on the joined output. Reduces 3 WINDOW passes to 1, and SUM() naturally skips NULLs from the FULL OUTER JOIN.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "dimension_cte_isolate",
      "tags": [
        "aggregate",
        "catalog_sales",
        "customer_demographics",
        "date_dim",
        "group_by",
        "item",
        "join",
        "or_branch_count:2",
        "or_cross_col",
        "or_predicate",
        "order_by",
        "promotion",
        "star_join_pattern"
      ],
      "category": "general",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Dimension CTE Isolation",
        "description": "Pre-filter ALL dimension tables into CTEs before joining with fact table, not just date_dim",
        "verified_speedup": "1.93x",
        "transforms": [
          "dimension cte isolation"
        ],
        "winning_transform": "dimension cte isolation",
        "principle": "Early Selection: pre-filter dimension tables into CTEs returning only surrogate keys before joining with fact tables. Each dimension CTE is tiny, creating small hash tables that speed up the fact table probe.",
        "key_insight": "Principle: Early Selection \u2014 pre-filter dimension tables into CTEs returning only surrogate keys before joining with fact tables. Each CTE creates a tiny hash table that the fact join probes against, reducing intermediate cardinality. Here: isolate date, demographics, and promotions into separate filtered CTEs, then join their keys with the fact table. Most effective when dimension filters are highly selective.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "early_filter",
      "tags": [
        "aggregate",
        "case",
        "group_by",
        "independent_sub",
        "join",
        "left_join",
        "left_join_right_filter",
        "order_by",
        "outer_join",
        "reason",
        "store_returns",
        "store_sales",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "join_reorder",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Early Dimension Filter",
        "description": "Filter dimension tables FIRST, then join to fact tables to reduce expensive joins",
        "verified_speedup": "4.00x",
        "transforms": [
          "early_filter"
        ],
        "winning_transform": "early_filter",
        "principle": "Early Selection: filter small dimension tables first, then join to large fact tables. This reduces the fact table scan to only rows matching the filter, rather than scanning all rows and filtering after the join.",
        "key_insight": "Principle: Early Selection \u2014 filter small dimension tables first, then join to large fact tables. This reduces the fact table scan to only rows matching the filter, rather than scanning all rows and filtering after the join. Here: filter reason table to 'duplicate purchase' first, then join to store_returns, then to store_sales \u2014 dramatically reducing the rows entering the expensive fact join.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "inner_join_conversion",
      "tags": [
        "aggregate",
        "case",
        "early_filter",
        "group_by",
        "independent_sub",
        "join",
        "left_join",
        "left_join_right_filter",
        "order_by",
        "outer_join",
        "reason",
        "store_returns",
        "store_sales",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "join_reorder",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Inner Join Conversion",
        "description": "Convert LEFT JOIN + right-table WHERE filter to INNER JOIN + early filter CTE when the WHERE eliminates NULL rows",
        "verified_speedup": "3.44x",
        "transforms": [
          "inner_join_conversion"
        ],
        "winning_transform": "inner_join_conversion",
        "principle": "When a LEFT JOIN is immediately followed by a WHERE filter on the right table that eliminates NULL rows, convert to INNER JOIN + early filter CTE. The WHERE clause already makes the LEFT JOIN behave as an INNER JOIN, but the optimizer keeps the LEFT JOIN semantics (preserving all left rows), wasting work on rows that are filtered out.",
        "key_insight": "Principle: Inner Join Conversion \u2014 when a LEFT JOIN is followed by a WHERE filter on the right table (sr_reason_sk = r_reason_sk), the WHERE already eliminates NULL rows from the LEFT JOIN, making it behave as an INNER JOIN. Converting explicitly to INNER JOIN + early filter CTE lets the optimizer skip preserving left-side rows. Here: filtered reason \u2192 INNER JOIN store_returns + store_sales \u2192 aggregate. The optimizer cannot infer that the WHERE makes LEFT JOIN equivalent to INNER JOIN.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "intersect_to_exists",
      "tags": [
        "aggregate",
        "avg_sales",
        "between",
        "catalog_sales",
        "correlated_sub",
        "correlated_subquery",
        "cross_items",
        "cte",
        "cte_filtered",
        "date_dim",
        "group_by",
        "having",
        "in",
        "independent_sub",
        "intersect",
        "item",
        "join",
        "multi_channel",
        "multi_cte",
        "order_by",
        "repeat:avg_sales:3",
        "repeat:catalog_sales:3",
        "repeat:cross_items:3",
        "repeat:date_dim:9",
        "repeat:item:7",
        "repeat:store_sales:3",
        "repeat:web_sales:3",
        "repeated_scan",
        "rollup",
        "self_join",
        "store_sales",
        "sub_nesting_depth:2",
        "subquery",
        "union",
        "web_sales"
      ],
      "category": "set_operations",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "INTERSECT to EXISTS",
        "description": "Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join planning",
        "verified_speedup": "1.83x",
        "transforms": [
          "intersect_to_exists"
        ],
        "winning_transform": "intersect_to_exists",
        "principle": "Semi-Join Short-Circuit: replace INTERSECT with EXISTS to avoid full materialization and sorting. INTERSECT must compute complete result sets before intersecting; EXISTS stops at the first match per row, enabling semi-join optimizations.",
        "key_insight": "Principle: Semi-Join Short-Circuit \u2014 replace INTERSECT with EXISTS to avoid full materialization and sorting. INTERSECT must compute complete result sets before intersecting; EXISTS stops at the first match per row, enabling semi-join optimizations. Here: convert three INTERSECT subqueries to EXISTS clauses, allowing the optimizer to short-circuit and use index-based semi-joins.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "materialize_cte",
      "tags": [
        "aggregate",
        "between",
        "cte",
        "cte_filtered",
        "customer_address",
        "date_dim",
        "distinct",
        "in",
        "independent_sub",
        "join",
        "order_by",
        "repeat:web_sales:3",
        "repeat:ws_wh:2",
        "repeated_scan",
        "self_join",
        "star_join_pattern",
        "sub_nesting_depth:1",
        "subquery",
        "web_returns",
        "web_sales",
        "web_site",
        "ws_wh"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Materialize Repeated Subquery",
        "description": "Extract repeated subquery patterns into a CTE to avoid recomputation",
        "verified_speedup": "1.37x",
        "transforms": [
          "materialize_cte"
        ],
        "winning_transform": "materialize_cte",
        "principle": "Shared Materialization: extract repeated subquery patterns into CTEs to avoid recomputation. When the same logical check appears multiple times, compute it once and reference the result.",
        "key_insight": "Principle: Shared Materialization \u2014 extract repeated subquery patterns into CTEs to avoid recomputation. When the same logical check appears in multiple places (EXISTS, WHERE, JOIN), computing it once as a CTE and referencing it is cheaper. Here: extract multi-warehouse order detection into one CTE, returned orders into another, then JOIN instead of nested EXISTS checks.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "multi_date_range_cte",
      "tags": [
        "aggregate",
        "between",
        "catalog_sales",
        "date_dim",
        "group_by",
        "in",
        "item",
        "join",
        "multi_channel",
        "order_by",
        "repeat:date_dim:3",
        "repeated_scan",
        "self_join",
        "star_join_pattern",
        "store",
        "store_returns",
        "store_sales"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Multi Date Range CTE",
        "description": "When query uses multiple date_dim aliases with different filters (d1, d2, d3), create separate CTEs for each date range and pre-join with fact tables",
        "verified_speedup": "2.35x",
        "transforms": [
          "multi date range cte"
        ],
        "winning_transform": "multi date range cte",
        "principle": "Early Selection per Alias: when a query joins the same dimension table multiple times with different filters (d1, d2, d3), create separate CTEs for each filter and pre-join with fact tables to reduce rows entering the main join.",
        "key_insight": "Principle: Early Selection per Alias \u2014 when a query joins the same dimension table multiple times with different filters (d1, d2, d3 pattern), create separate filtered CTEs for each alias. Pre-join each date CTE with its corresponding fact table reference. This filters fact rows early before the expensive multi-way join, avoiding repeated full dimension scans.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "multi_dimension_prefetch",
      "tags": [
        "aggregate",
        "case",
        "date_dim",
        "group_by",
        "join",
        "order_by",
        "store",
        "store_sales"
      ],
      "category": "aggregation_rewrite",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Multi Dimension Prefetch",
        "description": "Pre-filter multiple dimension tables (date + store) into separate CTEs before joining with fact table",
        "verified_speedup": "2.71x",
        "transforms": [
          "multi dimension prefetch"
        ],
        "winning_transform": "multi dimension prefetch",
        "principle": "Multi-Dimension Prefetch: when multiple dimension tables have selective filters, pre-filter ALL of them into CTEs before the fact table join. Combined selectivity compounds \u2014 each dimension CTE reduces the fact scan further.",
        "key_insight": "Principle: Multi-Dimension Prefetch \u2014 when multiple dimension tables have selective filters, pre-filter ALL of them into CTEs before the fact join. Each CTE creates a small hash table; the fact scan probes multiple tiny tables instead of large ones. Here: pre-filter both date_dim and store into separate CTEs with only the columns needed for join and grouping.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "multi_intersect_exists_cte",
      "tags": [
        "aggregate",
        "avg_sales",
        "between",
        "catalog_sales",
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "cross_items",
        "cte",
        "cte_filtered",
        "date_dim",
        "group_by",
        "having",
        "in",
        "independent_sub",
        "intersect",
        "item",
        "join",
        "materialize",
        "multi_channel",
        "multi_cte",
        "order_by",
        "repeat:avg_sales:3",
        "repeat:catalog_sales:3",
        "repeat:cross_items:3",
        "repeat:date_dim:9",
        "repeat:item:7",
        "repeat:store_sales:3",
        "repeat:web_sales:3",
        "repeated_scan",
        "rollup",
        "self_join",
        "store_sales",
        "sub_nesting_depth:2",
        "subquery",
        "union",
        "web_sales"
      ],
      "category": "set_operations",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Multi-INTERSECT to EXISTS with CTEs",
        "description": "Convert cascading INTERSECT operations into correlated EXISTS subqueries with pre-materialized date and channel CTEs",
        "verified_speedup": "2.39x",
        "transforms": [
          "intersect_to_exists + date_cte_isolate + materialize_cte"
        ],
        "winning_transform": "intersect_to_exists + date_cte_isolate + materialize_cte",
        "principle": "",
        "key_insight": "INTERSECT materializes full intermediate result sets (brand_id, class_id, category_id triples) from each channel before intersecting. EXISTS with correlated predicates short-circuits early \u2014 once a matching row is found for each channel, processing stops. Pre-filtering date_dim into a CTE avoids repeated scans of the 73K-row date table.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "or_to_union",
      "tags": [
        "aggregate",
        "catalog_sales",
        "customer",
        "customer_address",
        "date_dim",
        "group_by",
        "in",
        "join",
        "or_branch_count:3",
        "or_cross_col",
        "or_predicate",
        "order_by",
        "star_join_pattern"
      ],
      "category": "general",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "OR to UNION ALL",
        "description": "Split OR conditions on different columns into UNION ALL branches for better index usage",
        "verified_speedup": "3.17x",
        "transforms": [
          "or_to_union + early_filter"
        ],
        "winning_transform": "or_to_union + early_filter",
        "principle": "OR-to-UNION Decomposition: split OR conditions on different columns into separate UNION ALL branches, each with a focused predicate. The optimizer can use different access paths per branch instead of a single scan with a complex filter.",
        "key_insight": "Principle: OR-to-UNION Decomposition \u2014 split OR conditions on different columns into separate UNION ALL branches, each with a focused predicate. The optimizer can use different access paths per branch instead of a single scan with a complex filter. Here: three OR branches (zip codes, states, price threshold) become three UNION ALL branches, each with its own focused predicate. Date filter extracted as shared CTE.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "prefetch_fact_join",
      "tags": [
        "aggregate",
        "case",
        "date_dim",
        "group_by",
        "in",
        "independent_sub",
        "item",
        "join",
        "or_branch_count:2",
        "or_predicate",
        "or_same_col",
        "order_by",
        "star_join_pattern",
        "store",
        "store_sales",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "aggregation_rewrite",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Prefetch Fact Join",
        "description": "Pre-filter dimension table into CTE, then pre-join with fact table in second CTE before joining other dimensions",
        "verified_speedup": "3.77x",
        "transforms": [
          "prefetch fact join"
        ],
        "winning_transform": "prefetch fact join",
        "principle": "Staged Join Pipeline: build a CTE chain that progressively reduces data \u2014 first CTE filters the dimension, second CTE pre-joins filtered dimension keys with the fact table, subsequent CTEs join remaining dimensions against the already-reduced fact set.",
        "key_insight": "Principle: Staged Join Pipeline \u2014 build a CTE chain that progressively reduces data: first CTE filters the dimension, second CTE pre-joins the filtered dimension with the fact table to materialize a small intermediate result. Subsequent dimension joins then operate on this reduced dataset instead of the full fact table. Here: filter date_dim first, pre-join with store_sales, then join the smaller result with remaining dimensions.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "pushdown",
      "tags": [
        "aggregate",
        "between",
        "case",
        "independent_sub",
        "reason",
        "repeat:store_sales:15",
        "repeated_scan",
        "self_join",
        "store_sales",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Filter Pushdown",
        "description": "Push filters from outer query into CTEs/subqueries to reduce intermediate result sizes",
        "verified_speedup": "2.11x",
        "transforms": [
          "pushdown"
        ],
        "winning_transform": "pushdown",
        "principle": "Scan Consolidation: when multiple subqueries scan the same table with similar patterns, consolidate them into CTEs that compute all needed aggregates in fewer passes. Reduces N scans to fewer scans.",
        "key_insight": "Principle: Scan Consolidation \u2014 when multiple subqueries scan the same table with similar patterns, consolidate them into a single CTE that computes all needed aggregates in one pass. Reduces N scans to 1. Here: 15+ scalar subqueries with different quantity-range filters on store_sales become CTEs, each computing count, avg_ext_price, avg_net_profit in one scan per range.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "regression_q16_semantic_rewrite",
      "tags": [
        "aggregate",
        "between",
        "call_center",
        "catalog_returns",
        "catalog_sales",
        "customer_address",
        "date_dim",
        "distinct",
        "exists",
        "in",
        "join",
        "materialize",
        "order_by",
        "repeat:catalog_sales:2",
        "self_join",
        "star_join_pattern"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "regression",
      "metadata": {
        "name": "Q16 regression: semantic_rewrite (0.14x)",
        "description": "Never materialize GROUP BY aggregates with HAVING clauses on fact tables before filtering those fact tables through dimension joins.",
        "verified_speedup": "0.14x",
        "transforms": [],
        "winning_transform": "",
        "principle": "",
        "key_insight": "Never materialize GROUP BY aggregates with HAVING clauses on fact tables before filtering those fact tables through dimension joins.",
        "engine": "duckdb",
        "type": "regression"
      }
    },
    {
      "id": "regression_q1_decorrelate",
      "tags": [
        "aggregate",
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "cte",
        "cte_filtered",
        "customer",
        "customer_total_return",
        "date_dim",
        "group_by",
        "join",
        "order_by",
        "pushdown",
        "repeat:customer_total_return:2",
        "self_join",
        "star_join_pattern",
        "store",
        "store_returns",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "duckdb",
      "type": "regression",
      "metadata": {
        "name": "Q1 regression: decorrelate (0.71x)",
        "description": "Do not pre-aggregate GROUP BY results into CTEs when the query uses them in a correlated comparison (e.g., customer return > 1.2x store average). The optimizer can compute aggregates incrementally with filter pushdown; materialization loses this.",
        "verified_speedup": "0.71x",
        "transforms": [],
        "winning_transform": "",
        "principle": "",
        "key_insight": "Do not pre-aggregate GROUP BY results into CTEs when the query uses them in a correlated comparison (e.g., customer return > 1.2x store average). The optimizer can compute aggregates incrementally with filter pushdown; materialization loses this.",
        "engine": "duckdb",
        "type": "regression"
      }
    },
    {
      "id": "regression_q25_date_cte_isolate",
      "tags": [
        "aggregate",
        "between",
        "catalog_sales",
        "date_dim",
        "group_by",
        "item",
        "join",
        "materialize",
        "multi_channel",
        "order_by",
        "repeat:date_dim:3",
        "repeated_scan",
        "self_join",
        "star_join_pattern",
        "store",
        "store_returns",
        "store_sales"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "regression",
      "metadata": {
        "name": "Q25 regression: date_cte_isolate (0.5x)",
        "description": "Do not pre-filter and materialize fact tables when the query has 3+ fact table joins. The optimizer needs freedom to reorder multi-way fact joins and push filters across them.",
        "verified_speedup": "0.5x",
        "transforms": [],
        "winning_transform": "",
        "principle": "",
        "key_insight": "Do not pre-filter and materialize fact tables when the query has 3+ fact table joins. The optimizer needs freedom to reorder multi-way fact joins and push filters across them.",
        "engine": "duckdb",
        "type": "regression"
      }
    },
    {
      "id": "regression_q31_pushdown",
      "tags": [
        "aggregate",
        "case",
        "cte",
        "cte_filtered",
        "customer_address",
        "date_dim",
        "group_by",
        "join",
        "multi_channel",
        "multi_cte",
        "order_by",
        "repeat:customer_address:2",
        "repeat:date_dim:2",
        "repeat:ss:3",
        "repeat:ws:3",
        "repeated_scan",
        "self_join",
        "ss",
        "store_sales",
        "web_sales",
        "ws"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "regression",
      "metadata": {
        "name": "Q31 regression: pushdown (0.49x)",
        "description": "When creating filtered versions of existing CTEs, always REMOVE the original unfiltered CTEs. Keeping both causes redundant materialization and 1000x+ cardinality misestimates on self-joins.",
        "verified_speedup": "0.49x",
        "transforms": [],
        "winning_transform": "",
        "principle": "",
        "key_insight": "When creating filtered versions of existing CTEs, always REMOVE the original unfiltered CTEs. Keeping both causes redundant materialization and 1000x+ cardinality misestimates on self-joins.",
        "engine": "duckdb",
        "type": "regression"
      }
    },
    {
      "id": "regression_q51_date_cte_isolate",
      "tags": [
        "aggregate",
        "between",
        "case",
        "correlated_sub",
        "correlated_subquery",
        "cte",
        "cte_filtered",
        "date_dim",
        "group_by",
        "join",
        "materialize",
        "multi_channel",
        "multi_cte",
        "order_by",
        "outer_join",
        "repeat:date_dim:2",
        "self_join",
        "store_sales",
        "store_v1",
        "sub_nesting_depth:2",
        "subquery",
        "web_sales",
        "web_v1",
        "window"
      ],
      "category": "subquery_elimination",
      "engine": "duckdb",
      "type": "regression",
      "metadata": {
        "name": "Q51 regression: date_cte_isolate (0.87x)",
        "description": "Do not materialize running/cumulative window aggregates into CTEs before joins that filter based on those aggregates. The optimizer can co-optimize window evaluation and join filtering together.",
        "verified_speedup": "0.87x",
        "transforms": [],
        "winning_transform": "",
        "principle": "",
        "key_insight": "Do not materialize running/cumulative window aggregates into CTEs before joins that filter based on those aggregates. The optimizer can co-optimize window evaluation and join filtering together.",
        "engine": "duckdb",
        "type": "regression"
      }
    },
    {
      "id": "regression_q67_date_cte_isolate",
      "tags": [
        "aggregate",
        "between",
        "date_dim",
        "group_by",
        "grouping",
        "independent_sub",
        "item",
        "join",
        "materialize",
        "order_by",
        "rollup",
        "star_join_pattern",
        "store",
        "store_sales",
        "sub_nesting_depth:2",
        "subquery",
        "window"
      ],
      "category": "aggregation_rewrite",
      "engine": "duckdb",
      "type": "regression",
      "metadata": {
        "name": "Q67 regression: date_cte_isolate (0.85x)",
        "description": "Do not materialize dimension filters into CTEs before complex aggregations (ROLLUP, CUBE, GROUPING SETS) with window functions. The optimizer needs to push aggregation through joins; CTEs create materialization barriers.",
        "verified_speedup": "0.85x",
        "transforms": [],
        "winning_transform": "",
        "principle": "",
        "key_insight": "Do not materialize dimension filters into CTEs before complex aggregations (ROLLUP, CUBE, GROUPING SETS) with window functions. The optimizer needs to push aggregation through joins; CTEs create materialization barriers.",
        "engine": "duckdb",
        "type": "regression"
      }
    },
    {
      "id": "regression_q74_pushdown",
      "tags": [
        "aggregate",
        "case",
        "cte",
        "cte_filtered",
        "customer",
        "date_dim",
        "group_by",
        "in",
        "join",
        "multi_channel",
        "order_by",
        "repeat:customer:2",
        "repeat:date_dim:2",
        "repeat:year_total:4",
        "repeated_scan",
        "self_join",
        "store_sales",
        "union",
        "web_sales",
        "year_total"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "regression",
      "metadata": {
        "name": "Q74 regression: pushdown (0.68x)",
        "description": "When splitting a UNION CTE by year, you MUST remove or replace the original UNION CTE. Keeping both the split and original versions causes redundant materialization and extreme cardinality misestimates.",
        "verified_speedup": "0.68x",
        "transforms": [],
        "winning_transform": "",
        "principle": "",
        "key_insight": "When splitting a UNION CTE by year, you MUST remove or replace the original UNION CTE. Keeping both the split and original versions causes redundant materialization and extreme cardinality misestimates.",
        "engine": "duckdb",
        "type": "regression"
      }
    },
    {
      "id": "regression_q90_materialize_cte",
      "tags": [
        "aggregate",
        "between",
        "household_demographics",
        "independent_sub",
        "join",
        "order_by",
        "repeat:household_demographics:2",
        "repeat:time_dim:2",
        "repeat:web_page:2",
        "repeat:web_sales:2",
        "self_join",
        "star_join_pattern",
        "sub_nesting_depth:1",
        "subquery",
        "time_dim",
        "web_page",
        "web_sales"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "regression",
      "metadata": {
        "name": "Q90 regression: materialize_cte (0.59x)",
        "description": "Never convert OR conditions on the SAME column (e.g., range conditions on t_hour) into UNION ALL. The optimizer already handles same-column ORs as a single scan. UNION ALL only helps when branches access fundamentally different tables or columns.",
        "verified_speedup": "0.59x",
        "transforms": [],
        "winning_transform": "",
        "principle": "",
        "key_insight": "Never convert OR conditions on the SAME column (e.g., range conditions on t_hour) into UNION ALL. The optimizer already handles same-column ORs as a single scan. UNION ALL only helps when branches access fundamentally different tables or columns.",
        "engine": "duckdb",
        "type": "regression"
      }
    },
    {
      "id": "regression_q93_decorrelate",
      "tags": [
        "aggregate",
        "case",
        "correlated",
        "decorrelate",
        "group_by",
        "independent_sub",
        "join",
        "left_join",
        "left_join_right_filter",
        "order_by",
        "outer_join",
        "reason",
        "store_returns",
        "store_sales",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "join_reorder",
      "engine": "duckdb",
      "type": "regression",
      "metadata": {
        "name": "Q93 regression: decorrelate (0.34x)",
        "description": "Do not decorrelate correlated LEFT JOINs that the optimizer already executes as semi-joins. Materializing the correlated subquery into a CTE forces redundant scans.",
        "verified_speedup": "0.34x",
        "transforms": [],
        "winning_transform": "",
        "principle": "",
        "key_insight": "Do not decorrelate correlated LEFT JOINs that the optimizer already executes as semi-joins. Materializing the correlated subquery into a CTE forces redundant scans.",
        "engine": "duckdb",
        "type": "regression"
      }
    },
    {
      "id": "regression_q95_semantic_rewrite",
      "tags": [
        "aggregate",
        "between",
        "correlated",
        "cte",
        "cte_filtered",
        "customer_address",
        "date_dim",
        "distinct",
        "in",
        "independent_sub",
        "join",
        "order_by",
        "repeat:web_sales:3",
        "repeat:ws_wh:2",
        "repeated_scan",
        "self_join",
        "star_join_pattern",
        "sub_nesting_depth:1",
        "subquery",
        "web_returns",
        "web_sales",
        "web_site",
        "ws_wh"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "regression",
      "metadata": {
        "name": "Q95 regression: semantic_rewrite (0.54x)",
        "description": "Do not decompose tightly-correlated EXISTS/NOT EXISTS clause pairs into independent CTEs. Their cardinality estimates depend on each other; materializing them independently causes severe join cost misestimates.",
        "verified_speedup": "0.54x",
        "transforms": [],
        "winning_transform": "",
        "principle": "",
        "key_insight": "Do not decompose tightly-correlated EXISTS/NOT EXISTS clause pairs into independent CTEs. Their cardinality estimates depend on each other; materializing them independently causes severe join cost misestimates.",
        "engine": "duckdb",
        "type": "regression"
      }
    },
    {
      "id": "rollup_to_union_windowing",
      "tags": [
        "aggregate",
        "case",
        "date_dim",
        "group_by",
        "grouping",
        "in",
        "item",
        "join",
        "order_by",
        "rollup",
        "star_join_pattern",
        "store",
        "store_sales",
        "window"
      ],
      "category": "aggregation_rewrite",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "ROLLUP to UNION ALL Windowing",
        "description": "Replace GROUP BY ROLLUP with explicit UNION ALL of pre-aggregated CTEs at each hierarchy level, combined with window functions for ranking",
        "verified_speedup": "2.47x",
        "transforms": [
          "early_filter + materialize_cte + union_cte_split"
        ],
        "winning_transform": "early_filter + materialize_cte + union_cte_split",
        "principle": "",
        "key_insight": "ROLLUP generates all grouping levels in a single pass, but the optimizer cannot specialize each level's aggregation. Breaking into explicit UNION ALL of pre-computed CTEs allows each level to use the already-aggregated item_aggregates CTE, and dimension filters are pushed into early CTEs.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "self_join_decomposition",
      "tags": [
        "aggregate",
        "case",
        "cte",
        "cte_filtered",
        "date_dim",
        "group_by",
        "independent_sub",
        "inv",
        "inventory",
        "item",
        "join",
        "order_by",
        "repeat:inv:2",
        "self_join",
        "star_join_pattern",
        "sub_nesting_depth:1",
        "subquery",
        "warehouse"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Self-Join Decomposition",
        "description": "Split self-joined CTE with different filter values into separate per-filter CTEs to avoid full materialization and post-filtering",
        "verified_speedup": "4.76x",
        "transforms": [
          "self_join_decomposition"
        ],
        "winning_transform": "self_join_decomposition",
        "principle": "When a CTE is self-joined with different filter values (e.g., inv1.d_moy=1 AND inv2.d_moy=2), split into separate CTEs each embedding their filter. The optimizer cannot push the outer WHERE filter into the CTE's GROUP BY, causing full materialization and post-filtering.",
        "key_insight": "Principle: Self-Join Decomposition \u2014 when a CTE is self-joined with different discriminator filters (d_moy=1 vs d_moy=2), the optimizer materializes the CTE for ALL months then post-filters. Splitting into month1_stats and month2_stats CTEs each with their own d_moy filter means each CTE aggregates only its month's rows. The comma join is also converted to explicit JOIN ON. 4.76x speedup from processing 1/12th of the data in each CTE.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "shared_dimension_multi_channel",
      "tags": [
        "aggregate",
        "between",
        "catalog_page",
        "catalog_returns",
        "catalog_sales",
        "csr",
        "cte",
        "cte_filtered",
        "date_dim",
        "group_by",
        "independent_sub",
        "item",
        "join",
        "left_join",
        "multi_channel",
        "multi_cte",
        "order_by",
        "outer_join",
        "promotion",
        "repeat:date_dim:3",
        "repeat:item:3",
        "repeat:promotion:3",
        "repeated_scan",
        "rollup",
        "self_join",
        "ssr",
        "star_join_pattern",
        "store",
        "store_returns",
        "store_sales",
        "sub_nesting_depth:1",
        "subquery",
        "union",
        "web_returns",
        "web_sales",
        "web_site",
        "wsr"
      ],
      "category": "aggregation_rewrite",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Shared Dimension CTEs Across Multi-Channel Queries",
        "description": "Extract shared dimension filters (date, item, promotion) into CTEs when multiple channel CTEs (store/catalog/web) apply identical filters independently",
        "verified_speedup": "1.30x",
        "transforms": [
          "dimension_cte_isolate + prefetch_fact_join"
        ],
        "winning_transform": "dimension_cte_isolate + prefetch_fact_join",
        "principle": "Shared Dimension Extraction: when multiple channel CTEs (store/catalog/web) apply identical dimension filters, extract those shared filters into one CTE and reference it from each channel. Avoids redundant dimension scans.",
        "key_insight": "Principle: Shared Dimension Extraction \u2014 when multiple channel CTEs (store/catalog/web) apply identical dimension filters, extract those shared filters into common dimension CTEs and reference them from each channel. This eliminates redundant dimension scans across channels. Here: shared date, item, and promotion filters extracted once, then pre-joined with each channel's fact table. Only apply where join structure is straightforward.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "single_pass_aggregation",
      "tags": [
        "aggregate",
        "between",
        "case",
        "independent_sub",
        "reason",
        "repeat:store_sales:15",
        "repeated_scan",
        "self_join",
        "store_sales",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Single Pass Aggregation",
        "description": "Consolidate multiple subqueries scanning the same table into a single CTE with conditional aggregates",
        "verified_speedup": "4.47x",
        "transforms": [
          "consolidate repeated scans"
        ],
        "winning_transform": "consolidate repeated scans",
        "principle": "Single-Pass Aggregation: consolidate multiple scalar subqueries on the same table into one CTE using CASE expressions inside aggregate functions. Reduces N separate table scans to 1 pass.",
        "key_insight": "Principle: Single-Pass Aggregation \u2014 consolidate multiple scalar subqueries on the same table into a single CTE using CASE expressions inside aggregate functions. Each CASE routes rows to the appropriate bucket without multiple scans. Reduces N separate table scans to 1 pass. Here: 15 scalar subqueries on store_sales (5 quantity ranges x 3 aggregates each) become one CTE with conditional COUNT/AVG.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "union_cte_split",
      "tags": [
        "aggregate",
        "case",
        "cte",
        "cte_filtered",
        "customer",
        "date_dim",
        "group_by",
        "in",
        "join",
        "multi_channel",
        "order_by",
        "repeat:customer:2",
        "repeat:date_dim:2",
        "repeat:year_total:4",
        "repeated_scan",
        "self_join",
        "store_sales",
        "union",
        "web_sales",
        "year_total"
      ],
      "category": "scan_consolidation",
      "engine": "duckdb",
      "type": "gold",
      "metadata": {
        "name": "Union CTE Split/Specialization",
        "description": "Split a generic UNION ALL CTE into specialized CTEs when the main query filters by year or discriminator - eliminates redundant scans",
        "verified_speedup": "1.36x",
        "transforms": [
          "union_cte_split: cte with union all is scanned twice with different year filters - split into year-specific ctes"
        ],
        "winning_transform": "union_cte_split: cte with union all is scanned twice with different year filters - split into year-specific ctes",
        "principle": "CTE Specialization: when a generic CTE is scanned multiple times with different filters (e.g., by year), split it into specialized CTEs that embed the filter in their definition. Each specialized CTE processes only its relevant subset, eliminating redundant scans.",
        "key_insight": "Principle: CTE Specialization \u2014 when a generic CTE is scanned multiple times with different filters (e.g., by year), split it into specialized CTEs that embed the filter in their definition. Each specialized CTE processes only its relevant subset, eliminating redundant scans and post-hoc filtering. Here: generic wswscs CTE scanned twice with year filters becomes wswscs_1998 and wswscs_1999, each joining date_dim once during aggregation.",
        "engine": "duckdb",
        "type": "gold"
      }
    },
    {
      "id": "pg_date_cte_explicit_join",
      "tags": [
        "aggregate",
        "between",
        "call_center",
        "case",
        "catalog_sales",
        "date_dim",
        "group_by",
        "join",
        "order_by",
        "ship_mode",
        "star_join_pattern",
        "warehouse"
      ],
      "category": "aggregation_rewrite",
      "engine": "postgres",
      "type": "gold",
      "metadata": {
        "name": "Date CTE with Explicit JOIN Conversion (PostgreSQL)",
        "description": "Isolate a selective date_dim filter into a CTE AND convert all comma-separated joins to explicit JOIN syntax. The combination is key on PostgreSQL - the CTE alone can hurt, but CTE + explicit JOINs together enable better hash join planning with a tiny probe table.",
        "verified_speedup": "2.28x",
        "transforms": [
          "date_cte_explicit_join"
        ],
        "winning_transform": "date_cte_explicit_join",
        "principle": "Dimension Isolation + Explicit Joins: materialize selective dimension filters into CTEs to create tiny hash tables, AND convert comma-separated joins to explicit JOIN syntax. On PostgreSQL, the combination enables better hash join planning with a tiny probe table.",
        "key_insight": "Principle: Dimension Isolation + Explicit Joins \u2014 materialize selective dimension filters into CTEs to create tiny hash tables, AND convert comma joins to explicit JOIN syntax. On PostgreSQL, both are required: the CTE reduces probe size, while explicit JOINs give the optimizer join-order freedom. Here: date_dim (730 from 73K rows) becomes a CTE hash table that catalog_sales probes; comma joins converted to explicit INNER JOIN.",
        "engine": "postgres",
        "type": "gold"
      }
    },
    {
      "id": "pg_dimension_prefetch_star",
      "tags": [
        "aggregate",
        "between",
        "catalog_page",
        "catalog_returns",
        "catalog_sales",
        "csr",
        "cte",
        "cte_filtered",
        "date_dim",
        "group_by",
        "in",
        "independent_sub",
        "item",
        "join",
        "left_join",
        "materialize",
        "multi_channel",
        "multi_cte",
        "order_by",
        "outer_join",
        "promotion",
        "repeat:date_dim:3",
        "repeat:item:3",
        "repeat:promotion:3",
        "repeated_scan",
        "rollup",
        "self_join",
        "ssr",
        "star_join_pattern",
        "store",
        "store_returns",
        "store_sales",
        "sub_nesting_depth:1",
        "subquery",
        "union",
        "web_returns",
        "web_sales",
        "web_site",
        "wsr"
      ],
      "category": "aggregation_rewrite",
      "engine": "postgres",
      "type": "gold",
      "metadata": {
        "name": "Dimension Pre-filter with Explicit JOINs (PostgreSQL)",
        "description": "On multi-channel UNION queries with comma-separated implicit joins, pre-filter dimension tables (date, item, promotion) into CTEs and convert to explicit JOIN syntax. PostgreSQL's optimizer gets better cardinality estimates and join ordering from explicit JOINs with pre-materialized small dimension results.",
        "verified_speedup": "3.32x",
        "transforms": [
          "dimension_prefetch_star"
        ],
        "winning_transform": "dimension_prefetch_star",
        "principle": "Multi-Dimension Prefetch (PG): pre-filter all selective dimensions into CTEs to create tiny hash tables, combined with explicit JOIN syntax. PostgreSQL's optimizer gets better cardinality estimates from pre-materialized small dimension results.",
        "key_insight": "Principle: Multi-Dimension Prefetch (PG) \u2014 pre-filter all selective dimensions into CTEs to create tiny hash tables, combined with explicit JOIN syntax for PostgreSQL optimizer join-order freedom. Even partial transformation helps when one branch dominates runtime. Here: date (30/73K), item (2 categories), promotion (5 filters) all become CTEs; comma joins converted to INNER JOIN.",
        "engine": "postgres",
        "type": "gold"
      }
    },
    {
      "id": "early_filter_decorrelate",
      "tags": [
        "aggregate",
        "between",
        "correlated_sub",
        "correlated_subquery",
        "cte",
        "cte_filtered",
        "customer",
        "customer_demographics",
        "customer_total_return",
        "date_dim",
        "group_by",
        "in",
        "join",
        "order_by",
        "repeat:customer_total_return:2",
        "self_join",
        "star_join_pattern",
        "store",
        "store_returns",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "postgres",
      "type": "gold",
      "metadata": {
        "name": "Early Filter + Decorrelate",
        "description": "",
        "verified_speedup": "1.13x",
        "transforms": [],
        "winning_transform": "",
        "principle": "Early Selection + Decorrelation: push dimension filters into CTE definitions before materialization, and decorrelate correlated subqueries by pre-computing thresholds in separate CTEs. Filters reduce rows early; decorrelation replaces per-row subquery execution with a single pre-computed JOIN.",
        "key_insight": "",
        "engine": "postgres",
        "type": "gold"
      }
    },
    {
      "id": "inline_decorrelate_materialized",
      "tags": [
        "aggregate",
        "between",
        "catalog_sales",
        "date_dim",
        "in",
        "independent_sub",
        "item",
        "join",
        "or_branch_count:2",
        "or_cross_col",
        "or_predicate",
        "order_by",
        "repeat:catalog_sales:2",
        "repeat:date_dim:2",
        "self_join",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "scan_consolidation",
      "engine": "postgres",
      "type": "gold",
      "metadata": {
        "name": "Inline Correlated Subquery to Materialized CTEs",
        "description": "",
        "verified_speedup": "timeout_rescue",
        "transforms": [],
        "winning_transform": "",
        "principle": "Inline Decorrelation with MATERIALIZED CTEs: When a WHERE clause contains a correlated scalar subquery (e.g., col > (SELECT 1.3 * avg(col) FROM ... WHERE correlated_key = outer.key)), PostgreSQL re-executes the subquery per outer row. Fix: decompose into 3 MATERIALIZED CTEs \u2014 (1) pre-filter dimension table, (2) pre-filter fact table by date range, (3) compute per-key aggregate threshold from filtered data \u2014 then JOIN the threshold CTE in the final query. MATERIALIZED keyword prevents PG from inlining the CTEs back into correlated form.",
        "key_insight": "",
        "engine": "postgres",
        "type": "gold"
      }
    },
    {
      "id": "pg_materialized_dimension_fact_prefilter",
      "tags": [
        "aggregate",
        "between",
        "case",
        "catalog_returns",
        "catalog_sales",
        "customer_demographics",
        "date_dim",
        "group_by",
        "household_demographics",
        "in",
        "inventory",
        "item",
        "join",
        "left_join",
        "materialize",
        "order_by",
        "outer_join",
        "promotion",
        "repeat:date_dim:3",
        "repeated_scan",
        "self_join",
        "star_join_pattern",
        "warehouse"
      ],
      "category": "scan_consolidation",
      "engine": "postgres",
      "type": "gold",
      "metadata": {
        "name": "MATERIALIZED Dimension + Fact Pre-filter (PostgreSQL)",
        "description": "Pre-filter ALL dimension tables AND the fact table into MATERIALIZED CTEs, then join with explicit JOIN syntax. On queries with expensive non-equi joins (inventory quantity < sales quantity, week_seq correlation), reducing both dimension AND fact table sizes before the join dramatically cuts the search space. The MATERIALIZED keyword on PG12+ forces early execution of each CTE.",
        "verified_speedup": "2.68x",
        "transforms": [
          "materialized_dimension_fact_prefilter"
        ],
        "winning_transform": "materialized_dimension_fact_prefilter",
        "principle": "Staged Reduction for Non-Equi Joins: when queries have expensive non-equi joins, reduce BOTH dimension and fact table sizes via MATERIALIZED CTEs before the join. Combined selectivity dramatically cuts the search space for inequality predicates.",
        "key_insight": "Principle: Staged Reduction for Non-Equi Joins \u2014 when queries have expensive non-equi joins, reduce BOTH dimension and fact table sizes via MATERIALIZED CTEs before the join to shrink the search space. MATERIALIZED on PG12+ forces early execution. Here: fact table CTE removes ~70% of catalog_sales rows, dimension CTEs reduce date (365/73K), item (3 categories), and demographics to tiny sets \u2014 all before the expensive inventory non-equi join.",
        "engine": "postgres",
        "type": "gold"
      }
    },
    {
      "id": "pg_self_join_decomposition",
      "tags": [
        "aggregate",
        "between",
        "date_dim",
        "group_by",
        "in",
        "independent_sub",
        "item",
        "join",
        "materialize",
        "order_by",
        "repeat:date_dim:2",
        "repeat:store_sales:2",
        "self_join",
        "star_join_pattern",
        "store",
        "store_sales",
        "sub_nesting_depth:2",
        "subquery"
      ],
      "category": "scan_consolidation",
      "engine": "postgres",
      "type": "gold",
      "metadata": {
        "name": "Self-Join Decomposition (PostgreSQL)",
        "description": "Eliminate duplicate fact table scans in self-join patterns by computing the aggregation ONCE in a CTE and deriving both per-item and per-store averages from the same materialized result. PostgreSQL materializes CTEs by default, making this extremely effective.",
        "verified_speedup": "3.93x",
        "transforms": [
          "self_join_decomposition"
        ],
        "winning_transform": "self_join_decomposition",
        "principle": "Shared Materialization (PG): when the same fact+dimension scan appears multiple times in self-join patterns, materialize it once as a CTE and derive all needed aggregates from the same result. PostgreSQL materializes CTEs by default, making this extremely effective.",
        "key_insight": "Principle: Shared Materialization (PG) \u2014 when the same fact+dimension scan appears multiple times, materialize it once as a CTE and reference it from each consumer. PostgreSQL CTE materialization guarantees single execution. Here: store_sales+date_dim scanned twice with identical predicates becomes one materialized CTE, reused for both per-item revenue and per-store averages. Combined with dimension pre-filtering to reduce I/O.",
        "engine": "postgres",
        "type": "gold"
      }
    },
    {
      "id": "AGGREGATE_PULL_UP_CONSTANTS",
      "tags": [
        "aggregate",
        "group_by",
        "t"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Aggregate Pull Up Constants",
        "description": "Pull up constant GROUP BY keys (SF=100 cited)",
        "verified_speedup": "unknown",
        "transforms": [
          "aggregate_pull_up_constants"
        ],
        "winning_transform": "aggregate_pull_up_constants",
        "principle": "",
        "key_insight": "When a GROUP BY key is constant, avoid unnecessary grouping work or move constant filters earlier.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "AGGREGATE_PUSH_BELOW_JOIN",
      "tags": [
        "aggregate",
        "customers",
        "group_by",
        "join",
        "orders"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Aggregate Push Below Join",
        "description": "Push aggregation below join when only aggregated values are needed\n      from one side, reducing join cardinality.",
        "verified_speedup": "unknown",
        "transforms": [
          "aggregate_push_below_join"
        ],
        "winning_transform": "aggregate_push_below_join",
        "principle": "",
        "key_insight": "Join followed by aggregation where one side contributes only to\n      aggregate, not to grouping.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "ANTI_JOIN_LEFT_JOIN_IS_NULL",
      "tags": [
        "exists",
        "orders",
        "returns"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Anti Join Left Join Is Null",
        "description": "Convert NOT EXISTS to LEFT JOIN with IS NULL check when the optimizer\n      produces better plans for the join-based pattern.",
        "verified_speedup": "unknown",
        "transforms": [
          "anti_join_left_join_is_null"
        ],
        "winning_transform": "anti_join_left_join_is_null",
        "principle": "",
        "key_insight": "When NOT EXISTS produces SubPlan instead of Anti Join. Some query\n      structures work better with explicit LEFT JOIN pattern.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "COALESCE_NULL_PROPAGATION",
      "tags": [
        "products"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Coalesce Null Propagation",
        "description": "Use COALESCE to provide default values and prevent NULL propagation\n      in calculations.",
        "verified_speedup": "unknown",
        "transforms": [
          "coalesce_null_propagation"
        ],
        "winning_transform": "coalesce_null_propagation",
        "principle": "",
        "key_insight": "Arithmetic with potentially NULL values where NULL should be\n      treated as zero or default.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CONSTANT_FOLDING_COLUMN_SIDE",
      "tags": [
        "products"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Constant Folding Column Side",
        "description": "Move calculations to constant side of comparisons to enable index\n      usage. PostgreSQL folds constants but won't rearrange expressions.",
        "verified_speedup": "unknown",
        "transforms": [
          "constant_folding_column_side"
        ],
        "winning_transform": "constant_folding_column_side",
        "principle": "",
        "key_insight": "Arithmetic or function on indexed column in WHERE clause.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CORRELATED_AGGREGATE_TO_LATERAL",
      "tags": [
        "aggregate",
        "correlated_sub",
        "correlated_subquery",
        "customers",
        "orders",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Correlated Aggregate To Lateral",
        "description": "Rewrite scalar subqueries with aggregations to LATERAL joins, enabling\n      the optimizer to select optimal join strategies (hash, merge) rather\n      than being restricted to nested loop execution.",
        "verified_speedup": "unknown",
        "transforms": [
          "correlated_aggregate_to_lateral"
        ],
        "winning_transform": "correlated_aggregate_to_lateral",
        "principle": "",
        "key_insight": "When scalar subqueries contain aggregates (COUNT, SUM, AVG, MAX, MIN)\n      that reference outer query columns.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CORRELATED_SCALAR_TO_LEFT_JOIN",
      "tags": [
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "customers",
        "decorrelate",
        "orders",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Correlated Scalar To Left Join",
        "description": "Convert correlated scalar subqueries in SELECT clause to LEFT JOIN.\n      PostgreSQL executes scalar subqueries as nested loops and cannot \n      decorrelate them automatically, preventing optimal join strategies.",
        "verified_speedup": "unknown",
        "transforms": [
          "correlated_scalar_to_left_join"
        ],
        "winning_transform": "correlated_scalar_to_left_join",
        "principle": "",
        "key_insight": "When a correlated subquery returns a single value and the outer table \n      is large. Look for scalar subqueries in SELECT list referencing outer columns.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CORRELATED_SUBQUERY_TO_WINDOW",
      "tags": [
        "aggregate",
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "employees",
        "repeat:employees:2",
        "self_join",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Correlated Subquery To Window",
        "description": "Rewrite scalar subqueries computing group aggregates to window functions,\n      eliminating correlated execution and enabling single-pass processing.",
        "verified_speedup": "High - single scan vs N scans",
        "transforms": [
          "correlated_subquery_to_window"
        ],
        "winning_transform": "correlated_subquery_to_window",
        "principle": "",
        "key_insight": "Correlated subquery calculates aggregate for current row's group\n      without changing row count.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CORRELATED_WHERE_TO_DERIVED_TABLE",
      "tags": [
        "aggregate",
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "decorrelate",
        "employees",
        "repeat:employees:2",
        "self_join",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Correlated Where To Derived Table",
        "description": "Convert correlated subqueries in WHERE clause to derived table joins\n      when PostgreSQL fails to decorrelate automatically.",
        "verified_speedup": "unknown",
        "transforms": [
          "correlated_where_to_derived_table"
        ],
        "winning_transform": "correlated_where_to_derived_table",
        "principle": "",
        "key_insight": "Queries comparing row values against group aggregates. Common pattern\n      for \"above average\" type queries.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CTE_INLINE_NOT_MATERIALIZED",
      "tags": [
        "cte",
        "cte_unfiltered",
        "data",
        "materialize",
        "pushdown",
        "repeat:data:2",
        "self_join",
        "union",
        "very_large_table"
      ],
      "category": "scan_consolidation",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Cte Inline Not Materialized",
        "description": "Force CTE inlining with NOT MATERIALIZED to enable predicate pushdown\n      when CTE is referenced multiple times but benefits from different\n      filters in each reference.",
        "verified_speedup": "unknown",
        "transforms": [
          "cte_inline_not_materialized"
        ],
        "winning_transform": "cte_inline_not_materialized",
        "principle": "",
        "key_insight": "When CTE is referenced multiple times and each reference has different\n      WHERE conditions that could be pushed down.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CTE_OPTIMIZATION_FENCE_MATERIALIZED",
      "tags": [
        "big_table",
        "cte",
        "cte_unfiltered",
        "expensive_calc",
        "join",
        "materialize",
        "pushdown",
        "repeat:expensive_calc:2",
        "self_join"
      ],
      "category": "scan_consolidation",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Cte Optimization Fence Materialized",
        "description": "Use MATERIALIZED to create optimization fence, preventing predicate\n      pushdown and forcing single evaluation of expensive CTE computation.",
        "verified_speedup": "unknown",
        "transforms": [
          "cte_optimization_fence_materialized"
        ],
        "winning_transform": "cte_optimization_fence_materialized",
        "principle": "",
        "key_insight": "- CTE contains expensive computation that should run once\n      - Need to isolate subquery planning to prevent bad plan choices\n      - Force specific join ordering",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "DSB_NON_EQUI_JOIN_WINDOW",
      "tags": [
        "join",
        "multi_channel",
        "store_sales",
        "web_returns",
        "web_sales",
        "window"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Dsb Non Equi Join Window",
        "description": "Rewrite non-equi joins with temporal ordering into window function\n      patterns for better estimation.",
        "verified_speedup": "unknown",
        "transforms": [
          "dsb_non_equi_join_window"
        ],
        "winning_transform": "dsb_non_equi_join_window",
        "principle": "",
        "key_insight": "DSB Query 101, 102 patterns with range/temporal constraints.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "DSB_PREDICATE_CORRELATION_STATS",
      "tags": [
        "correlated",
        "customer",
        "customer_address",
        "in",
        "independent_sub",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Dsb Predicate Correlation Stats",
        "description": "Create extended statistics for DSB's intentionally correlated\n      predicates that defeat independence assumption.",
        "verified_speedup": "unknown",
        "transforms": [
          "dsb_predicate_correlation_stats"
        ],
        "winning_transform": "dsb_predicate_correlation_stats",
        "principle": "",
        "key_insight": "DSB explicitly introduces cross-table correlations. Create\n      statistics after identifying correlated filter patterns.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "DSB_SELF_JOIN_DECOMPOSITION",
      "tags": [
        "aggregate",
        "group_by",
        "item",
        "join",
        "repeat:item:2",
        "repeat:store_sales:2",
        "self_join",
        "store_sales"
      ],
      "category": "scan_consolidation",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Dsb Self Join Decomposition",
        "description": "Decompose many-to-many self-joins into multiple passes with\n      intermediate materialization for better cardinality estimation.",
        "verified_speedup": "unknown",
        "transforms": [
          "dsb_self_join_decomposition"
        ],
        "winning_transform": "dsb_self_join_decomposition",
        "principle": "",
        "key_insight": "DSB Query 100 pattern: items frequently sold together.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "EXISTS_INSTEAD_OF_COUNT",
      "tags": [
        "aggregate",
        "correlated_sub",
        "correlated_subquery",
        "customers",
        "orders",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Exists Instead Of Count",
        "description": "Replace COUNT(*) > 0 existence checks with EXISTS for early termination.\n      EXISTS stops after finding first match.",
        "verified_speedup": "30-40x faster in many cases",
        "transforms": [
          "exists_instead_of_count"
        ],
        "winning_transform": "exists_instead_of_count",
        "principle": "",
        "key_insight": "Checking if any matching rows exist rather than needing exact count.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "EXISTS_SUBPLAN_TO_SEMI_JOIN",
      "tags": [
        "customers",
        "exists",
        "join",
        "order_items",
        "orders"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Exists Subplan To Semi Join",
        "description": "Restructure EXISTS subqueries to ensure PostgreSQL recognizes semi-join\n      pattern. Moving correlation condition placement can enable semi-join\n      vs SubPlan execution.",
        "verified_speedup": "unknown",
        "transforms": [
          "exists_subplan_to_semi_join"
        ],
        "winning_transform": "exists_subplan_to_semi_join",
        "principle": "",
        "key_insight": "When EXPLAIN shows SubPlan for EXISTS instead of Semi Join. Often\n      triggered by ANSI JOIN syntax inside the EXISTS subquery.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "EXPRESSION_TO_SARGABLE",
      "tags": [
        "orders"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Expression To Sargable",
        "description": "Transform non-sargable predicates (functions on columns) to sargable\n      form enabling index usage.",
        "verified_speedup": "unknown",
        "transforms": [
          "expression_to_sargable"
        ],
        "winning_transform": "expression_to_sargable",
        "principle": "",
        "key_insight": "Functions applied to indexed columns preventing index scan.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "FILTER_INTO_JOIN",
      "tags": [
        "dim",
        "fact",
        "join"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Filter Into Join",
        "description": "Push filters to one side of a join",
        "verified_speedup": "unknown",
        "transforms": [
          "filter_into_join"
        ],
        "winning_transform": "filter_into_join",
        "principle": "",
        "key_insight": "Push selective predicates into the joined table to reduce join input size.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "FILTER_SUB_QUERY_TO_JOIN",
      "tags": [
        "in",
        "independent_sub",
        "sub_nesting_depth:1",
        "subquery",
        "t1",
        "t2"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Filter Subquery to Join",
        "description": "Scalar/IN/EXISTS subquery in WHERE rewritten to JOIN",
        "verified_speedup": "unknown",
        "transforms": [
          "filter_sub_query_to_join"
        ],
        "winning_transform": "filter_sub_query_to_join",
        "principle": "",
        "key_insight": "Rewrite scalar/IN/EXISTS subqueries into joins to enable predicate pushdown and better join planning.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "GROUPING_SETS_INSTEAD_OF_UNION",
      "tags": [
        "aggregate",
        "group_by",
        "grouping",
        "repeat:sales:3",
        "repeated_scan",
        "rollup",
        "sales",
        "self_join",
        "union"
      ],
      "category": "aggregation_rewrite",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Grouping Sets Instead Of Union",
        "description": "Replace multiple GROUP BY queries with UNION ALL using single\n      GROUPING SETS/ROLLUP/CUBE query for multi-level aggregations.",
        "verified_speedup": "unknown",
        "transforms": [
          "grouping_sets_instead_of_union"
        ],
        "winning_transform": "grouping_sets_instead_of_union",
        "principle": "",
        "key_insight": "Reports requiring multiple aggregation levels (subtotals, grand totals).",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "IS_NOT_DISTINCT_FROM_NULL_SAFE",
      "tags": [
        "join",
        "t1",
        "t2"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Is Not Distinct From Null Safe",
        "description": "Use IS NOT DISTINCT FROM for NULL-safe equality comparisons where\n      NULL should equal NULL.",
        "verified_speedup": "unknown",
        "transforms": [
          "is_not_distinct_from_null_safe"
        ],
        "winning_transform": "is_not_distinct_from_null_safe",
        "principle": "",
        "key_insight": "Self-joins or comparisons on nullable columns where NULL=NULL\n      should be TRUE.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "JOIN_ORDER_COLLAPSE_LIMIT",
      "tags": [
        "customers",
        "join",
        "orders",
        "products"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Join Order Collapse Limit",
        "description": "Set join_collapse_limit = 1 to force PostgreSQL to respect explicit\n      JOIN clause ordering instead of reordering for optimization.",
        "verified_speedup": "unknown",
        "transforms": [
          "join_order_collapse_limit"
        ],
        "winning_transform": "join_order_collapse_limit",
        "principle": "",
        "key_insight": "- Optimizer consistently chooses suboptimal join order\n      - Specific knowledge about data distribution optimizer lacks\n      - Complex queries where planning time is excessive",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "LATERAL_FORCE_NESTED_LOOP",
      "tags": [
        "join",
        "large_indexed_table",
        "small_table"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Lateral Force Nested Loop",
        "description": "Use CROSS JOIN LATERAL to force nested loop execution when you know\n      it's optimal (small outer table, indexed inner lookup).",
        "verified_speedup": "unknown",
        "transforms": [
          "lateral_force_nested_loop"
        ],
        "winning_transform": "lateral_force_nested_loop",
        "principle": "",
        "key_insight": "When planner incorrectly chooses hash/merge join but nested loop with\n      parameterized index scan would be faster.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "LIKE_PREFIX_INDEX_USAGE",
      "tags": [
        "like",
        "paths"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Like Prefix Index Usage",
        "description": "Ensure LIKE 'prefix%' uses index by creating text_pattern_ops index\n      for non-C locale databases.",
        "verified_speedup": "unknown",
        "transforms": [
          "like_prefix_index_usage"
        ],
        "winning_transform": "like_prefix_index_usage",
        "principle": "",
        "key_insight": "Prefix searches on text columns in non-C collation databases.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "LIMITED_COUNT_FOR_THRESHOLD",
      "tags": [
        "aggregate",
        "case",
        "orders"
      ],
      "category": "aggregation_rewrite",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Limited Count For Threshold",
        "description": "When checking if count exceeds threshold, use LIMIT to avoid\n      counting all rows.",
        "verified_speedup": "unknown",
        "transforms": [
          "limited_count_for_threshold"
        ],
        "winning_transform": "limited_count_for_threshold",
        "principle": "",
        "key_insight": "Need to know if \"at least N\" rows exist, not exact count.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "NOT_IN_TO_NOT_EXISTS",
      "tags": [
        "blacklist",
        "customers",
        "in",
        "independent_sub",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Not In To Not Exists",
        "description": "PostgreSQL CANNOT automatically transform NOT IN to anti-join due to\n      different NULL semantics. NOT IN with any NULL in subquery returns\n      no rows, while NOT EXISTS handles NULLs correctly and enables anti-join.",
        "verified_speedup": "High - enables Hash Anti Join vs O(N\u00b2) SubPlan",
        "transforms": [
          "not_in_to_not_exists"
        ],
        "winning_transform": "not_in_to_not_exists",
        "principle": "",
        "key_insight": "Always prefer NOT EXISTS over NOT IN for exclusion patterns. Critical\n      for correctness when subquery may contain NULLs.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "OR_TO_UNION_ALL",
      "tags": [
        "or_branch_count:2",
        "or_cross_col",
        "or_predicate",
        "orders"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Or To Union All",
        "description": "Rewrite OR conditions to UNION ALL when OR prevents efficient index\n      usage, especially in JOIN contexts.",
        "verified_speedup": "unknown",
        "transforms": [
          "or_to_union_all"
        ],
        "winning_transform": "or_to_union_all",
        "principle": "",
        "key_insight": "OR conditions span different columns with separate indexes.\n      Ensure result sets are mutually exclusive for UNION ALL.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "PARTITION_PRUNING_PREDICATE",
      "tags": [
        "sales"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Partition Pruning Predicate",
        "description": "Rewrite predicates to enable partition pruning by using direct\n      comparisons on partition key columns.",
        "verified_speedup": "unknown",
        "transforms": [
          "partition_pruning_predicate"
        ],
        "winning_transform": "partition_pruning_predicate",
        "principle": "",
        "key_insight": "Partitioned tables where pruning isn't occurring due to\n      functions/expressions on partition key.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "REDUNDANT_JOIN_ELIMINATION",
      "tags": [
        "customers",
        "join",
        "orders"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Redundant Join Elimination",
        "description": "Remove unnecessary joins to parent tables when only the foreign key\n      is used from the joined table and the FK is NOT NULL. PostgreSQL\n      does not automatically eliminate these (unlike Oracle/DB2).",
        "verified_speedup": "unknown",
        "transforms": [
          "redundant_join_elimination"
        ],
        "winning_transform": "redundant_join_elimination",
        "principle": "",
        "key_insight": "When only FK column is selected from joined table and FK has NOT NULL\n      constraint ensuring all rows match.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "SELF_JOIN_TO_WINDOW",
      "tags": [
        "aggregate",
        "employees",
        "group_by",
        "independent_sub",
        "join",
        "repeat:employees:2",
        "self_join",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "scan_consolidation",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Self Join To Window",
        "description": "Replace self-joins used to access group-level values with window\n      functions, eliminating the join entirely.",
        "verified_speedup": "unknown",
        "transforms": [
          "self_join_to_window"
        ],
        "winning_transform": "self_join_to_window",
        "principle": "",
        "key_insight": "Self-join retrieves aggregate values or rankings within a group.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "STAR_SCHEMA_DIMENSION_FILTER_FIRST",
      "tags": [
        "dim_date",
        "dim_product",
        "fact_sales",
        "join"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Star Schema Dimension Filter First",
        "description": "Restructure star schema queries to filter dimension tables first\n      using optimization barriers, then join filtered results to fact table.",
        "verified_speedup": "unknown",
        "transforms": [
          "star_schema_dimension_filter_first"
        ],
        "winning_transform": "star_schema_dimension_filter_first",
        "principle": "",
        "key_insight": "Star schema queries with selective dimension filters where optimizer\n      scans fact table first instead of filtering dimensions.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "SUBQUERY_OFFSET_ZERO_BARRIER",
      "tags": [
        "dim_table",
        "fact_table",
        "independent_sub",
        "join",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Subquery Offset Zero Barrier",
        "description": "Add OFFSET 0 to subquery to create optimization barrier preventing\n      subquery pull-up, forcing materialization and specific execution order.",
        "verified_speedup": "unknown",
        "transforms": [
          "subquery_offset_zero_barrier"
        ],
        "winning_transform": "subquery_offset_zero_barrier",
        "principle": "",
        "key_insight": "- Force specific join order without global setting changes\n      - Subquery results should compute before joining\n      - Debug plans by isolating subquery execution",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "TOP_N_PER_GROUP_DISTINCT_ON",
      "tags": [
        "independent_sub",
        "order_by",
        "orders",
        "row_number",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Top N Per Group Distinct On",
        "description": "Use PostgreSQL's DISTINCT ON for \"top-1-per-group\" instead of\n      ROW_NUMBER() window function.  More concise and often faster.",
        "verified_speedup": "unknown",
        "transforms": [
          "top_n_per_group_distinct_on"
        ],
        "winning_transform": "top_n_per_group_distinct_on",
        "principle": "",
        "key_insight": "Retrieving exactly one row per group based on ordering.\n      PostgreSQL-specific extension.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "TOP_N_PER_GROUP_ROW_NUMBER",
      "tags": [
        "aggregate",
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "items",
        "repeat:items:2",
        "self_join",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Top N Per Group Row Number",
        "description": "Use ROW_NUMBER() window function instead of correlated subquery\n      COUNT for top-N-per-group patterns.",
        "verified_speedup": "unknown",
        "transforms": [
          "top_n_per_group_row_number"
        ],
        "winning_transform": "top_n_per_group_row_number",
        "principle": "",
        "key_insight": "Retrieving multiple rows per group based on ranking.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "TOP_N_PER_GROUP_TO_LATERAL",
      "tags": [
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "customers",
        "order_by",
        "orders",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Top N Per Group To Lateral",
        "description": "Convert correlated subqueries for \"top N per group\" to LATERAL joins\n      with LIMIT, enabling index-only scans per group instead of window\n      functions over entire dataset.",
        "verified_speedup": "unknown",
        "transforms": [
          "top_n_per_group_to_lateral"
        ],
        "winning_transform": "top_n_per_group_to_lateral",
        "principle": "",
        "key_insight": "Finding top N rows per group where an appropriate index exists on\n      (group_key, sort_column). Especially effective when N is small.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "UNION_TO_UNION_ALL",
      "tags": [
        "active_users",
        "repeat:active_users:2",
        "self_join",
        "union"
      ],
      "category": "scan_consolidation",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Union To Union All",
        "description": "Replace UNION with UNION ALL when duplicate elimination is unnecessary,\n      avoiding expensive sort/hash operations.",
        "verified_speedup": "unknown",
        "transforms": [
          "union_to_union_all"
        ],
        "winning_transform": "union_to_union_all",
        "principle": "",
        "key_insight": "Result sets are provably disjoint or duplicates are acceptable.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "WINDOW_SORT_ALIGNMENT",
      "tags": [
        "aggregate",
        "order_by",
        "transactions",
        "window"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Window Sort Alignment",
        "description": "Align window function ORDER BY clauses to minimize sorts when\n      multiple window functions are used in same query.",
        "verified_speedup": "unknown",
        "transforms": [
          "window_sort_alignment"
        ],
        "winning_transform": "window_sort_alignment",
        "principle": "",
        "key_insight": "Queries with multiple window functions using different orderings.\n      Group windows with same sort together.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "AGGREGATE_PULL_UP_CONSTANTS",
      "tags": [
        "aggregate",
        "group_by",
        "t"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Aggregate Pull Up Constants",
        "description": "Pull up constant GROUP BY keys (SF=100 cited)",
        "verified_speedup": "unknown",
        "transforms": [
          "aggregate_pull_up_constants"
        ],
        "winning_transform": "aggregate_pull_up_constants",
        "principle": "",
        "key_insight": "When a GROUP BY key is constant, avoid unnecessary grouping work or move constant filters earlier.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "AGGREGATE_PUSH_BELOW_JOIN",
      "tags": [
        "aggregate",
        "customers",
        "group_by",
        "join",
        "orders"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Aggregate Push Below Join",
        "description": "Push aggregation below join when only aggregated values are needed\n      from one side, reducing join cardinality.",
        "verified_speedup": "unknown",
        "transforms": [
          "aggregate_push_below_join"
        ],
        "winning_transform": "aggregate_push_below_join",
        "principle": "",
        "key_insight": "Join followed by aggregation where one side contributes only to\n      aggregate, not to grouping.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "ANTI_JOIN_LEFT_JOIN_IS_NULL",
      "tags": [
        "exists",
        "orders",
        "returns"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Anti Join Left Join Is Null",
        "description": "Convert NOT EXISTS to LEFT JOIN with IS NULL check when the optimizer\n      produces better plans for the join-based pattern.",
        "verified_speedup": "unknown",
        "transforms": [
          "anti_join_left_join_is_null"
        ],
        "winning_transform": "anti_join_left_join_is_null",
        "principle": "",
        "key_insight": "When NOT EXISTS produces SubPlan instead of Anti Join. Some query\n      structures work better with explicit LEFT JOIN pattern.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "COALESCE_NULL_PROPAGATION",
      "tags": [
        "products"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Coalesce Null Propagation",
        "description": "Use COALESCE to provide default values and prevent NULL propagation\n      in calculations.",
        "verified_speedup": "unknown",
        "transforms": [
          "coalesce_null_propagation"
        ],
        "winning_transform": "coalesce_null_propagation",
        "principle": "",
        "key_insight": "Arithmetic with potentially NULL values where NULL should be\n      treated as zero or default.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CONSTANT_FOLDING_COLUMN_SIDE",
      "tags": [
        "products"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Constant Folding Column Side",
        "description": "Move calculations to constant side of comparisons to enable index\n      usage. PostgreSQL folds constants but won't rearrange expressions.",
        "verified_speedup": "unknown",
        "transforms": [
          "constant_folding_column_side"
        ],
        "winning_transform": "constant_folding_column_side",
        "principle": "",
        "key_insight": "Arithmetic or function on indexed column in WHERE clause.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CORRELATED_AGGREGATE_TO_LATERAL",
      "tags": [
        "aggregate",
        "correlated_sub",
        "correlated_subquery",
        "customers",
        "orders",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Correlated Aggregate To Lateral",
        "description": "Rewrite scalar subqueries with aggregations to LATERAL joins, enabling\n      the optimizer to select optimal join strategies (hash, merge) rather\n      than being restricted to nested loop execution.",
        "verified_speedup": "unknown",
        "transforms": [
          "correlated_aggregate_to_lateral"
        ],
        "winning_transform": "correlated_aggregate_to_lateral",
        "principle": "",
        "key_insight": "When scalar subqueries contain aggregates (COUNT, SUM, AVG, MAX, MIN)\n      that reference outer query columns.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CORRELATED_SCALAR_TO_LEFT_JOIN",
      "tags": [
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "customers",
        "decorrelate",
        "orders",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Correlated Scalar To Left Join",
        "description": "Convert correlated scalar subqueries in SELECT clause to LEFT JOIN.\n      PostgreSQL executes scalar subqueries as nested loops and cannot \n      decorrelate them automatically, preventing optimal join strategies.",
        "verified_speedup": "unknown",
        "transforms": [
          "correlated_scalar_to_left_join"
        ],
        "winning_transform": "correlated_scalar_to_left_join",
        "principle": "",
        "key_insight": "When a correlated subquery returns a single value and the outer table \n      is large. Look for scalar subqueries in SELECT list referencing outer columns.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CORRELATED_SUBQUERY_TO_WINDOW",
      "tags": [
        "aggregate",
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "employees",
        "repeat:employees:2",
        "self_join",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Correlated Subquery To Window",
        "description": "Rewrite scalar subqueries computing group aggregates to window functions,\n      eliminating correlated execution and enabling single-pass processing.",
        "verified_speedup": "High - single scan vs N scans",
        "transforms": [
          "correlated_subquery_to_window"
        ],
        "winning_transform": "correlated_subquery_to_window",
        "principle": "",
        "key_insight": "Correlated subquery calculates aggregate for current row's group\n      without changing row count.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CORRELATED_WHERE_TO_DERIVED_TABLE",
      "tags": [
        "aggregate",
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "decorrelate",
        "employees",
        "repeat:employees:2",
        "self_join",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Correlated Where To Derived Table",
        "description": "Convert correlated subqueries in WHERE clause to derived table joins\n      when PostgreSQL fails to decorrelate automatically.",
        "verified_speedup": "unknown",
        "transforms": [
          "correlated_where_to_derived_table"
        ],
        "winning_transform": "correlated_where_to_derived_table",
        "principle": "",
        "key_insight": "Queries comparing row values against group aggregates. Common pattern\n      for \"above average\" type queries.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CTE_INLINE_NOT_MATERIALIZED",
      "tags": [
        "cte",
        "cte_unfiltered",
        "data",
        "materialize",
        "pushdown",
        "repeat:data:2",
        "self_join",
        "union",
        "very_large_table"
      ],
      "category": "scan_consolidation",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Cte Inline Not Materialized",
        "description": "Force CTE inlining with NOT MATERIALIZED to enable predicate pushdown\n      when CTE is referenced multiple times but benefits from different\n      filters in each reference.",
        "verified_speedup": "unknown",
        "transforms": [
          "cte_inline_not_materialized"
        ],
        "winning_transform": "cte_inline_not_materialized",
        "principle": "",
        "key_insight": "When CTE is referenced multiple times and each reference has different\n      WHERE conditions that could be pushed down.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "CTE_OPTIMIZATION_FENCE_MATERIALIZED",
      "tags": [
        "big_table",
        "cte",
        "cte_unfiltered",
        "expensive_calc",
        "join",
        "materialize",
        "pushdown",
        "repeat:expensive_calc:2",
        "self_join"
      ],
      "category": "scan_consolidation",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Cte Optimization Fence Materialized",
        "description": "Use MATERIALIZED to create optimization fence, preventing predicate\n      pushdown and forcing single evaluation of expensive CTE computation.",
        "verified_speedup": "unknown",
        "transforms": [
          "cte_optimization_fence_materialized"
        ],
        "winning_transform": "cte_optimization_fence_materialized",
        "principle": "",
        "key_insight": "- CTE contains expensive computation that should run once\n      - Need to isolate subquery planning to prevent bad plan choices\n      - Force specific join ordering",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "DSB_NON_EQUI_JOIN_WINDOW",
      "tags": [
        "join",
        "multi_channel",
        "store_sales",
        "web_returns",
        "web_sales",
        "window"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Dsb Non Equi Join Window",
        "description": "Rewrite non-equi joins with temporal ordering into window function\n      patterns for better estimation.",
        "verified_speedup": "unknown",
        "transforms": [
          "dsb_non_equi_join_window"
        ],
        "winning_transform": "dsb_non_equi_join_window",
        "principle": "",
        "key_insight": "DSB Query 101, 102 patterns with range/temporal constraints.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "DSB_PREDICATE_CORRELATION_STATS",
      "tags": [
        "correlated",
        "customer",
        "customer_address",
        "in",
        "independent_sub",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Dsb Predicate Correlation Stats",
        "description": "Create extended statistics for DSB's intentionally correlated\n      predicates that defeat independence assumption.",
        "verified_speedup": "unknown",
        "transforms": [
          "dsb_predicate_correlation_stats"
        ],
        "winning_transform": "dsb_predicate_correlation_stats",
        "principle": "",
        "key_insight": "DSB explicitly introduces cross-table correlations. Create\n      statistics after identifying correlated filter patterns.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "DSB_SELF_JOIN_DECOMPOSITION",
      "tags": [
        "aggregate",
        "group_by",
        "item",
        "join",
        "repeat:item:2",
        "repeat:store_sales:2",
        "self_join",
        "store_sales"
      ],
      "category": "scan_consolidation",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Dsb Self Join Decomposition",
        "description": "Decompose many-to-many self-joins into multiple passes with\n      intermediate materialization for better cardinality estimation.",
        "verified_speedup": "unknown",
        "transforms": [
          "dsb_self_join_decomposition"
        ],
        "winning_transform": "dsb_self_join_decomposition",
        "principle": "",
        "key_insight": "DSB Query 100 pattern: items frequently sold together.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "EXISTS_INSTEAD_OF_COUNT",
      "tags": [
        "aggregate",
        "correlated_sub",
        "correlated_subquery",
        "customers",
        "orders",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Exists Instead Of Count",
        "description": "Replace COUNT(*) > 0 existence checks with EXISTS for early termination.\n      EXISTS stops after finding first match.",
        "verified_speedup": "30-40x faster in many cases",
        "transforms": [
          "exists_instead_of_count"
        ],
        "winning_transform": "exists_instead_of_count",
        "principle": "",
        "key_insight": "Checking if any matching rows exist rather than needing exact count.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "EXISTS_SUBPLAN_TO_SEMI_JOIN",
      "tags": [
        "customers",
        "exists",
        "join",
        "order_items",
        "orders"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Exists Subplan To Semi Join",
        "description": "Restructure EXISTS subqueries to ensure PostgreSQL recognizes semi-join\n      pattern. Moving correlation condition placement can enable semi-join\n      vs SubPlan execution.",
        "verified_speedup": "unknown",
        "transforms": [
          "exists_subplan_to_semi_join"
        ],
        "winning_transform": "exists_subplan_to_semi_join",
        "principle": "",
        "key_insight": "When EXPLAIN shows SubPlan for EXISTS instead of Semi Join. Often\n      triggered by ANSI JOIN syntax inside the EXISTS subquery.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "EXPRESSION_TO_SARGABLE",
      "tags": [
        "orders"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Expression To Sargable",
        "description": "Transform non-sargable predicates (functions on columns) to sargable\n      form enabling index usage.",
        "verified_speedup": "unknown",
        "transforms": [
          "expression_to_sargable"
        ],
        "winning_transform": "expression_to_sargable",
        "principle": "",
        "key_insight": "Functions applied to indexed columns preventing index scan.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "FILTER_INTO_JOIN",
      "tags": [
        "dim",
        "fact",
        "join"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Filter Into Join",
        "description": "Push filters to one side of a join",
        "verified_speedup": "unknown",
        "transforms": [
          "filter_into_join"
        ],
        "winning_transform": "filter_into_join",
        "principle": "",
        "key_insight": "Push selective predicates into the joined table to reduce join input size.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "FILTER_SUB_QUERY_TO_JOIN",
      "tags": [
        "in",
        "independent_sub",
        "sub_nesting_depth:1",
        "subquery",
        "t1",
        "t2"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Filter Subquery to Join",
        "description": "Scalar/IN/EXISTS subquery in WHERE rewritten to JOIN",
        "verified_speedup": "unknown",
        "transforms": [
          "filter_sub_query_to_join"
        ],
        "winning_transform": "filter_sub_query_to_join",
        "principle": "",
        "key_insight": "Rewrite scalar/IN/EXISTS subqueries into joins to enable predicate pushdown and better join planning.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "GROUPING_SETS_INSTEAD_OF_UNION",
      "tags": [
        "aggregate",
        "group_by",
        "grouping",
        "repeat:sales:3",
        "repeated_scan",
        "rollup",
        "sales",
        "self_join",
        "union"
      ],
      "category": "aggregation_rewrite",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Grouping Sets Instead Of Union",
        "description": "Replace multiple GROUP BY queries with UNION ALL using single\n      GROUPING SETS/ROLLUP/CUBE query for multi-level aggregations.",
        "verified_speedup": "unknown",
        "transforms": [
          "grouping_sets_instead_of_union"
        ],
        "winning_transform": "grouping_sets_instead_of_union",
        "principle": "",
        "key_insight": "Reports requiring multiple aggregation levels (subtotals, grand totals).",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "IS_NOT_DISTINCT_FROM_NULL_SAFE",
      "tags": [
        "join",
        "t1",
        "t2"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Is Not Distinct From Null Safe",
        "description": "Use IS NOT DISTINCT FROM for NULL-safe equality comparisons where\n      NULL should equal NULL.",
        "verified_speedup": "unknown",
        "transforms": [
          "is_not_distinct_from_null_safe"
        ],
        "winning_transform": "is_not_distinct_from_null_safe",
        "principle": "",
        "key_insight": "Self-joins or comparisons on nullable columns where NULL=NULL\n      should be TRUE.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "JOIN_ORDER_COLLAPSE_LIMIT",
      "tags": [
        "customers",
        "join",
        "orders",
        "products"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Join Order Collapse Limit",
        "description": "Set join_collapse_limit = 1 to force PostgreSQL to respect explicit\n      JOIN clause ordering instead of reordering for optimization.",
        "verified_speedup": "unknown",
        "transforms": [
          "join_order_collapse_limit"
        ],
        "winning_transform": "join_order_collapse_limit",
        "principle": "",
        "key_insight": "- Optimizer consistently chooses suboptimal join order\n      - Specific knowledge about data distribution optimizer lacks\n      - Complex queries where planning time is excessive",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "LATERAL_FORCE_NESTED_LOOP",
      "tags": [
        "join",
        "large_indexed_table",
        "small_table"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Lateral Force Nested Loop",
        "description": "Use CROSS JOIN LATERAL to force nested loop execution when you know\n      it's optimal (small outer table, indexed inner lookup).",
        "verified_speedup": "unknown",
        "transforms": [
          "lateral_force_nested_loop"
        ],
        "winning_transform": "lateral_force_nested_loop",
        "principle": "",
        "key_insight": "When planner incorrectly chooses hash/merge join but nested loop with\n      parameterized index scan would be faster.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "LIKE_PREFIX_INDEX_USAGE",
      "tags": [
        "like",
        "paths"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Like Prefix Index Usage",
        "description": "Ensure LIKE 'prefix%' uses index by creating text_pattern_ops index\n      for non-C locale databases.",
        "verified_speedup": "unknown",
        "transforms": [
          "like_prefix_index_usage"
        ],
        "winning_transform": "like_prefix_index_usage",
        "principle": "",
        "key_insight": "Prefix searches on text columns in non-C collation databases.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "LIMITED_COUNT_FOR_THRESHOLD",
      "tags": [
        "aggregate",
        "case",
        "orders"
      ],
      "category": "aggregation_rewrite",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Limited Count For Threshold",
        "description": "When checking if count exceeds threshold, use LIMIT to avoid\n      counting all rows.",
        "verified_speedup": "unknown",
        "transforms": [
          "limited_count_for_threshold"
        ],
        "winning_transform": "limited_count_for_threshold",
        "principle": "",
        "key_insight": "Need to know if \"at least N\" rows exist, not exact count.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "NOT_IN_TO_NOT_EXISTS",
      "tags": [
        "blacklist",
        "customers",
        "in",
        "independent_sub",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Not In To Not Exists",
        "description": "PostgreSQL CANNOT automatically transform NOT IN to anti-join due to\n      different NULL semantics. NOT IN with any NULL in subquery returns\n      no rows, while NOT EXISTS handles NULLs correctly and enables anti-join.",
        "verified_speedup": "High - enables Hash Anti Join vs O(N\u00b2) SubPlan",
        "transforms": [
          "not_in_to_not_exists"
        ],
        "winning_transform": "not_in_to_not_exists",
        "principle": "",
        "key_insight": "Always prefer NOT EXISTS over NOT IN for exclusion patterns. Critical\n      for correctness when subquery may contain NULLs.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "OR_TO_UNION_ALL",
      "tags": [
        "or_branch_count:2",
        "or_cross_col",
        "or_predicate",
        "orders"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Or To Union All",
        "description": "Rewrite OR conditions to UNION ALL when OR prevents efficient index\n      usage, especially in JOIN contexts.",
        "verified_speedup": "unknown",
        "transforms": [
          "or_to_union_all"
        ],
        "winning_transform": "or_to_union_all",
        "principle": "",
        "key_insight": "OR conditions span different columns with separate indexes.\n      Ensure result sets are mutually exclusive for UNION ALL.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "PARTITION_PRUNING_PREDICATE",
      "tags": [
        "sales"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Partition Pruning Predicate",
        "description": "Rewrite predicates to enable partition pruning by using direct\n      comparisons on partition key columns.",
        "verified_speedup": "unknown",
        "transforms": [
          "partition_pruning_predicate"
        ],
        "winning_transform": "partition_pruning_predicate",
        "principle": "",
        "key_insight": "Partitioned tables where pruning isn't occurring due to\n      functions/expressions on partition key.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "REDUNDANT_JOIN_ELIMINATION",
      "tags": [
        "customers",
        "join",
        "orders"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Redundant Join Elimination",
        "description": "Remove unnecessary joins to parent tables when only the foreign key\n      is used from the joined table and the FK is NOT NULL. PostgreSQL\n      does not automatically eliminate these (unlike Oracle/DB2).",
        "verified_speedup": "unknown",
        "transforms": [
          "redundant_join_elimination"
        ],
        "winning_transform": "redundant_join_elimination",
        "principle": "",
        "key_insight": "When only FK column is selected from joined table and FK has NOT NULL\n      constraint ensuring all rows match.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "SELF_JOIN_TO_WINDOW",
      "tags": [
        "aggregate",
        "employees",
        "group_by",
        "independent_sub",
        "join",
        "repeat:employees:2",
        "self_join",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "scan_consolidation",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Self Join To Window",
        "description": "Replace self-joins used to access group-level values with window\n      functions, eliminating the join entirely.",
        "verified_speedup": "unknown",
        "transforms": [
          "self_join_to_window"
        ],
        "winning_transform": "self_join_to_window",
        "principle": "",
        "key_insight": "Self-join retrieves aggregate values or rankings within a group.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "STAR_SCHEMA_DIMENSION_FILTER_FIRST",
      "tags": [
        "dim_date",
        "dim_product",
        "fact_sales",
        "join"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Star Schema Dimension Filter First",
        "description": "Restructure star schema queries to filter dimension tables first\n      using optimization barriers, then join filtered results to fact table.",
        "verified_speedup": "unknown",
        "transforms": [
          "star_schema_dimension_filter_first"
        ],
        "winning_transform": "star_schema_dimension_filter_first",
        "principle": "",
        "key_insight": "Star schema queries with selective dimension filters where optimizer\n      scans fact table first instead of filtering dimensions.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "SUBQUERY_OFFSET_ZERO_BARRIER",
      "tags": [
        "dim_table",
        "fact_table",
        "independent_sub",
        "join",
        "sub_nesting_depth:1",
        "subquery"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Subquery Offset Zero Barrier",
        "description": "Add OFFSET 0 to subquery to create optimization barrier preventing\n      subquery pull-up, forcing materialization and specific execution order.",
        "verified_speedup": "unknown",
        "transforms": [
          "subquery_offset_zero_barrier"
        ],
        "winning_transform": "subquery_offset_zero_barrier",
        "principle": "",
        "key_insight": "- Force specific join order without global setting changes\n      - Subquery results should compute before joining\n      - Debug plans by isolating subquery execution",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "TOP_N_PER_GROUP_DISTINCT_ON",
      "tags": [
        "independent_sub",
        "order_by",
        "orders",
        "row_number",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Top N Per Group Distinct On",
        "description": "Use PostgreSQL's DISTINCT ON for \"top-1-per-group\" instead of\n      ROW_NUMBER() window function.  More concise and often faster.",
        "verified_speedup": "unknown",
        "transforms": [
          "top_n_per_group_distinct_on"
        ],
        "winning_transform": "top_n_per_group_distinct_on",
        "principle": "",
        "key_insight": "Retrieving exactly one row per group based on ordering.\n      PostgreSQL-specific extension.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "TOP_N_PER_GROUP_ROW_NUMBER",
      "tags": [
        "aggregate",
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "items",
        "repeat:items:2",
        "self_join",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Top N Per Group Row Number",
        "description": "Use ROW_NUMBER() window function instead of correlated subquery\n      COUNT for top-N-per-group patterns.",
        "verified_speedup": "unknown",
        "transforms": [
          "top_n_per_group_row_number"
        ],
        "winning_transform": "top_n_per_group_row_number",
        "principle": "",
        "key_insight": "Retrieving multiple rows per group based on ranking.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "TOP_N_PER_GROUP_TO_LATERAL",
      "tags": [
        "correlated",
        "correlated_sub",
        "correlated_subquery",
        "customers",
        "order_by",
        "orders",
        "sub_nesting_depth:1",
        "subquery",
        "window"
      ],
      "category": "subquery_elimination",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Top N Per Group To Lateral",
        "description": "Convert correlated subqueries for \"top N per group\" to LATERAL joins\n      with LIMIT, enabling index-only scans per group instead of window\n      functions over entire dataset.",
        "verified_speedup": "unknown",
        "transforms": [
          "top_n_per_group_to_lateral"
        ],
        "winning_transform": "top_n_per_group_to_lateral",
        "principle": "",
        "key_insight": "Finding top N rows per group where an appropriate index exists on\n      (group_key, sort_column). Especially effective when N is small.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "UNION_TO_UNION_ALL",
      "tags": [
        "active_users",
        "repeat:active_users:2",
        "self_join",
        "union"
      ],
      "category": "scan_consolidation",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Union To Union All",
        "description": "Replace UNION with UNION ALL when duplicate elimination is unnecessary,\n      avoiding expensive sort/hash operations.",
        "verified_speedup": "unknown",
        "transforms": [
          "union_to_union_all"
        ],
        "winning_transform": "union_to_union_all",
        "principle": "",
        "key_insight": "Result sets are provably disjoint or duplicates are acceptable.",
        "engine": "seed",
        "type": "gold"
      }
    },
    {
      "id": "WINDOW_SORT_ALIGNMENT",
      "tags": [
        "aggregate",
        "order_by",
        "transactions",
        "window"
      ],
      "category": "general",
      "engine": "seed",
      "type": "gold",
      "metadata": {
        "name": "Window Sort Alignment",
        "description": "Align window function ORDER BY clauses to minimize sorts when\n      multiple window functions are used in same query.",
        "verified_speedup": "unknown",
        "transforms": [
          "window_sort_alignment"
        ],
        "winning_transform": "window_sort_alignment",
        "principle": "",
        "key_insight": "Queries with multiple window functions using different orderings.\n      Group windows with same sort together.",
        "engine": "seed",
        "type": "gold"
      }
    }
  ]
}