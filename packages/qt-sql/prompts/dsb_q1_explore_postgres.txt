You are an autonomous PostgreSQL Query Rewrite Engine. Your goal is to maximize execution speed while strictly preserving semantic invariants.

## Rules
- Output must return identical rows, columns, and ordering
- We will diff results to validate - any difference = rejection
- Avoid scanning large tables multiple times

## Query-Level Bottlenecks
- Full table scans (missing index usage, non-sargable predicates)
- Sort/Hash spills to disk (large intermediate results)
- Parallel query overhead (unnecessary parallelism on small sets)

## Techniques to Try
- **Window functions**: Replace correlated subqueries with `AVG/SUM(...) OVER (PARTITION BY ...)`
- **Decorrelate**: Convert `WHERE x > (SELECT AVG(...) WHERE correlated)` to JOIN on pre-computed CTE
- **Push filters early**: Move WHERE conditions into CTEs before aggregation
- **Single scan**: Compute multiple aggregates in one pass instead of multiple CTE references

## Original Query
```sql

with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sr_reason_sk as ctr_reason_sk
,sum(SR_REFUNDED_CASH) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2001
and sr_return_amt / sr_return_quantity between 236 and 295
group by sr_customer_sk
,sr_store_sk, sr_reason_sk)
 select  c_customer_id
from customer_total_return ctr1
,store
,customer
,customer_demographics
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk
)
and ctr1.ctr_reason_sk BETWEEN 28 AND 31
and s_store_sk = ctr1.ctr_store_sk
and s_state IN ('MI', 'NC', 'WI')
and ctr1.ctr_customer_sk = c_customer_sk
and c_current_cdemo_sk = cd_demo_sk
and cd_marital_status IN ('W', 'W')
and cd_education_status IN ('4 yr Degree', 'College')
and cd_gender = 'M'
and c_birth_month = 5
and c_birth_year BETWEEN 1950 AND 1956
order by c_customer_id
limit 100;



```

## Execution Plan
```
Limit  (rows=0, time=89.611)
  Aggregate  (rows=73, time=88.36)
    Sort  (rows=73, time=88.326)
      Nested Loop  (rows=73, time=88.227)
        Index Only Scan on date_dim  (rows=365, time=1.187)
        Index Scan on store_returns  (rows=0, time=0.238)
  Sort  (rows=0, time=89.607)
    Nested Loop  (rows=0, time=89.587)
      Nested Loop  (rows=0, time=89.586)
        Nested Loop  (rows=1, time=89.302)
          CTE Scan (ctr1)  (rows=2, time=88.427)
            Aggregate  (rows=1, time=0.013)
              CTE Scan (ctr2)  (rows=3, time=0.009)
          Seq Scan on store  (rows=8, time=0.434)
        Index Scan on customer  (rows=0, time=0.282)
      Index Scan on customer_demographics  (rows=0, time=0.0)
```

## Task
Find the bottleneck in the plan. Rewrite the query to fix it.

Output ONLY the optimized SQL:

```sql

```
