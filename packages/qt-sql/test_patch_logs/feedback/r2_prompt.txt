You are a SQL rewrite engine for PostgreSQL v14.3.
Preserve exact semantic equivalence (same rows, same columns, same ordering).

## Original SQL

```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sr_reason_sk as ctr_reason_sk
,sum(SR_RETURN_AMT_INC_TAX) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2002
and sr_return_amt / sr_return_quantity between 108 and 167
group by sr_customer_sk
,sr_store_sk, sr_reason_sk)
 select  c_customer_id
from customer_total_return ctr1
,store
,customer
,customer_demographics
where ctr1.ctr_total_return > (select avg(ctr_total_return)*1.2
from customer_total_return ctr2
where ctr1.ctr_store_sk = ctr2.ctr_store_sk
)
and ctr1.ctr_reason_sk BETWEEN 43 AND 46
and s_store_sk = ctr1.ctr_store_sk
and s_state IN ('IL', 'KY', 'TX')
and ctr1.ctr_customer_sk = c_customer_sk
and c_current_cdemo_sk = cd_demo_sk
and cd_marital_status IN ('M', 'M')
and cd_education_status IN ('Advanced Degree', 'College')
and cd_gender = 'F'
and c_birth_month = 2
and c_birth_year BETWEEN 1965 AND 1971
order by c_customer_id
limit 100;
```

## IR Node Map

```
S0 [SELECT]
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: store_returns, date_dim
    WHERE [ddc05012d854ff26]: sr_returned_date_sk = d_date_sk AND d_year = 2002 AND sr_return_amt / sr_return_quantity BETWEEN ...
    GROUP BY: sr_customer_sk, sr_store_sk, sr_reason_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store, customer, customer_demographics
    WHERE [a05952426f9ba20b]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WH...
    ORDER BY: c_customer_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

## Previous Round Feedback

## Round 2 Results (baseline: 7752ms, None rows)

### P1_decorrelate: WIN 16.17x (480ms)
Steps: s1: insert_cte — ; s2: replace_from — ; s3: replace_where_predicate — 
EXPLAIN top:
```
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=62680.20..62680.20 rows=1 width=17) (actual time=479.015..479.051 rows=0 loops=1)
   Buffers: shared hit=804523 read=97721, temp read=582 written=583
   CTE customer_total_return
     ->  Finalize GroupAggregate  (cost=62623.82..62649.31 rows=197 width=44) (actual time=406.118..451.093 rows=95599 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=803308 read=97649, temp read=243 written=244
```

### P2_pushdown: WIN 1.17x (6604ms)
Steps: s1: insert_cte — ; s2: replace_from — ; s3: replace_where_predicate — 
EXPLAIN top:
```
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=63552.92..63552.93 rows=1 width=17) (actual time=6603.392..6603.453 rows=0 loops=1)
   Buffers: shared hit=805751 read=98171, temp read=627211 written=583
   CTE customer_total_return
     ->  Finalize GroupAggregate  (cost=62623.82..62649.31 rows=197 width=44) (actual time=407.826..453.136 rows=95599 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=802857 read=98100, temp read=243 written=244
```

### P3_restructure: WIN 1.14x (6784ms)
Steps: s1: replace_from — ; s2: replace_where_predicate — 
EXPLAIN top:
```
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=63552.92..63552.93 rows=1 width=17) (actual time=6783.448..6783.510 rows=0 loops=1)
   Buffers: shared hit=806960 read=96962, temp read=627211 written=583
   CTE customer_total_return
     ->  Finalize GroupAggregate  (cost=62623.82..62649.31 rows=197 width=44) (actual time=439.084..484.123 rows=95599 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=804066 read=96891, temp read=243 written=244
```

### P4_combined: WIN 15.80x (491ms)
Steps: s1: insert_cte — ; s2: insert_cte — ; s3: replace_from — ; s4: replace_where_predicate — 
EXPLAIN top:
```
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=62680.20..62680.20 rows=1 width=17) (actual time=490.085..490.127 rows=0 loops=1)
   Buffers: shared hit=803255 read=98989, temp read=582 written=583
   CTE customer_total_return
     ->  Finalize GroupAggregate  (cost=62623.82..62649.31 rows=197 width=44) (actual time=415.904..462.129 rows=95599 loops=1)
           Group Key: store_returns.sr_customer_sk, store_returns.sr_store_sk, store_returns.sr_reason_sk
           Buffers: shared hit=802040 read=98917, temp read=243 written=244
```


## Task

Based on the feedback above, produce **4 improved patch plans** — one per strategy slot.
- If a plan WON, try to improve it further or combine its strategy with others.
- If a plan had WRONG RESULTS, fix the semantic error (usually: predicates dropped by replace_where_predicate — use replace_expr_subtree instead to target only the specific predicate).
- If a plan FAILED TO APPLY, simplify it or use different operations.
- If a plan had NO IMPROVEMENT, try a fundamentally different approach.

### Strategy Slots (you MUST use a different strategy for each)

**P1 DECORRELATE**: Pre-compute correlated subqueries into CTEs, use `replace_from` to JOIN them.
**P2 PREDICATE PUSHDOWN**: Push selective filters into CTE definitions or earlier FROM.
**P3 RESTRUCTURE**: Convert comma-joins to explicit JOINs via `replace_from`.
**P4 COMBINED**: Best elements of P1+P2+P3 together.

## Available Operations

| op | required fields | description |
|---|---|---|
| `insert_cte` | `by_node_id`, `cte_name`, `cte_query_sql` | Add a new CTE |
| `replace_expr_subtree` | `by_node_id`, `by_anchor_hash`, `expr_sql` | Replace one expression |
| `replace_where_predicate` | `by_node_id`, `by_anchor_hash`, `expr_sql` | Replace ENTIRE WHERE clause |
| `replace_from` | `by_node_id`, `from_sql` | Replace entire FROM+JOINs of a SELECT |
| `delete_expr_subtree` | `by_node_id`, `by_anchor_hash` | Delete an expression |

`replace_from`: `from_sql` is everything after FROM, before WHERE.

## CRITICAL rules

- `by_anchor_hash`: copy the 16-char hex from `[...]` in the IR Node Map. Do NOT invent hashes.
- `replace_where_predicate` replaces the ENTIRE WHERE clause. To replace just ONE predicate in a multi-AND WHERE, use `replace_expr_subtree` with that predicate's anchor hash.
- Every `cte_query_sql`, `expr_sql`, and `from_sql` must be complete, syntactically valid SQL.
- Each plan must preserve ALL existing predicates unless intentionally restructured.
- Fields can be flat at step level (no need for target/payload nesting).

## Output: JSON array of 4 plans

```json
[
  {"plan_id": "P1_...", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P2_...", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P3_...", "dialect": "postgres", "steps": [...]},
  {"plan_id": "P4_...", "dialect": "postgres", "steps": [...]}
]
```

After the JSON, write one line per plan: `P1: <strategy> — expected speedup: <estimate>`