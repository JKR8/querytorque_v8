## Role

You are a SQL optimization analyst. Your task is to analyze this query and design **up to 4 structural optimization targets**, each targeting a different optimization family.

For each target, describe the STRUCTURAL SHAPE of the optimized query using an IR node map (CTE names, FROM tables, WHERE conditions, GROUP BY, ORDER BY). A separate code-generation worker will convert your targets into executable patch plans.

You will **choose up to 4 of the 6 families** based on relevance to THIS SPECIFIC QUERY.

## Query: query_21

**Dialect**: DUCKDB

```sql
-- start query 21 in stream 0 using template query21.tpl
select *
 from(select w_warehouse_name
            ,i_item_id
            ,sum(case when (cast(d_date as date) < cast ('2002-02-27' as date))
	                then inv_quantity_on_hand 
                      else 0 end) as inv_before
            ,sum(case when (cast(d_date as date) >= cast ('2002-02-27' as date))
                      then inv_quantity_on_hand 
                      else 0 end) as inv_after
   from inventory
       ,warehouse
       ,item
       ,date_dim
   where i_current_price between 0.99 and 1.49
     and i_item_sk          = inv_item_sk
     and inv_warehouse_sk   = w_warehouse_sk
     and inv_date_sk    = d_date_sk
     and d_date between (cast ('2002-02-27' as date) - INTERVAL 30 DAY)
                    and (cast ('2002-02-27' as date) + INTERVAL 30 DAY)
   group by w_warehouse_name, i_item_id) x
 where (case when inv_before > 0 
             then inv_after / inv_before 
             else null
             end) between 2.0/3.0 and 3.0/2.0
 order by w_warehouse_name
         ,i_item_id
 LIMIT 100;

-- end query 21 in stream 0 using template query21.tpl
```


## Current Execution Plan

```
┌───────────────────────────┐
│           TOP_N           │
│    ────────────────────   │
│          Top: 100         │
│                           │
│         Order By:         │
│   x.w_warehouse_name ASC  │
│      x.i_item_id ASC      │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│           FILTER          │
│    ────────────────────   │
│ (CASE  WHEN ((inv_before >│
│  0)) THEN ((CAST(inv_after│
│      AS DOUBLE) / CAST    │
│  (inv_before AS DOUBLE))) │
│   ELSE NULL END BETWEEN 0 │
│ .6666666666666666 AND 1.5)│
│                           │
│        ~2,184 rows        │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│       HASH_GROUP_BY       │
│    ────────────────────   │
│          Groups:          │
│             #0            │
│             #1            │
│                           │
│        Aggregates:        │
│          sum(#2)          │
│          sum(#3)          │
│                           │
│        ~2,184 rows        │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│         PROJECTION        │
│    ────────────────────   │
│      w_warehouse_name     │
│         i_item_id         │
│   CASE  WHEN ((d_date <   │
│ '2002-02-27'::DATE)) THEN │
│   (inv_quantity_on_hand)  │
│         ELSE 0 END        │
│  CASE  WHEN ((d_date >=   │
│ '2002-02-27'::DATE)) THEN │
│   (inv_quantity_on_hand)  │
│         ELSE 0 END        │
│                           │
│      ~5,141,212 rows      │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│         HASH_JOIN         │
│    ────────────────────   │
│      Join Type: INNER     │
│                           │
│        Conditions:        ├────────────────────────────────────────────────────────────────────────┐
│     inv_warehouse_sk =    │                                                                        │
│       w_warehouse_sk      │                                                                        │
│                           │                                                                        │
│      ~5,141,212 rows      │                                                                        │
└─────────────┬─────────────┘                                                                        │
┌─────────────┴─────────────┐                                                          ┌─────────────┴─────────────┐
│         HASH_JOIN         │                                                          │         SEQ_SCAN          │
│    ────────────────────   │                                                          │    ────────────────────   │
│      Join Type: INNER     │                                                          │      Table: warehouse     │
│                           │                                                          │   Type: Sequential Scan   │
│        Conditions:        │                                                          │                           │
│  inv_item_sk = i_item_sk  ├───────────────────────────────────────────┐              │        Projections:       │
│                           │                                           │              │       w_warehouse_sk      │
│                           │                                           │              │      w_warehouse_name     │
│                           │                                           │              │                           │
│      ~5,655,333 rows      │                                           │              │          ~10 rows         │
└─────────────┬─────────────┘                                           │              └───────────────────────────┘
┌─────────────┴─────────────┐                             ┌─────────────┴─────────────┐
│         HASH_JOIN         │                             │         SEQ_SCAN          │
│    ────────────────────   │                             │    ────────────────────   │
│      Join Type: INNER     │                             │        Table: item        │
│                           │                             │   Type: Sequential Scan   │
│        Conditions:        │                             │                           │
│  inv_date_sk = d_date_sk  │                             │        Projections:       │
│                           │                             │         i_item_sk         │
│                           ├──────────────┐              │         i_item_id         │
│                           │              │              │                           │
│                           │              │              │          Filters:         │
│                           │              │              │ i_current_price>=0.99 AND │
│                           │              │              │    i_current_price<=1.49  │
│                           │              │              │                           │
│      ~26,620,542 rows     │              │              │        ~20,400 rows       │
└─────────────┬─────────────┘              │              └───────────────────────────┘
┌─────────────┴─────────────┐┌─────────────┴─────────────┐
│         SEQ_SCAN          ││           FILTER          │
│    ────────────────────   ││    ────────────────────   │
│      Table: inventory     ││ (d_date_sk BETWEEN 2450815│
│   Type: Sequential Scan   ││        AND 2452635)       │
│                           ││                           │
│        Projections:       ││                           │
│        inv_item_sk        ││                           │
│      inv_warehouse_sk     ││                           │
│        inv_date_sk        ││                           │
│    inv_quantity_on_hand   ││                           │
│                           ││                           │
│     ~133,110,000 rows     ││        ~14,609 rows       │
└───────────────────────────┘└─────────────┬─────────────┘
                             ┌─────────────┴─────────────┐
                             │         SEQ_SCAN          │
                             │    ────────────────────   │
                             │      Table: date_dim      │
                             │   Type: Sequential Scan   │
                             │                           │
                             │        Projections:       │
                             │         d_date_sk         │
                             │           d_date          │
                             │                           │
                             │          Filters:         │
                             │ (CAST(d_date AS TIMESTAMP)│
                             │  BETWEEN '2002-01-28 00:00│
                             │ :00'::TIMESTAMP AND '2002 │
                             │     -03-29 00:00:00':     │
                             │        :TIMESTAMP)        │
                             │                           │
                             │        ~14,609 rows       │
                             └───────────────────────────┘

```


## IR Structure (for patch targeting)

```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: (subquery) x
    WHERE [43499fffd10e5dc4]: (CASE WHEN inv_before > 0 THEN inv_after / inv_before ELSE NULL END) BETWEEN 2.0 / 3.0 AND 3.0 / 2.0
    ORDER BY: w_warehouse_name, i_item_id
S1 [OTHER_DDL]

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**Note**: Use `by_node_id` (e.g., "S0") and `by_anchor_hash` (16-char hex) from map above to target patch operations.


## Optimization Families

Review the 6 families below. Each shows a pattern with a gold example patch plan.

Choose up to **4 most relevant families** for this query based on:
- Query structure (CTEs, subqueries, joins, aggregations, set operations)
- Execution plan signals (WHERE placement, repeated scans, correlated subqueries, materializations)
- Problem signature (cardinality estimation errors, loops vs sets, filter ordering)



### Family A: Early Filtering (Predicate Pushback)
**Description**: Push small filters into CTEs early, reduce row count before expensive operations
**Speedup Range**: 1.3–4.0x (~35% of all wins)
**Use When**:
  1. Late WHERE filters on dimension tables
  2. Cascading CTEs with filters applied downstream
  3. Expensive joins after filters could be pushed earlier

**Gold Example**: `date_cte_isolate` (4.00x)

**BEFORE (slow):**
```sql
select a.ca_state state, count(*) cnt
 from customer_address a
     ,customer c
     ,store_sales s
     ,date_dim d
     ,item i
 where       a.ca_address_sk = c.c_current_addr_sk
 	and c.c_customer_sk = s.ss_customer_sk
 	and s.ss_sold_date_sk = d.d_date_sk
 	and s.ss_item_sk = i.i_item_sk
...
```

**AFTER (fast):**
```sql
WITH target_month AS (SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3), category_avg AS (SELECT i_category, AVG(i_current_price) * 1.2 AS price_threshold FROM item GROUP BY i_category)
SELECT a.ca_state AS state, COUNT(*) AS cnt FROM customer_address AS a JOIN customer AS c ON a.ca_address_sk = c.c_current_addr_sk JOIN store_sales AS s ON c.c_customer_sk = s.ss_customer_sk JOIN date_dim AS d ON s.ss_sold_date_sk = d.d_date_sk JOIN target_month AS tm ON d.d_month_seq = tm.d_month_seq JOIN item AS i ON s.ss_item_sk = i.i_item_sk JOIN category_avg AS ca ON i.i_category = ca.i_category WHERE i.i_current_price > ca.price_threshold GROUP BY a.ca_state HAVING COUNT(*) >= 10 ORDER BY cnt, a.ca_state LIMIT 100;
```

**IR BEFORE:**
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: customer_address a, customer c, store_sales s, date_dim d, item i
    WHERE [2837aea03aa52676]: a.ca_address_sk = c.c_current_addr_sk AND c.c_customer_sk = s.ss_customer_sk AND s.ss_sold_date_s...
    GROUP BY: a.ca_state
    ORDER BY: cnt, a.ca_state

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: target_month  (via CTE_Q_S0_target_month)
    FROM: date_dim
    WHERE [198e5f8f07395c48]: d_year = 2002 AND d_moy = 3
  CTE: category_avg  (via CTE_Q_S0_category_avg)
    FROM: item
    GROUP BY: i_category
  MAIN QUERY (via Q_S0)
    FROM: customer_address a, customer c, store_sales s, date_dim d, target_month tm, item i, category_avg ca
    WHERE [031e98036ebea62d]: i.i_current_price > ca.price_threshold
    GROUP BY: a.ca_state
    ORDER BY: cnt, a.ca_state

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**PATCH PLAN:**
```json
{
  "plan_id": "gold_duckdb_date_cte_isolate",
  "dialect": "duckdb",
  "description": "Extract date filtering into a separate CTE to enable predicate pushdown and reduce scans",
  "preconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "postconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "target_month",
        "cte_query_sql": "SELECT DISTINCT d_month_seq FROM date_dim WHERE d_year = 2002 AND d_moy = 3"
      },
      "description": "Insert CTE 'target_month' for date dimension filtering"
    },
    {
      "step_id": "s2",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "category_avg",
        "cte_query_sql": "SELECT i_category, AVG(i_current_price) * 1.2 AS price_threshold FROM item GROUP BY i_category"
      },
      "description": "Insert CTE 'category_avg' for pre-aggregated computation"
    },
    {
      "step_id": "s3",
      "op": "replace_from",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "from_sql": "customer_address AS a JOIN customer AS c ON a.ca_address_sk = c.c_current_addr_sk JOIN store_sales AS s ON c.c_customer_sk = s.ss_customer_sk JOIN date_dim AS d ON s.ss_sold_date_sk = d.d_date_sk JOIN target_month AS tm ON d.d_month_seq = tm.d_month_seq JOIN item AS i ON s.ss_item_sk = i.i_item_sk JOIN category_avg AS ca ON i.i_category = ca.i_category"
      },
      "description": "Replace comma-join FROM with explicit JOINs"
    },
    {
      "step_id": "s4",
      "op": "replace_where_predicate",
      "target": {
        "by_node_id": "S0",
        "by_anchor_hash": "2837aea03aa52676"
      },
      "payload": {
        "expr_sql": "i.i_current_price > ca.price_threshold"
      },
      "description": "Replace WHERE predicate with optimized version"
    }
  ]
}
```



### Family B: Decorrelation (Sets Over Loops)
**Description**: Convert correlated subqueries to standalone CTEs with GROUP BY, eliminate per-row re-execution
**Speedup Range**: 2.4–2.9x (~15% of all wins)
**Use When**:
  1. Correlated subqueries in WHERE clause
  2. Scalar aggregates computed per outer row
  3. DELIM_SCAN in execution plan (indicates correlation)

**Gold Example**: `decorrelate` (2.92x)

**BEFORE (slow):**
```sql
with customer_total_return as
(select sr_customer_sk as ctr_customer_sk
,sr_store_sk as ctr_store_sk
,sum(SR_FEE) as ctr_total_return
from store_returns
,date_dim
where sr_returned_date_sk = d_date_sk
and d_year =2000
group by sr_customer_sk
,sr_store_sk)
...
```

**AFTER (fast):**
```sql
WITH filtered_returns AS (SELECT sr.sr_customer_sk, sr.sr_store_sk, sr.SR_FEE FROM store_returns AS sr JOIN date_dim AS d ON sr.sr_returned_date_sk = d.d_date_sk JOIN store AS s ON sr.sr_store_sk = s.s_store_sk WHERE d.d_year = 2000 AND s.s_state = 'SD'), customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(SR_FEE) AS ctr_total_return FROM filtered_returns GROUP BY sr_customer_sk, sr_store_sk), store_avg_return AS (SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_return_threshold FROM customer_total_return GROUP BY ctr_store_sk)
SELECT c.c_customer_id FROM customer_total_return AS ctr1 JOIN store_avg_return AS sar ON ctr1.ctr_store_sk = sar.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c.c_customer_sk WHERE ctr1.ctr_total_return > sar.avg_return_threshold ORDER BY c.c_customer_id LIMIT 100;
```

**IR BEFORE:**
```
S0 [SELECT]
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: store_returns, date_dim
    WHERE [eb0f6bc97f7168d4]: sr_returned_date_sk = d_date_sk AND d_year = 2000
    GROUP BY: sr_customer_sk, sr_store_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store, customer
    WHERE [e5b7485395ff5a80]: ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2 FROM customer_total_return AS ctr2 WH...
    ORDER BY: c_customer_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: filtered_returns  (via CTE_Q_S0_filtered_returns)
    FROM: store_returns sr, date_dim d, store s
    WHERE [e49579c0ddbdbdda]: d.d_year = 2000 AND s.s_state = 'SD'
  CTE: customer_total_return  (via CTE_Q_S0_customer_total_return)
    FROM: filtered_returns
    GROUP BY: sr_customer_sk, sr_store_sk
  CTE: store_avg_return  (via CTE_Q_S0_store_avg_return)
    FROM: customer_total_return
    GROUP BY: ctr_store_sk
  MAIN QUERY (via Q_S0)
    FROM: customer_total_return ctr1, store_avg_return sar, customer c
    WHERE [0f5f48abeb70c147]: ctr1.ctr_total_return > sar.avg_return_threshold
    ORDER BY: c.c_customer_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**PATCH PLAN:**
```json
{
  "plan_id": "gold_duckdb_decorrelate",
  "dialect": "duckdb",
  "description": "Convert correlated subquery to separate CTE with GROUP BY, then JOIN",
  "preconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "postconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "filtered_returns",
        "cte_query_sql": "SELECT sr.sr_customer_sk, sr.sr_store_sk, sr.SR_FEE FROM store_returns AS sr JOIN date_dim AS d ON sr.sr_returned_date_sk = d.d_date_sk JOIN store AS s ON sr.sr_store_sk = s.s_store_sk WHERE d.d_year = 2000 AND s.s_state = 'SD'"
      },
      "description": "Insert CTE 'filtered_returns' for date dimension filtering"
    },
    {
      "step_id": "s2",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "store_avg_return",
        "cte_query_sql": "SELECT ctr_store_sk, AVG(ctr_total_return) * 1.2 AS avg_return_threshold FROM customer_total_return GROUP BY ctr_store_sk"
      },
      "description": "Insert CTE 'store_avg_return' for pre-aggregated computation"
    },
    {
      "step_id": "s3",
      "op": "replace_block_with_cte_pair",
      "target": {
        "by_node_id": "S0",
        "by_label": "customer_total_return"
      },
      "payload": {
        "sql_fragment": "customer_total_return AS (SELECT sr_customer_sk AS ctr_customer_sk, sr_store_sk AS ctr_store_sk, SUM(SR_FEE) AS ctr_total_return FROM filtered_returns GROUP BY sr_customer_sk, sr_store_sk)"
      },
      "description": "Replace CTE 'customer_total_return' body with optimized version"
    },
    {
      "step_id": "s4",
      "op": "replace_from",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "from_sql": "customer_total_return AS ctr1 JOIN store_avg_return AS sar ON ctr1.ctr_store_sk = sar.ctr_store_sk JOIN customer AS c ON ctr1.ctr_customer_sk = c.c_customer_sk"
      },
      "description": "Replace comma-join FROM with explicit JOINs"
    },
    {
      "step_id": "s5",
      "op": "replace_where_predicate",
      "target": {
        "by_node_id": "S0",
        "by_anchor_hash": "e5b7485395ff5a80"
      },
      "payload": {
        "expr_sql": "ctr1.ctr_total_return > sar.avg_return_threshold"
      },
      "description": "Replace WHERE predicate with optimized version"
    }
  ]
}
```



### Family C: Aggregation Pushdown (Minimize Rows Touched)
**Description**: Aggregate before expensive joins when GROUP BY keys ⊇ join keys, reduce intermediate sizes
**Speedup Range**: 1.3–15.3x (~5% of all wins (high variance))
**Use When**:
  1. GROUP BY happens after large joins
  2. GROUP BY keys are subset of join keys
  3. Intermediate result size >> final result size

**Gold Example**: `aggregate_pushdown` (42.90x)

**BEFORE (slow):**
```sql
select i_product_name
             ,i_brand
             ,i_class
             ,i_category
             ,avg(inv_quantity_on_hand) qoh
       from inventory
           ,date_dim
           ,item
       where inv_date_sk=d_date_sk
              and inv_item_sk=i_item_sk
...
```

**AFTER (fast):**
```sql
WITH date_filtered AS (SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1188 AND 1188 + 11), inventory_date AS (SELECT inv_item_sk, inv_quantity_on_hand FROM inventory JOIN date_filtered ON inv_date_sk = d_date_sk), inventory_agg AS (SELECT inv_item_sk, SUM(inv_quantity_on_hand) AS sum_qty, COUNT(inv_quantity_on_hand) AS cnt FROM inventory_date GROUP BY inv_item_sk), join_item AS (SELECT i_product_name, i_brand, i_class, i_category, sum_qty, cnt FROM inventory_agg JOIN item ON inv_item_sk = i_item_sk), rollup_aggregate AS (SELECT i_product_name, i_brand, i_class, i_category, CASE WHEN SUM(cnt) > 0 THEN SUM(sum_qty) / SUM(cnt) END AS qoh FROM join_item GROUP BY ROLLUP(i_product_name, i_brand, i_class, i_category)) SELECT i_product_name, i_brand, i_class, i_category, qoh FROM rollup_aggregate ORDER BY qoh ASC, i_product_name ASC, i_brand ASC, i_class ASC, i_category ASC LIMIT 100
```

**IR BEFORE:**
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: inventory, date_dim, item
    WHERE [cb0b927b3e0ad199]: inv_date_sk = d_date_sk AND inv_item_sk = i_item_sk AND d_month_seq BETWEEN 1188 AND 1188 + 11
    ORDER BY: qoh, i_product_name, i_brand, i_class, i_category

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: date_filtered  (via CTE_Q_S0_date_filtered)
    FROM: date_dim
    WHERE [64df5f706f9f2db0]: d_month_seq BETWEEN 1188 AND 1188 + 11
  CTE: inventory_date  (via CTE_Q_S0_inventory_date)
    FROM: inventory, date_filtered
  CTE: inventory_agg  (via CTE_Q_S0_inventory_agg)
    FROM: inventory_date
    GROUP BY: inv_item_sk
  CTE: join_item  (via CTE_Q_S0_join_item)
    FROM: inventory_agg, item
  CTE: rollup_aggregate  (via CTE_Q_S0_rollup_aggregate)
    FROM: join_item
  MAIN QUERY (via Q_S0)
    FROM: rollup_aggregate
    ORDER BY: qoh, i_product_name, i_brand, i_class, i_category

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**PATCH PLAN:**
```json
{
  "plan_id": "gold_duckdb_aggregate_pushdown",
  "dialect": "duckdb",
  "description": "Pre-aggregate fact table by join key before dimension joins to reduce rows entering the join from millions to thousands",
  "preconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "postconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "date_filtered",
        "cte_query_sql": "SELECT d_date_sk FROM date_dim WHERE d_month_seq BETWEEN 1188 AND 1188 + 11"
      },
      "description": "Insert CTE 'date_filtered' for date dimension filtering"
    },
    {
      "step_id": "s2",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "inventory_date",
        "cte_query_sql": "SELECT inv_item_sk, inv_quantity_on_hand FROM inventory JOIN date_filtered ON inv_date_sk = d_date_sk"
      },
      "description": "Insert CTE 'inventory_date' for date dimension filtering"
    },
    {
      "step_id": "s3",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "inventory_agg",
        "cte_query_sql": "SELECT inv_item_sk, SUM(inv_quantity_on_hand) AS sum_qty, COUNT(inv_quantity_on_hand) AS cnt FROM inventory_date GROUP BY inv_item_sk"
      },
      "description": "Insert CTE 'inventory_agg' for pre-aggregated computation"
    },
    {
      "step_id": "s4",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "join_item",
        "cte_query_sql": "SELECT i_product_name, i_brand, i_class, i_category, sum_qty, cnt FROM inventory_agg JOIN item ON inv_item_sk = i_item_sk"
      },
      "description": "Insert CTE 'join_item' for pre-filtered join"
    },
    {
      "step_id": "s5",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "rollup_aggregate",
        "cte_query_sql": "SELECT i_product_name, i_brand, i_class, i_category, CASE WHEN SUM(cnt) > 0 THEN SUM(sum_qty) / SUM(cnt) END AS qoh FROM join_item GROUP BY ROLLUP (i_product_name, i_brand, i_class, i_category)"
      },
      "description": "Insert CTE 'rollup_aggregate' for pre-aggregated computation"
    },
    {
      "step_id": "s6",
      "op": "replace_body",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "sql_fragment": "SELECT i_product_name, i_brand, i_class, i_category, qoh FROM rollup_aggregate ORDER BY qoh ASC, i_product_name ASC, i_brand ASC, i_class ASC, i_category ASC LIMIT 100"
      },
      "description": "Replace main query body with optimized version"
    }
  ]
}
```



### Family D: Set Operation Optimization (Sets Over Loops)
**Description**: Replace INTERSECT/UNION-based patterns with EXISTS/NOT EXISTS, avoid full materialization
**Speedup Range**: 1.7–2.7x (~8% of all wins)
**Use When**:
  1. INTERSECT patterns between large sets
  2. UNION ALL with duplicate elimination
  3. Set operations materializing full intermediate results

**Gold Example**: `intersect_to_exists` (1.83x)

**BEFORE (slow):**
```sql
with  cross_items as
 (select i_item_sk ss_item_sk
 from item,
 (select iss.i_brand_id brand_id
     ,iss.i_class_id class_id
     ,iss.i_category_id category_id
 from store_sales
     ,item iss
     ,date_dim d1
 where ss_item_sk = iss.i_item_sk
...
```

**AFTER (fast):**
```sql
WITH cross_items AS (SELECT i.i_item_sk AS ss_item_sk FROM item AS i WHERE EXISTS(SELECT 1 FROM store_sales, item AS iss, date_dim AS d1 WHERE ss_item_sk = iss.i_item_sk AND ss_sold_date_sk = d1.d_date_sk AND d1.d_year BETWEEN 2000 AND 2000 + 2 AND iss.i_brand_id = i.i_brand_id AND iss.i_class_id = i.i_class_id AND iss.i_category_id = i.i_category_id) AND EXISTS(SELECT 1 FROM catalog_sales, item AS ics, date_dim AS d2 WHERE cs_item_sk = ics.i_item_sk AND cs_sold_date_sk = d2.d_date_sk AND d2.d_year BETWEEN 2000 AND 2000 + 2 AND ics.i_brand_id = i.i_brand_id AND ics.i_class_id = i.i_class_id AND ics.i_category_id = i.i_category_id) AND EXISTS(SELECT 1 FROM web_sales, item AS iws, date_dim AS d3 WHERE ws_item_sk = iws.i_item_sk AND ws_sold_date_sk = d3.d_date_sk AND d3.d_year BETWEEN 2000 AND 2000 + 2 AND iws.i_brand_id = i.i_brand_id AND iws.i_class_id = i.i_class_id AND iws.i_category_id = i.i_category_id)), avg_sales AS (SELECT AVG(quantity * list_price) AS average_sales FROM (SELECT ss_quantity AS quantity, ss_list_price AS list_price FROM store_sales, date_dim WHERE ss_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2000 + 2 UNION ALL SELECT cs_quantity AS quantity, cs_list_price AS list_price FROM catalog_sales, date_dim WHERE cs_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2000 + 2 UNION ALL SELECT ws_quantity AS quantity, ws_list_price AS list_price FROM web_sales, date_dim WHERE ws_sold_date_sk = d_date_sk AND d_year BETWEEN 2000 AND 2000 + 2) AS x)
SELECT channel, i_brand_id, i_class_id, i_category_id, SUM(sales), SUM(number_sales) FROM (SELECT 'store' AS channel, i_brand_id, i_class_id, i_category_id, SUM(ss_quantity * ss_list_price) AS sales, COUNT(*) AS number_sales FROM store_sales, item, date_dim WHERE ss_item_sk IN (SELECT ss_item_sk FROM cross_items) AND ss_item_sk = i_item_sk AND ss_sold_date_sk = d_date_sk AND d_year = 2000 + 2 AND d_moy = 11 GROUP BY i_brand_id, i_class_id, i_category_id HAVING SUM(ss_quantity * ss_list_price) > (SELECT average_sales FROM avg_sales) UNION ALL SELECT 'catalog' AS channel, i_brand_id, i_class_id, i_category_id, SUM(cs_quantity * cs_list_price) AS sales, COUNT(*) AS number_sales FROM catalog_sales, item, date_dim WHERE cs_item_sk IN (SELECT ss_item_sk FROM cross_items) AND cs_item_sk = i_item_sk AND cs_sold_date_sk = d_date_sk AND d_year = 2000 + 2 AND d_moy = 11 GROUP BY i_brand_id, i_class_id, i_category_id HAVING SUM(cs_quantity * cs_list_price) > (SELECT average_sales FROM avg_sales) UNION ALL SELECT 'web' AS channel, i_brand_id, i_class_id, i_category_id, SUM(ws_quantity * ws_list_price) AS sales, COUNT(*) AS number_sales FROM web_sales, item, date_dim WHERE ws_item_sk IN (SELECT ss_item_sk FROM cross_items) AND ws_item_sk = i_item_sk AND ws_sold_date_sk = d_date_sk AND d_year = 2000 + 2 AND d_moy = 11 GROUP BY i_brand_id, i_class_id, i_category_id HAVING SUM(ws_quantity * ws_list_price) > (SELECT average_sales FROM avg_sales)) AS y GROUP BY ROLLUP (channel, i_brand_id, i_class_id, i_category_id) ORDER BY channel, i_brand_id, i_class_id, i_category_id LIMIT 100;
```

**IR BEFORE:**
```
S0 [SELECT]
  CTE: cross_items  (via CTE_Q_S0_cross_items)
    FROM: item, (subquery) 
    WHERE [3f561bc366ff68bb]: i_brand_id = brand_id AND i_class_id = class_id AND i_category_id = category_id
  CTE: avg_sales  (via CTE_Q_S0_avg_sales)
    FROM: (subquery) x
  MAIN QUERY (via Q_S0)
    FROM: (subquery) y
    ORDER BY: channel, i_brand_id, i_class_id, i_category_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: cross_items  (via CTE_Q_S0_cross_items)
    FROM: item i
    WHERE [8094f2c0095034d2]: EXISTS(SELECT 1 FROM store_sales, item AS iss, date_dim AS d1 WHERE ss_item_sk = iss.i_item_sk AN...
  CTE: avg_sales  (via CTE_Q_S0_avg_sales)
    FROM: (subquery) x
  MAIN QUERY (via Q_S0)
    FROM: (subquery) y
    ORDER BY: channel, i_brand_id, i_class_id, i_category_id

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**PATCH PLAN:**
```json
{
  "plan_id": "gold_duckdb_intersect_to_exists",
  "dialect": "duckdb",
  "description": "Convert INTERSECT subquery pattern to multiple EXISTS clauses for better join planning",
  "preconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "postconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "steps": [
    {
      "step_id": "s1",
      "op": "replace_block_with_cte_pair",
      "target": {
        "by_node_id": "S0",
        "by_label": "cross_items"
      },
      "payload": {
        "sql_fragment": "cross_items AS (SELECT i.i_item_sk AS ss_item_sk FROM item AS i WHERE EXISTS(SELECT 1 FROM store_sales, item AS iss, date_dim AS d1 WHERE ss_item_sk = iss.i_item_sk AND ss_sold_date_sk = d1.d_date_sk AND d1.d_year BETWEEN 2000 AND 2000 + 2 AND iss.i_brand_id = i.i_brand_id AND iss.i_class_id = i.i_class_id AND iss.i_category_id = i.i_category_id) AND EXISTS(SELECT 1 FROM catalog_sales, item AS ics, date_dim AS d2 WHERE cs_item_sk = ics.i_item_sk AND cs_sold_date_sk = d2.d_date_sk AND d2.d_year BETWEEN 2000 AND 2000 + 2 AND ics.i_brand_id = i.i_brand_id AND ics.i_class_id = i.i_class_id AND ics.i_category_id = i.i_category_id) AND EXISTS(SELECT 1 FROM web_sales, item AS iws, date_dim AS d3 WHERE ws_item_sk = iws.i_item_sk AND ws_sold_date_sk = d3.d_date_sk AND d3.d_year BETWEEN 2000 AND 2000 + 2 AND iws.i_brand_id = i.i_brand_id AND iws.i_class_id = i.i_class_id AND iws.i_category_id = i.i_category_id))"
      },
      "description": "Replace CTE 'cross_items' body with optimized version"
    }
  ]
}
```



### Family E: Materialization / Prefetch (Don't Repeat Work)
**Description**: Extract repeated scans or pre-compute intermediate results for reuse across multiple consumers
**Speedup Range**: 1.3–6.2x (~18% of all wins)
**Use When**:
  1. Repeated scans of same table with different filters
  2. Dimension filters applied independently multiple times
  3. CTE referenced multiple times with implicit re-evaluation

**Gold Example**: `multi_dimension_prefetch` (2.71x)

**BEFORE (slow):**
```sql
select s_store_name, s_store_id,
        sum(case when (d_day_name='Sunday') then ss_sales_price else null end) sun_sales,
        sum(case when (d_day_name='Monday') then ss_sales_price else null end) mon_sales,
        sum(case when (d_day_name='Tuesday') then ss_sales_price else  null end) tue_sales,
        sum(case when (d_day_name='Wednesday') then ss_sales_price else null end) wed_sales,
        sum(case when (d_day_name='Thursday') then ss_sales_price else null end) thu_sales,
        sum(case when (d_day_name='Friday') then ss_sales_price else null end) fri_sales,
        sum(case when (d_day_name='Saturday') then ss_sales_price else null end) sat_sales
 from date_dim, store_sales, store
 where d_date_sk = ss_sold_date_sk and
...
```

**AFTER (fast):**
```sql
WITH filtered_dates AS (SELECT d_date_sk, d_day_name FROM date_dim WHERE d_year = 2000), filtered_stores AS (SELECT s_store_sk, s_store_id, s_store_name FROM store WHERE s_gmt_offset = -5), filtered_sales AS (SELECT ss_sales_price, d_day_name, s_store_id, s_store_name FROM store_sales JOIN filtered_dates ON d_date_sk = ss_sold_date_sk JOIN filtered_stores ON s_store_sk = ss_store_sk)
SELECT s_store_name, s_store_id, SUM(CASE WHEN (d_day_name = 'Sunday') THEN ss_sales_price ELSE NULL END) AS sun_sales, SUM(CASE WHEN (d_day_name = 'Monday') THEN ss_sales_price ELSE NULL END) AS mon_sales, SUM(CASE WHEN (d_day_name = 'Tuesday') THEN ss_sales_price ELSE NULL END) AS tue_sales, SUM(CASE WHEN (d_day_name = 'Wednesday') THEN ss_sales_price ELSE NULL END) AS wed_sales, SUM(CASE WHEN (d_day_name = 'Thursday') THEN ss_sales_price ELSE NULL END) AS thu_sales, SUM(CASE WHEN (d_day_name = 'Friday') THEN ss_sales_price ELSE NULL END) AS fri_sales, SUM(CASE WHEN (d_day_name = 'Saturday') THEN ss_sales_price ELSE NULL END) AS sat_sales FROM filtered_sales GROUP BY s_store_name, s_store_id ORDER BY s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales LIMIT 100;
```

**IR BEFORE:**
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: date_dim, store_sales, store
    WHERE [834e9c75d01a8fa3]: d_date_sk = ss_sold_date_sk AND s_store_sk = ss_store_sk AND s_gmt_offset = -5 AND d_year = 2000
    GROUP BY: s_store_name, s_store_id
    ORDER BY: s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: filtered_dates  (via CTE_Q_S0_filtered_dates)
    FROM: date_dim
    WHERE [48b31a2bf2993b3d]: d_year = 2000
  CTE: filtered_stores  (via CTE_Q_S0_filtered_stores)
    FROM: store
    WHERE [812f7299c6fba51b]: s_gmt_offset = -5
  CTE: filtered_sales  (via CTE_Q_S0_filtered_sales)
    FROM: store_sales, filtered_dates, filtered_stores
  MAIN QUERY (via Q_S0)
    FROM: filtered_sales
    GROUP BY: s_store_name, s_store_id
    ORDER BY: s_store_name, s_store_id, sun_sales, mon_sales, tue_sales, wed_sales, thu_sales, fri_sales, sat_sales

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**PATCH PLAN:**
```json
{
  "plan_id": "gold_duckdb_multi_dimension_prefetch",
  "dialect": "duckdb",
  "description": "Pre-filter multiple dimension tables (date + store) into separate CTEs before joining with fact table",
  "preconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "postconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "filtered_dates",
        "cte_query_sql": "SELECT d_date_sk, d_day_name FROM date_dim WHERE d_year = 2000"
      },
      "description": "Insert CTE 'filtered_dates' for date dimension filtering"
    },
    {
      "step_id": "s2",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "filtered_stores",
        "cte_query_sql": "SELECT s_store_sk, s_store_id, s_store_name FROM store WHERE s_gmt_offset = -5"
      },
      "description": "Insert CTE 'filtered_stores'"
    },
    {
      "step_id": "s3",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "filtered_sales",
        "cte_query_sql": "SELECT ss_sales_price, d_day_name, s_store_id, s_store_name FROM store_sales JOIN filtered_dates ON d_date_sk = ss_sold_date_sk JOIN filtered_stores ON s_store_sk = ss_store_sk"
      },
      "description": "Insert CTE 'filtered_sales' for date dimension filtering"
    },
    {
      "step_id": "s4",
      "op": "replace_from",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "from_sql": "filtered_sales"
      },
      "description": "Replace FROM clause with optimized version"
    },
    {
      "step_id": "s5",
      "op": "delete_expr_subtree",
      "target": {
        "by_node_id": "S0",
        "by_anchor_hash": "834e9c75d01a8fa3"
      },
      "description": "Remove WHERE clause (conditions moved to CTEs)"
    }
  ]
}
```



### Family F: Join Transform (Right Shape First)
**Description**: Restructure join topology: convert comma joins to explicit INNER JOIN, optimize join order, eliminate self-joins via single-pass aggregation
**Speedup Range**: 1.8–8.6x (~19% of all wins)
**Use When**:
  1. Comma-separated joins (implicit cross joins) in FROM clause
  2. Self-joins scanning same table multiple times
  3. Dimension-fact join order suboptimal for predicate pushdown

**Gold Example**: `inner_join_conversion` (3.44x)

**BEFORE (slow):**
```sql
select ss_customer_sk
            ,sum(act_sales) sumsales
      from (select ss_item_sk
                  ,ss_ticket_number
                  ,ss_customer_sk
                  ,case when sr_return_quantity is not null then (ss_quantity-sr_return_quantity)*ss_sales_price
                                                            else (ss_quantity*ss_sales_price) end act_sales
            from store_sales left outer join store_returns on (sr_item_sk = ss_item_sk
                                                               and sr_ticket_number = ss_ticket_number)
                ,reason
...
```

**AFTER (fast):**
```sql
WITH filtered_reason AS (SELECT r_reason_sk, r_reason_desc FROM reason WHERE r_reason_desc = 'duplicate purchase'), joined_returns_sales AS (SELECT ss.ss_customer_sk, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales ss INNER JOIN store_returns sr ON (ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number) INNER JOIN filtered_reason fr ON sr.sr_reason_sk = fr.r_reason_sk), aggregated AS (SELECT ss_customer_sk, SUM((ss_quantity - sr_return_quantity) * ss_sales_price) AS sumsales FROM joined_returns_sales GROUP BY ss_customer_sk), top_n AS (SELECT ss_customer_sk, sumsales FROM aggregated ORDER BY sumsales ASC, ss_customer_sk ASC LIMIT 100) SELECT ss_customer_sk, sumsales FROM top_n
```

**IR BEFORE:**
```
S0 [SELECT]
  MAIN QUERY (via Q_S0)
    FROM: (subquery) t
    GROUP BY: ss_customer_sk
    ORDER BY: sumsales, ss_customer_sk

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**IR TARGET:**
```
S0 [SELECT]
  CTE: filtered_reason  (via CTE_Q_S0_filtered_reason)
    FROM: reason
    WHERE [a7afe1b89848b69b]: r_reason_desc = 'duplicate purchase'
  CTE: joined_returns_sales  (via CTE_Q_S0_joined_returns_sales)
    FROM: store_sales ss, store_returns sr, filtered_reason fr
  CTE: aggregated  (via CTE_Q_S0_aggregated)
    FROM: joined_returns_sales
    GROUP BY: ss_customer_sk
  CTE: top_n  (via CTE_Q_S0_top_n)
    FROM: aggregated
    ORDER BY: sumsales, ss_customer_sk
  MAIN QUERY (via Q_S0)
    FROM: top_n

Patch operations: insert_cte, replace_expr_subtree, replace_where_predicate, replace_from, delete_expr_subtree
Target: by_node_id (statement, e.g. "S0") + by_anchor_hash (expression)
```

**PATCH PLAN:**
```json
{
  "plan_id": "gold_duckdb_inner_join_conversion",
  "dialect": "duckdb",
  "description": "Convert LEFT JOIN + right-table WHERE filter to INNER JOIN + early filter CTE when the WHERE eliminates NULL rows",
  "preconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "postconditions": [
    {
      "kind": "parse_ok"
    }
  ],
  "steps": [
    {
      "step_id": "s1",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "filtered_reason",
        "cte_query_sql": "SELECT r_reason_sk, r_reason_desc FROM reason WHERE r_reason_desc = 'duplicate purchase'"
      },
      "description": "Insert CTE 'filtered_reason'"
    },
    {
      "step_id": "s2",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "joined_returns_sales",
        "cte_query_sql": "SELECT ss.ss_customer_sk, ss.ss_quantity, ss.ss_sales_price, sr.sr_return_quantity FROM store_sales AS ss INNER JOIN store_returns AS sr ON (ss.ss_item_sk = sr.sr_item_sk AND ss.ss_ticket_number = sr.sr_ticket_number) INNER JOIN filtered_reason AS fr ON sr.sr_reason_sk = fr.r_reason_sk"
      },
      "description": "Insert CTE 'joined_returns_sales' for pre-filtered join"
    },
    {
      "step_id": "s3",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "aggregated",
        "cte_query_sql": "SELECT ss_customer_sk, SUM((ss_quantity - sr_return_quantity) * ss_sales_price) AS sumsales FROM joined_returns_sales GROUP BY ss_customer_sk"
      },
      "description": "Insert CTE 'aggregated' for pre-aggregated computation"
    },
    {
      "step_id": "s4",
      "op": "insert_cte",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "cte_name": "top_n",
        "cte_query_sql": "SELECT ss_customer_sk, sumsales FROM aggregated ORDER BY sumsales ASC, ss_customer_sk ASC LIMIT 100"
      },
      "description": "Insert CTE 'top_n'"
    },
    {
      "step_id": "s5",
      "op": "replace_body",
      "target": {
        "by_node_id": "S0"
      },
      "payload": {
        "sql_fragment": "SELECT ss_customer_sk, sumsales FROM top_n"
      },
      "description": "Replace main query body with optimized version"
    }
  ]
}
```



## Worker Routing

Your targets will be routed to specialized workers:
- **W1 "Reducer"** (Families A, D): Cardinality reduction — early filtering, set operations
- **W2 "Unnester"** (Families B, C): Decorrelation, aggregation pushdown
- **W3 "Builder"** (Families F, E): Join restructuring, materialization/prefetch
- **W4 "Wildcard"** (Dynamic): Deep specialist — your **#1 target** gets maximum effort

The highest-relevance target always goes to W4. Design diverse targets across worker roles for maximum coverage.


## Your Task

Analyze this query against the 6 families above.

Choose 1 to 4 families. Fewer strong targets beat padding with weak ones. For each chosen family:
1. Describe the bottleneck hypothesis
2. Design a TARGET IR node map showing what the optimized query SHOULD look like
3. Score relevance (0.0–1.0)
4. Recommend which gold example(s) a code-generation worker should use as reference


**Output format**:

```json
[
  {
    "family": "B",
    "transform": "shared_scan_decorrelate",
    "target_id": "t1",
    "relevance_score": 0.95,
    "hypothesis": "Correlated scalar subquery re-scans web_sales per row. Shared-scan variant: inner=outer table with same date filter.",
    "target_ir": "S0 [SELECT]\n  CTE: common_scan  (via Q1)\n    FROM: web_sales, date_dim\n    WHERE: d_date BETWEEN ... AND d_date_sk = ws_sold_date_sk\n  CTE: thresholds  (via Q2)\n    FROM: common_scan\n    GROUP BY: ws_item_sk\n  MAIN QUERY (via Q0)\n    FROM: common_scan cs, item, thresholds t\n    WHERE: i_manufact_id = 320 AND ... AND cs.ws_ext_discount_amt > t.threshold\n    ORDER BY: sum(ws_ext_discount_amt)",
    "recommended_examples": ["sf_shared_scan_decorrelate"]
  }
]
```

**Rules**:
- target_ir must follow the IR node map format (same as Section 4)
- target_ir describes the STRUCTURAL SHAPE of the optimized query (CTE names, FROM tables, WHERE conditions, GROUP BY, ORDER BY)
- recommended_examples: list gold example IDs the worker should use as reference patch template
- Each target should represent a DIFFERENT optimization strategy
- Rank by relevance_score (highest first)
- Output up to 4 targets

After JSON, provide analysis:

## Analysis
For each available family, explain relevance (HIGH / MEDIUM / LOW) in 1-2 sentences.
**Chosen families**: [list]
**Confidence**: High/Medium/Low
