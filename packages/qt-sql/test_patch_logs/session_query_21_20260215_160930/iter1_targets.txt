[
  {
    "target_id": "t3",
    "family": "C",
    "transform": "corrected_aggregation_pushdown",
    "relevance_score": 0.98,
    "hypothesis": "Aggregate inventory by date before joining dimensions. Correct column alignment from previous t1 failure by preserving keys. This reduces join input from 133M to ~14K groups (date_dim cardinality).",
    "target_ir": "S0 [SELECT]\n  CTE: inv_agg  (via CTE_Q_S0_inv_agg)\n    FROM: inventory\n    JOIN: date_dim ON inv_date_sk=d_date_sk\n    WHERE: d_date BETWEEN '2002-01-28' AND '2002-03-29'\n    GROUP_BY: inv_item_sk, inv_warehouse_sk\n    AGGREGATES: \n      SUM(CASE WHEN d_date<'2002-02-27' THEN inv_quantity_on_hand ELSE 0 END) AS inv_before,\n      SUM(CASE WHEN d_date>='2002-02-27' THEN inv_quantity_on_hand ELSE 0 END) AS inv_after\n  MAIN_QUERY (via Q_S0)\n    JOIN: item ON i_item_sk=inv_item_sk\n    JOIN: warehouse ON w_warehouse_sk=inv_warehouse_sk\n    WHERE: i_current_price BETWEEN 0.99 AND 1.49\n      AND (CASE WHEN inv_before>0 THEN inv_after::DOUBLE/inv_before::DOUBLE ELSE NULL END) BETWEEN 0.666... AND 1.5\n    ORDER_BY: w_warehouse_name, i_item_id\n    LIMIT: 100",
    "recommended_examples": [
      "aggregate_pushdown"
    ]
  },
  {
    "target_id": "t4",
    "family": "C+A",
    "transform": "preaggregate_with_filter_propagation",
    "relevance_score": 0.92,
    "hypothesis": "Push item price filter into pre-aggregation CTE. Since item_sk is preserved, we can apply dimension filters before the final lightweight join.",
    "target_ir": "S0 [SELECT]\n  CTE: item_filtered  (via CTE_Q_S0_item_filtered)\n    FROM: item\n    WHERE: i_current_price BETWEEN 0.99 AND 1.49\n  CTE: inv_agg  (via CTE_Q_S0_inv_agg)\n    FROM: inventory\n    JOIN: date_dim ON inv_date_sk=d_date_sk\n    JOIN: item_filtered ON inv_item_sk=i_item_sk\n    WHERE: d_date BETWEEN '2002-01-28' AND '2002-03-29'\n    GROUP_BY: inv_warehouse_sk\n    AGGREGATES: inv_before, inv_after\n  MAIN_QUERY (via Q_S0)\n    JOIN: warehouse ON w_warehouse_sk=inv_warehouse_sk\n    WHERE: (ratio condition)\n    ORDER_BY: w_warehouse_name, i_item_id\n    LIMIT: 100",
    "recommended_examples": [
      "aggregate_pushdown",
      "dimension_prefilter"
    ]
  },
  {
    "target_id": "t5",
    "family": "F",
    "transform": "explicit_join_order",
    "relevance_score": 0.85,
    "hypothesis": "Convert implicit joins to explicit INNER JOIN ordering warehouse first. Leverages DuckDB's join ordering with small dimension (10 rows) as build side.",
    "target_ir": "S0 [SELECT]\n  MAIN_QUERY (via Q_S0)\n    FROM: warehouse\n    JOIN: inventory ON inv_warehouse_sk=w_warehouse_sk\n    JOIN: date_dim ON inv_date_sk=d_date_sk\n    JOIN: item ON inv_item_sk=i_item_sk\n    WHERE: (original conditions)\n    GROUP_BY: w_warehouse_name, i_item_id\n    HAVING: (ratio condition)\n    ORDER_BY: w_warehouse_name, i_item_id\n    LIMIT: 100",
    "recommended_examples": [
      "inner_join_conversion"
    ]
  },
  {
    "target_id": "t6",
    "family": "C+E",
    "transform": "materialized_date_aggregation",
    "relevance_score": 0.8,
    "hypothesis": "Materialize date-filtered inventory aggregates first, then join dimensions. Avoids recomputing aggregates during dimension joins.",
    "target_ir": "S0 [SELECT]\n  CTE: date_inv  (via CTE_Q_S0_date_inv)\n    FROM: inventory\n    JOIN: date_dim ON inv_date_sk=d_date_sk\n    WHERE: d_date BETWEEN '2002-01-28' AND '2002-03-29'\n  CTE: inv_agg  (via CTE_Q_S0_inv_agg)\n    FROM: date_inv\n    GROUP_BY: inv_item_sk, inv_warehouse_sk\n    AGGREGATES: inv_before, inv_after\n  MAIN_QUERY (via Q_S0)\n    JOIN: item ON i_item_sk=inv_item_sk\n    JOIN: warehouse ON w_warehouse_sk=inv_warehouse_sk\n    WHERE: (conditions)\n    ORDER_LIMIT",
    "recommended_examples": [
      "aggregate_pushdown",
      "multi_dimension_prefetch"
    ]
  }
]