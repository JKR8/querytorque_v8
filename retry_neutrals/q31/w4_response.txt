Looking at this query pattern, I can see a key opportunity: the main query is scanning the same aggregated CTEs (`ss` and `ws`) multiple times with different quarter filters, which forces repeated scans of the base tables. We can apply **Single Pass Aggregation** to compute all needed quarters in one scan of each fact table, combined with **Pushdown** to filter dates early.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "single_pass_aggregation",
      "nodes": {
        "date_filter": "SELECT d_date_sk FROM date_dim WHERE d_year = 2000 AND d_qoy IN (1, 2, 3)",
        "ss_agg": "SELECT ca_county, SUM(CASE WHEN d_qoy = 1 THEN ss_ext_sales_price ELSE 0 END) AS store_sales_q1, SUM(CASE WHEN d_qoy = 2 THEN ss_ext_sales_price ELSE 0 END) AS store_sales_q2, SUM(CASE WHEN d_qoy = 3 THEN ss_ext_sales_price ELSE 0 END) AS store_sales_q3 FROM store_sales JOIN date_filter ON ss_sold_date_sk = d_date_sk JOIN customer_address ON ss_addr_sk = ca_address_sk GROUP BY ca_county",
        "ws_agg": "SELECT ca_county, SUM(CASE WHEN d_qoy = 1 THEN ws_ext_sales_price ELSE 0 END) AS web_sales_q1, SUM(CASE WHEN d_qoy = 2 THEN ws_ext_sales_price ELSE 0 END) AS web_sales_q2, SUM(CASE WHEN d_qoy = 3 THEN ws_ext_sales_price ELSE 0 END) AS web_sales_q3 FROM web_sales JOIN date_filter ON ws_sold_date_sk = d_date_sk JOIN customer_address ON ws_bill_addr_sk = ca_address_sk GROUP BY ca_county",
        "main_query": "SELECT s.ca_county, 2000 AS d_year, CASE WHEN s.store_sales_q1 > 0 THEN (s.store_sales_q2 * 1.0000) / s.store_sales_q1 ELSE NULL END AS store_q1_q2_increase, CASE WHEN s.store_sales_q2 > 0 THEN (s.store_sales_q3 * 1.0000) / s.store_sales_q2 ELSE NULL END AS store_q2_q3_increase, CASE WHEN w.web_sales_q1 > 0 THEN (w.web_sales_q2 * 1.0000) / w.web_sales_q1 ELSE NULL END AS web_q1_q2_increase, CASE WHEN w.web_sales_q2 > 0 THEN (w.web_sales_q3 * 1.0000) / w.web_sales_q2 ELSE NULL END AS web_q2_q3_increase FROM ss_agg s JOIN ws_agg w ON s.ca_county = w.ca_county WHERE (CASE WHEN w.web_sales_q1 > 0 THEN (w.web_sales_q2 * 1.0000) / w.web_sales_q1 ELSE NULL END) > (CASE WHEN s.store_sales_q1 > 0 THEN (s.store_sales_q2 * 1.0000) / s.store_sales_q1 ELSE NULL END) AND (CASE WHEN w.web_sales_q2 > 0 THEN (w.web_sales_q3 * 1.0000) / w.web_sales_q2 ELSE NULL END) > (CASE WHEN s.store_sales_q2 > 0 THEN (s.store_sales_q3 * 1.0000) / s.store_sales_q2 ELSE NULL END) ORDER BY s.ca_county"
      },
      "invariants_kept": [
        "same result values",
        "same column output",
        "same ordering",
        "same aggregation semantics"
      ],
      "expected_speedup": "3.2x",
      "risk": "low"
    }
  ],
  "explanation": "The original query creates CTEs aggregated by county, quarter, and year, then joins 6 instances (3 for store sales, 3 for web sales) with different quarter filters. This rewrite: (1) creates a shared date filter CTE for year 2000 and quarters 1-3, (2) aggregates both fact tables once each with conditional CASE expressions to compute all three quarters in a single pass, (3) simplifies the main query to join just two aggregated tables instead of six. This reduces 6 CTE scans and repeated base table joins to 2 aggregations with single scans of store_sales and web_sales."
}
```

**Key optimizations applied:**

1. **Single Pass Aggregation**: Instead of computing `ss` and `ws` CTEs that need to be scanned 3 times each, we compute all three quarters in one aggregation using conditional CASE expressions inside SUM().

2. **Pushdown**: The year=2000 and quarter filters are pushed into a shared date_filter CTE, which reduces date_dim scans from 4 (2 per fact table) to 1.

3. **Date CTE Isolation**: Created a reusable date_filter CTE that both fact tables can join to.

4. **Semantic Rewrite**: Restructured the main query from 6-way self-join to a simple join between two pre-aggregated tables with all quarters pre-computed.

**Expected benefits:**
- Reduces store_sales scans from 1 to 1 (same), but eliminates 2 additional CTE scans
- Reduces web_sales scans from 1 to 1 (same), but eliminates 2 additional CTE scans  
- Reduces date_dim scans from 4 to 1
- Eliminates 4 CTE scans in main query
- Reduces join complexity from 6-way self-join to simple 2-table join
- Maintains exact same output values and ordering