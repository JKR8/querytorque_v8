```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_year FROM date_dim WHERE d_moy = 11",
        "filtered_items": "SELECT i_item_sk, i_brand_id, i_brand FROM item WHERE i_manufact_id = 128",
        "joined_sales": "SELECT ss_ext_sales_price, ss_sold_date_sk, ss_item_sk FROM store_sales",
        "filtered_sales": "SELECT fd.d_year, fi.i_brand_id, fi.i_brand, js.ss_ext_sales_price FROM joined_sales js JOIN filtered_dates fd ON js.ss_sold_date_sk = fd.d_date_sk JOIN filtered_items fi ON js.ss_item_sk = fi.i_item_sk",
        "main_query": "SELECT d_year, i_brand_id AS brand_id, i_brand AS brand, SUM(ss_ext_sales_price) AS sum_agg FROM filtered_sales GROUP BY d_year, i_brand, i_brand_id ORDER BY d_year, sum_agg DESC, brand_id LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same grouping and aggregation"
      ],
      "expected_speedup": "3.5x",
      "risk": "low"
    }
  ],
  "explanation": "The original query performs sequential scans on all three tables without early filtering. By creating filtered CTEs for date_dim (with d_moy=11) and item (with i_manufact_id=128), we reduce the dimension tables to 6,000 and 180 rows respectively before joining. This allows the fact table (store_sales) to be filtered early through joins with small dimension CTEs, significantly reducing the number of rows processed in the aggregation. The transform follows the Date CTE Isolation pattern verified with 4.00x speedup in similar scenarios."
}
```