```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "materialize_cte",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2000-01-27' AND CAST('2000-04-26' AS DATE)",
        "item_avg_discounts": "SELECT ws_item_sk, 1.3 * AVG(ws_ext_discount_amt) AS threshold_discount FROM web_sales JOIN filtered_dates ON d_date_sk = ws_sold_date_sk GROUP BY ws_item_sk",
        "main_query": "SELECT SUM(ws_ext_discount_amt) AS \"Excess Discount Amount\" FROM web_sales JOIN filtered_dates ON d_date_sk = ws_sold_date_sk JOIN item ON i_item_sk = ws_item_sk JOIN item_avg_discounts iad ON web_sales.ws_item_sk = iad.ws_item_sk WHERE i_manufact_id = 350 AND ws_ext_discount_amt > iad.threshold_discount ORDER BY SUM(ws_ext_discount_amt) LIMIT 100"
      },
      "invariants_kept": [
        "same result rows", 
        "same aggregation",
        "same ordering"
      ],
      "expected_speedup": "3.5x",
      "risk": "low"
    }
  ],
  "explanation": "Two key optimizations applied: (1) Extracted date filter into CTE to isolate date_dim scan and enable early filtering before joins. (2) Materialized the correlated subquery into a CTE that precomputes 1.3*average discount for each item in the date range. This eliminates repeated execution of correlated subquery per row and allows hash join instead of nested loop evaluation. The original query scanned web_sales twice (once for main query, once per correlated subquery evaluation), now scans once for CTE and once for main join."
}
```