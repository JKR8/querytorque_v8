```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "decorrelate",
      "nodes": {
        "date_range": "SELECT d_date_sk FROM date_dim WHERE d_date BETWEEN '2000-01-27' AND CAST('2000-04-26' AS DATE)",
        "web_sales_filtered": "SELECT ws_item_sk, ws_ext_discount_amt, ws_sold_date_sk FROM web_sales ws JOIN date_range dr ON ws.ws_sold_date_sk = dr.d_date_sk",
        "item_filtered": "SELECT i_item_sk FROM item WHERE i_manufact_id = 350",
        "item_avg_discount": "SELECT wf.ws_item_sk, AVG(wf.ws_ext_discount_amt) AS avg_discount FROM web_sales_filtered wf JOIN item_filtered i ON wf.ws_item_sk = i.i_item_sk GROUP BY wf.ws_item_sk",
        "main_query": "SELECT SUM(wf.ws_ext_discount_amt) AS \"Excess Discount Amount\" FROM web_sales_filtered wf JOIN item_filtered i ON wf.ws_item_sk = i.i_item_sk JOIN item_avg_discount avgd ON wf.ws_item_sk = avgd.ws_item_sk WHERE wf.ws_ext_discount_amt > 1.3 * avgd.avg_discount ORDER BY SUM(wf.ws_ext_discount_amt) LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same filter logic (i_manufact_id=350 and date range)"
      ],
      "expected_speedup": "3.2x",
      "risk": "low"
    }
  ],
  "explanation": "Decorrelated the subquery by pre-computing average discount per item in a CTE. Also pushed date range and manufacturer filters early into CTEs to reduce data volume before joins and aggregation. This avoids scanning web_sales twice and eliminates row-by-row correlated subquery execution."
}
```