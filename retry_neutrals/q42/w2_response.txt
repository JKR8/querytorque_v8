```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates": "SELECT d_date_sk, d_year FROM date_dim WHERE d_moy = 11 AND d_year = 2000",
        "filtered_items": "SELECT i_item_sk, i_category_id, i_category FROM item WHERE i_manager_id = 1",
        "joined_sales": "SELECT ss.ss_ext_sales_price, fd.d_year, fi.i_category_id, fi.i_category FROM store_sales ss JOIN filtered_dates fd ON ss.ss_sold_date_sk = fd.d_date_sk JOIN filtered_items fi ON ss.ss_item_sk = fi.i_item_sk",
        "main_query": "SELECT d_year, i_category_id, i_category, SUM(ss_ext_sales_price) FROM joined_sales GROUP BY d_year, i_category_id, i_category ORDER BY SUM(ss_ext_sales_price) DESC, d_year, i_category_id, i_category LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same ordering",
        "same column output",
        "same grouping and aggregation"
      ],
      "expected_speedup": "3.0x",
      "risk": "low"
    }
  ],
  "explanation": "Created separate CTEs for filtered date_dim and item tables to reduce the cardinality before joining with the large store_sales fact table. This allows early filtering of dimension tables (date_dim reduces from 73K→30 rows, item from 102K→1.8K rows) before joining with store_sales (345M rows), significantly reducing the hash join cost. The transformed query scans each dimension once with filters, then joins the filtered results with the fact table, eliminating the need to scan the full store_sales table before applying dimension filters."
}
```