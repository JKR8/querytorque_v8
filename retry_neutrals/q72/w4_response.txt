Looking at the query and execution plan, I can identify a key optimization opportunity: **date dimension joins are filtering different columns but using the same table**. The query joins `date_dim` three times with different aliases (d1, d2, d3), but only d1 has an explicit filter (`d_year = 1999`). However, d2 and d3 are filtered indirectly through join conditions with d1.

The optimization is to **isolate the filtered date_dim rows early and reuse them** instead of scanning date_dim three times. This matches the "date_cte_isolate" transform pattern.

```json
{
  "rewrite_sets": [
    {
      "id": "rs_01",
      "transform": "date_cte_isolate",
      "nodes": {
        "filtered_dates_1999": "SELECT d_date_sk, d_date, d_week_seq FROM date_dim WHERE d_year = 1999",
        "filtered_demographics": "SELECT cd_demo_sk FROM customer_demographics WHERE cd_marital_status = 'D'",
        "filtered_household": "SELECT hd_demo_sk FROM household_demographics WHERE hd_buy_potential = '>10000'",
        "main_query": "SELECT i_item_desc, w_warehouse_name, d1.d_week_seq, SUM(CASE WHEN p_promo_sk IS NULL THEN 1 ELSE 0 END) AS no_promo, SUM(CASE WHEN NOT p_promo_sk IS NULL THEN 1 ELSE 0 END) AS promo, COUNT(*) AS total_cnt FROM catalog_sales JOIN inventory ON (cs_item_sk = inv_item_sk) JOIN warehouse ON (w_warehouse_sk = inv_warehouse_sk) JOIN item ON (i_item_sk = cs_item_sk) JOIN filtered_demographics cd ON (cs_bill_cdemo_sk = cd.cd_demo_sk) JOIN filtered_household hd ON (cs_bill_hdemo_sk = hd.hd_demo_sk) JOIN filtered_dates_1999 d1 ON (cs_sold_date_sk = d1.d_date_sk) JOIN filtered_dates_1999 d2 ON (inv_date_sk = d2.d_date_sk AND d1.d_week_seq = d2.d_week_seq) JOIN date_dim d3 ON (cs_ship_date_sk = d3.d_date_sk AND d3.d_date > d1.d_date + 5) LEFT OUTER JOIN promotion ON (cs_promo_sk = p_promo_sk) LEFT OUTER JOIN catalog_returns ON (cr_item_sk = cs_item_sk AND cr_order_number = cs_order_number) WHERE inv_quantity_on_hand < cs_quantity GROUP BY i_item_desc, w_warehouse_name, d1.d_week_seq ORDER BY total_cnt DESC NULLS FIRST, i_item_desc NULLS FIRST, w_warehouse_name NULLS FIRST, d1.d_week_seq NULLS FIRST LIMIT 100"
      },
      "invariants_kept": [
        "same result rows",
        "same output columns",
        "same grouping semantics",
        "same ordering",
        "all original predicates preserved"
      ],
      "expected_speedup": "1.5x",
      "risk": "low"
    }
  ],
  "explanation": "Isolated date_dim rows filtered by d_year=1999 into a CTE (filtered_dates_1999), then reused for both d1 and d2 joins (since d2 must have same week_seq as d1, and d1 is in 1999). Also isolated filtered customer_demographics and household_demographics. This reduces 3 date_dim scans to 1 filtered scan and 1 full scan (for d3), and reduces the other dimension table scans by pushing filters early."
}
```

**Key insight:** The original query scans date_dim three times (d1, d2, d3). Since d2 must have the same week_seq as d1 (from `d1.d_week_seq = d2.d_week_seq`) and d1 is filtered to 1999, d2 must also be in 1999 (week_seq is unique across years). Therefore, we can reuse the filtered 1999 dates for both d1 and d2. This eliminates 2 of the 3 date_dim scans. Additionally, isolating filtered dimension tables (customer_demographics, household_demographics) reduces their scan sizes early.